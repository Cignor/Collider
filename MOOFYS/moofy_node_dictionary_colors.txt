================================================================================
CONTEXT BUNDLE: Node Dictionary Color-Coded Sections Implementation
================================================================================
Generated: 2025-11-14 09:38:37
Purpose: Plan and implement color-coded background sections for node documentation

================================================================================
REQUIREMENT
================================================================================

USER REQUEST:
Divide node documentation by colors for each explanation section. There's a common
structure to definitions:
1. Description (always different but always first)
2. Inputs (if any)
3. Outputs
4. Parameters
5. How to Use

Each section should have a background color that is:
- Consistent with the Theme Manager
- Matches the actual colors used in the software
- Allows users to quickly understand the structure at a glance

================================================================================
CURRENT STRUCTURE
================================================================================

MARKDOWN STRUCTURE:
- Level 2 (###) = Node name (e.g., "### noise")
- Level 3 (####) = Section headers (e.g., "#### Inputs:", "#### Outputs:")
- Content follows each header

EXAMPLE NODE ENTRY:
### noise
**Noise Generator**

Generates white, pink, or brown noise for percussion, ambience, or modulation.

**Inputs:**
- Level Mod (CV) - Level modulation input
- Colour Mod (CV) - Noise color modulation

**Outputs:**
- Out L (Audio) - Left channel output
- Out R (Audio) - Right channel output

**Parameters:**
- Colour (Choice) - White, Pink, or Brown
- Level dB (-60 to +6 dB) - Output level

**How to Use:**
1. Select the noise color
2. Adjust the level to taste
...

================================================================================
CURRENT RENDERING
================================================================================


================================================================================
FILE: juce/Source/preset_creator/HelpManagerComponent.h
================================================================================

#pragma once

#include <juce_core/juce_core.h>
#include <imgui.h>
#include "ShortcutManager.h" // We need this for the capture state and manager reference

// Forward declaration
class ImGuiNodeEditorComponent;

/**
 * @class HelpManagerComponent
 * Manages the non-modal, tabbed Help window.
 *
 * This component consolidates:
 * 1. Shortcut Editor (migrated from ImGuiNodeEditorComponent)
 * 2. Node Dictionary (Markdown renderer)
 * 3. Getting Started (Markdown renderer)
 * 4. About Page
 *
 * It follows the same self-contained window pattern as ThemeEditorComponent.
 */
class HelpManagerComponent
{
public:
    HelpManagerComponent(ImGuiNodeEditorComponent* parent);
    ~HelpManagerComponent() = default;

    // === Public API ===
    void render();
    void open();
    void close();
    bool isOpen() const { return m_isOpen; }

    /**
     * @brief Sets the currently active tab by its index.
     * 0 = Shortcuts, 1 = Node Dictionary, 2 = Getting Started, 3 = FAQ, 4 = About
     * This is used by external triggers (like F1 or context menus) to
     * open the manager to a specific tab.
     * @param tabIndex The index of the tab to select.
     */
    void setActiveTab(int tabIndex) 
    { 
        m_currentTab = tabIndex; 
        m_shouldSetTab = true; // Flag that we want to programmatically set this tab
    }
    
    /**
     * @brief Opens the Help Manager to the Node Dictionary tab and scrolls to a specific node.
     * @param nodeAnchor The anchor of the node to scroll to (e.g., "vco", "track-mixer").
     *                   The anchor should match the format used in the markdown file.
     */
    void openToNode(const juce::String& nodeAnchor);

private:
    // === Window State ===
    bool m_isOpen = false;
    int m_currentTab = 0; // 0:Shortcuts, 1:Dictionary, 2:GettingStarted, 3:FAQ, 4:About
    bool m_shouldSetTab = false; // Flag to programmatically set tab (e.g., from F1)
    ImGuiNodeEditorComponent* parentEditor = nullptr;
    collider::ShortcutManager& shortcutManager;

    // === Tab Rendering Functions ===
    void renderShortcutsTab();
    void renderNodeDictionaryTab();
    void renderGettingStartedTab();
    void renderFaqTab();
    void renderAboutTab();

    // === Markdown Parsing & Rendering (for Node Dictionary and Getting Started) ===
    struct MarkdownSection
    {
        juce::String title;
        int level; // 1 = ##, 2 = ###, 3 = ####
        juce::String content; // Text content before subsections
        std::vector<MarkdownSection> children;
        juce::String anchor; // For anchor links (e.g., #vco)
        
        // Helper to check if this section or any child matches search
        bool matchesSearch(const juce::String& searchTerm) const;
        
        // Helper to check if this section or any child contains the given anchor
        bool containsAnchor(const juce::String& targetAnchor) const;
    };

    // Node Dictionary state
    juce::String nodeDictionarySearchTerm;
    std::vector<MarkdownSection> nodeDictionarySections;
    bool nodeDictionaryLoaded = false;
    juce::File nodeDictionaryFile;

    // Getting Started state
    juce::String gettingStartedSearchTerm;
    std::vector<MarkdownSection> gettingStartedSections;
    bool gettingStartedLoaded = false;
    juce::File gettingStartedFile;

    // FAQ state
    juce::String faqSearchTerm;
    std::vector<MarkdownSection> faqSections;
    bool faqLoaded = false;
    juce::File faqFile;

    // Markdown parsing functions
    void loadNodeDictionary();
    void loadGettingStarted();
    void loadFaq();
    void parseMarkdown(const juce::String& content, std::vector<MarkdownSection>& sections);
    void renderMarkdownSection(const MarkdownSection& section, const juce::String& searchTerm, bool parentMatches = true, bool forceExpand = false);
    void renderMarkdownText(const juce::String& text);
    void renderFormattedText(const juce::String& text); // Renders text with inline formatting (bold, code)
    juce::String extractAnchor(const juce::String& headerLine);
    
    // Helper to get category color from section title
    ImU32 getCategoryColorForSection(const juce::String& sectionTitle) const;
    
    // Helper to scroll to anchor (stores anchor to scroll to)
    juce::String scrollToAnchor;
    bool scrollToSectionIfNeeded(const juce::String& anchor);
    
    // Split-pane navigation state
    struct NavigationItem
    {
        juce::String title;
        juce::String anchor;
        int level; // Indentation level
        bool isCategory; // True for category headers (like "SOURCE NODES")
    };
    std::vector<NavigationItem> nodeDictionaryNavItems; // Flattened navigation list
    void buildNavigationList(const std::vector<MarkdownSection>& sections, std::vector<NavigationItem>& navItems, int level = 0);
    void renderNavigationSidebar(const std::vector<NavigationItem>& navItems, const juce::String& searchTerm);
    void renderNodeDictionaryContent(const std::vector<MarkdownSection>& sections, const juce::String& searchTerm);
    std::unordered_map<juce::String, float> sectionScrollPositions; // Anchor -> scroll position
    float findSectionScrollPosition(const juce::String& anchor, const std::vector<MarkdownSection>& sections, float currentPos = 0.0f);

    // === START: State Migrated from ImGuiNodeEditorComponent ===
    // This state is moving here to make the Help Manager self-contained.
    juce::String shortcutsSearchTerm;
    juce::Identifier shortcutContextSelection;
    bool shortcutsDirty { false };
    juce::File defaultShortcutFile;
    juce::File userShortcutFile;

    // Struct for shortcut capture state
    struct ShortcutCaptureState
    {
        bool isCapturing { false };
        juce::Identifier actionId;
        juce::Identifier context;
        collider::KeyChord captured;
        bool hasCaptured { false };
        juce::Identifier conflictActionId;
        juce::Identifier conflictContextId;
        bool conflictIsUserBinding { false };
    };

    ShortcutCaptureState shortcutCaptureState;

    // Helper functions for the shortcut editor
    void renderShortcutEditorTable(const juce::Identifier& context);
    void renderShortcutRow(const collider::ShortcutAction& action,
                           const juce::Identifier& actionId,
                           const juce::Identifier& context,
                           bool categoryChanged);
    void renderShortcutCapturePanel();
    void beginShortcutCapture(const juce::Identifier& actionId, const juce::Identifier& context);
    void updateShortcutCapture();
    void cancelShortcutCapture();
    void applyShortcutCapture(bool forceReplace);
    void evaluateShortcutCaptureConflict();
    void clearShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context);
    void resetShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context);
    void saveUserShortcutBindings();
    juce::String getBindingLabelForContext(const juce::Identifier& actionId,
                                           const juce::Identifier& context,
                                           juce::String& sourceLabel) const;
    // === END: State Migrated from ImGuiNodeEditorComponent ===
};




================================================================================
FILE: juce/Source/preset_creator/HelpManagerComponent.cpp
================================================================================

#include "HelpManagerComponent.h"

#include "ImGuiNodeEditorComponent.h" // Required for parentEditor
#include "theme/ThemeManager.h"      // For themed colors (includes Theme.h with ModuleCategory)
#include "PresetCreatorApplication.h"  // For app properties
#include "NotificationManager.h"     // For notification posting
#include <juce_gui_basics/juce_gui_basics.h>
#include <imgui_internal.h> // For IsKeyPressed
#include <vector>
#include <unordered_map>
#include <functional>
#include <algorithm>

// Helper copied from ImGuiNodeEditorComponent.cpp
namespace
{
    [[nodiscard]] juce::String contextDisplayName(const juce::Identifier& contextId)
    {
        if (contextId == collider::ShortcutManager::getGlobalContextIdentifier())
            return "Global";
        if (contextId == ImGuiNodeEditorComponent::nodeEditorContextId)
            return "Node Editor";
        return contextId.toString();
    }

    [[nodiscard]] bool chordsEqual(const collider::KeyChord& a, const collider::KeyChord& b) noexcept
    {
        return a.key == b.key && a.ctrl == b.ctrl && a.shift == b.shift &&
               a.alt == b.alt && a.superKey == b.superKey;
    }
}

HelpManagerComponent::HelpManagerComponent(ImGuiNodeEditorComponent* parent)
    : parentEditor(parent),
      shortcutManager(collider::ShortcutManager::getInstance()),
      shortcutContextSelection(ImGuiNodeEditorComponent::nodeEditorContextId)
{
    // === LOGIC MOVED FROM ImGuiNodeEditorComponent CONSTRUCTOR ===
    // This logic now lives here, making the Help Manager responsible
    // for finding and loading its own shortcut files.
    auto executable = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
    auto exeDir = executable.getParentDirectory();
    auto assetsDir = exeDir.getChildFile("assets");
    defaultShortcutFile = assetsDir.getChildFile("default_shortcuts.json");
    if (defaultShortcutFile.existsAsFile())
        shortcutManager.loadDefaultBindingsFromFile(defaultShortcutFile);
    else
        juce::Logger::writeToLog("[HelpManager] WARNING: Default shortcuts file not found at: " + defaultShortcutFile.getFullPathName());

    juce::File userSettingsDir;
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
        userSettingsDir = props->getFile().getParentDirectory();
    else
        userSettingsDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory).getChildFile("Collider");

    if (!userSettingsDir.isDirectory())
        userSettingsDir.createDirectory();

    userShortcutFile = userSettingsDir.getChildFile("user_shortcuts.json");
    shortcutManager.loadUserBindingsFromFile(userShortcutFile);
    
    // Initialize documentation file paths
    // Try multiple locations: next to executable, or in project root
    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
    auto appDir = appFile.getParentDirectory();
    auto userManualDir = appDir.getChildFile("USER_MANUAL");
    
    nodeDictionaryFile = userManualDir.getChildFile("Nodes_Dictionary.md");
    gettingStartedFile = userManualDir.getChildFile("Getting_Started.md");
    faqFile = userManualDir.getChildFile("FAQ.md");
    
    // Fallback: try project root (for development)
    auto projectRoot = appDir.getParentDirectory(); // Go up one level from executable
    auto fallbackUserManualDir = projectRoot.getChildFile("USER_MANUAL");
    
    if (!nodeDictionaryFile.existsAsFile())
    {
        auto fallbackFile = fallbackUserManualDir.getChildFile("Nodes_Dictionary.md");
        if (fallbackFile.existsAsFile())
            nodeDictionaryFile = fallbackFile;
    }
    
    if (!gettingStartedFile.existsAsFile())
    {
        auto fallbackFile = fallbackUserManualDir.getChildFile("Getting_Started.md");
        if (fallbackFile.existsAsFile())
            gettingStartedFile = fallbackFile;
    }
    
    if (!faqFile.existsAsFile())
    {
        auto fallbackFile = fallbackUserManualDir.getChildFile("FAQ.md");
        if (fallbackFile.existsAsFile())
            faqFile = fallbackFile;
    }
    
    juce::Logger::writeToLog("[HelpManager] Initialized and loaded shortcut files.");
    // === END OF MOVED LOGIC ===
}

void HelpManagerComponent::open()
{
    m_isOpen = true;
}

void HelpManagerComponent::close()
{
    // On close, save any dirty shortcuts
    if (shortcutsDirty)
    {
        saveUserShortcutBindings();
    }
    
    // Cancel any pending capture
    if (shortcutCaptureState.isCapturing)
    {
        cancelShortcutCapture();
    }
    
    m_isOpen = false;
}

void HelpManagerComponent::openToNode(const juce::String& nodeAnchor)
{
    // Open the Help Manager
    open();
    
    // Set to Node Dictionary tab (index 1)
    setActiveTab(1);
    
    // Set the scroll target anchor
    // Convert module type format (e.g., "track_mixer") to anchor format (e.g., "track-mixer")
    juce::String anchor = nodeAnchor.toLowerCase();
    anchor = anchor.replace("_", "-");
    scrollToAnchor = anchor;
    
    // Ensure the dictionary is loaded
    if (!nodeDictionaryLoaded)
    {
        loadNodeDictionary();
        if (!nodeDictionarySections.empty())
        {
            buildNavigationList(nodeDictionarySections, nodeDictionaryNavItems);
        }
    }
}

void HelpManagerComponent::render()
{
    if (!m_isOpen)
        return;

    // Set default window size
    ImGui::SetNextWindowSize(ImVec2(900, 700), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);
    
    // Ensure window is fully opaque (uses WindowBg from theme)
    ImGui::SetNextWindowBgAlpha(1.0f);
    if (ImGui::Begin("Help Manager", &m_isOpen, ImGuiWindowFlags_None))
    {
        if (ImGui::BeginTabBar("HelpTabs"))
        {
            // --- Tab 1: Shortcuts ---
            bool selectShortcuts = m_shouldSetTab && m_currentTab == 0;
            if (ImGui::BeginTabItem("Shortcuts", nullptr, (selectShortcuts ? ImGuiTabItemFlags_SetSelected : 0)))
            {
                // Only update state on user click (not on default selection)
                if (ImGui::IsItemClicked())
                {
                    m_currentTab = 0;
                    m_shouldSetTab = false; // User click overrides programmatic set
                }
                
                // Acknowledge programmatic set only if this was the target
                if (selectShortcuts)
                    m_shouldSetTab = false;
                
                renderShortcutsTab();
                ImGui::EndTabItem();
            }

            // --- Tab 2: Node Dictionary ---
            bool selectDictionary = m_shouldSetTab && m_currentTab == 1;
            if (ImGui::BeginTabItem("Node Dictionary", nullptr, (selectDictionary ? ImGuiTabItemFlags_SetSelected : 0)))
            {
                // Only update state on user click (not on programmatic selection)
                if (ImGui::IsItemClicked())
                {
                    m_currentTab = 1;
                    m_shouldSetTab = false; // User click overrides programmatic set
                }
                
                // Acknowledge programmatic set only if this was the target
                if (selectDictionary)
                    m_shouldSetTab = false;
                
                renderNodeDictionaryTab();
                ImGui::EndTabItem();
            }

            // --- Tab 3: Getting Started ---
            bool selectGettingStarted = m_shouldSetTab && m_currentTab == 2;
            if (ImGui::BeginTabItem("Getting Started", nullptr, (selectGettingStarted ? ImGuiTabItemFlags_SetSelected : 0)))
            {
                // Only update state on user click
                if (ImGui::IsItemClicked())
                {
                    m_currentTab = 2;
                    m_shouldSetTab = false;
                }
                
                if (selectGettingStarted)
                    m_shouldSetTab = false;
                
                renderGettingStartedTab();
                ImGui::EndTabItem();
            }

            // --- Tab 4: FAQ ---
            bool selectFaq = m_shouldSetTab && m_currentTab == 3;
            if (ImGui::BeginTabItem("FAQ", nullptr, (selectFaq ? ImGuiTabItemFlags_SetSelected : 0)))
            {
                // Only update state on user click
                if (ImGui::IsItemClicked())
                {
                    m_currentTab = 3;
                    m_shouldSetTab = false;
                }
                
                if (selectFaq)
                    m_shouldSetTab = false;
                
                renderFaqTab();
                ImGui::EndTabItem();
            }

            // --- Tab 5: About ---
            bool selectAbout = m_shouldSetTab && m_currentTab == 4;
            if (ImGui::BeginTabItem("About", nullptr, (selectAbout ? ImGuiTabItemFlags_SetSelected : 0)))
            {
                // Only update state on user click
                if (ImGui::IsItemClicked())
                {
                    m_currentTab = 4;
                    m_shouldSetTab = false;
                }
                
                if (selectAbout)
                    m_shouldSetTab = false;
                
                renderAboutTab();
                ImGui::EndTabItem();
            }

            ImGui::EndTabBar();
        }
    }
    ImGui::End();

    // If window "X" was clicked, handle shutdown
    if (!m_isOpen)
    {
        close();
    }
}

// === STUBBED TABS (To be implemented in later phases) ===

void HelpManagerComponent::renderNodeDictionaryTab()
{
    // Lazy load the markdown file on first open
    if (!nodeDictionaryLoaded)
    {
        loadNodeDictionary();
        // Build navigation list after loading
        if (!nodeDictionarySections.empty())
        {
            buildNavigationList(nodeDictionarySections, nodeDictionaryNavItems);
        }
    }

    // Search bar
    char searchBuffer[256] = {};
    std::strncpy(searchBuffer, nodeDictionarySearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(-1);
    if (ImGui::InputTextWithHint("##node-dict-search", "Search nodes...", searchBuffer, sizeof(searchBuffer)))
    {
        nodeDictionarySearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    ImGui::Spacing();

    // Split-pane layout: left sidebar (navigation) + right content
    float sidebarWidth = 280.0f;
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    float availableWidth = window->ContentRegionRect.GetWidth();
    float contentWidth = availableWidth - sidebarWidth - ImGui::GetStyle().ItemSpacing.x;

    // Left sidebar: Navigation list
    if (ImGui::BeginChild("NodeDictionarySidebar", ImVec2(sidebarWidth, 0), true))
    {
        if (nodeDictionarySections.empty())
        {
            ImGui::TextWrapped("Node Dictionary file not found or could not be loaded.");
        }
        else
        {
            renderNavigationSidebar(nodeDictionaryNavItems, nodeDictionarySearchTerm);
        }
    }
    ImGui::EndChild();

    ImGui::SameLine();

    // Right pane: Main content
    if (ImGui::BeginChild("NodeDictionaryContent", ImVec2(contentWidth, 0), false, ImGuiWindowFlags_HorizontalScrollbar))
    {
        if (nodeDictionarySections.empty())
        {
            ImGui::TextWrapped("Node Dictionary file not found or could not be loaded.");
            ImGui::TextWrapped("Expected location: %s", nodeDictionaryFile.getFullPathName().toRawUTF8());
        }
        else
        {
            renderNodeDictionaryContent(nodeDictionarySections, nodeDictionarySearchTerm);
        }
    }
    ImGui::EndChild();
}

void HelpManagerComponent::renderGettingStartedTab()
{
    // Lazy load the markdown file on first open
    if (!gettingStartedLoaded)
    {
        loadGettingStarted();
    }

    // Search bar
    char searchBuffer[256] = {};
    std::strncpy(searchBuffer, gettingStartedSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(-1);
    if (ImGui::InputTextWithHint("##getting-started-search", "Search...", searchBuffer, sizeof(searchBuffer)))
    {
        gettingStartedSearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    ImGui::Spacing();

    // Render the markdown content
    if (ImGui::BeginChild("GettingStartedContent", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar))
    {
        if (gettingStartedSections.empty())
        {
            ImGui::TextWrapped("Getting Started file not found or could not be loaded.");
            ImGui::TextWrapped("Expected location: %s", gettingStartedFile.getFullPathName().toRawUTF8());
        }
        else
        {
            for (const auto& section : gettingStartedSections)
            {
                renderMarkdownSection(section, gettingStartedSearchTerm, true, false);
            }
        }
    }
    ImGui::EndChild();
}

void HelpManagerComponent::renderFaqTab()
{
    // Lazy load the markdown file on first open
    if (!faqLoaded)
    {
        loadFaq();
    }

    // Search bar
    char searchBuffer[256] = {};
    std::strncpy(searchBuffer, faqSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(-1);
    if (ImGui::InputTextWithHint("##faq-search", "Search FAQ...", searchBuffer, sizeof(searchBuffer)))
    {
        faqSearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    ImGui::Spacing();

    // Render the markdown content
    if (ImGui::BeginChild("FaqContent", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar))
    {
        if (faqSections.empty())
        {
            ImGui::TextWrapped("FAQ file not found or could not be loaded.");
            ImGui::TextWrapped("Expected location: %s", faqFile.getFullPathName().toRawUTF8());
        }
        else
        {
            for (const auto& section : faqSections)
            {
                renderMarkdownSection(section, faqSearchTerm, true, false);
            }
        }
    }
    ImGui::EndChild();
}

void HelpManagerComponent::renderAboutTab()
{
    ImGui::Text("Collider Modular Synthesizer");
    ImGui::Text("Version 1.2 (Hypothetical)"); // TODO: Pull this from a central version header
    ImGui::Separator();
    ImGui::TextWrapped("Built with JUCE, Dear ImGui, imnodes, and the Collider Core audio engine.");
    
    ImGui::Spacing();
    ImGui::Spacing();
    
    // Use dummy buttons for link look-and-feel
    if (ImGui::Button("GitHub Repository"))
    {
        juce::URL("https://github.com/Moof-Moof/Collider").launchInDefaultBrowser();
    }
    ImGui::SameLine();
    if (ImGui::Button("Full Documentation"))
    {
        // TODO: Add link to documentation website
    }
}

// === START: CODE MOVED FROM ImGuiNodeEditorComponent.cpp ===
// All this logic is now part of the HelpManagerComponent

void HelpManagerComponent::renderShortcutsTab()
{
    // This is the logic from the old `renderShortcutEditorContents()`
    
    updateShortcutCapture();
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    const juce::Identifier contexts[] = { globalContext, ImGuiNodeEditorComponent::nodeEditorContextId };
    int selectedIndex = (shortcutContextSelection == globalContext) ? 0 : 1;
    ImGui::SetNextItemWidth(250.0f);
    if (ImGui::BeginCombo("Context", contextDisplayName(shortcutContextSelection).toRawUTF8()))
    {
        for (int i = 0; i < 2; ++i)
        {
            const bool isSelected = (selectedIndex == i);
            if (ImGui::Selectable(contextDisplayName(contexts[i]).toRawUTF8(), isSelected))
                shortcutContextSelection = contexts[i];
            if (isSelected)
                ImGui::SetItemDefaultFocus();
        }
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    char searchBuffer[128] = {};
    std::strncpy(searchBuffer, shortcutsSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(300.0f);
    if (ImGui::InputTextWithHint("##shortcut-search", "Search actionsâ€¦", searchBuffer, sizeof(searchBuffer)))
    {
        shortcutsSearchTerm = juce::String(searchBuffer).trim();
    }
    
    ImGui::SameLine();
    if (ImGui::Button("Save Changes"))
    {
        saveUserShortcutBindings();
    }
    if (ImGui::IsItemHovered())
        ImGui::SetTooltip("Saves changes to user_shortcuts.json");
    ImGui::Separator();
    
    if (ImGui::BeginChild("ShortcutTableChild"))
    {
        renderShortcutEditorTable(shortcutContextSelection);
    }
    ImGui::EndChild();
    renderShortcutCapturePanel();
}

void HelpManagerComponent::renderShortcutEditorTable(const juce::Identifier& context)
{
    const auto& registry = shortcutManager.getRegistry();
    std::vector<std::pair<juce::Identifier, collider::ShortcutAction>> actions;
    actions.reserve(registry.size());
    for (const auto& entry : registry)
        actions.emplace_back(entry.first, entry.second);

    std::sort(actions.begin(), actions.end(), [](const auto& a, const auto& b)
    {
        int categoryCompare = a.second.category.compareIgnoreCase(b.second.category);
        if (categoryCompare != 0)
            return categoryCompare < 0;
        return a.second.name.compareIgnoreCase(b.second.name) < 0;
    });

    if (ImGui::BeginTable("shortcut-editor-table", 5, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable | ImGuiTableFlags_Sortable))
    {
        ImGui::TableSetupColumn("Category", ImGuiTableColumnFlags_WidthFixed, 140.0f);
        ImGui::TableSetupColumn("Action", ImGuiTableColumnFlags_WidthStretch);
        ImGui::TableSetupColumn("Binding", ImGuiTableColumnFlags_WidthFixed, 160.0f);
        ImGui::TableSetupColumn("Source", ImGuiTableColumnFlags_WidthFixed, 160.0f);
        ImGui::TableSetupColumn("Options", ImGuiTableColumnFlags_WidthFixed, 200.0f);
        ImGui::TableHeadersRow();

        juce::String previousCategory;
        for (const auto& [actionId, action] : actions)
        {
            if (shortcutsSearchTerm.isNotEmpty())
            {
                const juce::String search = shortcutsSearchTerm;
                if (!action.name.containsIgnoreCase(search)
                    && !action.description.containsIgnoreCase(search)
                    && !action.category.containsIgnoreCase(search))
                {
                    continue;
                }
            }

            const bool categoryChanged = previousCategory != action.category;
            renderShortcutRow(action, actionId, context, categoryChanged);
            previousCategory = action.category;
        }

        ImGui::EndTable();
    }
}

void HelpManagerComponent::renderShortcutRow(const collider::ShortcutAction& action,
                                             const juce::Identifier& actionId,
                                             const juce::Identifier& context,
                                             bool categoryChanged)
{
    ImGui::TableNextRow();
    ImGui::TableSetColumnIndex(0);
    if (categoryChanged)
        ImGui::TextUnformatted(action.category.toRawUTF8());
    ImGui::TableSetColumnIndex(1);
    ImGui::TextUnformatted(action.name.toRawUTF8());
    if (!action.description.isEmpty() && ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::TextUnformatted(action.description.toRawUTF8());
        ImGui::EndTooltip();
    }
    ImGui::TableSetColumnIndex(2);
    juce::String sourceLabel;
    juce::String bindingLabel = getBindingLabelForContext(actionId, context, sourceLabel);
    ImGui::TextUnformatted(bindingLabel.toRawUTF8());
    ImGui::TableSetColumnIndex(3);
    ImGui::TextUnformatted(sourceLabel.toRawUTF8());
    ImGui::TableSetColumnIndex(4);
    juce::String assignId = "Assign##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(assignId.toRawUTF8()))
    {
        beginShortcutCapture(actionId, context);
    }
    ImGui::SameLine();
    juce::String clearId = "Clear##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(clearId.toRawUTF8()))
    {
        clearShortcutForContext(actionId, context);
    }
    ImGui::SameLine();
    juce::String resetId = "Reset##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(resetId.toRawUTF8()))
    {
        resetShortcutForContext(actionId, context);
    }
}

void HelpManagerComponent::renderShortcutCapturePanel()
{
    if (!shortcutCaptureState.isCapturing)
        return;

    // This renders as an overlay
    ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    ImGui::SetNextWindowBgAlpha(0.85f);
    
    if (ImGui::Begin("ShortcutCapture", nullptr, 
                     ImGuiWindowFlags_NoDecoration | 
                     ImGuiWindowFlags_NoMove | 
                     ImGuiWindowFlags_AlwaysAutoResize))
    {
        const auto& registry = shortcutManager.getRegistry();
        juce::String actionName = shortcutCaptureState.actionId.toString();
        if (auto it = registry.find(shortcutCaptureState.actionId); it != registry.end())
            actionName = it->second.name;

        ImGui::Text("Assigning: %s (%s)",
                    actionName.toRawUTF8(),
                    contextDisplayName(shortcutCaptureState.context).toRawUTF8());
        
        ImGui::Separator();
        ImGui::TextUnformatted("Press a key combinationâ€¦ (Esc to cancel)");
        
        ImGui::End();
    }
}

void HelpManagerComponent::beginShortcutCapture(const juce::Identifier& actionId, const juce::Identifier& context)
{
    shortcutCaptureState = {};
    shortcutCaptureState.isCapturing = true;
    shortcutCaptureState.actionId = actionId;
    shortcutCaptureState.context = context;
}

void HelpManagerComponent::updateShortcutCapture()
{
    if (!shortcutCaptureState.isCapturing)
        return;
    if (ImGui::IsKeyPressed(ImGuiKey_Escape, false))
    {
        cancelShortcutCapture();
        return;
    }
    const ImGuiIO& io = ImGui::GetIO();
    for (int keyIndex = ImGuiKey_NamedKey_BEGIN; keyIndex < ImGuiKey_NamedKey_END; ++keyIndex)
    {
        const ImGuiKey key = static_cast<ImGuiKey>(keyIndex);
        if (key >= ImGuiKey_MouseLeft && key <= ImGuiKey_MouseWheelY)
            continue;
        if (key >= ImGuiKey_ReservedForModCtrl)
            continue;
        const ImGuiKeyData* data = ImGui::GetKeyData(key);
        if (data == nullptr)
            continue;
        if (data->Down && data->DownDuration == 0.0f)
        {
            shortcutCaptureState.captured = collider::KeyChord::fromImGui(io, key);
            shortcutCaptureState.hasCaptured = shortcutCaptureState.captured.isValid();
            evaluateShortcutCaptureConflict();
            applyShortcutCapture(true);
            break;
        }
    }
}

void HelpManagerComponent::cancelShortcutCapture()
{
    shortcutCaptureState = {};
}

void HelpManagerComponent::applyShortcutCapture(bool forceReplace)
{
    if (!shortcutCaptureState.isCapturing || !shortcutCaptureState.hasCaptured || !shortcutCaptureState.captured.isValid())
        return;
    const auto& actionId = shortcutCaptureState.actionId;
    const auto& context = shortcutCaptureState.context;
    if (auto userBinding = shortcutManager.getUserBinding(actionId, context))
    {
        if (userBinding->isValid() && chordsEqual(*userBinding, shortcutCaptureState.captured))
        {
            cancelShortcutCapture();
            return;
        }
    }
    if (auto defaultBinding = shortcutManager.getDefaultBinding(actionId, context))
    {
        if (defaultBinding->isValid() && chordsEqual(*defaultBinding, shortcutCaptureState.captured))
        {
            if (shortcutManager.removeUserBinding(actionId, context))
                shortcutsDirty = true;
            cancelShortcutCapture();
            return;
        }
    }
    if (shortcutCaptureState.conflictActionId.isValid())
    {
        if (!forceReplace)
            return;
        clearShortcutForContext(shortcutCaptureState.conflictActionId, shortcutCaptureState.conflictContextId);
    }
    shortcutManager.setUserBinding(actionId, context, shortcutCaptureState.captured);
    shortcutsDirty = true;
    cancelShortcutCapture();
}

void HelpManagerComponent::evaluateShortcutCaptureConflict()
{
    shortcutCaptureState.conflictActionId = {};
    shortcutCaptureState.conflictContextId = {};
    shortcutCaptureState.conflictIsUserBinding = false;
    if (!shortcutCaptureState.hasCaptured || !shortcutCaptureState.captured.isValid())
        return;
    const auto& chord = shortcutCaptureState.captured;
    const auto& targetAction = shortcutCaptureState.actionId;
    const auto& targetContext = shortcutCaptureState.context;
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    const auto& registry = shortcutManager.getRegistry();
    const juce::Identifier contextsToCheck[] = { globalContext, ImGuiNodeEditorComponent::nodeEditorContextId };
    auto isSameChord = [&](const juce::Identifier& actionId, const juce::Identifier& contextId, const juce::Optional<collider::KeyChord>& chordOpt, bool isUser)
    {
        if (!chordOpt.hasValue() || !chordOpt->isValid())
            return false;
        if (!chordsEqual(*chordOpt, chord))
            return false;
        shortcutCaptureState.conflictActionId = actionId;
        shortcutCaptureState.conflictContextId = contextId;
        shortcutCaptureState.conflictIsUserBinding = isUser;
        return true;
    };
    // Ignore if chord matches current binding for this action/context
    auto currentBinding = shortcutManager.getBindingForContext(targetAction, targetContext);
    if (currentBinding.isValid() && chordsEqual(currentBinding, chord))
        return;
    for (const auto& [actionId, action] : registry)
    {
        for (const auto& ctx : contextsToCheck)
        {
            if (ctx != targetContext && targetContext == globalContext && ctx != globalContext)
                continue; // when editing global, only check global + other contexts once
            auto userBinding = shortcutManager.getUserBinding(actionId, ctx);
            if (isSameChord(actionId, ctx, userBinding, true))
                return;
            auto defaultBinding = shortcutManager.getDefaultBinding(actionId, ctx);
            // Only check default if no user override
            if (!userBinding.hasValue())
            {
                if (isSameChord(actionId, ctx, defaultBinding, false))
                    return;
            }
        }
    }
}

void HelpManagerComponent::clearShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context)
{
    collider::KeyChord cleared;
    shortcutManager.setUserBinding(actionId, context, cleared);
    shortcutsDirty = true;
    if (shortcutCaptureState.isCapturing &&
        shortcutCaptureState.actionId == actionId &&
        shortcutCaptureState.context == context)
    {
        cancelShortcutCapture();
    }
}

void HelpManagerComponent::resetShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context)
{
    if (shortcutManager.removeUserBinding(actionId, context))
    {
        shortcutsDirty = true;
    }
    if (shortcutCaptureState.isCapturing &&
        shortcutCaptureState.actionId == actionId &&
        shortcutCaptureState.context == context)
    {
        cancelShortcutCapture();
    }
}

void HelpManagerComponent::saveUserShortcutBindings()
{
    if (userShortcutFile.getFullPathName().isEmpty())
        return;
    auto parent = userShortcutFile.getParentDirectory();
    if (!parent.isDirectory())
        parent.createDirectory();
    shortcutManager.saveUserBindingsToFile(userShortcutFile);
    shortcutsDirty = false;
    NotificationManager::post(NotificationManager::Type::Success, "Shortcut settings saved");
}

juce::String HelpManagerComponent::getBindingLabelForContext(const juce::Identifier& actionId,
                                                             const juce::Identifier& context,
                                                             juce::String& sourceLabel) const
{
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    auto userBinding = shortcutManager.getUserBinding(actionId, context);
    if (userBinding.hasValue())
    {
        if (userBinding->isValid())
        {
            sourceLabel = "User";
            return userBinding->toString();
        }
        sourceLabel = "User (cleared)";
        return "Unassigned";
    }
    auto defaultBinding = shortcutManager.getDefaultBinding(actionId, context);
    if (defaultBinding.hasValue() && defaultBinding->isValid())
    {
        sourceLabel = "Default";
        return defaultBinding->toString();
    }
    if (context != globalContext)
    {
        auto userGlobal = shortcutManager.getUserBinding(actionId, globalContext);
        if (userGlobal.hasValue())
        {
            if (userGlobal->isValid())
            {
                sourceLabel = "Global (user)";
                return userGlobal->toString();
            }
            sourceLabel = "Global (user cleared)";
            return "Unassigned";
        }
        auto defaultGlobal = shortcutManager.getDefaultBinding(actionId, globalContext);
        if (defaultGlobal.hasValue() && defaultGlobal->isValid())
        {
            sourceLabel = "Global (default)";
            return defaultGlobal->toString();
        }
    }
    sourceLabel = "Unassigned";
    return "Unassigned";
}

// === END: CODE MOVED FROM ImGuiNodeEditorComponent.cpp ===

// === MARKDOWN PARSING & RENDERING ===

bool HelpManagerComponent::MarkdownSection::matchesSearch(const juce::String& searchTerm) const
{
    if (searchTerm.isEmpty())
        return true;
    
    if (title.containsIgnoreCase(searchTerm) || content.containsIgnoreCase(searchTerm))
        return true;
    
    for (const auto& child : children)
    {
        if (child.matchesSearch(searchTerm))
            return true;
    }
    
    return false;
}

bool HelpManagerComponent::MarkdownSection::containsAnchor(const juce::String& targetAnchor) const
{
    if (targetAnchor.isEmpty())
        return false;
    
    // Check if this section's anchor matches
    if (anchor == targetAnchor)
        return true;
    
    // Recursively check children
    for (const auto& child : children)
    {
        if (child.containsAnchor(targetAnchor))
            return true;
    }
    
    return false;
}

void HelpManagerComponent::loadNodeDictionary()
{
    if (nodeDictionaryLoaded || !nodeDictionaryFile.existsAsFile())
    {
        if (!nodeDictionaryFile.existsAsFile())
        {
            juce::Logger::writeToLog("[HelpManager] Node Dictionary file not found: " + nodeDictionaryFile.getFullPathName());
        }
        nodeDictionaryLoaded = true;
        return;
    }
    
    juce::String content = nodeDictionaryFile.loadFileAsString();
    if (content.isEmpty())
    {
        juce::Logger::writeToLog("[HelpManager] Failed to load Node Dictionary file or file is empty.");
        nodeDictionaryLoaded = true;
        return;
    }
    
    parseMarkdown(content, nodeDictionarySections);
    nodeDictionaryLoaded = true;
    juce::Logger::writeToLog("[HelpManager] Loaded Node Dictionary: " + juce::String(nodeDictionarySections.size()) + " top-level sections");
}

void HelpManagerComponent::loadGettingStarted()
{
    if (gettingStartedLoaded || !gettingStartedFile.existsAsFile())
    {
        if (!gettingStartedFile.existsAsFile())
        {
            juce::Logger::writeToLog("[HelpManager] Getting Started file not found: " + gettingStartedFile.getFullPathName());
        }
        gettingStartedLoaded = true;
        return;
    }
    
    juce::String content = gettingStartedFile.loadFileAsString();
    if (content.isEmpty())
    {
        juce::Logger::writeToLog("[HelpManager] Failed to load Getting Started file or file is empty.");
        gettingStartedLoaded = true;
        return;
    }
    
    parseMarkdown(content, gettingStartedSections);
    gettingStartedLoaded = true;
    juce::Logger::writeToLog("[HelpManager] Loaded Getting Started: " + juce::String(gettingStartedSections.size()) + " top-level sections");
}

void HelpManagerComponent::loadFaq()
{
    if (faqLoaded || !faqFile.existsAsFile())
    {
        if (!faqFile.existsAsFile())
        {
            juce::Logger::writeToLog("[HelpManager] FAQ file not found: " + faqFile.getFullPathName());
        }
        faqLoaded = true;
        return;
    }
    
    juce::String content = faqFile.loadFileAsString();
    if (content.isEmpty())
    {
        juce::Logger::writeToLog("[HelpManager] Failed to load FAQ file or file is empty.");
        faqLoaded = true;
        return;
    }
    
    parseMarkdown(content, faqSections);
    faqLoaded = true;
    juce::Logger::writeToLog("[HelpManager] Loaded FAQ: " + juce::String(faqSections.size()) + " top-level sections");
}

void HelpManagerComponent::parseMarkdown(const juce::String& content, std::vector<MarkdownSection>& sections)
{
    sections.clear();
    
    auto lines = juce::StringArray::fromLines(content);
    std::vector<MarkdownSection*> stack; // Stack to track current section hierarchy
    
    for (int i = 0; i < lines.size(); ++i)
    {
        juce::String line = lines[i].trimEnd();
        
        // Check for headers (##, ###, ####)
        if (line.startsWith("##"))
        {
            int level = 0;
            int startIdx = 0;
            while (startIdx < line.length() && line[startIdx] == '#')
            {
                level++;
                startIdx++;
            }
            
            // Skip if level is 1 (single #) - we only care about ## and below
            if (level < 2)
                continue;
            
            level -= 1; // Convert to 1-based: ## = 1, ### = 2, #### = 3
            
            juce::String title = line.substring(startIdx).trim();
            juce::String anchor = extractAnchor(line);
            
            // Pop stack until we find the right parent level
            while (!stack.empty() && stack.back()->level >= level)
            {
                stack.pop_back();
            }
            
            MarkdownSection newSection;
            newSection.title = title;
            newSection.level = level;
            newSection.anchor = anchor;
            
            // Add to appropriate parent
            if (stack.empty())
            {
                sections.push_back(newSection);
                stack.push_back(&sections.back());
            }
            else
            {
                stack.back()->children.push_back(newSection);
                stack.push_back(&stack.back()->children.back());
            }
        }
        else if (!stack.empty() && !line.isEmpty())
        {
            // Add content to current section
            if (stack.back()->content.isNotEmpty())
                stack.back()->content += "\n";
            stack.back()->content += line;
        }
    }
}

juce::String HelpManagerComponent::extractAnchor(const juce::String& headerLine)
{
    // Extract anchor from header line (e.g., "### vco" -> "vco")
    int startIdx = 0;
    while (startIdx < headerLine.length() && headerLine[startIdx] == '#')
        startIdx++;
    
    juce::String title = headerLine.substring(startIdx).trim();
    
    // Convert to lowercase anchor (simple version)
    juce::String anchor = title.toLowerCase();
    // Remove special characters and replace spaces with hyphens
    anchor = anchor.replaceCharacters(".,!?;:()[]{}", "");
    anchor = anchor.replace(" ", "-");
    
    return anchor;
}

void HelpManagerComponent::renderMarkdownSection(const MarkdownSection& section, const juce::String& searchTerm, bool parentMatches, bool forceExpand)
{
    bool sectionMatches = searchTerm.isEmpty() ? true : section.matchesSearch(searchTerm);
    bool shouldShow = searchTerm.isEmpty() || sectionMatches || parentMatches;
    
    if (!shouldShow)
        return;
    
    // Check if this section or any of its children contain the target anchor
    bool containsTargetAnchor = !scrollToAnchor.isEmpty() && section.containsAnchor(scrollToAnchor);
    
    // Check if this is the exact target section for scrolling
    bool isTargetSection = !scrollToAnchor.isEmpty() && section.anchor == scrollToAnchor;
    
    // Render based on level
    if (section.level == 1)
    {
        // Top-level sections use CollapsingHeader with category color
        ImU32 categoryColor = getCategoryColorForSection(section.title);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(categoryColor);
        
        ImGui::PushStyleColor(ImGuiCol_Header, categoryColor);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
        
        // Use optimal text color for contrast
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(categoryColor);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
        
        // Force expand if this section contains the target anchor
        if (forceExpand || containsTargetAnchor)
        {
            ImGui::SetNextItemOpen(true, ImGuiCond_Always);
        }
        
        // Determine if section should be expanded by default
        ImGuiTreeNodeFlags flags = 0;
        if (searchTerm.isEmpty() || sectionMatches || forceExpand || containsTargetAnchor)
            flags |= ImGuiTreeNodeFlags_DefaultOpen;
        
        bool isOpen = ImGui::CollapsingHeader(section.title.toRawUTF8(), flags);
        ImGui::PopStyleColor(4);
        if (isOpen)
        {
            ImGui::Indent(10.0f);
            renderMarkdownText(section.content);
            
            for (const auto& child : section.children)
            {
                renderMarkdownSection(child, searchTerm, sectionMatches || containsTargetAnchor, containsTargetAnchor);
            }
            ImGui::Unindent(10.0f);
        }
    }
    else if (section.level == 2)
    {
        // Second-level sections (###) - node names with category colors
        
        // Check if this is the target section for scrolling - scroll BEFORE rendering header
        if (isTargetSection)
        {
            ImGui::SetScrollHereY(0.1f); // 10% from top
            scrollToAnchor = ""; // Clear after scrolling
        }
        
        ImGui::Spacing();
        ImGui::PushID(section.anchor.toRawUTF8()); // Unique ID for each node section
        
        // Use theme accent color for node names - bright and vibrant
        ImVec4 accentColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
        accentColor.w = 1.0f;
        // Make it slightly more vibrant
        accentColor.x = std::min(1.0f, accentColor.x * 1.1f);
        accentColor.y = std::min(1.0f, accentColor.y * 1.1f);
        accentColor.z = std::min(1.0f, accentColor.z * 1.15f);
        ImGui::PushStyleColor(ImGuiCol_Text, accentColor);
        ImGui::SetWindowFontScale(1.3f);
        ImGui::TextUnformatted(section.title.toRawUTF8());
        ImGui::SetWindowFontScale(1.0f);
        ImGui::PopStyleColor();
        ImGui::PopID();
        
        ImGui::Spacing();
        
        renderMarkdownText(section.content);
        
        for (const auto& child : section.children)
        {
            renderMarkdownSection(child, searchTerm, sectionMatches, forceExpand && containsTargetAnchor);
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
    }
    else
    {
        // Level 3+ (####) - smaller styled header
        
        // Check if this is the target section for scrolling - scroll BEFORE rendering header
        if (isTargetSection)
        {
            ImGui::SetScrollHereY(0.1f); // 10% from top
            scrollToAnchor = ""; // Clear after scrolling
        }
        
        ImGui::Spacing();
        ImGui::PushID(section.anchor.toRawUTF8()); // Unique ID for each subsection
        
        // Use theme text color with slight emphasis
        ImVec4 subHeaderColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
        subHeaderColor.w = 0.9f; // Slightly brighter than disabled
        ImGui::PushStyleColor(ImGuiCol_Text, subHeaderColor);
        ImGui::SetWindowFontScale(1.1f);
        ImGui::TextUnformatted(section.title.toRawUTF8());
        ImGui::SetWindowFontScale(1.0f);
        ImGui::PopStyleColor();
        ImGui::PopID();
        
        ImGui::Spacing();
        
        renderMarkdownText(section.content);
        
        for (const auto& child : section.children)
        {
            renderMarkdownSection(child, searchTerm, sectionMatches, forceExpand && containsTargetAnchor);
        }
    }
}

void HelpManagerComponent::renderMarkdownText(const juce::String& text)
{
    if (text.isEmpty())
        return;
    
    auto lines = juce::StringArray::fromLines(text);
    bool inCodeBlock = false;
    
    for (int lineIdx = 0; lineIdx < lines.size(); ++lineIdx)
    {
        juce::String line = lines[lineIdx];
        juce::String trimmed = line.trim();
        
        // Handle code blocks
        if (trimmed.startsWith("```"))
        {
            inCodeBlock = !inCodeBlock;
            if (inCodeBlock)
            {
                ImGui::Spacing();
                // Use a slightly brighter background for code blocks
                ImVec4 codeBg = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
                codeBg.w = std::min(1.0f, codeBg.w * 1.3f); // Brighter background
                ImGui::PushStyleColor(ImGuiCol_ChildBg, codeBg);
                ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 4.0f);
                ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.0f, 8.0f));
            }
            else
            {
                ImGui::PopStyleVar(2);
                ImGui::PopStyleColor();
                ImGui::Spacing();
            }
            continue;
        }
        
        if (inCodeBlock)
        {
            // Render code block line with theme-aware color
            ImVec4 codeTextColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
            // Make code text slightly brighter/cyan-tinted
            codeTextColor.x = std::min(1.0f, codeTextColor.x * 1.2f);
            codeTextColor.y = std::min(1.0f, codeTextColor.y * 1.1f);
            codeTextColor.z = std::min(1.0f, codeTextColor.z * 1.15f);
            ImGui::PushStyleColor(ImGuiCol_Text, codeTextColor);
            ImGui::TextUnformatted(line.toRawUTF8());
            ImGui::PopStyleColor();
            continue;
        }
        
        if (trimmed.isEmpty())
        {
            ImGui::Spacing();
            continue;
        }
        
        // Check for list items
        if (trimmed.startsWith("- ") || trimmed.startsWith("* "))
        {
            ImGui::Indent(20.0f);
            renderFormattedText(trimmed.substring(2));
            ImGui::Unindent(20.0f);
        }
        // Regular text with formatting
        else
        {
            renderFormattedText(trimmed);
        }
    }
}

void HelpManagerComponent::renderFormattedText(const juce::String& text)
{
    // Parse formatting: bold (**text**), code (`text`), and links ([text](#anchor))
    juce::String remaining = text;
    std::vector<std::tuple<juce::String, int, juce::String>> segments; // text, type (0=plain, 1=bold, 2=code, 3=link), linkTarget
    
    // Parse the text into segments
    while (remaining.isNotEmpty())
    {
        int boldStart = remaining.indexOf("**");
        int codeStart = remaining.indexOf("`");
        int linkStart = remaining.indexOf("[");
        
        int nextMarker = -1;
        int formatType = 0;
        
        // Find the earliest marker
        if (boldStart >= 0 && (codeStart < 0 || boldStart < codeStart) && (linkStart < 0 || boldStart < linkStart))
        {
            nextMarker = boldStart;
            formatType = 1; // bold
        }
        else if (codeStart >= 0 && (linkStart < 0 || codeStart < linkStart))
        {
            nextMarker = codeStart;
            formatType = 2; // code
        }
        else if (linkStart >= 0)
        {
            nextMarker = linkStart;
            formatType = 3; // link
        }
        
        if (nextMarker < 0)
        {
            // No more formatting
            if (remaining.isNotEmpty())
                segments.emplace_back(remaining, 0, "");
            break;
        }
        
        // Add plain text before marker
        if (nextMarker > 0)
        {
            segments.emplace_back(remaining.substring(0, nextMarker), 0, "");
        }
        
        if (formatType == 1) // bold
        {
            int boldEnd = remaining.indexOf(boldStart + 2, "**");
            if (boldEnd > boldStart + 2)
            {
                segments.emplace_back(remaining.substring(boldStart + 2, boldEnd), 1, "");
                remaining = remaining.substring(boldEnd + 2);
            }
            else
            {
                // Malformed bold, treat as plain text
                segments.emplace_back(remaining.substring(boldStart), 0, "");
                remaining = "";
            }
        }
        else if (formatType == 2) // code
        {
            int codeEnd = remaining.indexOf(codeStart + 1, "`");
            if (codeEnd > codeStart)
            {
                segments.emplace_back(remaining.substring(codeStart + 1, codeEnd), 2, "");
                remaining = remaining.substring(codeEnd + 1);
            }
            else
            {
                segments.emplace_back(remaining.substring(codeStart), 0, "");
                remaining = "";
            }
        }
        else if (formatType == 3) // link [text](#anchor)
        {
            int linkTextEnd = remaining.indexOf(nextMarker + 1, "]");
            if (linkTextEnd > nextMarker)
            {
                juce::String linkText = remaining.substring(nextMarker + 1, linkTextEnd);
                int linkTargetStart = remaining.indexOf(linkTextEnd + 1, "(");
                if (linkTargetStart == linkTextEnd + 1)
                {
                    int linkTargetEnd = remaining.indexOf(linkTargetStart + 1, ")");
                    if (linkTargetEnd > linkTargetStart)
                    {
                        juce::String linkTarget = remaining.substring(linkTargetStart + 1, linkTargetEnd);
                        // Remove # from anchor if present
                        if (linkTarget.startsWith("#"))
                            linkTarget = linkTarget.substring(1);
                        segments.emplace_back(linkText, 3, linkTarget);
                        remaining = remaining.substring(linkTargetEnd + 1);
                    }
                    else
                    {
                        segments.emplace_back(remaining.substring(nextMarker), 0, "");
                        remaining = "";
                    }
                }
                else
                {
                    segments.emplace_back(remaining.substring(nextMarker), 0, "");
                    remaining = "";
                }
            }
            else
            {
                segments.emplace_back(remaining.substring(nextMarker), 0, "");
                remaining = "";
            }
        }
    }
    
    // Render segments
    for (const auto& [segmentText, formatType, linkTarget] : segments)
    {
        if (segmentText.isEmpty())
            continue;
            
        if (formatType == 1) // bold
        {
            // Bold text - use theme accent color
            ImVec4 boldColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
            boldColor.w = 1.0f;
            ImGui::PushStyleColor(ImGuiCol_Text, boldColor);
            ImGui::SetWindowFontScale(1.08f);
            ImGui::TextWrapped("%s", segmentText.toRawUTF8());
            ImGui::SetWindowFontScale(1.0f);
            ImGui::PopStyleColor();
        }
        else if (formatType == 2) // code
        {
            // Inline code - use theme colors with subtle background
            ImVec4 codeTextColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
            codeTextColor.x = std::min(1.0f, codeTextColor.x * 1.15f);
            codeTextColor.y = std::min(1.0f, codeTextColor.y * 1.1f);
            codeTextColor.z = std::min(1.0f, codeTextColor.z * 1.2f);
            
            ImVec4 codeBgColor = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
            codeBgColor.w = std::min(1.0f, codeBgColor.w * 1.2f); // Slightly brighter background
            
            ImGui::PushStyleColor(ImGuiCol_Text, codeTextColor);
            ImGui::PushStyleColor(ImGuiCol_FrameBg, codeBgColor);
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4.0f, 2.0f));
            ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);
            ImGui::TextWrapped("%s", segmentText.toRawUTF8());
            ImGui::PopStyleVar(2);
            ImGui::PopStyleColor(2);
        }
        else if (formatType == 3) // link
        {
            // Link - use theme accent color with hover effect
            ImVec4 linkColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
            linkColor.z = std::min(1.0f, linkColor.z * 1.2f); // Slightly more blue
            linkColor.w = 1.0f;
            
            juce::String linkId = "link_" + linkTarget;
            ImGui::PushID(linkId.toRawUTF8()); // Unique ID for each link
            
            ImGui::PushStyleColor(ImGuiCol_Text, linkColor);
            if (ImGui::Selectable(segmentText.toRawUTF8(), false, ImGuiSelectableFlags_None))
            {
                // Clicked! Scroll to anchor
                juce::String target = linkTarget;
                if (target.startsWith("#"))
                    target = target.substring(1);
                scrollToAnchor = target;
            }
            ImGui::PopStyleColor();
            ImGui::PopID();
        }
        else // plain
        {
            ImGui::TextWrapped("%s", segmentText.toRawUTF8());
        }
    }
}

ImU32 HelpManagerComponent::getCategoryColorForSection(const juce::String& sectionTitle) const
{
    juce::String titleUpper = sectionTitle.toUpperCase();
    
    // Map section titles to ModuleCategory
    if (titleUpper.contains("SOURCE") || titleUpper.contains("1. SOURCE"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Source);
    else if (titleUpper.contains("EFFECT") || titleUpper.contains("2. EFFECT"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Effect);
    else if (titleUpper.contains("MODULATOR") || titleUpper.contains("3. MODULATOR"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Modulator);
    else if (titleUpper.contains("UTILITY") || titleUpper.contains("4. UTILITY"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Utility);
    else if (titleUpper.contains("SEQUENCER") || titleUpper.contains("5. SEQUENCER"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Seq);
    else if (titleUpper.contains("MIDI") || titleUpper.contains("6. MIDI"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::MIDI);
    else if (titleUpper.contains("ANALYSIS") || titleUpper.contains("7. ANALYSIS"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Analysis);
    else if (titleUpper.contains("TTS") || titleUpper.contains("8. TTS"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::TTS_Voice);
    else if (titleUpper.contains("SPECIAL") || titleUpper.contains("9. SPECIAL"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Special_Exp);
    else if (titleUpper.contains("COMPUTER VISION") || titleUpper.contains("10. COMPUTER VISION"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::OpenCV);
    else if (titleUpper.contains("SYSTEM") || titleUpper.contains("11. SYSTEM"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Sys);
    
    // Default color
    return ImGui::ColorConvertFloat4ToU32(ImGui::GetStyleColorVec4(ImGuiCol_Header));
}

bool HelpManagerComponent::scrollToSectionIfNeeded(const juce::String& anchor)
{
    if (scrollToAnchor.isNotEmpty() && scrollToAnchor == anchor)
    {
        // Scroll to this section
        ImGui::SetScrollHereY(0.5f);
        scrollToAnchor = ""; // Clear after scrolling
        return true; // Indicate we scrolled
    }
    return false; // No scroll needed
}

void HelpManagerComponent::buildNavigationList(const std::vector<MarkdownSection>& sections, std::vector<NavigationItem>& navItems, int level)
{
    for (const auto& section : sections)
    {
        // Add all sections to navigation, but indent based on hierarchy
        NavigationItem item;
        item.title = section.title;
        item.anchor = section.anchor;
        item.level = level;
        item.isCategory = (section.level == 1); // Level 1 headers are categories like "1. SOURCE NODES"
        navItems.push_back(item);
        
        // Recursively add children with increased indentation
        if (!section.children.empty())
        {
            buildNavigationList(section.children, navItems, level + 1);
        }
    }
}

void HelpManagerComponent::renderNavigationSidebar(const std::vector<NavigationItem>& navItems, const juce::String& searchTerm)
{
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered));
    ImGui::SetWindowFontScale(1.15f);
    ImGui::Text("Navigation");
    ImGui::SetWindowFontScale(1.0f);
    ImGui::PopStyleColor();
    ImGui::Separator();
    ImGui::Spacing();

    int visibleIndex = 0; // Counter for unique IDs
    for (size_t i = 0; i < navItems.size(); ++i)
    {
        const auto& item = navItems[i];
        
        // Filter by search term
        if (!searchTerm.isEmpty() && !item.title.containsIgnoreCase(searchTerm))
            continue;

        // Skip items without anchors (like "Table of Contents")
        if (item.anchor.isEmpty())
            continue;

        // Indentation for nested items
        if (item.level > 0)
        {
            ImGui::Indent(item.level * 15.0f);
        }

        // Create unique ID using index and anchor
        juce::String uniqueId = juce::String(visibleIndex) + "_" + item.anchor;
        ImGui::PushID(uniqueId.toRawUTF8());

        bool isSelected = scrollToAnchor == item.anchor;
        
        // Category headers get special styling with category colors
        if (item.isCategory)
        {
            ImU32 categoryColor = getCategoryColorForSection(item.title);
            ImVec4 c = ImGui::ColorConvertU32ToFloat4(categoryColor);
            
            // Use category color for selected state
            if (isSelected)
            {
                ImGui::PushStyleColor(ImGuiCol_Header, categoryColor);
                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, categoryColor);
                ImVec4 selectedColor = ImVec4(c.x * 1.3f, c.y * 1.3f, c.z * 1.3f, 1.0f);
                ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(selectedColor));
                ImGui::PushStyleColor(ImGuiCol_Text, ThemeUtils::getOptimalTextColor(categoryColor));
            }
            else
            {
                ImGui::PushStyleColor(ImGuiCol_Text, c);
            }
            
            ImGui::SetWindowFontScale(1.1f);
        }
        else
        {
            // Node items - use theme accent color for selected
            if (isSelected)
            {
                ImVec4 accentColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
                accentColor.w = 1.0f;
                ImGui::PushStyleColor(ImGuiCol_Header, ImGui::ColorConvertFloat4ToU32(accentColor));
                ImGui::PushStyleColor(ImGuiCol_Text, accentColor);
                ImGui::SetWindowFontScale(1.05f);
            }
            else
            {
                // Use slightly brighter text for nodes
                ImVec4 nodeTextColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
                nodeTextColor.w = 0.95f; // Slightly brighter
                ImGui::PushStyleColor(ImGuiCol_Text, nodeTextColor);
            }
        }

        // Clickable link with hover effect
        if (ImGui::Selectable(item.title.toRawUTF8(), isSelected, ImGuiSelectableFlags_None))
        {
            // Clicked! Scroll to this section in the content pane
            scrollToAnchor = item.anchor;
        }

        // Pop style colors
        if (item.isCategory)
        {
            ImGui::SetWindowFontScale(1.0f);
            if (isSelected)
                ImGui::PopStyleColor(4);
            else
                ImGui::PopStyleColor(1);
        }
        else
        {
            if (isSelected)
            {
                ImGui::SetWindowFontScale(1.0f);
                ImGui::PopStyleColor(2);
            }
            else
            {
                ImGui::PopStyleColor(1);
            }
        }

        ImGui::PopID();

        if (item.level > 0)
        {
            ImGui::Unindent(item.level * 15.0f);
        }

        visibleIndex++;
    }
}

void HelpManagerComponent::renderNodeDictionaryContent(const std::vector<MarkdownSection>& sections, const juce::String& searchTerm)
{
    for (const auto& section : sections)
    {
        // Check if we need to scroll to this section or any of its children
        bool shouldExpand = scrollToAnchor.isNotEmpty() && section.containsAnchor(scrollToAnchor);
        
        // If scrolling is needed, ensure parent sections are expanded
        if (shouldExpand && section.level == 1)
        {
            // Force expand this section by using SetNextItemOpen
            ImGui::SetNextItemOpen(true, ImGuiCond_Always);
        }
        
        // Render the section (it will handle scrolling internally)
        renderMarkdownSection(section, searchTerm, true, shouldExpand);
    }
}





================================================================================
FILE: juce/Source/preset_creator/theme/Theme.h
================================================================================

#pragma once

#include <imgui.h>
#include <map>
#include <juce_core/juce_core.h>

#include "../../audio/modules/ModuleProcessor.h" // For PinDataType

// Shared module category enum for theming (mirrors UI categories)
enum class ModuleCategory { Source, Effect, Modulator, Utility, Seq, MIDI, Analysis, TTS_Voice, Special_Exp, OpenCV, Sys, Comment, Plugin, Default };

struct TriStateColor
{
	ImU32 base { 0 };
	ImU32 hovered { 0 };
	ImU32 active { 0 };
};

struct Theme
{
	// ImGui base style (padding/rounding etc.)
	ImGuiStyle style {};

	// Global accent color used across highlights
	ImVec4 accent { 0.0f, 0.8f, 1.0f, 1.0f };

	struct TextColors
	{
		ImVec4 section_header { 0.7f, 0.7f, 0.7f, 1.0f };
		ImVec4 warning { 1.0f, 0.8f, 0.0f, 1.0f };
		ImVec4 success { 0.0f, 1.0f, 0.0f, 1.0f };
		ImVec4 error { 1.0f, 0.5f, 0.0f, 1.0f };
		ImVec4 disabled { 100/255.f, 100/255.f, 100/255.f, 1.0f };
		ImVec4 active { 100/255.f, 255/255.f, 100/255.f, 1.0f };
		float tooltip_wrap_standard { 35.0f };
		float tooltip_wrap_compact { 25.0f };
		bool enable_text_glow { false };
		ImVec4 text_glow_color { 0.0f, 0.0f, 0.0f, 0.5f };
	} text;

	struct StatusColors
	{
		ImVec4 edited { 1.0f, 1.0f, 0.0f, 1.0f };
		ImVec4 saved { 0.0f, 1.0f, 0.0f, 1.0f };
	} status;

	struct HeaderColors
	{
		TriStateColor recent {};
		TriStateColor samples {};
		TriStateColor presets {};
		TriStateColor system {};
	} headers;

	struct ImNodesColors
	{
		std::map<ModuleCategory, ImU32> category_colors;
		std::map<PinDataType, ImU32> pin_colors;
		ImU32 pin_connected { 0 };
		ImU32 pin_disconnected { 0 };
		ImU32 node_muted { 0 };
		float node_muted_alpha { 0.5f };
		ImU32 node_hovered_link_highlight { 0 };
	} imnodes;

	struct LinkColors
	{
		ImU32 link_hovered { 0 };
		ImU32 link_selected { 0 };
		ImU32 link_highlighted { 0 };
		ImU32 preview_color { 0 };
		float preview_width { 3.0f };
		ImU32 label_background { 0 };
		ImU32 label_text { 0 };
	} links;

	struct CanvasColors
	{
		// Canvas background (drawn behind grid)
		ImU32 canvas_background { 0 };
		// Grid settings (custom drawn)
		ImU32 grid_color { 0 };
		ImU32 grid_origin_color { 0 };
		float grid_size { 64.0f };
		ImU32 scale_text_color { 0 };
		float scale_interval { 400.0f };
		ImU32 drop_target_overlay { 0 };
		ImU32 mouse_position_text { 0 };
		// Node styling (ImNodes)
		ImU32 node_background { 0 };
		ImU32 node_frame { 0 };
		ImU32 node_frame_hovered { 0 };
		ImU32 node_frame_selected { 0 };
		float node_rounding { 0.0f };
		float node_border_width { 0.0f };
		ImU32 selection_rect { 0 };
		ImU32 selection_rect_outline { 0 };
	} canvas;

	struct LayoutSettings
	{
		float sidebar_width { 260.0f };
		float window_padding { 10.0f };
		float node_vertical_padding { 50.0f };
		float preset_vertical_padding { 100.0f };
		float node_default_width { 240.0f };
		ImVec2 node_default_padding { 8.0f, 8.0f };
		ImVec2 node_muted_padding { 8.0f, 8.0f };
	} layout;

	struct FontSettings
	{
		float default_size { 16.0f };
		juce::String default_path; // empty = ImGui default
	} fonts;

	struct WindowSettings
	{
		float status_overlay_alpha { 0.5f };
		float probe_scope_alpha { 0.85f };
		float preset_status_alpha { 0.7f };
		float notifications_alpha { 0.92f };
		float probe_scope_width { 260.0f };
		float probe_scope_height { 180.0f };
	} windows;

	struct ModulationColors
	{
		ImVec4 frequency { 0.4f, 0.8f, 1.0f, 1.0f };
		ImVec4 timbre { 1.0f, 0.8f, 0.4f, 1.0f };
		ImVec4 amplitude { 1.0f, 0.4f, 1.0f, 1.0f };
		ImVec4 filter { 0.4f, 1.0f, 0.4f, 1.0f };
	} modulation;

	struct MeterColors
	{
		ImVec4 safe { 0.2f, 0.8f, 0.2f, 1.0f };
		ImVec4 warning { 0.9f, 0.7f, 0.0f, 1.0f };
		ImVec4 clipping { 0.9f, 0.2f, 0.2f, 1.0f };
	} meters;

	struct TimelineColors
	{
		ImU32 marker_start_end { 0 };
		ImU32 marker_gate { 0 };
		ImU32 marker_trigger { 0 };
	} timeline;

	struct ModuleColors
	{
		ImVec4 videofx_section_header { 0.7f, 0.7f, 0.7f, 1.0f };
		ImVec4 videofx_section_subheader { 0.9f, 0.9f, 0.5f, 1.0f };
		ImVec4 scope_section_header { 0.7f, 0.7f, 0.7f, 1.0f };
		ImVec4 sequencer_section_header { 0.5f, 1.0f, 0.7f, 1.0f };
		ImVec4 sequencer_step_active_frame { 0.3f, 0.7f, 1.0f, 1.0f };
		ImVec4 sequencer_step_active_grab { 0.9f, 0.9f, 0.9f, 1.0f };
		ImVec4 sequencer_gate_active_frame { 1.0f, 0.7f, 0.3f, 1.0f };
		ImU32 sequencer_threshold_line { IM_COL32(255, 255, 0, 200) };
		ImVec4 stroke_seq_title { 0.9f, 0.95f, 0.2f, 1.0f };
		ImVec4 stroke_seq_section { 0.85f, 0.9f, 0.3f, 1.0f };
		ImU32 scope_plot_bg { 0 };
		ImU32 scope_plot_fg { 0 };
		ImU32 scope_plot_max { 0 };
		ImU32 scope_plot_min { 0 };
		ImVec4 scope_text_max { 1.0f, 0.3f, 0.3f, 1.0f };
		ImVec4 scope_text_min { 1.0f, 0.86f, 0.31f, 1.0f };
		ImU32 stroke_seq_border { 0 };
		ImU32 stroke_seq_canvas_bg { 0 };
		ImU32 stroke_seq_line_inactive { 0 };
		ImU32 stroke_seq_line_active { 0 };
		ImU32 stroke_seq_playhead { 0 };
		ImU32 stroke_seq_thresh_floor { 0 };
		ImU32 stroke_seq_thresh_mid { 0 };
		ImU32 stroke_seq_thresh_ceil { 0 };
		ImVec4 stroke_seq_frame_bg { 0.3f, 0.28f, 0.1f, 0.7f };
		ImVec4 stroke_seq_frame_bg_hovered { 0.4f, 0.38f, 0.15f, 0.8f };
		ImVec4 stroke_seq_frame_bg_active { 0.5f, 0.48f, 0.2f, 0.9f };
		
		struct FrequencyGraphColors
		{
			ImU32 background { IM_COL32(20, 22, 24, 255) };
			ImU32 grid { IM_COL32(50, 55, 60, 255) };
			ImU32 label { IM_COL32(150, 150, 150, 255) };
			ImU32 peak_line { IM_COL32(255, 150, 80, 150) };
			ImU32 live_line { IM_COL32(120, 170, 255, 220) };
			ImU32 border { IM_COL32(80, 80, 80, 255) };
			ImU32 threshold { IM_COL32(255, 100, 100, 150) };
		} frequency_graph;
		
		struct PhysicsColors
		{
			ImVec4 sandbox_title { 0.3f, 0.9f, 1.0f, 1.0f };
			ImVec4 stroke_label { 0.9f, 0.9f, 0.5f, 1.0f };
			ImVec4 physics_section { 0.7f, 0.9f, 0.7f, 1.0f };
			ImVec4 spawn_section { 0.5f, 0.9f, 1.0f, 1.0f };
			ImVec4 count_ok { 0.6f, 0.9f, 0.6f, 1.0f };
			ImVec4 count_warn { 1.0f, 0.9f, 0.4f, 1.0f };
			ImVec4 count_alert { 1.0f, 0.4f, 0.4f, 1.0f };
			ImVec4 stroke_metal { 0.53f, 0.81f, 0.92f, 1.0f };
			ImVec4 stroke_wood { 0.96f, 0.64f, 0.38f, 1.0f };
			ImVec4 stroke_soil { 0.0f, 0.39f, 0.0f, 1.0f };
			ImVec4 stroke_conveyor { 0.58f, 0.44f, 0.86f, 1.0f };
			ImVec4 stroke_bouncy { 0.0f, 0.98f, 0.6f, 1.0f };
			ImVec4 stroke_sticky { 0.54f, 0.27f, 0.07f, 1.0f };
			ImVec4 stroke_emitter { 1.0f, 0.84f, 0.0f, 1.0f };
			ImVec4 spawn_ball { 1.0f, 0.4f, 0.4f, 1.0f };
			ImVec4 spawn_square { 0.4f, 1.0f, 0.4f, 1.0f };
			ImVec4 spawn_triangle { 0.4f, 0.4f, 1.0f, 1.0f };
			ImVec4 spawn_vortex { 0.7f, 0.4f, 1.0f, 1.0f };
			ImVec4 spawn_clear { 0.6f, 0.2f, 0.2f, 0.8f };
			ImVec4 spawn_clear_hover { 0.8f, 0.3f, 0.3f, 1.0f };
			ImVec4 spawn_clear_active { 1.0f, 0.4f, 0.4f, 1.0f };
			ImVec4 canvas_background { 0.12f, 0.12f, 0.12f, 1.0f };
			ImVec4 canvas_border { 0.39f, 0.39f, 0.39f, 1.0f };
			ImVec4 drag_indicator_fill { 1.0f, 1.0f, 0.0f, 0.4f };
			ImVec4 drag_indicator_outline { 1.0f, 1.0f, 0.0f, 0.8f };
			ImVec4 eraser_fill { 1.0f, 0.39f, 0.39f, 0.24f };
			ImVec4 eraser_outline { 0.86f, 0.08f, 0.08f, 0.7f };
			ImVec4 crosshair_idle { 1.0f, 1.0f, 1.0f, 0.5f };
			ImVec4 crosshair_active { 1.0f, 1.0f, 0.0f, 1.0f };
			ImVec4 magnet_north { 1.0f, 0.39f, 0.39f, 0.78f };
			ImVec4 magnet_south { 0.39f, 0.39f, 1.0f, 0.78f };
			ImVec4 magnet_link { 1.0f, 1.0f, 0.0f, 0.78f };
			ImVec4 vector_outline { 1.0f, 1.0f, 1.0f, 0.78f };
			ImVec4 vector_fill { 1.0f, 1.0f, 1.0f, 0.6f };
			ImVec4 soil_detail { 0.55f, 0.27f, 0.07f, 0.7f };
			ImVec4 overlay_text { 0.0f, 0.0f, 0.0f, 0.78f };
			ImVec4 overlay_line { 1.0f, 1.0f, 1.0f, 0.5f };
			ImVec4 separator_line { 1.0f, 0.84f, 0.0f, 0.78f };
		} physics;
		
		// PanVol module settings
		float panvol_node_width { 180.0f };  // Custom compact width (default 180px)
		ImU32 panvol_grid_background { IM_COL32(20, 20, 20, 255) };
		ImU32 panvol_grid_border { IM_COL32(100, 100, 100, 255) };
		ImU32 panvol_grid_lines { IM_COL32(50, 50, 50, 255) };
		ImU32 panvol_crosshair { IM_COL32(80, 80, 80, 200) };
		ImU32 panvol_circle_manual { IM_COL32(255, 200, 100, 255) };  // Orange when manual
		ImU32 panvol_circle_modulated { IM_COL32(100, 200, 255, 255) };  // Cyan when modulated
		ImU32 panvol_label_text { IM_COL32(150, 150, 150, 200) };
		ImU32 panvol_value_text { IM_COL32(100, 100, 100, 120) };
	} modules;
};





================================================================================
FILE: juce/Source/preset_creator/theme/ThemeManager.h
================================================================================

#pragma once

#include <juce_core/juce_core.h>
#include <imgui.h>
#include <atomic>
#include <cmath>
#include "Theme.h"

class ThemeManager
{
public:
	static ThemeManager& getInstance();

	bool loadTheme(const juce::File& themeFile);
	bool saveTheme(const juce::File& themeFile);
	void applyTheme();
	void resetToDefault();
	void applyFonts(ImGuiIO& io);
	void requestFontReload();
	bool consumeFontReloadRequest();
	void rebuildFontsNow();
	
	// Persistence
	void saveUserThemePreference(const juce::String& themeFilename);
	bool loadUserThemePreference();

	const Theme& getCurrentTheme() const;
	Theme& getEditableTheme();  // For theme editor - returns mutable reference
	juce::String getCurrentThemeFilename() const { return m_currentThemeFilename; }  // Get filename of currently loaded theme

	// Colors
	ImU32 getCategoryColor(ModuleCategory cat, bool hovered = false);
	ImU32 getPinColor(PinDataType type);
	ImU32 getPinConnectedColor();
	ImU32 getPinDisconnectedColor();
	ImU32 getCategoryColor(ModuleCategory category) const;

	// Layout
	float getSidebarWidth() const;
	float getNodeDefaultWidth() const;
	float getWindowPadding() const;
	
	// Canvas
	ImU32 getCanvasBackground() const;
	ImU32 getGridColor() const;
	ImU32 getGridOriginColor() const;
	float getGridSize() const;
	ImU32 getScaleTextColor() const;
	float getScaleInterval() const;
	ImU32 getDropTargetOverlay() const;
	ImU32 getMousePositionText() const;
	ImU32 getSelectionRect() const;
	ImU32 getSelectionRectOutline() const;
	
	// Node styling
	ImU32 getNodeBackground() const;
	ImU32 getNodeFrame() const;
	ImU32 getNodeFrameHovered() const;
	ImU32 getNodeFrameSelected() const;
	float getNodeRounding() const;
	float getNodeBorderWidth() const;

private:
	ThemeManager();
	~ThemeManager() = default;
	ThemeManager(const ThemeManager&) = delete;
	ThemeManager& operator=(const ThemeManager&) = delete;
	ThemeManager(ThemeManager&&) = delete;
	ThemeManager& operator=(ThemeManager&&) = delete;

	void loadDefaultTheme();
	void applyImGuiStyle();

	// JSON helpers
	static juce::var colorToVar(ImU32 c);
	static ImU32 varToColor(const juce::var& v, ImU32 fallback);
	static juce::var vec4ToVar(const ImVec4& v);
	static ImVec4 varToVec4(const juce::var& v, const ImVec4& fallback);

	static juce::String moduleCategoryToString(ModuleCategory c);
	static bool stringToModuleCategory(const juce::String& s, ModuleCategory& out);
	static juce::String pinTypeToString(PinDataType t);
	static bool stringToPinType(const juce::String& s, PinDataType& out);

	Theme currentTheme;
	Theme defaultTheme;
	juce::String m_currentThemeFilename;  // Filename of currently loaded theme (empty if default)

	std::atomic<bool> fontReloadPending { false };
};

/**
 * A theme-aware replacement for ImGui::TextColored.
 * It automatically applies a text glow/shadow if enabled in the theme.
 */
inline void ThemeText(const char* text, ImVec4 color)
{
	const auto& theme = ThemeManager::getInstance().getCurrentTheme();

	if (theme.text.enable_text_glow)
	{
		// --- DRAW GLOW/SHADOW ---
		// Get the current cursor, draw the shadows offset,
		// then reset the cursor to draw the main text on top.
		
		ImVec2 pos = ImGui::GetCursorPos();
		ImVec4 glowColor = theme.text.text_glow_color;

		ImGui::PushStyleColor(ImGuiCol_Text, glowColor);
		
		// Draw 4 shadow layers for a soft "glow" effect.
		// We must use ImGui::TextUnformatted and handle newlines
		// manually to prevent formatting issues with ImGui::Text.
		ImGui::SetCursorPos(ImVec2(pos.x - 1, pos.y)); ImGui::TextUnformatted(text);
		ImGui::SetCursorPos(ImVec2(pos.x + 1, pos.y)); ImGui::TextUnformatted(text);
		ImGui::SetCursorPos(ImVec2(pos.x, pos.y - 1)); ImGui::TextUnformatted(text);
		ImGui::SetCursorPos(ImVec2(pos.x, pos.y + 1)); ImGui::TextUnformatted(text);

		ImGui::PopStyleColor();

		// Reset cursor to the original position
		ImGui::SetCursorPos(pos);
	}
	
	// --- DRAW MAIN TEXT ---
	// This draws the main text and advances the cursor normally.
	ImGui::PushStyleColor(ImGuiCol_Text, color);
	ImGui::TextUnformatted(text); // Use TextUnformatted for consistency
	ImGui::PopStyleColor();
}

/**
 * Overload for non-colored text (uses default theme text color)
 */
inline void ThemeText(const char* text)
{
	// Get the default text color from ImGui style settings
	ImVec4 defaultColor = ImGui::GetStyle().Colors[ImGuiCol_Text];
	ThemeText(text, defaultColor);
}

/**
 * Utility functions for automatic text color adjustment based on background luminance.
 * Implements WCAG 2.1 relative luminance calculation for accessibility.
 */
namespace ThemeUtils
{
	/**
	 * Calculate relative luminance of a color using WCAG 2.1 formula.
	 * Returns a value between 0.0 (black) and 1.0 (white).
	 * 
	 * @param color ImU32 color in format IM_COL32(R, G, B, A)
	 * @return Relative luminance (0.0 = darkest, 1.0 = lightest)
	 */
	inline float calculateRelativeLuminance(ImU32 color)
	{
		// Extract RGB components (ImU32 is typically ARGB or RGBA depending on endianness)
		// ImGui uses IM_COL32(R, G, B, A) which creates RGBA format
		ImVec4 rgba = ImGui::ColorConvertU32ToFloat4(color);
		
		// Convert sRGB to linear RGB (gamma correction)
		auto toLinear = [](float c) -> float
		{
			if (c <= 0.04045f)
				return c / 12.92f;
			return std::pow((c + 0.055f) / 1.055f, 2.4f);
		};
		
		float r = toLinear(rgba.x);
		float g = toLinear(rgba.y);
		float b = toLinear(rgba.z);
		
		// Calculate relative luminance using WCAG 2.1 coefficients
		// These weights account for human eye sensitivity to different colors
		return 0.2126f * r + 0.7152f * g + 0.0722f * b;
	}
	
	/**
	 * Calculate contrast ratio between two colors using WCAG 2.1 formula.
	 * Returns a value >= 1.0, where higher values indicate better contrast.
	 * WCAG AA requires 4.5:1 for normal text, 3:1 for large text.
	 * 
	 * @param color1 First color (lighter should be first for accurate ratio)
	 * @param color2 Second color (darker should be second)
	 * @return Contrast ratio (1.0 = no contrast, 21.0 = maximum contrast)
	 */
	inline float calculateContrastRatio(ImU32 color1, ImU32 color2)
	{
		float l1 = calculateRelativeLuminance(color1);
		float l2 = calculateRelativeLuminance(color2);
		
		// Ensure lighter color is first
		if (l1 < l2)
		{
			float temp = l1;
			l1 = l2;
			l2 = temp;
		}
		
		// WCAG contrast ratio formula: (L1 + 0.05) / (L2 + 0.05)
		return (l1 + 0.05f) / (l2 + 0.05f);
	}
	
	/**
	 * Get optimal text color (black or white) for a given background color.
	 * Uses contrast ratio calculation to ensure WCAG-compliant legibility.
	 * Chooses the text color (black or white) that provides the best contrast.
	 * 
	 * @param backgroundColor Background color in ImU32 format
	 * @param minContrast Minimum contrast ratio required (default 4.5 for WCAG AA)
	 * @return IM_COL32(0, 0, 0, 255) for black text, IM_COL32(255, 255, 255, 255) for white text
	 */
	inline ImU32 getOptimalTextColor(ImU32 backgroundColor, float minContrast = 4.5f)
	{
		// Define pure black and white
		const ImU32 blackText = IM_COL32(0, 0, 0, 255);
		const ImU32 whiteText = IM_COL32(255, 255, 255, 255);
		
		// Calculate contrast ratios for both text color options
		// calculateContrastRatio ensures lighter color is first, so order doesn't matter
		float contrastWithBlack = calculateContrastRatio(backgroundColor, blackText);
		float contrastWithWhite = calculateContrastRatio(whiteText, backgroundColor);
		
		// Choose the option with better contrast
		// This handles edge cases like bright yellow where white text has poor contrast
		if (contrastWithBlack >= contrastWithWhite)
		{
			// Black text provides better or equal contrast
			// This will be chosen for light backgrounds (yellow, light green, etc.)
			return blackText;
		}
		else
		{
			// White text provides better contrast
			// This will be chosen for dark backgrounds
			return whiteText;
		}
	}
}





================================================================================
FILE: USER_MANUAL/Nodes_Dictionary.md
================================================================================

# Collider Modular Synthesizer - Node Dictionary

**Last Updated:** December 18, 2024  
**Version:** 1.2

---

## Table of Contents

### Quick Reference Index

#### 1. SOURCE NODES
- [vco](#vco) - Voltage-Controlled Oscillator
- [polyvco](#polyvco) - Multi-Voice Oscillator Bank
- [noise](#noise) - Noise Generator
- [audio_input](#audio_input) - Hardware Audio Input
- [sample_loader](#sample_loader) - Audio Sample Player
- [value](#value) - Constant Value Generator

#### 2. EFFECT NODES
- [vcf](#vcf) - Voltage-Controlled Filter
- [delay](#delay) - Stereo Delay Effect
- [reverb](#reverb) - Stereo Reverb Effect
- [chorus](#chorus) - Stereo Chorus Effect
- [phaser](#phaser) - Stereo Phaser Effect
- [compressor](#compressor) - Dynamic Range Compressor
- [limiter](#limiter) - Audio Limiter
- [gate](#gate) - Noise Gate
- [drive](#drive) - Waveshaping Distortion
- [graphic_eq](#graphic_eq) - 8-Band Graphic Equalizer
- [waveshaper](#waveshaper) - Multi-Algorithm Waveshaper
- [8bandshaper](#8bandshaper) - Multi-Band Waveshaper
- [granulator](#granulator) - Granular Synthesizer/Effect
- [harmonic_shaper](#harmonic_shaper) - Harmonic Content Shaper
- [timepitch](#timepitch) - Time/Pitch Manipulation
- [de_crackle](#de_crackle) - Click/Pop Reducer
- [vocal_tract_filter](#vocal_tract_filter) - Formant Filter

#### 3. MODULATOR NODES
- [lfo](#lfo) - Low-Frequency Oscillator
- [adsr](#adsr) - Envelope Generator
- [random](#random) - Random Value Generator
- [s_and_h](#s_and_h) - Sample & Hold
- [function_generator](#function_generator) - Drawable Envelope/LFO
- [shaping_oscillator](#shaping_oscillator) - Oscillator with Built-in Waveshaper

#### 4. UTILITY & LOGIC NODES
- [vca](#vca) - Voltage-Controlled Amplifier
- [mixer](#mixer) - Stereo Audio Mixer
- [cv_mixer](#cv_mixer) - Control Voltage Mixer
- [track_mixer](#track_mixer) - Multi-Channel Mixer
- [panvol](#panvol) - 2D Volume and Panning Control
- [attenuverter](#attenuverte

================================================================================
IMPLEMENTATION PLAN
================================================================================

1. DETECT SECTION TYPES:
   - Parse level 3 headers to identify section type
   - Map headers to section types: Description, Inputs, Outputs, Parameters, How to Use
   - Track current section while rendering

2. COLOR SCHEME:
   - Description: Subtle background (maybe light tint of category color or neutral)
   - Inputs: Color related to CV/input signals (could use PinDataType::CV color)
   - Outputs: Color related to audio/output signals (could use PinDataType::Audio color)
   - Parameters: Color related to controls (maybe FrameBg or ButtonBg variant)
   - How to Use: Tutorial/guide color (maybe accent color with low opacity)

3. RENDERING APPROACH:
   - Use ImGui::BeginChild() with background color for each section
   - Or use ImGui::PushStyleColor(ImGuiCol_ChildBg) before rendering section content
   - Apply padding and rounding for visual separation
   - Ensure text contrast is maintained

4. THEME INTEGRATION:
   - Use ThemeManager colors where possible
   - Use ImGui style colors (FrameBg, ButtonBg, etc.) as fallback
   - Ensure colors work with both light and dark themes

================================================================================
KEY QUESTIONS
================================================================================

1. Which theme colors should be used for each section type?
2. Should sections have borders or just background colors?
3. How much padding/spacing between sections?
4. Should the background color be subtle or prominent?
5. How to handle sections that span multiple paragraphs?

================================================================================
END OF CONTEXT BUNDLE
================================================================================
