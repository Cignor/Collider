================================================================================
CONTEXT BUNDLE: F1 Key Node Help Feature - Tab Selection Issue
================================================================================
Generated: 2025-11-14 09:18:31
Purpose: External expert consultation on programmatic tab selection in ImGui

================================================================================
PROBLEM STATEMENT
================================================================================

CURRENT TASK:
We need to implement a feature where:
1. User selects a node in the node editor
2. User presses F1 key
3. Help Manager opens to the "Node Dictionary" tab (index 1)
4. Help Manager scrolls to and displays the help entry for that specific node

CURRENT PROBLEM:
The tab selection mechanism is not working correctly. When F1 is pressed with a 
node selected:
- The Help Manager window opens correctly
- The code sets m_currentTab = 1 and m_shouldSetTab = true
- The scroll anchor is set correctly
- BUT the window always shows the "Shortcuts" tab (index 0) instead of 
  "Node Dictionary" tab (index 1)

ROOT CAUSE:
ImGui's BeginTabItem() with ImGuiTabItemFlags_SetSelected doesn't work when:
- The target tab is not the first tab rendered
- The tab bar already exists (not the first frame)
- ImGui defaults to selecting the first tab rendered, ignoring SetSelected on later tabs

REQUIREMENTS:
1. F1 with no node selected â†’ Open Help Manager to Shortcuts tab (index 0) âœ“ (works)
2. F1 with node selected â†’ Open Help Manager to Node Dictionary tab (index 1) âœ— (broken)
3. Users must be able to click tabs normally at all times âœ“ (works after revert)
4. Tab selection must work reliably on first window open âœ— (broken)

================================================================================
CURRENT IMPLEMENTATION FLOW
================================================================================

1. USER ACTION: Selects a node and presses F1

2. SHORTCUT HANDLER (ImGuiNodeEditorComponent.cpp:510-534):
   - Checks if a node is selected using ImNodes::NumSelectedNodes()
   - Gets the selected node's logical ID
   - Calls synth->getModuleTypeForLogical(logicalId) to get module type (e.g., "vco", "track_mixer")
   - Calls m_helpManager.openToNode(moduleType)

3. openToNode() METHOD (HelpManagerComponent.cpp:123-146):
   - Calls open() to set m_isOpen = true
   - Calls setActiveTab(1) which sets m_currentTab = 1 and m_shouldSetTab = true
   - Converts module type to anchor format (e.g., "track_mixer" â†’ "track-mixer")
   - Sets scrollToAnchor for later scrolling
   - Loads the Node Dictionary markdown file if not already loaded

4. RENDER LOOP (HelpManagerComponent.cpp:161-214):
   - Creates tab bar with ImGui::BeginTabBar("HelpTabs")
   - Renders "Shortcuts" tab first (index 0) - NO SetSelected flag
   - Renders "Node Dictionary" tab second (index 1) - WITH SetSelected flag if m_shouldSetTab && m_currentTab == 1
   - PROBLEM: ImGui selects the first tab (Shortcuts) by default, ignoring SetSelected on second tab

================================================================================
KEY CODE SECTIONS
================================================================================


================================================================================
FILE: juce/Source/preset_creator/HelpManagerComponent.h
================================================================================

#pragma once

#include <juce_core/juce_core.h>
#include <imgui.h>
#include "ShortcutManager.h" // We need this for the capture state and manager reference

// Forward declaration
class ImGuiNodeEditorComponent;

/**
 * @class HelpManagerComponent
 * Manages the non-modal, tabbed Help window.
 *
 * This component consolidates:
 * 1. Shortcut Editor (migrated from ImGuiNodeEditorComponent)
 * 2. Node Dictionary (Markdown renderer)
 * 3. Getting Started (Markdown renderer)
 * 4. About Page
 *
 * It follows the same self-contained window pattern as ThemeEditorComponent.
 */
class HelpManagerComponent
{
public:
    HelpManagerComponent(ImGuiNodeEditorComponent* parent);
    ~HelpManagerComponent() = default;

    // === Public API ===
    void render();
    void open();
    void close();
    bool isOpen() const { return m_isOpen; }

    /**
     * @brief Sets the currently active tab by its index.
     * 0 = Shortcuts, 1 = Node Dictionary, 2 = Getting Started, 3 = FAQ, 4 = About
     * This is used by external triggers (like F1 or context menus) to
     * open the manager to a specific tab.
     * @param tabIndex The index of the tab to select.
     */
    void setActiveTab(int tabIndex) 
    { 
        m_currentTab = tabIndex; 
        m_shouldSetTab = true; // Flag that we want to programmatically set this tab
    }
    
    /**
     * @brief Opens the Help Manager to the Node Dictionary tab and scrolls to a specific node.
     * @param nodeAnchor The anchor of the node to scroll to (e.g., "vco", "track-mixer").
     *                   The anchor should match the format used in the markdown file.
     */
    void openToNode(const juce::String& nodeAnchor);

private:
    // === Window State ===
    bool m_isOpen = false;
    int m_currentTab = 0; // 0:Shortcuts, 1:Dictionary, 2:GettingStarted, 3:FAQ, 4:About
    bool m_shouldSetTab = false; // Flag to programmatically set tab (e.g., from F1)
    ImGuiNodeEditorComponent* parentEditor = nullptr;
    collider::ShortcutManager& shortcutManager;

    // === Tab Rendering Functions ===
    void renderShortcutsTab();
    void renderNodeDictionaryTab();
    void renderGettingStartedTab();
    void renderFaqTab();
    void renderAboutTab();

    // === Markdown Parsing & Rendering (for Node Dictionary and Getting Started) ===
    struct MarkdownSection
    {
        juce::String title;
        int level; // 1 = ##, 2 = ###, 3 = ####
        juce::String content; // Text content before subsections
        std::vector<MarkdownSection> children;
        juce::String anchor; // For anchor links (e.g., #vco)
        
        // Helper to check if this section or any child matches search
        bool matchesSearch(const juce::String& searchTerm) const;
        
        // Helper to check if this section or any child contains the given anchor
        bool containsAnchor(const juce::String& targetAnchor) const;
    };

    // Node Dictionary state
    juce::String nodeDictionarySearchTerm;
    std::vector<MarkdownSection> nodeDictionarySections;
    bool nodeDictionaryLoaded = false;
    juce::File nodeDictionaryFile;

    // Getting Started state
    juce::String gettingStartedSearchTerm;
    std::vector<MarkdownSection> gettingStartedSections;
    bool gettingStartedLoaded = false;
    juce::File gettingStartedFile;

    // FAQ state
    juce::String faqSearchTerm;
    std::vector<MarkdownSection> faqSections;
    bool faqLoaded = false;
    juce::File faqFile;

    // Markdown parsing functions
    void loadNodeDictionary();
    void loadGettingStarted();
    void loadFaq();
    void parseMarkdown(const juce::String& content, std::vector<MarkdownSection>& sections);
    void renderMarkdownSection(const MarkdownSection& section, const juce::String& searchTerm, bool parentMatches = true, bool forceExpand = false);
    void renderMarkdownText(const juce::String& text);
    void renderFormattedText(const juce::String& text); // Renders text with inline formatting (bold, code)
    juce::String extractAnchor(const juce::String& headerLine);
    
    // Helper to get category color from section title
    ImU32 getCategoryColorForSection(const juce::String& sectionTitle) const;
    
    // Helper to scroll to anchor (stores anchor to scroll to)
    juce::String scrollToAnchor;
    bool scrollToSectionIfNeeded(const juce::String& anchor);
    
    // Split-pane navigation state
    struct NavigationItem
    {
        juce::String title;
        juce::String anchor;
        int level; // Indentation level
        bool isCategory; // True for category headers (like "SOURCE NODES")
    };
    std::vector<NavigationItem> nodeDictionaryNavItems; // Flattened navigation list
    void buildNavigationList(const std::vector<MarkdownSection>& sections, std::vector<NavigationItem>& navItems, int level = 0);
    void renderNavigationSidebar(const std::vector<NavigationItem>& navItems, const juce::String& searchTerm);
    void renderNodeDictionaryContent(const std::vector<MarkdownSection>& sections, const juce::String& searchTerm);
    std::unordered_map<juce::String, float> sectionScrollPositions; // Anchor -> scroll position
    float findSectionScrollPosition(const juce::String& anchor, const std::vector<MarkdownSection>& sections, float currentPos = 0.0f);

    // === START: State Migrated from ImGuiNodeEditorComponent ===
    // This state is moving here to make the Help Manager self-contained.
    juce::String shortcutsSearchTerm;
    juce::Identifier shortcutContextSelection;
    bool shortcutsDirty { false };
    juce::File defaultShortcutFile;
    juce::File userShortcutFile;

    // Struct for shortcut capture state
    struct ShortcutCaptureState
    {
        bool isCapturing { false };
        juce::Identifier actionId;
        juce::Identifier context;
        collider::KeyChord captured;
        bool hasCaptured { false };
        juce::Identifier conflictActionId;
        juce::Identifier conflictContextId;
        bool conflictIsUserBinding { false };
    };

    ShortcutCaptureState shortcutCaptureState;

    // Helper functions for the shortcut editor
    void renderShortcutEditorTable(const juce::Identifier& context);
    void renderShortcutRow(const collider::ShortcutAction& action,
                           const juce::Identifier& actionId,
                           const juce::Identifier& context,
                           bool categoryChanged);
    void renderShortcutCapturePanel();
    void beginShortcutCapture(const juce::Identifier& actionId, const juce::Identifier& context);
    void updateShortcutCapture();
    void cancelShortcutCapture();
    void applyShortcutCapture(bool forceReplace);
    void evaluateShortcutCaptureConflict();
    void clearShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context);
    void resetShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context);
    void saveUserShortcutBindings();
    juce::String getBindingLabelForContext(const juce::Identifier& actionId,
                                           const juce::Identifier& context,
                                           juce::String& sourceLabel) const;
    // === END: State Migrated from ImGuiNodeEditorComponent ===
};




================================================================================
FILE: juce/Source/preset_creator/HelpManagerComponent.cpp
================================================================================

#include "HelpManagerComponent.h"

#include "ImGuiNodeEditorComponent.h" // Required for parentEditor
#include "theme/ThemeManager.h"      // For themed colors (includes Theme.h with ModuleCategory)
#include "PresetCreatorApplication.h"  // For app properties
#include "NotificationManager.h"     // For notification posting
#include <juce_gui_basics/juce_gui_basics.h>
#include <imgui_internal.h> // For IsKeyPressed
#include <vector>
#include <unordered_map>
#include <functional>
#include <algorithm>

// Helper copied from ImGuiNodeEditorComponent.cpp
namespace
{
    [[nodiscard]] juce::String contextDisplayName(const juce::Identifier& contextId)
    {
        if (contextId == collider::ShortcutManager::getGlobalContextIdentifier())
            return "Global";
        if (contextId == ImGuiNodeEditorComponent::nodeEditorContextId)
            return "Node Editor";
        return contextId.toString();
    }

    [[nodiscard]] bool chordsEqual(const collider::KeyChord& a, const collider::KeyChord& b) noexcept
    {
        return a.key == b.key && a.ctrl == b.ctrl && a.shift == b.shift &&
               a.alt == b.alt && a.superKey == b.superKey;
    }
}

HelpManagerComponent::HelpManagerComponent(ImGuiNodeEditorComponent* parent)
    : parentEditor(parent),
      shortcutManager(collider::ShortcutManager::getInstance()),
      shortcutContextSelection(ImGuiNodeEditorComponent::nodeEditorContextId)
{
    // === LOGIC MOVED FROM ImGuiNodeEditorComponent CONSTRUCTOR ===
    // This logic now lives here, making the Help Manager responsible
    // for finding and loading its own shortcut files.
    auto executable = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
    auto exeDir = executable.getParentDirectory();
    auto assetsDir = exeDir.getChildFile("assets");
    defaultShortcutFile = assetsDir.getChildFile("default_shortcuts.json");
    if (defaultShortcutFile.existsAsFile())
        shortcutManager.loadDefaultBindingsFromFile(defaultShortcutFile);
    else
        juce::Logger::writeToLog("[HelpManager] WARNING: Default shortcuts file not found at: " + defaultShortcutFile.getFullPathName());

    juce::File userSettingsDir;
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
        userSettingsDir = props->getFile().getParentDirectory();
    else
        userSettingsDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory).getChildFile("Collider");

    if (!userSettingsDir.isDirectory())
        userSettingsDir.createDirectory();

    userShortcutFile = userSettingsDir.getChildFile("user_shortcuts.json");
    shortcutManager.loadUserBindingsFromFile(userShortcutFile);
    
    // Initialize documentation file paths
    // Try multiple locations: next to executable, or in project root
    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
    auto appDir = appFile.getParentDirectory();
    auto userManualDir = appDir.getChildFile("USER_MANUAL");
    
    nodeDictionaryFile = userManualDir.getChildFile("Nodes_Dictionary.md");
    gettingStartedFile = userManualDir.getChildFile("Getting_Started.md");
    faqFile = userManualDir.getChildFile("FAQ.md");
    
    // Fallback: try project root (for development)
    auto projectRoot = appDir.getParentDirectory(); // Go up one level from executable
    auto fallbackUserManualDir = projectRoot.getChildFile("USER_MANUAL");
    
    if (!nodeDictionaryFile.existsAsFile())
    {
        auto fallbackFile = fallbackUserManualDir.getChildFile("Nodes_Dictionary.md");
        if (fallbackFile.existsAsFile())
            nodeDictionaryFile = fallbackFile;
    }
    
    if (!gettingStartedFile.existsAsFile())
    {
        auto fallbackFile = fallbackUserManualDir.getChildFile("Getting_Started.md");
        if (fallbackFile.existsAsFile())
            gettingStartedFile = fallbackFile;
    }
    
    if (!faqFile.existsAsFile())
    {
        auto fallbackFile = fallbackUserManualDir.getChildFile("FAQ.md");
        if (fallbackFile.existsAsFile())
            faqFile = fallbackFile;
    }
    
    juce::Logger::writeToLog("[HelpManager] Initialized and loaded shortcut files.");
    // === END OF MOVED LOGIC ===
}

void HelpManagerComponent::open()
{
    m_isOpen = true;
}

void HelpManagerComponent::close()
{
    // On close, save any dirty shortcuts
    if (shortcutsDirty)
    {
        saveUserShortcutBindings();
    }
    
    // Cancel any pending capture
    if (shortcutCaptureState.isCapturing)
    {
        cancelShortcutCapture();
    }
    
    m_isOpen = false;
}

void HelpManagerComponent::openToNode(const juce::String& nodeAnchor)
{
    // Open the Help Manager
    open();
    
    // Set to Node Dictionary tab (index 1)
    setActiveTab(1);
    
    // Set the scroll target anchor
    // Convert module type format (e.g., "track_mixer") to anchor format (e.g., "track-mixer")
    juce::String anchor = nodeAnchor.toLowerCase();
    anchor = anchor.replace("_", "-");
    scrollToAnchor = anchor;
    
    // Ensure the dictionary is loaded
    if (!nodeDictionaryLoaded)
    {
        loadNodeDictionary();
        if (!nodeDictionarySections.empty())
        {
            buildNavigationList(nodeDictionarySections, nodeDictionaryNavItems);
        }
    }
}

void HelpManagerComponent::render()
{
    if (!m_isOpen)
        return;

    // Set default window size
    ImGui::SetNextWindowSize(ImVec2(900, 700), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);
    
    // Ensure window is fully opaque (uses WindowBg from theme)
    ImGui::SetNextWindowBgAlpha(1.0f);
    if (ImGui::Begin("Help Manager", &m_isOpen, ImGuiWindowFlags_None))
    {
        if (ImGui::BeginTabBar("HelpTabs"))
        {
            // --- Tab 1: Shortcuts ---
            if (ImGui::BeginTabItem("Shortcuts"))
            {
                m_currentTab = 0;
                if (m_shouldSetTab && m_currentTab == 0)
                    m_shouldSetTab = false;
                renderShortcutsTab();
                ImGui::EndTabItem();
            }

            // --- Tab 2: Node Dictionary ---
            bool shouldSelectDictionary = m_shouldSetTab && m_currentTab == 1;
            if (ImGui::BeginTabItem("Node Dictionary", nullptr, (shouldSelectDictionary ? ImGuiTabItemFlags_SetSelected : 0)))
            {
                m_currentTab = 1;
                if (shouldSelectDictionary)
                    m_shouldSetTab = false;
                renderNodeDictionaryTab();
                ImGui::EndTabItem();
            }

            // --- Tab 3: Getting Started ---
            if (ImGui::BeginTabItem("Getting Started"))
            {
                m_currentTab = 2;
                if (m_shouldSetTab && m_currentTab == 2)
                    m_shouldSetTab = false;
                renderGettingStartedTab();
                ImGui::EndTabItem();
            }

            // --- Tab 4: FAQ ---
            if (ImGui::BeginTabItem("FAQ"))
            {
                m_currentTab = 3;
                if (m_shouldSetTab && m_currentTab == 3)
                    m_shouldSetTab = false;
                renderFaqTab();
                ImGui::EndTabItem();
            }

            // --- Tab 5: About ---
            if (ImGui::BeginTabItem("About"))
            {
                m_currentTab = 4;
                if (m_shouldSetTab && m_currentTab == 4)
                    m_shouldSetTab = false;
                renderAboutTab();
                ImGui::EndTabItem();
            }

            ImGui::EndTabBar();
        }
    }
    ImGui::End();

    // If window "X" was clicked, handle shutdown
    if (!m_isOpen)
    {
        close();
    }
}

// === STUBBED TABS (To be implemented in later phases) ===

void HelpManagerComponent::renderNodeDictionaryTab()
{
    // Lazy load the markdown file on first open
    if (!nodeDictionaryLoaded)
    {
        loadNodeDictionary();
        // Build navigation list after loading
        if (!nodeDictionarySections.empty())
        {
            buildNavigationList(nodeDictionarySections, nodeDictionaryNavItems);
        }
    }

    // Search bar
    char searchBuffer[256] = {};
    std::strncpy(searchBuffer, nodeDictionarySearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(-1);
    if (ImGui::InputTextWithHint("##node-dict-search", "Search nodes...", searchBuffer, sizeof(searchBuffer)))
    {
        nodeDictionarySearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    ImGui::Spacing();

    // Split-pane layout: left sidebar (navigation) + right content
    float sidebarWidth = 280.0f;
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    float availableWidth = window->ContentRegionRect.GetWidth();
    float contentWidth = availableWidth - sidebarWidth - ImGui::GetStyle().ItemSpacing.x;

    // Left sidebar: Navigation list
    if (ImGui::BeginChild("NodeDictionarySidebar", ImVec2(sidebarWidth, 0), true))
    {
        if (nodeDictionarySections.empty())
        {
            ImGui::TextWrapped("Node Dictionary file not found or could not be loaded.");
        }
        else
        {
            renderNavigationSidebar(nodeDictionaryNavItems, nodeDictionarySearchTerm);
        }
    }
    ImGui::EndChild();

    ImGui::SameLine();

    // Right pane: Main content
    if (ImGui::BeginChild("NodeDictionaryContent", ImVec2(contentWidth, 0), false, ImGuiWindowFlags_HorizontalScrollbar))
    {
        if (nodeDictionarySections.empty())
        {
            ImGui::TextWrapped("Node Dictionary file not found or could not be loaded.");
            ImGui::TextWrapped("Expected location: %s", nodeDictionaryFile.getFullPathName().toRawUTF8());
        }
        else
        {
            renderNodeDictionaryContent(nodeDictionarySections, nodeDictionarySearchTerm);
        }
    }
    ImGui::EndChild();
}

void HelpManagerComponent::renderGettingStartedTab()
{
    // Lazy load the markdown file on first open
    if (!gettingStartedLoaded)
    {
        loadGettingStarted();
    }

    // Search bar
    char searchBuffer[256] = {};
    std::strncpy(searchBuffer, gettingStartedSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(-1);
    if (ImGui::InputTextWithHint("##getting-started-search", "Search...", searchBuffer, sizeof(searchBuffer)))
    {
        gettingStartedSearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    ImGui::Spacing();

    // Render the markdown content
    if (ImGui::BeginChild("GettingStartedContent", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar))
    {
        if (gettingStartedSections.empty())
        {
            ImGui::TextWrapped("Getting Started file not found or could not be loaded.");
            ImGui::TextWrapped("Expected location: %s", gettingStartedFile.getFullPathName().toRawUTF8());
        }
        else
        {
            for (const auto& section : gettingStartedSections)
            {
                renderMarkdownSection(section, gettingStartedSearchTerm, true, false);
            }
        }
    }
    ImGui::EndChild();
}

void HelpManagerComponent::renderFaqTab()
{
    // Lazy load the markdown file on first open
    if (!faqLoaded)
    {
        loadFaq();
    }

    // Search bar
    char searchBuffer[256] = {};
    std::strncpy(searchBuffer, faqSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(-1);
    if (ImGui::InputTextWithHint("##faq-search", "Search FAQ...", searchBuffer, sizeof(searchBuffer)))
    {
        faqSearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    ImGui::Spacing();

    // Render the markdown content
    if (ImGui::BeginChild("FaqContent", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar))
    {
        if (faqSections.empty())
        {
            ImGui::TextWrapped("FAQ file not found or could not be loaded.");
            ImGui::TextWrapped("Expected location: %s", faqFile.getFullPathName().toRawUTF8());
        }
        else
        {
            for (const auto& section : faqSections)
            {
                renderMarkdownSection(section, faqSearchTerm, true, false);
            }
        }
    }
    ImGui::EndChild();
}

void HelpManagerComponent::renderAboutTab()
{
    ImGui::Text("Collider Modular Synthesizer");
    ImGui::Text("Version 1.2 (Hypothetical)"); // TODO: Pull this from a central version header
    ImGui::Separator();
    ImGui::TextWrapped("Built with JUCE, Dear ImGui, imnodes, and the Collider Core audio engine.");
    
    ImGui::Spacing();
    ImGui::Spacing();
    
    // Use dummy buttons for link look-and-feel
    if (ImGui::Button("GitHub Repository"))
    {
        juce::URL("https://github.com/Moof-Moof/Collider").launchInDefaultBrowser();
    }
    ImGui::SameLine();
    if (ImGui::Button("Full Documentation"))
    {
        // TODO: Add link to documentation website
    }
}

// === START: CODE MOVED FROM ImGuiNodeEditorComponent.cpp ===
// All this logic is now part of the HelpManagerComponent

void HelpManagerComponent::renderShortcutsTab()
{
    // This is the logic from the old `renderShortcutEditorContents()`
    
    updateShortcutCapture();
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    const juce::Identifier contexts[] = { globalContext, ImGuiNodeEditorComponent::nodeEditorContextId };
    int selectedIndex = (shortcutContextSelection == globalContext) ? 0 : 1;
    ImGui::SetNextItemWidth(250.0f);
    if (ImGui::BeginCombo("Context", contextDisplayName(shortcutContextSelection).toRawUTF8()))
    {
        for (int i = 0; i < 2; ++i)
        {
            const bool isSelected = (selectedIndex == i);
            if (ImGui::Selectable(contextDisplayName(contexts[i]).toRawUTF8(), isSelected))
                shortcutContextSelection = contexts[i];
            if (isSelected)
                ImGui::SetItemDefaultFocus();
        }
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    char searchBuffer[128] = {};
    std::strncpy(searchBuffer, shortcutsSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    ImGui::SetNextItemWidth(300.0f);
    if (ImGui::InputTextWithHint("##shortcut-search", "Search actionsâ€¦", searchBuffer, sizeof(searchBuffer)))
    {
        shortcutsSearchTerm = juce::String(searchBuffer).trim();
    }
    
    ImGui::SameLine();
    if (ImGui::Button("Save Changes"))
    {
        saveUserShortcutBindings();
    }
    if (ImGui::IsItemHovered())
        ImGui::SetTooltip("Saves changes to user_shortcuts.json");
    ImGui::Separator();
    
    if (ImGui::BeginChild("ShortcutTableChild"))
    {
        renderShortcutEditorTable(shortcutContextSelection);
    }
    ImGui::EndChild();
    renderShortcutCapturePanel();
}

void HelpManagerComponent::renderShortcutEditorTable(const juce::Identifier& context)
{
    const auto& registry = shortcutManager.getRegistry();
    std::vector<std::pair<juce::Identifier, collider::ShortcutAction>> actions;
    actions.reserve(registry.size());
    for (const auto& entry : registry)
        actions.emplace_back(entry.first, entry.second);

    std::sort(actions.begin(), actions.end(), [](const auto& a, const auto& b)
    {
        int categoryCompare = a.second.category.compareIgnoreCase(b.second.category);
        if (categoryCompare != 0)
            return categoryCompare < 0;
        return a.second.name.compareIgnoreCase(b.second.name) < 0;
    });

    if (ImGui::BeginTable("shortcut-editor-table", 5, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable | ImGuiTableFlags_Sortable))
    {
        ImGui::TableSetupColumn("Category", ImGuiTableColumnFlags_WidthFixed, 140.0f);
        ImGui::TableSetupColumn("Action", ImGuiTableColumnFlags_WidthStretch);
        ImGui::TableSetupColumn("Binding", ImGuiTableColumnFlags_WidthFixed, 160.0f);
        ImGui::TableSetupColumn("Source", ImGuiTableColumnFlags_WidthFixed, 160.0f);
        ImGui::TableSetupColumn("Options", ImGuiTableColumnFlags_WidthFixed, 200.0f);
        ImGui::TableHeadersRow();

        juce::String previousCategory;
        for (const auto& [actionId, action] : actions)
        {
            if (shortcutsSearchTerm.isNotEmpty())
            {
                const juce::String search = shortcutsSearchTerm;
                if (!action.name.containsIgnoreCase(search)
                    && !action.description.containsIgnoreCase(search)
                    && !action.category.containsIgnoreCase(search))
                {
                    continue;
                }
            }

            const bool categoryChanged = previousCategory != action.category;
            renderShortcutRow(action, actionId, context, categoryChanged);
            previousCategory = action.category;
        }

        ImGui::EndTable();
    }
}

void HelpManagerComponent::renderShortcutRow(const collider::ShortcutAction& action,
                                             const juce::Identifier& actionId,
                                             const juce::Identifier& context,
                                             bool categoryChanged)
{
    ImGui::TableNextRow();
    ImGui::TableSetColumnIndex(0);
    if (categoryChanged)
        ImGui::TextUnformatted(action.category.toRawUTF8());
    ImGui::TableSetColumnIndex(1);
    ImGui::TextUnformatted(action.name.toRawUTF8());
    if (!action.description.isEmpty() && ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::TextUnformatted(action.description.toRawUTF8());
        ImGui::EndTooltip();
    }
    ImGui::TableSetColumnIndex(2);
    juce::String sourceLabel;
    juce::String bindingLabel = getBindingLabelForContext(actionId, context, sourceLabel);
    ImGui::TextUnformatted(bindingLabel.toRawUTF8());
    ImGui::TableSetColumnIndex(3);
    ImGui::TextUnformatted(sourceLabel.toRawUTF8());
    ImGui::TableSetColumnIndex(4);
    juce::String assignId = "Assign##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(assignId.toRawUTF8()))
    {
        beginShortcutCapture(actionId, context);
    }
    ImGui::SameLine();
    juce::String clearId = "Clear##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(clearId.toRawUTF8()))
    {
        clearShortcutForContext(actionId, context);
    }
    ImGui::SameLine();
    juce::String resetId = "Reset##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(resetId.toRawUTF8()))
    {
        resetShortcutForContext(actionId, context);
    }
}

void HelpManagerComponent::renderShortcutCapturePanel()
{
    if (!shortcutCaptureState.isCapturing)
        return;

    // This renders as an overlay
    ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    ImGui::SetNextWindowBgAlpha(0.85f);
    
    if (ImGui::Begin("ShortcutCapture", nullptr, 
                     ImGuiWindowFlags_NoDecoration | 
                     ImGuiWindowFlags_NoMove | 
                     ImGuiWindowFlags_AlwaysAutoResize))
    {
        const auto& registry = shortcutManager.getRegistry();
        juce::String actionName = shortcutCaptureState.actionId.toString();
        if (auto it = registry.find(shortcutCaptureState.actionId); it != registry.end())
            actionName = it->second.name;

        ImGui::Text("Assigning: %s (%s)",
                    actionName.toRawUTF8(),
                    contextDisplayName(shortcutCaptureState.context).toRawUTF8());
        
        ImGui::Separator();
        ImGui::TextUnformatted("Press a key combinationâ€¦ (Esc to cancel)");
        
        ImGui::End();
    }
}

void HelpManagerComponent::beginShortcutCapture(const juce::Identifier& actionId, const juce::Identifier& context)
{
    shortcutCaptureState = {};
    shortcutCaptureState.isCapturing = true;
    shortcutCaptureState.actionId = actionId;
    shortcutCaptureState.context = context;
}

void HelpManagerComponent::updateShortcutCapture()
{
    if (!shortcutCaptureState.isCapturing)
        return;
    if (ImGui::IsKeyPressed(ImGuiKey_Escape, false))
    {
        cancelShortcutCapture();
        return;
    }
    const ImGuiIO& io = ImGui::GetIO();
    for (int keyIndex = ImGuiKey_NamedKey_BEGIN; keyIndex < ImGuiKey_NamedKey_END; ++keyIndex)
    {
        const ImGuiKey key = static_cast<ImGuiKey>(keyIndex);
        if (key >= ImGuiKey_MouseLeft && key <= ImGuiKey_MouseWheelY)
            continue;
        if (key >= ImGuiKey_ReservedForModCtrl)
            continue;
        const ImGuiKeyData* data = ImGui::GetKeyData(key);
        if (data == nullptr)
            continue;
        if (data->Down && data->DownDuration == 0.0f)
        {
            shortcutCaptureState.captured = collider::KeyChord::fromImGui(io, key);
            shortcutCaptureState.hasCaptured = shortcutCaptureState.captured.isValid();
            evaluateShortcutCaptureConflict();
            applyShortcutCapture(true);
            break;
        }
    }
}

void HelpManagerComponent::cancelShortcutCapture()
{
    shortcutCaptureState = {};
}

void HelpManagerComponent::applyShortcutCapture(bool forceReplace)
{
    if (!shortcutCaptureState.isCapturing || !shortcutCaptureState.hasCaptured || !shortcutCaptureState.captured.isValid())
        return;
    const auto& actionId = shortcutCaptureState.actionId;
    const auto& context = shortcutCaptureState.context;
    if (auto userBinding = shortcutManager.getUserBinding(actionId, context))
    {
        if (userBinding->isValid() && chordsEqual(*userBinding, shortcutCaptureState.captured))
        {
            cancelShortcutCapture();
            return;
        }
    }
    if (auto defaultBinding = shortcutManager.getDefaultBinding(actionId, context))
    {
        if (defaultBinding->isValid() && chordsEqual(*defaultBinding, shortcutCaptureState.captured))
        {
            if (shortcutManager.removeUserBinding(actionId, context))
                shortcutsDirty = true;
            cancelShortcutCapture();
            return;
        }
    }
    if (shortcutCaptureState.conflictActionId.isValid())
    {
        if (!forceReplace)
            return;
        clearShortcutForContext(shortcutCaptureState.conflictActionId, shortcutCaptureState.conflictContextId);
    }
    shortcutManager.setUserBinding(actionId, context, shortcutCaptureState.captured);
    shortcutsDirty = true;
    cancelShortcutCapture();
}

void HelpManagerComponent::evaluateShortcutCaptureConflict()
{
    shortcutCaptureState.conflictActionId = {};
    shortcutCaptureState.conflictContextId = {};
    shortcutCaptureState.conflictIsUserBinding = false;
    if (!shortcutCaptureState.hasCaptured || !shortcutCaptureState.captured.isValid())
        return;
    const auto& chord = shortcutCaptureState.captured;
    const auto& targetAction = shortcutCaptureState.actionId;
    const auto& targetContext = shortcutCaptureState.context;
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    const auto& registry = shortcutManager.getRegistry();
    const juce::Identifier contextsToCheck[] = { globalContext, ImGuiNodeEditorComponent::nodeEditorContextId };
    auto isSameChord = [&](const juce::Identifier& actionId, const juce::Identifier& contextId, const juce::Optional<collider::KeyChord>& chordOpt, bool isUser)
    {
        if (!chordOpt.hasValue() || !chordOpt->isValid())
            return false;
        if (!chordsEqual(*chordOpt, chord))
            return false;
        shortcutCaptureState.conflictActionId = actionId;
        shortcutCaptureState.conflictContextId = contextId;
        shortcutCaptureState.conflictIsUserBinding = isUser;
        return true;
    };
    // Ignore if chord matches current binding for this action/context
    auto currentBinding = shortcutManager.getBindingForContext(targetAction, targetContext);
    if (currentBinding.isValid() && chordsEqual(currentBinding, chord))
        return;
    for (const auto& [actionId, action] : registry)
    {
        for (const auto& ctx : contextsToCheck)
        {
            if (ctx != targetContext && targetContext == globalContext && ctx != globalContext)
                continue; // when editing global, only check global + other contexts once
            auto userBinding = shortcutManager.getUserBinding(actionId, ctx);
            if (isSameChord(actionId, ctx, userBinding, true))
                return;
            auto defaultBinding = shortcutManager.getDefaultBinding(actionId, ctx);
            // Only check default if no user override
            if (!userBinding.hasValue())
            {
                if (isSameChord(actionId, ctx, defaultBinding, false))
                    return;
            }
        }
    }
}

void HelpManagerComponent::clearShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context)
{
    collider::KeyChord cleared;
    shortcutManager.setUserBinding(actionId, context, cleared);
    shortcutsDirty = true;
    if (shortcutCaptureState.isCapturing &&
        shortcutCaptureState.actionId == actionId &&
        shortcutCaptureState.context == context)
    {
        cancelShortcutCapture();
    }
}

void HelpManagerComponent::resetShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context)
{
    if (shortcutManager.removeUserBinding(actionId, context))
    {
        shortcutsDirty = true;
    }
    if (shortcutCaptureState.isCapturing &&
        shortcutCaptureState.actionId == actionId &&
        shortcutCaptureState.context == context)
    {
        cancelShortcutCapture();
    }
}

void HelpManagerComponent::saveUserShortcutBindings()
{
    if (userShortcutFile.getFullPathName().isEmpty())
        return;
    auto parent = userShortcutFile.getParentDirectory();
    if (!parent.isDirectory())
        parent.createDirectory();
    shortcutManager.saveUserBindingsToFile(userShortcutFile);
    shortcutsDirty = false;
    NotificationManager::post(NotificationManager::Type::Success, "Shortcut settings saved");
}

juce::String HelpManagerComponent::getBindingLabelForContext(const juce::Identifier& actionId,
                                                             const juce::Identifier& context,
                                                             juce::String& sourceLabel) const
{
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    auto userBinding = shortcutManager.getUserBinding(actionId, context);
    if (userBinding.hasValue())
    {
        if (userBinding->isValid())
        {
            sourceLabel = "User";
            return userBinding->toString();
        }
        sourceLabel = "User (cleared)";
        return "Unassigned";
    }
    auto defaultBinding = shortcutManager.getDefaultBinding(actionId, context);
    if (defaultBinding.hasValue() && defaultBinding->isValid())
    {
        sourceLabel = "Default";
        return defaultBinding->toString();
    }
    if (context != globalContext)
    {
        auto userGlobal = shortcutManager.getUserBinding(actionId, globalContext);
        if (userGlobal.hasValue())
        {
            if (userGlobal->isValid())
            {
                sourceLabel = "Global (user)";
                return userGlobal->toString();
            }
            sourceLabel = "Global (user cleared)";
            return "Unassigned";
        }
        auto defaultGlobal = shortcutManager.getDefaultBinding(actionId, globalContext);
        if (defaultGlobal.hasValue() && defaultGlobal->isValid())
        {
            sourceLabel = "Global (default)";
            return defaultGlobal->toString();
        }
    }
    sourceLabel = "Unassigned";
    return "Unassigned";
}

// === END: CODE MOVED FROM ImGuiNodeEditorComponent.cpp ===

// === MARKDOWN PARSING & RENDERING ===

bool HelpManagerComponent::MarkdownSection::matchesSearch(const juce::String& searchTerm) const
{
    if (searchTerm.isEmpty())
        return true;
    
    if (title.containsIgnoreCase(searchTerm) || content.containsIgnoreCase(searchTerm))
        return true;
    
    for (const auto& child : children)
    {
        if (child.matchesSearch(searchTerm))
            return true;
    }
    
    return false;
}

bool HelpManagerComponent::MarkdownSection::containsAnchor(const juce::String& targetAnchor) const
{
    if (targetAnchor.isEmpty())
        return false;
    
    // Check if this section's anchor matches
    if (anchor == targetAnchor)
        return true;
    
    // Recursively check children
    for (const auto& child : children)
    {
        if (child.containsAnchor(targetAnchor))
            return true;
    }
    
    return false;
}

void HelpManagerComponent::loadNodeDictionary()
{
    if (nodeDictionaryLoaded || !nodeDictionaryFile.existsAsFile())
    {
        if (!nodeDictionaryFile.existsAsFile())
        {
            juce::Logger::writeToLog("[HelpManager] Node Dictionary file not found: " + nodeDictionaryFile.getFullPathName());
        }
        nodeDictionaryLoaded = true;
        return;
    }
    
    juce::String content = nodeDictionaryFile.loadFileAsString();
    if (content.isEmpty())
    {
        juce::Logger::writeToLog("[HelpManager] Failed to load Node Dictionary file or file is empty.");
        nodeDictionaryLoaded = true;
        return;
    }
    
    parseMarkdown(content, nodeDictionarySections);
    nodeDictionaryLoaded = true;
    juce::Logger::writeToLog("[HelpManager] Loaded Node Dictionary: " + juce::String(nodeDictionarySections.size()) + " top-level sections");
}

void HelpManagerComponent::loadGettingStarted()
{
    if (gettingStartedLoaded || !gettingStartedFile.existsAsFile())
    {
        if (!gettingStartedFile.existsAsFile())
        {
            juce::Logger::writeToLog("[HelpManager] Getting Started file not found: " + gettingStartedFile.getFullPathName());
        }
        gettingStartedLoaded = true;
        return;
    }
    
    juce::String content = gettingStartedFile.loadFileAsString();
    if (content.isEmpty())
    {
        juce::Logger::writeToLog("[HelpManager] Failed to load Getting Started file or file is empty.");
        gettingStartedLoaded = true;
        return;
    }
    
    parseMarkdown(content, gettingStartedSections);
    gettingStartedLoaded = true;
    juce::Logger::writeToLog("[HelpManager] Loaded Getting Started: " + juce::String(gettingStartedSections.size()) + " top-level sections");
}

void HelpManagerComponent::loadFaq()
{
    if (faqLoaded || !faqFile.existsAsFile())
    {
        if (!faqFile.existsAsFile())
        {
            juce::Logger::writeToLog("[HelpManager] FAQ file not found: " + faqFile.getFullPathName());
        }
        faqLoaded = true;
        return;
    }
    
    juce::String content = faqFile.loadFileAsString();
    if (content.isEmpty())
    {
        juce::Logger::writeToLog("[HelpManager] Failed to load FAQ file or file is empty.");
        faqLoaded = true;
        return;
    }
    
    parseMarkdown(content, faqSections);
    faqLoaded = true;
    juce::Logger::writeToLog("[HelpManager] Loaded FAQ: " + juce::String(faqSections.size()) + " top-level sections");
}

void HelpManagerComponent::parseMarkdown(const juce::String& content, std::vector<MarkdownSection>& sections)
{
    sections.clear();
    
    auto lines = juce::StringArray::fromLines(content);
    std::vector<MarkdownSection*> stack; // Stack to track current section hierarchy
    
    for (int i = 0; i < lines.size(); ++i)
    {
        juce::String line = lines[i].trimEnd();
        
        // Check for headers (##, ###, ####)
        if (line.startsWith("##"))
        {
            int level = 0;
            int startIdx = 0;
            while (startIdx < line.length() && line[startIdx] == '#')
            {
                level++;
                startIdx++;
            }
            
            // Skip if level is 1 (single #) - we only care about ## and below
            if (level < 2)
                continue;
            
            level -= 1; // Convert to 1-based: ## = 1, ### = 2, #### = 3
            
            juce::String title = line.substring(startIdx).trim();
            juce::String anchor = extractAnchor(line);
            
            // Pop stack until we find the right parent level
            while (!stack.empty() && stack.back()->level >= level)
            {
                stack.pop_back();
            }
            
            MarkdownSection newSection;
            newSection.title = title;
            newSection.level = level;
            newSection.anchor = anchor;
            
            // Add to appropriate parent
            if (stack.empty())
            {
                sections.push_back(newSection);
                stack.push_back(&sections.back());
            }
            else
            {
                stack.back()->children.push_back(newSection);
                stack.push_back(&stack.back()->children.back());
            }
        }
        else if (!stack.empty() && !line.isEmpty())
        {
            // Add content to current section
            if (stack.back()->content.isNotEmpty())
                stack.back()->content += "\n";
            stack.back()->content += line;
        }
    }
}

juce::String HelpManagerComponent::extractAnchor(const juce::String& headerLine)
{
    // Extract anchor from header line (e.g., "### vco" -> "vco")
    int startIdx = 0;
    while (startIdx < headerLine.length() && headerLine[startIdx] == '#')
        startIdx++;
    
    juce::String title = headerLine.substring(startIdx).trim();
    
    // Convert to lowercase anchor (simple version)
    juce::String anchor = title.toLowerCase();
    // Remove special characters and replace spaces with hyphens
    anchor = anchor.replaceCharacters(".,!?;:()[]{}", "");
    anchor = anchor.replace(" ", "-");
    
    return anchor;
}

void HelpManagerComponent::renderMarkdownSection(const MarkdownSection& section, const juce::String& searchTerm, bool parentMatches, bool forceExpand)
{
    bool sectionMatches = searchTerm.isEmpty() ? true : section.matchesSearch(searchTerm);
    bool shouldShow = searchTerm.isEmpty() || sectionMatches || parentMatches;
    
    if (!shouldShow)
        return;
    
    // Check if this section or any of its children contain the target anchor
    bool containsTargetAnchor = !scrollToAnchor.isEmpty() && section.containsAnchor(scrollToAnchor);
    
    // Check if this is the exact target section for scrolling
    bool isTargetSection = !scrollToAnchor.isEmpty() && section.anchor == scrollToAnchor;
    
    // Render based on level
    if (section.level == 1)
    {
        // Top-level sections use CollapsingHeader with category color
        ImU32 categoryColor = getCategoryColorForSection(section.title);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(categoryColor);
        
        ImGui::PushStyleColor(ImGuiCol_Header, categoryColor);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
        
        // Use optimal text color for contrast
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(categoryColor);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
        
        // Force expand if this section contains the target anchor
        if (forceExpand || containsTargetAnchor)
        {
            ImGui::SetNextItemOpen(true, ImGuiCond_Always);
        }
        
        // Determine if section should be expanded by default
        ImGuiTreeNodeFlags flags = 0;
        if (searchTerm.isEmpty() || sectionMatches || forceExpand || containsTargetAnchor)
            flags |= ImGuiTreeNodeFlags_DefaultOpen;
        
        bool isOpen = ImGui::CollapsingHeader(section.title.toRawUTF8(), flags);
        ImGui::PopStyleColor(4);
        if (isOpen)
        {
            ImGui::Indent(10.0f);
            renderMarkdownText(section.content);
            
            for (const auto& child : section.children)
            {
                renderMarkdownSection(child, searchTerm, sectionMatches || containsTargetAnchor, containsTargetAnchor);
            }
            ImGui::Unindent(10.0f);
        }
    }
    else if (section.level == 2)
    {
        // Second-level sections (###) - node names with category colors
        
        // Check if this is the target section for scrolling - scroll BEFORE rendering header
        if (isTargetSection)
        {
            ImGui::SetScrollHereY(0.1f); // 10% from top
            scrollToAnchor = ""; // Clear after scrolling
        }
        
        ImGui::Spacing();
        ImGui::PushID(section.anchor.toRawUTF8()); // Unique ID for each node section
        
        // Use theme accent color for node names - bright and vibrant
        ImVec4 accentColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
        accentColor.w = 1.0f;
        // Make it slightly more vibrant
        accentColor.x = std::min(1.0f, accentColor.x * 1.1f);
        accentColor.y = std::min(1.0f, accentColor.y * 1.1f);
        accentColor.z = std::min(1.0f, accentColor.z * 1.15f);
        ImGui::PushStyleColor(ImGuiCol_Text, accentColor);
        ImGui::SetWindowFontScale(1.3f);
        ImGui::TextUnformatted(section.title.toRawUTF8());
        ImGui::SetWindowFontScale(1.0f);
        ImGui::PopStyleColor();
        ImGui::PopID();
        
        ImGui::Spacing();
        
        renderMarkdownText(section.content);
        
        for (const auto& child : section.children)
        {
            renderMarkdownSection(child, searchTerm, sectionMatches, forceExpand && containsTargetAnchor);
        }
        
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();
    }
    else
    {
        // Level 3+ (####) - smaller styled header
        
        // Check if this is the target section for scrolling - scroll BEFORE rendering header
        if (isTargetSection)
        {
            ImGui::SetScrollHereY(0.1f); // 10% from top
            scrollToAnchor = ""; // Clear after scrolling
        }
        
        ImGui::Spacing();
        ImGui::PushID(section.anchor.toRawUTF8()); // Unique ID for each subsection
        
        // Use theme text color with slight emphasis
        ImVec4 subHeaderColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
        subHeaderColor.w = 0.9f; // Slightly brighter than disabled
        ImGui::PushStyleColor(ImGuiCol_Text, subHeaderColor);
        ImGui::SetWindowFontScale(1.1f);
        ImGui::TextUnformatted(section.title.toRawUTF8());
        ImGui::SetWindowFontScale(1.0f);
        ImGui::PopStyleColor();
        ImGui::PopID();
        
        ImGui::Spacing();
        
        renderMarkdownText(section.content);
        
        for (const auto& child : section.children)
        {
            renderMarkdownSection(child, searchTerm, sectionMatches, forceExpand && containsTargetAnchor);
        }
    }
}

void HelpManagerComponent::renderMarkdownText(const juce::String& text)
{
    if (text.isEmpty())
        return;
    
    auto lines = juce::StringArray::fromLines(text);
    bool inCodeBlock = false;
    
    for (int lineIdx = 0; lineIdx < lines.size(); ++lineIdx)
    {
        juce::String line = lines[lineIdx];
        juce::String trimmed = line.trim();
        
        // Handle code blocks
        if (trimmed.startsWith("```"))
        {
            inCodeBlock = !inCodeBlock;
            if (inCodeBlock)
            {
                ImGui::Spacing();
                // Use a slightly brighter background for code blocks
                ImVec4 codeBg = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
                codeBg.w = std::min(1.0f, codeBg.w * 1.3f); // Brighter background
                ImGui::PushStyleColor(ImGuiCol_ChildBg, codeBg);
                ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 4.0f);
                ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.0f, 8.0f));
            }
            else
            {
                ImGui::PopStyleVar(2);
                ImGui::PopStyleColor();
                ImGui::Spacing();
            }
            continue;
        }
        
        if (inCodeBlock)
        {
            // Render code block line with theme-aware color
            ImVec4 codeTextColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
            // Make code text slightly brighter/cyan-tinted
            codeTextColor.x = std::min(1.0f, codeTextColor.x * 1.2f);
            codeTextColor.y = std::min(1.0f, codeTextColor.y * 1.1f);
            codeTextColor.z = std::min(1.0f, codeTextColor.z * 1.15f);
            ImGui::PushStyleColor(ImGuiCol_Text, codeTextColor);
            ImGui::TextUnformatted(line.toRawUTF8());
            ImGui::PopStyleColor();
            continue;
        }
        
        if (trimmed.isEmpty())
        {
            ImGui::Spacing();
            continue;
        }
        
        // Check for list items
        if (trimmed.startsWith("- ") || trimmed.startsWith("* "))
        {
            ImGui::Indent(20.0f);
            renderFormattedText(trimmed.substring(2));
            ImGui::Unindent(20.0f);
        }
        // Regular text with formatting
        else
        {
            renderFormattedText(trimmed);
        }
    }
}

void HelpManagerComponent::renderFormattedText(const juce::String& text)
{
    // Parse formatting: bold (**text**), code (`text`), and links ([text](#anchor))
    juce::String remaining = text;
    std::vector<std::tuple<juce::String, int, juce::String>> segments; // text, type (0=plain, 1=bold, 2=code, 3=link), linkTarget
    
    // Parse the text into segments
    while (remaining.isNotEmpty())
    {
        int boldStart = remaining.indexOf("**");
        int codeStart = remaining.indexOf("`");
        int linkStart = remaining.indexOf("[");
        
        int nextMarker = -1;
        int formatType = 0;
        
        // Find the earliest marker
        if (boldStart >= 0 && (codeStart < 0 || boldStart < codeStart) && (linkStart < 0 || boldStart < linkStart))
        {
            nextMarker = boldStart;
            formatType = 1; // bold
        }
        else if (codeStart >= 0 && (linkStart < 0 || codeStart < linkStart))
        {
            nextMarker = codeStart;
            formatType = 2; // code
        }
        else if (linkStart >= 0)
        {
            nextMarker = linkStart;
            formatType = 3; // link
        }
        
        if (nextMarker < 0)
        {
            // No more formatting
            if (remaining.isNotEmpty())
                segments.emplace_back(remaining, 0, "");
            break;
        }
        
        // Add plain text before marker
        if (nextMarker > 0)
        {
            segments.emplace_back(remaining.substring(0, nextMarker), 0, "");
        }
        
        if (formatType == 1) // bold
        {
            int boldEnd = remaining.indexOf(boldStart + 2, "**");
            if (boldEnd > boldStart + 2)
            {
                segments.emplace_back(remaining.substring(boldStart + 2, boldEnd), 1, "");
                remaining = remaining.substring(boldEnd + 2);
            }
            else
            {
                // Malformed bold, treat as plain text
                segments.emplace_back(remaining.substring(boldStart), 0, "");
                remaining = "";
            }
        }
        else if (formatType == 2) // code
        {
            int codeEnd = remaining.indexOf(codeStart + 1, "`");
            if (codeEnd > codeStart)
            {
                segments.emplace_back(remaining.substring(codeStart + 1, codeEnd), 2, "");
                remaining = remaining.substring(codeEnd + 1);
            }
            else
            {
                segments.emplace_back(remaining.substring(codeStart), 0, "");
                remaining = "";
            }
        }
        else if (formatType == 3) // link [text](#anchor)
        {
            int linkTextEnd = remaining.indexOf(nextMarker + 1, "]");
            if (linkTextEnd > nextMarker)
            {
                juce::String linkText = remaining.substring(nextMarker + 1, linkTextEnd);
                int linkTargetStart = remaining.indexOf(linkTextEnd + 1, "(");
                if (linkTargetStart == linkTextEnd + 1)
                {
                    int linkTargetEnd = remaining.indexOf(linkTargetStart + 1, ")");
                    if (linkTargetEnd > linkTargetStart)
                    {
                        juce::String linkTarget = remaining.substring(linkTargetStart + 1, linkTargetEnd);
                        // Remove # from anchor if present
                        if (linkTarget.startsWith("#"))
                            linkTarget = linkTarget.substring(1);
                        segments.emplace_back(linkText, 3, linkTarget);
                        remaining = remaining.substring(linkTargetEnd + 1);
                    }
                    else
                    {
                        segments.emplace_back(remaining.substring(nextMarker), 0, "");
                        remaining = "";
                    }
                }
                else
                {
                    segments.emplace_back(remaining.substring(nextMarker), 0, "");
                    remaining = "";
                }
            }
            else
            {
                segments.emplace_back(remaining.substring(nextMarker), 0, "");
                remaining = "";
            }
        }
    }
    
    // Render segments
    for (const auto& [segmentText, formatType, linkTarget] : segments)
    {
        if (segmentText.isEmpty())
            continue;
            
        if (formatType == 1) // bold
        {
            // Bold text - use theme accent color
            ImVec4 boldColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
            boldColor.w = 1.0f;
            ImGui::PushStyleColor(ImGuiCol_Text, boldColor);
            ImGui::SetWindowFontScale(1.08f);
            ImGui::TextWrapped("%s", segmentText.toRawUTF8());
            ImGui::SetWindowFontScale(1.0f);
            ImGui::PopStyleColor();
        }
        else if (formatType == 2) // code
        {
            // Inline code - use theme colors with subtle background
            ImVec4 codeTextColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
            codeTextColor.x = std::min(1.0f, codeTextColor.x * 1.15f);
            codeTextColor.y = std::min(1.0f, codeTextColor.y * 1.1f);
            codeTextColor.z = std::min(1.0f, codeTextColor.z * 1.2f);
            
            ImVec4 codeBgColor = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
            codeBgColor.w = std::min(1.0f, codeBgColor.w * 1.2f); // Slightly brighter background
            
            ImGui::PushStyleColor(ImGuiCol_Text, codeTextColor);
            ImGui::PushStyleColor(ImGuiCol_FrameBg, codeBgColor);
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4.0f, 2.0f));
            ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);
            ImGui::TextWrapped("%s", segmentText.toRawUTF8());
            ImGui::PopStyleVar(2);
            ImGui::PopStyleColor(2);
        }
        else if (formatType == 3) // link
        {
            // Link - use theme accent color with hover effect
            ImVec4 linkColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
            linkColor.z = std::min(1.0f, linkColor.z * 1.2f); // Slightly more blue
            linkColor.w = 1.0f;
            
            juce::String linkId = "link_" + linkTarget;
            ImGui::PushID(linkId.toRawUTF8()); // Unique ID for each link
            
            ImGui::PushStyleColor(ImGuiCol_Text, linkColor);
            if (ImGui::Selectable(segmentText.toRawUTF8(), false, ImGuiSelectableFlags_None))
            {
                // Clicked! Scroll to anchor
                juce::String target = linkTarget;
                if (target.startsWith("#"))
                    target = target.substring(1);
                scrollToAnchor = target;
            }
            ImGui::PopStyleColor();
            ImGui::PopID();
        }
        else // plain
        {
            ImGui::TextWrapped("%s", segmentText.toRawUTF8());
        }
    }
}

ImU32 HelpManagerComponent::getCategoryColorForSection(const juce::String& sectionTitle) const
{
    juce::String titleUpper = sectionTitle.toUpperCase();
    
    // Map section titles to ModuleCategory
    if (titleUpper.contains("SOURCE") || titleUpper.contains("1. SOURCE"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Source);
    else if (titleUpper.contains("EFFECT") || titleUpper.contains("2. EFFECT"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Effect);
    else if (titleUpper.contains("MODULATOR") || titleUpper.contains("3. MODULATOR"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Modulator);
    else if (titleUpper.contains("UTILITY") || titleUpper.contains("4. UTILITY"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Utility);
    else if (titleUpper.contains("SEQUENCER") || titleUpper.contains("5. SEQUENCER"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Seq);
    else if (titleUpper.contains("MIDI") || titleUpper.contains("6. MIDI"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::MIDI);
    else if (titleUpper.contains("ANALYSIS") || titleUpper.contains("7. ANALYSIS"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Analysis);
    else if (titleUpper.contains("TTS") || titleUpper.contains("8. TTS"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::TTS_Voice);
    else if (titleUpper.contains("SPECIAL") || titleUpper.contains("9. SPECIAL"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Special_Exp);
    else if (titleUpper.contains("COMPUTER VISION") || titleUpper.contains("10. COMPUTER VISION"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::OpenCV);
    else if (titleUpper.contains("SYSTEM") || titleUpper.contains("11. SYSTEM"))
        return ThemeManager::getInstance().getCategoryColor(ModuleCategory::Sys);
    
    // Default color
    return ImGui::ColorConvertFloat4ToU32(ImGui::GetStyleColorVec4(ImGuiCol_Header));
}

bool HelpManagerComponent::scrollToSectionIfNeeded(const juce::String& anchor)
{
    if (scrollToAnchor.isNotEmpty() && scrollToAnchor == anchor)
    {
        // Scroll to this section
        ImGui::SetScrollHereY(0.5f);
        scrollToAnchor = ""; // Clear after scrolling
        return true; // Indicate we scrolled
    }
    return false; // No scroll needed
}

void HelpManagerComponent::buildNavigationList(const std::vector<MarkdownSection>& sections, std::vector<NavigationItem>& navItems, int level)
{
    for (const auto& section : sections)
    {
        // Add all sections to navigation, but indent based on hierarchy
        NavigationItem item;
        item.title = section.title;
        item.anchor = section.anchor;
        item.level = level;
        item.isCategory = (section.level == 1); // Level 1 headers are categories like "1. SOURCE NODES"
        navItems.push_back(item);
        
        // Recursively add children with increased indentation
        if (!section.children.empty())
        {
            buildNavigationList(section.children, navItems, level + 1);
        }
    }
}

void HelpManagerComponent::renderNavigationSidebar(const std::vector<NavigationItem>& navItems, const juce::String& searchTerm)
{
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered));
    ImGui::SetWindowFontScale(1.15f);
    ImGui::Text("Navigation");
    ImGui::SetWindowFontScale(1.0f);
    ImGui::PopStyleColor();
    ImGui::Separator();
    ImGui::Spacing();

    int visibleIndex = 0; // Counter for unique IDs
    for (size_t i = 0; i < navItems.size(); ++i)
    {
        const auto& item = navItems[i];
        
        // Filter by search term
        if (!searchTerm.isEmpty() && !item.title.containsIgnoreCase(searchTerm))
            continue;

        // Skip items without anchors (like "Table of Contents")
        if (item.anchor.isEmpty())
            continue;

        // Indentation for nested items
        if (item.level > 0)
        {
            ImGui::Indent(item.level * 15.0f);
        }

        // Create unique ID using index and anchor
        juce::String uniqueId = juce::String(visibleIndex) + "_" + item.anchor;
        ImGui::PushID(uniqueId.toRawUTF8());

        bool isSelected = scrollToAnchor == item.anchor;
        
        // Category headers get special styling with category colors
        if (item.isCategory)
        {
            ImU32 categoryColor = getCategoryColorForSection(item.title);
            ImVec4 c = ImGui::ColorConvertU32ToFloat4(categoryColor);
            
            // Use category color for selected state
            if (isSelected)
            {
                ImGui::PushStyleColor(ImGuiCol_Header, categoryColor);
                ImGui::PushStyleColor(ImGuiCol_HeaderHovered, categoryColor);
                ImVec4 selectedColor = ImVec4(c.x * 1.3f, c.y * 1.3f, c.z * 1.3f, 1.0f);
                ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(selectedColor));
                ImGui::PushStyleColor(ImGuiCol_Text, ThemeUtils::getOptimalTextColor(categoryColor));
            }
            else
            {
                ImGui::PushStyleColor(ImGuiCol_Text, c);
            }
            
            ImGui::SetWindowFontScale(1.1f);
        }
        else
        {
            // Node items - use theme accent color for selected
            if (isSelected)
            {
                ImVec4 accentColor = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
                accentColor.w = 1.0f;
                ImGui::PushStyleColor(ImGuiCol_Header, ImGui::ColorConvertFloat4ToU32(accentColor));
                ImGui::PushStyleColor(ImGuiCol_Text, accentColor);
                ImGui::SetWindowFontScale(1.05f);
            }
            else
            {
                // Use slightly brighter text for nodes
                ImVec4 nodeTextColor = ImGui::GetStyleColorVec4(ImGuiCol_Text);
                nodeTextColor.w = 0.95f; // Slightly brighter
                ImGui::PushStyleColor(ImGuiCol_Text, nodeTextColor);
            }
        }

        // Clickable link with hover effect
        if (ImGui::Selectable(item.title.toRawUTF8(), isSelected, ImGuiSelectableFlags_None))
        {
            // Clicked! Scroll to this section in the content pane
            scrollToAnchor = item.anchor;
        }

        // Pop style colors
        if (item.isCategory)
        {
            ImGui::SetWindowFontScale(1.0f);
            if (isSelected)
                ImGui::PopStyleColor(4);
            else
                ImGui::PopStyleColor(1);
        }
        else
        {
            if (isSelected)
            {
                ImGui::SetWindowFontScale(1.0f);
                ImGui::PopStyleColor(2);
            }
            else
            {
                ImGui::PopStyleColor(1);
            }
        }

        ImGui::PopID();

        if (item.level > 0)
        {
            ImGui::Unindent(item.level * 15.0f);
        }

        visibleIndex++;
    }
}

void HelpManagerComponent::renderNodeDictionaryContent(const std::vector<MarkdownSection>& sections, const juce::String& searchTerm)
{
    for (const auto& section : sections)
    {
        // Check if we need to scroll to this section or any of its children
        bool shouldExpand = scrollToAnchor.isNotEmpty() && section.containsAnchor(scrollToAnchor);
        
        // If scrolling is needed, ensure parent sections are expanded
        if (shouldExpand && section.level == 1)
        {
            // Force expand this section by using SetNextItemOpen
            ImGui::SetNextItemOpen(true, ImGuiCond_Always);
        }
        
        // Render the section (it will handle scrolling internally)
        renderMarkdownSection(section, searchTerm, true, shouldExpand);
    }
}





================================================================================
FILE: juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp
================================================================================

#include "ImGuiNodeEditorComponent.h"
#include "PinDatabase.h"
#include "SavePresetJob.h"
#include "NotificationManager.h"
#include "PresetValidator.h"
#include "PresetAutoHealer.h"

#include <imgui.h>
#include <imgui_internal.h>
#include <imnodes.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <backends/imgui_impl_opengl2.h>
#include <cmath>
#include <cstring>
#include <juce_core/juce_core.h>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <cstdint>
#include <algorithm>
#include <limits>
#include <optional>
#include "theme/ThemeManager.h"

namespace
{
    using collider::KeyChord;

    [[nodiscard]] bool chordsEqual(const KeyChord& a, const KeyChord& b) noexcept
    {
        return a.key == b.key && a.ctrl == b.ctrl && a.shift == b.shift &&
               a.alt == b.alt && a.superKey == b.superKey;
    }

    [[nodiscard]] juce::String contextDisplayName(const juce::Identifier& contextId)
    {
        if (contextId == collider::ShortcutManager::getGlobalContextIdentifier())
            return "Global";
        if (contextId == ImGuiNodeEditorComponent::nodeEditorContextId)
            return "Node Editor";
        return contextId.toString();
    }
}

#if JUCE_DEBUG
namespace
{
struct ImGuiStackBalanceChecker
{
    ImGuiContext* ctx { ImGui::GetCurrentContext() };
    ImGuiWindow* window { ctx ? ctx->CurrentWindow : nullptr };
    float indent { window ? window->DC.Indent.x : 0.0f };
    float groupOffset { window ? window->DC.GroupOffset.x : 0.0f };
    float columnsOffset { window ? window->DC.ColumnsOffset.x : 0.0f };

    void validate(const juce::String& label)
    {
        if (ctx == nullptr)
            return;

        if (window != nullptr)
        {
            constexpr float epsilon = 1.0e-4f;
            auto approxEqual = [](float a, float b, float eps) noexcept
            {
                return std::abs(a - b) <= eps;
            };

            if (!approxEqual(window->DC.Indent.x, indent, epsilon)
                || !approxEqual(window->DC.GroupOffset.x, groupOffset, epsilon)
                || !approxEqual(window->DC.ColumnsOffset.x, columnsOffset, epsilon))
            {
                juce::Logger::writeToLog("[ImGui][IndentLeak] " + label
                                         + " indent=" + juce::String(window->DC.Indent.x)
                                         + " expected=" + juce::String(indent));
                jassertfalse;
                window->DC.Indent.x = indent;
                window->DC.GroupOffset.x = groupOffset;
                window->DC.ColumnsOffset.x = columnsOffset;
            }
        }
    }
};
}
#else
struct ImGuiStackBalanceChecker
{
    ImGuiStackBalanceChecker() = default;
    void validate(const juce::String&) const {}
};
#endif

// Lightweight theme change toast state
static double s_themeToastEndTime = 0.0;
static juce::String s_themeToastText;

// ============================================================================
// Global GPU/CPU Settings (default: GPU enabled for best performance)
// ============================================================================
bool ImGuiNodeEditorComponent::s_globalGpuEnabled = true;
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/modules/RerouteModuleProcessor.h"
#include "../audio/modules/AudioInputModuleProcessor.h"
#include "../audio/modules/AttenuverterModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/RandomModuleProcessor.h"
#include "../audio/modules/ValueModuleProcessor.h"
#include "../audio/modules/SampleLoaderModuleProcessor.h"
#include "../audio/modules/MIDIPlayerModuleProcessor.h"
#include "../audio/modules/PolyVCOModuleProcessor.h"
#include "../audio/modules/TrackMixerModuleProcessor.h"
#include "../audio/modules/MathModuleProcessor.h"
#include "../audio/modules/StepSequencerModuleProcessor.h"
#include "../audio/modules/MultiSequencerModuleProcessor.h"
#include "../audio/modules/StrokeSequencerModuleProcessor.h"
#include "../audio/modules/AnimationModuleProcessor.h"
#include "../audio/modules/TempoClockModuleProcessor.h"
#include "../audio/modules/WebcamLoaderModule.h"
#include "../audio/modules/VideoFileLoaderModule.h"
#include "../audio/modules/MovementDetectorModule.h"
#include "../audio/modules/HumanDetectorModule.h"
#include "../audio/modules/PoseEstimatorModule.h"
#include "../audio/modules/ColorTrackerModule.h"
#include "../audio/modules/ContourDetectorModule.h"
#include "../audio/modules/SemanticSegmentationModule.h"
#include "../audio/modules/ObjectDetectorModule.h"
#include "../audio/modules/HandTrackerModule.h"
#include "../audio/modules/FaceTrackerModule.h"
#include "../audio/modules/VideoFXModule.h"
#include "../audio/modules/CropVideoModule.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/LagProcessorModuleProcessor.h"
#include "../audio/modules/DeCrackleModuleProcessor.h"
#include "../audio/modules/GraphicEQModuleProcessor.h"
#include "../audio/modules/FrequencyGraphModuleProcessor.h"
#include "../audio/modules/ChorusModuleProcessor.h"
#include "../audio/modules/PhaserModuleProcessor.h"
#include "../audio/modules/CompressorModuleProcessor.h"
#include "../audio/modules/RecordModuleProcessor.h"
#include "../audio/modules/CommentModuleProcessor.h"
#include "../audio/modules/LimiterModuleProcessor.h"
#include "../audio/modules/GateModuleProcessor.h"
#include "../audio/modules/DriveModuleProcessor.h"
#include "../audio/modules/VstHostModuleProcessor.h"
// #include "../audio/modules/SnapshotSequencerModuleProcessor.h"  // Commented out - causing build errors
#include "../audio/modules/MIDICVModuleProcessor.h"
#include "../audio/modules/ScopeModuleProcessor.h"
#include "../audio/modules/MetaModuleProcessor.h"
#include "../audio/modules/InletModuleProcessor.h"
#include "../audio/modules/OutletModuleProcessor.h"
#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include <juce_audio_processors/juce_audio_processors.h>
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>
#include <juce_opengl/juce_opengl.h>

#if JUCE_DEBUG
static int gImNodesNodeDepth = 0;
static int gImNodesInputDepth = 0;
static int gImNodesOutputDepth = 0;
static juce::String gLastRenderedNodeLabel;

struct ImNodesDepthSnapshot
{
    int node;
    int input;
    int output;
    juce::String label;

    ImNodesDepthSnapshot(const juce::String& lbl)
        : node(gImNodesNodeDepth),
          input(gImNodesInputDepth),
          output(gImNodesOutputDepth),
          label(lbl) {}

    ~ImNodesDepthSnapshot()
    {
        if (gImNodesNodeDepth != node || gImNodesInputDepth != input || gImNodesOutputDepth != output)
        {
            juce::Logger::writeToLog("[ImNodes][DepthLeak] " + label
                                     + " node=" + juce::String(gImNodesNodeDepth) + " (expected " + juce::String(node) + ")"
                                     + " input=" + juce::String(gImNodesInputDepth) + " (expected " + juce::String(input) + ")"
                                     + " output=" + juce::String(gImNodesOutputDepth) + " (expected " + juce::String(output) + ")");
            jassertfalse;

            // Reset to avoid cascading logs
            gImNodesNodeDepth = node;
            gImNodesInputDepth = input;
            gImNodesOutputDepth = output;
        }
    }
};
#endif

#define NODE_DEBUG 0

// --- Module Descriptions for Tooltips ---
static const char* toString(PinDataType t)
{
    switch (t)
    {
        case PinDataType::Audio: return "Audio";
        case PinDataType::CV: return "CV";
        case PinDataType::Gate: return "Gate";
        case PinDataType::Raw: return "Raw";
        case PinDataType::Video: return "Video";
        default: return "Unknown";
    }
}

#define LOG_LINK(msg) do { if (NODE_DEBUG) juce::Logger::writeToLog("[LINK] " + juce::String(msg)); } while(0)

struct Range { float min; float max; };

// Forward declarations
class ModularSynthProcessor;
class RandomModuleProcessor;
class ValueModuleProcessor;
class StepSequencerModuleProcessor;
class MapRangeModuleProcessor;

// Helper methods for MapRange configuration
ImGuiNodeEditorComponent::Range getSourceRange(const ImGuiNodeEditorComponent::PinID& srcPin, ModularSynthProcessor* synth)
{
    if (synth == nullptr) return {0.0f, 1.0f};
    
    auto* module = synth->getModuleForLogical(srcPin.logicalId);
    if (auto* random = dynamic_cast<RandomModuleProcessor*>(module))
    {
        auto& ap = random->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* value = dynamic_cast<ValueModuleProcessor*>(module))
    {
        auto& ap = value->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* stepSeq = dynamic_cast<StepSequencerModuleProcessor*>(module))
    {
        // StepSequencer outputs CV range
        return {0.0f, 1.0f};
    }
    // Fallback: estimate from source's lastOutputValues
    // TODO: implement fallback estimation
    return {0.0f, 1.0f};
}

void configureMapRangeFor(PinDataType srcType, PinDataType dstType, MapRangeModuleProcessor& m, ImGuiNodeEditorComponent::Range inRange)
{
    auto& ap = m.getAPVTS();
    
    // Set input range
    if (auto* inMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin")))
        *inMinParam = inRange.min;
    if (auto* inMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax")))
        *inMaxParam = inRange.max;
    
    // Set output range based on destination type
    if (dstType == PinDataType::Audio)
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = -1.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
    else // CV or Gate
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = 0.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
}




ImGuiNodeEditorComponent::ImGuiNodeEditorComponent(juce::AudioDeviceManager& dm)
    : deviceManager(dm)
{
    juce::Logger::writeToLog("ImGuiNodeEditorComponent constructor starting...");
    
    // --- THIS WILL BE THE SMOKING GUN ---
    juce::Logger::writeToLog("About to populate pin database...");
    populatePinDatabase(); // Initialize the pin database for color coding
    populateDragInsertSuggestions();
    juce::Logger::writeToLog("Pin database populated.");
    
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
    registerShortcuts();

    // Wire Theme Editor to use framebuffer-based eyedropper
    themeEditor.setStartPicker([this](std::function<void(ImU32)> onPicked){ this->startColorPicking(std::move(onPicked)); });
    
    // Initialize browser paths (load from saved settings or use defaults)
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        // Load the last used paths, providing defaults if they don't exist
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultPresetPath = appFile.getParentDirectory().getChildFile("Presets");
        juce::File defaultSamplePath = appFile.getParentDirectory().getChildFile("Samples");

        m_presetScanPath = juce::File(props->getValue("presetScanPath", defaultPresetPath.getFullPathName()));
        m_sampleScanPath = juce::File(props->getValue("sampleScanPath", defaultSamplePath.getFullPathName()));
    }
    
    // Create these directories if they don't already exist
    if (!m_presetScanPath.exists())
        m_presetScanPath.createDirectory();
    if (!m_sampleScanPath.exists())
        m_sampleScanPath.createDirectory();
    
    juce::Logger::writeToLog("[UI] Preset path set to: " + m_presetScanPath.getFullPathName());
    juce::Logger::writeToLog("[UI] Sample path set to: " + m_sampleScanPath.getFullPathName());
    
    // --- MIDI BROWSER PATH INITIALIZATION ---
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultMidiPath = appFile.getParentDirectory().getChildFile("audio").getChildFile("MIDI");
        m_midiScanPath = juce::File(props->getValue("midiScanPath", defaultMidiPath.getFullPathName()));
    }
    if (!m_midiScanPath.exists())
        m_midiScanPath.createDirectory();
    juce::Logger::writeToLog("[UI] MIDI path set to: " + m_midiScanPath.getFullPathName());
    // --- END OF MIDI INITIALIZATION ---
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    unregisterShortcuts();
    glContext.detach();
}

void ImGuiNodeEditorComponent::registerShortcuts()
{
    auto registerAction = [this](const juce::Identifier& id,
                                 const char* name,
                                 const char* description,
                                 const char* category,
                                 const collider::KeyChord& chord,
                                 std::atomic<bool>& flag)
    {
        collider::ShortcutAction action { id, juce::String(name), juce::String(description), juce::String(category) };
        shortcutManager.registerAction(action, [this, &flag]()
        {
            flag.store(true, std::memory_order_release);
        });
        shortcutManager.setDefaultBinding(id, nodeEditorContextId, chord);
    };

    registerAction(ShortcutActionIds::fileSave,
                   "Save Preset",
                   "Save the current patch to its file.",
                   "File",
                   { ImGuiKey_S, true, false, false, false },
                   shortcutFileSaveRequested);

    registerAction(ShortcutActionIds::fileSaveAs,
                   "Save Preset Asâ€¦",
                   "Save the current patch to a new file.",
                   "File",
                   { ImGuiKey_S, true, false, true, false },
                   shortcutFileSaveAsRequested);

    registerAction(ShortcutActionIds::fileOpen,
                   "Load Preset",
                   "Open a preset from disk.",
                   "File",
                   { ImGuiKey_O, true, false, false, false },
                   shortcutFileOpenRequested);

    registerAction(ShortcutActionIds::fileRandomizePatch,
                   "Randomize Patch",
                   "Randomize the entire patch.",
                   "File",
                   { ImGuiKey_P, true, false, false, false },
                   shortcutRandomizePatchRequested);

    registerAction(ShortcutActionIds::fileRandomizeConnections,
                   "Randomize Connections",
                   "Randomize node connections.",
                   "File",
                   { ImGuiKey_M, true, false, false, false },
                   shortcutRandomizeConnectionsRequested);

    registerAction(ShortcutActionIds::fileBeautifyLayout,
                   "Beautify Layout",
                   "Automatically tidy the node layout.",
                   "File",
                   { ImGuiKey_B, true, false, false, false },
                   shortcutBeautifyLayoutRequested);

    registerAction(ShortcutActionIds::editCtrlR,
                   "Record Output / Reset Selection",
                   "Record the output when nothing is selected or reset selected nodes to defaults.",
                   "Edit",
                   { ImGuiKey_R, true, false, false, false },
                   shortcutCtrlRRequested);

    registerAction(ShortcutActionIds::editSelectAll,
                   "Select All",
                   "Select every node in the graph.",
                   "Edit",
                   { ImGuiKey_A, true, false, false, false },
                   shortcutSelectAllRequested);

    registerAction(ShortcutActionIds::editMuteSelection,
                   "Toggle Mute",
                   "Mute or bypass the selected nodes.",
                   "Edit",
                   { ImGuiKey_M, false, false, false, false },
                   shortcutMuteSelectionRequested);

    registerAction(ShortcutActionIds::editConnectOutput,
                   "Connect to Output",
                   "Wire the selected node to the main output.",
                   "Edit",
                   { ImGuiKey_O, false, false, false, false },
                   shortcutConnectOutputRequested);

    registerAction(ShortcutActionIds::editDisconnectSelection,
                   "Disconnect Selection",
                   "Remove all connections from selected nodes.",
                   "Edit",
                   { ImGuiKey_D, false, false, true, false },
                   shortcutDisconnectRequested);

    registerAction(ShortcutActionIds::editDuplicate,
                   "Duplicate Selection",
                   "Duplicate selected nodes.",
                   "Edit",
                   { ImGuiKey_D, true, false, false, false },
                   shortcutDuplicateRequested);

    registerAction(ShortcutActionIds::editDuplicateWithRouting,
                   "Duplicate Selection (With Routing)",
                   "Duplicate selected nodes and replicate their connections.",
                   "Edit",
                   { ImGuiKey_D, false, true, false, false },
                   shortcutDuplicateWithRoutingRequested);

    registerAction(ShortcutActionIds::editDelete,
                   "Delete Selection",
                   "Delete selected nodes or links.",
                   "Edit",
                   { ImGuiKey_Delete, false, false, false, false },
                   shortcutDeleteRequested);

    registerAction(ShortcutActionIds::editBypassDelete,
                   "Bypass Delete",
                   "Delete selected nodes while preserving signal flow.",
                   "Edit",
                   { ImGuiKey_Delete, false, true, false, false },
                   shortcutBypassDeleteRequested);

    registerAction(ShortcutActionIds::viewFrameSelection,
                   "Frame Selection",
                   "Frame the currently selected nodes.",
                   "View",
                   { ImGuiKey_F, false, false, false, false },
                   shortcutFrameSelectionRequested);

    registerAction(ShortcutActionIds::viewFrameAll,
                   "Frame All",
                   "Frame the entire graph.",
                   "View",
                   { ImGuiKey_Home, false, false, false, false },
                   shortcutFrameAllRequested);

    registerAction(ShortcutActionIds::viewResetOrigin,
                   "Reset View Origin",
                   "Reset the editor panning to the origin.",
                   "View",
                   { ImGuiKey_Home, true, false, false, false },
                   shortcutResetOriginRequested);

    registerAction(ShortcutActionIds::viewToggleMinimap,
                   "Toggle Minimap Zoom",
                   "Temporarily enlarge the minimap.",
                   "View",
                   { ImGuiKey_Comma, false, false, false, false },
                   shortcutToggleMinimapRequested);

    // This action now opens the new Help Manager to the Shortcuts tab
    // If a node is selected, opens to that node's dictionary entry instead
    shortcutManager.registerAction(
        { ShortcutActionIds::viewToggleShortcutsWindow, "Help Manager", "Show the Help Manager window.", "Help" },
        [this]() {
            // Check if a node is selected
            int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                // Get the first selected node
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                if (!selectedNodeIds.empty())
                {
                    juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                    if (synth != nullptr)
                    {
                        juce::String moduleType = synth->getModuleTypeForLogical(logicalId);
                        
                        if (moduleType.isNotEmpty())
                        {
                            // Open Help Manager to this node's dictionary entry
                            m_helpManager.openToNode(moduleType);
                            return;
                        }
                    }
                }
            }
            
            // Default behavior: open to Shortcuts tab
            m_helpManager.open();
            m_helpManager.setActiveTab(0); // 0 = Shortcuts tab
        }
    );
    shortcutManager.setDefaultBinding(ShortcutActionIds::viewToggleShortcutsWindow, nodeEditorContextId, { ImGuiKey_F1, false, false, false, false });

    registerAction(ShortcutActionIds::historyUndo,
                   "Undo",
                   "Revert the last action.",
                   "History",
                   { ImGuiKey_Z, true, false, false, false },
                   shortcutUndoRequested);

    registerAction(ShortcutActionIds::historyRedo,
                   "Redo",
                   "Redo the last undone action.",
                   "History",
                   { ImGuiKey_Y, true, false, false, false },
                   shortcutRedoRequested);

    registerAction(ShortcutActionIds::debugToggleOverlay,
                   "Toggle Debug Menu",
                   "Show or hide the diagnostics window.",
                   "Debug",
                   { ImGuiKey_D, true, true, false, false },
                   shortcutToggleDebugRequested);

    registerAction(ShortcutActionIds::graphInsertMixer,
                   "Insert Mixer",
                   "Insert a mixer after the selected node.",
                   "Graph",
                   { ImGuiKey_T, true, false, false, false },
                   shortcutInsertMixerRequested);

    registerAction(ShortcutActionIds::graphShowInsertPopup,
                   "Open Insert Node Popup",
                   "Open the insert node popup for the selected node.",
                   "Graph",
                   { ImGuiKey_I, true, false, false, false },
                   shortcutShowInsertPopupRequested);

    registerAction(ShortcutActionIds::graphInsertOnLink,
                   "Insert Node On Link",
                   "Insert a node on the hovered link.",
                   "Graph",
                   { ImGuiKey_I, false, false, false, false },
                   shortcutInsertOnLinkRequested);

    registerAction(ShortcutActionIds::graphChainSequential,
                   "Chain Selection (Stereo)",
                   "Connect selected nodes sequentially using stereo outputs.",
                   "Graph",
                   { ImGuiKey_C, false, false, false, false },
                   shortcutChainSequentialRequested);

    registerAction(ShortcutActionIds::graphChainAudio,
                   "Chain Audio Pins",
                   "Connect matching audio pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_G, false, false, false, false },
                   shortcutChainAudioRequested);

    registerAction(ShortcutActionIds::graphChainCv,
                   "Chain CV Pins",
                   "Connect matching CV pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_B, false, false, false, false },
                   shortcutChainCvRequested);

    registerAction(ShortcutActionIds::graphChainGate,
                   "Chain Gate Pins",
                   "Connect matching gate pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_Y, false, false, false, false },
                   shortcutChainGateRequested);

    registerAction(ShortcutActionIds::graphChainRaw,
                   "Chain Raw Pins",
                   "Connect matching raw pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_R, false, false, false, false },
                   shortcutChainRawRequested);

    registerAction(ShortcutActionIds::graphChainVideo,
                   "Chain Video Pins",
                   "Connect matching video pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_V, false, false, false, false },
                   shortcutChainVideoRequested);
}

void ImGuiNodeEditorComponent::unregisterShortcuts()
{
    shortcutManager.unregisterAction(ShortcutActionIds::graphInsertOnLink);
    shortcutManager.unregisterAction(ShortcutActionIds::graphShowInsertPopup);
    shortcutManager.unregisterAction(ShortcutActionIds::graphInsertMixer);
    shortcutManager.unregisterAction(ShortcutActionIds::debugToggleOverlay);
    shortcutManager.unregisterAction(ShortcutActionIds::historyRedo);
    shortcutManager.unregisterAction(ShortcutActionIds::historyUndo);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainVideo);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainRaw);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainGate);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainCv);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainAudio);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainSequential);
    shortcutManager.unregisterAction(ShortcutActionIds::viewToggleShortcutsWindow);
    shortcutManager.unregisterAction(ShortcutActionIds::viewToggleMinimap);
    shortcutManager.unregisterAction(ShortcutActionIds::viewResetOrigin);
    shortcutManager.unregisterAction(ShortcutActionIds::viewFrameAll);
    shortcutManager.unregisterAction(ShortcutActionIds::viewFrameSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editBypassDelete);
    shortcutManager.unregisterAction(ShortcutActionIds::editDelete);
    shortcutManager.unregisterAction(ShortcutActionIds::editDuplicateWithRouting);
    shortcutManager.unregisterAction(ShortcutActionIds::editDuplicate);
    shortcutManager.unregisterAction(ShortcutActionIds::editDisconnectSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editConnectOutput);
    shortcutManager.unregisterAction(ShortcutActionIds::editMuteSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editSelectAll);
    shortcutManager.unregisterAction(ShortcutActionIds::editCtrlR);
    shortcutManager.unregisterAction(ShortcutActionIds::fileBeautifyLayout);
    shortcutManager.unregisterAction(ShortcutActionIds::fileRandomizeConnections);
    shortcutManager.unregisterAction(ShortcutActionIds::fileRandomizePatch);
    shortcutManager.unregisterAction(ShortcutActionIds::fileOpen);
    shortcutManager.unregisterAction(ShortcutActionIds::fileSaveAs);
    shortcutManager.unregisterAction(ShortcutActionIds::fileSave);
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}
// Input handled by imgui_juce backend
void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    
    // Try to load user's saved theme preference, otherwise use default
    if (!ThemeManager::getInstance().loadUserThemePreference())
    {
        // No preference found or failed to load, apply default theme
        ThemeManager::getInstance().applyTheme();
    }
    // If preference was loaded successfully, loadUserThemePreference() already called applyTheme()

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    
    // Enable grid snapping
    ImNodes::GetStyle().GridSpacing = 64.0f;
    
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // ======================================================
    // === ðŸ’¡ FONT REBUILD DEFERRED EXECUTION ===============
    // ======================================================
    if (fontAtlasNeedsRebuild.exchange(false, std::memory_order_acq_rel)
        || ThemeManager::getInstance().consumeFontReloadRequest())
    {
        rebuildFontAtlas();
    }

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    themeEditor.render();  // Render theme editor if open
    m_helpManager.render(); // Render help manager if open
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);

    // --- Eyedropper sampling after rendering (framebuffer has ImGui drawn) ---
    if (m_isPickingColor)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImVec2 mousePos = ImGui::GetMousePos();

        // Convert to framebuffer Y
        const int fbH = (int) io.DisplaySize.y;
        const int px = juce::jlimit(0, (int)io.DisplaySize.x - 1, (int)mousePos.x);
        const int py = juce::jlimit(0, fbH - 1, fbH - (int)mousePos.y - 1);

        unsigned char rgba[4] { 0, 0, 0, 255 };
        juce::gl::glReadPixels(px, py, 1, 1, juce::gl::GL_RGBA, juce::gl::GL_UNSIGNED_BYTE, rgba);
        ImU32 picked = IM_COL32(rgba[0], rgba[1], rgba[2], 255);

        // Draw cursor overlay
        ImDrawList* fg = ImGui::GetForegroundDrawList();
        const float s = 16.0f;
        ImVec2 tl(mousePos.x + 12, mousePos.y + 12);
        ImVec2 br(tl.x + s, tl.y + s);
        fg->AddRectFilled(tl, br, picked, 3.0f);
        fg->AddRect(tl, br, IM_COL32(0,0,0,255), 3.0f, 0, 1.0f);
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            if (m_onColorPicked) m_onColorPicked(picked);
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
        else if (ImGui::IsKeyPressed(ImGuiKey_Escape) || ImGui::IsMouseClicked(ImGuiMouseButton_Right))
        {
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
    }
}
void ImGuiNodeEditorComponent::renderImGui()
{
    // Ensure the synth always has the creation notification hook registered
    if (synth != nullptr)
    {
        synth->setOnModuleCreated([](const juce::String& pretty){
            NotificationManager::post(NotificationManager::Type::Info, "Created " + pretty + " node");
        });
    }
    static int frameCounter = 0;
    frameCounter++;

    // ========================= THE DEFINITIVE FIX =========================
    //
    // Rebuild the audio graph at the START of the frame if a change is pending.
    // This ensures that the synth model is in a consistent state BEFORE we try
    // to draw the UI, eliminating the "lost frame" that caused nodes to jump.
    //
    if (graphNeedsRebuild.load())
    {
        juce::Logger::writeToLog("[GraphSync] Rebuild flag is set. Committing changes now...");
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false; // Reset the flag immediately after committing.
        
        // CRITICAL: Invalidate hover state to prevent cable inspector from accessing
        // modules that were just deleted/recreated during commitChanges()
        lastHoveredLinkId = -1;
        lastHoveredNodeId = -1;
        hoveredLinkSrcId = 0;
        hoveredLinkDstId = 0;
        
        juce::Logger::writeToLog("[GraphSync] Graph rebuild complete.");
    }
    // ========================== END OF FIX ==========================

    // Frame start
    
    // --- Stateless Frame Rendering ---
    // Clear link registries at start of each frame for fully stateless rendering.
    // Pin IDs are now generated directly via bitmasking, no maps needed.
    linkIdToAttrs.clear();
    linkToId.clear();
    nextLinkId = 1000;

    collider::ScopedShortcutContext contextGuard(shortcutManager, nodeEditorContextId);

    if (imguiIO != nullptr)
        shortcutManager.processImGuiIO(*imguiIO);


    // --- ZOOM CONTROL HANDLER (requires imnodes zoom-enabled build) ---
#if defined(IMNODES_ZOOM_ENABLED)
    if (ImNodes::GetCurrentContext())
    {
        const ImGuiIO& io = ImGui::GetIO();
        const float currentZoom = ImNodes::EditorContextGetZoom();
        if (io.KeyCtrl && io.MouseWheel != 0.0f)
        {
            const float zoomFactor = 1.0f + (io.MouseWheel * 0.1f);
            const float newZoom = currentZoom * zoomFactor;
            ImNodes::EditorContextSetZoom(newZoom, ImGui::GetMousePos());
            juce::Logger::writeToLog("[Zoom] New Zoom: " + juce::String(newZoom, 2) + "x");
        }
    }
#endif
    // --- END ZOOM CONTROL HANDLER ---

    // === FIX DOUBLE CANVAS RENDERING ===
    // Make the parent window's background transparent.
    // This ensures that only the ImNodes canvas background (which
    // your theme controls) is the only one visible.
    ImGui::PushStyleColor(ImGuiCol_WindowBg, IM_COL32(0, 0, 0, 0));
    // === END OF FIX ===

    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_MenuBar);

    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    const float sidebarWidth = theme.layout.sidebar_width;
    const float menuBarHeight = ImGui::GetFrameHeight();
    const float padding = theme.layout.window_padding;

    // === PROBE SCOPE OVERLAY ===
    if (synth != nullptr && showProbeScope)
    {
        if (auto* scope = synth->getProbeScopeProcessor())
        {
            const float scopeWidth = theme.windows.probe_scope_width;
            const float scopeHeight = theme.windows.probe_scope_height;
            const float scopePosX = (float)getWidth() - (scopeWidth + padding);
            ImGui::SetNextWindowPos(ImVec2(scopePosX, menuBarHeight + padding), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowSize(ImVec2(scopeWidth, scopeHeight), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowBgAlpha(theme.windows.probe_scope_alpha);
            
            if (ImGui::Begin("ðŸ”¬ Probe Scope", &showProbeScope, ImGuiWindowFlags_NoFocusOnAppearing))
            {
                ImGui::Text("Signal Probe");
                ImGui::Separator();
                
                // Get scope buffer
                const auto& buffer = scope->getScopeBuffer();
                
                // Get statistics
                float minVal = 0.0f, maxVal = 0.0f;
                scope->getStatistics(minVal, maxVal);
                
                if (buffer.getNumSamples() > 0 && maxVal - minVal > 0.0001f)
                {
                    // Display stats
                    ImGui::Text("Min: %.3f  Max: %.3f", minVal, maxVal);
                    ImGui::Text("Peak: %.3f", juce::jmax(std::abs(minVal), std::abs(maxVal)));
                    
                    // Draw waveform with explicit width to avoid node expansion feedback
                    ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
                    const int numSamples = buffer.getNumSamples();
                    if (buffer.getNumChannels() > 0)
                    {
                        const float* samples = buffer.getReadPointer(0);
                        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
                    }
                    
                    // Button to clear probe connection
                    if (ImGui::Button("Clear Probe"))
                    {
                        synth->clearProbeConnection();
                    }
                }
                else
                {
                    ThemeText("No signal probed", theme.text.disabled);
                    ImGui::Text("Right-click > Probe Signal");
                    ImGui::Text("Then click any output pin");
                }
            }
            ImGui::End();
        }
    }
    // === END OF PROBE SCOPE OVERLAY ===

    // Clean up textures for deleted sample loaders
    if (synth != nullptr)
    {
        auto infos = synth->getModulesInfo();
        std::unordered_set<int> activeSampleLoaderIds;
        for (const auto& info : infos)
        {
            if (info.second.equalsIgnoreCase("sample_loader"))
            {
                activeSampleLoaderIds.insert((int)info.first);
            }
        }

        for (auto it = sampleLoaderTextureIds.begin(); it != sampleLoaderTextureIds.end(); )
        {
            if (activeSampleLoaderIds.find(it->first) == activeSampleLoaderIds.end())
            {
                if (it->second)
                    it->second.reset();
                it = sampleLoaderTextureIds.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }
    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { 
                if (currentPresetFile.existsAsFile()) {
                    savePresetToFile(currentPresetFile);
                } else {
                    startSaveDialog();
                }
            }
            if (ImGui::MenuItem("Save Preset As...", "Ctrl+Alt+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            
            ImGui::Separator();
            
            // Plugin scanning menu item
            if (ImGui::MenuItem("Scan for Plugins..."))
            {
                // Get the application instance to access plugin management
                auto& app = PresetCreatorApplication::getApp();
                auto& formatManager = app.getPluginFormatManager();
                auto& knownPluginList = app.getKnownPluginList();

                // 1. Find the VST3 format
                juce::VST3PluginFormat* vst3Format = nullptr;
                for (int i = 0; i < formatManager.getNumFormats(); ++i)
                {
                    if (auto* format = formatManager.getFormat(i); format->getName() == "VST3")
                    {
                        vst3Format = dynamic_cast<juce::VST3PluginFormat*>(format);
                        break;
                    }
                }

                if (vst3Format != nullptr)
                {
                    // 2. Define the specific folder to scan
                    juce::File vstDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile)
                                            .getParentDirectory().getChildFile("VST");

                    juce::FileSearchPath searchPath;
                    if (vstDir.isDirectory())
                    {
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Starting scan in: " + vstDir.getFullPathName());
                    }
                    else
                    {
                        vstDir.createDirectory();
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Created VST directory at: " + vstDir.getFullPathName());
                    }

                    // 3. Scan for plugins
                    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                        .getChildFile(app.getApplicationName());
                    
                    juce::PluginDirectoryScanner scanner(knownPluginList, *vst3Format, searchPath, true,
                                                         appDataDir.getChildFile("dead_plugins.txt"), true);

                    // 4. Perform the scan
                    juce::String pluginBeingScanned;
                    int numFound = 0;
                    while (scanner.scanNextFile(true, pluginBeingScanned))
                    {
                        juce::Logger::writeToLog("[VST Scan] Scanning: " + pluginBeingScanned);
                        ++numFound;
                    }
                    
                    juce::Logger::writeToLog("[VST Scan] Scan complete. Found " + juce::String(numFound) + " plugin(s).");
                    juce::Logger::writeToLog("[VST Scan] Total plugins in list: " + juce::String(knownPluginList.getNumTypes()));
                    
                    // 5. Save the updated plugin list
                    auto pluginListFile = appDataDir.getChildFile("known_plugins.xml");
                    if (auto pluginListXml = knownPluginList.createXml())
                    {
                        if (pluginListXml->writeTo(pluginListFile))
                        {
                            juce::Logger::writeToLog("[VST Scan] Saved plugin list to: " + pluginListFile.getFullPathName());
                        }
                    }
                }
                else
                {
                    juce::Logger::writeToLog("[VST Scan] ERROR: VST3 format not found in format manager.");
                }
            }
            
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }
        
        // ========================================================================
        // SETTINGS MENU - Global GPU/CPU Configuration, Audio, and MIDI
        // ========================================================================
        if (ImGui::BeginMenu("Settings"))
        {
            // Audio Settings
            if (ImGui::MenuItem("Audio Settings..."))
            {
                if (onShowAudioSettings)
                    onShowAudioSettings();
            }
            
            // MIDI Device Manager
            if (ImGui::MenuItem("MIDI Device Manager..."))
            {
                showMidiDeviceManager = !showMidiDeviceManager;
            }

            if (ImGui::MenuItem("Help Manager...", "F1"))
            {
                m_helpManager.open();
                m_helpManager.setActiveTab(0); // Open to Shortcuts tab
            }
            
            ImGui::Separator();

                if (ImGui::BeginMenu("Theme"))
                {
                    if (ImGui::MenuItem("Edit Current Theme..."))
                    {
                        themeEditor.open();
                    }
                    ImGui::Separator();
                    
                    // Dynamic theme scanning - refreshes each time menu is opened
                    auto loadThemePreset = [&](const char* label, const juce::String& filename)
                    {
                        if (ImGui::MenuItem(label))
                        {
                            juce::File presetFile;
                            auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                            auto exeDir = exeFile.getParentDirectory();
                            auto themesDir = exeDir.getChildFile("themes");
                            auto candidate = themesDir.getChildFile(filename);
                            
                            if (candidate.existsAsFile())
                            {
                                if (ThemeManager::getInstance().loadTheme(candidate))
                                {
                                    // Save user preference
                                    ThemeManager::getInstance().saveUserThemePreference(filename);
                                    themeEditor.refreshThemeFromManager();
                                    juce::Logger::writeToLog("[Theme] Loaded: " + juce::String(label));
                                    s_themeToastText = "Theme Loaded: " + juce::String(label);
                                    s_themeToastEndTime = ImGui::GetTime() + 2.0;
                                }
                            }
                        }
                    };
                    
                    // Helper to convert filename to display name
                    auto filenameToDisplayName = [](const juce::String& filename) -> juce::String
                    {
                        juce::String name = filename;
                        // Remove .json extension
                        if (name.endsWithIgnoreCase(".json"))
                            name = name.substring(0, name.length() - 5);
                        
                        // Special case for MoofyDark
                        if (name.equalsIgnoreCase("MoofyDark"))
                            return "Moofy Dark (Default)";
                        
                        // Convert camelCase/PascalCase to Title Case with spaces
                        // e.g., "AtomOneLight" -> "Atom One Light", "ClassicTheme" -> "Classic Theme"
                        juce::String result;
                        for (int i = 0; i < name.length(); ++i)
                        {
                            juce::juce_wchar c = name[i];
                            // Insert space before uppercase letters (except first character)
                            if (i > 0 && juce::CharacterFunctions::isUpperCase(c))
                                result += " ";
                            result += c;
                        }
                        
                        // Handle special cases
                        result = result.replace("Synthwave 84", "Synthwave '84");
                        result = result.replace("RosÃ© Pine", "RosÃ© Pine Moon");
                        result = result.replace("Night Owl", "Night Owl Neo");
                        result = result.replace("Everforest", "Everforest Night");
                        result = result.replace("Dracula Midnight", "Dracula Midnight");
                        
                        return result;
                    };
                    
                    // Scan themes directory for all .json files
                    auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                    auto exeDir = exeFile.getParentDirectory();
                    auto themesDir = exeDir.getChildFile("themes");
                    
                    std::vector<std::pair<juce::String, juce::String>> foundThemes; // {displayName, filename}
                    
                    if (themesDir.exists() && themesDir.isDirectory())
                    {
                        juce::Array<juce::File> themeFiles;
                        themesDir.findChildFiles(themeFiles, juce::File::findFiles, false, "*.json");
                        
                        for (const auto& themeFile : themeFiles)
                        {
                            juce::String filename = themeFile.getFileName();
                            // Skip hidden/system files
                            if (filename.startsWithChar('.'))
                                continue;
                            
                            juce::String displayName = filenameToDisplayName(filename);
                            foundThemes.push_back({displayName, filename});
                        }
                    }
                    
                    // Also check source tree for development (fallback)
                    {
                        auto sourceThemesDir = exeDir.getParentDirectory().getParentDirectory()
                            .getChildFile("Source")
                            .getChildFile("preset_creator")
                            .getChildFile("theme")
                            .getChildFile("presets");
                        
                        if (sourceThemesDir.exists() && sourceThemesDir.isDirectory())
                        {
                            juce::Array<juce::File> sourceThemeFiles;
                            sourceThemesDir.findChildFiles(sourceThemeFiles, juce::File::findFiles, false, "*.json");
                            
                            for (const auto& themeFile : sourceThemeFiles)
                            {
                                juce::String filename = themeFile.getFileName();
                                if (filename.startsWithChar('.'))
                                    continue;
                                
                                // Check if we already have this theme from exe/themes
                                bool alreadyFound = false;
                                for (const auto& existing : foundThemes)
                                {
                                    if (existing.second.equalsIgnoreCase(filename))
                                    {
                                        alreadyFound = true;
                                        break;
                                    }
                                }
                                
                                if (!alreadyFound)
                                {
                                    juce::String displayName = filenameToDisplayName(filename);
                                    foundThemes.push_back({displayName, filename});
                                }
                            }
                        }
                    }
                    
                    // Sort themes alphabetically by display name
                    std::sort(foundThemes.begin(), foundThemes.end(), [](const auto& a, const auto& b)
                    {
                        return a.first.compareIgnoreCase(b.first) < 0;
                    });
                    
                    // Render menu items from dynamically found themes
                    for (const auto& theme : foundThemes)
                    {
                        loadThemePreset(theme.first.toRawUTF8(), theme.second);
                    }
                    
                    // If no themes found, show a message
                    if (foundThemes.empty())
                    {
                        ImGui::TextDisabled("No themes found in themes/ directory");
                    }

                    ImGui::EndMenu();
                }
            
            ImGui::Separator();
            
            #if WITH_CUDA_SUPPORT
                bool gpuEnabled = getGlobalGpuEnabled();
                if (ImGui::Checkbox("Enable GPU Acceleration (CUDA)", &gpuEnabled))
                {
                    setGlobalGpuEnabled(gpuEnabled);
                    juce::Logger::writeToLog("[Settings] Global GPU: " + juce::String(gpuEnabled ? "ENABLED" : "DISABLED"));
                }
                
                ImGui::TextDisabled("This setting controls all vision nodes:");
                ImGui::TextDisabled("  - Pose Estimator");
                ImGui::TextDisabled("  - Hand Tracker");
                ImGui::TextDisabled("  - Face Tracker");
                ImGui::TextDisabled("  - Object Detector");
                ImGui::TextDisabled("  - Human Detector");
                ImGui::TextDisabled("  - Color Tracker");
                ImGui::TextDisabled("  - Contour Detector");
                ImGui::TextDisabled("  - Movement Detector");
                ImGui::TextDisabled("  - Semantic Segmentation");
                
                ImGui::Separator();
                
                // Show CUDA device info
                #if WITH_CUDA_SUPPORT
                    int deviceCount = cv::cuda::getCudaEnabledDeviceCount();
                    if (deviceCount > 0)
                    {
                        ThemeText("CUDA Available", theme.text.success);
                        ImGui::Text("GPU Devices: %d", deviceCount);
                    }
                    else
                    {
                        ThemeText("CUDA compiled but no devices found", theme.text.warning);
                    }
                #endif
            #else
                ImGui::TextDisabled("GPU Acceleration: Not Compiled");
                ImGui::TextDisabled("Rebuild with CUDA support to enable");
            #endif
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Actions"))
        {
            // This item should only be enabled if at least one node is selected
            bool anyNodesSelected = ImNodes::NumSelectedNodes() > 0;
            bool multipleNodesSelected = ImNodes::NumSelectedNodes() > 1;
            
            if (ImGui::MenuItem("Connect Selected to Track Mixer", nullptr, false, anyNodesSelected))
            {
                handleConnectSelectedToTrackMixer();
            }
            
            // Meta Module: Collapse selected nodes into a reusable sub-patch
            // if (ImGui::MenuItem("Collapse to Meta Module", "Ctrl+Shift+M", false, multipleNodesSelected))
            // {
            //     handleCollapseToMetaModule();
            // }
            
            if (ImGui::MenuItem("Record Output", "Ctrl+R"))
            {
                handleRecordOutput();
            }
            
            if (ImGui::MenuItem("Beautify Layout", "Ctrl+B"))
            {
                handleBeautifyLayout();
            }
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Recording"))
        {
            if (synth != nullptr)
            {
                bool isAnyRecording = synth->isAnyModuleRecording();
                const char* label = isAnyRecording ? "Stop All Recordings" : "Start All Recordings";
                if (ImGui::MenuItem(label))
                {
                    if (isAnyRecording)
                    {
                        synth->stopAllRecorders();
                    }
                    else
                    {
                        synth->startAllRecorders();
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Insert Node"))
        {
            bool isNodeSelected = (selectedLogicalId != 0);
            
            if (ImGui::BeginMenu("Effects", isNodeSelected))
            {
                if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); }
                if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); }
                if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); }
                if (ImGui::MenuItem("Chorus")) { insertNodeBetween("chorus"); }
                if (ImGui::MenuItem("Phaser")) { insertNodeBetween("phaser"); }
                if (ImGui::MenuItem("Compressor")) { insertNodeBetween("compressor"); }
                if (ImGui::MenuItem("Limiter")) { insertNodeBetween("limiter"); }
                if (ImGui::MenuItem("Noise Gate")) { insertNodeBetween("gate"); }
                if (ImGui::MenuItem("Reroute")) { insertNodeBetween("reroute"); }
                if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
                if (ImGui::MenuItem("Graphic EQ")) { insertNodeBetween("graphic_eq"); }
                if (ImGui::MenuItem("Waveshaper")) { insertNodeBetween("waveshaper"); }
                if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); }
                if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); }
                if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); }
                if (ImGui::MenuItem("Time/Pitch Shifter")) { insertNodeBetween("timepitch"); }
                if (ImGui::MenuItem("De-Crackle")) { insertNodeBetween("de_crackle"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Modulators", isNodeSelected))
            {
                if (ImGui::MenuItem("LFO")) { insertNodeBetween("lfo"); }
                if (ImGui::MenuItem("ADSR")) { insertNodeBetween("adsr"); }
                if (ImGui::MenuItem("Random")) { insertNodeBetween("random"); }
                if (ImGui::MenuItem("S&H")) { insertNodeBetween("s_and_h"); }
                if (ImGui::MenuItem("Function Generator")) { insertNodeBetween("function_generator"); }
                if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Utilities & Logic", isNodeSelected))
            {
                if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); }
                if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); }
                if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); }
                if (ImGui::MenuItem("Track Mixer")) { insertNodeBetween("track_mixer"); }
                if (ImGui::MenuItem("PanVol")) { insertNodeBetween("panvol"); }
                if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); }
                if (ImGui::MenuItem("Lag Processor")) { insertNodeBetween("lag_processor"); }
                if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); }
                if (ImGui::MenuItem("Map Range")) { insertNodeBetween("map_range"); }
                if (ImGui::MenuItem("Quantizer")) { insertNodeBetween("quantizer"); }
                if (ImGui::MenuItem("Rate")) { insertNodeBetween("rate"); }
                if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); }
                if (ImGui::MenuItem("Logic")) { insertNodeBetween("logic"); }
                if (ImGui::MenuItem("Reroute")) { insertNodeBetween("reroute"); }
                if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Computer Vision", isNodeSelected))
            {
                if (ImGui::MenuItem("Video FX")) { insertNodeBetween("video_fx"); }
                if (ImGui::MenuItem("Crop Video")) { insertNodeBetween("crop_video"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("TTS", isNodeSelected))
            {
                if (ImGui::MenuItem("TTS Performer")) { insertNodeBetween("tts_performer"); }
                if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Analysis", isNodeSelected))
            {
                if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); }
                if (ImGui::MenuItem("Frequency Graph")) { insertNodeBetween("frequency_graph"); }
                ImGui::EndMenu();
            }
            
            ImGui::EndMenu();
        }
        // === DEBUG MENU ===
        if (ImGui::BeginMenu("Debug"))
        {
            if (ImGui::MenuItem("Show System Diagnostics", "Ctrl+Shift+D")) 
            {
                showDebugMenu = !showDebugMenu;
            }
            
            
            if (ImGui::MenuItem("Log System State"))
            {
                if (synth != nullptr)
                {
                    juce::Logger::writeToLog("=== SYSTEM DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getSystemDiagnostics());
                }
            }
            
            if (ImGui::MenuItem("Log Selected Module Diagnostics"))
            {
                if (synth != nullptr && selectedLogicalId != 0)
                {
                    juce::Logger::writeToLog("=== MODULE DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getModuleDiagnostics(selectedLogicalId));
                }
            }
            
            ImGui::EndMenu();
        }
        
        // === TRANSPORT CONTROLS ===
        if (synth != nullptr)
        {
            // Get current transport state
            auto transportState = synth->getTransportState();
            
            // Add some spacing before transport controls
            ImGui::Separator();
            ImGui::Spacing();
            
            // Play/Pause button
            if (transportState.isPlaying)
            {
                if (ImGui::Button("Pause"))
                    synth->setPlaying(false);
            }
            else
            {
                if (ImGui::Button("Play"))
                    synth->setPlaying(true);
            }
            
            ImGui::SameLine();
            
            // Stop button (resets position)
            if (ImGui::Button("Stop"))
            {
                synth->setPlaying(false);
                synth->resetTransportPosition();
            }
            
            ImGui::SameLine();
            
            // BPM control (greyed out if controlled by Tempo Clock module)
            float bpm = static_cast<float>(transportState.bpm);
            ImGui::SetNextItemWidth(80.0f);
            
            bool isControlled = transportState.isTempoControlledByModule.load();
            if (isControlled)
                ImGui::BeginDisabled();
                
            if (ImGui::DragFloat("BPM", &bpm, 0.1f, 20.0f, 999.0f, "%.1f"))
                synth->setBPM(static_cast<double>(bpm));
                
            if (isControlled)
            {
                ImGui::EndDisabled();
                if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
                {
                    ImGui::BeginTooltip();
                    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                    ThemeText("Tempo Clock Module Active", theme.text.warning);
                    ImGui::TextUnformatted("A Tempo Clock node with 'Sync to Host' disabled is controlling the global BPM.");
                    ImGui::PopTextWrapPos();
                    ImGui::EndTooltip();
                }
            }
            
            ImGui::SameLine();
            
            // Position display
            ImGui::Text("%.2f beats", transportState.songPositionBeats);
        }
        // === MULTI-MIDI DEVICE ACTIVITY INDICATOR ===
        ImGui::SameLine();
        ImGui::Separator();
        ImGui::SameLine();
        if (synth != nullptr)
        {
            auto activityState = synth->getMidiActivityState();
            
            if (activityState.deviceNames.empty())
            {
                // No MIDI devices connected
                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                ImGui::Text("MIDI: No Devices");
                ImGui::PopStyleColor();
            }
            else
            {
                ImGui::Text("MIDI:");
                ImGui::SameLine();
                
                // Display each device with active channels
                for (const auto& [deviceIndex, deviceName] : activityState.deviceNames)
                {
                    ImGui::SameLine();
                    
                    bool hasActivity = false;
                    if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                    {
                        const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                        for (bool active : channels)
                        {
                            if (active)
                            {
                                hasActivity = true;
                                break;
                            }
                        }
                    }
                    
                    // Abbreviated device name (max 12 chars)
                    juce::String abbrevName = deviceName;
                    if (abbrevName.length() > 12)
                        abbrevName = abbrevName.substring(0, 12) + "...";
                    
                    // Color: bright green if active, dim gray if inactive
                    if (hasActivity)
                        ImGui::PushStyleColor(ImGuiCol_Text, theme.text.active);
                    else
                        ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                    
                    ImGui::Text("[%s]", abbrevName.toRawUTF8());
                    ImGui::PopStyleColor();
                    
                    // Tooltip with full name and active channels
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("%s", deviceName.toRawUTF8());
                        ImGui::Separator();
                        
                        if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                        {
                            const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                            ImGui::Text("Active Channels:");
                            juce::String activeChannels;
                            for (int ch = 0; ch < 16; ++ch)
                            {
                                if (channels[ch])
                                {
                                    if (activeChannels.isNotEmpty())
                                        activeChannels += ", ";
                                    activeChannels += juce::String(ch + 1);
                                }
                            }
                            if (activeChannels.isEmpty())
                                activeChannels = "None";
                            ImGui::Text("%s", activeChannels.toRawUTF8());
                        }
                        
                        ImGui::EndTooltip();
                    }
                }
            }
        }
        else
        {
            ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
            ImGui::Text("MIDI: ---");
            ImGui::PopStyleColor();
        }
        // === END OF MULTI-MIDI INDICATOR ===

        // --- ZOOM DISPLAY (menu bar, right side) ---
#if defined(IMNODES_ZOOM_ENABLED)
        if (ImNodes::GetCurrentContext())
        {
            ImGui::SameLine();
            ImGui::Separator();
            ImGui::SameLine();
            ImGui::Text("Zoom: %.2fx", ImNodes::EditorContextGetZoom());
        }
#endif
        // --- END ZOOM DISPLAY ---

        ImGui::EndMainMenuBar();
    }

    // --- PRESET STATUS OVERLAY ---
    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(ThemeManager::getInstance().getCurrentTheme().windows.preset_status_alpha);
    ImGui::Begin("Preset Status", nullptr, 
                 ImGuiWindowFlags_NoDecoration | 
                 ImGuiWindowFlags_NoMove | 
                 ImGuiWindowFlags_NoFocusOnAppearing | 
                 ImGuiWindowFlags_NoNav | 
                 ImGuiWindowFlags_AlwaysAutoResize);

    if (currentPresetFile.existsAsFile()) {
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    // Get the theme colors
    if (isPatchDirty) {
        ThemeText("Status: EDITED", theme.status.edited);
    } else {
        ThemeText("Status: SAVED", theme.status.saved);
    }
    ImGui::End();
    // --- END OF PRESET STATUS OVERLAY ---
    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, sidebarWidth);
    // Zoom removed
    // ADD THIS BLOCK:
    ImGui::Text("Browser");
    // Create a scrolling child window to contain the entire browser
    ImGui::BeginChild("BrowserScrollRegion", ImVec2(0, 0), true);
    // Helper lambda to recursively draw the directory tree for presets
    std::function<void(const PresetManager::DirectoryNode*)> drawPresetTree = 
        [&](const PresetManager::DirectoryNode* node)
    {
        if (!node || (node->presets.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawPresetTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw presets in this directory with drag-and-drop support
        for (const auto& preset : node->presets)
        {
            if (m_presetSearchTerm.isEmpty() || preset.name.containsIgnoreCase(m_presetSearchTerm))
            {
                // Draw the selectable item and capture its return value
                bool clicked = ImGui::Selectable(preset.name.toRawUTF8());

                // --- THIS IS THE FIX ---
                // Check if this item is the source of a drag operation
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload type and data (the preset's file path)
                    const juce::String path = preset.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_PRESET_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback while dragging
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Merge Preset: %s", preset.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // If a drag did NOT occur, and the item was clicked, load the preset
                else if (clicked)
                {
                    loadPresetFromFile(preset.file);
                }
                // --- END OF FIX ---
                
                // Tooltip (only shown when hovering, not dragging)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0) && preset.description.isNotEmpty())
                {
                    ImGui::BeginTooltip();
                    ImGui::TextUnformatted(preset.description.toRawUTF8());
                    if (!preset.tags.isEmpty())
                        ImGui::Text("Tags: %s", preset.tags.joinIntoString(", ").toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // Helper to push category colors (used for all module category headers)
    auto pushCategoryColor = [&](ModuleCategory cat) {
        ImU32 color = getImU32ForCategory(cat);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        ImGui::PushStyleColor(ImGuiCol_Header, color);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
        
        // Automatically adjust text color based on background contrast for optimal legibility
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(color);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
    };
    auto pushHeaderColors = [&](const TriStateColor& tri)
    {
        const ImGuiStyle& styleRef = ImGui::GetStyle();
        auto toVec4 = [&](ImU32 value, ImGuiCol fallback) -> ImVec4
        {
            if (value != 0)
                return ImGui::ColorConvertU32ToFloat4(value);
            return styleRef.Colors[fallback];
        };
        ImGui::PushStyleColor(ImGuiCol_Header, toVec4(tri.base, ImGuiCol_Header));
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, toVec4(tri.hovered, ImGuiCol_HeaderHovered));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, toVec4(tri.active, ImGuiCol_HeaderActive));
        
        // Automatically adjust text color based on background luminance for optimal legibility
        // Use the base background color to determine text color (Option B: single text color)
        ImU32 baseBgColor = tri.base != 0 ? tri.base : ImGui::ColorConvertFloat4ToU32(styleRef.Colors[ImGuiCol_Header]);
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(baseBgColor);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
    };
    // === PRESET BROWSER ===
    pushHeaderColors(theme.headers.presets);
    bool presetsExpanded = ImGui::CollapsingHeader("Presets");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (presetsExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_presetScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##presetpath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##preset"))
        {
            presetPathChooser = std::make_unique<juce::FileChooser>("Select Preset Directory", m_presetScanPath);
            presetPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_presetScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("presetScanPath", m_presetScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##preset"))
        {
            m_presetManager.clearCache();
            m_presetManager.scanDirectory(m_presetScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_presetSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##preset", searchBuf, sizeof(searchBuf)))
            m_presetSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical preset tree
        drawPresetTree(m_presetManager.getRootNode());
    }
    
    // Helper lambda to recursively draw the directory tree for samples
    std::function<void(const SampleManager::DirectoryNode*)> drawSampleTree = 
        [&](const SampleManager::DirectoryNode* node)
    {
        if (!node || (node->samples.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawSampleTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw samples in this directory with drag-and-drop support
        for (const auto& sample : node->samples)
        {
            if (m_sampleSearchTerm.isEmpty() || sample.name.containsIgnoreCase(m_sampleSearchTerm))
            {
                // --- THIS IS THE HEROIC FIX ---

                // A. Draw the selectable item and capture its return value (which is true on mouse release).
                bool clicked = ImGui::Selectable(sample.name.toRawUTF8());

                // B. Check if this item is the source of a drag operation. This takes priority.
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload (the data we are transferring is the sample's file path).
                    const juce::String path = sample.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_SAMPLE_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback during the drag.
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Dragging: %s", sample.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // C. If a drag did NOT occur, and the item was clicked (mouse released on it), then create the node.
                else if (clicked)
                {
                    if (synth != nullptr)
                    {
                        auto newNodeId = synth->addModule("sample_loader");
                        auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                        pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                        if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                        {
                            sampleLoader->loadSample(sample.file);
                        }
                        snapshotAfterEditor = true;
                    }
                }
                
                // --- END OF FIX ---

                // (Existing tooltip for sample info remains the same)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Duration: %.2f s", sample.durationSeconds);
                    ImGui::Text("Rate: %d Hz", sample.sampleRate);
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // === SAMPLE BROWSER ===
    pushHeaderColors(theme.headers.samples);
    bool samplesExpanded = ImGui::CollapsingHeader("Samples");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (samplesExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_sampleScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##samplepath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##sample"))
        {
            samplePathChooser = std::make_unique<juce::FileChooser>("Select Sample Directory", m_sampleScanPath);
            samplePathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_sampleScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("sampleScanPath", m_sampleScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##sample"))
        {
            m_sampleManager.clearCache();
            m_sampleManager.scanDirectory(m_sampleScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_sampleSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##sample", searchBuf, sizeof(searchBuf)))
            m_sampleSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical sample tree
        drawSampleTree(m_sampleManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MIDI BROWSER ===
    pushHeaderColors(theme.headers.recent);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI Files");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (midiExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_midiScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##midipath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##midi"))
        {
            midiPathChooser = std::make_unique<juce::FileChooser>("Select MIDI Directory", m_midiScanPath);
            midiPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_midiScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("midiScanPath", m_midiScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##midi"))
        {
            m_midiManager.clearCache();
            m_midiManager.scanDirectory(m_midiScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_midiSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##midi", searchBuf, sizeof(searchBuf)))
            m_midiSearchTerm = juce::String(searchBuf);
        ImGui::Separator();
        // 5. Display hierarchical MIDI tree
        std::function<void(const MidiManager::DirectoryNode*)> drawMidiTree = 
            [&](const MidiManager::DirectoryNode* node)
        {
            if (!node || (node->midiFiles.empty() && node->subdirectories.empty())) return;

            // Draw subdirectories first
            for (const auto& subdir : node->subdirectories)
            {
                if (ImGui::TreeNode(subdir->name.toRawUTF8()))
                {
                    drawMidiTree(subdir.get());
                    ImGui::TreePop();
                }
            }
            
            // Then draw MIDI files in this directory with drag-and-drop support
            for (const auto& midi : node->midiFiles)
            {
                if (m_midiSearchTerm.isEmpty() || midi.name.containsIgnoreCase(m_midiSearchTerm))
                {
                    // Draw the selectable item and capture its return value
                    bool clicked = ImGui::Selectable(midi.name.toRawUTF8());

                    // Check if this item is the source of a drag operation
                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                    {
                        // Set the payload (the MIDI file path)
                        const juce::String path = midi.file.getFullPathName();
                        const std::string pathStr = path.toStdString();
                        ImGui::SetDragDropPayload("DND_MIDI_PATH", pathStr.c_str(), pathStr.length() + 1);
                        
                        // Provide visual feedback during the drag
                        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                        ImGui::Text("Dragging: %s", midi.name.toRawUTF8());
                        
                        ImGui::EndDragDropSource();
                    }
                    // If a drag did NOT occur, and the item was clicked, create a new MIDI Player node
                    else if (clicked)
                    {
                        if (synth != nullptr)
                        {
                            auto newNodeId = synth->addModule("midi_player");
                            auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                            pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                            
                            // Load the MIDI file into the new player
                            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                            {
                                midiPlayer->loadMIDIFile(midi.file);
                            }
                            
                            snapshotAfterEditor = true;
                        }
                    }
                    
                    // Tooltip for MIDI info (only shown when hovering, not dragging)
                    if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("MIDI File: %s", midi.file.getFileName().toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
            }
        };
        
        drawMidiTree(m_midiManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MODULE BROWSER ===
    pushHeaderColors(theme.headers.system);
    bool modulesExpanded = ImGui::CollapsingHeader("Modules", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (modulesExpanded)
    {
    
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
        
        // --- FIX: Show tooltip with module description on hover ---
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            
            // Find the description in our list using the module's internal 'type'
            bool found = false;
            for (const auto& pair : getModuleDescriptions())
            {
                if (pair.first.equalsIgnoreCase(type))
                {
                    // If found, display it
                    ImGui::TextUnformatted(pair.second);
                    found = true;
                    break;
                }
            }
            if (!found)
            {
                // Fallback text if a description is missing
                ImGui::TextUnformatted("No description available.");
            }
            
            ImGui::EndTooltip();
        }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MODULE NAMING CONVENTION:
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
    // ALL module type names MUST follow this strict naming convention:
    //   â€¢ Use ONLY lowercase letters (a-z)
    //   â€¢ Use ONLY numbers (0-9) where appropriate
    //   â€¢ Replace ALL spaces with underscores (_)
    //   â€¢ NO capital letters allowed
    //   â€¢ NO hyphens or other special characters
    //
    // Examples:
    //   âœ“ CORRECT:   "midi_player", "sample_loader", "graphic_eq", "vco"
    //   âœ— INCORRECT: "MIDI Player", "Sample Loader", "Graphic EQ", "VCO"
    //
    // This ensures consistent module identification across the system.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. SOURCES - Signal generators and inputs
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Source);
    bool sourcesExpanded = ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (sourcesExpanded) {
        addModuleButton("VCO", "vco");
        addModuleButton("Polyphonic VCO", "polyvco");
        addModuleButton("Noise", "noise");
        addModuleButton("Audio Input", "audio_input");
        addModuleButton("Sample Loader", "sample_loader");
        addModuleButton("Value", "value");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2. EFFECTS - Audio processing and tone shaping
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Effect);
    bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (effectsExpanded) {
        addModuleButton("VCF", "vcf");
        addModuleButton("Delay", "delay");
        addModuleButton("Reverb", "reverb");
        addModuleButton("Chorus", "chorus");
        addModuleButton("Phaser", "phaser");
        addModuleButton("Compressor", "compressor");
        addModuleButton("Limiter", "limiter");
        addModuleButton("Noise Gate", "gate");
        addModuleButton("Drive", "drive");
        addModuleButton("Graphic EQ", "graphic_eq");
        addModuleButton("Waveshaper", "waveshaper");
        addModuleButton("8-Band Shaper", "8bandshaper");
        addModuleButton("Granulator", "granulator");
        addModuleButton("Harmonic Shaper", "harmonic_shaper");
        addModuleButton("Time/Pitch Shifter", "timepitch");
        addModuleButton("De-Crackle", "de_crackle");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3. MODULATORS - CV generation and modulation sources
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Modulator);
    bool modulatorsExpanded = ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (modulatorsExpanded) {
        addModuleButton("LFO", "lfo");
        addModuleButton("ADSR", "adsr");
        addModuleButton("Random", "random");
        addModuleButton("S&H", "s_and_h");
        addModuleButton("Function Generator", "function_generator");
        addModuleButton("Shaping Oscillator", "shaping_oscillator");
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4. UTILITIES & LOGIC - Signal processing and routing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Utility);
    bool utilitiesExpanded = ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (utilitiesExpanded) {
        addModuleButton("VCA", "vca");
        addModuleButton("Mixer", "mixer");
        addModuleButton("CV Mixer", "cv_mixer");
        addModuleButton("Track Mixer", "track_mixer");
        addModuleButton("Attenuverter", "attenuverter");
        addModuleButton("Reroute", "reroute");
        addModuleButton("Lag Processor", "lag_processor");
        addModuleButton("Math", "math");
        addModuleButton("Map Range", "map_range");
        addModuleButton("Quantizer", "quantizer");
        addModuleButton("Rate", "rate");
        addModuleButton("Comparator", "comparator");
        addModuleButton("Logic", "logic");
        addModuleButton("Clock Divider", "clock_divider");
        addModuleButton("Sequential Switch", "sequential_switch");
        addModuleButton("PanVol", "panvol");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 5. SEQUENCERS - Pattern and rhythm generation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Seq);
    bool sequencersExpanded = ImGui::CollapsingHeader("Sequencers", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (sequencersExpanded) {
        addModuleButton("Sequencer", "sequencer");
        addModuleButton("Multi Sequencer", "multi_sequencer");
        addModuleButton("Tempo Clock", "tempo_clock");
        addModuleButton("Snapshot Sequencer", "snapshot_sequencer");
        addModuleButton("Stroke Sequencer", "stroke_sequencer");
        addModuleButton("Timeline", "timeline");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 6. MIDI - MIDI input/output and controllers
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::MIDI);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (midiExpanded) {
        addModuleButton("MIDI CV", "midi_cv");
        addModuleButton("MIDI Player", "midi_player");
        ImGui::Separator();
        addModuleButton("MIDI Faders", "midi_faders");
        addModuleButton("MIDI Knobs", "midi_knobs");
        addModuleButton("MIDI Buttons", "midi_buttons");
        addModuleButton("MIDI Jog Wheel", "midi_jog_wheel");
        addModuleButton("MIDI Pads", "midi_pads");
        ImGui::Separator();
        addModuleButton("MIDI Logger", "midi_logger");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 7. ANALYSIS - Signal visualization and debugging
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Analysis);
    bool analysisExpanded = ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (analysisExpanded) {
        addModuleButton("Scope", "scope");
        addModuleButton("Debug", "debug");
        addModuleButton("Input Debug", "input_debug");
        addModuleButton("Frequency Graph", "frequency_graph");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 8. TTS - Text-to-Speech and vocal synthesis
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::TTS_Voice);
    bool ttsExpanded = ImGui::CollapsingHeader("TTS", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (ttsExpanded) {
        addModuleButton("TTS Performer", "tts_performer");
        addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 9. SPECIAL - Physics, animation, and experimental
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Special_Exp);
    bool specialExpanded = ImGui::CollapsingHeader("Special", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (specialExpanded) {
        addModuleButton("Physics", "physics");
        addModuleButton("Animation", "animation");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 10. COMPUTER VISION - Video processing and analysis
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::OpenCV);
    bool openCVExpanded = ImGui::CollapsingHeader("Computer Vision", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (openCVExpanded) {
        ThemeText("Sources:", theme.text.section_header);
        addModuleButton("Webcam Loader", "webcam_loader");
        addModuleButton("Video File Loader", "video_file_loader");
        ImGui::Spacing();
        ThemeText("Processors:", theme.text.section_header);
        addModuleButton("Video FX", "video_fx");
        addModuleButton("Movement Detector", "movement_detector");
        addModuleButton("Human Detector", "human_detector");
        addModuleButton("Object Detector", "object_detector");
        addModuleButton("Pose Estimator", "pose_estimator");
        addModuleButton("Hand Tracker", "hand_tracker");
        addModuleButton("Face Tracker", "face_tracker");
        addModuleButton("Color Tracker", "color_tracker");
        addModuleButton("Contour Detector", "contour_detector");
        addModuleButton("Semantic Segmentation", "semantic_segmentation");
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 11. PLUGINS / VST - Third-party audio plugins
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Plugin);
    bool pluginsExpanded = ImGui::CollapsingHeader("Plugins / VST", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (pluginsExpanded) {
        addPluginModules();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 12. SYSTEM - Patch organization and system utilities
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    pushCategoryColor(ModuleCategory::Sys);
    bool systemExpanded = ImGui::CollapsingHeader("System", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (systemExpanded) {
        // addModuleButton("Meta", "meta");
        // addModuleButton("Inlet", "inlet");
        // addModuleButton("Outlet", "outlet");
        addModuleButton("Comment", "comment");
        addModuleButton("Recorder", "recorder");
        ImGui::Separator();
        addModuleButton("Best Practice", "best_practice");
    }
    
    } // End of Modules collapsing header

    // End the scrolling region
    ImGui::EndChild();
    ImGui::NextColumn();
    // --- DEFINITIVE FIX FOR PRESET DRAG-AND-DROP WITH VISUAL FEEDBACK ---
    // Step 1: Define canvas dimensions first (needed for the drop target)
    // Get grid/canvas colors from theme
    auto& themeMgr = ThemeManager::getInstance();
    const ImU32 GRID_COLOR = themeMgr.getGridColor();
    const ImU32 GRID_ORIGIN_COLOR = themeMgr.getGridOriginColor();
    const float GRID_SIZE = themeMgr.getGridSize();
    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Cache canvas dimensions for modal pan logic later
    lastCanvasP0 = canvas_p0;
    lastCanvasSize = canvas_sz;

    // Step 2: Create a full-canvas invisible button to act as our drop area
    ImGui::SetCursorScreenPos(canvas_p0);
    ImGui::InvisibleButton("##canvas_drop_target", canvas_sz);

    const ImGuiStyle& style = ImGui::GetStyle();
    const ImU32 nodeBackground      = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_ChildBg]);
    const ImU32 nodeBackgroundHover = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_FrameBgHovered]);
    const ImU32 nodeBackgroundSel   = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_FrameBgActive]);
    const ImU32 nodeOutline         = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_Border]);

    auto& imnodesStyle = ImNodes::GetStyle();
    imnodesStyle.NodeCornerRounding = style.ChildRounding;
    imnodesStyle.NodeBorderThickness = style.FrameBorderSize;

    ImNodes::PushColorStyle(ImNodesCol_NodeBackground, nodeBackground);
    ImNodes::PushColorStyle(ImNodesCol_NodeBackgroundHovered, nodeBackgroundHover);
    ImNodes::PushColorStyle(ImNodesCol_NodeBackgroundSelected, nodeBackgroundSel);
    ImNodes::PushColorStyle(ImNodesCol_NodeOutline, nodeOutline);

    // Step 3: Make this area a drop target with visual feedback
    if (ImGui::BeginDragDropTarget())
    {
        // Check if a preset payload is being hovered over the canvas
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_PRESET_PATH", ImGuiDragDropFlags_AcceptBeforeDelivery))
        {
            // Draw a semi-transparent overlay to show the canvas is a valid drop zone
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            drawList->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getDropTargetOverlay());
            
            // Check if the mouse button was released to complete the drop
            if (payload->IsDelivery())
            {
                const char* path = (const char*)payload->Data;
                ImVec2 dropPos = ImGui::GetMousePos(); // Get the exact drop position
                mergePresetFromFile(juce::File(path), dropPos);
            }
        }
        ImGui::EndDragDropTarget();
    }
    // --- END OF DEFINITIVE FIX ---

    // Reset cursor position for subsequent drawing
    ImGui::SetCursorScreenPos(canvas_p0);

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinId({0, c.dstChan, true}) : 
                encodePinId({c.dstLogicalId, c.dstChan, true});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = themeMgr.getPinDisconnectedColor();
    const ImU32 colPinConnected = themeMgr.getPinConnectedColor();
    // <<< END OF BLOCK >>>

    // Pre-register is no longer needed - stateless encoding generates IDs on-the-fly
    // (Removed the old pre-registration loop)

    // --- BACKGROUND GRID AND COORDINATE DISPLAY ---
    // (Canvas dimensions already defined above in the drop target code)
    // Draw into the window draw list so colors aren't obscured by window bg
    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    // Note: EditorContextGetPanning() can only be called AFTER BeginNodeEditor()
    // Since we draw the grid before BeginNodeEditor, we use zero panning here
    // The grid will be drawn correctly after BeginNodeEditor is called
    ImVec2 panning = lastEditorPanning;

    // Node canvas bound to the underlying model if available
    // Hide ImNodes' own grid so we only render the custom one above.
    ImNodes::PushColorStyle(ImNodesCol_GridBackground, IM_COL32(0, 0, 0, 0));
    ImNodes::PushColorStyle(ImNodesCol_GridLine, IM_COL32(0, 0, 0, 0));
    ImNodes::PushColorStyle(ImNodesCol_GridLinePrimary, IM_COL32(0, 0, 0, 0));

    // Draw canvas background (behind everything)
    draw_list->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getCanvasBackground());

    // Draw grid lines
    for (float x = fmodf(panning.x, GRID_SIZE); x < canvas_sz.x; x += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p0.y + canvas_sz.y), GRID_COLOR);
    for (float y = fmodf(panning.y, GRID_SIZE); y < canvas_sz.y; y += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + y), GRID_SIZE);
    // Draw thicker lines for the origin (0,0)
    ImVec2 origin_on_screen = ImVec2(canvas_p0.x + panning.x, canvas_p0.y + panning.y);
    draw_list->AddLine(ImVec2(origin_on_screen.x, canvas_p0.y), ImVec2(origin_on_screen.x, canvas_p1.y), GRID_ORIGIN_COLOR, 2.0f);
    draw_list->AddLine(ImVec2(canvas_p0.x, origin_on_screen.y), ImVec2(canvas_p1.x, origin_on_screen.y), GRID_ORIGIN_COLOR, 2.0f);
    // Draw scale markers every SCALE_INTERVAL grid units as a grid (not a cross)
    const float SCALE_INTERVAL = themeMgr.getScaleInterval();
    const ImU32 SCALE_TEXT_COLOR = themeMgr.getScaleTextColor();
    ImDrawList* fg_draw_list = ImGui::GetForegroundDrawList();
    // X-axis scale markers - always at the bottom edge
    float gridLeft = -panning.x;
    float gridRight = canvas_sz.x - panning.x;
    int startX = (int)std::floor(gridLeft / SCALE_INTERVAL);
    int endX = (int)std::ceil(gridRight / SCALE_INTERVAL);
    for (int i = startX; i <= endX; ++i)
    {
        float gridX = i * SCALE_INTERVAL;
        float screenX = canvas_p0.x + panning.x + gridX;
        
        // Only draw if visible on screen
        if (screenX >= canvas_p0.x && screenX <= canvas_p1.x)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridX);
            // Always draw at bottom edge
            fg_draw_list->AddText(ImVec2(screenX + 2, canvas_p1.y - 45), SCALE_TEXT_COLOR, label);
        }
    }
    
    // Y-axis scale markers - always at the left edge
    float gridTop = -panning.y;
    float gridBottom = canvas_sz.y - panning.y;
    int startY = (int)std::floor(gridTop / SCALE_INTERVAL);
    int endY = (int)std::ceil(gridBottom / SCALE_INTERVAL);
    
    for (int i = startY; i <= endY; ++i)
    {
        float gridY = i * SCALE_INTERVAL;
        float screenY = canvas_p0.y + panning.y + gridY;
        
        // Only draw if visible on screen
        if (screenY >= canvas_p0.y && screenY <= canvas_p1.y)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridY);
            // Always draw at left edge
            fg_draw_list->AddText(ImVec2(canvas_p0.x + 5, screenY + 2), SCALE_TEXT_COLOR, label);
        }
    }
    // Mouse coordinate display overlay (bottom-left)
    ImVec2 mouseScreenPos = ImGui::GetMousePos();
    ImVec2 mouseGridPos = ImVec2(mouseScreenPos.x - canvas_p0.x - panning.x, mouseScreenPos.y - canvas_p0.y - panning.y);
    char posStr[32];
    snprintf(posStr, sizeof(posStr), "%.0f, %.0f", mouseGridPos.x, mouseGridPos.y);
    // Use the foreground draw list to ensure text is on top of everything
    // Position at bottom-left: canvas_p1.y is bottom edge, subtract text height plus padding
    ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), themeMgr.getMousePositionText(), posStr);
    // --- END OF BACKGROUND GRID AND COORDINATE DISPLAY ---
    // Node canvas bound to the underlying model if available
    // Keep ImNodes' background/panning grid visible, but colour-match to theme overrides.
    ImNodes::PushColorStyle(ImNodesCol_GridBackground, themeMgr.getCanvasBackground());
    ImNodes::PushColorStyle(ImNodesCol_GridLine, GRID_COLOR);
    ImNodes::PushColorStyle(ImNodesCol_GridLinePrimary, GRID_ORIGIN_COLOR);
    ImNodes::PushColorStyle(ImNodesCol_BoxSelector, themeMgr.getSelectionRect());
    ImNodes::PushColorStyle(ImNodesCol_BoxSelectorOutline, themeMgr.getSelectionRectOutline());
    // === END OF FIX ===
    ImNodes::BeginNodeEditor();
    lastEditorPanning = ImNodes::EditorContextGetPanning();
    // Now we can safely get the actual panning for any future use
    // (Grid is already drawn with zero panning above, which is fine for background)
    // Begin the editor
    // +++ ADD THIS LINE AT THE START OF THE RENDER LOOP +++
    attrPositions.clear(); // Clear the cache at the beginning of each frame.
    auto cancelDragInsert = [this]()
    {
        dragInsertActive = false;
        dragInsertStartAttrId = -1;
        dragInsertStartPin = PinID{};
        shouldOpenDragInsertPopup = false;
    };
    // Rebuild mod attribute mapping from currently drawn nodes only
    // modAttrToParam.clear(); // TODO: Remove when fully migrated
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    // Track duplicates to diagnose disappearing pins
    std::unordered_set<int> seenAttrs;
    auto linkIdOf = [this] (int srcAttr, int dstAttr) -> int
    {
        return getLinkId(srcAttr, dstAttr);
    };
    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                if (!(x == 0.0f && y == 0.0f))
                    pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        // Graph is now always in consistent state since we rebuild at frame start
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;
            juce::String moduleLabel = type + " [lid=" + juce::String((int) lid) + "]";

            // Color-code modules by category (base colors)
            const auto moduleCategory = getModuleCategory(type);
            ImU32 baseTitleBarColor = getImU32ForCategory(moduleCategory);
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, baseTitleBarColor);
            ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));

            // Determine the actual title bar color that will be used (checking overrides in order)
            ImU32 actualTitleBarColor = baseTitleBarColor;
            
            // Highlight nodes participating in the hovered link (overrides category color)
            const bool isHoveredSource = (hoveredLinkSrcId != 0 && hoveredLinkSrcId == (juce::uint32) lid);
            const bool isHoveredDest   = (hoveredLinkDstId != 0 && hoveredLinkDstId == (juce::uint32) lid);
            if (isHoveredSource || isHoveredDest)
            {
                actualTitleBarColor = IM_COL32(255, 220, 0, 255);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, actualTitleBarColor);
            }

            // Visual feedback for muted nodes (overrides category color and hover)
            const bool isMuted = mutedNodeStates.count(lid) > 0;
            if (isMuted) {
                actualTitleBarColor = IM_COL32(80, 80, 80, 255);
                ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, actualTitleBarColor);
            }

#if JUCE_DEBUG
            gLastRenderedNodeLabel = moduleLabel;
#endif
            ImNodes::BeginNode ((int) lid);
#if JUCE_DEBUG
            ++gImNodesNodeDepth;
#endif
            ImNodes::BeginNodeTitleBar();
            
            // Calculate optimal text color based on title bar background color
            ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(actualTitleBarColor);
            ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(optimalTextColor));
            
            // Special handling for reroute nodes: show dynamic type in name
            if (type.equalsIgnoreCase("reroute"))
            {
                if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(lid)))
                {
                    PinDataType passthroughType = reroute->getPassthroughType();
                    juce::String typeName;
                    switch (passthroughType)
                    {
                        case PinDataType::CV:    typeName = "CV"; break;
                        case PinDataType::Audio: typeName = "Audio"; break;
                        case PinDataType::Gate:  typeName = "Gate"; break;
                        case PinDataType::Raw:   typeName = "Raw"; break;
                        case PinDataType::Video: typeName = "Video"; break;
                        default:                 typeName = "Audio"; break;
                    }
                    juce::String displayName = "Reroute " + typeName;
                    ImGui::TextUnformatted(displayName.toRawUTF8());
                }
                else
                {
                    ImGui::TextUnformatted(type.toRawUTF8());
                }
            }
            else
            {
                ImGui::TextUnformatted(type.toRawUTF8());
            }
            
            // Pop the text color we pushed
            ImGui::PopStyleColor();
            
            ImNodes::EndNodeTitleBar();

            // Get node content width - check if module has custom size, otherwise use default
            float nodeContentWidth = 240.0f; // Default width
            if (auto* mp = synth->getModuleForLogical(lid))
            {
                ImVec2 customSize = mp->getCustomNodeSize();
                if (customSize.x > 0.0f) // Module specified a custom width
                {
                    nodeContentWidth = customSize.x;
                }
            }

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
if (auto* mp = synth->getModuleForLogical (lid))
{
    ImGui::PushID ((int) lid);
#if JUCE_DEBUG
    ImGuiStackBalanceChecker parameterStackGuard;
    ImNodesDepthSnapshot depthSnapshot(moduleLabel + "::drawParametersInNode");
#endif

    // This new lambda function checks if a parameter is being modulated
    auto isParamModulated = [&](const juce::String& paramId) -> bool {
        if (!synth) return false;
        if (auto* mp = synth->getModuleForLogical(lid))
        {
            int busIdx = -1, chInBus = -1;
            // Use the new standardized routing API on the module itself
            if (!mp->getParamRouting(paramId, busIdx, chInBus)) 
                return false;

            // Calculate the absolute channel index that the graph uses for this bus/channel pair
            const int absoluteChannelIndex = mp->getChannelIndexInProcessBlockBuffer(true, busIdx, chInBus);
            if (absoluteChannelIndex < 0) return false;
            
            // Scan the simple graph connections for a match
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == lid && c.dstChan == absoluteChannelIndex)
                    return true;
            }
        }
        return false;
    };

    // Helper to read a live, modulated value if available (respects _mod alias)
    auto getLiveValueOr = [&](const juce::String& paramId, float fallback) -> float
    {
        if (!synth) return fallback;
        if (auto* mp = synth->getModuleForLogical(lid))
            return mp->getLiveParamValueFor(paramId + "_mod", paramId + "_live", fallback);
        return fallback;
    };
    // Create a new function that calls pushSnapshot
    auto onModificationEnded = [&](){ this->pushSnapshot(); };
    // --- SPECIAL RENDERING FOR SAMPLE LOADER ---
    if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (buttons, sliders, etc.)
        // We pass a modified onModificationEnded to avoid creating undo states while dragging.
        sampleLoader->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);

        // Now, handle the spectrogram texture and drawing
        juce::OpenGLTexture* texturePtr = nullptr;
        if (auto it = sampleLoaderTextureIds.find((int)lid); it != sampleLoaderTextureIds.end())
            texturePtr = it->second.get();

        juce::Image spectrogram = sampleLoader->getSpectrogramImage();
        if (spectrogram.isValid())
        {
            if (texturePtr == nullptr)
            {
                auto tex = std::make_unique<juce::OpenGLTexture>();
                texturePtr = tex.get();
                sampleLoaderTextureIds[(int)lid] = std::move(tex);
            }
            // Upload or update texture from JUCE image (handles format & parameters internally)
            texturePtr->loadImage(spectrogram);

            ImGui::Image((void*)(intptr_t) texturePtr->getTextureID(), ImVec2(nodeContentWidth, 100.0f));

            // Drag state is tracked per Sample Loader node to avoid cross-node interference
            static std::unordered_map<int,int> draggedHandleByNode; // lid -> -1,0,1
            int& draggedHandle = draggedHandleByNode[(int) lid];
            if (draggedHandle != 0 && draggedHandle != 1) draggedHandle = -1;
            ImGui::SetCursorScreenPos(ImGui::GetItemRectMin());
            ImGui::InvisibleButton("##spectrogram_interaction", ImVec2(nodeContentWidth, 100.0f));

            auto* drawList = ImGui::GetWindowDrawList();
            const ImVec2 rectMin = ImGui::GetItemRectMin();
            const ImVec2 rectMax = ImGui::GetItemRectMax();

            float startNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeStart")->load();
            float endNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeEnd")->load();

            // Use live telemetry values when modulated
            startNorm = sampleLoader->getLiveParamValueFor("rangeStart_mod", "rangeStart_live", startNorm);
            endNorm = sampleLoader->getLiveParamValueFor("rangeEnd_mod", "rangeEnd_live", endNorm);

            // Visual guard even when modulated
            const float kMinGap = 0.001f;
            startNorm = juce::jlimit(0.0f, 1.0f, startNorm);
            endNorm   = juce::jlimit(0.0f, 1.0f, endNorm);
            if (startNorm >= endNorm)
            {
                if (startNorm <= 1.0f - kMinGap)
                    endNorm = juce::jmin(1.0f, startNorm + kMinGap);
                else
                    startNorm = juce::jmax(0.0f, endNorm - kMinGap);
            }

            // --- FIX FOR BUG 1: Separate modulation checks for each handle ---
            bool startIsModulated = isParamModulated("rangeStart_mod");
            bool endIsModulated = isParamModulated("rangeEnd_mod");

            const bool itemHovered = ImGui::IsItemHovered();
            const bool itemActive  = ImGui::IsItemActive();
            if (itemHovered)
            {
                ImVec2 mousePos = ImGui::GetMousePos();
                float startHandleX = rectMin.x + startNorm * nodeContentWidth;
                float endHandleX = rectMin.x + endNorm * nodeContentWidth;

                bool canDragStart = !startIsModulated && (std::abs(mousePos.x - startHandleX) < 5);
                bool canDragEnd = !endIsModulated && (std::abs(mousePos.x - endHandleX) < 5);

                if (draggedHandle == -1 && (canDragStart || canDragEnd))
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                }

                if (ImGui::IsItemClicked())
                {
                    // Only allow dragging to start if the corresponding handle is not modulated
                    if (canDragStart && canDragEnd)
                        draggedHandle = (std::abs(mousePos.x - startHandleX) < std::abs(mousePos.x - endHandleX)) ? 0 : 1;
                    else if (canDragStart)
                        draggedHandle = 0;
                    else if (canDragEnd)
                        draggedHandle = 1;
                }
            }

            if (itemActive && ImGui::IsMouseReleased(0))
            {
                if (draggedHandle != -1) onModificationEnded();
                draggedHandle = -1;
            }

            // Handle the drag update, checking the specific modulation flag for the active handle
            if (itemActive && draggedHandle != -1 && ImGui::IsMouseDragging(0))
            {
                float newNormX = juce::jlimit(0.0f, 1.0f, (ImGui::GetMousePos().x - rectMin.x) / nodeContentWidth);
                if (draggedHandle == 0 && !startIsModulated)
                {
                    // Guard: start cannot be >= end
                    startNorm = juce::jmin(newNormX, endNorm - 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeStart")->setValueNotifyingHost(startNorm);
                }
                else if (draggedHandle == 1 && !endIsModulated)
                {
                    // Guard: end cannot be <= start
                    endNorm = juce::jmax(newNormX, startNorm + 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeEnd")->setValueNotifyingHost(endNorm);
                }
            }

            float startX = rectMin.x + startNorm * nodeContentWidth;
            float endX = rectMin.x + endNorm * nodeContentWidth;
            drawList->AddRectFilled(rectMin, ImVec2(startX, rectMax.y), IM_COL32(0, 0, 0, 120));
            drawList->AddRectFilled(ImVec2(endX, rectMin.y), rectMax, IM_COL32(0, 0, 0, 120));
            drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
            drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
        }
    }
    // --- SPECIAL RENDERING FOR AUDIO INPUT (MULTI-CHANNEL) ---
    else if (auto* audioIn = dynamic_cast<AudioInputModuleProcessor*>(mp))
    {
        auto& apvts = audioIn->getAPVTS();

        // --- Device Selectors ---
        juce::AudioDeviceManager::AudioDeviceSetup setup;
        deviceManager.getAudioDeviceSetup(setup);
        
        // Input Device
        juce::StringArray availableInputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableInputDevices = deviceType->getDeviceNames(true);
        }
        std::vector<const char*> inputDeviceItems;
        for (const auto& name : availableInputDevices) inputDeviceItems.push_back(name.toRawUTF8());
        int currentInputDeviceIndex = availableInputDevices.indexOf(setup.inputDeviceName);
        if (currentInputDeviceIndex < 0) currentInputDeviceIndex = 0;

        ImGui::PushItemWidth(nodeContentWidth);
        if (ImGui::Combo("Input Device", &currentInputDeviceIndex, inputDeviceItems.data(), (int)inputDeviceItems.size())) {
            if (currentInputDeviceIndex < availableInputDevices.size()) {
                setup.inputDeviceName = availableInputDevices[currentInputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }

        // Output Device
        juce::StringArray availableOutputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableOutputDevices = deviceType->getDeviceNames(false);
        }
        std::vector<const char*> outputDeviceItems;
        for (const auto& name : availableOutputDevices) outputDeviceItems.push_back(name.toRawUTF8());
        int currentOutputDeviceIndex = availableOutputDevices.indexOf(setup.outputDeviceName);
        if (currentOutputDeviceIndex < 0) currentOutputDeviceIndex = 0;
        
        if (ImGui::Combo("Output Device", &currentOutputDeviceIndex, outputDeviceItems.data(), (int)outputDeviceItems.size())) {
            if (currentOutputDeviceIndex < availableOutputDevices.size()) {
                setup.outputDeviceName = availableOutputDevices[currentOutputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }
        
        // --- Channel Count ---
        auto* numChannelsParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("numChannels"));
        int numChannels = numChannelsParam->get();
        if (ImGui::SliderInt("Channels", &numChannels, 1, AudioInputModuleProcessor::MAX_CHANNELS)) {
            *numChannelsParam = numChannels;
            onModificationEnded();
        }
        
        // --- Threshold Sliders ---
        auto* gateThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"));
        float gateThresh = gateThreshParam->get();
        if (ImGui::SliderFloat("Gate Threshold", &gateThresh, 0.0f, 1.0f, "%.3f")) {
            *gateThreshParam = gateThresh;
            onModificationEnded();
        }
        
        auto* trigThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("triggerThreshold"));
        float trigThresh = trigThreshParam->get();
        if (ImGui::SliderFloat("Trigger Threshold", &trigThresh, 0.0f, 1.0f, "%.3f")) {
            *trigThreshParam = trigThresh;
            onModificationEnded();
        }
        
        ImGui::PopItemWidth();

        // --- Dynamic Channel Selectors & VU Meters ---
        auto hardwareChannels = deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getInputChannelNames() : juce::StringArray{};
        if (!hardwareChannels.isEmpty())
        {
            std::vector<const char*> hwChannelItems;
            for (const auto& name : hardwareChannels) hwChannelItems.push_back(name.toRawUTF8());
            
            for (int i = 0; i < numChannels; ++i) {
                auto* mappingParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(i)));
                int selectedHwChannel = mappingParam->get();
                selectedHwChannel = juce::jlimit(0, (int)hwChannelItems.size() - 1, selectedHwChannel);

                ImGui::PushID(i);
                ImGui::PushItemWidth(nodeContentWidth * 0.6f);
                if (ImGui::Combo(("Input for Out " + juce::String(i + 1)).toRawUTF8(), &selectedHwChannel, hwChannelItems.data(), (int)hwChannelItems.size())) {
                    *mappingParam = selectedHwChannel;
                    std::vector<int> newMapping(numChannels);
                    for (int j = 0; j < numChannels; ++j) {
                        auto* p = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(j)));
                        newMapping[j] = p->get();
                    }
                    synth->setAudioInputChannelMapping(synth->getNodeIdForLogical(lid), newMapping);
                    onModificationEnded();
                }
                ImGui::PopItemWidth();

                ImGui::SameLine();
                
                // --- VU Meter with Threshold Lines ---
                float level = (i < (int)audioIn->channelLevels.size() && audioIn->channelLevels[i]) ? audioIn->channelLevels[i]->load() : 0.0f;
                ImVec2 meterSize(nodeContentWidth * 0.38f, ImGui::GetTextLineHeightWithSpacing() * 0.8f);
                ImGui::ProgressBar(level, meterSize, "");

                // Draw threshold lines on top of the progress bar
                ImVec2 p_min = ImGui::GetItemRectMin();
                ImVec2 p_max = ImGui::GetItemRectMax();
                ImDrawList* draw_list = ImGui::GetWindowDrawList();

                // Gate Threshold (Yellow)
                float gateLineX = p_min.x + gateThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);

                // Trigger Threshold (Orange)
                float trigLineX = p_min.x + trigThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
                
                ImGui::PopID();
            }
        }
    }
    // --- SPECIAL RENDERING FOR OPENCV MODULES (WITH VIDEO FEED) ---
    else if (auto* webcamModule = dynamic_cast<WebcamLoaderModule*>(mp))
    {
        juce::Image frame = webcamModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        webcamModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* videoFileModule = dynamic_cast<VideoFileLoaderModule*>(mp))
    {
        juce::Image frame = videoFileModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        videoFileModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* movementModule = dynamic_cast<MovementDetectorModule*>(mp))
    {
        juce::Image frame = movementModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        movementModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* humanModule = dynamic_cast<HumanDetectorModule*>(mp))
    {
        juce::Image frame = humanModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        humanModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* poseModule = dynamic_cast<PoseEstimatorModule*>(mp))
    {
        juce::Image frame = poseModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        poseModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* colorModule = dynamic_cast<ColorTrackerModule*>(mp))
    {
        juce::Image frame = colorModule->getLatestFrame();
        if (!frame.isNull())
        {
            static std::map<int, int> hoverRadiusByNode; // logicalId -> radius (half-size), default 2 => 5x5
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));

                // Handle color picker clicks when active
                if (colorModule->isPickerActive() && ImGui::IsItemHovered())
                {
                    ImGui::SetTooltip("Click to pick a color from the video");
                    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
                    {
                        ImVec2 mousePos = ImGui::GetMousePos();
                        ImVec2 itemMin = ImGui::GetItemRectMin();
                        ImVec2 itemSize = ImGui::GetItemRectSize();
                        float nx = (mousePos.x - itemMin.x) / itemSize.x;
                        float ny = (mousePos.y - itemMin.y) / itemSize.y;
                        nx = juce::jlimit(0.0f, 1.0f, nx);
                        ny = juce::jlimit(0.0f, 1.0f, ny);
                        // Use ny directly (no flip) to align clicks with displayed image
                        int px = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                        int py = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());
                        juce::Logger::writeToLog(juce::String("[ColorTracker][UI] nx=") + juce::String(nx, 3) + ", ny=" + juce::String(ny, 3) +
                                                  ", px=" + juce::String(px) + ", py=" + juce::String(py));
                        colorModule->addColorAt(px, py);
                        colorModule->exitPickerMode();
                    }
                }

                // Hover preview: median/average color swatch and scroll-wheel radius control
                if (ImGui::IsItemHovered())
                {
                    // Update radius by mouse wheel
                    int& rad = hoverRadiusByNode[(int)lid]; if (rad <= 0) rad = 2;
                    float wheel = ImGui::GetIO().MouseWheel;
                    if (wheel != 0.0f)
                    {
                        rad += (wheel > 0) ? 1 : -1;
                        rad = juce::jlimit(1, 30, rad); // (2*rad+1)^2 window, max 61x61
                    }

                    // Map mouse to pixel
                    ImVec2 mousePos = ImGui::GetMousePos();
                    ImVec2 itemMin = ImGui::GetItemRectMin();
                    ImVec2 itemSize = ImGui::GetItemRectSize();
                    float nx = (mousePos.x - itemMin.x) / itemSize.x;
                    float ny = (mousePos.y - itemMin.y) / itemSize.y;
                    nx = juce::jlimit(0.0f, 1.0f, nx);
                    ny = juce::jlimit(0.0f, 1.0f, ny);
                    int cx = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                    int cy = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());

                    // Sample ROI from juce::Image
                    std::vector<int> vr, vg, vb; vr.reserve((2*rad+1)*(2*rad+1)); vg.reserve(vr.capacity()); vb.reserve(vr.capacity());
                    juce::Image::BitmapData bd(frame, juce::Image::BitmapData::readOnly);
                    auto clampi = [](int v, int lo, int hi){ return (v < lo) ? lo : (v > hi ? hi : v); };
                    for (int y = cy - rad; y <= cy + rad; ++y)
                    {
                        int yy = clampi(y, 0, frame.getHeight()-1);
                        const juce::PixelARGB* row = (const juce::PixelARGB*)(bd.getLinePointer(yy));
                        for (int x = cx - rad; x <= cx + rad; ++x)
                        {
                            int xx = clampi(x, 0, frame.getWidth()-1);
                            const juce::PixelARGB& p = row[xx];
                            vr.push_back(p.getRed());
                            vg.push_back(p.getGreen());
                            vb.push_back(p.getBlue());
                        }
                    }
                    auto median = [](std::vector<int>& v){ std::nth_element(v.begin(), v.begin()+v.size()/2, v.end()); return v[v.size()/2]; };
                    int mr = median(vr), mg = median(vg), mb = median(vb);
                    juce::Colour mc((juce::uint8)mr, (juce::uint8)mg, (juce::uint8)mb);
                    float h = mc.getHue(), s = mc.getSaturation(), b = mc.getBrightness();

                    // Tooltip near cursor with swatch and numbers
                    ImGui::BeginTooltip();
                    ImGui::Text("(%d,%d) rad=%d", cx, cy, rad);
                    ImGui::ColorButton("##hoverSwatch", ImVec4(mc.getFloatRed(), mc.getFloatGreen(), mc.getFloatBlue(), 1.0f), 0, ImVec2(22,22));
                    ImGui::SameLine();
                    ImGui::Text("RGB %d,%d,%d\nHSV %d,%d,%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f));
                    ImGui::EndTooltip();

                    // Textual summary under the image (lightweight)
                    ImGui::TextDisabled("Hover RGB %d,%d,%d  HSV %d,%d,%d  rad=%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f), rad);
                }
            }
        }
        colorModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* contourModule = dynamic_cast<ContourDetectorModule*>(mp))
    {
        juce::Image frame = contourModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        contourModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* segModule = dynamic_cast<SemanticSegmentationModule*>(mp))
    {
        juce::Image frame = segModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        segModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* objModule = dynamic_cast<ObjectDetectorModule*>(mp))
    {
        juce::Image frame = objModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        objModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* handModule = dynamic_cast<HandTrackerModule*>(mp))
    {
        juce::Image frame = handModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        handModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* faceModule = dynamic_cast<FaceTrackerModule*>(mp))
    {
        juce::Image frame = faceModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        faceModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* fxModule = dynamic_cast<VideoFXModule*>(mp))
    {
        juce::Image frame = fxModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                // Flip Y-coords for correct orientation
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        // Now draw the regular parameters below the video
        fxModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* cropVideoModule = dynamic_cast<CropVideoModule*>(mp))
    {
        // CropVideoModule handles its own preview rendering with interaction in drawParametersInNode
        cropVideoModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else
    {
        mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);
    }
#if JUCE_DEBUG
    parameterStackGuard.validate(moduleLabel + "::drawParametersInNode");
#endif
    ImGui::Spacing();
    ImGui::PopID();
}
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
            
            // Helper to draw right-aligned text within a node's content width
            // From imnodes examples (color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73):
            // Use ImGui::Indent() for right-alignment - this is the CORRECT ImNodes pattern!
            auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
            {
                const ImVec2 textSize = ImGui::CalcTextSize(txt);
                
                // Indent by (nodeWidth - textWidth) to right-align the text
                // CRITICAL: Must call Unindent() to prevent indent from persisting!
                const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
                ImGui::Indent(indentAmount);
                ImGui::TextUnformatted(txt);
                ImGui::Unindent(indentAmount);  // Reset indent!
            };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinId({lid, channel, true});
                seenAttrs.insert(attr);
                availableAttrs.insert(attr);

                // Get pin data type for color coding
                PinID pinId = { lid, channel, true, false, "" };
                PinDataType pinType = this->getPinDataTypeForPin(pinId);
                unsigned int pinColor = this->getImU32ForType(pinType);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                ImNodes::BeginInputAttribute(attr);
#if JUCE_DEBUG
                ++gImNodesInputDepth;
#endif
                ImGui::TextUnformatted(label);
                ImNodes::EndInputAttribute();
#if JUCE_DEBUG
                --gImNodesInputDepth;
                jassert(gImNodesInputDepth >= 0);
#endif

                // --- THIS IS THE DEFINITIVE FIX ---
                // Get the bounding box of the pin circle that was just drawn.
                ImVec2 pinMin = ImGui::GetItemRectMin();
                ImVec2 pinMax = ImGui::GetItemRectMax();
                // Calculate the exact center and cache it.
                float centerX = (pinMin.x + pinMax.x) * 0.5f;
                float centerY = (pinMin.y + pinMax.y) * 0.5f;
                attrPositions[attr] = ImVec2(centerX, centerY);
                // --- END OF FIX ---

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ThemeText("Connected", theme.text.active);
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                // CRASH FIX: Verify module exists before accessing it
                                if (c.srcLogicalId != 0 && synth != nullptr)
                                {
                                    bool moduleExists = false;
                                    for (const auto& modInfo : synth->getModulesInfo())
                                    {
                                        if (modInfo.first == c.srcLogicalId)
                                        {
                                            moduleExists = true;
                                            break;
                                        }
                                    }
                                    
                                    if (moduleExists)
                                    {
                                        if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                        {
                                            float value = srcMod->getOutputChannelValue(c.srcChan);
                                            ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                            ImGui::Text("Value: %.3f", value);
                                        }
                                    }
                                }
                                break; 
                            }
                        }
                    } else {
                        ThemeText("Not Connected", theme.text.disabled);
                    }
                    // Show pin data type
                    ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                    ImGui::EndTooltip();
                }
            };

                // NEW CLEAN OUTPUT PIN TEXT FUNCTION - FIXED SPACING
                helpers.drawAudioOutputPin = [&](const char* label, int channel)
                {
                    const int attr = encodePinId({(juce::uint32)lid, channel, false});
                    seenAttrs.insert(attr);
                    availableAttrs.insert(attr);

                    PinID pinId = {(juce::uint32)lid, channel, false, false, ""};
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(attr) > 0;

                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                    // EXACT OFFICIAL PATTERN: Text right-aligned, pin touches text edge
                    ImNodes::BeginOutputAttribute(attr);
#if JUCE_DEBUG
                    ++gImNodesOutputDepth;
#endif
                    const float label_width = ImGui::CalcTextSize(label).x;
                    ImGui::Indent(nodeContentWidth - label_width);  // Right-align to content width
                    ImGui::TextUnformatted(label);
                    ImGui::Unindent(nodeContentWidth - label_width);
                    ImNodes::EndOutputAttribute();
#if JUCE_DEBUG
                    --gImNodesOutputDepth;
                    jassert(gImNodesOutputDepth >= 0);
#endif

                    // Cache pin center
                    {
                        ImVec2 pinMin = ImGui::GetItemRectMin();
                        ImVec2 pinMax = ImGui::GetItemRectMax();
                        float centerY = (pinMin.y + pinMax.y) * 0.5f;
                        float x_pos   = pinMax.x;
                        attrPositions[attr] = ImVec2(x_pos, centerY);
                    }

                    ImNodes::PopColorStyle();

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                    if (isConnected) {
                        ThemeText("Connected", theme.text.active);
                    } else {
                        ThemeText("Not Connected", theme.text.disabled);
                        }
                        ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                        if (auto* mp = synth->getModuleForLogical(lid))
                        {
                            float value = mp->getOutputChannelValue(channel);
                            ImGui::Text("Value: %.3f", value);
                        }
                        ImGui::EndTooltip();
                    }
                };

            // ADD THE NEW drawParallelPins HELPER
            helpers.drawParallelPins = [&](const char* inLabel, int inChannel, const char* outLabel, int outChannel)
            {
                // 3-column layout: [InputPin] [Right-aligned Output Label] [Output Pin]
                ImGui::PushID((inChannel << 16) ^ outChannel ^ lid);
                ImGui::Columns(3, "parallel_io_layout", false);

                const float pinW = 18.0f;
                const float spacing = ImGui::GetStyle().ItemSpacing.x;
                // CRITICAL FIX: Use stable nodeContentWidth to set ALL column widths explicitly
                // This prevents the feedback loop that causes position-dependent node scaling
                
                // Calculate column widths to fill exactly nodeContentWidth
                float inTextW = inLabel ? ImGui::CalcTextSize(inLabel).x : 0.0f;
                float inColW = inLabel ? (inTextW + pinW + spacing) : 0.0f;  // Input label + pin + spacing
                float outPinColW = 20.0f;  // Output pin column (fixed narrow width)
                float labelColW = nodeContentWidth - inColW - outPinColW - spacing;  // Middle fills remaining space

                ImGui::SetColumnWidth(0, inColW);
                ImGui::SetColumnWidth(1, labelColW);
                ImGui::SetColumnWidth(2, outPinColW);

                // Column 0: Input pin with label
                if (inLabel != nullptr)
                {
                    int inAttr = encodePinId({lid, inChannel, true});
                    seenAttrs.insert(inAttr);
                    availableAttrs.insert(inAttr);
                    PinID pinId = { lid, inChannel, true, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedInputAttrs.count(inAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginInputAttribute(inAttr);
#if JUCE_DEBUG
                    ++gImNodesInputDepth;
#endif
                    ImGui::TextUnformatted(inLabel);
                    ImNodes::EndInputAttribute();
#if JUCE_DEBUG
                    --gImNodesInputDepth;
                    jassert(gImNodesInputDepth >= 0);
#endif
                    ImNodes::PopColorStyle();
                }

                // Column 1: Output label (right-aligned within this column)
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    // EXACT OFFICIAL PATTERN: Same as regular output pins
                    const float textW = ImGui::CalcTextSize(outLabel).x;
                    ImGui::Indent(labelColW - textW);  // Right-align to column width
                    ImGui::TextUnformatted(outLabel);
                    ImGui::Unindent(labelColW - textW);
                }

                // Column 2: Output pin
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    int outAttr = encodePinId({lid, outChannel, false});
                    seenAttrs.insert(outAttr);
                    availableAttrs.insert(outAttr);
                    PinID pinId = { lid, outChannel, false, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(outAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
#if JUCE_DEBUG
                    ++gImNodesOutputDepth;
#endif
                    ImNodes::BeginOutputAttribute(outAttr);
                    ImGui::Dummy(ImVec2(1.0f, ImGui::GetTextLineHeight()));
                    ImNodes::EndOutputAttribute();
#if JUCE_DEBUG
                    --gImNodesOutputDepth;
                    jassert(gImNodesOutputDepth >= 0);
#endif

                    // Cache pin center
                    ImVec2 pinMin = ImGui::GetItemRectMin();
                    ImVec2 pinMax = ImGui::GetItemRectMax();
                    float yCenter = pinMin.y + (pinMax.y - pinMin.y) * 0.5f;
                    float xPos = pinMax.x;
                    attrPositions[outAttr] = ImVec2(xPos, yCenter);
                    ImNodes::PopColorStyle();
                }

                // Restore to single column for the next row
                ImGui::Columns(1);
                ImGui::PopID();
            };

            // --- DYNAMIC PIN FIX ---
            // Add a new helper that uses dynamic pin information from modules
            helpers.drawIoPins = [&](ModuleProcessor* module) {
                if (!module) return;
                const auto logicalId = module->getLogicalId();
                const auto moduleType = synth->getModuleTypeForLogical(logicalId);

                // 1. Get dynamic pins from the module itself.
                auto dynamicInputs = module->getDynamicInputPins();
                auto dynamicOutputs = module->getDynamicOutputPins();

                // 2. Get static pins from the database as a fallback.
                const auto& pinDb = getModulePinDatabase();
                auto pinInfoIt = pinDb.find(moduleType.toLowerCase());
                const bool hasStaticPinInfo = (pinInfoIt != pinDb.end());
                const auto& staticPinInfo = hasStaticPinInfo ? pinInfoIt->second : ModulePinInfo{};

                // 3. If the module has dynamic pins, use the new system
                const bool hasDynamicPins = !dynamicInputs.empty() || !dynamicOutputs.empty();
                
                if (hasDynamicPins)
                {
                    // Draw inputs (dynamic if available, otherwise static)
                    if (!dynamicInputs.empty())
                    {
                        for (const auto& pin : dynamicInputs)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioIns)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    
                    // Draw outputs (dynamic if available, otherwise static)
                    if (!dynamicOutputs.empty())
                    {
                        for (const auto& pin : dynamicOutputs)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioOuts)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                }
                else
                {
                    // 4. Otherwise, fall back to the module's custom drawIoPins implementation
                    module->drawIoPins(helpers);
                }
            };
            // --- END OF DYNAMIC PIN FIX ---

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                {
#if JUCE_DEBUG
                    ImGuiStackBalanceChecker ioStackGuard;
                    ImNodesDepthSnapshot ioDepthSnapshot(moduleLabel + "::drawIoPins");
#endif
                    helpers.drawIoPins(mp);
#if JUCE_DEBUG
                    ioStackGuard.validate(type + " [lid=" + juce::String((int)lid) + "]::drawIoPins");
#endif
                }

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
#if JUCE_DEBUG
            --gImNodesNodeDepth;
            jassert(gImNodesNodeDepth >= 0);
#endif
            
            // Cache position for snapshot safety
            // Graph is always in consistent state since we rebuild at frame start
            lastKnownNodePositions[(int)lid] = ImNodes::GetNodeGridSpacePos((int)lid);
            
            // Pop muted node styles (in reverse order of push)
            if (isMuted) {
                ImNodes::PopColorStyle();      // Mute TitleBar
                ImGui::PopStyleVar();          // Alpha
                ImNodes::PopStyleVar();        // NodePadding
            }
            
            // Pop hover highlight color
            if (isHoveredSource || isHoveredDest)
                ImNodes::PopColorStyle();      // Hover TitleBar
            
            // Pop category colors (in reverse order of push)
            ImNodes::PopColorStyle();          // TitleBarSelected
            ImNodes::PopColorStyle();          // TitleBarHovered
            ImNodes::PopColorStyle();          // TitleBar
            
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
        if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
        {
            // Apply saved position once; do not write (0,0) defaults
            const ImVec2 p = it->second;
            if (!(p.x == 0.0f && p.y == 0.0f))
            {
                ImNodes::SetNodeGridSpacePos((int) lid, p);
                juce::Logger::writeToLog("[PositionRestore] Applied pending position for node " + juce::String((int)lid) + ": (" + juce::String(p.x) + ", " + juce::String(p.y) + ")");
            }
            pendingNodePositions.erase(it);
        }
            // Apply pending size if queued (for Comment nodes to prevent feedback loop)
            if (auto itSize = pendingNodeSizes.find((int) lid); itSize != pendingNodeSizes.end())
            {
                // Store the desired size in the Comment module itself
                if (auto* comment = dynamic_cast<CommentModuleProcessor*>(synth->getModuleForLogical((juce::uint32)lid)))
                {
                    comment->nodeWidth = itSize->second.x;
                    comment->nodeHeight = itSize->second.y;
                }
                pendingNodeSizes.erase(itSize);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        bool triggerInsertMixer = false;
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            const juce::String selectedType = selectedLogicalId != 0 ? getTypeForLogical((juce::uint32)selectedLogicalId) : juce::String();
            const bool selectedIsMeta = selectedType.equalsIgnoreCase("meta_module") || selectedType.equalsIgnoreCase("meta");

            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0 && selectedLogicalId != 999)
            {
                mutedNodeStates.erase((juce::uint32)selectedLogicalId); // Clean up muted state if exists
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                pushSnapshot();
                NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(1) + " node(s)");
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    pushSnapshot();
                }
            }
            if (ImGui::MenuItem("Expand Meta Module", nullptr, false, selectedIsMeta))
            {
                expandMetaModule((juce::uint32)selectedLogicalId);
            }
            if (ImGui::MenuItem("Insert Mixer", "Ctrl+T") && selectedLogicalId != 0) { triggerInsertMixer = true; }
            ImGui::EndPopup();
        }

        // Shortcut: Ctrl+T to insert a Mixer after selected node and reroute
        // Debounced Ctrl+T
        const bool ctrlDown = ImGui::GetIO().KeyCtrl;
        if (!ctrlDown)
        {
            mixerShortcutCooldown = false;
            insertNodeShortcutCooldown = false;
        }

        const bool insertMixerShortcut = consumeShortcutFlag(shortcutInsertMixerRequested);
        if ((triggerInsertMixer || (selectedLogicalId != 0 && insertMixerShortcut)) && !mixerShortcutCooldown)
        {
            mixerShortcutCooldown = true; // Prevent re-triggering in the same frame
            const juce::uint32 srcLid = (juce::uint32) selectedLogicalId;

            juce::Logger::writeToLog("--- [InsertMixer] Start ---");
            juce::Logger::writeToLog("[InsertMixer] Selected Node Logical ID: " + juce::String(srcLid));

            auto srcNodeId = synth->getNodeIdForLogical(srcLid);
            if (srcNodeId.uid == 0) 
            {
                juce::Logger::writeToLog("[InsertMixer] ABORT: Source node with logical ID " + juce::String(srcLid) + " is invalid or could not be found.");
            } 
            else 
            {
                // 1. Collect all outgoing connections from the selected node
                std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
                for (const auto& c : synth->getConnectionsInfo()) {
                    if (c.srcLogicalId == srcLid) {
                        outgoingConnections.push_back(c);
                    }
                }
                juce::Logger::writeToLog("[InsertMixer] Found " + juce::String(outgoingConnections.size()) + " outgoing connections to reroute.");
                for (const auto& c : outgoingConnections) {
                    juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                    juce::Logger::writeToLog("  - Stored connection: [Src: " + juce::String(c.srcLogicalId) + ":" + juce::String(c.srcChan) + "] -> [Dst: " + destStr + ":" + juce::String(c.dstChan) + "]");
                }

                // 2. Create and position the new mixer node intelligently
                auto mixNodeIdGraph = synth->addModule("mixer");
                const juce::uint32 mixLid = synth->getLogicalIdForNode(mixNodeIdGraph);
                
                ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(selectedLogicalId);
                ImVec2 avgDestPos = srcPos; // Default to source pos if no outputs
                
                if (!outgoingConnections.empty())
                {
                    float totalX = 0.0f, totalY = 0.0f;
                    for (const auto& c : outgoingConnections)
                    {
                        int destId = c.dstIsOutput ? 0 : (int)c.dstLogicalId;
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(destId);
                        totalX += pos.x;
                        totalY += pos.y;
                    }
                    avgDestPos = ImVec2(totalX / outgoingConnections.size(), totalY / outgoingConnections.size());
                }
                else
                {
                    // If there are no outgoing connections, place it to the right
                    avgDestPos.x += 600.0f;
                }
                
                // Place the new mixer halfway between the source and the average destination
                pendingNodePositions[(int)mixLid] = ImVec2((srcPos.x + avgDestPos.x) * 0.5f, (srcPos.y + avgDestPos.y) * 0.5f);
                juce::Logger::writeToLog("[InsertMixer] Added new Mixer. Logical ID: " + juce::String(mixLid) + ", Node ID: " + juce::String(mixNodeIdGraph.uid));

                // 3. Disconnect all original outgoing links
                juce::Logger::writeToLog("[InsertMixer] Disconnecting original links...");
                for (const auto& c : outgoingConnections) {
                    auto currentSrcNodeId = synth->getNodeIdForLogical(c.srcLogicalId);
                    auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);

                    if (currentSrcNodeId.uid != 0 && dstNodeId.uid != 0) {
                        bool success = synth->disconnect(currentSrcNodeId, c.srcChan, dstNodeId, c.dstChan);
                        juce::Logger::writeToLog("  - Disconnecting [" + juce::String(currentSrcNodeId.uid) + ":" + juce::String(c.srcChan) + "] -> [" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                    } else {
                        juce::Logger::writeToLog("  - SKIPPING Disconnect due to invalid node ID.");
                    }
                }

                // 4. Connect the source node to the new mixer's first input
                juce::Logger::writeToLog("[InsertMixer] Connecting source node to new mixer...");
                bool c1 = synth->connect(srcNodeId, 0, mixNodeIdGraph, 0); // L to In A L
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":0] -> [" + juce::String(mixNodeIdGraph.uid) + ":0]... " + (c1 ? "SUCCESS" : "FAILED"));
                bool c2 = synth->connect(srcNodeId, 1, mixNodeIdGraph, 1); // R to In A R
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":1] -> [" + juce::String(mixNodeIdGraph.uid) + ":1]... " + (c2 ? "SUCCESS" : "FAILED"));


                // 5. Connect the mixer's output to all the original destinations (maintaining the chain)
                juce::Logger::writeToLog("[InsertMixer] Connecting mixer to original destinations to maintain chain...");
                if (outgoingConnections.empty()) {
                    juce::Logger::writeToLog("  - No original outgoing connections. Connecting mixer to Main Output by default.");
                    auto outNode = synth->getOutputNodeID();
                    if (outNode.uid != 0) {
                        bool o1 = synth->connect(mixNodeIdGraph, 0, outNode, 0);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":0] -> [Output:0]... " + (o1 ? "SUCCESS" : "FAILED"));
                        bool o2 = synth->connect(mixNodeIdGraph, 1, outNode, 1);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":1] -> [Output:1]... " + (o2 ? "SUCCESS" : "FAILED"));
                    }
                } else {
                    for (const auto& c : outgoingConnections) {
                        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                        if (dstNodeId.uid != 0) {
                            // Connect mixer output to the same destination the original node was connected to
                            // This maintains the chain: original -> mixer -> destination
                            bool success = synth->connect(mixNodeIdGraph, c.srcChan, dstNodeId, c.dstChan);
                            juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                            juce::Logger::writeToLog("  - Maintaining chain: Mixer [" + juce::String(mixNodeIdGraph.uid) + ":" + juce::String(c.srcChan) + "] -> " + destStr + "[" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                        } else {
                            juce::Logger::writeToLog("  - SKIPPING Reconnect due to invalid destination node ID for original logical ID " + juce::String(c.dstLogicalId));
                        }
                    }
                }

                graphNeedsRebuild = true;
                pushSnapshot(); // Make the entire operation undoable
                juce::Logger::writeToLog("[InsertMixer] Rerouting complete. Flagging for graph rebuild.");
            }
            juce::Logger::writeToLog("--- [InsertMixer] End ---");
        }

        // Shortcut: Ctrl+I to show Insert Node popup menu
        const bool showInsertPopupShortcut = consumeShortcutFlag(shortcutShowInsertPopupRequested);
        if (selectedLogicalId != 0 && showInsertPopupShortcut && !insertNodeShortcutCooldown)
        {
            insertNodeShortcutCooldown = true;
            showInsertNodePopup = true;
        }

        // Insert Node popup menu
        if (showInsertNodePopup)
        {
            ImGui::OpenPopup("InsertNodePopup");
            showInsertNodePopup = false;
        }

        if (ImGui::BeginPopup("InsertNodePopup"))
        {
            ImGui::Text("Insert Node Between Connections");
            
            // Audio Path
            if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); ImGui::CloseCurrentPopup(); }
            
            ImGui::Separator();
            
            // Modulation Path
            if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); ImGui::CloseCurrentPopup(); }
            
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        const bool isOutputHovered = (hoveredLinkDstId == kOutputHighlightId);
        ImU32 outputTitleBarColor = IM_COL32(80, 80, 80, 255);  // Default output node color (dark grey)
        if (isOutputHovered)
        {
            outputTitleBarColor = IM_COL32(255, 220, 0, 255);  // Yellow when hovered
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, outputTitleBarColor);
        }
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        
        // Calculate optimal text color based on title bar background color
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(outputTitleBarColor);
        ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(optimalTextColor));
        ImGui::TextUnformatted ("Output");
        ImGui::PopStyleColor();
        
        ImNodes::EndNodeTitleBar();
        if (isOutputHovered)
            ImNodes::PopColorStyle();
        
        // In L pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 0, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 0, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
#if JUCE_DEBUG
            ++gImNodesInputDepth;
#endif
            ImGui::Text ("In L");
            ImNodes::EndInputAttribute();
#if JUCE_DEBUG
            --gImNodesInputDepth;
            jassert(gImNodesInputDepth >= 0);
#endif
            ImNodes::PopColorStyle();
        }
        
        // In R pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 1, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 1, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
#if JUCE_DEBUG
            ++gImNodesInputDepth;
#endif
            ImGui::Text ("In R");
            ImNodes::EndInputAttribute();
#if JUCE_DEBUG
            --gImNodesInputDepth;
            jassert(gImNodesInputDepth >= 0);
#endif
            ImNodes::PopColorStyle();
        }
        
        ImNodes::EndNode();
        
        // Cache output node position for snapshot safety
        // Graph is always in consistent state since we rebuild at frame start
        lastKnownNodePositions[0] = ImNodes::GetNodeGridSpacePos(0);
        
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            juce::Logger::writeToLog("[PositionRestore] Applied pending position for output node 0: (" + juce::String(it->second.x) + ", " + juce::String(it->second.y) + ")");
            pendingNodePositions.erase(it);
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections (IDs stable via bitmasking)
        int cableIdx = 0;
        for (const auto& c : synth->getConnectionsInfo())
        {
            
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) {
                continue;
            }
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) {
                continue;
            }
            
            const int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            const int dstAttr = c.dstIsOutput ? encodePinId({0, c.dstChan, true}) : encodePinId({c.dstLogicalId, c.dstChan, true});
            
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
            {
                static std::unordered_set<std::string> skipOnce;
                const std::string key = std::to_string((int)c.srcLogicalId) + ":" + std::to_string(c.srcChan) + "->" +
                                         (c.dstIsOutput? std::string("0") : std::to_string((int)c.dstLogicalId)) + ":" + std::to_string(c.dstChan);
                if (skipOnce.insert(key).second)
                {
                    juce::Logger::writeToLog(
                        juce::String("[ImNodes][SKIP] missing attr: srcPresent=") + (availableAttrs.count(srcAttr)?"1":"0") +
                        " dstPresent=" + (availableAttrs.count(dstAttr)?"1":"0") +
                        " srcKey=(lid=" + juce::String((int)c.srcLogicalId) + ",ch=" + juce::String(c.srcChan) + ")" +
                        " dstKey=(lid=" + juce::String(c.dstIsOutput?0:(int)c.dstLogicalId) + ",ch=" + juce::String(c.dstChan) + ",in=1) id(s)=" +
                        juce::String(srcAttr) + "," + juce::String(dstAttr));
                }
                continue;
            }
            
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            
            // --- THIS IS THE DEFINITIVE FIX ---
            // 1. Determine the base color and check for signal activity.
            auto srcPin = decodePinId(srcAttr);
            PinDataType linkDataType = getPinDataTypeForPin(srcPin);
            ImU32 linkColor = getImU32ForType(linkDataType);
            float magnitude = 0.0f;
            bool hasThicknessModification = false;

            // CRASH FIX: Verify module still exists before accessing it.
            // During preset loading, modules may be destroyed while we're iterating connections.
            if (synth != nullptr && srcPin.logicalId != 0)
            {
                // First verify the module exists in the current module list
                bool moduleExists = false;
                for (const auto& modInfo : synth->getModulesInfo())
                {
                    if (modInfo.first == srcPin.logicalId)
                    {
                        moduleExists = true;
                        break;
                    }
                }
                
                // Only access if module still exists
                if (moduleExists)
                {
                    if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                    {
                        magnitude = srcModule->getOutputChannelValue(srcPin.channel);
                    }
                }
            }

            // 2. If the signal is active, calculate a glowing/blinking color.
            if (magnitude > 0.01f)
            {
                const float blinkSpeed = 8.0f;
                float blinkFactor = (std::sin((float)ImGui::GetTime() * blinkSpeed) + 1.0f) * 0.5f;
                float glowIntensity = juce::jlimit(0.0f, 1.0f, blinkFactor * magnitude * 2.0f);

                // Brighten the base color and modulate alpha for glow effect
                ImVec4 colorVec = ImGui::ColorConvertU32ToFloat4(linkColor);
                colorVec.x = juce::jmin(1.0f, colorVec.x + glowIntensity * 0.4f);
                colorVec.y = juce::jmin(1.0f, colorVec.y + glowIntensity * 0.4f);
                colorVec.z = juce::jmin(1.0f, colorVec.z + glowIntensity * 0.4f);
                colorVec.w = juce::jlimit(0.5f, 1.0f, 0.5f + glowIntensity * 0.5f);
                linkColor = ImGui::ColorConvertFloat4ToU32(colorVec);

                // Make active cables slightly thicker (keep constant in screen space under zoom)
                {
                    float currentZoom = 1.0f;
#if defined(IMNODES_ZOOM_ENABLED)
                    if (ImNodes::GetCurrentContext())
                        currentZoom = ImNodes::EditorContextGetZoom();
#endif
                    ImNodes::PushStyleVar(ImNodesStyleVar_LinkThickness, 3.0f / currentZoom);
                }
                hasThicknessModification = true;
            }

            // 3. Push the chosen color (either normal or glowing) to the style stack.
            const auto& theme = ThemeManager::getInstance().getCurrentTheme();
            ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);
            ImNodes::PushColorStyle(ImNodesCol_LinkHovered, theme.links.link_hovered);
            ImNodes::PushColorStyle(ImNodesCol_LinkSelected, theme.links.link_selected);

            // 4. Check for node hover highlight (this should override the glow).
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle(ImNodesCol_Link, theme.links.link_highlighted);
            }
            
            // 5. Tell imnodes to draw the link. It will use the color we just pushed.
            ImNodes::Link(linkId, srcAttr, dstAttr);
            
            // 6. Pop ALL style modifications to restore the defaults for the next link.
            if (hl) ImNodes::PopColorStyle();
            ImNodes::PopColorStyle(); // LinkSelected
            ImNodes::PopColorStyle(); // LinkHovered
            ImNodes::PopColorStyle(); // Link
            if (hasThicknessModification) ImNodes::PopStyleVar(); // LinkThickness
            
            // --- END OF FIX ---
        }

        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    // --- Handle Auto-Connect Requests from MIDI Players ---
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
        {
            // Check for initial button presses
            if (midiPlayer->autoConnectTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Samplers;
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO;
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Hybrid;
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            // --- THIS IS THE NEW LOGIC ---
            // Check if an update was requested after a new file was loaded
            else if (midiPlayer->connectionUpdateRequested.exchange(false))
            {
                // Re-run the correct handler based on the saved state
                switch (midiPlayer->lastAutoConnectState.load())
                {
                    case MIDIPlayerModuleProcessor::AutoConnectState::Samplers:
                        handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO:
                        handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::Hybrid:
                        handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::None:
                    default:
                        // Do nothing if it wasn't auto-connected before
                        break;
                }
            }
            // --- END OF NEW LOGIC ---
        }
    }
    // --- Handle Auto-Connect Requests using new intelligent system ---
    handleAutoConnectionRequests();

    // Capture hover state for drag/drop logic before we leave the node editor scope
    int hoverPinIdForDrop = -1;
    int hoverNodeIdForDrop = -1;
    int hoverLinkIdForDrop = -1;
    bool pinHoveredDuringEditor = false;
    bool nodeHoveredDuringEditor = false;
    bool linkHoveredDuringEditor = false;

    // ======================================================
    // === ðŸ’¡ MODAL MINIMAP (v13 - Scale-on-Press) ==========
    // ======================================================
    if (isMinimapEnlarged.load())
    {
        ImNodes::MiniMap(modalMinimapScale, ImNodesMiniMapLocation_BottomRight);
    }
    else
    {
        ImNodes::MiniMap(0.2f, ImNodesMiniMapLocation_BottomRight);
    }
    // ======================================================
    // === ðŸ’¡ END MODAL MINIMAP =============================
    // ======================================================

    ImNodes::EndNodeEditor();
#if JUCE_DEBUG
    if (gImNodesNodeDepth != 0 || gImNodesInputDepth != 0 || gImNodesOutputDepth != 0)
    {
        juce::Logger::writeToLog(
            "[ImNodes][DepthLeak][Frame] nodeDepth=" + juce::String(gImNodesNodeDepth) +
            " inputDepth=" + juce::String(gImNodesInputDepth) +
            " outputDepth=" + juce::String(gImNodesOutputDepth) +
            " lastNode=" + gLastRenderedNodeLabel);
        jassertfalse;
        gImNodesNodeDepth = 0;
        gImNodesInputDepth = 0;
        gImNodesOutputDepth = 0;
    }
#endif
    pinHoveredDuringEditor = ImNodes::IsPinHovered(&hoverPinIdForDrop);
    nodeHoveredDuringEditor = ImNodes::IsNodeHovered(&hoverNodeIdForDrop);
    linkHoveredDuringEditor = ImNodes::IsLinkHovered(&hoverLinkIdForDrop);
    juce::ignoreUnused(hoverPinIdForDrop, hoverNodeIdForDrop, hoverLinkIdForDrop);
    int linkStartAttr = -1;
    if (ImNodes::IsLinkStarted(&linkStartAttr))
    {
        dragInsertActive = true;
        dragInsertStartAttrId = linkStartAttr;
        dragInsertStartPin = decodePinId(linkStartAttr);
        shouldOpenDragInsertPopup = false;
        juce::Logger::writeToLog("[DragInsert] Started drag from attr " + juce::String(linkStartAttr));
    }
    if (dragInsertActive)
    {
        const bool cancelRequested = ImGui::IsKeyPressed(ImGuiKey_Escape, false) ||
                                     ImGui::IsMouseReleased(ImGuiMouseButton_Right);
        if (cancelRequested)
        {
            juce::Logger::writeToLog("[DragInsert] Drag cancelled.");
            cancelDragInsert();
        }
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            const bool editorHovered = ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows |
                                                              ImGuiHoveredFlags_AllowWhenBlockedByPopup);
            if (!pinHoveredDuringEditor && !nodeHoveredDuringEditor && !linkHoveredDuringEditor && editorHovered)
            {
                dragInsertDropPos = ImGui::GetMousePos();
                shouldOpenDragInsertPopup = true;
                juce::Logger::writeToLog("[DragInsert] Drop captured on canvas (logicalId="
                                         + juce::String((int)dragInsertStartPin.logicalId)
                                         + ", channel=" + juce::String(dragInsertStartPin.channel) + ").");
            }
            else
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                shouldOpenDragInsertPopup = false;
            }
            dragInsertActive = false;
        }
    }
    else if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
    {
        shouldOpenDragInsertPopup = false;
    }
    // === POP THE TRANSPARENT GRID BACKGROUND STYLE ===
    ImNodes::PopColorStyle(); // Pop BoxSelectorOutline
    ImNodes::PopColorStyle(); // Pop BoxSelector
    ImNodes::PopColorStyle(); // Pop GridLinePrimary
    ImNodes::PopColorStyle(); // Pop GridLine
    ImNodes::PopColorStyle(); // Pop GridBackground
    ImNodes::PopColorStyle(); // Pop NodeOutline
    ImNodes::PopColorStyle(); // Pop NodeBackgroundSelected
    ImNodes::PopColorStyle(); // Pop NodeBackgroundHovered
    ImNodes::PopColorStyle(); // Pop NodeBackground
    // === END OF FIX ===
    hasRenderedAtLeastOnce = true;
    
    if (shouldOpenDragInsertPopup)
    {
        shouldOpenDragInsertPopup = false;
        ImGui::SetNextWindowPos(dragInsertDropPos, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
        ImGui::OpenPopup("DragInsertPopup");
    }
    if (ImGui::BeginPopup("DragInsertPopup"))
    {
        const PinDataType displayType = dragInsertStartPin.isMod
            ? PinDataType::CV
            : getPinDataTypeForPin(dragInsertStartPin);
        const auto& suggestions = getDragInsertSuggestionsFor(dragInsertStartPin);

        if (suggestions.empty())
        {
            ImGui::TextDisabled("No compatible modules found.");
            if (ImGui::MenuItem("Close"))
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                ImGui::CloseCurrentPopup();
            }
        }
        else
        {
            ImGui::Text("Insert node for %s", pinDataTypeToString(displayType));
            ImGui::Separator();

            for (const auto& moduleType : suggestions)
            {
                if (ImGui::MenuItem(moduleType.toRawUTF8()))
                {
                    insertNodeFromDragSelection(moduleType);
                    ImGui::CloseCurrentPopup();
                    break;
                }
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Cancel"))
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                ImGui::CloseCurrentPopup();
            }
        }

        ImGui::EndPopup();
    }

    // ======================================================
    // === ðŸ’¡ MODAL MINIMAP LOGIC (v13 - Scale-on-Press) ====
    // ======================================================
    ImGuiIO& io = ImGui::GetIO();
    bool isEditorHovered = ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows |
                                                 ImGuiHoveredFlags_AllowWhenBlockedByPopup);

    if (consumeShortcutFlag(shortcutToggleMinimapRequested) && !isMinimapEnlarged.load() && isEditorHovered)
    {
        isMinimapEnlarged.store(true);

        ImVec2 minimapCorner = ImVec2(lastCanvasP0.x + lastCanvasSize.x,
                                      lastCanvasP0.y + lastCanvasSize.y);
        ImVec2 mousePos = io.MousePos;
        float dist_x = minimapCorner.x - mousePos.x;
        float dist_y = minimapCorner.y - mousePos.y;
        float distance = std::sqrt(dist_x * dist_x + dist_y * dist_y);
        float max_dist = std::sqrt(lastCanvasSize.x * lastCanvasSize.x +
                                   lastCanvasSize.y * lastCanvasSize.y);

        float norm_dist = 0.0f;
        if (max_dist > 0.0f)
            norm_dist = juce::jlimit(0.0f, 1.0f, distance / max_dist);

        modalMinimapScale = 0.2f + (norm_dist * 0.6f);
    }

    if (ImGui::IsKeyReleased(ImGuiKey_Comma))
    {
        isMinimapEnlarged.store(false);
        modalMinimapScale = 0.2f;
    }

    if (isMinimapEnlarged.load() && !ImGui::IsWindowFocused(ImGuiHoveredFlags_RootAndChildWindows))
    {
        isMinimapEnlarged.store(false);
        modalMinimapScale = 0.2f;
    }
    // ======================================================
    // === ðŸ’¡ END MODAL MINIMAP LOGIC =======================
    // ======================================================
    
    // ================== MIDI PLAYER QUICK CONNECT LOGIC ==================
    // Poll all MIDI Player modules for connection requests
    if (synth != nullptr)
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                int requestType = midiPlayer->getAndClearConnectionRequest();
                if (requestType > 0)
                {
                    handleMIDIPlayerConnectionRequest(modInfo.first, midiPlayer, requestType);
                    break; // Only handle one request per frame
                }
            }
        }
    }
    // ================== END MIDI PLAYER QUICK CONNECT ==================
    // ================== META MODULE EDITING LOGIC ==================
    // Check if any Meta Module has requested to be edited
    if (synth != nullptr && metaModuleToEditLid == 0) // Only check if not already editing one
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                // Atomically check and reset the flag
                if (metaModule->editRequested.exchange(false))
                {
                    metaModuleToEditLid = modInfo.first;
                    juce::Logger::writeToLog("[MetaEdit] Opening editor for Meta Module L-ID " + juce::String((int)metaModuleToEditLid));
                    ImGui::OpenPopup("Edit Meta Module");
                    break; // Only handle one request per frame
                }
            }
        }
    }
    
    // Draw the modal popup for the internal editor if one is selected
    if (metaModuleToEditLid != 0)
    {
        ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
        if (ImGui::BeginPopupModal("Edit Meta Module", nullptr, ImGuiWindowFlags_MenuBar))
        {
            ImGui::PushID((int)metaModuleToEditLid);
            auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaModuleToEditLid));
            if (metaModule && metaModule->getInternalGraph())
            {
                if (!metaEditorSession || metaEditorSession->metaLogicalId != metaModuleToEditLid)
                    openMetaModuleEditor(metaModule, metaModuleToEditLid);

                if (metaEditorSession)
                    renderMetaModuleEditor(*metaEditorSession);

                ImGui::Separator();
                if (ImGui::Button("Apply Changes"))
                {
                    if (metaEditorSession && metaEditorSession->dirty)
                    {
                        metaModule->refreshCachedLayout();
                        graphNeedsRebuild = true;
                        snapshotAfterEditor = true;
                    }
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("Close"))
                {
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
            }
            else
            {
                ImGui::Text("Meta module %d has no internal graph to edit.", (int)metaModuleToEditLid);
                if (ImGui::Button("Close"))
                {
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
            }
            ImGui::PopID();
            ImGui::EndPopup();
        }
        else
        {
            closeMetaModuleEditor();
            metaModuleToEditLid = 0;
        }
    }
    // ======================= END OF META MODULE LOGIC =======================

    // --- CONSOLIDATED HOVERED LINK DETECTION ---
    // Declare these variables ONCE, immediately after the editor has ended.
    // All subsequent features that need to know about hovered links can now
    // safely reuse these results without causing redefinition or scope errors.
    // Graph is always in consistent state since we rebuild at frame start
    int hoveredLinkId = -1;
    bool isLinkHovered = ImNodes::IsLinkHovered(&hoveredLinkId);
    // --- END OF CONSOLIDATED DECLARATION ---
    
    // Smart cable visualization is now integrated directly into the link drawing loop above.
    // No separate overlay needed - cables glow by modifying their own color.
    
    // === PROBE TOOL MODE HANDLING ===
    if (isProbeModeActive)
    {
        // Change cursor to indicate probe mode is active
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        
        // Draw "PROBE ACTIVE" indicator at mouse position
        auto* drawList = ImGui::GetForegroundDrawList();
        ImVec2 mousePos = ImGui::GetMousePos();
        const char* text = "PROBE MODE: Click output pin";
        auto textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImVec2(mousePos.x + 20, mousePos.y - 20);
        const auto& theme = ThemeManager::getInstance().getCurrentTheme();
        drawList->AddRectFilled(
            ImVec2(textPos.x - 5, textPos.y - 2),
            ImVec2(textPos.x + textSize.x + 5, textPos.y + textSize.y + 2),
            theme.links.label_background
        );
        drawList->AddText(textPos, theme.links.label_text, text);
        
        // Check for pin clicks
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                auto pinId = decodePinId(hoveredPinId);
                // Check if it's an output pin (not input, not mod)
                if (!pinId.isInput && !pinId.isMod && pinId.logicalId != 0)
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on valid output pin. LogicalID: " + juce::String(pinId.logicalId) + ", Channel: " + juce::String(pinId.channel));
                    auto nodeId = synth->getNodeIdForLogical(pinId.logicalId);
                    synth->setProbeConnection(nodeId, pinId.channel);
                    isProbeModeActive = false; // Deactivate after probing
                }
                else
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on an invalid pin (input or output node). Cancelling.");
                    isProbeModeActive = false;
                }
            }
            else
            {
                // Clicked on empty space, cancel probe mode
                juce::Logger::writeToLog("[PROBE_UI] Probe clicked on empty space. Cancelling.");
                isProbeModeActive = false;
            }
        }
        
        // Allow ESC to cancel probe mode
        if (ImGui::IsKeyPressed(ImGuiKey_Escape))
        {
            isProbeModeActive = false;
            juce::Logger::writeToLog("[PROBE_UI] Cancelled with ESC");
        }
    }
    // --- CONTEXTUAL RIGHT-CLICK HANDLER ---
    // A cable was right-clicked. Store its info and open the insert popup.
    if (isLinkHovered && hoveredLinkId != -1)
    {
        if (ImGui::GetIO().KeyCtrl && ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            // User initiated a split. Find the source pin of the hovered link.
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                splittingFromAttrId = it->second.first; // The source attribute ID
                juce::Logger::writeToLog("[CableSplit] Starting split from attr ID: " + juce::String(splittingFromAttrId));
            }
        }
    }
    // --- END OF CABLE SPLITTING ---

    // 2. If a split-drag is active, handle drawing and completion.
    if (splittingFromAttrId != -1)
    {
        // Draw a line from the source pin to the mouse cursor for visual feedback.
        if (auto it = attrPositions.find(splittingFromAttrId); it != attrPositions.end())
        {
            ImVec2 sourcePos = it->second;
            ImVec2 mousePos = ImGui::GetMousePos();
            const auto& theme = ThemeManager::getInstance().getCurrentTheme();
            ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, theme.links.preview_color, theme.links.preview_width);
        }

        // 3. Handle completion or cancellation of the drag.
        // We use Left-click to complete the link, matching ImNodes' default behavior.
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                // User dropped the link on a pin.
                auto srcPin = decodePinId(splittingFromAttrId);
                auto dstPin = decodePinId(hoveredPinId);

                // Ensure the connection is valid (Output -> Input).
                if (!srcPin.isInput && dstPin.isInput)
                {
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    graphNeedsRebuild = true;
                    pushSnapshot(); // Make it undoable
                }
            }

            // ALWAYS reset the state, whether the connection was successful or not.
            splittingFromAttrId = -1;
        }
        // Also allow cancellation with a right-click.
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            splittingFromAttrId = -1; // Cancel the operation.
        }
    }
    // --- END OF NEW LOGIC ---

    // Open popup now (outside editor) if requested this frame
    if (showInsertNodePopup)
    {
        showInsertNodePopup = false;
        // Validate the link still exists
        if (pendingInsertLinkId != -1)
        {
            bool stillValid = (/* modLinkIdToRoute.count(pendingInsertLinkId) || */ linkIdToAttrs.count(pendingInsertLinkId));
            if (!stillValid)
            {
                juce::Logger::writeToLog("[InsertNode] Skipping popup: link disappeared this frame");
                pendingInsertLinkId = -1;
            }
        }
        if (pendingInsertLinkId != -1)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            // Consume the mouse release/click so the popup stays open
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode] Opened popup (post-editor)");
        }
        else
        {
            linkToInsertOn = {}; // safety
        }
        pendingInsertLinkId = -1;
    }
    // Fallback: If user right-clicked and a link was hovered this frame, open popup using cached hover
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Right)
        && lastHoveredLinkId != -1
        && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        int id = lastHoveredLinkId;
        linkToInsertOn = {}; linkToInsertOn.linkId = id;
        bool captured = false;
        // TODO: Handle modulation link deletion for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(id); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][RC-Fallback] Mod link captured id=" + juce::String(id));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            // Infer modulation vs audio vs video list from pin data types
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Link captured id=" + juce::String(id));
        }
        if (captured)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Opened popup");
        }
        else
        {
            linkToInsertOn.linkId = -1;
        }
    }
    // This function draws the popup if the popup is open.
    drawInsertNodeOnLinkPopup();

    // --- Cable Inspector: Stateless, rebuild-safe implementation ---
    hoveredLinkSrcId = 0;
    hoveredLinkDstId = 0;

    // Skip inspector if popups are open (graph is always in consistent state now)
    const bool anyPopupOpen = ImGui::IsPopupOpen("InsertNodeOnLinkPopup") || ImGui::IsPopupOpen("AddModulePopup");
    // Do not early-return here; we still need to finish the frame and close any ImGui scopes.

    if (!anyPopupOpen && synth != nullptr)
    {
        if (isLinkHovered && hoveredLinkId != -1)
        {
            // Safety: Re-verify link still exists in our mapping
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                // Set highlight IDs for this frame only
                hoveredLinkSrcId = srcPin.logicalId;
                hoveredLinkDstId = (dstPin.logicalId == 0) ? kOutputHighlightId : dstPin.logicalId;

                if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                {
                    const int numOutputs = srcModule->getTotalNumOutputChannels();
                    if (srcPin.channel >= 0 && srcPin.channel < numOutputs)
                    {
                        if (hoveredLinkId != m_currentlyProbedLinkId)
                        {
                            auto sourceNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
                            synth->setProbeConnection(sourceNodeId, srcPin.channel);
                            m_currentlyProbedLinkId = hoveredLinkId;
                        }

                        // Create link info for the tooltip
                        LinkInfo linkInfo;
                        linkInfo.srcLogicalNodeId = srcPin.logicalId;
                        linkInfo.srcNodeId = srcPin.logicalId;
                        linkInfo.srcChannel = srcPin.channel;
                        linkInfo.sourceNodeName = srcModule->getName();
                        linkInfo.pinName = srcModule->getAudioOutputLabel(srcPin.channel);
                        if (linkInfo.pinName.isEmpty())
                            linkInfo.pinName = "Channel " + juce::String(srcPin.channel);

                        ImGui::BeginTooltip();
                        drawLinkInspectorTooltip(linkInfo);
                        ImGui::EndTooltip();
                    }
                    else if (m_currentlyProbedLinkId != -1 && m_currentlyProbedLinkId != hoveredLinkId)
                    {
                        synth->clearProbeConnection();
                        m_currentlyProbedLinkId = -1;
                    }
                }
            }
        }
        else if (m_currentlyProbedLinkId != -1)
        {
            int hoveredNodeId = -1;
            bool isNodeHovered = ImNodes::IsNodeHovered(&hoveredNodeId);

            int hoveredPinId = -1;
            bool isPinHovered = ImNodes::IsPinHovered(&hoveredPinId);

            if (!isLinkHovered && !isNodeHovered && !isPinHovered)
            {
                synth->clearProbeConnection();
                m_currentlyProbedLinkId = -1;
            }
        }
    }
    else if (m_currentlyProbedLinkId != -1 && synth != nullptr)
    {
        synth->clearProbeConnection();
        m_currentlyProbedLinkId = -1;
    }
    // Update hovered node/link id for next frame (must be called outside editor scope)
    // Graph is always in consistent state since we rebuild at frame start
    int hv = -1;
    if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    int hl = -1;
    if (ImNodes::IsLinkHovered(&hl)) lastHoveredLinkId = hl; else lastHoveredLinkId = -1;
    // Shortcut: press 'I' while hovering a link to open Insert-on-Link popup (bypasses mouse handling)
    if (consumeShortcutFlag(shortcutInsertOnLinkRequested) && lastHoveredLinkId != -1 && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        linkToInsertOn = {}; // reset
        linkToInsertOn.linkId = lastHoveredLinkId;
        bool captured = false;
        // TODO: Handle modulation link hover end for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(lastHoveredLinkId); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][KeyI] Mod link captured id=" + juce::String(lastHoveredLinkId));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(lastHoveredLinkId); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][KeyI] Link captured id=" + juce::String(lastHoveredLinkId));
        }
        if (captured)
        {
            pendingInsertLinkId = lastHoveredLinkId;
            showInsertNodePopup = true; // will open next lines
        }
        else
        {
            linkToInsertOn.linkId = -1;
            juce::Logger::writeToLog("[InsertNode][KeyI] No link data found for id=" + juce::String(lastHoveredLinkId));
        }
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }
    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        // Avoid passing nullptr to ImNodes::IsLinkHovered; some builds may write to the pointer
        int dummyHoveredLinkId = -1;
        const bool anyLinkHovered = ImNodes::IsLinkHovered(&dummyHoveredLinkId);
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered()
            && !anyLinkHovered
            && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup")
            && linkToInsertOn.linkId == -1) // avoid conflict with insert-on-link popup
        {
                ImGui::OpenPopup("AddModulePopup");
        }
        // --- REVISED AND IMPROVED "QUICK ADD" POPUP ---
        if (ImGui::BeginPopup("AddModulePopup"))
        {
            static char searchQuery[128] = "";
            static int selectedIndex = 0;  // Track keyboard navigation

            // Auto-focus the search bar when the popup opens and clear any previous search
            if (ImGui::IsWindowAppearing())
            {
                ImGui::SetWindowFocus();

                if (dragInsertStartAttrId != -1)
                {
                    PinID displayPin = dragInsertStartPin;
                    auto type = displayPin.isMod ? PinDataType::CV : getPinDataTypeForPin(displayPin);

                    juce::String seed = ":" + juce::String(pinDataTypeToString(type));
                    juce::String modules;
                    const auto& suggestions = getDragInsertSuggestionsFor(displayPin);
                    for (size_t i = 0; i < suggestions.size(); ++i)
                        modules += ":" + suggestions[i];

                    juce::String tokenized = seed + modules;
                    auto truncated = tokenized.substring(0, juce::jmin((int)tokenized.length(), (int)sizeof(searchQuery) - 1));
                    std::memset(searchQuery, 0, sizeof(searchQuery));
                    std::memcpy(searchQuery, truncated.toRawUTF8(), (size_t)truncated.getNumBytesAsUTF8());
                }
                else
                {
                    searchQuery[0] = '\0';
                }

                ImGui::SetKeyboardFocusHere(0);
                selectedIndex = 0;
            }
            
            ImGui::Text("Add Module");
            ImGui::PushItemWidth(250.0f);
            
            // Enable Enter key detection for instant module creation
            bool enterPressed = ImGui::InputText("Search##addmodule", searchQuery, sizeof(searchQuery), 
                                                  ImGuiInputTextFlags_EnterReturnsTrue);
            
            ImGui::PopItemWidth();
            ImGui::Separator();
            
            // --- PROBE TOOL ---
            if (ImGui::MenuItem("ðŸ”¬ Probe Signal (Click any output pin)"))
            {
                isProbeModeActive = true;
                ImGui::CloseCurrentPopup();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Activate probe mode to instantly visualize any signal without manual patching.\nClick on any output pin to route it to the probe scope.");
            }
            ImGui::Separator();

            auto addAtMouse = [this](const char* type) {
                auto nodeId = synth->addModule(type);
                juce::String nodeName = juce::String(type).replaceCharacter('_', ' ');
                // Capitalize first letter of each word
                nodeName = nodeName.toLowerCase();
                bool capitalizeNext = true;
                for (int i = 0; i < nodeName.length(); ++i)
                {
                    if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
                    {
                        nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                        capitalizeNext = false;
                    }
                    else if (nodeName[i] == ' ')
                        capitalizeNext = true;
                }
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                // This places the new node exactly where the user right-clicked
                pendingNodeScreenPositions[logicalId] = ImGui::GetMousePosOnOpeningCurrentPopup();
                
                // Special handling for recorder module
                if (juce::String(type).equalsIgnoreCase("recorder"))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical((juce::uint32)logicalId)))
                    {
                        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
                    }
                }
                
                // Give comment nodes a default size to prevent feedback loop
                if (juce::String(type).equalsIgnoreCase("comment"))
                {
                    pendingNodeSizes[logicalId] = ImVec2(250.f, 150.f);
                }
                
                snapshotAfterEditor = true;
                ImGui::CloseCurrentPopup();
            };
            
            juce::String filter(searchQuery);

            ImGui::BeginChild("ModuleList", ImVec2(280, 350), true);

            if (filter.isEmpty())
            {
                // --- BROWSE MODE (No text in search bar) ---
                // Reorganized to match the new category structure
                
                if (ImGui::BeginMenu("Sources")) {
                    if (ImGui::MenuItem("VCO")) addAtMouse("vco");
                    if (ImGui::MenuItem("Polyphonic VCO")) addAtMouse("polyvco");
                    if (ImGui::MenuItem("Noise")) addAtMouse("noise");
                    if (ImGui::MenuItem("Audio Input")) addAtMouse("audio_input");
                    if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample_loader");
                    if (ImGui::MenuItem("Value")) addAtMouse("value");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Effects")) {
                    if (ImGui::MenuItem("VCF")) addAtMouse("vcf");
                    if (ImGui::MenuItem("Delay")) addAtMouse("delay");
                    if (ImGui::MenuItem("Reverb")) addAtMouse("reverb");
                    if (ImGui::MenuItem("Chorus")) addAtMouse("chorus");
                    if (ImGui::MenuItem("Phaser")) addAtMouse("phaser");
                    if (ImGui::MenuItem("Compressor")) addAtMouse("compressor");
                    if (ImGui::MenuItem("Limiter")) addAtMouse("limiter");
                    if (ImGui::MenuItem("Noise Gate")) addAtMouse("gate");
                    if (ImGui::MenuItem("Reroute")) addAtMouse("reroute");
                    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
                    if (ImGui::MenuItem("Graphic EQ")) addAtMouse("graphic_eq");
                    if (ImGui::MenuItem("Waveshaper")) addAtMouse("waveshaper");
                    if (ImGui::MenuItem("8-Band Shaper")) addAtMouse("8bandshaper");
                    if (ImGui::MenuItem("Granulator")) addAtMouse("granulator");
                    if (ImGui::MenuItem("Harmonic Shaper")) addAtMouse("harmonic_shaper");
                    if (ImGui::MenuItem("Time/Pitch Shifter")) addAtMouse("timepitch");
                    if (ImGui::MenuItem("De-Crackle")) addAtMouse("de_crackle");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Modulators")) {
                    if (ImGui::MenuItem("LFO")) addAtMouse("lfo");
                    if (ImGui::MenuItem("ADSR")) addAtMouse("adsr");
                    if (ImGui::MenuItem("Random")) addAtMouse("random");
                    if (ImGui::MenuItem("S&H")) addAtMouse("s_and_h");
                    if (ImGui::MenuItem("Function Generator")) addAtMouse("function_generator");
                    if (ImGui::MenuItem("Shaping Oscillator")) addAtMouse("shaping_oscillator");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Utilities & Logic")) {
                    if (ImGui::MenuItem("VCA")) addAtMouse("vca");
                    if (ImGui::MenuItem("Mixer")) addAtMouse("mixer");
                    if (ImGui::MenuItem("CV Mixer")) addAtMouse("cv_mixer");
                    if (ImGui::MenuItem("Track Mixer")) addAtMouse("track_mixer");
                    if (ImGui::MenuItem("PanVol")) addAtMouse("panvol");
                    if (ImGui::MenuItem("Attenuverter")) addAtMouse("attenuverter");
                    if (ImGui::MenuItem("Lag Processor")) addAtMouse("lag_processor");
                    if (ImGui::MenuItem("Math")) addAtMouse("math");
                    if (ImGui::MenuItem("Map Range")) addAtMouse("map_range");
                    if (ImGui::MenuItem("Quantizer")) addAtMouse("quantizer");
                    if (ImGui::MenuItem("Rate")) addAtMouse("rate");
                    if (ImGui::MenuItem("Comparator")) addAtMouse("comparator");
                    if (ImGui::MenuItem("Logic")) addAtMouse("logic");
                    if (ImGui::MenuItem("Reroute")) addAtMouse("reroute");
                    if (ImGui::MenuItem("Clock Divider")) addAtMouse("clock_divider");
                    if (ImGui::MenuItem("Sequential Switch")) addAtMouse("sequential_switch");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Sequencers")) {
                    if (ImGui::MenuItem("Sequencer")) addAtMouse("sequencer");
                    if (ImGui::MenuItem("Multi Sequencer")) addAtMouse("multi_sequencer");
                    if (ImGui::MenuItem("Tempo Clock")) addAtMouse("tempo_clock");
                    if (ImGui::MenuItem("Snapshot Sequencer")) addAtMouse("snapshot_sequencer");
                    if (ImGui::MenuItem("Stroke Sequencer")) addAtMouse("stroke_sequencer");
                    if (ImGui::MenuItem("Timeline")) addAtMouse("timeline");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("MIDI")) {
                    if (ImGui::MenuItem("MIDI CV")) addAtMouse("midi_cv");
                    if (ImGui::MenuItem("MIDI Player")) addAtMouse("midi_player");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Faders")) addAtMouse("midi_faders");
                    if (ImGui::MenuItem("MIDI Knobs")) addAtMouse("midi_knobs");
                    if (ImGui::MenuItem("MIDI Buttons")) addAtMouse("midi_buttons");
                    if (ImGui::MenuItem("MIDI Jog Wheel")) addAtMouse("midi_jog_wheel");
                    if (ImGui::MenuItem("MIDI Pads")) addAtMouse("midi_pads");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Logger")) addAtMouse("midi_logger");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Analysis")) {
                    if (ImGui::MenuItem("Scope")) addAtMouse("scope");
                    if (ImGui::MenuItem("Debug")) addAtMouse("debug");
                    if (ImGui::MenuItem("Input Debug")) addAtMouse("input_debug");
                    if (ImGui::MenuItem("Frequency Graph")) addAtMouse("frequency_graph");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("TTS")) {
                    if (ImGui::MenuItem("TTS Performer")) addAtMouse("tts_performer");
                    if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("vocal_tract_filter");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Special")) {
                    if (ImGui::MenuItem("Physics")) addAtMouse("physics");
                    if (ImGui::MenuItem("Animation")) addAtMouse("animation");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Computer Vision")) {
                    if (ImGui::MenuItem("Webcam Loader")) addAtMouse("webcam_loader");
                    if (ImGui::MenuItem("Video File Loader")) addAtMouse("video_file_loader");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Video FX")) addAtMouse("video_fx");
                    if (ImGui::MenuItem("Crop Video")) addAtMouse("crop_video");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Movement Detector")) addAtMouse("movement_detector");
                    if (ImGui::MenuItem("Human Detector")) addAtMouse("human_detector");
                    if (ImGui::MenuItem("Object Detector")) addAtMouse("object_detector");
                    if (ImGui::MenuItem("Pose Estimator")) addAtMouse("pose_estimator");
                    if (ImGui::MenuItem("Hand Tracker")) addAtMouse("hand_tracker");
                    if (ImGui::MenuItem("Face Tracker")) addAtMouse("face_tracker");
                    if (ImGui::MenuItem("Color Tracker")) addAtMouse("color_tracker");
                    if (ImGui::MenuItem("Contour Detector")) addAtMouse("contour_detector");
                    if (ImGui::MenuItem("Semantic Segmentation")) addAtMouse("semantic_segmentation");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Plugins / VST")) {
                    addPluginModules(); // Re-use your existing plugin menu logic
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("System")) {
                    // if (ImGui::MenuItem("Meta")) addAtMouse("meta");
                    // if (ImGui::MenuItem("Inlet")) addAtMouse("inlet");
                    // if (ImGui::MenuItem("Outlet")) addAtMouse("outlet");
                    if (ImGui::MenuItem("Comment")) addAtMouse("comment");
                    if (ImGui::MenuItem("Recorder")) addAtMouse("recorder");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Best Practice")) addAtMouse("best_practice");
                    ImGui::EndMenu();
                }
            }
            else
            {
                // --- SEARCH MODE (Text has been entered) ---
                struct MatchedModule {
                    juce::String displayName;
                    const char* internalType;
                    const char* description;
                };
                std::vector<MatchedModule> matches;

                auto registry = getModuleRegistry();
                std::unordered_set<juce::String> matchedInternals;

                auto addMatchByInternal = [&](const juce::String& internal)
                {
                    if (!matchedInternals.insert(internal).second)
                        return;
                    for (const auto& entry : registry)
                    {
                        if (juce::String(entry.second.first).equalsIgnoreCase(internal))
                        {
                            matches.push_back({entry.first, entry.second.first, entry.second.second});
                            break;
                        }
                    }
                };

                bool usingTokenFilter = false;
                juce::String tokenType;

                if (filter.startsWithChar(':'))
                {
                    juce::StringArray tokens;
                    tokens.addTokens(filter, ":", "");
                    tokens.removeEmptyStrings();

                    if (!tokens.isEmpty())
                    {
                        usingTokenFilter = true;
                        tokenType = tokens[0];

                        auto parsePinTypeToken = [](const juce::String& token, PinDataType& outType) -> bool
                        {
                            if (token.equalsIgnoreCase("audio")) { outType = PinDataType::Audio; return true; }
                            if (token.equalsIgnoreCase("cv") || token.equalsIgnoreCase("mod")) { outType = PinDataType::CV; return true; }
                            if (token.equalsIgnoreCase("gate") || token.equalsIgnoreCase("trigger")) { outType = PinDataType::Gate; return true; }
                            if (token.equalsIgnoreCase("raw")) { outType = PinDataType::Raw; return true; }
                            if (token.equalsIgnoreCase("video")) { outType = PinDataType::Video; return true; }
                            return false;
                        };

                        PinDataType parsedType = PinDataType::Raw;
                        const bool typeParsed = parsePinTypeToken(tokenType, parsedType);

                        for (int i = 1; i < tokens.size(); ++i)
                        {
                            juce::String internal = tokens[i].trim();
                            if (internal.isNotEmpty())
                                addMatchByInternal(internal);
                        }

                        if (matches.empty() && typeParsed)
                        {
                            auto appendFromMap = [&](const std::map<PinDataType, std::vector<juce::String>>& source)
                            {
                                if (auto it = source.find(parsedType); it != source.end())
                                {
                                    for (const auto& internal : it->second)
                                        addMatchByInternal(internal);
                                }
                            };
                            appendFromMap(dragInsertSuggestionsInputs);
                            appendFromMap(dragInsertSuggestionsOutputs);
                        }

                        if (matches.empty())
                        {
                            usingTokenFilter = false;
                        }
                        else
                        {
                            juce::String label = tokenType.isNotEmpty() ? tokenType : "signal";
                            ImGui::TextDisabled("Suggestions for %s", label.toRawUTF8());
                            ImGui::Separator();
                        }
                    }
                }

                if (!usingTokenFilter)
                {
                    for (const auto& entry : registry)
                    {
                        const juce::String& displayName = entry.first;
                        const char* internalType = entry.second.first;
                        const char* description = entry.second.second;

                        if (displayName.containsIgnoreCase(filter)
                            || juce::String(internalType).containsIgnoreCase(filter))
                        {
                            if (matchedInternals.insert(juce::String(internalType)).second)
                                matches.push_back({displayName, internalType, description});
                        }
                    }
                }

                if (ImGui::IsKeyPressed(ImGuiKey_DownArrow))
                {
                    selectedIndex++;
                    if (selectedIndex >= (int)matches.size())
                        selectedIndex = (int)matches.size() - 1;
                }
                if (ImGui::IsKeyPressed(ImGuiKey_UpArrow))
                {
                    selectedIndex--;
                    if (selectedIndex < 0)
                        selectedIndex = 0;
                }
                if (enterPressed && !matches.empty())
                {
                    if (selectedIndex >= 0 && selectedIndex < (int)matches.size())
                    {
                        addAtMouse(matches[selectedIndex].internalType);
                    }
                }

                for (int i = 0; i < (int)matches.size(); ++i)
                {
                    const auto& match = matches[i];
                    bool isSelected = (i == selectedIndex);

                    if (ImGui::Selectable(match.displayName.toRawUTF8(), isSelected))
                    {
                        addAtMouse(match.internalType);
                    }

                    if (isSelected && !ImGui::IsItemVisible())
                        ImGui::SetScrollHereY(0.5f);

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::TextUnformatted(match.description);
                        ImGui::EndTooltip();
                    }
                }

                if (selectedIndex >= (int)matches.size())
                    selectedIndex = (int)matches.size() - 1;
                if (selectedIndex < 0 && !matches.empty())
                    selectedIndex = 0;
            }

            ImGui::EndChild();
            ImGui::EndPopup();
        }

        // Helper functions are now class methods

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinId(startAttr);
            auto endPin = decodePinId(endAttr);
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // Ensure connection is always Output -> Input
            if (!srcPin.isInput && dstPin.isInput)
            {
                PinDataType srcType = getPinDataTypeForPin(srcPin);
                
                // CRITICAL: Update reroute node type BEFORE checking compatibility
                // This ensures reroute nodes adopt the source type before type checks
                if (dstPin.logicalId != 0 && getTypeForLogical(dstPin.logicalId).equalsIgnoreCase("reroute"))
                {
                    if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(dstPin.logicalId)))
                    {
                        reroute->setPassthroughType(srcType);
                    }
                }
                
                // Re-query dstType after potential reroute update
                PinDataType dstType = getPinDataTypeForPin(dstPin);

                bool conversionHandled = false;

                // Determine if a converter is needed based on pin types
                if (srcType == PinDataType::Audio && dstType == PinDataType::CV)
                {
                    insertNodeBetween("attenuverter", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::CV && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Audio && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Raw && dstType != PinDataType::Raw)
                {
                    insertNodeBetween("map_range", srcPin, dstPin);
                    conversionHandled = true;
                }

                if (conversionHandled)
                {
                    pushSnapshot();
                }
                else
                {
                    // All other combinations are considered directly compatible.
                    if (!dstPin.isMod && dstPin.isInput && dstPin.logicalId != 0)
                    {
                        if (getTypeForLogical(dstPin.logicalId).equalsIgnoreCase("reroute"))
                            updateRerouteTypeFromConnections(dstPin.logicalId);
                    }

                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    // Immediate commit for RecordModuleProcessor filename update
                    synth->commitChanges();

                    if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId)) {
                        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule)) {
                            juce::String sourceName;
                            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId)) {
                                sourceName = srcModule->getName();
                            }
                            recorder->updateSuggestedFilename(sourceName);
                        }
                    }

                    auto updateRerouteForPin = [&](const PinID& pin)
                    {
                        if (pin.logicalId != 0 && getTypeForLogical(pin.logicalId).equalsIgnoreCase("reroute"))
                            updateRerouteTypeFromConnections(pin.logicalId);
                    };
                    updateRerouteForPin(srcPin);
                    updateRerouteForPin(dstPin);

                    pushSnapshot();
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                // Debug log disconnect intent
                juce::Logger::writeToLog(
                    juce::String("[LinkDelete] src(lid=") + juce::String((int)srcPin.logicalId) + ",ch=" + juce::String(srcPin.channel) +
                    ") -> dst(lid=" + juce::String((int)dstPin.logicalId) + ",ch=" + juce::String(dstPin.channel) + ")");

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                
                // Immediate commit for RecordModuleProcessor filename update
                synth->commitChanges();
                
                auto updateRerouteForPin = [&](const PinID& pin)
                {
                    if (pin.logicalId != 0 && getTypeForLogical(pin.logicalId).equalsIgnoreCase("reroute"))
                        updateRerouteTypeFromConnections(pin.logicalId);
                };
                updateRerouteForPin(srcPin);
                updateRerouteForPin(dstPin);
                
                // After disconnecting, tell the recorder to update (pass empty string for unconnected)
                if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule))
                    {
                        recorder->updateSuggestedFilename(""); // Empty = unconnected
                    }
                }
                
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)
        // Keyboard shortcuts
        // Only process global keyboard shortcuts if no ImGui widget wants the keyboard
        if (!ImGui::GetIO().WantCaptureKeyboard)
        {
            if (consumeShortcutFlag(shortcutFileSaveAsRequested))
            {
                startSaveDialog();
            }
            if (consumeShortcutFlag(shortcutFileSaveRequested))
            {
                if (currentPresetFile.existsAsFile())
                    savePresetToFile(currentPresetFile);
                else
                    startSaveDialog();
            }
            if (consumeShortcutFlag(shortcutFileOpenRequested))
            {
                startLoadDialog();
            }
            if (consumeShortcutFlag(shortcutRandomizePatchRequested))
            {
                handleRandomizePatch();
            }
            if (consumeShortcutFlag(shortcutRandomizeConnectionsRequested))
            {
                handleRandomizeConnections();
            }
            if (consumeShortcutFlag(shortcutBeautifyLayoutRequested))
            {
                handleBeautifyLayout();
            }
        
            if (consumeShortcutFlag(shortcutMuteSelectionRequested) && ImNodes::NumSelectedNodes() > 0)
            {
                handleMuteToggle();
            }

            if (consumeShortcutFlag(shortcutSelectAllRequested))
            {
                if (synth != nullptr)
                {
                    const auto& modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0);
                    for (const auto& mod : modules)
                        allNodeIds.push_back((int)mod.first);

                    ImNodes::ClearNodeSelection();
                    for (int id : allNodeIds)
                        ImNodes::SelectNode(id);
                }
            }

            if (consumeShortcutFlag(shortcutChainSequentialRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleNodeChaining();
            }

            if (consumeShortcutFlag(shortcutChainAudioRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Audio);
            }

            if (consumeShortcutFlag(shortcutChainCvRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::CV);
            }

            if (consumeShortcutFlag(shortcutChainGateRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Gate);
            }

            if (consumeShortcutFlag(shortcutChainRawRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Raw);
            }

            if (consumeShortcutFlag(shortcutChainVideoRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Video);
            }
        
            if (consumeShortcutFlag(shortcutCtrlRRequested))
            {
                const int numSelected = ImNodes::NumSelectedNodes();
                if (numSelected > 0 && synth != nullptr)
                {
                    pushSnapshot();

                    std::vector<int> selectedNodeIds(numSelected);
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());

                    for (int lid : selectedNodeIds)
                    {
                        if (auto* module = synth->getModuleForLogical((juce::uint32)lid))
                        {
                            auto& params = module->getParameters();
                            for (auto* paramBase : params)
                            {
                                if (auto* param = dynamic_cast<juce::RangedAudioParameter*>(paramBase))
                                    param->setValueNotifyingHost(param->getDefaultValue());
                            }
                            juce::Logger::writeToLog("[Reset] Reset parameters for node " + juce::String(lid));
                        }
                    }
                }
                else
                {
                    handleRecordOutput();
                }
            }
            if (consumeShortcutFlag(shortcutConnectOutputRequested) && ImNodes::NumSelectedNodes() == 1)
            {
                if (synth != nullptr)
                {
                    int selectedId = 0;
                    ImNodes::GetSelectedNodes(&selectedId);
                    if (selectedId != 0)
                    {
                        synth->connect(synth->getNodeIdForLogical(selectedId), 0, synth->getOutputNodeID(), 0);
                        synth->connect(synth->getNodeIdForLogical(selectedId), 1, synth->getOutputNodeID(), 1);
                        graphNeedsRebuild = true;
                        pushSnapshot();
                    }
                }
            }

            if (consumeShortcutFlag(shortcutDisconnectRequested) && ImNodes::NumSelectedNodes() > 0)
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    for (int id : selectedNodeIds)
                        synth->clearConnectionsForNode(synth->getNodeIdForLogical(id));

                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
            }
            auto frameNodes = [&](const std::vector<int>& nodeIds)
            {
                if (nodeIds.empty() || synth == nullptr)
                    return;

                juce::Rectangle<float> bounds;
                bool foundAny = false;

                std::unordered_set<int> validNodes;
                validNodes.insert(0);
                for (const auto& mod : synth->getModulesInfo())
                    validNodes.insert((int)mod.first);

                for (int nodeId : nodeIds)
                {
                    if (validNodes.find(nodeId) != validNodes.end())
                    {
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
                        if (!foundAny)
                        {
                            bounds = juce::Rectangle<float>(pos.x, pos.y, 1, 1);
                            foundAny = true;
                        }
                        else
                        {
                            bounds = bounds.getUnion(juce::Rectangle<float>(pos.x, pos.y, 1, 1));
                        }
                    }
                }

                if (!foundAny)
                    return;

                if (!nodeIds.empty() && validNodes.find(nodeIds[0]) != validNodes.end())
                    bounds = bounds.expanded(ImNodes::GetNodeDimensions(nodeIds[0]).x, ImNodes::GetNodeDimensions(nodeIds[0]).y);

                ImVec2 center((bounds.getX() + bounds.getRight()) * 0.5f,
                              (bounds.getY() + bounds.getBottom()) * 0.5f);
                ImNodes::EditorContextResetPanning(center);
            };

            if (consumeShortcutFlag(shortcutFrameSelectionRequested))
            {
                const int numSelected = ImNodes::NumSelectedNodes();
                if (numSelected > 0)
                {
                    std::vector<int> selectedNodeIds(numSelected);
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    frameNodes(selectedNodeIds);
                }
            }

            if (consumeShortcutFlag(shortcutFrameAllRequested))
            {
                if (synth != nullptr)
                {
                    auto modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0);
                    for (const auto& mod : modules)
                        allNodeIds.push_back((int)mod.first);
                    frameNodes(allNodeIds);
                }
            }

            if (consumeShortcutFlag(shortcutResetOriginRequested))
            {
                ImNodes::EditorContextResetPanning(ImVec2(0, 0));
            }

            if (consumeShortcutFlag(shortcutToggleDebugRequested))
            {
                showDebugMenu = !showDebugMenu;
            }

            if (consumeShortcutFlag(shortcutUndoRequested))
            {
                if (undoStack.size() > 1)
                {
                    Snapshot current = undoStack.back();
                    redoStack.push_back(current);
                    undoStack.pop_back();
                    restoreSnapshot(undoStack.back());
                    linkIdToAttrs.clear();
                    NotificationManager::post(NotificationManager::Type::Info, "Undo");
                }
            }

            if (consumeShortcutFlag(shortcutRedoRequested))
            {
                if (!redoStack.empty())
                {
                    Snapshot s = redoStack.back();
                    redoStack.pop_back();
                    restoreSnapshot(s);
                    undoStack.push_back(s);
                    linkIdToAttrs.clear();
                    NotificationManager::post(NotificationManager::Type::Info, "Redo");
                }
            }

            const bool duplicateRequested = consumeShortcutFlag(shortcutDuplicateRequested);
            const bool duplicateWithRoutingRequested = consumeShortcutFlag(shortcutDuplicateWithRoutingRequested);
            if (duplicateRequested || duplicateWithRoutingRequested)
            {
                const bool copyConnections = duplicateWithRoutingRequested;
                const int n = ImNodes::NumSelectedNodes();
                if (n > 0)
                {
                    std::vector<int> sel((size_t)n);
                    ImNodes::GetSelectedNodes(sel.data());
                    for (int oldId : sel)
                    {
                        if (oldId == 0)
                            continue;

                        const juce::String type = getTypeForLogical((juce::uint32)oldId);
                        if (type.isEmpty())
                            continue;

                        auto newNodeId = synth->addModule(type);
                        graphNeedsRebuild = true;
                        const juce::uint32 newLogical = synth->getLogicalIdForNode(newNodeId);
                        if (newLogical != 0)
                        {
                            if (auto* src = synth->getModuleForLogical((juce::uint32)oldId))
                                if (auto* dst = synth->getModuleForLogical(newLogical))
                                    dst->getAPVTS().replaceState(src->getAPVTS().copyState());

                            ImVec2 pos = ImNodes::GetNodeGridSpacePos(oldId);
                            pendingNodePositions[(int)newLogical] = ImVec2(pos.x + 40.0f, pos.y + 40.0f);

                            if (copyConnections)
                            {
                                const auto oldNode = synth->getNodeIdForLogical((juce::uint32)oldId);
                                const auto newNode = newNodeId;
                                for (const auto& c : synth->getConnectionsInfo())
                                {
                                    if ((int)c.srcLogicalId == oldId)
                                    {
                                        auto dstNode = (c.dstLogicalId == 0)
                                                            ? synth->getOutputNodeID()
                                                            : synth->getNodeIdForLogical(c.dstLogicalId);
                                        synth->connect(newNode, c.srcChan, dstNode, c.dstChan);
                                    }
                                    if ((int)c.dstLogicalId == oldId)
                                    {
                                        auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                                        synth->connect(srcNode, c.srcChan, newNode, c.dstChan);
                                    }
                                }
                                // TODO: Implement modulation route duplication for new bus-based system
                            }
                        }
                    }

                    pushSnapshot();
                    NotificationManager::post(NotificationManager::Type::Info, "Duplicated " + juce::String(n) + " node(s)");
                }
            }
        
        } // End of keyboard shortcuts (WantCaptureKeyboard check)

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }
    // === MIDI DEVICE MANAGER WINDOW ===
    if (showMidiDeviceManager)
    {
        if (ImGui::Begin("MIDI Device Manager", &showMidiDeviceManager, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ThemeText("MIDI Input Devices", theme.text.section_header);
            ImGui::Separator();
            
            // Access MidiDeviceManager from PresetCreatorComponent
            auto* presetCreator = dynamic_cast<PresetCreatorComponent*>(getParentComponent());
            if (presetCreator && presetCreator->midiDeviceManager)
            {
                auto& midiMgr = *presetCreator->midiDeviceManager;
                const auto& devices = midiMgr.getDevices();
                
                if (devices.empty())
                {
                    ImGui::TextDisabled("No MIDI devices found");
                }
                else
                {
                    ImGui::Text("Found %d device(s):", (int)devices.size());
                    ImGui::Spacing();
                    
                    // Display each device
                    for (const auto& device : devices)
                    {
                        ImGui::PushID(device.identifier.toRawUTF8());
                        
                        // Checkbox to enable/disable device
                        bool enabled = device.enabled;
                        if (ImGui::Checkbox("##enabled", &enabled))
                        {
                            if (enabled)
                                midiMgr.enableDevice(device.identifier);
                            else
                                midiMgr.disableDevice(device.identifier);
                        }
                        
                        ImGui::SameLine();
                        
                        // Device name
                        ImGui::Text("%s", device.name.toRawUTF8());
                        
                        // Activity indicator
                        auto activity = midiMgr.getDeviceActivity(device.identifier);
                        if (activity.lastMessageTime > 0)
                        {
                            ImGui::SameLine();
                            float timeSinceMessage = (juce::Time::getMillisecondCounter() - activity.lastMessageTime) / 1000.0f;
                            if (timeSinceMessage < 1.0f)
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.active);
                                ImGui::Text("ACTIVE");
                                ImGui::PopStyleColor();
                            }
                            else
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                                ImGui::Text("idle");
                                ImGui::PopStyleColor();
                            }
                        }
                        
                        ImGui::PopID();
                    }
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                // Rescan button
                if (ImGui::Button("Rescan Devices"))
                {
                    midiMgr.scanDevices();
                }
                
                ImGui::SameLine();
                
                // Enable/Disable all buttons
                if (ImGui::Button("Enable All"))
                {
                    midiMgr.enableAllDevices();
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Disable All"))
                {
                    midiMgr.disableAllDevices();
                }
            }
            else
            {
                ImGui::TextDisabled("MIDI Manager not available");
            }
        }
        ImGui::End();
    }

    // === DEBUG WINDOW ===
    if (showDebugMenu)
    {
        if (ImGui::Begin("System Diagnostics", &showDebugMenu))
        {
            if (synth != nullptr)
            {
                ImGui::Text("=== SYSTEM OVERVIEW ===");
                if (ImGui::Button("Refresh"))
                {
                    // Force refresh of diagnostics
                }
                
                
                // System diagnostics
                ImGui::Text("System State:");
                juce::String systemDiag = synth->getSystemDiagnostics();
                ImGui::TextWrapped("%s", systemDiag.toUTF8());
                
                
                // Module selector
                ImGui::Text("Module Diagnostics:");
                auto modules = synth->getModulesInfo();
                if (!modules.empty())
                {
                    static int selectedModuleIndex = 0;
                    if (selectedModuleIndex >= (int)modules.size()) selectedModuleIndex = 0;
                    
                    juce::String moduleList = "";
                    for (size_t i = 0; i < modules.size(); ++i)
                    {
                        if (i > 0) moduleList += "\0";
                        moduleList += "Logical " + juce::String((int)modules[i].first) + ": " + modules[i].second;
                    }
                    moduleList += "\0";
                    
                    if (ImGui::Combo("Select Module", &selectedModuleIndex, moduleList.toUTF8()))
                    {
                        if (selectedModuleIndex < (int)modules.size())
                        {
                            juce::String moduleDiag = synth->getModuleDiagnostics(modules[selectedModuleIndex].first);
                            ImGui::TextWrapped("%s", moduleDiag.toUTF8());
                        }
                    }
                }
                else
                {
                    ImGui::Text("No modules found.");
                }
            }
            else
            {
                ImGui::Text("No synth processor available.");
            }
        }
        ImGui::End();
    }

    ImGui::End();
    
    // === POP THE TRANSPARENT BACKGROUND STYLE ===
    ImGui::PopStyleColor();
    // === END OF FIX ===

    // Render notification system (must be called at the end to appear on top)
    NotificationManager::render();
    // --- Phase 5: Periodic Stale History Cleanup ---
    static double lastCleanupTime = 0.0;
    const double currentTimeSec = juce::Time::getMillisecondCounterHiRes() / 1000.0;
    if (currentTimeSec - lastCleanupTime > 10.0) // Run every 10 seconds
    {
        lastCleanupTime = currentTimeSec;
        // Set cutoff for "stale" entries (2x the max window size = 40 seconds)
        const double staleCutoffTime = currentTimeSec - (20.0 * 2.0);
        
        for (auto it = inspectorHistory.begin(); it != inspectorHistory.end(); /* no increment */)
        {
            if (it->second.lastAccessTime < staleCutoffTime)
            {
                it = inspectorHistory.erase(it); // Erase stale entry
            }
            else
            {
                ++it;
            }
        }
    }

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::rebuildFontAtlas()
{
    ImGuiIO& io = ImGui::GetIO();
    ThemeManager::getInstance().applyFonts(io);
    ImGui_ImplOpenGL2_DestroyDeviceObjects();
    ImGui_ImplOpenGL2_CreateDeviceObjects();
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        // Temporarily mask rebuild flag to avoid ImNodes queries during capture
        const bool rebuilding = graphNeedsRebuild.load();
        if (rebuilding) {
            // getUiValueTree will still avoid ImNodes now, but assert safety
        }
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        // Do not commit pending positions of (0,0) which are placeholders
        for (int i = 0; i < applied.getNumChildren(); ++i)
        {
            auto n = applied.getChild(i);
            if (! n.hasType("node")) continue;
            const float x = (float) n.getProperty("x", 0.0f);
            const float y = (float) n.getProperty("y", 0.0f);
            if (x == 0.0f && y == 0.0f) {
                // Try to recover from last-known or pending
                const int nid = (int) n.getProperty("id", -1);
                auto itL = lastKnownNodePositions.find(nid);
                if (itL != lastKnownNodePositions.end()) { n.setProperty("x", itL->second.x, nullptr); n.setProperty("y", itL->second.y, nullptr); }
                else if (auto itP = pendingNodePositions.find(nid); itP != pendingNodePositions.end()) { n.setProperty("x", itP->second.x, nullptr); n.setProperty("y", itP->second.y, nullptr); }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        isPatchDirty = true; // Mark patch as dirty
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
    
    // Mark patch as dirty whenever a change is made
    isPatchDirty = true;
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed


juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        
        // Prefer cached position if available; never query ImNodes while rebuilding
        ImVec2 pos;
        if (lastKnownNodePositions.count(nid) > 0)
        {
            pos = lastKnownNodePositions.at(nid);
        }
        else if (auto it = pendingNodePositions.find(nid); it != pendingNodePositions.end())
        {
            pos = it->second;
        }
        else if (!graphNeedsRebuild.load() && hasRenderedAtLeastOnce)
        {
            pos = ImNodes::GetNodeGridSpacePos(nid);
        }
        else
        {
            pos = ImVec2(0.0f, 0.0f);
        }
        
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        
        // --- FIX: Save muted/bypassed state ---
        // If this node's ID is in our map of muted nodes, add the property to the XML
        if (mutedNodeStates.count(nid) > 0)
        {
            n.setProperty("muted", true, nullptr);
        }
        
        ui.addChild (n, -1, nullptr);
    }
    
    // --- FIX: Explicitly save the output node position (ID 0) ---
    // The main output node is not part of getModulesInfo(), so we need to save it separately
    
    // Prefer cached output position; avoid ImNodes when rebuilding
    ImVec2 outputPos;
    if (lastKnownNodePositions.count(0) > 0)
    {
        outputPos = lastKnownNodePositions.at(0);
    }
    else if (auto it0 = pendingNodePositions.find(0); it0 != pendingNodePositions.end())
    {
        outputPos = it0->second;
    }
    else if (!graphNeedsRebuild.load() && hasRenderedAtLeastOnce)
    {
        outputPos = ImNodes::GetNodeGridSpacePos(0);
    }
    else
    {
        outputPos = ImVec2(0.0f, 0.0f);
    }
    
    juce::ValueTree outputNode("node");
    outputNode.setProperty("id", 0, nullptr);
    outputNode.setProperty("x", outputPos.x, nullptr);
    outputNode.setProperty("y", outputPos.y, nullptr);
    ui.addChild(outputNode, -1, nullptr);
    // --- END OF FIX ---
    
    return ui;
}
void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid() || synth == nullptr) return;
    
    juce::Logger::writeToLog("[UI_RESTORE] Applying UI ValueTree now...");

    // This is the core of the crash: the synth graph has already been rebuilt by setStateInformation.
    // We must clear our stale UI data (like muted nodes) before applying the new state from the preset.
    mutedNodeStates.clear();
    
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);

        // ========================= THE FIX STARTS HERE =========================
        //
        // Before applying any property, VERIFY that this node ID actually exists
        // in the synth. This prevents crashes when loading presets that contain
        // modules which are not available in the current build.
        //
        bool nodeExistsInSynth = (nid == 0); // Node 0 is always the output node.
        if (!nodeExistsInSynth) {
            for (const auto& modInfo : synth->getModulesInfo()) {
                if ((int)modInfo.first == nid) {
                    nodeExistsInSynth = true;
                    break;
                }
            }
        }

        if (!nodeExistsInSynth)
        {
            juce::Logger::writeToLog("[UI_RESTORE] WARNING: Skipping UI properties for non-existent node ID " + juce::String(nid) + ". The module may be missing or failed to load.");
            continue; // Skip to the next node in the preset.
        }
        // ========================== END OF FIX ==========================

        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        if (!(x == 0.0f && y == 0.0f))
        {
            pendingNodePositions[nid] = ImVec2(x, y);
            juce::Logger::writeToLog("[UI_RESTORE] Queued position for node " + juce::String(nid) + ": (" + juce::String(x) + ", " + juce::String(y) + ")");
        }
        
        // Read and apply muted state from preset for existing nodes.
        if ((bool) n.getProperty("muted", false))
        {
            // Use muteNodeSilent to store the original connections first,
            // then apply the mute (which creates bypass connections)
            muteNodeSilent(nid);
            muteNode(nid);
        }
    }
    
    // Muting/unmuting modifies graph connections, so we must tell the
    // synth to rebuild its processing order.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[UI_RESTORE] UI state applied. Flagging for graph rebuild.");
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    const bool bypassRequested = consumeShortcutFlag(shortcutBypassDeleteRequested);
    const bool deleteRequested = consumeShortcutFlag(shortcutDeleteRequested);

    if (!bypassRequested && !deleteRequested)
        return;

    if (bypassRequested)
    {
        bypassDeleteSelectedNodes();
        return;
    }

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            // TODO: Handle modulation link deletion for new bus-based system
            // if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
            // {
            //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
            //     // TODO: Handle modulation route removal
            //     // if (paramId.isNotEmpty())
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL, paramId);
            //     // else
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            // }
            // else 
            if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            
            // Clean up vision module textures if exists
            if (visionModuleTextures.count(nid))
            {
                visionModuleTextures.erase(nid);
            }
            
            // Clean up sample loader textures if exists
            if (sampleLoaderTextureIds.count(nid))
            {
                sampleLoaderTextureIds.erase(nid);
            }
            
            mutedNodeStates.erase((juce::uint32)nid); // Clean up muted state if exists
            lastKnownNodePositions.erase(nid); // Clean up position cache
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}
void ImGuiNodeEditorComponent::bypassDeleteSelectedNodes()
{
    const int numSelNodes = ImNodes::NumSelectedNodes();
    if (numSelNodes <= 0 || synth == nullptr)
        return;

    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    std::vector<int> nodeIds((size_t) numSelNodes);
    ImNodes::GetSelectedNodes(nodeIds.data());

    for (int nid : nodeIds)
    {
        if (nid == 0)
            continue;

        bypassDeleteNode((juce::uint32) nid);
    }

    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}

void ImGuiNodeEditorComponent::bypassDeleteNode(juce::uint32 logicalId)
{
    // Collect all incoming/outgoing audio links for this node
    std::vector<decltype(synth->getConnectionsInfo())::value_type> inputs, outputs;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) inputs.push_back(c);
        if (c.srcLogicalId == logicalId) outputs.push_back(c);
    }

    // For each output channel, find matching input channel to splice
    for (const auto& out : outputs)
    {
        // Try to find input with same channel index, else fallback to first input
        const auto* inPtr = (const decltype(inputs)::value_type*) nullptr;
        for (const auto& in : inputs) { if (in.dstChan == out.srcChan) { inPtr = &in; break; } }
        if (inPtr == nullptr && !inputs.empty()) inPtr = &inputs.front();

        // Disconnect out link first
        auto srcNode = synth->getNodeIdForLogical(out.srcLogicalId);
        auto dstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
        synth->disconnect(srcNode, out.srcChan, dstNode, out.dstChan);

        if (inPtr != nullptr)
        {
            // Disconnect incoming link from the node
            auto inSrcNode = synth->getNodeIdForLogical(inPtr->srcLogicalId);
            auto inDstNode = synth->getNodeIdForLogical(inPtr->dstLogicalId);
            synth->disconnect(inSrcNode, inPtr->srcChan, inDstNode, inPtr->dstChan);

            // Connect source of incoming directly to destination of outgoing
            auto finalDstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
            synth->connect(inSrcNode, inPtr->srcChan, finalDstNode, out.dstChan);
        }
    }

    // TODO: Remove modulation routes targeting or originating this node using new bus-based system

    // Finally remove the node itself
    mutedNodeStates.erase(logicalId); // Clean up muted state if exists
    synth->removeModule(synth->getNodeIdForLogical(logicalId));
}

// === Non-Destructive Mute/Bypass Implementation ===

void ImGuiNodeEditorComponent::muteNodeSilent(juce::uint32 logicalId)
{
    // This function is used when loading presets. It records the connections that were
    // loaded from the XML without modifying the graph or creating bypass connections.
    // This preserves the original "unmuted" connections for later use.
    
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // Store all connections attached to this node
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // Store the state, but DON'T modify the graph or create bypass connections
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[MuteSilent] Node " + juce::String(logicalId) + 
                            " marked as muted, stored " + juce::String(state.incomingConnections.size()) + 
                            " incoming and " + juce::String(state.outgoingConnections.size()) + 
                            " outgoing connections.");
}
void ImGuiNodeEditorComponent::muteNode(juce::uint32 logicalId)
{
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // 1. Find and store all connections attached to this node.
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // 2. Disconnect all of them.
    for (const auto& c : state.incomingConnections) {
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }
    
    // --- FIX: More robust bypass splicing logic ---
    // 3. Splice the connections to bypass the node.
    // Connect the FIRST input source to ALL output destinations.
    // This correctly handles cases where input channel != output channel (e.g., Mixer input 3 â†’ output 0).
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Connect the primary input's source directly to the original output's destination
            synth->connect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Mute] Splicing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 4. Store the original state.
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " muted and bypassed.");
}

void ImGuiNodeEditorComponent::unmuteNode(juce::uint32 logicalId)
{
    if (!synth || mutedNodeStates.find(logicalId) == mutedNodeStates.end()) return;

    MutedNodeState state = mutedNodeStates[logicalId];

    // --- FIX: Remove bypass connections matching the new mute logic ---
    // 1. Find and remove the bypass connections.
    // The bypass connected the first input source to all output destinations.
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Disconnect the bypass connection
            synth->disconnect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Unmute] Removing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 2. Restore the original connections.
    for (const auto& c : state.incomingConnections) {
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }

    // 3. Remove from muted state.
    mutedNodeStates.erase(logicalId);
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " unmuted.");
}
void ImGuiNodeEditorComponent::handleMuteToggle()
{
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected == 0) return;

    pushSnapshot(); // Create a single undo state for the whole operation.

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    for (int lid : selectedNodeIds) {
        if (mutedNodeStates.count(lid)) {
            unmuteNode(lid);
        } else {
            muteNode(lid);
        }
    }

    graphNeedsRebuild = true;
}
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    bool wasAlreadyInProgress = isSaveInProgress.exchange(true); // Atomically check and set
    if (wasAlreadyInProgress)
    {
        juce::Logger::writeToLog("[SaveWorkflow] Save action ignored (already in progress). Current flag state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Flag set to TRUE. Starting save workflow for: " + file.getFullPathName());

    if (synth == nullptr) {
        juce::Logger::writeToLog("[SaveWorkflow] ERROR: Synth is null! Resetting flag and aborting.");
        NotificationManager::post(NotificationManager::Type::Error, "ERROR: Synth not ready!");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after synth null check.");
        return;
    }

    juce::Logger::writeToLog("--- [Save Workflow] Initiated for: " + file.getFullPathName() + " ---");
    
    // Post status notification (long duration since it will be replaced by Success/Error when complete)
    NotificationManager::post(NotificationManager::Type::Status, "Saving: " + file.getFileNameWithoutExtension(), 1000.0f);
    
    // --- All fast operations now happen on the UI thread BEFORE the job is launched ---
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Capturing state...");
    auto mutedNodeIDs = getMutedNodeIds();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Found " + juce::String((int)mutedNodeIDs.size()) + " muted nodes.");

    // Temporarily unmute to get correct connections
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Temporarily unmuting nodes for state capture...");
    for (auto lid : mutedNodeIDs) unmuteNode(lid);
    synth->commitChanges();

    // Capture state while unmuted
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling synth->getStateInformation()...");
    juce::MemoryBlock synthState;
    try {
        synth->getStateInformation(synthState);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Synth state captured (" + juce::String(synthState.getSize()) + " bytes).");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION in getStateInformation: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION in getStateInformation");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    }
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling editor->getUiValueTree()...");
    juce::ValueTree uiState = getUiValueTree();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UI state captured (valid: " + juce::String(uiState.isValid() ? 1 : 0) + ").");

    // Immediately re-mute to restore visual state
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Re-muting nodes to restore visual state...");
    for (auto lid : mutedNodeIDs) muteNode(lid);
    synth->commitChanges();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] State captured. Offloading to background thread.");

    // Launch the background job with the captured data
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Creating SavePresetJob...");
    auto* job = new SavePresetJob(synthState, uiState, file);

    job->onSaveComplete = [this, filePath = file.getFullPathName()](const juce::File& savedFile, bool success) {
        juce::Logger::writeToLog("[SaveWorkflow] onSaveComplete callback called (success: " + juce::String(success ? 1 : 0) + ") for: " + savedFile.getFullPathName());
        
        if (success) {
            NotificationManager::post(NotificationManager::Type::Success, "Saved: " + savedFile.getFileNameWithoutExtension());
            isPatchDirty = false;
            currentPresetFile = savedFile;
            juce::Logger::writeToLog("[SaveWorkflow] Save completed successfully. Flag will be reset.");
        } else {
            juce::Logger::writeToLog("[SaveWorkflow] Save FAILED. Flag will be reset.");
            NotificationManager::post(NotificationManager::Type::Error, "Failed to save preset!");
        }
        
        juce::Logger::writeToLog("[SaveWorkflow] Resetting isSaveInProgress flag to FALSE.");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset complete. Current state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    };

    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Adding job to thread pool...");
    try {
        threadPool.addJob(job, true);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Job added to thread pool successfully.");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION adding job to thread pool: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION adding job to thread pool");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    }
}
void ImGuiNodeEditorComponent::startSaveDialog()
{
    juce::Logger::writeToLog("[SaveWorkflow] startSaveDialog() called. isSaveInProgress: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    
    // Check if a save is already in progress to avoid opening multiple dialogs
    if (isSaveInProgress.load()) {
        juce::Logger::writeToLog("[SaveWorkflow] 'Save As' action ignored (a save is already in progress).");
        NotificationManager::post(NotificationManager::Type::Warning, "A save operation is already in progress. Please wait...", 3.0f);
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Opening file chooser dialog...");
    auto presetsDir = findPresetsDirectory();
    juce::Logger::writeToLog("[SaveWorkflow] Presets directory: " + presetsDir.getFullPathName());
    
    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      presetsDir, 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        juce::Logger::writeToLog("[SaveWorkflow] File chooser callback invoked.");
        auto fileToSave = fc.getResult();
        
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            juce::Logger::writeToLog("[SaveWorkflow] User selected file: " + fileToSave.getFullPathName());
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
        else
        {
            juce::Logger::writeToLog("[SaveWorkflow] User cancelled file chooser dialog.");
        }
    });
    juce::Logger::writeToLog("[SaveWorkflow] File chooser launched (async).");
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::getMutedNodeIds() const
{
    std::vector<juce::uint32> ids;
    // MutedNodeState is a map, so we don't need a lock if we're just reading keys
    for (const auto& pair : mutedNodeStates)
    {
        ids.push_back(pair.first);
    }
    return ids;
}


void ImGuiNodeEditorComponent::startLoadDialog()
{
    NotificationManager::post(NotificationManager::Type::Info, "Opening Load Preset dialog...", 3.0f);
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", findPresetsDirectory(), "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (!file.existsAsFile()) return;
        NotificationManager::post(NotificationManager::Type::Info, "Loading: " + file.getFileName(), 5.0f);

        auto xml = juce::XmlDocument::parse(file);
        if (!xml)
        {
            NotificationManager::post(NotificationManager::Type::Error, "Preset failed to load: Not a valid XML file.");
            return;
        }
        juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);

        // === STAGE 1 & 2: HEAL THE PRESET (RULE-BASED) ===
        PresetAutoHealer healer;
        auto healingMessages = healer.heal(presetVT);

        // === STAGE 3: VALIDATE THE (NOW HEALED) PRESET ===
        PresetValidator validator;
        auto issues = validator.validate(presetVT);
        int errorCount = 0;
        int warningCount = 0;
        for (const auto& issue : issues)
        {
            if (issue.severity == PresetValidator::Issue::Error) errorCount++; else warningCount++;
        }

        // Report errors/warnings but proceed to load to match built-in loader behavior
        if (errorCount > 0)
        {
            juce::String summary = "Validation found " + juce::String(errorCount) + " error(s). Attempting load anyway.";
            if (!healingMessages.empty()) summary += " (" + juce::String((int)healingMessages.size()) + " issue(s) auto-healed).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 12.0f);
            for (const auto& issue : issues)
            {
                if (issue.severity == PresetValidator::Issue::Error)
                    NotificationManager::post(NotificationManager::Type::Warning, issue.message, 12.0f);
            }
        }

        // === STAGE 4: LOAD THE HEALED DATA ===
        juce::MemoryBlock mb;
        juce::MemoryOutputStream mos(mb, false);
        if (auto healedXml = presetVT.createXml()) healedXml->writeTo(mos);
        synth->setStateInformation(mb.getData(), (int)mb.getSize());
        auto uiState = presetVT.getChildWithName("NodeEditorUI");
        if (uiState.isValid()) applyUiValueTree(uiState);
        isPatchDirty = false;
        currentPresetFile = file;
        pushSnapshot();

        // === STAGE 5: NOTIFY ===
        if (!healingMessages.empty() || warningCount > 0 || errorCount > 0)
        {
            juce::String summary = "Loaded with " + juce::String(warningCount + errorCount) + " issue(s).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 8.0f);
            for (const auto& msg : healingMessages)
                NotificationManager::post(NotificationManager::Type::Info, msg, 8.0f);
            for (const auto& issue : issues)
                NotificationManager::post(
                    issue.severity == PresetValidator::Issue::Warning ? NotificationManager::Type::Warning
                                                                       : NotificationManager::Type::Warning,
                    issue.message, 8.0f);
        }
        else
        {
            NotificationManager::post(NotificationManager::Type::Success, "Loaded: " + file.getFileNameWithoutExtension());
        }
    });
}
void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "vco", "noise", "sequencer", "vcf", "delay", "reverb", "waveshaper",
        "lfo", "adsr", "random", "s_and_h", "math", "map_range", "quantizer", "clock_divider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    addedModules.push_back({mixerId, "mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));
    addedModules.push_back({scopeId, "scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "mixer") finalMixerId = mod.first;
        if (mod.second == "scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "mixer") mixerId = mod.first;
        if (mod.second == "scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}
void ImGuiNodeEditorComponent::handleBeautifyLayout()
{
    if (synth == nullptr) return;

    // Graph is always in consistent state since we rebuild at frame start
    // Create an undo state so the action can be reversed
    pushSnapshot();
    juce::Logger::writeToLog("--- [Beautify Layout] Starting ---");

    // --- STEP 1: Build Graph Representation ---
    // Adjacency list: map<source_lid, vector<destination_lid>>
    std::map<juce::uint32, std::vector<juce::uint32>> adjacencyList;
    std::map<juce::uint32, int> inDegree; // Counts incoming connections for each node
    std::vector<juce::uint32> sourceNodes;

    auto modules = synth->getModulesInfo();
    for (const auto& mod : modules)
    {
        inDegree[mod.first] = 0;
        adjacencyList[mod.first] = {};
    }
    // Include the output node in the graph
    inDegree[0] = 0; // Output node ID is 0
    adjacencyList[0] = {}; // Output node has no outgoing connections

    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput)
        {
            adjacencyList[conn.srcLogicalId].push_back(0); // Connect to output node
            inDegree[0]++;
        }
        else
        {
            adjacencyList[conn.srcLogicalId].push_back(conn.dstLogicalId);
            inDegree[conn.dstLogicalId]++;
        }
    }

    for (const auto& mod : modules)
    {
        if (inDegree[mod.first] == 0)
        {
            sourceNodes.push_back(mod.first);
        }
    }

    juce::Logger::writeToLog("[Beautify] Found " + juce::String(sourceNodes.size()) + " source nodes");

    // --- STEP 2: Assign Nodes to Columns (Topological Sort) ---
    std::map<juce::uint32, int> nodeColumn;
    std::vector<std::vector<juce::uint32>> columns;
    int maxColumn = 0;

    // Initialize source nodes in column 0
    for (juce::uint32 nodeId : sourceNodes)
    {
        nodeColumn[nodeId] = 0;
    }
    columns.push_back(sourceNodes);

    // Process each column and assign children to appropriate columns
    std::queue<juce::uint32> processQueue;
    for (juce::uint32 srcNode : sourceNodes)
        processQueue.push(srcNode);

    while (!processQueue.empty())
    {
        juce::uint32 u = processQueue.front();
        processQueue.pop();

        for (juce::uint32 v : adjacencyList[u])
        {
            // The column for node 'v' is the maximum of its predecessors' columns + 1
            int newColumn = nodeColumn[u] + 1;
            if (nodeColumn.count(v) == 0 || newColumn > nodeColumn[v])
            {
                nodeColumn[v] = newColumn;
                maxColumn = std::max(maxColumn, newColumn);
                processQueue.push(v);
            }
        }
    }

    // Re-populate columns based on assignments
    columns.assign(maxColumn + 1, {});
    for (const auto& pair : nodeColumn)
    {
        columns[pair.second].push_back(pair.first);
    }

    juce::Logger::writeToLog("[Beautify] Arranged nodes into " + juce::String(maxColumn + 1) + " columns");

    // --- STEP 3: Optimize Node Ordering Within Columns ---
    // Sort nodes in each column based on median position of their parents
    for (int c = 1; c <= maxColumn; ++c)
    {
        std::map<juce::uint32, float> medianPositions;
        
        for (juce::uint32 nodeId : columns[c])
        {
            std::vector<float> parentPositions;
            
            // Find all parents in previous columns
            for (const auto& pair : adjacencyList)
            {
                for (juce::uint32 dest : pair.second)
                {
                    if (dest == nodeId)
                    {
                        // Find the vertical index of the parent node
                        int parentColumn = nodeColumn[pair.first];
                        auto& parentColVec = columns[parentColumn];
                        auto it = std::find(parentColVec.begin(), parentColVec.end(), pair.first);
                        if (it != parentColVec.end())
                        {
                            parentPositions.push_back((float)std::distance(parentColVec.begin(), it));
                        }
                    }
                }
            }
            
            if (!parentPositions.empty())
            {
                std::sort(parentPositions.begin(), parentPositions.end());
                medianPositions[nodeId] = parentPositions[parentPositions.size() / 2];
            }
            else
            {
                medianPositions[nodeId] = 0.0f;
            }
        }
        
        // Sort the column based on median positions
        std::sort(columns[c].begin(), columns[c].end(), [&](juce::uint32 a, juce::uint32 b) {
            return medianPositions[a] < medianPositions[b];
        });
    }

    // --- STEP 4: Calculate Final Coordinates ---
    const float COLUMN_WIDTH = 400.0f;
    const float NODE_VERTICAL_PADDING = 50.0f;

    // Find the tallest column to center shorter ones
    float tallestColumnHeight = 0.0f;
    for (const auto& col : columns)
    {
        float height = 0.0f;
        for (juce::uint32 lid : col)
        {
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            height += nodeSize.y + NODE_VERTICAL_PADDING;
        }
        tallestColumnHeight = std::max(tallestColumnHeight, height);
    }

    // --- STEP 5: Apply Positions ---
    for (int c = 0; c <= maxColumn; ++c)
    {
        // Calculate column height for centering
        float columnHeight = 0.0f;
        for (juce::uint32 lid : columns[c])
        {
            columnHeight += ImNodes::GetNodeDimensions((int)lid).y + NODE_VERTICAL_PADDING;
        }
        
        // Start Y position (centered vertically)
        float currentY = (tallestColumnHeight - columnHeight) / 2.0f;

        for (juce::uint32 lid : columns[c])
        {
            float x = c * COLUMN_WIDTH;
            pendingNodePositions[(int)lid] = ImVec2(x, currentY);
            
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            currentY += nodeSize.y + NODE_VERTICAL_PADDING;
        }
    }

    // Position the output node to the right of all other modules
    float finalX = (maxColumn + 1) * COLUMN_WIDTH;
    float outputNodeY = (tallestColumnHeight - ImNodes::GetNodeDimensions(0).y) / 2.0f;
    pendingNodePositions[0] = ImVec2(finalX, outputNodeY);
    juce::Logger::writeToLog("[Beautify] Applied position to Output Node");
    
    juce::Logger::writeToLog("[Beautify] Applied positions to " + juce::String(modules.size()) + " nodes");
    juce::Logger::writeToLog("--- [Beautify Layout] Complete ---");
}
void ImGuiNodeEditorComponent::handleConnectSelectedToTrackMixer()
{
    if (synth == nullptr || ImNodes::NumSelectedNodes() <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: No synth or no nodes selected.");
        return;
    }

    // This is a significant action, so create an undo state first.
    pushSnapshot();
    juce::Logger::writeToLog("--- [Connect to Mixer] Starting routine ---");

    // 1. Get all selected node IDs.
    const int numSelectedNodes = ImNodes::NumSelectedNodes();
    std::vector<int> selectedNodeLids(numSelectedNodes);
    ImNodes::GetSelectedNodes(selectedNodeLids.data());

    // 2. Find the geometric center of the selected nodes to position our new modules.
    float totalX = 0.0f, maxX = 0.0f, totalY = 0.0f;
    for (int lid : selectedNodeLids)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(lid);
        totalX += pos.x;
        totalY += pos.y;
        if (pos.x > maxX) {
            maxX = pos.x;
        }
    }
    ImVec2 centerPos = ImVec2(totalX / numSelectedNodes, totalY / numSelectedNodes);
    
    // 3. Create the Value node and set its value to the number of selected nodes.
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    if (auto* valueProc = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(valueProc->getAPVTS().getParameter("value")))
        {
            *p = (float)numSelectedNodes;
            juce::Logger::writeToLog("[AutoConnect] Created Value node " + juce::String(valueLid) + " and set its value to " + juce::String(numSelectedNodes));
        }
    }
    // Position it slightly to the right of the center of the selection.
    pendingNodePositions[(int)valueLid] = ImVec2(centerPos.x + 400.0f, centerPos.y);

    // 4. Create the Track Mixer node.
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    // Position it to the right of the right-most selected node for a clean signal flow.
    pendingNodePositions[(int)mixerLid] = ImVec2(maxX + 800.0f, centerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 5. Connect the Value node to the Track Mixer's "Num Tracks Mod" input.
    // The Value module's "Raw" output is channel 0 (provides the exact value entered by the user).
    // The Track Mixer's "Num Tracks Mod" is on Bus 1, Channel 0, which is absolute channel 64.
    synth->connect(valueNodeId, 0, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected Value node 'Raw' output to Track Mixer's Num Tracks Mod input.");

    // 6. Connect the primary audio output of each selected node to a unique input on the Track Mixer.
    int mixerInputChannel = 0;
    for (int lid : selectedNodeLids)
    {
        if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;

        auto sourceNodeId = synth->getNodeIdForLogical((juce::uint32)lid);
        
        // We will connect the first audio output (channel 0) of the source to the next available mixer input.
        synth->connect(sourceNodeId, 0, mixerNodeId, mixerInputChannel);
        juce::Logger::writeToLog("[AutoConnect] Connected node " + juce::String(lid) + " (Out 0) to Track Mixer (In " + juce::String(mixerInputChannel + 1) + ")");
        
        mixerInputChannel++;
    }

    // 7. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [Connect to Mixer] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: MIDI Player not ready.");
        return;
    }

    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);

    // --- FIX: Create and position the Track Mixer first ---
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 1200.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // --- FIX: Connect MIDI Player "Num Tracks" output to Track Mixer "Num Tracks Mod" input ---
    // This ensures the Track Mixer automatically adjusts its track count based on the MIDI file content
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected MIDI Player Num Tracks to Track Mixer Num Tracks Mod");

    // 2. Create and connect a Sample Loader for each active MIDI track.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnect] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks.");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= MIDIPlayerModuleProcessor::kMaxTracks) break;

        // A. Create and position the new modules.
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y + (i * 350.0f));

        auto mapRangeNodeId = synth->addModule("map_range");
        auto mapRangeLid = synth->getLogicalIdForNode(mapRangeNodeId);
        pendingNodePositions[(int)mapRangeLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y + (i * 350.0f));
        
        // B. Configure the MapRange module for Pitch CV conversion.
        if (auto* mapRangeProc = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(mapRangeLid)))
        {
            auto& ap = mapRangeProc->getAPVTS();
            // MIDI Player Pitch Out (0..1) -> Sample Loader Pitch Mod (-24..+24 semitones)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = 0.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = 1.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = -24.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = 24.0f;
        }

        // C. Connect the outputs for this track.
        const int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        const int gateChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 1;
        const int trigChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 3;

        // Pitch: MIDI Player -> MapRange -> Sample Loader
        synth->connect(midiPlayerNodeId, pitchChan, mapRangeNodeId, 0); // Pitch Out -> MapRange In
        synth->connect(mapRangeNodeId, 1, samplerNodeId, 0);             // MapRange Raw Out -> SampleLoader Pitch Mod In

        // Gate: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, gateChan, samplerNodeId, 2);    // Gate Out -> SampleLoader Gate Mod In

        // Trigger: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, trigChan, samplerNodeId, 3);    // Trigger Out -> SampleLoader Trigger Mod In

        // --- FIX: Connect the Sample Loader's audio output to the Track Mixer ---
        // The Sample Loader's main audio output is channel 0.
        // The Track Mixer's inputs are mono channels 0, 1, 2...
        synth->connect(samplerNodeId, 0, mixerNodeId, i);
    }

    // --- FIX: Connect the mixer to the main output so you can hear it! ---
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R

    // 3. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnectVCO] Aborted: MIDI Player not ready.");
        return;
    }
    
    juce::Logger::writeToLog("--- [AutoConnectVCO] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear all existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);
    
    // 2. Create and position the PolyVCO and Track Mixer.
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created PolyVCO with logical ID " + juce::String(polyVcoLid));

    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 3. Connect the track count outputs to control both new modules.
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, polyVcoNodeId, 0); // Raw Num Tracks -> PolyVCO Num Voices Mod
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS); // Raw Num Tracks -> Mixer Num Tracks Mod
    juce::Logger::writeToLog("[AutoConnectVCO] Connected MIDI Player raw track counts to PolyVCO and Track Mixer modulation inputs.");
    
    // 4. Loop through active MIDI tracks to connect CV routes and audio.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnectVCO] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks. Patching voices...");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= PolyVCOModuleProcessor::MAX_VOICES) break; // Don't try to connect more voices than the PolyVCO has

        int sourceTrackIndex = activeTrackIndices[i];

        // A. Connect CV modulation routes from MIDI Player to the corresponding PolyVCO voice.
        int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        int velChan   = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 2;
        
        // Connect MIDI CV to the corresponding PolyVCO voice inputs
        synth->connect(midiPlayerNodeId, pitchChan, polyVcoNodeId, 1 + i); // Pitch -> Freq Mod
        synth->connect(midiPlayerNodeId, velChan,   polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Velocity -> Gate Mod

        // B. Connect the PolyVCO voice's audio output to the Track Mixer's input.
        synth->connect(polyVcoNodeId, i, mixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, mixerNodeId, i * 2 + 1);
    }
    
    // 5. Connect the Track Mixer to the main audio output.
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R
    
    // 6. Flag the graph for a rebuild.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnectVCO] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer) return;

    pushSnapshot();

    const int numTracks = midiPlayer->getNumTracks();
    if (numTracks == 0) return;

    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);

    // --- THIS IS THE NEW "FIND-BY-TRACING" LOGIC ---

    juce::uint32 polyVcoLid = 0;
    juce::uint32 trackMixerLid = 0;

    // 1. Scan existing connections to find modules to reuse by tracing backwards.
    // First, find a TrackMixer connected to the output.
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("track_mixer"))
        {
            trackMixerLid = conn.srcLogicalId; // Found a TrackMixer to reuse!
            break;
        }
    }
    // If we found a TrackMixer, now find a PolyVCO connected to it.
    if (trackMixerLid != 0)
    {
        for (const auto& conn : synth->getConnectionsInfo())
        {
            if (conn.dstLogicalId == trackMixerLid && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("polyvco"))
            {
                polyVcoLid = conn.srcLogicalId; // Found a PolyVCO to reuse!
                break;
            }
        }
    }

    // 2. Clear all old Pitch/Gate/Velocity connections from the MIDI Player.
    std::vector<ModularSynthProcessor::ConnectionInfo> oldConnections;
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.srcLogicalId == midiPlayerLid && conn.srcChan < 16 * 3)
            oldConnections.push_back(conn);
    }
    for (const auto& conn : oldConnections)
    {
        synth->disconnect(synth->getNodeIdForLogical(conn.srcLogicalId), conn.srcChan,
                          synth->getNodeIdForLogical(conn.dstLogicalId), conn.dstChan);
    }

    // 3. If we didn't find a PolyVCO to reuse after tracing, create a new one.
    if (polyVcoLid == 0)
    {
        auto polyVcoNodeId = synth->addModule("polyvco", false);
        polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
        pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPos.x + 400.0f, midiPos.y);
    }

    // 4. If we didn't find a TrackMixer to reuse after tracing, create a new one.
    if (trackMixerLid == 0)
    {
        auto trackMixerNodeId = synth->addModule("track_mixer", false);
        trackMixerLid = synth->getLogicalIdForNode(trackMixerNodeId);
        pendingNodePositions[(int)trackMixerLid] = ImVec2(midiPos.x + 800.0f, midiPos.y);
    }
    // --- END OF NEW LOGIC ---

    auto polyVcoNodeId = synth->getNodeIdForLogical(polyVcoLid);
    auto trackMixerNodeId = synth->getNodeIdForLogical(trackMixerLid);

    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numTracks;
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(trackMixerLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numTracks;

    int voicesToConnect = std::min({numTracks, PolyVCOModuleProcessor::MAX_VOICES, 64});
    for (int i = 0; i < voicesToConnect; ++i)
    {
        synth->connect(midiPlayerNodeId, i, polyVcoNodeId, 1 + i);
        synth->connect(midiPlayerNodeId, i + 16, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2 + 1);
    }
    
    synth->connect(trackMixerNodeId, 0, synth->getOutputNodeID(), 0);
    synth->connect(trackMixerNodeId, 1, synth->getOutputNodeID(), 1);

    synth->commitChanges();
}

void ImGuiNodeEditorComponent::handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid)
{
    if (!synth || !strokeSeq) return;

    juce::Logger::writeToLog("ðŸ¥ BUILD DRUM KIT handler called! Creating modules...");

    // 1. Get Stroke Sequencer position
    auto seqNodeId = synth->getNodeIdForLogical(strokeSeqLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)strokeSeqLid);

    // 2. Create 3 Sample Loaders (for Floor, Mid, Ceiling triggers)
    auto sampler1NodeId = synth->addModule("sample_loader");
    auto sampler2NodeId = synth->addModule("sample_loader");
    auto sampler3NodeId = synth->addModule("sample_loader");
    
    auto sampler1Lid = synth->getLogicalIdForNode(sampler1NodeId);
    auto sampler2Lid = synth->getLogicalIdForNode(sampler2NodeId);
    auto sampler3Lid = synth->getLogicalIdForNode(sampler3NodeId);
    
    // Position samplers in a vertical stack to the right
    pendingNodePositions[(int)sampler1Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    pendingNodePositions[(int)sampler2Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 220.0f);
    pendingNodePositions[(int)sampler3Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 440.0f);

    // 3. Create Track Mixer (will be set to 6 tracks by Value node)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 200.0f);

    // 4. Create Value node set to 6.0 (for 3 stereo tracks = 6 channels)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(seqPos.x + 600.0f, seqPos.y + 550.0f);
    
    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = 6.0f;
    }

    // 5. Connect Stroke Sequencer TRIGGERS to Sample Loader TRIGGER MOD inputs (channel 3)
    synth->connect(seqNodeId, 0, sampler1NodeId, 3); // Floor Trig   -> Sampler 1 Trigger Mod
    synth->connect(seqNodeId, 1, sampler2NodeId, 3); // Mid Trig     -> Sampler 2 Trigger Mod
    synth->connect(seqNodeId, 2, sampler3NodeId, 3); // Ceiling Trig -> Sampler 3 Trigger Mod

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    // Sampler 1 (L+R) -> Mixer Audio 1+2
    synth->connect(sampler1NodeId, 0, mixerNodeId, 0); // Sampler 1 L -> Mixer Audio 1
    synth->connect(sampler1NodeId, 1, mixerNodeId, 1); // Sampler 1 R -> Mixer Audio 2
    
    // Sampler 2 (L+R) -> Mixer Audio 3+4
    synth->connect(sampler2NodeId, 0, mixerNodeId, 2); // Sampler 2 L -> Mixer Audio 3
    synth->connect(sampler2NodeId, 1, mixerNodeId, 3); // Sampler 2 R -> Mixer Audio 4
    
    // Sampler 3 (L+R) -> Mixer Audio 5+6
    synth->connect(sampler3NodeId, 0, mixerNodeId, 4); // Sampler 3 L -> Mixer Audio 5
    synth->connect(sampler3NodeId, 1, mixerNodeId, 5); // Sampler 3 R -> Mixer Audio 6

    // 7. Connect Value node (6.0) to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value (6) -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid)
{
    if (!synth || !animModule) return;

    // Query the dynamic output pins to determine how many bones are tracked
    auto dynamicPins = animModule->getDynamicOutputPins();
    
    // Each bone has 3 outputs: Vel X, Vel Y, Hit
    // So number of bones = number of pins / 3
    int numTrackedBones = (int)dynamicPins.size() / 3;
    
    if (numTrackedBones == 0)
    {
        juce::Logger::writeToLog("ðŸ¦¶ BUILD TRIGGERS AUDIO: No tracked bones! Add bones first.");
        return;
    }

    juce::Logger::writeToLog("ðŸ¦¶ BUILD TRIGGERS AUDIO handler called! Creating modules for " + 
                             juce::String(numTrackedBones) + " tracked bones...");

    // 1. Get Animation Module position
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    ImVec2 animPos = ImNodes::GetNodeGridSpacePos((int)animModuleLid);

    // 2. Create one Sample Loader per tracked bone
    std::vector<juce::AudioProcessorGraph::NodeID> samplerNodeIds;
    std::vector<juce::uint32> samplerLids;
    
    for (int i = 0; i < numTrackedBones; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        samplerNodeIds.push_back(samplerNodeId);
        samplerLids.push_back(synth->getLogicalIdForNode(samplerNodeId));
        
        // Position samplers in a vertical stack to the right
        pendingNodePositions[(int)samplerLids[i]] = ImVec2(animPos.x + 400.0f, animPos.y + i * 220.0f);
    }

    // 3. Create Track Mixer (num_bones * 2 for stereo pairs)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(animPos.x + 800.0f, animPos.y + (numTrackedBones * 110.0f));

    // 4. Create Value node for mixer track count
    int numMixerTracks = numTrackedBones * 2; // 2 channels per sampler (stereo)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(animPos.x + 600.0f, animPos.y + (numTrackedBones * 220.0f));

    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = (float)numMixerTracks;
    }

    // 5. Connect Animation Module TRIGGERS to Sample Loader TRIGGER MOD inputs
    // Animation Module Output Channels (per bone):
    //   i*3 + 0: Bone Vel X
    //   i*3 + 1: Bone Vel Y
    //   i*3 + 2: Bone Hit (trigger) â† Connect this to sampler
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int triggerChannel = i * 3 + 2; // Every 3rd channel starting at 2 (2, 5, 8, 11, ...)
        synth->connect(animNodeId, triggerChannel, samplerNodeIds[i], 3); // Bone Hit -> Sampler Trigger Mod
    }

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int mixerChannelL = i * 2;       // 0, 2, 4, 6, ...
        int mixerChannelR = i * 2 + 1;   // 1, 3, 5, 7, ...
        
        synth->connect(samplerNodeIds[i], 0, mixerNodeId, mixerChannelL); // Sampler L -> Mixer Audio L
        synth->connect(samplerNodeIds[i], 1, mixerNodeId, mixerChannelR); // Sampler R -> Mixer Audio R
    }

    // 7. Connect Value node to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
    
    juce::Logger::writeToLog("ðŸ¦¶ BUILD TRIGGERS AUDIO complete! " + juce::String(numTrackedBones) + 
                             " samplers + mixer + wiring created.");
}
void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. Create the necessary Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 100.0f);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        *dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")) = numSteps;
    }

    // 3. CREATE a Sample Loader for each step and connect its audio to the mixer
    for (int i = 0; i < numSteps; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(seqPos.x + 400.0f, seqPos.y + (i * 220.0f));

        // Connect this sampler's audio output to the mixer's input
        synth->connect(samplerNodeId, 0 /*Audio Output*/, mixerNodeId, i);
        
        // Connect the Sequencer's CV/Trig for this step directly to the new sampler
        synth->connect(seqNodeId, 7 + i * 3 + 0, samplerNodeId, 0); // Pitch N -> Pitch Mod
        synth->connect(seqNodeId, 1, samplerNodeId, 2); // Main Gate -> Gate Mod
        synth->connect(seqNodeId, 7 + i * 3 + 2, samplerNodeId, 3); // Trig N  -> Trigger Mod
    }
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod

    // 4. Connect the mixer to the main output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. CREATE the PolyVCO and Track Mixer
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numSteps;
    }
    
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numSteps;
    }

    // 3. Connect CV, Audio, and Main Output
    for (int i = 0; i < numSteps; ++i)
    {
        // Connect CV: Sequencer -> PolyVCO
        synth->connect(seqNodeId, 7 + i * 3 + 0, polyVcoNodeId, 1 + i);                                  // Pitch N -> Freq N Mod
        synth->connect(seqNodeId, 1, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Main Gate -> Gate N Mod

        // Connect Audio: PolyVCO -> Mixer
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // Connect Num Steps output (channel 6) to PolyVCO's Num Voices Mod input (channel 0)
    synth->connect(seqNodeId, 6, polyVcoNodeId, 0); // Num Steps -> Num Voices Mod
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod
    
    // Connect Mixer -> Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::openMetaModuleEditor(MetaModuleProcessor* metaModule, juce::uint32 metaLogicalId)
{
    closeMetaModuleEditor();

    if (metaModule == nullptr)
        return;

    auto session = std::make_unique<MetaModuleEditorSession>();
    session->context.reset(ImNodes::CreateContext());
    if (session->context == nullptr)
        return;

    ImNodes::SetCurrentContext(session->context.get());
    ImNodes::StyleColorsDark();
    ImNodesIO& io = ImNodes::GetIO();
    io.LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyAlt;

    session->meta = metaModule;
    session->metaLogicalId = metaLogicalId;
    session->graph = metaModule->getInternalGraph();

    if (session->graph != nullptr)
    {
        auto modules = session->graph->getModulesInfo();
        int index = 0;
        for (const auto& mod : modules)
        {
            const int logicalId = (int)mod.first;
            const int row = index / 5;
            const int col = index % 5;
            session->nodePositions.emplace(logicalId, ImVec2(220.0f * col, 140.0f * row));
            ++index;
        }
    }

    ImNodes::SetCurrentContext(editorContext);
    metaEditorSession = std::move(session);
}

void ImGuiNodeEditorComponent::closeMetaModuleEditor()
{
    if (metaEditorSession)
    {
        if (metaEditorSession->context)
        {
            ImNodes::SetCurrentContext(metaEditorSession->context.get());
            ImNodes::DestroyContext(metaEditorSession->context.release());
        }
        metaEditorSession.reset();
    }
    if (editorContext != nullptr)
        ImNodes::SetCurrentContext(editorContext);
}

void ImGuiNodeEditorComponent::renderMetaModuleEditor(MetaModuleEditorSession& session)
{
    if (session.context == nullptr || session.meta == nullptr || session.graph == nullptr)
    {
        ImGui::TextUnformatted("Internal graph is unavailable.");
        return;
    }

    ImNodes::SetCurrentContext(session.context.get());

    auto modules = session.graph->getModulesInfo();

    if (session.nodePositions.empty())
    {
        int index = 0;
        for (const auto& mod : modules)
        {
            const int logicalId = (int)mod.first;
            const int row = index / 5;
            const int col = index % 5;
            session.nodePositions.emplace(logicalId, ImVec2(220.0f * col, 140.0f * row));
            ++index;
        }
    }

    ImVec2 canvasSize = ImGui::GetContentRegionAvail();
    canvasSize.x = juce::jmax(canvasSize.x, 640.0f);
    canvasSize.y = juce::jmax(canvasSize.y, 360.0f);

    ImGui::BeginChild("MetaEditorCanvas", canvasSize, true, ImGuiWindowFlags_NoScrollWithMouse);
    ImNodes::BeginNodeEditor();

    const auto& pinDb = getModulePinDatabase();

    auto drawPinsForModule = [&](ModuleProcessor* module, const ModulePinInfo* info)
    {
        std::vector<AudioPin> audioIns;
        std::vector<AudioPin> audioOuts;
        std::vector<ModPin> modIns;

        if (info != nullptr)
        {
            audioIns.assign(info->audioIns.begin(), info->audioIns.end());
            audioOuts.assign(info->audioOuts.begin(), info->audioOuts.end());
            modIns.assign(info->modIns.begin(), info->modIns.end());
        }

        if (module != nullptr)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            auto dynamicOutputs = module->getDynamicOutputPins();

            for (const auto& dyn : dynamicInputs)
                audioIns.emplace_back(dyn.name, dyn.channel, dyn.type);
            for (const auto& dyn : dynamicOutputs)
                audioOuts.emplace_back(dyn.name, dyn.channel, dyn.type);
        }

        for (const auto& pin : audioIns)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = pin.channel;
            pinId.isInput = true;
            pinId.isMod = (pin.type != PinDataType::Audio);

            ImNodes::BeginInputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndInputAttribute();
        }

        for (const auto& pin : modIns)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = (int)pin.paramId.hashCode();
            pinId.isInput = true;
            pinId.isMod = true;

            ImNodes::BeginInputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndInputAttribute();
        }

        for (const auto& pin : audioOuts)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = pin.channel;
            pinId.isInput = false;
            pinId.isMod = (pin.type != PinDataType::Audio);

            ImNodes::BeginOutputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndOutputAttribute();
        }
    };

    for (const auto& mod : modules)
    {
        const int logicalId = (int)mod.first;
        const juce::String type = mod.second;
        ModuleProcessor* module = session.graph->getModuleForLogical(mod.first);

        ImNodes::BeginNode(logicalId);
        ImGui::Text("%s", type.toRawUTF8());

        const ModulePinInfo* info = nullptr;
        auto it = pinDb.find(type);
        if (it != pinDb.end())
            info = &it->second;

        drawPinsForModule(module, info);

        ImNodes::EndNode();

        const auto posIt = session.nodePositions.find(logicalId);
        if (posIt != session.nodePositions.end())
            ImNodes::SetNodeGridSpacePos(logicalId, posIt->second);
    }

    session.linkIdToAttrs.clear();
    const auto connections = session.graph->getConnectionsInfo();
    for (const auto& conn : connections)
    {
        PinID srcPin;
        srcPin.logicalId = conn.srcLogicalId;
        srcPin.channel = conn.srcChan;
        srcPin.isInput = false;
        srcPin.isMod = false;

        PinID dstPin;
        if (conn.dstIsOutput)
        {
            dstPin.logicalId = 0;
        }
        else
        {
            dstPin.logicalId = conn.dstLogicalId;
        }
        dstPin.channel = conn.dstChan;
        dstPin.isInput = true;
        dstPin.isMod = false;

        const int srcAttr = encodePinId(srcPin);
        const int dstAttr = encodePinId(dstPin);

        const int linkId = (int)(((conn.srcLogicalId & 0xFFFF) << 16)
                            ^ ((conn.dstLogicalId & 0xFFFF) << 1)
                            ^ ((conn.srcChan & 0xFF) << 8)
                            ^ (conn.dstChan & 0xFF)
                            ^ (conn.dstIsOutput ? 0x4000 : 0x0));

        session.linkIdToAttrs[linkId] = { srcAttr, dstAttr };
        ImNodes::Link(linkId, srcAttr, dstAttr);
    }

    if (ImGui::BeginPopupContextWindow("MetaNodeEditorContext", ImGuiPopupFlags_MouseButtonRight))
    {
        if (ImGui::MenuItem("Delete Selected"))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                std::vector<int> selected(numSelected);
                ImNodes::GetSelectedNodes(selected.data());
                for (int nodeId : selected)
                {
                    auto node = session.graph->getNodeIdForLogical((juce::uint32)nodeId);
                    if (node.uid != 0)
                        session.graph->removeModule(node);
                }
                session.graph->commitChanges();
                session.meta->refreshCachedLayout();
                session.dirty = true;
                ImNodes::ClearNodeSelection();
            }
        }
        ImGui::EndPopup();
    }

    ImNodes::MiniMap(0.2f);
    ImNodes::EndNodeEditor();

    int startAttr = 0;
    int endAttr = 0;
    if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
    {
        PinID a = decodePinId(startAttr);
        PinID b = decodePinId(endAttr);

        PinID src = a;
        PinID dst = b;
        if (src.isInput && !dst.isInput)
            std::swap(src, dst);

        if (!src.isInput && dst.isInput)
        {
            auto srcNodeId = session.graph->getNodeIdForLogical(src.logicalId);
            juce::AudioProcessorGraph::NodeID dstNodeId;
            if (dst.logicalId == 0)
                dstNodeId = session.graph->getOutputNodeID();
            else
                dstNodeId = session.graph->getNodeIdForLogical(dst.logicalId);

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                if (session.graph->connect(srcNodeId, src.channel, dstNodeId, dst.channel))
                {
                    session.graph->commitChanges();
                    session.meta->refreshCachedLayout();
                    session.dirty = true;
                }
            }
        }
    }

    int destroyedLink = 0;
    if (ImNodes::IsLinkDestroyed(&destroyedLink))
    {
        auto linkIt = session.linkIdToAttrs.find(destroyedLink);
        if (linkIt != session.linkIdToAttrs.end())
        {
            PinID src = decodePinId(linkIt->second.first);
            PinID dst = decodePinId(linkIt->second.second);

            auto srcNodeId = session.graph->getNodeIdForLogical(src.logicalId);
            juce::AudioProcessorGraph::NodeID dstNodeId;
            if (dst.logicalId == 0)
                dstNodeId = session.graph->getOutputNodeID();
            else
                dstNodeId = session.graph->getNodeIdForLogical(dst.logicalId);

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                if (session.graph->disconnect(srcNodeId, src.channel, dstNodeId, dst.channel))
                {
                    session.graph->commitChanges();
                    session.meta->refreshCachedLayout();
                    session.dirty = true;
                }
            }
        }
    }

    for (const auto& mod : modules)
    {
        const int logicalId = (int)mod.first;
        session.nodePositions[logicalId] = ImNodes::GetNodeGridSpacePos(logicalId);
    }

    ImGui::EndChild();

    char searchBuffer[128];
    std::memset(searchBuffer, 0, sizeof(searchBuffer));
    std::strncpy(searchBuffer, session.moduleSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    if (ImGui::InputTextWithHint("##MetaModuleSearch", "Module type (e.g. vco)", searchBuffer, sizeof(searchBuffer)))
    {
        session.moduleSearchTerm = juce::String(searchBuffer);
    }

    if (ImGui::Button("Create Module"))
    {
        juce::String moduleType = session.moduleSearchTerm.trim();
        if (moduleType.isNotEmpty())
        {
            auto nodeId = session.graph->addModule(moduleType);
            if (nodeId.uid != 0)
            {
                auto logicalId = session.graph->getLogicalIdForNode(nodeId);
                session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
                session.graph->commitChanges();
                session.meta->refreshCachedLayout();
                session.dirty = true;
            }
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Add Inlet"))
    {
        auto nodeId = session.graph->addModule("inlet");
        if (nodeId.uid != 0)
        {
            auto logicalId = session.graph->getLogicalIdForNode(nodeId);
            session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
            session.graph->commitChanges();
            session.meta->refreshCachedLayout();
            session.dirty = true;
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Add Outlet"))
    {
        auto nodeId = session.graph->addModule("outlet");
        if (nodeId.uid != 0)
        {
            auto logicalId = session.graph->getLogicalIdForNode(nodeId);
            session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
            session.graph->commitChanges();
            session.meta->refreshCachedLayout();
            session.dirty = true;
        }
    }

    ImNodes::SetCurrentContext(editorContext);
}
void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info and get number of tracked colors
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count using the new helper method
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create PolyVCO with matching number of voices
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y);
    
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices")))
            *p = numColors;
    }
    
    // 3. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 4. Connect Num Colors output to PolyVCO's NumVoices Mod and TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, polyVcoNodeId, 0); // Num Colors -> NumVoices Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64);  // Num Colors -> Num Tracks Mod
    
    // 5. Connect ColorTracker outputs to PolyVCO inputs
    for (int i = 0; i < numColors; ++i)
    {
        // Map X position to pitch/frequency for voice i
        synth->connect(colorTrackerNodeId, i * 3 + 0, polyVcoNodeId, 1 + i); // X -> Freq Mod
        
        // Map Area to gate level for voice i
        const int gateModChannel = 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i;
        synth->connect(colorTrackerNodeId, i * 3 + 2, polyVcoNodeId, gateModChannel); // Area -> Gate Mod
    }
    
    // 6. Connect PolyVCO audio outputs to Track Mixer inputs
    for (int i = 0; i < numColors; ++i)
    {
        synth->connect(polyVcoNodeId, i, mixerNodeId, i); // Voice i -> Mixer Track i
    }
    
    // 7. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to PolyVCO.");
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y + 100.0f);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 3. Connect Num Colors output to TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64); // Num Colors -> Num Tracks Mod

    // 4. Create a Sample Loader for each tracked color
    for (int i = 0; i < numColors; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y + (i * 220.0f));

        // Connect Sample Loader audio output to mixer
        synth->connect(samplerNodeId, 0, mixerNodeId, i); // Audio -> Mixer Track i
        
        // Connect ColorTracker CV outputs to Sample Loader modulation inputs
        synth->connect(colorTrackerNodeId, i * 3 + 0, samplerNodeId, 0); // X -> Pitch Mod
        synth->connect(colorTrackerNodeId, i * 3 + 2, samplerNodeId, 2); // Area -> Gate Mod
    }
    
    // 5. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to Sample Loaders.");
}

// Add this exact helper function to the class
void ImGuiNodeEditorComponent::parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex)
{
    outIndex = -1; // Default to no index
    outType = fullName;

    if (fullName.contains(" "))
    {
        const juce::String lastWord = fullName.substring(fullName.lastIndexOfChar(' ') + 1);
        if (lastWord.containsOnly("0123456789"))
        {
            outIndex = lastWord.getIntValue();
            outType = fullName.substring(0, fullName.lastIndexOfChar(' '));
        }
    }
}

void ImGuiNodeEditorComponent::updateRerouteTypeFromConnections(juce::uint32 rerouteLogicalId)
{
    if (synth == nullptr)
        return;

    auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(rerouteLogicalId));
    if (reroute == nullptr)
        return;

    std::optional<PinDataType> resolvedType;
    const auto connections = synth->getConnectionsInfo();

    for (const auto& conn : connections)
    {
        if (!conn.dstIsOutput && conn.dstLogicalId == rerouteLogicalId)
        {
            PinID srcPin { conn.srcLogicalId, conn.srcChan, false, false, {} };
            resolvedType = getPinDataTypeForPin(srcPin);
            break;
        }
    }

    if (!resolvedType.has_value())
    {
        for (const auto& conn : connections)
        {
            if (conn.srcLogicalId == rerouteLogicalId && !conn.dstIsOutput)
            {
                PinID dstPin { conn.dstLogicalId, conn.dstChan, true, false, {} };
                resolvedType = getPinDataTypeForPin(dstPin);
                break;
            }
        }
    }

    if (resolvedType.has_value())
        reroute->setPassthroughType(*resolvedType);
    else
        reroute->setPassthroughType(PinDataType::Audio);
}

// Helper functions to get pins from modules
std::vector<AudioPin> ImGuiNodeEditorComponent::getOutputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioOuts;
    return {};
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getInputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioIns;
    return {};
}

AudioPin* ImGuiNodeEditorComponent::findInputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getInputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

AudioPin* ImGuiNodeEditorComponent::findOutputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getOutputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::findNodesOfType(const juce::String& moduleType)
{
    std::vector<juce::uint32> result;
    if (!synth) return result;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleTypeForLogical(modInfo.first) == moduleType)
        {
            result.push_back(modInfo.first);
        }
    }
    return result;
}

// New dynamic pin-fetching helper
std::vector<PinInfo> ImGuiNodeEditorComponent::getDynamicOutputPins(ModuleProcessor* module)
{
    std::vector<PinInfo> pins;
    if (!module) return pins;

    const int numOutputChannels = module->getBus(false, 0)->getNumberOfChannels();
    for (int i = 0; i < numOutputChannels; ++i)
    {
        juce::String pinName = module->getAudioOutputLabel(i);
        if (pinName.isNotEmpty())
        {
            pins.push_back({(uint32_t)i, pinName}); // Store the full pin name in the type field
        }
    }
    return pins;
}
// Template function implementations
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToMonophonicTargets(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping,
    const std::vector<juce::uint32>& targetLids)
{
    if (!synth || !sourceNode || targetLids.empty()) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToMonophonicTargets called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    // Use provided target logical IDs explicitly
    auto targetNodes = targetLids;

    int currentTargetIndex = 0;

    // First, group all of the source node's output pins by their index number.
    // For example, "Pitch 1" and "Trig 1" will both be in the group for index 1.
    std::map<int, std::vector<PinInfo>> pinsByIndex;
    
    // THE FIX: Get pins directly from the module instance.
    auto outputPins = getDynamicOutputPins(sourceNode);
    
    for (const auto& pin : outputPins)
    {
        juce::String type;
        int index = -1;
        parsePinName(pin.type, type, index); // Use pin.type instead of pin.name
        if (index != -1) {
            // Store channel ID as the pin's ID
            pinsByIndex[index].push_back({(uint32_t)pin.id, type}); 
        }
    }

    // Now, loop through each group of pins (each voice).
    for (auto const& [index, pinsInGroup] : pinsByIndex)
    {
        if (currentTargetIndex >= (int)targetNodes.size()) break; // Stop if we run out of targets
        auto targetNodeId = targetNodes[currentTargetIndex];

        // For each pin in the group (e.g., for "Pitch 1" and "Trig 1")...
        for (const auto& pinInfo : pinsInGroup)
        {
            // Check if we have a connection rule for this pin type (e.g., "Pitch").
            if (pinNameMapping.count(pinInfo.type))
            {
                juce::String targetPinName = pinNameMapping.at(pinInfo.type);
                auto* targetPin = findInputPin("sample_loader", targetPinName);

                // If the target pin exists, create the connection.
                if (targetPin)
                {
                    juce::uint32 sourceLogicalId = 0;
                    for (const auto& modInfo : synth->getModulesInfo())
                    {
                        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
                        {
                            sourceLogicalId = modInfo.first;
                            break;
                        }
                    }
                    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);
                    synth->connect(sourceNodeId, pinInfo.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
                }
            }
        }
        // IMPORTANT: Move to the next target module for the next voice.
        currentTargetIndex++;
    }
}
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToPolyphonicTarget(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping)
{
    if (!synth || !sourceNode) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToPolyphonicTarget called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    juce::uint32 sourceLogicalId = 0;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            sourceLogicalId = modInfo.first;
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    auto targetNodes = findNodesOfType("polyvco");
    if (targetNodes.empty()) return;
    auto targetNodeId = targetNodes[0]; // Use the first available PolyVCO

    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);

    // THE FIX: Get pins directly from the module instance, not the database.
    auto outputPins = getDynamicOutputPins(sourceNode);

    // Loop through every output pin on the source module.
    for (const auto& sourcePin : outputPins)
    {
        // Parse the source pin's name to get its type and index.
        juce::String sourceType;
        int sourceIndex = -1;
        parsePinName(sourcePin.type, sourceType, sourceIndex); // Use pin.type instead of pin.name

        if (sourceIndex == -1) continue; // Skip pins that aren't numbered.

        // Check if we have a rule for this pin type (e.g., "Pitch" maps to "Freq").
        if (pinNameMapping.count(sourceType))
        {
            juce::String targetType = pinNameMapping.at(sourceType);
            // PolyVCO inputs use the format "Freq 1 Mod", "Gate 1 Mod", etc.
            juce::String targetPinName = targetType + " " + juce::String(sourceIndex) + " Mod";

            // Find that pin on the target and connect it if available.
            auto* targetPin = findInputPin("polyvco", targetPinName);
            if (targetPin)
            {
                synth->connect(sourceNodeId, sourcePin.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleAutoConnectionRequests()
{
    if (!synth) return;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* module = synth->getModuleForLogical(modInfo.first);
        if (!module) continue;

        // --- Check MultiSequencer Flags ---
        if (auto* multiSeq = dynamic_cast<MultiSequencerModuleProcessor*>(module))
        {
            if (multiSeq->autoConnectSamplersTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectSamplers(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
            if (multiSeq->autoConnectVCOTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectVCO(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
        }
        
        // --- Check ColorTracker Flags ---
        if (auto* colorTracker = dynamic_cast<ColorTrackerModule*>(module))
        {
            if (colorTracker->autoConnectPolyVCOTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectPolyVCO(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
            if (colorTracker->autoConnectSamplersTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectSamplers(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check StrokeSequencer Flags ---
        if (auto* strokeSeq = dynamic_cast<StrokeSequencerModuleProcessor*>(module))
        {
            if (strokeSeq->autoBuildDrumKitTriggered.exchange(false))
            {
                handleStrokeSeqBuildDrumKit(strokeSeq, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check AnimationModule Flags ---
        if (auto* animModule = dynamic_cast<AnimationModuleProcessor*>(module))
        {
            if (animModule->autoBuildTriggersAudioTriggered.exchange(false))
            {
                handleAnimationBuildTriggersAudio(animModule, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check MIDIPlayer Flags ---
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(module))
        {
            if (midiPlayer->autoConnectTriggered.exchange(false)) // Samplers
            {
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType)
{
    if (!synth || !midiPlayer) return;
    
    juce::Logger::writeToLog("[MIDI Player Quick Connect] Request type: " + juce::String(requestType));
    
    // Get ALL tracks (don't filter by whether they have notes)
    const auto& notesByTrack = midiPlayer->getNotesByTrack();
    int numTracks = (int)notesByTrack.size();
    
    if (numTracks == 0)
    {
        juce::Logger::writeToLog("[MIDI Player Quick Connect] No tracks in MIDI file");
        return;
    }
    
    // Get MIDI Player position for positioning new nodes
    ImVec2 playerPos = ImNodes::GetNodeEditorSpacePos(static_cast<int>(midiPlayerLid));
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    
    // Request Type: 1=PolyVCO, 2=Samplers, 3=Both
    juce::uint32 polyVCOLid = 0;
    juce::uint32 mixerLid = 0;
    
    if (requestType == 1 || requestType == 3) // PolyVCO or Both
    {
        // 1. Create PolyVCO
        auto polyVCONodeId = synth->addModule("polyvco");
        polyVCOLid = synth->getLogicalIdForNode(polyVCONodeId);
        pendingNodeScreenPositions[(int)polyVCOLid] = ImVec2(playerPos.x + 400.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created PolyVCO at LID " + juce::String((int)polyVCOLid));
        
        // 2. Create Track Mixer
        auto mixerNodeId = synth->addModule("track_mixer");
        mixerLid = synth->getLogicalIdForNode(mixerNodeId);
        pendingNodeScreenPositions[(int)mixerLid] = ImVec2(playerPos.x + 700.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        
        // 3. Connect MIDI Player tracks to PolyVCO
        // Connect ALL tracks, regardless of whether they have notes
        int trackIdx = 0;
        for (size_t i = 0; i < notesByTrack.size() && trackIdx < 32; ++i)
        {
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiVeloPin = trackIdx * 4 + 2;
            
            const int vcoFreqPin = trackIdx + 1;
            const int vcoWavePin = 32 + trackIdx + 1;
            const int vcoGatePin = 64 + trackIdx + 1;
            
            synth->connect(midiPlayerNodeId, midiPitchPin, polyVCONodeId, vcoFreqPin);
            synth->connect(midiPlayerNodeId, midiGatePin, polyVCONodeId, vcoGatePin);
            synth->connect(midiPlayerNodeId, midiVeloPin, polyVCONodeId, vcoWavePin);
            trackIdx++;
        }
        
        // 4. Connect Num Tracks to PolyVCO (Num Voices Mod on channel 0)
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       polyVCONodeId, 0);
        
        // 5. Connect PolyVCO outputs to Track Mixer inputs
        for (int i = 0; i < trackIdx; ++i)
        {
            synth->connect(polyVCONodeId, i, mixerNodeId, i);
        }
        
        // 6. Connect Num Tracks output to mixer's Num Tracks Mod input
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
        
        // 7. Connect Track Mixer to main output
        auto outputNodeId = synth->getOutputNodeID();
        synth->connect(mixerNodeId, 0, outputNodeId, 0); // L
        synth->connect(mixerNodeId, 1, outputNodeId, 1); // R
        
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                " tracks: MIDI Player â†’ PolyVCO â†’ Track Mixer â†’ Output");
    }
    if (requestType == 2 || requestType == 3) // Samplers or Both
    {
        float samplerX = playerPos.x + 400.0f;
        float mixerX = playerPos.x + 700.0f;
        
        // If PolyVCO mode (Both), offset samplers and use same mixer
        if (requestType == 3)
        {
            samplerX += 300.0f; // Offset samplers if PolyVCO exists
            // Reuse existing mixer created in PolyVCO section
        }
        else
        {
            // 1. Create Track Mixer for Samplers-only mode
            auto mixerNodeId = synth->addModule("track_mixer");
            mixerLid = synth->getLogicalIdForNode(mixerNodeId);
            pendingNodeScreenPositions[(int)mixerLid] = ImVec2(mixerX, playerPos.y);
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        }
        
        // 2. Create samplers and connect
        // Connect ALL tracks, regardless of whether they have notes
        auto mixerNodeId = synth->getNodeIdForLogical(mixerLid);
        int trackIdx = 0;
        int totalTracks = (int)notesByTrack.size();
        int mixerStartChannel = (requestType == 3) ? totalTracks : 0; // Offset for "Both" mode
        
        for (size_t i = 0; i < notesByTrack.size(); ++i)
        {
            // Create SampleLoader
            float samplerY = playerPos.y + (trackIdx * 150.0f);
            auto samplerNodeId = synth->addModule("sample_loader");
            juce::uint32 samplerLid = synth->getLogicalIdForNode(samplerNodeId);
            pendingNodeScreenPositions[(int)samplerLid] = ImVec2(samplerX, samplerY);
            
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiTrigPin = trackIdx * 4 + 3;
            
            // Connect MIDI Player to Sampler
            synth->connect(midiPlayerNodeId, midiPitchPin, samplerNodeId, 0);
            synth->connect(midiPlayerNodeId, midiGatePin, samplerNodeId, 2);
            synth->connect(midiPlayerNodeId, midiTrigPin, samplerNodeId, 3);
            
            // Connect Sampler output to Track Mixer input
            synth->connect(samplerNodeId, 0, mixerNodeId, mixerStartChannel + trackIdx);
            
            trackIdx++;
        }
        
        // 3. Connect Num Tracks to mixer and route to output (only if not already done in PolyVCO mode)
        if (requestType != 3)
        {
            synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                           mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
            
            // 4. Connect Track Mixer to output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(mixerNodeId, 0, outputNodeId, 0);
            synth->connect(mixerNodeId, 1, outputNodeId, 1);
            
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Complete chain: " + juce::String(trackIdx) + 
                                    " SampleLoaders â†’ Track Mixer (with Num Tracks) â†’ Stereo Output");
        }
        else
        {
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                    " SampleLoaders â†’ Track Mixer (channels " + juce::String(mixerStartChannel) + 
                                    "-" + juce::String(mixerStartChannel + trackIdx - 1) + 
                                    ") [Mixer already connected in PolyVCO section]");
        }
    }
    
    // Commit changes
    if (synth)
    {
        synth->commitChanges();
        graphNeedsRebuild = true;
    }
    
    pushSnapshot();
}

void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        const int numSelected = ImNodes::NumSelectedLinks();
        const bool isMultiInsert = numSelected > 1;

        // --- Module Insertion on Cables (Organized by Category) ---
        // Map format: {Display Name, Internal Type}
        // Internal types use lowercase with underscores for spaces
        const std::map<const char*, const char*> audioInsertable = {
            // Effects
            {"VCF", "vcf"}, {"Delay", "delay"}, {"Reverb", "reverb"},
            {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
            {"Limiter", "limiter"}, {"Noise Gate", "gate"}, {"Drive", "drive"},
            {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"}, 
            {"8-Band Shaper", "8bandshaper"}, {"Granulator", "granulator"}, 
            {"Harmonic Shaper", "harmonic_shaper"}, {"Time/Pitch Shifter", "timepitch"},
            {"De-Crackle", "de_crackle"},
            // Utilities
            {"VCA", "vca"}, {"Mixer", "mixer"}, {"Attenuverter", "attenuverter"},
            {"Reroute", "reroute"},
            // Modulators
            {"Function Generator", "function_generator"}, {"Shaping Oscillator", "shaping_oscillator"},
            // TTS
            {"Vocal Tract Filter", "vocal_tract_filter"},
            // Analysis
            {"Scope", "scope"}, {"Frequency Graph", "frequency_graph"}
        };
        const std::map<const char*, const char*> modInsertable = {
            // Utilities
            {"Attenuverter", "attenuverter"}, {"Lag Processor", "lag_processor"}, 
            {"Math", "math"}, {"Map Range", "map_range"}, {"Quantizer", "quantizer"},
            {"Rate", "rate"}, {"Comparator", "comparator"}, {"Logic", "logic"},
            {"Reroute", "reroute"},
            {"CV Mixer", "cv_mixer"}, {"PanVol", "panvol"}, {"Sequential Switch", "sequential_switch"},
            // Modulators
            {"S&H", "s_and_h"}, {"Function Generator", "function_generator"},
            // Sequencers
            {"Timeline", "timeline"}
        };
        const std::map<const char*, const char*> videoInsertable = {
            // Computer Vision (Video processing)
            // Passthrough nodes (Video In â†’ Video Out)
            {"Video FX", "video_fx"}, {"Crop Video", "crop_video"},
            {"Reroute", "reroute"},
            {"Movement Detector", "movement_detector"},
            {"Human Detector", "human_detector"}, {"Object Detector", "object_detector"},
            {"Pose Estimator", "pose_estimator"}, {"Hand Tracker", "hand_tracker"},
            {"Face Tracker", "face_tracker"}, {"Color Tracker", "color_tracker"},
            {"Contour Detector", "contour_detector"}, {"Semantic Segmentation", "semantic_segmentation"}
        };
        
        // Determine which list to show based on cable type
        const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
        const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
        const bool isVideoCable = (srcType == PinDataType::Video && dstType == PinDataType::Video);
        const auto& listToShow = isVideoCable ? videoInsertable : (linkToInsertOn.isMod ? modInsertable : audioInsertable);

        if (isMultiInsert)
            ImGui::Text("Insert Node on %d Cables", numSelected);
        else
            ImGui::Text("Insert Node on Cable");

        // --- FIX: Iterate over map pairs instead of simple strings ---
        for (const auto& pair : listToShow)
        {
            // pair.first = display label, pair.second = internal type
            if (ImGui::MenuItem(pair.first))
            {
                if (isMultiInsert)
                {
                    handleInsertNodeOnSelectedLinks(pair.second);
                }
                else
                {
                    insertNodeBetween(pair.second);
                }
                ImGui::CloseCurrentPopup();
            }
        }
        
        // VST Plugins submenu (only for audio cables, not video cables)
        if (!linkToInsertOn.isMod && !isVideoCable)
        {
            ImGui::Separator();
            if (ImGui::BeginMenu("VST"))
            {
                auto& app = PresetCreatorApplication::getApp();
                auto& knownPluginList = app.getKnownPluginList();
                
                for (const auto& desc : knownPluginList.getTypes())
                {
                    if (ImGui::MenuItem(desc.name.toRawUTF8()))
                    {
                        if (isMultiInsert)
                        {
                            handleInsertNodeOnSelectedLinks(desc.name);
                        }
                        else
                        {
                            insertNodeBetween(desc.name);
                        }
                        ImGui::CloseCurrentPopup();
                    }
                    
                    // Show tooltip with plugin info
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
                        ImGui::Text("Version: %s", desc.version.toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
                ImGui::EndMenu();
            }
        }
        
        ImGui::EndPopup();
    }
    else
    {
        // --- FIX: Reset state when popup is closed ---
        // If the popup is not open (i.e., it was closed or the user clicked away),
        // we must reset the state variable. This ensures that the application
        // is no longer "stuck" in the insert-on-link mode and right-click on
        // empty canvas will work again.
        linkToInsertOn.linkId = -1;
    }
}
void ImGuiNodeEditorComponent::drawLinkInspectorTooltip(const LinkInfo& link)
{
    if (synth == nullptr) return;
    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    
    // Get the probe scope processor
    auto* scope = synth->getProbeScopeProcessor();
    if (scope == nullptr) return;

    // Get the statistics from the scope module
    float minVal, maxVal;
    scope->getStatistics(minVal, maxVal);

    // Get the scope buffer for waveform
    const auto& scopeBuffer = scope->getScopeBuffer();

    // Draw the text info
    ImGui::Text("Inspecting: %s", link.pinName.toRawUTF8());
    ImGui::Text("From: %s (ID %d)", link.sourceNodeName.toRawUTF8(), (int)link.srcNodeId);
    ImGui::Text("Pin: %s", link.pinName.toRawUTF8());
    
    ImGui::Separator();
    
    juce::String peakMaxText = juce::String::formatted("Peak Max: %.3f", maxVal);
    juce::String peakMinText = juce::String::formatted("Peak Min: %.3f", minVal);
    ThemeText(peakMaxText.toRawUTF8(), theme.modules.scope_text_max);
    ThemeText(peakMinText.toRawUTF8(), theme.modules.scope_text_min);
    
    float peakToPeak = maxVal - minVal;
    ImGui::Text("P-P: %.3f", peakToPeak);
    
    float dBMax = maxVal > 0.0001f ? 20.0f * std::log10(maxVal) : -100.0f;
    ImGui::Text("Max dBFS: %.1f", dBMax);

    ImGui::Separator();

    // Draw the waveform using ImGui PlotLines
    const int numSamples = scopeBuffer.getNumSamples();
    if (scopeBuffer.getNumChannels() > 0 && numSamples > 0)
    {
        const float* samples = scopeBuffer.getReadPointer(0);
        ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 80.0f);
        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
    }
}
// --- NEW HELPER FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position)
{
    if (synth == nullptr) return;

    PinDataType srcType = getPinDataTypeForPin(linkInfo.srcPin);
    PinDataType dstType = getPinDataTypeForPin(linkInfo.dstPin);

    // 1. Create and Position the New Node
    // Check if this is a VST plugin by checking against known plugins
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // This is a VST plugin - use addVstModule
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        // Regular module - use addModule
        newNodeId = synth->addModule(nodeType);
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    if (!linkInfo.srcPin.isMod)
    {
        if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
            reroute->setPassthroughType(srcType);
    }

    // 2. Get Original Connection Points
    auto originalSrcNodeId = synth->getNodeIdForLogical(linkInfo.srcPin.logicalId);
    auto originalDstNodeId = (linkInfo.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkInfo.dstPin.logicalId);

    // 3. Disconnect the Original Link
    synth->disconnect(originalSrcNodeId, linkInfo.srcPin.channel, originalDstNodeId, linkInfo.dstPin.channel);

    // 4. Configure newly inserted node if necessary (e.g., MapRange)
    int newNodeOutputChannel = 0;
    if (nodeType == "map_range")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(linkInfo.srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    // 5. Reconnect through the New Node
    synth->connect(originalSrcNodeId, linkInfo.srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, linkInfo.dstPin.channel);

    if (getTypeForLogical(newNodeLid).equalsIgnoreCase("reroute"))
        updateRerouteTypeFromConnections((juce::uint32)newNodeLid);
}
void ImGuiNodeEditorComponent::insertNodeOnLinkStereo(const juce::String& nodeType, 
                                                       const LinkInfo& linkLeft, 
                                                       const LinkInfo& linkRight, 
                                                       const ImVec2& position)
{
    if (synth == nullptr) return;

    juce::Logger::writeToLog("[InsertStereo] Inserting stereo node: " + nodeType);
    juce::Logger::writeToLog("[InsertStereo] Left cable: " + juce::String(linkLeft.srcPin.logicalId) + 
                            " ch" + juce::String(linkLeft.srcPin.channel) + " -> " + 
                            juce::String(linkLeft.dstPin.logicalId) + " ch" + juce::String(linkLeft.dstPin.channel));
    juce::Logger::writeToLog("[InsertStereo] Right cable: " + juce::String(linkRight.srcPin.logicalId) + 
                            " ch" + juce::String(linkRight.srcPin.channel) + " -> " + 
                            juce::String(linkRight.dstPin.logicalId) + " ch" + juce::String(linkRight.dstPin.channel));

    // 1. Create ONE node for both channels
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points for LEFT cable (first cable)
    auto leftSrcNodeId = synth->getNodeIdForLogical(linkLeft.srcPin.logicalId);
    auto leftDstNodeId = (linkLeft.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkLeft.dstPin.logicalId);

    // 3. Get Original Connection Points for RIGHT cable (second cable)
    auto rightSrcNodeId = synth->getNodeIdForLogical(linkRight.srcPin.logicalId);
    auto rightDstNodeId = (linkRight.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkRight.dstPin.logicalId);

    // 4. Disconnect BOTH Original Links (using their actual source/dest channels)
    synth->disconnect(leftSrcNodeId, linkLeft.srcPin.channel, leftDstNodeId, linkLeft.dstPin.channel);
    synth->disconnect(rightSrcNodeId, linkRight.srcPin.channel, rightDstNodeId, linkRight.dstPin.channel);

    // 5. Reconnect Through the New Node
    // Left cable -> new node's LEFT input (ch0)
    bool leftInConnected = synth->connect(leftSrcNodeId, linkLeft.srcPin.channel, newNodeId, 0);
    
    // Right cable -> new node's RIGHT input (ch1)
    bool rightInConnected = synth->connect(rightSrcNodeId, linkRight.srcPin.channel, newNodeId, 1);
    
    // New node's outputs -> original destinations
    // Note: We'll connect both outputs to their respective destinations
    bool leftOutConnected = synth->connect(newNodeId, 0, leftDstNodeId, linkLeft.dstPin.channel);
    bool rightOutConnected = synth->connect(newNodeId, 1, rightDstNodeId, linkRight.dstPin.channel);

    if (leftInConnected && rightInConnected && leftOutConnected && rightOutConnected)
    {
        juce::Logger::writeToLog("[InsertStereo] Successfully inserted stereo node: both channels connected");
    }
    else
    {
        juce::Logger::writeToLog("[InsertStereo] WARNING: Some connections failed - leftIn=" + juce::String(leftInConnected ? 1 : 0) +
                                ", rightIn=" + juce::String(rightInConnected ? 1 : 0) +
                                ", leftOut=" + juce::String(leftOutConnected ? 1 : 0) +
                                ", rightOut=" + juce::String(rightOutConnected ? 1 : 0));
    }
}
void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin, bool createUndoSnapshot)
{
    if (synth == nullptr)
        return;

    PinDataType srcType = getPinDataTypeForPin(srcPin);
    PinDataType dstType = getPinDataTypeForPin(dstPin);

    ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(srcPin.logicalId);
    ImVec2 dstPos = ImNodes::GetNodeGridSpacePos(dstPin.logicalId == 0 ? 0 : dstPin.logicalId);
    ImVec2 newNodePos = ImVec2((srcPos.x + dstPos.x) * 0.5f, (srcPos.y + dstPos.y) * 0.5f);

    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;

    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }

    if (! isVst)
        newNodeId = synth->addModule(nodeType);

    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodePositions[(int)newNodeLid] = newNodePos;

    if (!srcPin.isMod)
    {
        if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
            reroute->setPassthroughType(srcType);
    }

    auto originalSrcNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
    auto originalDstNodeId = (dstPin.logicalId == 0)
        ? synth->getOutputNodeID()
        : synth->getNodeIdForLogical(dstPin.logicalId);

    int newNodeOutputChannel = 0;
    if (nodeType == "map_range")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    synth->connect(originalSrcNodeId, srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, dstPin.channel);

    if (getTypeForLogical(newNodeLid).equalsIgnoreCase("reroute"))
        updateRerouteTypeFromConnections((juce::uint32)newNodeLid);

    juce::Logger::writeToLog("[AutoConvert] Inserted '" + nodeType + "' between "
                             + juce::String(srcPin.logicalId) + " and " + juce::String(dstPin.logicalId));

    if (createUndoSnapshot)
    {
        pushSnapshot();
        graphNeedsRebuild = true;
    }
}

void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType)
{
    if (linkToInsertOn.linkId != -1)
    {
        insertNodeOnLink(nodeType, linkToInsertOn, ImGui::GetMousePos());
        graphNeedsRebuild = true;
        pushSnapshot();
        linkToInsertOn.linkId = -1;
    }
}
void ImGuiNodeEditorComponent::handleInsertNodeOnSelectedLinks(const juce::String& nodeType)
{
    if (synth == nullptr || ImNodes::NumSelectedLinks() == 0)
        return;

    pushSnapshot();

    const int numSelectedLinks = ImNodes::NumSelectedLinks();
    std::vector<int> selectedLinkIds(numSelectedLinks);
    ImNodes::GetSelectedLinks(selectedLinkIds.data());

    ImVec2 basePosition = ImGui::GetMousePos();
    float xOffset = 0.0f;

    if (numSelectedLinks == 2)
    {
        auto it0 = linkIdToAttrs.find(selectedLinkIds[0]);
        auto it1 = linkIdToAttrs.find(selectedLinkIds[1]);

        if (it0 != linkIdToAttrs.end() && it1 != linkIdToAttrs.end())
        {
            LinkInfo firstLink;
            firstLink.linkId = selectedLinkIds[0];
            firstLink.srcPin = decodePinId(it0->second.first);
            firstLink.dstPin = decodePinId(it0->second.second);
            firstLink.isMod = firstLink.srcPin.isMod || firstLink.dstPin.isMod;

            LinkInfo secondLink;
            secondLink.linkId = selectedLinkIds[1];
            secondLink.srcPin = decodePinId(it1->second.first);
            secondLink.dstPin = decodePinId(it1->second.second);
            secondLink.isMod = secondLink.srcPin.isMod || secondLink.dstPin.isMod;

            if (!firstLink.isMod && !secondLink.isMod)
            {
                auto isStereoCandidate = [&]() -> bool
                {
                    // Both links must be from the same source node
                    if (firstLink.srcPin.logicalId != secondLink.srcPin.logicalId)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: different source nodes");
                        return false;
                    }

                    // Both links must go to the same destination (or both to main output)
                    const bool bothToMainOutput = (firstLink.dstPin.logicalId == 0 && secondLink.dstPin.logicalId == 0);
                    if (!bothToMainOutput && firstLink.dstPin.logicalId != secondLink.dstPin.logicalId)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: different destination nodes");
                        return false;
                    }

                    // Source channels should be consecutive (0-1, 1-2, etc.) for stereo
                    const int srcDelta = std::abs(firstLink.srcPin.channel - secondLink.srcPin.channel);
                    const int dstDelta = std::abs(firstLink.dstPin.channel - secondLink.dstPin.channel);
                    
                    // For stereo, we expect channels 0 and 1, but allow other consecutive pairs
                    if (srcDelta != 1)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: source channels not consecutive (delta=" + juce::String(srcDelta) + ")");
                        return false;
                    }
                    
                    // Destination channels should also be consecutive
                    if (dstDelta != 1)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: destination channels not consecutive (delta=" + juce::String(dstDelta) + ")");
                        return false;
                    }

                    // All pins must be audio type
                    const auto srcTypeA = getPinDataTypeForPin(firstLink.srcPin);
                    const auto srcTypeB = getPinDataTypeForPin(secondLink.srcPin);
                    const auto dstTypeA = getPinDataTypeForPin(firstLink.dstPin);
                    const auto dstTypeB = getPinDataTypeForPin(secondLink.dstPin);
                    const bool allAudio = srcTypeA == PinDataType::Audio && srcTypeB == PinDataType::Audio
                                          && dstTypeA == PinDataType::Audio && dstTypeB == PinDataType::Audio;
                    
                    if (!allAudio)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: not all audio pins");
                        return false;
                    }

                    juce::Logger::writeToLog("[InsertNode] Detected stereo pair: ch" + juce::String(firstLink.srcPin.channel) + 
                                            " and ch" + juce::String(secondLink.srcPin.channel));
                    return true;
                };

                if (isStereoCandidate())
                {
                    LinkInfo leftLink = firstLink;
                    LinkInfo rightLink = secondLink;
                    
                    // Ensure left link has the lower channel number
                    if (rightLink.srcPin.channel < leftLink.srcPin.channel)
                        std::swap(leftLink, rightLink);

                    juce::Logger::writeToLog("[InsertNode] Inserting STEREO node: left=ch" + juce::String(leftLink.srcPin.channel) + 
                                            ", right=ch" + juce::String(rightLink.srcPin.channel));
                    insertNodeOnLinkStereo(nodeType, leftLink, rightLink, basePosition);
                    juce::Logger::writeToLog("[InsertNode] Successfully inserted STEREO node for 2 selected audio cables");
                    graphNeedsRebuild = true;
                    return;
                }
            }
        }
    }

    std::set<int> processedLinks;

    for (int linkId : selectedLinkIds)
    {
        if (processedLinks.count(linkId) != 0)
            continue;

        auto it = linkIdToAttrs.find(linkId);
        if (it == linkIdToAttrs.end())
            continue;

        LinkInfo link;
        link.linkId = linkId;
        link.srcPin = decodePinId(it->second.first);
        link.dstPin = decodePinId(it->second.second);
        link.isMod = link.srcPin.isMod || link.dstPin.isMod;

        ImVec2 newPosition(basePosition.x + xOffset, basePosition.y);
        insertNodeOnLink(nodeType, link, newPosition);
        processedLinks.insert(linkId);
        juce::Logger::writeToLog("[InsertNode] Inserted MONO node for link " + juce::String(linkId));

        xOffset += 40.0f;
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::expandMetaModule(juce::uint32 metaLogicalId)
{
    if (!synth)
        return;

    const auto metaNodeId = synth->getNodeIdForLogical(metaLogicalId);
    if (metaNodeId.uid == 0)
        return;

    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule == nullptr)
        return;

    const auto metaState = metaModule->getExtraStateTree();
    const juce::String encoded = metaState.getProperty("internalGraphState").toString();
    if (encoded.isEmpty())
    {
        NotificationManager::post(NotificationManager::Type::Warning, "Meta module has no internal patch to expand.");
        return;
    }

    juce::MemoryOutputStream decoded;
    if (!juce::Base64::convertFromBase64(decoded, encoded))
    {
        NotificationManager::post(NotificationManager::Type::Warning, "Failed to decode meta module state.");
        return;
    }

    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(decoded.toString()));
    if (xml == nullptr)
        return;

    juce::ValueTree internalRoot = juce::ValueTree::fromXml(*xml);
    auto modulesVT = internalRoot.getChildWithName("modules");
    auto connsVT = internalRoot.getChildWithName("connections");
    if (!modulesVT.isValid() || !connsVT.isValid())
        return;

    pushSnapshot();

    struct CollapsedInlet { int oldId{}; int pinIndex{}; int channelCount{1}; juce::uint32 externalLogicalId{}; int externalChannel{}; int metaChannel{}; };
    struct CollapsedOutlet { int oldId{}; int pinIndex{}; int channelCount{1}; juce::uint32 externalLogicalId{}; int externalChannel{}; bool externalIsOutput{}; int metaChannel{}; };
    struct InternalConnection { int srcId; int srcChan; int dstId; int dstChan; };
    struct InboundConnection { int inletOldId; int dstId; int dstChan; };
    struct OutboundConnection { int srcId; int srcChan; int outletOldId; };

    std::vector<CollapsedInlet> collapsedInlets;
    std::vector<CollapsedOutlet> collapsedOutlets;
    std::vector<InternalConnection> internalConnections;
    std::vector<InboundConnection> inboundConnections;
    std::vector<OutboundConnection> outboundConnections;
    std::map<int, juce::uint32> oldToNew;
    std::vector<juce::uint32> createdLogicalIds;

    auto readChannelCount = [](const juce::ValueTree& moduleVT, const juce::Identifier& paramId) -> int
    {
        if (auto paramsWrapper = moduleVT.getChildWithName("params"); paramsWrapper.isValid())
        {
            if (paramsWrapper.getNumChildren() > 0)
            {
                auto params = paramsWrapper.getChild(0);
                for (int i = 0; i < params.getNumChildren(); ++i)
                {
                    auto paramNode = params.getChild(i);
                    if (paramNode.getProperty("id").toString().equalsIgnoreCase(paramId.toString()))
                        return (int)paramNode.getProperty("value", 1.0);
                }
            }
        }
        return 1;
    };

    std::unordered_set<int> inletIds;
    std::unordered_set<int> outletIds;

    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleVT = modulesVT.getChild(i);
        if (!moduleVT.hasType("module"))
            continue;

        const int oldId = (int)moduleVT.getProperty("logicalId", 0);
        const juce::String type = moduleVT.getProperty("type").toString();

        auto extraWrapper = moduleVT.getChildWithName("extra");
        auto extraState = (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0) ? extraWrapper.getChild(0) : juce::ValueTree();

        if (type.equalsIgnoreCase("inlet"))
        {
            CollapsedInlet inlet;
            inlet.oldId = oldId;
            inlet.pinIndex = (int)extraState.getProperty("pinIndex", (int)collapsedInlets.size());
            inlet.channelCount = readChannelCount(moduleVT, InletModuleProcessor::paramIdChannelCount);
            inlet.externalLogicalId = (juce::uint32)(int)extraState.getProperty("externalLogicalId", 0);
            inlet.externalChannel = (int)extraState.getProperty("externalChannel", 0);
            collapsedInlets.push_back(inlet);
            inletIds.insert(oldId);
            continue;
        }

        if (type.equalsIgnoreCase("outlet"))
        {
            CollapsedOutlet outlet;
            outlet.oldId = oldId;
            outlet.pinIndex = (int)extraState.getProperty("pinIndex", (int)collapsedOutlets.size());
            outlet.channelCount = readChannelCount(moduleVT, OutletModuleProcessor::paramIdChannelCount);
            outlet.externalLogicalId = (juce::uint32)(int)extraState.getProperty("externalLogicalId", 0);
            outlet.externalChannel = (int)extraState.getProperty("externalChannel", 0);
            outlet.externalIsOutput = (bool)(int)extraState.getProperty("externalIsOutput", outlet.externalLogicalId == 0 ? 1 : 0);
            collapsedOutlets.push_back(outlet);
            outletIds.insert(oldId);
            continue;
        }

        const auto nodeId = synth->addModule(type);
        const juce::uint32 newLogical = synth->getLogicalIdForNode(nodeId);
        oldToNew[oldId] = newLogical;
        createdLogicalIds.push_back(newLogical);

        if (auto* module = synth->getModuleForLogical(newLogical))
        {
            if (auto paramsWrapper = moduleVT.getChildWithName("params"); paramsWrapper.isValid())
                if (paramsWrapper.getNumChildren() > 0)
                    module->getAPVTS().replaceState(paramsWrapper.getChild(0));
            if (extraState.isValid())
                module->setExtraStateTree(extraState);
        }
    }

    for (int i = 0; i < connsVT.getNumChildren(); ++i)
    {
        auto cv = connsVT.getChild(i);
        if (!cv.hasType("connection"))
            continue;

        const int srcId = (int)cv.getProperty("srcId", 0);
        const int dstId = (int)cv.getProperty("dstId", 0);
        const int srcChan = (int)cv.getProperty("srcChan", 0);
        const int dstChan = (int)cv.getProperty("dstChan", 0);

        const bool srcIsInlet = inletIds.count(srcId) > 0;
        const bool dstIsOutlet = outletIds.count(dstId) > 0;

        if (srcIsInlet && !dstIsOutlet)
            inboundConnections.push_back({ srcId, dstId, dstChan });
        else if (!srcIsInlet && dstIsOutlet)
            outboundConnections.push_back({ srcId, srcChan, dstId });
        else if (!srcIsInlet && !dstIsOutlet)
            internalConnections.push_back({ srcId, srcChan, dstId, dstChan });
    }

    std::sort(collapsedInlets.begin(), collapsedInlets.end(), [](const CollapsedInlet& a, const CollapsedInlet& b)
    {
        if (a.pinIndex != b.pinIndex)
            return a.pinIndex < b.pinIndex;
        return a.oldId < b.oldId;
    });

    int runningChannel = 0;
    for (auto& inlet : collapsedInlets)
    {
        inlet.metaChannel = runningChannel;
        runningChannel += inlet.channelCount;
    }

    std::sort(collapsedOutlets.begin(), collapsedOutlets.end(), [](const CollapsedOutlet& a, const CollapsedOutlet& b)
    {
        if (a.pinIndex != b.pinIndex)
            return a.pinIndex < b.pinIndex;
        return a.oldId < b.oldId;
    });

    runningChannel = 0;
    for (auto& outlet : collapsedOutlets)
    {
        outlet.metaChannel = runningChannel;
        runningChannel += outlet.channelCount;
    }

    std::unordered_map<int, std::pair<juce::uint32, int>> metaInputs;
    std::unordered_map<int, std::tuple<juce::uint32, int, bool>> metaOutputs;

    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstLogicalId == metaLogicalId && !c.dstIsOutput)
            metaInputs.emplace(c.dstChan, std::make_pair(c.srcLogicalId, c.srcChan));
        if (c.srcLogicalId == metaLogicalId)
            metaOutputs.emplace(c.srcChan, std::make_tuple(c.dstLogicalId, c.dstChan, c.dstIsOutput));
    }

    for (auto& inlet : collapsedInlets)
    {
        if (inlet.externalLogicalId == 0 && metaInputs.count(inlet.metaChannel) > 0)
        {
            auto external = metaInputs[inlet.metaChannel];
            inlet.externalLogicalId = external.first;
            inlet.externalChannel = external.second;
        }
    }

    for (auto& outlet : collapsedOutlets)
    {
        if (metaOutputs.count(outlet.metaChannel) > 0)
        {
            auto external = metaOutputs[outlet.metaChannel];
            if ((outlet.externalLogicalId == 0 || std::get<0>(external) != 0))
                outlet.externalLogicalId = std::get<0>(external);
            outlet.externalChannel = std::get<1>(external);
            outlet.externalIsOutput = std::get<2>(external) || outlet.externalLogicalId == 0;
        }
    }

    std::unordered_map<int, CollapsedInlet> inletLookup;
    for (const auto& inlet : collapsedInlets)
        inletLookup.emplace(inlet.oldId, inlet);

    std::unordered_map<int, CollapsedOutlet> outletLookup;
    for (const auto& outlet : collapsedOutlets)
        outletLookup.emplace(outlet.oldId, outlet);

    for (const auto& conn : internalConnections)
    {
        auto srcIt = oldToNew.find(conn.srcId);
        auto dstIt = oldToNew.find(conn.dstId);
        if (srcIt == oldToNew.end() || dstIt == oldToNew.end())
            continue;

        auto srcNode = synth->getNodeIdForLogical(srcIt->second);
        auto dstNode = synth->getNodeIdForLogical(dstIt->second);
        if (srcNode.uid == 0 || dstNode.uid == 0)
            continue;

        synth->connect(srcNode, conn.srcChan, dstNode, conn.dstChan);
    }

    for (const auto& inbound : inboundConnections)
    {
        auto inletIt = inletLookup.find(inbound.inletOldId);
        auto dstIt = oldToNew.find(inbound.dstId);
        if (inletIt == inletLookup.end() || dstIt == oldToNew.end())
            continue;

        const auto& inlet = inletIt->second;
        if (inlet.externalLogicalId == 0)
            continue;

        auto srcNode = synth->getNodeIdForLogical(inlet.externalLogicalId);
        auto dstNode = synth->getNodeIdForLogical(dstIt->second);
        if (srcNode.uid == 0 || dstNode.uid == 0)
            continue;

        synth->connect(srcNode, inlet.externalChannel, dstNode, inbound.dstChan);
    }

    for (const auto& outbound : outboundConnections)
    {
        auto outletIt = outletLookup.find(outbound.outletOldId);
        auto srcIt = oldToNew.find(outbound.srcId);
        if (outletIt == outletLookup.end() || srcIt == oldToNew.end())
            continue;

        const auto& outlet = outletIt->second;
        auto srcNode = synth->getNodeIdForLogical(srcIt->second);
        if (srcNode.uid == 0)
            continue;

        juce::AudioProcessorGraph::NodeID dstNode;
        if (outlet.externalIsOutput || outlet.externalLogicalId == 0)
            dstNode = synth->getOutputNodeID();
        else
            dstNode = synth->getNodeIdForLogical(outlet.externalLogicalId);

        if (dstNode.uid == 0)
            continue;

        synth->connect(srcNode, outbound.srcChan, dstNode, outlet.externalChannel);
    }

    const ImVec2 metaPos = ImNodes::GetNodeGridSpacePos((int)metaLogicalId);
    synth->removeModule(metaNodeId);

    const float spacing = 160.0f;
    for (std::size_t idx = 0; idx < createdLogicalIds.size(); ++idx)
    {
        const auto lid = createdLogicalIds[idx];
        const int ix = (int)(idx % 4);
        const int iy = (int)(idx / 4);
        pendingNodePositions[(int)lid] = ImVec2(metaPos.x + ix * spacing, metaPos.y + iy * spacing);
    }

    selectedLogicalId = 0;
    graphNeedsRebuild = true;
    synth->commitChanges();

    NotificationManager::post(NotificationManager::Type::Info, "Expanded Meta Module");
}

juce::File ImGuiNodeEditorComponent::findPresetsDirectory()
{
    // Search upwards from the executable's location for a sibling directory
    // named "Synth_presets". This is robust to different build configurations.
    juce::File dir = juce::File::getSpecialLocation(juce::File::currentExecutableFile);

    for (int i = 0; i < 8; ++i) // Limit search depth to 8 levels
    {
        dir = dir.getParentDirectory();
        if (!dir.exists()) break;

        juce::File candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.isDirectory())
        {
            return candidate;
        }
    }
    
    // Fallback to an empty file (system default) if not found
    return {};
}
// Helper function implementations
PinDataType ImGuiNodeEditorComponent::getPinDataTypeForPin(const PinID& pin)
{
    if (synth == nullptr) return PinDataType::Raw;

    // Handle the main output node as a special case
    if (pin.logicalId == 0)
    {
        return PinDataType::Audio;
    }

    juce::String moduleType = getTypeForLogical(pin.logicalId);
    if (moduleType.isEmpty()) return PinDataType::Raw;

    // *** NEW: Check dynamic pins FIRST ***
    if (auto* module = synth->getModuleForLogical(pin.logicalId))
    {
        // Check dynamic input pins
        if (pin.isInput && !pin.isMod)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            for (const auto& dynPin : dynamicInputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
        // Check dynamic output pins
        else if (!pin.isInput && !pin.isMod)
        {
            auto dynamicOutputs = module->getDynamicOutputPins();
            for (const auto& dynPin : dynamicOutputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
    }
    // *** END NEW CODE ***

    auto it = getModulePinDatabase().find(moduleType);
    if (it == getModulePinDatabase().end())
    {
        // Fallback: case-insensitive lookup (module registry may use different casing)
        juce::String moduleTypeLower = moduleType.toLowerCase();
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0 || kv.first.toLowerCase() == moduleTypeLower)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
        if (it == getModulePinDatabase().end())
        {
            // If the module type is not in our static database, it's likely a VST plugin.
            // A safe assumption is that its pins are for audio.
            if (auto* module = synth->getModuleForLogical(pin.logicalId))
            {
                if (dynamic_cast<VstHostModuleProcessor*>(module))
                {
                    return PinDataType::Audio; // Green for VST pins
                }
            }
            return PinDataType::Raw;
        }
    }

    const auto& pinInfo = it->second;

    if (pin.isMod)
    {
        for (const auto& modPin : pinInfo.modIns)
        {
            if (modPin.paramId == pin.paramId)
            {
                return modPin.type;
            }
        }
    }
    else // It's an audio pin
    {
        const auto& pins = pin.isInput ? pinInfo.audioIns : pinInfo.audioOuts;
        for (const auto& audioPin : pins)
        {
            if (audioPin.channel == pin.channel)
            {
                return audioPin.type;
            }
        }
    }
    return PinDataType::Raw; // Fallback
}

unsigned int ImGuiNodeEditorComponent::getImU32ForType(PinDataType type)
{
	const ImU32 themedColor = ThemeManager::getInstance().getPinColor(type);
	if (themedColor != 0)
		return themedColor;

	switch (type)
	{
		case PinDataType::CV:    return IM_COL32(100, 150, 255, 255); // Blue
		case PinDataType::Audio: return IM_COL32(100, 255, 150, 255); // Green
		case PinDataType::Gate:  return IM_COL32(255, 220, 100, 255); // Yellow
		case PinDataType::Raw:   return IM_COL32(255, 100, 100, 255); // Red
		case PinDataType::Video: return IM_COL32(0, 200, 255, 255);   // Cyan
		default:                 return IM_COL32(150, 150, 150, 255); // Grey
	}
}

const char* ImGuiNodeEditorComponent::pinDataTypeToString(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return "CV (0 to 1)";
        case PinDataType::Audio: return "Audio (-1 to 1)";
        case PinDataType::Gate:  return "Gate/Trigger";
        case PinDataType::Raw:   return "Raw";
        case PinDataType::Video: return "Video Source";
        default:                 return "Unknown";
    }
}
std::vector<AudioPin> ImGuiNodeEditorComponent::getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType)
{
    std::vector<AudioPin> matchingPins;
    juce::String moduleType = getTypeForLogical(logicalId);

    if (moduleType.isEmpty())
    {
        return matchingPins;
    }

    auto it = getModulePinDatabase().find(moduleType);

    // --- CASE-INSENSITIVE LOOKUP ---
    if (it == getModulePinDatabase().end())
    {
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
    }

    if (it != getModulePinDatabase().end())
    {
        // --- Standard path for built-in modules ---
        const auto& pins = isInput ? it->second.audioIns : it->second.audioOuts;
        for (const auto& pin : pins)
        {
            if (pin.type == targetType)
            {
                matchingPins.push_back(pin);
            }
        }
    }

    // If no static pins matched (or none defined), fall back to dynamic pins from the module
    if (matchingPins.empty())
    {
        if (auto* module = synth->getModuleForLogical(logicalId))
        {
            // --- DYNAMIC PATH FOR MODULES WITH getDynamicInputPins/getDynamicOutputPins ---
            auto dynamicPins = isInput ? module->getDynamicInputPins() : module->getDynamicOutputPins();
            
            if (!dynamicPins.empty())
            {
                // Module provides dynamic pins - filter by type
                for (const auto& pin : dynamicPins)
                {
                    if (pin.type == targetType)
                    {
                        matchingPins.emplace_back(pin.name, pin.channel, pin.type);
                    }
                }
            }
            else if (auto* vst = dynamic_cast<VstHostModuleProcessor*>(module))
            {
                // For VSTs without dynamic pins, assume all pins are 'Audio' type for chaining.
                if (targetType == PinDataType::Audio)
                {
                    const int numChannels = isInput ? vst->getTotalNumInputChannels() : vst->getTotalNumOutputChannels();
                    for (int i = 0; i < numChannels; ++i)
                    {
                        juce::String pinName = isInput ? vst->getAudioInputLabel(i) : vst->getAudioOutputLabel(i);
                        if (pinName.isNotEmpty())
                        {
                            matchingPins.emplace_back(pinName, i, PinDataType::Audio);
                        }
                    }
                }
            }
        }
    }

    return matchingPins;
}

void ImGuiNodeEditorComponent::handleNodeChaining()
{
    if (synth == nullptr)
        return;

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
        return;

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    sortedNodes.reserve(selectedNodeIds.size());

    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0)
            continue;
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.emplace_back(pos.x, nodeId);
    }

    if (sortedNodes.size() <= 1)
        return;

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    pushSnapshot();

    for (size_t i = 0; i + 1 < sortedNodes.size(); ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
            continue;

        synth->connect(sourceNodeId, 0, destNodeId, 0);
        synth->connect(sourceNodeId, 1, destNodeId, 1);

        if (auto* destModule = synth->getModuleForLogical(destLid))
        {
            if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
            {
                if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                    recorder->updateSuggestedFilename(sourceModule->getName());
            }
        }
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleRecordOutput()
{
    if (!synth) return;

    pushSnapshot();
    juce::Logger::writeToLog("[Record Output] Initiated.");

    // 1. Find connections going to the main output node.
    std::vector<ModularSynthProcessor::ConnectionInfo> outputFeeds;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstIsOutput)
        {
            outputFeeds.push_back(c);
        }
    }

    if (outputFeeds.empty())
    {
        juce::Logger::writeToLog("[Record Output] No connections to main output found.");
        return;
    }

    // 2. Create and position the recorder.
    auto recorderNodeId = synth->addModule("recorder");
    auto recorderLid = synth->getLogicalIdForNode(recorderNodeId);
    ImVec2 outPos = ImNodes::GetNodeGridSpacePos(0);
    pendingNodePositions[(int)recorderLid] = ImVec2(outPos.x - 400.0f, outPos.y);
    
    auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical(recorderLid));
    if (recorder)
    {
        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
    }

    // 3. "Tap" the signals by connecting the original sources to the recorder.
    juce::String sourceName;
    for (const auto& feed : outputFeeds)
    {
        auto srcNodeId = synth->getNodeIdForLogical(feed.srcLogicalId);
        synth->connect(srcNodeId, feed.srcChan, recorderNodeId, feed.dstChan); // dstChan will be 0 or 1
        
        // Get the name of the first source for the filename prefix
        if (sourceName.isEmpty())
        {
            if (auto* srcModule = synth->getModuleForLogical(feed.srcLogicalId))
            {
                sourceName = srcModule->getName();
            }
        }
    }
    
    if (recorder)
    {
        recorder->updateSuggestedFilename(sourceName);
    }

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[Record Output] Recorder added and connected.");
}
void ImGuiNodeEditorComponent::handleColorCodedChaining(PinDataType targetType)
{
    if (synth == nullptr)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: synth is nullptr");
        return;
    }

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: numSelected <= 1 (" + juce::String(numSelected) + ")");
        return;
    }

    juce::Logger::writeToLog("[Color Chaining] Started for " + juce::String(toString(targetType)) + " with " + juce::String(numSelected) + " nodes");

    // 1. Get and sort selected nodes by their horizontal position.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0) continue; // Exclude the output node.
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    if (sortedNodes.empty())
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: No valid nodes after filtering");
        return;
    }

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    int totalConnectionsMade = 0;
    int totalConnectionAttempts = 0;

    // 2. Iterate through sorted nodes and connect matching pins.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[Color Chaining] Skipping invalid node pair: " + juce::String(sourceLid) + " -> " + juce::String(destLid));
            continue;
        }

        // Find all matching output pins on the source and input pins on the destination.
        auto sourcePins = getPinsOfType(sourceLid, false, targetType);
        auto destPins   = getPinsOfType(destLid, true, targetType);

        if (sourcePins.empty() || destPins.empty())
        {
            juce::Logger::writeToLog("[Color Chaining] No matching pins: " + juce::String(sourcePins.size()) + " src, " + juce::String(destPins.size()) + " dst");
            continue;
        }

        // Connect them one-to-one until we run out of available pins on either side.
        int connectionsToMake = std::min((int)sourcePins.size(), (int)destPins.size());

        for (int j = 0; j < connectionsToMake; ++j)
        {
            totalConnectionAttempts++;
            bool connectResult = synth->connect(sourceNodeId, sourcePins[j].channel, destNodeId, destPins[j].channel);
            if (connectResult)
            {
                totalConnectionsMade++;
                juce::Logger::writeToLog("[Color Chaining] Connected " + getTypeForLogical(sourceLid) + " -> " + getTypeForLogical(destLid));

                // Check if the destination is a recorder and update its filename
                if (auto* destModule = synth->getModuleForLogical(destLid))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                    {
                        if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                        {
                            recorder->updateSuggestedFilename(sourceModule->getName());
                        }
                    }
                }
            }
        }
    }

    juce::Logger::writeToLog("[Color Chaining] Completed: " + juce::String(totalConnectionsMade) + "/" + juce::String(totalConnectionAttempts) + " connections made");

    // 3. Apply all new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Module Category Color Coding
ImGuiNodeEditorComponent::ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleType)
{
    juce::String lower = moduleType.toLowerCase();
    
    // === CATEGORY CLASSIFICATION (Following Dictionary Structure) ===
    
    // --- 1. SOURCES (Green) ---
    if (lower.contains("vco") || lower.contains("polyvco") ||
        lower.contains("noise") || lower == "audio_input" || 
        lower.contains("sample") || lower == "value")
        return ModuleCategory::Source;
    
    // --- 2. EFFECTS (Red) ---
    // Note: Recorder moved to System, Vocal Tract Filter moved to TTS
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("reverb") || lower.contains("chorus") || 
        lower.contains("phaser") || lower.contains("compressor") || 
        lower.contains("limiter") || lower == "gate" ||
        lower.contains("drive") || lower.contains("eq") ||
        lower.contains("waveshaper") || lower.contains("8bandshaper") ||
        lower.contains("granulator") || lower.contains("harmonic_shaper") ||
        lower.contains("timepitch") || lower.contains("crackle"))
        return ModuleCategory::Effect;
    
    // --- 3. MODULATORS (Blue) ---
    if (lower.contains("lfo") || lower.contains("adsr") || 
        lower.contains("random") || lower.contains("s&h") || 
        lower.contains("function_generator") || lower.contains("shaping_oscillator"))
        return ModuleCategory::Modulator;
    
    // --- 4. UTILITIES & LOGIC (Orange) ---
    if (lower.contains("vca") || lower.contains("mixer") || 
        lower.contains("attenuverter") || lower.contains("lag_processor") ||
        lower.contains("math") || lower.contains("map_range") ||
        lower.contains("quantizer") || lower.contains("rate") ||
        lower.contains("comparator") || lower.contains("logic") ||
        lower.contains("reroute") || lower.contains("panvol") ||
        lower.contains("clock_divider") || lower.contains("sequential_switch"))
        return ModuleCategory::Utility;
    
    // --- 5. SEQUENCERS (Light Green) ---
    if (lower.contains("sequencer") || lower.contains("tempo_clock") || lower == "timeline")
        return ModuleCategory::Seq;
    
    // --- 6. MIDI (Vibrant Purple) ---
    if (lower.contains("midi"))
        return ModuleCategory::MIDI;
    
    // --- 7. ANALYSIS (Purple) ---
    if (lower.contains("scope") || lower.contains("debug") || 
        lower.contains("frequency_graph"))
        return ModuleCategory::Analysis;
    
    // --- 8. TTS (Peach/Coral) ---
    if (lower.contains("tts") || lower.contains("vocal_tract"))
        return ModuleCategory::TTS_Voice;
    
    // --- 9. SPECIAL (Cyan) - Physics & Animation ---
    if (lower.contains("physics") || lower.contains("animation"))
        return ModuleCategory::Special_Exp;
    
    // --- 10. COMPUTER VISION (Bright Orange) ---
    if (lower.contains("webcam") || lower.contains("video_file") ||
        lower == "video_fx" || lower == "crop_video" ||
        lower.contains("movement") || lower.contains("detector") || 
        lower.contains("opencv") || lower.contains("vision") ||
        lower.contains("tracker") || lower.contains("segmentation") ||
        lower.contains("pose_estimator"))
        return ModuleCategory::OpenCV;
    
    // --- 11. SYSTEM (Lavender) ---
    if (lower.contains("meta") || lower.contains("inlet") || 
        lower.contains("outlet") || lower.contains("comment") ||
        lower.contains("recorder") || lower.contains("vst_host") ||
        lower.contains("best_practice") || lower == "bpm_monitor" || lower.contains("bpm monitor"))
        return ModuleCategory::Sys;
    
    // --- 12. PLUGINS (Teal) ---
    if (lower.contains("vst") || lower.contains("plugin"))
        return ModuleCategory::Plugin;
    
    // --- Default: Utility ---
    return ModuleCategory::Utility;
}

unsigned int ImGuiNodeEditorComponent::getImU32ForCategory(ModuleCategory category, bool hovered)
{
    ImU32 color = ThemeManager::getInstance().getCategoryColor(static_cast<::ModuleCategory>(category));
    
    if (hovered) 
    { 
        // Brighten on hover
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        c.x = juce::jmin(c.x * 1.3f, 1.0f);
        c.y = juce::jmin(c.y * 1.3f, 1.0f);
        c.z = juce::jmin(c.z * 1.3f, 1.0f);
        return ImGui::ColorConvertFloat4ToU32(c);
    }
    return color;
}

// Quick Add Menu - Module Registry - Dictionary
// Maps Display Name -> { Internal Type, Description }
std::map<juce::String, std::pair<const char*, const char*>> ImGuiNodeEditorComponent::getModuleRegistry()
{
    return {
        // Sources
        {"Audio Input", {"audio_input", "Records audio from your audio interface"}},
        {"VCO", {"vco", "Voltage Controlled Oscillator - generates waveforms"}},
        {"Polyphonic VCO", {"polyvco", "Polyphonic VCO with multiple voices"}},
        {"Noise", {"noise", "White, pink, or brown noise generator"}},
        {"Sequencer", {"sequencer", "Step sequencer for creating patterns"}},
        {"Multi Sequencer", {"multi_sequencer", "Multi-track step sequencer"}},
        {"Stroke Sequencer", {"stroke_sequencer", "Freeform visual rhythmic and CV generator"}},
        {"MIDI Player", {"midi_player", "Plays MIDI files"}},
        {"MIDI CV", {"midi_cv", "Converts MIDI Note/CC messages to CV signals. (Monophonic)"}},
        {"MIDI Faders", {"midi_faders", "Up to 16 MIDI faders with CC learning"}},
        {"MIDI Knobs", {"midi_knobs", "Up to 16 MIDI knobs/rotary encoders with CC learning"}},
        {"MIDI Buttons", {"midi_buttons", "Up to 32 MIDI buttons with Gate/Toggle/Trigger modes"}},
        {"MIDI Jog Wheel", {"midi_jog_wheel", "Single MIDI jog wheel/rotary encoder"}},
        {"MIDI Pads", {"midi_pads", "16-pad MIDI controller with polyphonic triggers and velocity outputs"}},
        {"MIDI Logger", {"midi_logger", "Records CV/Gate to MIDI events with piano roll editor and .mid export"}},
        {"Value", {"value", "Constant CV value output"}},
        {"Sample Loader", {"sample_loader", "Loads and plays audio samples"}},
        
        // TTS
        {"TTS Performer", {"tts_performer", "Text-to-speech synthesizer"}},
        {"Vocal Tract Filter", {"vocal_tract_filter", "Physical model vocal tract filter"}},
        
        // Physics & Animation
        {"Physics", {"physics", "2D physics simulation for audio modulation"}},
        {"Animation", {"animation", "Skeletal animation system with glTF file support"}},
        
        // OpenCV (Computer Vision)
        {"Webcam Loader", {"webcam_loader", "Captures video from a webcam and publishes it as a source for vision processing modules"}},
        {"Video File Loader", {"video_file_loader", "Loads and plays a video file, publishes it as a source for vision processing modules"}},
        {"Video FX", {"video_fx", "Applies real-time video effects (brightness, contrast, saturation, blur, sharpen, etc.) to video sources, chainable"}},
        {"Crop Video", {"crop_video", "Crops and resizes video frames to a specified region, chainable video processor"}},
        {"Movement Detector", {"movement_detector", "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV"}},
        {"Human Detector", {"human_detector", "Detects faces or bodies in video source via Haar Cascades or HOG, outputs position and size as CV"}},
        {"Object Detector", {"object_detector", "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV"}},
        {"Pose Estimator", {"pose_estimator", "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals"}},
        {"Hand Tracker", {"hand_tracker", "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels)"}},
        {"Face Tracker", {"face_tracker", "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels)"}},
        {"Color Tracker", {"color_tracker", "Tracks multiple colors in video and outputs their positions and sizes as CV"}},
        {"Contour Detector", {"contour_detector", "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV"}},
        {"Semantic Segmentation", {"semantic_segmentmentation", "Uses deep learning to segment video into semantic regions and outputs detected areas as CV"}},
        
        // Effects
        {"VCF", {"vcf", "Voltage Controlled Filter"}},
        {"Delay", {"delay", "Echo/delay effect"}},
        {"Reverb", {"reverb", "Reverb effect"}},
        {"Chorus", {"chorus", "Chorus effect for thickening sound"}},
        {"Phaser", {"phaser", "Phaser modulation effect"}},
        {"Compressor", {"compressor", "Dynamic range compressor"}},
        {"Recorder", {"recorder", "Records audio to disk"}},
        {"Limiter", {"limiter", "Peak limiter"}},
        {"Noise Gate", {"gate", "Noise gate"}},
        {"Drive", {"drive", "Distortion/overdrive"}},
        {"PanVol", {"panvol", "2D control surface for volume and panning"}},
        {"Graphic EQ", {"graphic_eq", "Graphic equalizer"}},
        {"Waveshaper", {"waveshaper", "Waveshaping distortion"}},
        {"8-Band Shaper", {"8bandshaper", "8-band spectral shaper"}},
        {"Granulator", {"granulator", "Granular synthesis effect"}},
        {"Harmonic Shaper", {"harmonic_shaper", "Harmonic content shaper"}},
        {"Time/Pitch Shifter", {"timepitch", "Time stretching and pitch shifting"}},
        {"De-Crackle", {"de_crackle", "Removes clicks and pops"}},
        
        // Modulators
        {"LFO", {"lfo", "Low Frequency Oscillator for modulation"}},
        {"ADSR", {"adsr", "Attack Decay Sustain Release envelope"}},
        {"Random", {"random", "Random value generator"}},
        {"S&H", {"s_and_h", "Sample and Hold"}},
        {"Tempo Clock", {"tempo_clock", "Global clock with BPM control, transport (play/stop/reset), division, swing, and clock/gate outputs. Use External Takeover to drive the master transport."}},
        {"Function Generator", {"function_generator", "Custom function curves"}},
        {"Shaping Oscillator", {"shaping_oscillator", "Oscillator with waveshaping"}},
        
        // Utilities
        {"VCA", {"vca", "Voltage Controlled Amplifier"}},
        {"Mixer", {"mixer", "Audio/CV mixer"}},
        {"CV Mixer", {"cv_mixer", "CV signal mixer"}},
        {"Track Mixer", {"track_mixer", "Multi-track mixer with panning"}},
        {"Attenuverter", {"attenuverter", "Attenuate and invert signals"}},
        {"Reroute", {"reroute", "A polymorphic passthrough node. Pin color adapts to the input signal."}},
        {"Lag Processor", {"lag_processor", "Slew rate limiter/smoother"}},
        {"Math", {"math", "Mathematical operations"}},
        {"Map Range", {"map_range", "Map values from one range to another"}},
        {"Quantizer", {"quantizer", "Quantize CV to scales"}},
        {"Rate", {"rate", "Rate/frequency divider"}},
        {"Comparator", {"comparator", "Compare and threshold signals"}},
        {"Logic", {"logic", "Boolean logic operations"}},
        {"Clock Divider", {"clock_divider", "Clock division and multiplication"}},
        {"Sequential Switch", {"sequential_switch", "Sequential signal router"}},
        {"Comment", {"comment", "Text comment box"}},
        {"Best Practice", {"best_practice", "Best practice node template"}},
        {"Snapshot Sequencer", {"snapshot_sequencer", "Snapshot sequencer for parameter automation"}},
        {"Timeline", {"timeline", "Transport-synchronized automation recorder for CV, Gate, Trigger, and Raw signals"}},
        {"BPM Monitor", {"bpm_monitor", "Hybrid rhythm detection and BPM reporting from sequencers and audio inputs"}},
        
        // Analysis
        {"Scope", {"scope", "Oscilloscope display"}},
        {"Debug", {"debug", "Debug value display"}},
        {"Input Debug", {"input_debug", "Input signal debugger"}},
        {"Frequency Graph", {"frequency_graph", "Spectrum analyzer display"}}
    };
}

// Legacy function for backwards compatibility with tooltip display
std::vector<std::pair<juce::String, const char*>> ImGuiNodeEditorComponent::getModuleDescriptions()
{
    std::vector<std::pair<juce::String, const char*>> result;
    for (const auto& entry : getModuleRegistry())
    {
        // Return {internal type, description} for compatibility
        result.push_back({entry.second.first, entry.second.second});
    }
    return result;
}

// VST Plugin Support
void ImGuiNodeEditorComponent::addPluginModules()
{
    if (synth == nullptr)
        return;
    
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    auto& formatManager = app.getPluginFormatManager();
    
    // Set the plugin format manager and known plugin list on the synth if not already set
    synth->setPluginFormatManager(&formatManager);
    synth->setKnownPluginList(&knownPluginList);
    
    // Get the VST folder at exe position
    juce::File exeDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File vstFolder = exeDir.getChildFile("VST");
    
    // Get all plugins and filter/deduplicate
    const auto& allPlugins = knownPluginList.getTypes();
    
    if (allPlugins.isEmpty())
    {
        ImGui::TextDisabled("No plugins found.");
        ImGui::TextDisabled("Use 'Scan for Plugins...' in the File menu.");
        return;
    }
    
    // Filter to only plugins in the VST folder and deduplicate
    std::vector<juce::PluginDescription> filteredPlugins;
    std::set<juce::String> seenPlugins; // Use name + manufacturer as unique key
    
    for (const auto& desc : allPlugins)
    {
        // Check if plugin is in the VST folder at exe position
        juce::File pluginFile(desc.fileOrIdentifier);
        if (!pluginFile.existsAsFile())
            continue;
            
        juce::File pluginDir = pluginFile.getParentDirectory();
        if (!pluginDir.isAChildOf(vstFolder) && pluginDir != vstFolder)
            continue;
        
        // Create unique key for deduplication (name + manufacturer)
        juce::String uniqueKey = desc.name + "|" + desc.manufacturerName;
        if (seenPlugins.find(uniqueKey) != seenPlugins.end())
            continue; // Skip duplicate
        
        seenPlugins.insert(uniqueKey);
        filteredPlugins.push_back(desc);
    }
    
    if (filteredPlugins.empty())
    {
        ImGui::TextDisabled("No plugins found in VST folder.");
        ImGui::TextDisabled(("Place VST plugins in: " + vstFolder.getFullPathName()).toRawUTF8());
        return;
    }
    
    // Use PushID to create unique IDs for each plugin to avoid conflicts when called from multiple menus
    ImGui::PushID("PluginList");
    int pluginIndex = 0;
    for (const auto& desc : filteredPlugins)
    {
        ImGui::PushID(pluginIndex++);
        juce::String buttonLabel = desc.name;
        if (desc.manufacturerName.isNotEmpty())
        {
            buttonLabel += " (" + desc.manufacturerName + ")";
        }
        
        if (ImGui::Selectable(buttonLabel.toRawUTF8()))
        {
            auto nodeId = synth->addVstModule(formatManager, desc);
            if (nodeId.uid != 0)
            {
                const ImVec2 mouse = ImGui::GetMousePos();
                const auto logicalId = synth->getLogicalIdForNode(nodeId);
                pendingNodeScreenPositions[(int)logicalId] = mouse;
                snapshotAfterEditor = true;
                juce::Logger::writeToLog("[VST] Added plugin: " + desc.name);
                // Close popup if we're in a popup context (safe to call even if not in popup)
                ImGui::CloseCurrentPopup();
            }
            else
            {
                juce::Logger::writeToLog("[VST] ERROR: Failed to add plugin: " + desc.name);
            }
        }
        
        // Show tooltip with plugin info on hover
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("Name: %s", desc.name.toRawUTF8());
            ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
            ImGui::Text("Version: %s", desc.version.toRawUTF8());
            ImGui::Text("Format: %s", desc.pluginFormatName.toRawUTF8());
            ImGui::Text("Type: %s", desc.isInstrument ? "Instrument" : "Effect");
            ImGui::Text("Inputs: %d", desc.numInputChannels);
            ImGui::Text("Outputs: %d", desc.numOutputChannels);
            ImGui::EndTooltip();
        }
        
        ImGui::PopID(); // Pop plugin index ID
    }
    ImGui::PopID(); // Pop PluginList ID
}
void ImGuiNodeEditorComponent::handleCollapseToMetaModule()
{
    if (!synth)
        return;
    
    juce::Logger::writeToLog("[Meta Module] Starting collapse operation...");
    
    // 1. Get selected nodes
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected < 2)
    {
        juce::Logger::writeToLog("[Meta Module] ERROR: Need at least 2 nodes selected");
        return;
    }
    
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());
    
    // Convert to logical IDs
    std::set<juce::uint32> selectedLogicalIds;
    for (int nodeId : selectedNodeIds)
    {
        selectedLogicalIds.insert((juce::uint32)nodeId);
    }
    
    juce::Logger::writeToLog("[Meta Module] Selected " + juce::String(numSelected) + " nodes");
    
    // 2. Analyze boundary connections
    struct BoundaryConnection
    {
        juce::uint32 externalLogicalId;
        int externalChannel;
        juce::uint32 internalLogicalId;
        int internalChannel;
        bool isInput; // true = external -> internal, false = internal -> external
    };
    std::vector<BoundaryConnection> boundaries;
    using InletKey = std::pair<juce::uint32, int>;
    using OutletKey = std::pair<juce::uint32, int>;
    struct InletInfo { juce::uint32 logicalId; int pinIndex; int channelCount; juce::uint32 externalLogicalId; int externalChannel; };
    struct OutletInfo { juce::uint32 logicalId; int pinIndex; int channelCount; juce::uint32 externalLogicalId; int externalChannel; bool externalIsOutput; };
    std::map<InletKey, InletInfo> inletInfoMap;
    std::map<OutletKey, OutletInfo> outletInfoMap;
    std::unordered_map<juce::uint32, InletInfo> inletInfoByLogical;
    std::unordered_map<juce::uint32, OutletInfo> outletInfoByLogical;
    int inletPinIndexCounter = 0;
    int outletPinIndexCounter = 0;
    auto allConnections = synth->getConnectionsInfo();
    for (const auto& conn : allConnections)
    {
        bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
        bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0 && !conn.dstIsOutput;
        bool dstIsOutput = conn.dstIsOutput;
        
        // Inlet: external -> selected
        if (!srcIsSelected && dstIsSelected)
        {
            BoundaryConnection bc;
            bc.externalLogicalId = conn.srcLogicalId;
            bc.externalChannel = conn.srcChan;
            bc.internalLogicalId = conn.dstLogicalId;
            bc.internalChannel = conn.dstChan;
            bc.isInput = true;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found inlet: " + juce::String(bc.externalLogicalId) + 
                                    " -> " + juce::String(bc.internalLogicalId));
        }
        // Outlet: selected -> external or output
        else if (srcIsSelected && (!dstIsSelected || dstIsOutput))
        {
            BoundaryConnection bc;
            bc.externalLogicalId = dstIsOutput ? 0 : conn.dstLogicalId;
            bc.externalChannel = conn.dstChan;
            bc.internalLogicalId = conn.srcLogicalId;
            bc.internalChannel = conn.srcChan;
            bc.isInput = false;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found outlet: " + juce::String(bc.internalLogicalId) + 
                                    " -> " + (dstIsOutput ? "OUTPUT" : juce::String(bc.externalLogicalId)));
        }
    }
    
    // Count inlets and outlets
    int numInlets = 0;
    int numOutlets = 0;
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            numInlets++;
        else
            numOutlets++;
    }
    
    juce::Logger::writeToLog("[META] Boundary Detection: Found " + juce::String(numInlets) + " inlets and " + juce::String(numOutlets) + " outlets.");
    juce::Logger::writeToLog("[META] Found " + juce::String(boundaries.size()) + " boundary connections");
    
    if (boundaries.empty())
    {
        juce::Logger::writeToLog("[META] WARNING: No boundary connections - creating isolated meta module");
    }
    
    // 3. Create the internal graph state
    pushSnapshot(); // Make undoable
    
    // Save the state of selected nodes
    juce::MemoryBlock internalState;
    {
        // Create a temporary state containing only selected nodes
        juce::ValueTree internalRoot("ModularSynthPreset");
        internalRoot.setProperty("version", 1, nullptr);
        
        juce::ValueTree modsVT("modules");
        juce::ValueTree connsVT("connections");
        
        // Add selected modules
        std::map<juce::uint32, juce::uint32> oldToNewLogicalId;
        juce::uint32 newLogicalId = 1;
        
        for (juce::uint32 oldId : selectedLogicalIds)
        {
            oldToNewLogicalId[oldId] = newLogicalId++;
            
            auto* module = synth->getModuleForLogical(oldId);
            if (!module)
                continue;
            
            juce::String moduleType = synth->getModuleTypeForLogical(oldId);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)oldToNewLogicalId[oldId], nullptr);
            mv.setProperty("type", moduleType, nullptr);
            
            // Save parameters
            juce::ValueTree params = module->getAPVTS().copyState();
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(params, -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            // Save extra state
            if (auto extra = module->getExtraStateTree(); extra.isValid())
            {
                juce::ValueTree extraWrapper("extra");
                extraWrapper.addChild(extra, -1, nullptr);
                mv.addChild(extraWrapper, -1, nullptr);
            }
            
            modsVT.addChild(mv, -1, nullptr);
        }
        
        auto createParameterState = [](const juce::String& paramId, int value)
        {
            juce::ValueTree params("Parameters");
            juce::ValueTree paramNode("Parameter");
            paramNode.setProperty("id", paramId, nullptr);
            paramNode.setProperty("value", (double)value, nullptr);
            params.addChild(paramNode, -1, nullptr);
            return params;
        };
        
        // Add inlet modules for each unique input
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
                continue;
            
            InletKey key { bc.externalLogicalId, bc.externalChannel };
            if (inletInfoMap.find(key) != inletInfoMap.end())
                continue;
            
            const juce::uint32 inletId = newLogicalId++;
            const int pinIndex = inletPinIndexCounter++;
            const int channelCount = 1;
            
            InletInfo info { inletId, pinIndex, channelCount, bc.externalLogicalId, bc.externalChannel };
            inletInfoMap[key] = info;
            inletInfoByLogical.emplace(inletId, info);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)inletId, nullptr);
            mv.setProperty("type", "inlet", nullptr);
            
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(createParameterState(InletModuleProcessor::paramIdChannelCount, channelCount), -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            juce::ValueTree extra("InletState");
            juce::String inletLabel;
            if (auto* srcModule = synth->getModuleForLogical(bc.externalLogicalId))
            {
                inletLabel = srcModule->getName();
                const juce::String channelLabel = srcModule->getAudioOutputLabel(bc.externalChannel);
                if (channelLabel.isNotEmpty())
                    inletLabel += " :: " + channelLabel;
                else
                    inletLabel += " :: Out " + juce::String(bc.externalChannel + 1);
            }
            else
            {
                inletLabel = "In " + juce::String(pinIndex + 1);
            }
            extra.setProperty("customLabel", inletLabel, nullptr);
            extra.setProperty("pinIndex", pinIndex, nullptr);
            extra.setProperty("externalLogicalId", (int)bc.externalLogicalId, nullptr);
            extra.setProperty("externalChannel", bc.externalChannel, nullptr);
            juce::ValueTree extraWrapper("extra");
            extraWrapper.addChild(extra, -1, nullptr);
            mv.addChild(extraWrapper, -1, nullptr);
            
            modsVT.addChild(mv, -1, nullptr);
            juce::Logger::writeToLog("[Meta Module] Created inlet node ID=" + juce::String(inletId));
        }
        
        // Add outlet modules for each unique output
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
                continue;
            
            OutletKey key { bc.internalLogicalId, bc.internalChannel };
            if (outletInfoMap.find(key) != outletInfoMap.end())
                continue;
            
            const juce::uint32 outletId = newLogicalId++;
            const int pinIndex = outletPinIndexCounter++;
            const int channelCount = 1;
            
            OutletInfo info { outletId, pinIndex, channelCount, bc.externalLogicalId, bc.externalChannel, bc.externalLogicalId == 0 };
            outletInfoMap[key] = info;
            outletInfoByLogical.emplace(outletId, info);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)outletId, nullptr);
            mv.setProperty("type", "outlet", nullptr);
            
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(createParameterState(OutletModuleProcessor::paramIdChannelCount, channelCount), -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            juce::ValueTree extra("OutletState");
            juce::String outletLabel;
            if (bc.externalLogicalId == 0)
            {
                outletLabel = "Main Output :: Ch " + juce::String(bc.externalChannel + 1);
            }
            else if (auto* dstModule = synth->getModuleForLogical(bc.externalLogicalId))
            {
                outletLabel = dstModule->getName();
                const juce::String channelLabel = dstModule->getAudioInputLabel(bc.externalChannel);
                if (channelLabel.isNotEmpty())
                    outletLabel += " :: " + channelLabel;
                else
                    outletLabel += " :: In " + juce::String(bc.externalChannel + 1);
            }
            else
            {
                outletLabel = "Out " + juce::String(pinIndex + 1);
            }
            extra.setProperty("customLabel", outletLabel, nullptr);
            extra.setProperty("pinIndex", pinIndex, nullptr);
            extra.setProperty("externalLogicalId", (int)bc.externalLogicalId, nullptr);
            extra.setProperty("externalChannel", bc.externalChannel, nullptr);
            extra.setProperty("externalIsOutput", bc.externalLogicalId == 0, nullptr);
            juce::ValueTree extraWrapper("extra");
            extraWrapper.addChild(extra, -1, nullptr);
            mv.addChild(extraWrapper, -1, nullptr);
            
            modsVT.addChild(mv, -1, nullptr);
            juce::Logger::writeToLog("[Meta Module] Created outlet node ID=" + juce::String(outletId));
        }
        
        // Add internal connections (between selected nodes)
        for (const auto& conn : allConnections)
        {
            bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
            bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0;
            
            if (srcIsSelected && dstIsSelected)
            {
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[conn.srcLogicalId], nullptr);
                cv.setProperty("srcChan", conn.srcChan, nullptr);
                cv.setProperty("dstId", (int)oldToNewLogicalId[conn.dstLogicalId], nullptr);
                cv.setProperty("dstChan", conn.dstChan, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from inlets to internal nodes
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                InletKey key { bc.externalLogicalId, bc.externalChannel };
                auto it = inletInfoMap.find(key);
                if (it == inletInfoMap.end())
                    continue;
                juce::uint32 inletId = it->second.logicalId;
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)inletId, nullptr);
                cv.setProperty("srcChan", 0, nullptr); // Inlets output on channel 0
                cv.setProperty("dstId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("dstChan", bc.internalChannel, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from internal nodes to outlets
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                OutletKey key { bc.internalLogicalId, bc.internalChannel };
                auto it = outletInfoMap.find(key);
                if (it == outletInfoMap.end())
                    continue;
                juce::uint32 outletId = it->second.logicalId;
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("srcChan", bc.internalChannel, nullptr);
                cv.setProperty("dstId", (int)outletId, nullptr);
                cv.setProperty("dstChan", 0, nullptr); // Outlets input on channel 0
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        internalRoot.addChild(modsVT, -1, nullptr);
        internalRoot.addChild(connsVT, -1, nullptr);
        
        // Serialize to memory block
        if (auto xml = internalRoot.createXml())
        {
            juce::MemoryOutputStream mos(internalState, false);
            xml->writeTo(mos);
            juce::Logger::writeToLog("[META] Generated state for sub-patch.");
        }
    }
    
    // 4. Calculate average position for the meta module
    ImVec2 avgPos(0.0f, 0.0f);
    int posCount = 0;
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos((int)logicalId);
        avgPos.x += pos.x;
        avgPos.y += pos.y;
        posCount++;
    }
    if (posCount > 0)
    {
        avgPos.x /= posCount;
        avgPos.y /= posCount;
    }
    
    // 5. Delete selected nodes
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        auto nodeId = synth->getNodeIdForLogical(logicalId);
        synth->removeModule(nodeId);
    }
    
    // 6. Create meta module
    auto metaNodeId = synth->addModule("meta_module");
    auto metaLogicalId = synth->getLogicalIdForNode(metaNodeId);
    pendingNodePositions[(int)metaLogicalId] = avgPos;
    
    juce::Logger::writeToLog("[META] Created new MetaModule with logical ID: " + juce::String((int)metaLogicalId));
    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule)
    {
        juce::ValueTree metaState("MetaModuleState");
        metaState.setProperty("label", "Meta Module", nullptr);

        if (internalState.getSize() > 0)
        {
            juce::MemoryOutputStream base64Stream;
            juce::Base64::convertToBase64(base64Stream, internalState.getData(), internalState.getSize());
            metaState.setProperty("internalGraphState", base64Stream.toString(), nullptr);
        }

        metaModule->setExtraStateTree(metaState);
        juce::Logger::writeToLog("[META] Loaded internal state into meta module");
    }
    else
    {
        juce::Logger::writeToLog("[META] ERROR: Failed to create meta module");
        return;
    }
    // 7. Reconnect external connections
    auto sortedInlets = metaModule->getInletNodes();
    std::sort(sortedInlets.begin(), sortedInlets.end(), [](auto* a, auto* b)
    {
        if (a->getPinIndex() != b->getPinIndex())
            return a->getPinIndex() < b->getPinIndex();
        return a->getLogicalId() < b->getLogicalId();
    });
    std::unordered_map<int, int> inletBaseChannels;
    std::unordered_map<int, int> inletChannelCounts;
    int runningInputChannel = 0;
    for (auto* inlet : sortedInlets)
    {
        const int pinIndex = inlet->getPinIndex();
        int channelCount = 1;
        if (auto* param = dynamic_cast<juce::AudioParameterInt*>(
                inlet->getAPVTS().getParameter(InletModuleProcessor::paramIdChannelCount)))
        {
            channelCount = juce::jmax(1, param->get());
        }
        if (auto logicalIt = inletInfoByLogical.find(inlet->getLogicalId()); logicalIt != inletInfoByLogical.end())
        {
            inlet->setExternalMapping(logicalIt->second.externalLogicalId, logicalIt->second.externalChannel);
        }
        inletBaseChannels[pinIndex] = runningInputChannel;
        inletChannelCounts[pinIndex] = channelCount;
        runningInputChannel += channelCount;
    }

    auto sortedOutlets = metaModule->getOutletNodes();
    std::sort(sortedOutlets.begin(), sortedOutlets.end(), [](auto* a, auto* b)
    {
        if (a->getPinIndex() != b->getPinIndex())
            return a->getPinIndex() < b->getPinIndex();
        return a->getLogicalId() < b->getLogicalId();
    });

    std::unordered_map<int, int> outletBaseChannels;
    std::unordered_map<int, int> outletChannelCounts;
    int runningOutputChannel = 0;
    for (auto* outlet : sortedOutlets)
    {
        const int pinIndex = outlet->getPinIndex();
        int channelCount = 1;
        if (auto* param = dynamic_cast<juce::AudioParameterInt*>(
                outlet->getAPVTS().getParameter(OutletModuleProcessor::paramIdChannelCount)))
        {
            channelCount = juce::jmax(1, param->get());
        }
        if (auto logicalIt = outletInfoByLogical.find(outlet->getLogicalId()); logicalIt != outletInfoByLogical.end())
        {
            outlet->setExternalMapping(logicalIt->second.externalLogicalId,
                                       logicalIt->second.externalChannel,
                                       logicalIt->second.externalIsOutput);
        }
        outletBaseChannels[pinIndex] = runningOutputChannel;
        outletChannelCounts[pinIndex] = channelCount;
        runningOutputChannel += channelCount;
    }

    // Connect unique external sources to meta inputs
    for (const auto& entry : inletInfoMap)
    {
        const InletKey& key = entry.first;
        const InletInfo& info = entry.second;

        auto extNodeId = synth->getNodeIdForLogical(key.first);
        if (extNodeId.uid == 0)
            continue;

        auto baseIt = inletBaseChannels.find(info.pinIndex);
        auto countIt = inletChannelCounts.find(info.pinIndex);
        if (baseIt == inletBaseChannels.end() || countIt == inletChannelCounts.end())
            continue;

        const int baseChannel = baseIt->second;
        const int channelCount = countIt->second;

        for (int ch = 0; ch < channelCount; ++ch)
        {
            synth->connect(extNodeId, key.second + ch, metaNodeId, baseChannel + ch);
        }
    }

    const auto outputNodeId = synth->getOutputNodeID();

    // Reconnect meta outputs to their original destinations
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            continue;

        OutletKey key { bc.internalLogicalId, bc.internalChannel };
        auto infoIt = outletInfoMap.find(key);
        if (infoIt == outletInfoMap.end())
            continue;

        const OutletInfo& info = infoIt->second;
        auto destNodeId = (bc.externalLogicalId == 0)
            ? outputNodeId
            : synth->getNodeIdForLogical(bc.externalLogicalId);

        if (destNodeId.uid == 0)
            continue;

        auto baseIt = outletBaseChannels.find(info.pinIndex);
        auto countIt = outletChannelCounts.find(info.pinIndex);
        if (baseIt == outletBaseChannels.end() || countIt == outletChannelCounts.end())
            continue;

        const int baseChannel = baseIt->second;
        const int channelCount = countIt->second;

        for (int ch = 0; ch < channelCount; ++ch)
        {
            synth->connect(metaNodeId, baseChannel + ch, destNodeId, bc.externalChannel + ch);
        }
    }
    
    graphNeedsRebuild = true;
    synth->commitChanges();
    
    juce::Logger::writeToLog("[META] Reconnected external cables. Collapse complete!");
    NotificationManager::post(NotificationManager::Type::Info, "Collapsed to Meta Module");
}

void ImGuiNodeEditorComponent::populateDragInsertSuggestions()
{
    dragInsertSuggestionsInputs.clear();
    dragInsertSuggestionsOutputs.clear();

    const auto& pinDb = getModulePinDatabase();

    auto addUnique = [](auto& mapRef, PinDataType type, const juce::String& moduleType)
    {
        auto& modules = mapRef[type];
        if (std::find(modules.begin(), modules.end(), moduleType) == modules.end())
            modules.push_back(moduleType);
    };

    auto addInputModule = [&](PinDataType type, const juce::String& moduleType)
    {
        addUnique(dragInsertSuggestionsInputs, type, moduleType);
    };

    auto addOutputModule = [&](PinDataType type, const juce::String& moduleType)
    {
        addUnique(dragInsertSuggestionsOutputs, type, moduleType);
    };

    // Seed curated utilities for fast access when connecting FROM outputs (needs inputs).
    addInputModule(PinDataType::Audio, "attenuverter");
    addInputModule(PinDataType::Audio, "comparator");
    addInputModule(PinDataType::Audio, "mixer");

    addInputModule(PinDataType::CV, "attenuverter");
    addInputModule(PinDataType::CV, "lag_processor");
    addInputModule(PinDataType::CV, "math");

    addInputModule(PinDataType::Gate, "comparator");
    addInputModule(PinDataType::Gate, "logic");
    addInputModule(PinDataType::Gate, "sequential_switch");

    addInputModule(PinDataType::Raw, "map_range");
    addInputModule(PinDataType::Raw, "scope");

    addInputModule(PinDataType::Video, "video_fx");
    addInputModule(PinDataType::Video, "crop_video");

    // Seed curated sources for fast access when connecting INTO inputs (needs outputs).
    addOutputModule(PinDataType::Audio, "vco");
    addOutputModule(PinDataType::Audio, "polyvco");
    addOutputModule(PinDataType::Audio, "noise");
    addOutputModule(PinDataType::Audio, "sample_loader");
    addOutputModule(PinDataType::Audio, "midi_player");

    addOutputModule(PinDataType::CV, "lfo");
    addOutputModule(PinDataType::CV, "adsr");
    addOutputModule(PinDataType::CV, "function_generator");
    addOutputModule(PinDataType::CV, "value");

    addOutputModule(PinDataType::Gate, "adsr");
    addOutputModule(PinDataType::Gate, "random");

    addOutputModule(PinDataType::Raw, "value");

    addOutputModule(PinDataType::Video, "webcam_loader");
    addOutputModule(PinDataType::Video, "video_file_loader");

    for (auto type : { PinDataType::Audio, PinDataType::CV, PinDataType::Gate, PinDataType::Raw, PinDataType::Video })
    {
        addInputModule(type, "reroute");
        addOutputModule(type, "reroute");
    }

    for (const auto& entry : pinDb)
    {
        const juce::String& moduleType = entry.first;
        const auto& info = entry.second;

        for (const auto& pin : info.audioIns)
            addInputModule(pin.type, moduleType);

        for (const auto& pin : info.modIns)
            addInputModule(pin.type, moduleType);

        for (const auto& pin : info.audioOuts)
            addOutputModule(pin.type, moduleType);
    }

    auto sortMapVectors = [](auto& mapRef)
    {
        for (auto& entry : mapRef)
        {
            auto& modules = entry.second;
            std::sort(modules.begin(), modules.end(),
                      [](const juce::String& a, const juce::String& b)
                      {
                          return a.compareIgnoreCase(b) < 0;
                      });
        }
    };

    sortMapVectors(dragInsertSuggestionsInputs);
    sortMapVectors(dragInsertSuggestionsOutputs);
}

const std::vector<juce::String>& ImGuiNodeEditorComponent::getDragInsertSuggestionsFor(const PinID& pin) const
{
    PinID localPin = pin;
    PinDataType type = localPin.isMod ? PinDataType::CV
                                      : const_cast<ImGuiNodeEditorComponent*>(this)->getPinDataTypeForPin(localPin);

    const auto& sourceMap = localPin.isInput ? dragInsertSuggestionsOutputs
                                             : dragInsertSuggestionsInputs;
    if (auto it = sourceMap.find(type); it != sourceMap.end())
        return it->second;

    static const std::vector<juce::String> empty;
    return empty;
}
void ImGuiNodeEditorComponent::insertNodeFromDragSelection(const juce::String& moduleType)
{
    if (synth == nullptr || dragInsertStartAttrId == -1)
        return;

    auto newNodeId = synth->addModule(moduleType);
    auto newLogicalId = synth->getLogicalIdForNode(newNodeId);

    pendingNodeScreenPositions[(int)newLogicalId] = dragInsertDropPos;

    const PinDataType primaryType = dragInsertStartPin.isMod
        ? PinDataType::CV
        : getPinDataTypeForPin(dragInsertStartPin);

    auto getSortedPinsForType = [&](juce::uint32 logicalId, bool isInput) -> std::vector<AudioPin>
    {
        std::vector<AudioPin> pins;

        if (logicalId == 0)
        {
            if (primaryType == PinDataType::Audio)
            {
                pins.emplace_back("Main L", 0, PinDataType::Audio);
                pins.emplace_back("Main R", 1, PinDataType::Audio);
            }
            return pins;
        }

        pins = getPinsOfType(logicalId, isInput, primaryType);
        std::sort(pins.begin(), pins.end(),
                  [](const AudioPin& a, const AudioPin& b)
                  {
                      return a.channel < b.channel;
                  });
        return pins;
    };

    auto findChannelIndex = [](const std::vector<AudioPin>& pins, int channel) -> int
    {
        for (int i = 0; i < (int)pins.size(); ++i)
        {
            if (pins[(size_t)i].channel == channel)
                return i;
        }
        return -1;
    };

    auto logNoCompatiblePins = [&](const char* role)
    {
        juce::Logger::writeToLog("[DragInsert] No compatible "
                                 + juce::String(toString(primaryType))
                                 + " " + juce::String(role)
                                 + " found for '" + moduleType + "', skipping auto-wire.");
    };

    bool connected = false;
    if (!dragInsertStartPin.isMod)
    {
        if (!dragInsertStartPin.isInput)
        {
            auto srcNodeId = synth->getNodeIdForLogical(dragInsertStartPin.logicalId);
            if (srcNodeId.uid != 0)
            {
                const auto sourcePins = getSortedPinsForType(dragInsertStartPin.logicalId, false);
                const auto targetPins = getSortedPinsForType((juce::uint32)newLogicalId, true);

        if (!sourcePins.empty() && !targetPins.empty())
        {
            if (primaryType == PinDataType::Audio)
            {
                std::vector<int> sourceChannels;
                sourceChannels.reserve(sourcePins.size());
                for (const auto& pin : sourcePins)
                    sourceChannels.push_back(pin.channel);
                if (sourceChannels.empty())
                    sourceChannels.push_back(dragInsertStartPin.channel);
                if (sourceChannels.size() > 2)
                    sourceChannels.resize(2);

                std::vector<int> targetChannels;
                targetChannels.reserve(targetPins.size());
                for (const auto& pin : targetPins)
                    targetChannels.push_back(pin.channel);
                if (targetChannels.size() > 2)
                    targetChannels.resize(2);

                std::set<std::pair<int,int>> madeConnections;
                auto connectAudioPair = [&](int srcChan, int dstChan)
                {
                    if (srcChan < 0 || dstChan < 0)
                        return;
                    std::pair<int,int> key{srcChan, dstChan};
                    if (madeConnections.insert(key).second)
                    {
                        synth->connect(srcNodeId, srcChan, newNodeId, dstChan);
                        connected = true;
                    }
                };

                if (!sourceChannels.empty() && !targetChannels.empty())
                {
                    const bool sourceStereo = sourceChannels.size() >= 2;
                    const bool targetStereo = targetChannels.size() >= 2;

                    if (!sourceStereo && targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                        connectAudioPair(sourceChannels[0], targetChannels[1]);
                    }
                    else if (sourceStereo && !targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                    }
                    else if (sourceStereo && targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                        connectAudioPair(sourceChannels[1], targetChannels[1]);
                    }
                    else
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                    }
                }
                if (!connected)
                    logNoCompatiblePins("input");
            }
            else
            {
                const int sourceIndex = juce::jmax(0, findChannelIndex(sourcePins, dragInsertStartPin.channel));
                const int targetIndex = juce::jlimit(0, (int)targetPins.size() - 1, sourceIndex);

                synth->connect(srcNodeId,
                               sourcePins[(size_t)sourceIndex].channel,
                               newNodeId,
                               targetPins[(size_t)targetIndex].channel);
                connected = true;
            }
        }
        else
        {
            logNoCompatiblePins("input");
        }
            }
        }
        else
        {
            auto dstNodeId = dragInsertStartPin.logicalId == 0
                             ? synth->getOutputNodeID()
                             : synth->getNodeIdForLogical(dragInsertStartPin.logicalId);
            if (dstNodeId.uid != 0)
            {
                const auto sourcePins = getSortedPinsForType((juce::uint32)newLogicalId, false);
                const auto destinationPins = getSortedPinsForType(dragInsertStartPin.logicalId, true);

                if (!sourcePins.empty() && !destinationPins.empty())
                {
                    const int destinationIndex = findChannelIndex(destinationPins, dragInsertStartPin.channel);
                    if (destinationIndex >= 0)
                    {
                        const int sourceIndex = juce::jlimit(0, (int)sourcePins.size() - 1, destinationIndex);

                        synth->connect(newNodeId,
                                       sourcePins[(size_t)sourceIndex].channel,
                                       dstNodeId,
                                       destinationPins[(size_t)destinationIndex].channel);
                        connected = true;

                        if (primaryType == PinDataType::Audio)
                        {
                            const int stereoSourceIndex = sourceIndex + 1;
                            const int stereoDestinationIndex = destinationIndex + 1;

                            if (stereoSourceIndex < (int)sourcePins.size() &&
                                stereoDestinationIndex < (int)destinationPins.size())
                            {
                                synth->connect(newNodeId,
                                               sourcePins[(size_t)stereoSourceIndex].channel,
                                               dstNodeId,
                                               destinationPins[(size_t)stereoDestinationIndex].channel);
                            }
                        }
                    }
                }
                else
                {
                    logNoCompatiblePins("output");
                }
            }
        }
    }

    synth->commitChanges();

    graphNeedsRebuild = true;
    pushSnapshot();

    juce::Logger::writeToLog("[DragInsert] Added '" + moduleType + "' (LID "
                             + juce::String((int)newLogicalId) + ")"
                             + (connected ? " and auto-wired input." : "."));

    dragInsertStartAttrId = -1;
    dragInsertStartPin = PinID{};
    shouldOpenDragInsertPopup = false;
}

void ImGuiNodeEditorComponent::loadPresetFromFile(const juce::File& file)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    // 1. Load the file content.
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);

    // 2. Set the synthesizer's state. This rebuilds the audio graph.
    synth->setStateInformation(mb.getData(), (int)mb.getSize());

    // 3. Parse the XML to find the UI state.
    juce::ValueTree uiState;
    if (auto xml = juce::XmlDocument::parse(mb.toString()))
    {
        auto vt = juce::ValueTree::fromXml(*xml);
        uiState = vt.getChildWithName("NodeEditorUI");
        if (uiState.isValid())
        {
            // 4. Apply the UI state (node positions, muted status, etc.).
            // This queues the changes to be applied on the next frame.
            applyUiValueTree(uiState);
        }
    }

    // 5. Create an undo snapshot for this action.
    Snapshot s;
    synth->getStateInformation(s.synthState);
    s.uiState = uiState.isValid() ? uiState : getUiValueTree();
    undoStack.push_back(std::move(s));
    redoStack.clear();

    // 5. Update the UI status trackers.
    isPatchDirty = false;
    currentPresetFile = file; // Store full file path
    
    // No notification here; the calling function will handle it.
}
void ImGuiNodeEditorComponent::mergePresetFromFile(const juce::File& file, ImVec2 dropPosition)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    auto xml = juce::XmlDocument::parse(file);
    if (xml == nullptr) return;

    juce::ValueTree preset = juce::ValueTree::fromXml(*xml);
    auto modulesVT = preset.getChildWithName("modules");
    auto connectionsVT = preset.getChildWithName("connections");
    auto uiVT = preset.getChildWithName("NodeEditorUI");

    if (!modulesVT.isValid()) return;

    pushSnapshot(); // Create an undo state before we start merging.

    // --- THIS IS THE NEW LOGIC ---
    // 1. Find the top-most Y coordinate of all existing nodes on the canvas.
    float topMostY = FLT_MAX;
    auto currentUiState = getUiValueTree();
    bool canvasHasNodes = false;
    for (int i = 0; i < currentUiState.getNumChildren(); ++i)
    {
        auto nodePosVT = currentUiState.getChild(i);
        if (nodePosVT.hasType("node"))
        {
            canvasHasNodes = true;
            float y = (float)nodePosVT.getProperty("y");
            if (y < topMostY)
            {
                topMostY = y;
            }
        }
    }
    // If the canvas is empty, use the drop position as the reference.
    if (!canvasHasNodes)
    {
        topMostY = dropPosition.y;
    }

    // 2. Find the bounding box of the nodes within the preset we are dropping.
    float presetMinX = FLT_MAX;
    float presetMaxY = -FLT_MAX;
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                float x = (float)nodePosVT.getProperty("x");
                float y = (float)nodePosVT.getProperty("y");
                if (x < presetMinX) presetMinX = x;
                if (y > presetMaxY) presetMaxY = y; // We need the lowest point (max Y) of the preset group.
            }
        }
    }
    
    // 3. Calculate the necessary offsets.
    const float verticalPadding = 100.0f;
    const float yOffset = topMostY - presetMaxY - verticalPadding;
    const float xOffset = dropPosition.x - presetMinX;
    // --- END OF NEW LOGIC ---

    // This map will track how we remap old IDs from the file to new, unique IDs on the canvas.
    std::map<juce::uint32, juce::uint32> oldIdToNewId;

    // First pass: create all the new modules from the preset.
    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleNode = modulesVT.getChild(i);
        if (moduleNode.hasType("module"))
        {
            juce::uint32 oldLogicalId = (juce::uint32)(int)moduleNode.getProperty("logicalId");
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Add the module without committing the graph changes yet.
            auto newNodeId = synth->addModule(type, false);
            juce::uint32 newLogicalId = synth->getLogicalIdForNode(newNodeId);

            oldIdToNewId[oldLogicalId] = newLogicalId; // Store the mapping

            // Restore the new module's parameters and extra state.
            if (auto* proc = synth->getModuleForLogical(newLogicalId))
            {
                auto paramsWrapper = moduleNode.getChildWithName("params");
                if (paramsWrapper.isValid()) proc->getAPVTS().replaceState(paramsWrapper.getChild(0));
                
                auto extraWrapper = moduleNode.getChildWithName("extra");
                if (extraWrapper.isValid()) proc->setExtraStateTree(extraWrapper.getChild(0));
            }
        }
    }

    // Second pass: recreate the internal connections between the new modules.
    if (connectionsVT.isValid())
    {
        for (int i = 0; i < connectionsVT.getNumChildren(); ++i)
        {
            auto connNode = connectionsVT.getChild(i);
            if (connNode.hasType("connection"))
            {
                juce::uint32 oldSrcId = (juce::uint32)(int)connNode.getProperty("srcId");
                int srcChan = (int)connNode.getProperty("srcChan");
                juce::uint32 oldDstId = (juce::uint32)(int)connNode.getProperty("dstId");
                int dstChan = (int)connNode.getProperty("dstChan");

                // Only connect if both source and destination are part of the preset we're merging.
                if (oldIdToNewId.count(oldSrcId) && oldIdToNewId.count(oldDstId))
                {
                    auto newSrcNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldSrcId]);
                    auto newDstNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldDstId]);
                    synth->connect(newSrcNodeId, srcChan, newDstNodeId, dstChan);
                }
            }
        }
    }
    
    // Third pass: Apply UI positions using our new calculated offsets.
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                juce::uint32 oldId = (juce::uint32)(int)nodePosVT.getProperty("id");
                if (oldIdToNewId.count(oldId)) // Check if it's one of our new nodes
                {
                    ImVec2 pos = ImVec2((float)nodePosVT.getProperty("x"), (float)nodePosVT.getProperty("y"));
                    
                    // Apply the smart offsets
                    ImVec2 newPos = ImVec2(pos.x + xOffset, pos.y + yOffset);
                    
                    pendingNodeScreenPositions[(int)oldIdToNewId[oldId]] = newPos;
                }
            }
        }
    }

    // Finally, commit all the changes to the audio graph at once.
    synth->commitChanges();
    isPatchDirty = true; // Mark the patch as edited.
    
    juce::Logger::writeToLog("[Preset] Successfully merged preset: " + file.getFullPathName() + 
                             " above existing nodes with offsets (" + juce::String(xOffset) + ", " + juce::String(yOffset) + ")");
}



================================================================================
FILE: juce/Source/preset_creator/theme/ThemeEditorComponent.cpp
================================================================================

#include "ThemeEditorComponent.h"
#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <imgui.h>
#include <juce_opengl/juce_opengl.h>
#include <cstring>
#if defined(_WIN32)
  #include <windows.h>
  #include <GL/gl.h>
#else
  #include <GL/gl.h>
#endif
#ifndef GL_RGBA
  #define GL_RGBA 0x1908
#endif
#ifndef GL_UNSIGNED_BYTE
  #define GL_UNSIGNED_BYTE 0x1401
#endif

namespace
{
static juce::File resolveFontPath(const juce::String& path)
{
    juce::File file(path);
    if (path.isNotEmpty() && !juce::File::isAbsolutePath(path))
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        file = exeDir.getChildFile(path);
    }
    return file;
}
}

ThemeEditorComponent::ThemeEditorComponent(ImGuiNodeEditorComponent* parent)
    : parentEditor(parent)
{
    // Initialize working copy with current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    syncFontBuffersFromWorkingCopy();
    scanFontFolder();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::open()
{
    m_isOpen = true;
    // Refresh working copy from current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_currentThemeFilename = ThemeManager::getInstance().getCurrentThemeFilename();  // Get current theme filename
    m_hasChanges = false;
    m_currentTab = 0;
    m_showSaveDialog = false;
    memset(m_saveThemeName, 0, sizeof(m_saveThemeName));
    syncFontBuffersFromWorkingCopy();
    scanFontFolder();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::close()
{
    if (m_hasChanges)
    {
        // TODO: Ask for confirmation if there are unsaved changes
        // For now, just discard
    }
    m_isOpen = false;
    m_showSaveDialog = false;
}

void ThemeEditorComponent::refreshThemeFromManager()
{
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_currentThemeFilename = ThemeManager::getInstance().getCurrentThemeFilename();  // Update current theme filename
    m_hasChanges = false;
    juce::Logger::writeToLog("[ThemeEditor] Refreshed working copy from ThemeManager");
    syncFontBuffersFromWorkingCopy();
    scanFontFolder();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::render()
{
    if (!m_isOpen)
        return;

    // Window flags
    ImGuiWindowFlags flags = ImGuiWindowFlags_None;
    
    // Set window size and position
    ImGui::SetNextWindowSize(ImVec2(900, 700), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);

    // Build window title with current theme name
    juce::String windowTitle = "Theme Editor";
    if (m_currentThemeFilename.isNotEmpty())
    {
        // Remove .json extension and format nicely
        juce::String displayName = m_currentThemeFilename;
        if (displayName.endsWithIgnoreCase(".json"))
            displayName = displayName.substring(0, displayName.length() - 5);
        windowTitle += " - " + displayName;
    }
    else
    {
        windowTitle += " - Default Theme";
    }
    
    if (ImGui::Begin(windowTitle.toRawUTF8(), &m_isOpen, flags))
    {
        // Toolbar
        if (ImGui::Button("Apply Changes"))
        {
            applyChanges();
        }
        ImGui::SameLine();
        if (ImGui::Button("Reset Tab"))
        {
            resetCurrentTab();
        }
        ImGui::SameLine();
        
        // Save button (only enabled if editing an existing theme)
        bool hasCurrentTheme = m_currentThemeFilename.isNotEmpty();
        if (!hasCurrentTheme)
            ImGui::BeginDisabled();
        if (ImGui::Button("Save"))
        {
            saveTheme();
        }
        if (!hasCurrentTheme)
            ImGui::EndDisabled();
        
        ImGui::SameLine();
        if (ImGui::Button("Save As..."))
        {
            m_showSaveDialog = true;
            // Pre-fill with current theme name if available, otherwise use "CustomTheme"
            if (m_currentThemeFilename.isNotEmpty())
            {
                juce::String baseName = m_currentThemeFilename;
                if (baseName.endsWithIgnoreCase(".json"))
                    baseName = baseName.substring(0, baseName.length() - 5);
                strncpy(m_saveThemeName, baseName.toRawUTF8(), sizeof(m_saveThemeName) - 1);
            }
            else
            {
                strncpy(m_saveThemeName, "CustomTheme", sizeof(m_saveThemeName) - 1);
            }
        }
        ImGui::SameLine();
        if (m_hasChanges)
        {
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "* Unsaved changes");
        }

        ImGui::Separator();

        // Tabs
        renderTabs();

        // Save dialog (modal)
        if (m_showSaveDialog)
        {
            renderSaveDialog();
        }

        // Eyedropper overlay if active
        renderPickerOverlay();
    }
    ImGui::End();

    // Close if window X clicked (m_isOpen was set to false by ImGui::Begin)
    if (!m_isOpen)
        close();
}

// ---- Eyedropper utilities ----
void ThemeEditorComponent::beginPickColor(ImU32* target)
{
    m_pickerActive = true;
    m_pickTargetU32 = target;
    m_pickTargetVec4 = nullptr;
}

void ThemeEditorComponent::beginPickColor(ImVec4* target)
{
    m_pickerActive = true;
    m_pickTargetU32 = nullptr;
    m_pickTargetVec4 = target;
}

bool ThemeEditorComponent::sampleScreenPixel(int, int, unsigned char outRGBA[4])
{
    // Disabled: pixel picking handled by ImGuiNodeEditorComponent.
    outRGBA[0]=outRGBA[1]=outRGBA[2]=0; outRGBA[3]=255;
    return false;
}

void ThemeEditorComponent::renderPickerOverlay()
{
    // Disabled: handled by node editor (we keep function for compatibility)
    juce::ignoreUnused(m_pickerActive);
}

void ThemeEditorComponent::renderTabs()
{
    if (ImGui::BeginTabBar("ThemeEditorTabs"))
    {
        // Tab buttons
        const char* tabNames[] = {
            "Style", "Colors", "Accent", "Text", "Status", "Headers",
            "ImNodes", "Links", "Canvas", "Layout", "Fonts", "Windows",
            "Modulation", "Meters", "Timeline", "Modules"
        };

        for (int i = 0; i < s_numTabs; ++i)
        {
            if (ImGui::BeginTabItem(tabNames[i]))
            {
                m_currentTab = i;
                
                // Render tab content
                switch (i)
                {
                    case 0: renderImGuiStyleTab(); break;
                    case 1: renderImGuiColorsTab(); break;
                    case 2: renderAccentTab(); break;
                    case 3: renderTextColorsTab(); break;
                    case 4: renderStatusColorsTab(); break;
                    case 5: renderHeaderColorsTab(); break;
                    case 6: renderImNodesTab(); break;
                    case 7: renderLinksTab(); break;
                    case 8: renderCanvasTab(); break;
                    case 9: renderLayoutTab(); break;
                    case 10: renderFontsTab(); break;
                    case 11: renderWindowsTab(); break;
                    case 12: renderModulationTab(); break;
                    case 13: renderMetersTab(); break;
                    case 14: renderTimelineTab(); break;
                    case 15: renderModulesTab(); break;
                }
                
                ImGui::EndTabItem();
            }
        }
        ImGui::EndTabBar();
    }
}

// Helper implementations
bool ThemeEditorComponent::colorEdit4(const char* label, ImVec4& color, ImGuiColorEditFlags flags)
{
    if (!label)
        return false;

    juce::Logger::writeToLog(juce::String("[ThemeColorPicker] Drawing (ImVec4) picker for: ") + label);

    bool valueChanged = false;
    try
    {
        ImGui::PushID(label);
        valueChanged = ImGui::ColorEdit4("##picker", (float*)&color,
                                         ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

        ImGui::SameLine();
        ImGui::TextUnformatted(label);
        ImGui::PopID();

        if (valueChanged)
            m_hasChanges = true;
    }
    catch (const std::exception& e)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] EXCEPTION (ImVec4) for label '") + label + "': " + e.what());
        ImGui::PopID();
        return false;
    }
    catch (...)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] UNKNOWN EXCEPTION (ImVec4) for label '") + label + "'");
        ImGui::PopID();
        return false;
    }

    return valueChanged;
}

bool ThemeEditorComponent::colorEditU32(const char* label, ImU32& color, ImGuiColorEditFlags flags)
{
    if (!label)
        return false;

    juce::Logger::writeToLog(juce::String("[ThemeColorPicker] Drawing (ImU32) picker for: ") + label);

    ImVec4 floatColor;
    bool valueChanged = false;

    try
    {
        ImGui::PushID(label);

        floatColor = ImGui::ColorConvertU32ToFloat4(color);

        valueChanged = ImGui::ColorEdit4("##picker", (float*)&floatColor,
                                         ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

        if (valueChanged)
        {
            color = ImGui::ColorConvertFloat4ToU32(floatColor);
            m_hasChanges = true;
        }

        ImGui::SameLine();
        ImGui::TextUnformatted(label);

        ImGui::PopID();
    }
    catch (const std::exception& e)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] EXCEPTION (ImU32) for label '") + label + "': " + e.what());
        ImGui::PopID();
        return false;
    }
    catch (...)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] UNKNOWN EXCEPTION (ImU32) for label '") + label + "'");
        ImGui::PopID();
        return false;
    }

    return valueChanged;
}

bool ThemeEditorComponent::dragFloat(const char* label, float& value, float speed, float min, float max, const char* format)
{
    bool changed = ImGui::DragFloat(label, &value, speed, min, max, format);
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::dragFloat2(const char* label, ImVec2& value, float speed, float min, float max, const char* format)
{
    bool changed = ImGui::DragFloat2(label, &value.x, speed, min, max, format);
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::triStateColorEdit(const char* label, TriStateColor& tsc)
{
    bool changed = false;
    if (ImGui::TreeNode(label))
    {
        changed |= colorEditU32("Base", tsc.base);
        changed |= colorEditU32("Hovered", tsc.hovered);
        changed |= colorEditU32("Active", tsc.active);
        ImGui::TreePop();
    }
    return changed;
}

// Tab implementations (stubs for now)
void ThemeEditorComponent::renderImGuiStyleTab()
{
    ImGui::Text("ImGui Style Settings");
    ImGui::Separator();
    
    // Split into two columns: controls on left, preview on right
    ImGui::Columns(2, "StyleColumns", true);
    
    // Left column: Controls
    if (ImGui::CollapsingHeader("Padding & Spacing"))
    {
        dragFloat2("Window Padding", m_workingCopy.style.WindowPadding, 1.0f, 0.0f, 50.0f);
        dragFloat2("Frame Padding", m_workingCopy.style.FramePadding, 1.0f, 0.0f, 50.0f);
        dragFloat2("Item Spacing", m_workingCopy.style.ItemSpacing, 1.0f, 0.0f, 50.0f);
        dragFloat2("Item Inner Spacing", m_workingCopy.style.ItemInnerSpacing, 1.0f, 0.0f, 50.0f);
    }
    
    if (ImGui::CollapsingHeader("Rounding"))
    {
        dragFloat("Window Rounding", m_workingCopy.style.WindowRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Child Rounding", m_workingCopy.style.ChildRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Frame Rounding", m_workingCopy.style.FrameRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Popup Rounding", m_workingCopy.style.PopupRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Scrollbar Rounding", m_workingCopy.style.ScrollbarRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Grab Rounding", m_workingCopy.style.GrabRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Tab Rounding", m_workingCopy.style.TabRounding, 0.5f, 0.0f, 20.0f);
    }
    
    if (ImGui::CollapsingHeader("Borders"))
    {
        dragFloat("Window Border Size", m_workingCopy.style.WindowBorderSize, 0.1f, 0.0f, 5.0f);
        dragFloat("Frame Border Size", m_workingCopy.style.FrameBorderSize, 0.1f, 0.0f, 5.0f);
        dragFloat("Popup Border Size", m_workingCopy.style.PopupBorderSize, 0.1f, 0.0f, 5.0f);
    }
    
    ImGui::NextColumn();
    
    // Right column: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Apply working copy style temporarily for preview
    ImGuiStyle& style = ImGui::GetStyle();
    ImGuiStyle backup = style;
    
    style.WindowPadding = m_workingCopy.style.WindowPadding;
    style.FramePadding = m_workingCopy.style.FramePadding;
    style.ItemSpacing = m_workingCopy.style.ItemSpacing;
    style.ItemInnerSpacing = m_workingCopy.style.ItemInnerSpacing;
    style.WindowRounding = m_workingCopy.style.WindowRounding;
    style.ChildRounding = m_workingCopy.style.ChildRounding;
    style.FrameRounding = m_workingCopy.style.FrameRounding;
    style.PopupRounding = m_workingCopy.style.PopupRounding;
    style.ScrollbarRounding = m_workingCopy.style.ScrollbarRounding;
    style.GrabRounding = m_workingCopy.style.GrabRounding;
    style.TabRounding = m_workingCopy.style.TabRounding;
    style.WindowBorderSize = m_workingCopy.style.WindowBorderSize;
    style.FrameBorderSize = m_workingCopy.style.FrameBorderSize;
    style.PopupBorderSize = m_workingCopy.style.PopupBorderSize;
    
    // Preview window
    if (ImGui::BeginChild("StylePreview", ImVec2(0, 0), true))
    {
        ImGui::Text("Preview Window");
        ImGui::Separator();
        
        // Button preview
        if (ImGui::Button("Sample Button"))
        {
            // Button clicked
        }
        ImGui::SameLine();
        if (ImGui::Button("Another Button"))
        {
            // Button clicked
        }
        
        ImGui::Spacing();
        
        // Frame preview
        ImGui::Text("Frame with border:");
        ImGui::BeginChildFrame(ImGui::GetID("preview_frame"), ImVec2(0, 60));
        ImGui::Text("Content inside frame");
        ImGui::Button("Button in Frame");
        ImGui::EndChildFrame();
        
        ImGui::Spacing();
        
        // Tab preview
        if (ImGui::BeginTabBar("PreviewTabs"))
        {
            if (ImGui::BeginTabItem("Tab 1"))
            {
                ImGui::Text("Tab 1 content");
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Tab 2"))
            {
                ImGui::Text("Tab 2 content");
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }
        
        ImGui::Spacing();
        
        // Slider preview
        static float sliderValue = 0.5f;
        ImGui::SliderFloat("Preview Slider", &sliderValue, 0.0f, 1.0f);
        
        ImGui::Spacing();
        
        // Checkbox preview
        static bool check1 = true, check2 = false;
        ImGui::Checkbox("Checkbox 1", &check1);
        ImGui::Checkbox("Checkbox 2", &check2);
        
        ImGui::Spacing();
        
        // Input preview
        static char text[64] = "Sample text";
        ImGui::InputText("Text Input", text, sizeof(text));
    }
    ImGui::EndChild();
    
    // Restore original style
    style = backup;
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderImGuiColorsTab()
{
    ImGui::Text("ImGui Colors");
    ImGui::Separator();
    ImGui::TextWrapped("Edit core ImGui colors. These affect all ImGui windows and widgets.");
    
    ImGui::Columns(2, "ImGuiColorsColumns", true);
    
    // Left: Controls organized by category
    if (ImGui::CollapsingHeader("Window Colors"))
    {
        ImVec4& windowBg = m_workingCopy.style.Colors[ImGuiCol_WindowBg];
        ImVec4& childBg = m_workingCopy.style.Colors[ImGuiCol_ChildBg];
        ImVec4& popupBg = m_workingCopy.style.Colors[ImGuiCol_PopupBg];
        ImVec4& titleBg = m_workingCopy.style.Colors[ImGuiCol_TitleBg];
        ImVec4& titleBgActive = m_workingCopy.style.Colors[ImGuiCol_TitleBgActive];
        ImVec4& titleBgCollapsed = m_workingCopy.style.Colors[ImGuiCol_TitleBgCollapsed];
        
        colorEdit4("Window Background", windowBg);
        colorEdit4("Node Background (ChildBg)", childBg);
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("Controls the background color used for node editors and child regions.");
        colorEdit4("Popup Background", popupBg);
        colorEdit4("Title Background", titleBg);
        colorEdit4("Title Active", titleBgActive);
        colorEdit4("Title Collapsed", titleBgCollapsed);
    }
    
    if (ImGui::CollapsingHeader("Text Colors"))
    {
        ImVec4& text = m_workingCopy.style.Colors[ImGuiCol_Text];
        ImVec4& textDisabled = m_workingCopy.style.Colors[ImGuiCol_TextDisabled];
        ImVec4& textSelectedBg = m_workingCopy.style.Colors[ImGuiCol_TextSelectedBg];
        
        colorEdit4("Text", text);
        colorEdit4("Text Disabled", textDisabled);
        colorEdit4("Text Selected Background", textSelectedBg);
    }
    
    if (ImGui::CollapsingHeader("Button & Frame Colors"))
    {
        ImVec4& button = m_workingCopy.style.Colors[ImGuiCol_Button];
        ImVec4& buttonHovered = m_workingCopy.style.Colors[ImGuiCol_ButtonHovered];
        ImVec4& buttonActive = m_workingCopy.style.Colors[ImGuiCol_ButtonActive];
        ImVec4& frameBg = m_workingCopy.style.Colors[ImGuiCol_FrameBg];
        ImVec4& frameBgHovered = m_workingCopy.style.Colors[ImGuiCol_FrameBgHovered];
        ImVec4& frameBgActive = m_workingCopy.style.Colors[ImGuiCol_FrameBgActive];
        
        colorEdit4("Button", button);
        colorEdit4("Button Hovered", buttonHovered);
        colorEdit4("Button Active", buttonActive);
        colorEdit4("Frame Background", frameBg);
        colorEdit4("Frame Hovered", frameBgHovered);
        colorEdit4("Frame Active", frameBgActive);
    }
    
    if (ImGui::CollapsingHeader("Slider & Scrollbar"))
    {
        ImVec4& sliderGrab = m_workingCopy.style.Colors[ImGuiCol_SliderGrab];
        ImVec4& sliderGrabActive = m_workingCopy.style.Colors[ImGuiCol_SliderGrabActive];
        ImVec4& scrollbarBg = m_workingCopy.style.Colors[ImGuiCol_ScrollbarBg];
        ImVec4& scrollbarGrab = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrab];
        ImVec4& scrollbarGrabHovered = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrabHovered];
        ImVec4& scrollbarGrabActive = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrabActive];
        
        colorEdit4("Slider Grab", sliderGrab);
        colorEdit4("Slider Grab Active", sliderGrabActive);
        colorEdit4("Scrollbar Background", scrollbarBg);
        colorEdit4("Scrollbar Grab", scrollbarGrab);
        colorEdit4("Scrollbar Grab Hovered", scrollbarGrabHovered);
        colorEdit4("Scrollbar Grab Active", scrollbarGrabActive);
    }
    
    if (ImGui::CollapsingHeader("Border & Separator"))
    {
        ImVec4& border = m_workingCopy.style.Colors[ImGuiCol_Border];
        ImVec4& borderShadow = m_workingCopy.style.Colors[ImGuiCol_BorderShadow];
        ImVec4& separator = m_workingCopy.style.Colors[ImGuiCol_Separator];
        ImVec4& separatorHovered = m_workingCopy.style.Colors[ImGuiCol_SeparatorHovered];
        ImVec4& separatorActive = m_workingCopy.style.Colors[ImGuiCol_SeparatorActive];
        
        colorEdit4("Border", border);
        colorEdit4("Border Shadow", borderShadow);
        colorEdit4("Separator", separator);
        colorEdit4("Separator Hovered", separatorHovered);
        colorEdit4("Separator Active", separatorActive);
    }
    
    if (ImGui::CollapsingHeader("Tab & Menu"))
    {
        ImVec4& tab = m_workingCopy.style.Colors[ImGuiCol_Tab];
        ImVec4& tabHovered = m_workingCopy.style.Colors[ImGuiCol_TabHovered];
        ImVec4& tabActive = m_workingCopy.style.Colors[ImGuiCol_TabActive];
        ImVec4& tabUnfocused = m_workingCopy.style.Colors[ImGuiCol_TabUnfocused];
        ImVec4& tabUnfocusedActive = m_workingCopy.style.Colors[ImGuiCol_TabUnfocusedActive];
        ImVec4& menuBarBg = m_workingCopy.style.Colors[ImGuiCol_MenuBarBg];
        
        colorEdit4("Tab", tab);
        colorEdit4("Tab Hovered", tabHovered);
        colorEdit4("Tab Active", tabActive);
        colorEdit4("Tab Unfocused", tabUnfocused);
        colorEdit4("Tab Unfocused Active", tabUnfocusedActive);
        colorEdit4("Menu Bar Background", menuBarBg);
    }
    
    if (ImGui::CollapsingHeader("Other"))
    {
        ImVec4& checkMark = m_workingCopy.style.Colors[ImGuiCol_CheckMark];
        ImVec4& dragDropTarget = m_workingCopy.style.Colors[ImGuiCol_DragDropTarget];
        ImVec4& header = m_workingCopy.style.Colors[ImGuiCol_Header];
        ImVec4& headerHovered = m_workingCopy.style.Colors[ImGuiCol_HeaderHovered];
        ImVec4& headerActive = m_workingCopy.style.Colors[ImGuiCol_HeaderActive];
        ImVec4& resizeGrip = m_workingCopy.style.Colors[ImGuiCol_ResizeGrip];
        ImVec4& resizeGripHovered = m_workingCopy.style.Colors[ImGuiCol_ResizeGripHovered];
        ImVec4& resizeGripActive = m_workingCopy.style.Colors[ImGuiCol_ResizeGripActive];
        
        colorEdit4("Check Mark", checkMark);
        colorEdit4("Drag Drop Target", dragDropTarget);
        colorEdit4("Header", header);
        colorEdit4("Header Hovered", headerHovered);
        colorEdit4("Header Active", headerActive);
        colorEdit4("Resize Grip", resizeGrip);
        colorEdit4("Resize Grip Hovered", resizeGripHovered);
        colorEdit4("Resize Grip Active", resizeGripActive);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Apply working copy colors temporarily for preview
    ImGuiStyle& style = ImGui::GetStyle();
    ImGuiStyle backup = style;
    style = m_workingCopy.style;
    
    if (ImGui::BeginChild("ImGuiColorsPreview", ImVec2(0, 0), true))
    {
        // Window preview
        ImGui::Text("Window Preview");
        ImGui::Separator();
        
        if (ImGui::Button("Sample Button"))
        {
            // Button clicked
        }
        ImGui::SameLine();
        if (ImGui::Button("Another Button"))
        {
            // Button clicked
        }
        
        ImGui::Spacing();
        
        // Frame preview
        ImGui::Text("Frame with border:");
        ImGui::BeginChildFrame(ImGui::GetID("preview_frame2"), ImVec2(0, 60));
        ImGui::Text("Content inside frame");
        ImGui::Button("Button in Frame");
        ImGui::EndChildFrame();
        
        ImGui::Spacing();
        
        // Slider preview
        static float sliderValue = 0.5f;
        ImGui::SliderFloat("Preview Slider", &sliderValue, 0.0f, 1.0f);
        
        ImGui::Spacing();
        
        // Checkbox preview
        static bool check1 = true, check2 = false;
        ImGui::Checkbox("Checkbox 1", &check1);
        ImGui::Checkbox("Checkbox 2", &check2);
        
        ImGui::Spacing();
        
        // Input preview
        static char text[64] = "Sample text";
        ImGui::InputText("Text Input", text, sizeof(text));
        
        ImGui::Spacing();
        
        // Tab preview
        if (ImGui::BeginTabBar("PreviewTabs2"))
        {
            if (ImGui::BeginTabItem("Tab 1"))
            {
                ImGui::Text("Tab 1 content");
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Tab 2"))
            {
                ImGui::Text("Tab 2 content");
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }
    }
    ImGui::EndChild();
    
    // Restore original style
    style = backup;
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderAccentTab()
{
    ImGui::Text("Accent Color");
    ImGui::Separator();
    ImGui::TextWrapped("The accent color is used throughout the UI for highlights and interactive elements.");
    
    ImGui::Columns(2, "AccentColumns", true);
    
    // Left: Color picker
    colorEdit4("Accent", m_workingCopy.accent);
    
    ImGui::Spacing();
    ImGui::Text("RGB Values:");
    ImGui::Text("R: %.3f", m_workingCopy.accent.x);
    ImGui::Text("G: %.3f", m_workingCopy.accent.y);
    ImGui::Text("B: %.3f", m_workingCopy.accent.z);
    ImGui::Text("A: %.3f", m_workingCopy.accent.w);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Large color swatch
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.accent));
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + ImGui::GetStyle().ItemSpacing.y));
    
    ImGui::Spacing();
    
    // Preview accent in UI elements
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_CheckMark, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_SliderGrabActive, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_TabHovered, ImVec4(m_workingCopy.accent.x, m_workingCopy.accent.y, m_workingCopy.accent.z, 0.8f));
    
    if (ImGui::Button("Button (hovered color)"))
    {
        // Button clicked
    }
    
    static bool previewCheck = true;
    ImGui::Checkbox("Checkbox (checkmark color)", &previewCheck);
    
    static float previewSlider = 0.5f;
    ImGui::SliderFloat("Slider (grab color)", &previewSlider, 0.0f, 1.0f);
    
    if (ImGui::BeginTabBar("AccentTabs"))
    {
        if (ImGui::BeginTabItem("Tab (hover)"))
        {
            ImGui::Text("Tab content");
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }
    
    ImGui::PopStyleColor(4);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderTextColorsTab()
{
    ImGui::Text("Text Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "TextColorsColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Text Colors"))
    {
        colorEdit4("Section Header", m_workingCopy.text.section_header);
        colorEdit4("Warning", m_workingCopy.text.warning);
        colorEdit4("Success", m_workingCopy.text.success);
        colorEdit4("Error", m_workingCopy.text.error);
        colorEdit4("Disabled", m_workingCopy.text.disabled);
        colorEdit4("Active", m_workingCopy.text.active);
    }
    
    if (ImGui::CollapsingHeader("Tooltip Settings"))
    {
        dragFloat("Tooltip Wrap (Standard)", m_workingCopy.text.tooltip_wrap_standard, 1.0f, 10.0f, 100.0f);
        dragFloat("Tooltip Wrap (Compact)", m_workingCopy.text.tooltip_wrap_compact, 1.0f, 10.0f, 100.0f);
    }
    
    if (ImGui::CollapsingHeader("Text Rendering"))
    {
        // Add the master toggle checkbox
        if (ImGui::Checkbox("Enable Text Glow / Shadow", &m_workingCopy.text.enable_text_glow))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enable a soft shadow/glow effect for all themed text");
        
        // Add the color picker for the glow
        colorEdit4("Glow / Shadow Color", m_workingCopy.text.text_glow_color);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImGui::TextColored(m_workingCopy.text.section_header, "Section Header Text");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.warning, "âš  Warning Message");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.success, "âœ“ Success Message");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.error, "âœ— Error Message");
    ImGui::Spacing();
    
    ImGui::PushStyleColor(ImGuiCol_Text, m_workingCopy.text.disabled);
    ImGui::Text("Disabled Text (grayed out)");
    ImGui::PopStyleColor();
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.active, "â— Active/Enabled Text");
    ImGui::Spacing();
    
    ImGui::Separator();
    ImGui::Text("Tooltip Preview:");
    ImGui::TextDisabled("(Hover over this text)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * m_workingCopy.text.tooltip_wrap_standard);
        ImGui::Text("This is a tooltip with the wrap width you set. It demonstrates how tooltips will wrap at the specified character count.");
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderStatusColorsTab()
{
    ImGui::Text("Status Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "StatusColumns", true);
    
    // Left: Controls
    colorEdit4("Edited", m_workingCopy.status.edited);
    colorEdit4("Saved", m_workingCopy.status.saved);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImGui::Text("Status: ");
    ImGui::SameLine();
    ImGui::TextColored(m_workingCopy.status.edited, "EDITED");
    
    ImGui::Spacing();
    
    ImGui::Text("Status: ");
    ImGui::SameLine();
    ImGui::TextColored(m_workingCopy.status.saved, "SAVED");
    
    ImGui::Spacing();
    ImGui::Separator();
    
    // Preview as overlay-style status indicator
    ImGui::BeginChild("StatusPreview", ImVec2(0, 80), true);
    ImGui::SetCursorPos(ImVec2(10, 10));
    ImGui::TextColored(m_workingCopy.status.edited, "Status: EDITED");
    
    ImGui::SetCursorPos(ImVec2(10, 40));
    ImGui::TextColored(m_workingCopy.status.saved, "Status: SAVED");
    ImGui::EndChild();
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderHeaderColorsTab()
{
    ImGui::Text("Header Colors (TriState)");
    ImGui::Separator();
    
    ImGui::Columns(2, "HeaderColumns", true);
    
    // Left: Controls
    triStateColorEdit("Recent", m_workingCopy.headers.recent);
    triStateColorEdit("Samples", m_workingCopy.headers.samples);
    triStateColorEdit("Presets", m_workingCopy.headers.presets);
    triStateColorEdit("System", m_workingCopy.headers.system);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Preview Recent header
    ImVec2 pos = ImGui::GetCursorScreenPos();
    ImVec2 size = ImVec2(ImGui::GetContentRegionAvail().x, 30);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview Samples header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.samples.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Samples (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview Presets header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.presets.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Presets (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview System header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.system.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("System (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Text("Hover states:");
    
    // Hover preview
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.hovered);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Hovered)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.active);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Active)");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderImNodesTab()
{
    ImGui::Text("ImNodes Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ImNodesColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Category Colors"))
    {
        // Module categories
        const char* categoryNames[] = {
            "Source", "Effect", "Modulator", "Utility", "Seq", "MIDI",
            "Analysis", "TTS_Voice", "Special_Exp", "OpenCV", "Sys", "Comment", "Plugin", "Default"
        };
        
        ModuleCategory categories[] = {
            ModuleCategory::Source, ModuleCategory::Effect, ModuleCategory::Modulator,
            ModuleCategory::Utility, ModuleCategory::Seq, ModuleCategory::MIDI,
            ModuleCategory::Analysis, ModuleCategory::TTS_Voice, ModuleCategory::Special_Exp,
            ModuleCategory::OpenCV, ModuleCategory::Sys, ModuleCategory::Comment,
            ModuleCategory::Plugin, ModuleCategory::Default
        };
        
        for (int i = 0; i < 14; ++i)
        {
            ImU32& color = m_workingCopy.imnodes.category_colors[categories[i]];
            if (colorEditU32(categoryNames[i], color))
            {
                m_hasChanges = true;
            }
        }
    }
    
    if (ImGui::CollapsingHeader("Pin Colors"))
    {
        // Pin data types
        const char* pinTypeNames[] = { "CV", "Audio", "Gate", "Raw", "Video" };
        PinDataType pinTypes[] = {
            PinDataType::CV, PinDataType::Audio, PinDataType::Gate,
            PinDataType::Raw, PinDataType::Video
        };
        
        for (int i = 0; i < 5; ++i)
        {
            ImU32& color = m_workingCopy.imnodes.pin_colors[pinTypes[i]];
            if (colorEditU32(pinTypeNames[i], color))
            {
                m_hasChanges = true;
            }
        }
        
        ImGui::Separator();
        colorEditU32("Pin Connected", m_workingCopy.imnodes.pin_connected);
        colorEditU32("Pin Disconnected", m_workingCopy.imnodes.pin_disconnected);
    }
    
    if (ImGui::CollapsingHeader("Node States"))
    {
        colorEditU32("Node Muted", m_workingCopy.imnodes.node_muted);
        dragFloat("Node Muted Alpha", m_workingCopy.imnodes.node_muted_alpha, 0.01f, 0.0f, 1.0f);
        colorEditU32("Node Hovered Link Highlight", m_workingCopy.imnodes.node_hovered_link_highlight);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 300);
    
    // Draw category color previews
    ImGui::Text("Category Colors:");
    float y = canvasPos.y + 20;
    float boxSize = 20.0f;
    float spacing = 5.0f;
    
    const char* categoryNames[] = {
        "Source", "Effect", "Modulator", "Utility", "Seq", "MIDI",
        "Analysis", "TTS_Voice", "Special_Exp", "OpenCV", "Sys", "Comment", "Plugin", "Default"
    };
    
    ModuleCategory categories[] = {
        ModuleCategory::Source, ModuleCategory::Effect, ModuleCategory::Modulator,
        ModuleCategory::Utility, ModuleCategory::Seq, ModuleCategory::MIDI,
        ModuleCategory::Analysis, ModuleCategory::TTS_Voice, ModuleCategory::Special_Exp,
        ModuleCategory::OpenCV, ModuleCategory::Sys, ModuleCategory::Comment,
        ModuleCategory::Plugin, ModuleCategory::Default
    };
    
    for (int i = 0; i < 14; ++i)
    {
        float x = canvasPos.x + (i % 7) * (boxSize + spacing + 60);
        float rowY = y + (i / 7) * (boxSize + spacing + 15);
        
        ImU32 color = m_workingCopy.imnodes.category_colors[categories[i]];
        drawList->AddRectFilled(ImVec2(x, rowY), ImVec2(x + boxSize, rowY + boxSize), color);
        drawList->AddRect(ImVec2(x, rowY), ImVec2(x + boxSize, rowY + boxSize), IM_COL32(100, 100, 100, 255));
        ImGui::SetCursorScreenPos(ImVec2(x + boxSize + 5, rowY));
        ImGui::Text("%s", categoryNames[i]);
    }
    
    y += 80;
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, y));
    ImGui::Text("Pin Colors:");
    y += 20;
    
    // Draw pin color previews
    const char* pinTypeNames[] = { "CV", "Audio", "Gate", "Raw", "Video" };
    PinDataType pinTypes[] = {
        PinDataType::CV, PinDataType::Audio, PinDataType::Gate,
        PinDataType::Raw, PinDataType::Video
    };
    
    for (int i = 0; i < 5; ++i)
    {
        float x = canvasPos.x + i * 80;
        ImU32 color = m_workingCopy.imnodes.pin_colors[pinTypes[i]];
        
        // Draw pin circle
        ImVec2 center = ImVec2(x + 15, y + 10);
        drawList->AddCircleFilled(center, 8.0f, color, 0);
        drawList->AddCircle(center, 8.0f, IM_COL32(100, 100, 100, 255), 0, 1.0f);
        
        ImGui::SetCursorScreenPos(ImVec2(x, y + 25));
        ImGui::Text("%s", pinTypeNames[i]);
    }
    
    y += 60;
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, y));
    
    // Node muted preview
    ImGui::Text("Node Muted Preview:");
    ImVec2 nodePos = ImVec2(canvasPos.x, y + 20);
    ImVec2 nodeSize = ImVec2(150, 60);
    ImU32 nodeColor = m_workingCopy.imnodes.node_muted;
    ImU32 nodeColorAlpha = IM_COL32(
        (int)((nodeColor & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        (int)(((nodeColor >> 8) & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        (int)(((nodeColor >> 16) & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        255
    );
    drawList->AddRectFilled(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), nodeColorAlpha);
    drawList->AddRect(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), IM_COL32(100, 100, 100, 255));
    ImGui::SetCursorScreenPos(ImVec2(nodePos.x + 5, nodePos.y + 20));
    ImGui::Text("Muted Node");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderLinksTab()
{
    ImGui::Text("Link Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "LinksColumns", true);
    
    // Left: Controls
    colorEditU32("Link Hovered", m_workingCopy.links.link_hovered);
    colorEditU32("Link Selected", m_workingCopy.links.link_selected);
    colorEditU32("Link Highlighted", m_workingCopy.links.link_highlighted);
    colorEditU32("Preview Color", m_workingCopy.links.preview_color);
    dragFloat("Preview Width", m_workingCopy.links.preview_width, 0.1f, 1.0f, 10.0f);
    colorEditU32("Label Background", m_workingCopy.links.label_background);
    colorEditU32("Label Text", m_workingCopy.links.label_text);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    
    // Draw link previews
    float y = canvasPos.y;
    float x = canvasPos.x + 20;
    
    // Hovered link
    ImVec2 p1 = ImVec2(x, y + 20);
    ImVec2 p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_hovered, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Hovered Link");
    
    // Selected link
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_selected, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Selected Link");
    
    // Highlighted link
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_highlighted, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Highlighted Link");
    
    // Preview color
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.preview_color, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Preview Color");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    // Label preview
    ImGui::Text("Link Label Preview:");
    ImVec2 labelPos = ImGui::GetCursorScreenPos();
    ImVec2 labelSize = ImVec2(120, 30);
    drawList->AddRectFilled(labelPos, ImVec2(labelPos.x + labelSize.x, labelPos.y + labelSize.y), 
                           m_workingCopy.links.label_background);
    ImGui::SetCursorScreenPos(ImVec2(labelPos.x + 5, labelPos.y + 8));
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(m_workingCopy.links.label_text));
    ImGui::Text("Link Label");
    ImGui::PopStyleColor();
    ImGui::SetCursorScreenPos(ImVec2(labelPos.x, labelPos.y + labelSize.y + 5));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderCanvasTab()
{
    ImGui::Text("Canvas Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "CanvasColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Canvas Background"))
    {
        colorEditU32("Canvas Background", m_workingCopy.canvas.canvas_background);
    }
    
    if (ImGui::CollapsingHeader("Grid Settings"))
    {
        colorEditU32("Grid Color", m_workingCopy.canvas.grid_color);
        colorEditU32("Grid Origin Color", m_workingCopy.canvas.grid_origin_color);
        dragFloat("Grid Size", m_workingCopy.canvas.grid_size, 1.0f, 10.0f, 200.0f);
        colorEditU32("Scale Text Color", m_workingCopy.canvas.scale_text_color);
        dragFloat("Scale Interval", m_workingCopy.canvas.scale_interval, 10.0f, 50.0f, 1000.0f);
    }
    
    if (ImGui::CollapsingHeader("Overlays & UI"))
    {
        colorEditU32("Drop Target Overlay", m_workingCopy.canvas.drop_target_overlay);
        colorEditU32("Mouse Position Text", m_workingCopy.canvas.mouse_position_text);
    }
    
    if (ImGui::CollapsingHeader("Node Styling"))
    {
        colorEditU32("Node Background", m_workingCopy.canvas.node_background);
        colorEditU32("Node Frame", m_workingCopy.canvas.node_frame);
        colorEditU32("Node Frame Hovered", m_workingCopy.canvas.node_frame_hovered);
        colorEditU32("Node Frame Selected", m_workingCopy.canvas.node_frame_selected);
        dragFloat("Node Rounding", m_workingCopy.canvas.node_rounding, 0.1f, 0.0f, 20.0f);
        dragFloat("Node Border Width", m_workingCopy.canvas.node_border_width, 0.1f, 0.0f, 10.0f);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 300);
    
    // Draw canvas background
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           m_workingCopy.canvas.canvas_background);
    
    // Draw grid preview
    float gridSize = m_workingCopy.canvas.grid_size;
    float scaleInterval = m_workingCopy.canvas.scale_interval;
    
    // Draw grid lines
    for (float x = canvasPos.x; x < canvasPos.x + canvasSize.x; x += gridSize)
    {
        drawList->AddLine(ImVec2(x, canvasPos.y), ImVec2(x, canvasPos.y + canvasSize.y), 
                         m_workingCopy.canvas.grid_color);
    }
    for (float y = canvasPos.y; y < canvasPos.y + canvasSize.y; y += gridSize)
    {
        drawList->AddLine(ImVec2(canvasPos.x, y), ImVec2(canvasPos.x + canvasSize.x, y), 
                         m_workingCopy.canvas.grid_color);
    }
    
    // Draw origin (center)
    ImVec2 center = ImVec2(canvasPos.x + canvasSize.x * 0.5f, canvasPos.y + canvasSize.y * 0.5f);
    drawList->AddCircle(center, 3.0f, m_workingCopy.canvas.grid_origin_color, 0, 2.0f);
    drawList->AddLine(ImVec2(center.x - 10, center.y), ImVec2(center.x + 10, center.y), 
                     m_workingCopy.canvas.grid_origin_color, 2.0f);
    drawList->AddLine(ImVec2(center.x, center.y - 10), ImVec2(center.x, center.y + 10), 
                     m_workingCopy.canvas.grid_origin_color, 2.0f);
    
    // Draw scale markers
    for (float x = canvasPos.x; x < canvasPos.x + canvasSize.x; x += scaleInterval)
    {
        ImVec2 textPos = ImVec2(x, canvasPos.y + 5);
        char label[32];
        snprintf(label, sizeof(label), "%.0f", (x - canvasPos.x));
        drawList->AddText(textPos, m_workingCopy.canvas.scale_text_color, label);
    }
    
    // Draw drop target overlay preview
    ImVec2 dropPos = ImVec2(canvasPos.x + canvasSize.x * 0.3f, canvasPos.y + canvasSize.y * 0.3f);
    ImVec2 dropSize = ImVec2(80, 60);
    drawList->AddRectFilled(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), 
                           m_workingCopy.canvas.drop_target_overlay);
    drawList->AddRect(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), 
                     m_workingCopy.canvas.drop_target_overlay, 0.0f, 0, 2.0f);
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    // Mouse position text preview
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(m_workingCopy.canvas.mouse_position_text));
    ImGui::Text("Mouse: 1234, 567");
    ImGui::PopStyleColor();
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    // Node preview
    ImGui::Text("Node Preview");
    ImVec2 nodePreviewPos = ImGui::GetCursorScreenPos();
    ImVec2 nodeSize = ImVec2(150, 80);
    ImVec2 nodeMin = ImVec2(nodePreviewPos.x + 20, nodePreviewPos.y + 20);
    ImVec2 nodeMax = ImVec2(nodeMin.x + nodeSize.x, nodeMin.y + nodeSize.y);
    
    // Draw node background
    drawList->AddRectFilled(nodeMin, nodeMax, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    
    // Draw node frame (normal state)
    drawList->AddRect(nodeMin, nodeMax, m_workingCopy.canvas.node_frame, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    
    // Draw node title bar
    ImVec2 titleBarMin = nodeMin;
    ImVec2 titleBarMax = ImVec2(nodeMax.x, nodeMin.y + 25);
    drawList->AddRectFilled(titleBarMin, titleBarMax, m_workingCopy.canvas.node_frame, m_workingCopy.canvas.node_rounding);
    
    drawList->AddText(ImVec2(nodeMin.x + 8, nodeMin.y + 5), IM_COL32(255, 255, 255, 255), "Example Node");
    
    // Draw hovered state preview (second node)
    ImVec2 node2Min = ImVec2(nodePreviewPos.x + 200, nodePreviewPos.y + 20);
    ImVec2 node2Max = ImVec2(node2Min.x + nodeSize.x, node2Min.y + nodeSize.y);
    drawList->AddRectFilled(node2Min, node2Max, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    drawList->AddRect(node2Min, node2Max, m_workingCopy.canvas.node_frame_hovered, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    drawList->AddRectFilled(node2Min, ImVec2(node2Max.x, node2Min.y + 25), m_workingCopy.canvas.node_frame_hovered, m_workingCopy.canvas.node_rounding);
    drawList->AddText(ImVec2(node2Min.x + 8, node2Min.y + 5), IM_COL32(255, 255, 255, 255), "Hovered");
    
    // Draw selected state preview (third node)
    ImVec2 node3Min = ImVec2(nodePreviewPos.x + 380, nodePreviewPos.y + 20);
    ImVec2 node3Max = ImVec2(node3Min.x + nodeSize.x, node3Min.y + nodeSize.y);
    drawList->AddRectFilled(node3Min, node3Max, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    drawList->AddRect(node3Min, node3Max, m_workingCopy.canvas.node_frame_selected, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    drawList->AddRectFilled(node3Min, ImVec2(node3Max.x, node3Min.y + 25), m_workingCopy.canvas.node_frame_selected, m_workingCopy.canvas.node_rounding);
    drawList->AddText(ImVec2(node3Min.x + 8, node3Min.y + 5), IM_COL32(255, 255, 255, 255), "Selected");
    
    ImGui::SetCursorScreenPos(ImVec2(nodePreviewPos.x, nodePreviewPos.y + nodeSize.y + 40));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderLayoutTab()
{
    ImGui::Text("Layout Settings");
    ImGui::Separator();
    
    ImGui::Columns(2, "LayoutColumns", true);
    
    // Left: Controls
    dragFloat("Sidebar Width", m_workingCopy.layout.sidebar_width, 1.0f, 100.0f, 500.0f);
    dragFloat("Window Padding", m_workingCopy.layout.window_padding, 1.0f, 0.0f, 50.0f);
    dragFloat("Node Vertical Padding", m_workingCopy.layout.node_vertical_padding, 1.0f, 0.0f, 200.0f);
    dragFloat("Preset Vertical Padding", m_workingCopy.layout.preset_vertical_padding, 1.0f, 0.0f, 300.0f);
    dragFloat("Node Default Width", m_workingCopy.layout.node_default_width, 1.0f, 100.0f, 1000.0f);
    dragFloat2("Node Default Padding", m_workingCopy.layout.node_default_padding, 1.0f, 0.0f, 50.0f);
    dragFloat2("Node Muted Padding", m_workingCopy.layout.node_muted_padding, 1.0f, 0.0f, 50.0f);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 250);
    
    // Draw sidebar
    float sidebarWidth = m_workingCopy.layout.sidebar_width;
    if (sidebarWidth > canvasSize.x * 0.4f) sidebarWidth = canvasSize.x * 0.4f; // Limit for preview
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + sidebarWidth, canvasPos.y + canvasSize.y), 
                           IM_COL32(40, 40, 40, 255));
    drawList->AddLine(ImVec2(canvasPos.x + sidebarWidth, canvasPos.y), 
                     ImVec2(canvasPos.x + sidebarWidth, canvasPos.y + canvasSize.y), 
                     IM_COL32(60, 60, 60, 255), 1.0f);
    
    // Draw main area with padding
    float padding = m_workingCopy.layout.window_padding;
    ImVec2 mainAreaStart = ImVec2(canvasPos.x + sidebarWidth + padding, canvasPos.y + padding);
    ImVec2 mainAreaSize = ImVec2(canvasSize.x - sidebarWidth - padding * 2, canvasSize.y - padding * 2);
    
    // Draw node preview
    float nodeWidth = m_workingCopy.layout.node_default_width;
    if (nodeWidth > mainAreaSize.x * 0.8f) nodeWidth = mainAreaSize.x * 0.8f;
    float nodeHeight = 60.0f;
    ImVec2 nodePos = ImVec2(mainAreaStart.x + m_workingCopy.layout.node_default_padding.x, 
                           mainAreaStart.y + m_workingCopy.layout.node_default_padding.y);
    ImVec2 nodeSize = ImVec2(nodeWidth, nodeHeight);
    
    drawList->AddRectFilled(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), 
                           IM_COL32(50, 50, 50, 255));
    drawList->AddRect(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), 
                     IM_COL32(100, 100, 100, 255), 0.0f, 0, 1.0f);
    
    // Draw second node with vertical padding
    ImVec2 node2Pos = ImVec2(nodePos.x, 
                             nodePos.y + nodeHeight + m_workingCopy.layout.node_vertical_padding);
    drawList->AddRectFilled(node2Pos, ImVec2(node2Pos.x + nodeSize.x, node2Pos.y + nodeSize.y), 
                           IM_COL32(50, 50, 50, 255));
    drawList->AddRect(node2Pos, ImVec2(node2Pos.x + nodeSize.x, node2Pos.y + nodeSize.y), 
                     IM_COL32(100, 100, 100, 255), 0.0f, 0, 1.0f);
    
    // Labels
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x + 5, canvasPos.y + 5));
    ImGui::Text("Sidebar");
    
    ImGui::SetCursorScreenPos(ImVec2(nodePos.x + 5, nodePos.y + 5));
    ImGui::Text("Node");
    
    ImGui::SetCursorScreenPos(ImVec2(node2Pos.x + 5, node2Pos.y + 5));
    ImGui::Text("Node");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    ImGui::Text("Sidebar: %.0fpx | Node Width: %.0fpx | Padding: %.0fpx", 
                m_workingCopy.layout.sidebar_width, 
                m_workingCopy.layout.node_default_width,
                m_workingCopy.layout.window_padding);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderFontsTab()
{
    ImGui::Text("Font Settings");
    ImGui::Separator();
    ImGui::TextWrapped("Select a font from the bundled 'fonts' folder or browse for a custom font. Click 'Apply Changes' to rebuild the font atlas.");

    ImGui::Spacing();

    if (ImGui::CollapsingHeader("Default Font", ImGuiTreeNodeFlags_DefaultOpen))
    {
        ImGui::Text("Scanned Fonts (from 'fonts' folder')");

        juce::String selectionLabel = "<None (ImGui Default)>";
        const juce::String currentPath = m_workingCopy.fonts.default_path;

        if (m_selectedFontIndex >= 0 && m_selectedFontIndex < m_scannedFontFiles.size())
        {
            selectionLabel = juce::File(m_scannedFontFiles[m_selectedFontIndex]).getFileName();
        }
        else if (currentPath.isNotEmpty())
        {
            selectionLabel = juce::File(currentPath).getFileName();
        }

        float availableWidth = ImGui::GetContentRegionAvail().x;
        float comboWidth = availableWidth - 70.0f;
        if (comboWidth < 150.0f)
            comboWidth = availableWidth;

        ImGui::SetNextItemWidth(comboWidth);
        if (ImGui::BeginCombo("##DefaultFontCombo", selectionLabel.toRawUTF8()))
        {
            const bool defaultSelected = (m_selectedFontIndex == -1 && currentPath.isEmpty());
            if (ImGui::Selectable("<None (ImGui Default)>", defaultSelected))
            {
                m_selectedFontIndex = -1;
                m_workingCopy.fonts.default_path.clear();
                m_hasChanges = true;
                previewFontChanges();
            }
            if (defaultSelected)
                ImGui::SetItemDefaultFocus();

            for (int i = 0; i < m_scannedFontFiles.size(); ++i)
            {
                const bool isSelected = (m_selectedFontIndex == i);
                juce::String filename = juce::File(m_scannedFontFiles[i]).getFileName();

                if (ImGui::Selectable(filename.toRawUTF8(), isSelected))
                {
                    m_selectedFontIndex = i;
                    m_workingCopy.fonts.default_path = m_scannedFontFiles[i];
                    m_hasChanges = true;
                    previewFontChanges();
                }

                if (isSelected)
                    ImGui::SetItemDefaultFocus();
            }

            ImGui::EndCombo();
        }

        ImGui::SameLine();
        if (ImGui::Button("Scan"))
        {
            scanFontFolder();
            m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
        }

        ImGui::Spacing();
        if (ImGui::Button("Browse for other font..."))
        {
            auto fontsFolder = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory().getChildFile("fonts");
            juce::File initialDir = fontsFolder.exists() ? fontsFolder : juce::File();
            m_fontChooser = std::make_unique<juce::FileChooser>("Select custom font", initialDir, "*.ttf;*.otf;*.ttc");

            auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;
            m_fontChooser->launchAsync(chooserFlags,
                                       [this](const juce::FileChooser& fc)
                                       {
                                           auto file = fc.getResult();
                                           if (file.existsAsFile())
                                           {
                                               m_workingCopy.fonts.default_path = file.getFullPathName();
                                               m_hasChanges = true;
                                               m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
                                               previewFontChanges();
                                           }
                                       });
        }

        ImGui::Spacing();
        if (dragFloat("Default Font Size", m_workingCopy.fonts.default_size, 0.5f, 8.0f, 72.0f))
        {
            if (ImGui::IsItemDeactivatedAfterEdit())
                previewFontChanges();
        }
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    ImGui::Text("Preview");
    ImGui::BeginChild("FontPreview", ImVec2(0, 200), true);

    const float baseSize = ImGui::GetFontSize();
    const float desiredSize = m_workingCopy.fonts.default_size;
    const float scale = (baseSize > 0.0f) ? (desiredSize / baseSize) : 1.0f;
    ImGui::SetWindowFontScale(scale);

    ImGui::Text("Default Font Size (%.1f):", m_workingCopy.fonts.default_size);
    ImGui::Text("The quick brown fox jumps over the lazy dog.");
    ImGui::Text("0123456789 !@#$%%^&*()");

    ImGui::SetWindowFontScale(1.0f);
    ImGui::EndChild();
}

void ThemeEditorComponent::renderWindowsTab()
{
    ImGui::Text("Window Settings");
    ImGui::Separator();
    
    ImGui::Columns(2, "WindowsColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Window Transparency"))
    {
        // Slider for the main Status Overlay
        if (ImGui::SliderFloat("Status Overlay", &m_workingCopy.windows.status_overlay_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for the 'Status: EDITED' overlay");
        
        // Slider for the Probe Scope
        if (ImGui::SliderFloat("Probe Scope", &m_workingCopy.windows.probe_scope_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for the ðŸ”¬ Probe Scope window");
        
        // Slider for Notifications
        if (ImGui::SliderFloat("Notifications", &m_workingCopy.windows.notifications_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for pop-up notifications (Success, Error, etc.)");
        
        // Slider for Preset Status (kept for backward compatibility)
        if (ImGui::SliderFloat("Preset Status", &m_workingCopy.windows.preset_status_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for the Preset Status overlay");
    }
    
    if (ImGui::CollapsingHeader("Probe Scope Size"))
    {
        dragFloat("Probe Scope Width", m_workingCopy.windows.probe_scope_width, 1.0f, 100.0f, 500.0f);
        dragFloat("Probe Scope Height", m_workingCopy.windows.probe_scope_height, 1.0f, 50.0f, 500.0f);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 250);
    
    // Draw background
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           IM_COL32(10, 10, 10, 255));
    
    // Status overlay preview
    ImVec2 statusPos = ImVec2(canvasPos.x + 10, canvasPos.y + 10);
    ImVec2 statusSize = ImVec2(150, 40);
    ImU32 statusColor = IM_COL32(255, 255, 255, (int)(m_workingCopy.windows.status_overlay_alpha * 255));
    drawList->AddRectFilled(statusPos, ImVec2(statusPos.x + statusSize.x, statusPos.y + statusSize.y), 
                           statusColor);
    drawList->AddRect(statusPos, ImVec2(statusPos.x + statusSize.x, statusPos.y + statusSize.y), 
                     IM_COL32(200, 200, 200, 255), 0.0f, 0, 1.0f);
    ImGui::SetCursorScreenPos(ImVec2(statusPos.x + 5, statusPos.y + 12));
    ImGui::Text("Status Overlay");
    ImGui::SetCursorScreenPos(ImVec2(statusPos.x, statusPos.y + statusSize.y + 5));
    
    // Probe scope preview
    float scopeWidth = m_workingCopy.windows.probe_scope_width;
    float scopeHeight = m_workingCopy.windows.probe_scope_height;
    if (scopeWidth > canvasSize.x * 0.8f) scopeWidth = canvasSize.x * 0.8f;
    if (scopeHeight > canvasSize.y * 0.5f) scopeHeight = canvasSize.y * 0.5f;
    
    ImVec2 scopePos = ImVec2(canvasPos.x + 10, ImGui::GetCursorScreenPos().y);
    ImVec2 scopeSize = ImVec2(scopeWidth, scopeHeight);
    ImU32 scopeColor = IM_COL32(0, 200, 255, (int)(m_workingCopy.windows.probe_scope_alpha * 255));
    drawList->AddRectFilled(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                           IM_COL32(20, 20, 20, 255));
    drawList->AddRect(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                     scopeColor, 0.0f, 0, 2.0f);
    
    // Draw scope waveform
    for (int i = 0; i < (int)scopeSize.x - 4; i += 2)
    {
        float x = scopePos.x + 2 + i;
        float y = scopePos.y + scopeSize.y * 0.5f + sinf(i * 0.1f) * scopeSize.y * 0.3f;
        drawList->AddLine(ImVec2(x, y), ImVec2(x + 2, y + sinf((i + 2) * 0.1f) * scopeSize.y * 0.3f), 
                         scopeColor, 1.5f);
    }
    
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + 5));
    ImGui::Text("Probe Scope");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    ImGui::Text("Scope: %.0fx%.0fpx | Alpha: %.2f", 
                m_workingCopy.windows.probe_scope_width,
                m_workingCopy.windows.probe_scope_height,
                m_workingCopy.windows.probe_scope_alpha);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderModulationTab()
{
    ImGui::Text("Modulation Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ModulationColumns", true);
    
    // Left: Controls
    colorEdit4("Frequency", m_workingCopy.modulation.frequency);
    colorEdit4("Timbre", m_workingCopy.modulation.timbre);
    colorEdit4("Amplitude", m_workingCopy.modulation.amplitude);
    colorEdit4("Filter", m_workingCopy.modulation.filter);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    
    // Draw waveform previews for each modulation type
    float waveHeight = 30.0f;
    float ySpacing = 40.0f;
    
    // Frequency
    ImVec2 freqStart = ImVec2(canvasPos.x, canvasPos.y);
    ImGui::SetCursorScreenPos(freqStart);
    ImGui::Text("Frequency:");
    for (int i = 0; i < 50; ++i)
    {
        float x = freqStart.x + i * 5.0f;
        float y = freqStart.y + 20.0f + sinf(i * 0.2f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.frequency), 0);
    }
    
    // Timbre
    ImVec2 timbreStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing);
    ImGui::SetCursorScreenPos(timbreStart);
    ImGui::Text("Timbre:");
    for (int i = 0; i < 50; ++i)
    {
        float x = timbreStart.x + i * 5.0f;
        float y = timbreStart.y + 20.0f + sinf(i * 0.15f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.timbre), 0);
    }
    
    // Amplitude
    ImVec2 ampStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing * 2);
    ImGui::SetCursorScreenPos(ampStart);
    ImGui::Text("Amplitude:");
    for (int i = 0; i < 50; ++i)
    {
        float x = ampStart.x + i * 5.0f;
        float y = ampStart.y + 20.0f + sinf(i * 0.3f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.amplitude), 0);
    }
    
    // Filter
    ImVec2 filterStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing * 3);
    ImGui::SetCursorScreenPos(filterStart);
    ImGui::Text("Filter:");
    for (int i = 0; i < 50; ++i)
    {
        float x = filterStart.x + i * 5.0f;
        float y = filterStart.y + 20.0f + sinf(i * 0.1f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.filter), 0);
    }
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderMetersTab()
{
    ImGui::Text("Meter Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "MetersColumns", true);
    
    // Left: Controls
    colorEdit4("Safe", m_workingCopy.meters.safe);
    colorEdit4("Warning", m_workingCopy.meters.warning);
    colorEdit4("Clipping", m_workingCopy.meters.clipping);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    
    // Draw meter bars
    float meterWidth = ImGui::GetContentRegionAvail().x;
    float meterHeight = 20.0f;
    float spacing = 5.0f;
    
    // Safe level meter
    ImVec2 safePos = canvasPos;
    float safeLevel = 0.6f; // 60% full
    drawList->AddRectFilled(safePos, ImVec2(safePos.x + meterWidth, safePos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(safePos, ImVec2(safePos.x + meterWidth * safeLevel, safePos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    ImGui::SetCursorScreenPos(ImVec2(safePos.x, safePos.y));
    ImGui::Text("Safe (60%):");
    ImGui::SetCursorScreenPos(ImVec2(safePos.x, safePos.y + meterHeight + spacing));
    
    // Warning level meter
    ImVec2 warnPos = ImGui::GetCursorScreenPos();
    float warnLevel = 0.85f; // 85% full
    drawList->AddRectFilled(warnPos, ImVec2(warnPos.x + meterWidth, warnPos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(warnPos, ImVec2(warnPos.x + meterWidth * 0.8f, warnPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    drawList->AddRectFilled(ImVec2(warnPos.x + meterWidth * 0.8f, warnPos.y), 
                           ImVec2(warnPos.x + meterWidth * warnLevel, warnPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.warning));
    ImGui::SetCursorScreenPos(ImVec2(warnPos.x, warnPos.y));
    ImGui::Text("Warning (85%):");
    ImGui::SetCursorScreenPos(ImVec2(warnPos.x, warnPos.y + meterHeight + spacing));
    
    // Clipping level meter
    ImVec2 clipPos = ImGui::GetCursorScreenPos();
    float clipLevel = 1.0f; // 100% full (clipping)
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + meterWidth, clipPos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + meterWidth * 0.8f, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    drawList->AddRectFilled(ImVec2(clipPos.x + meterWidth * 0.8f, clipPos.y), 
                           ImVec2(clipPos.x + meterWidth * 0.95f, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.warning));
    drawList->AddRectFilled(ImVec2(clipPos.x + meterWidth * 0.95f, clipPos.y), 
                           ImVec2(clipPos.x + meterWidth * clipLevel, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.clipping));
    ImGui::SetCursorScreenPos(ImVec2(clipPos.x, clipPos.y));
    ImGui::Text("Clipping (100%):");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderTimelineTab()
{
    ImGui::Text("Timeline Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "TimelineColumns", true);
    
    // Left: Controls
    colorEditU32("Marker Start/End", m_workingCopy.timeline.marker_start_end);
    colorEditU32("Marker Gate", m_workingCopy.timeline.marker_gate);
    colorEditU32("Marker Trigger", m_workingCopy.timeline.marker_trigger);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 150);
    
    // Draw timeline preview
    float timelineHeight = 40.0f;
    ImVec2 timelineStart = ImVec2(canvasPos.x, canvasPos.y + 20);
    
    // Draw timeline background
    drawList->AddRectFilled(timelineStart, 
                           ImVec2(timelineStart.x + canvasSize.x, timelineStart.y + timelineHeight), 
                           IM_COL32(20, 20, 20, 255));
    
    // Draw markers
    // Start marker
    ImVec2 startMarker = ImVec2(timelineStart.x + 20, timelineStart.y);
    drawList->AddLine(ImVec2(startMarker.x, startMarker.y), 
                     ImVec2(startMarker.x, startMarker.y + timelineHeight), 
                     m_workingCopy.timeline.marker_start_end, 3.0f);
    drawList->AddTriangleFilled(ImVec2(startMarker.x, startMarker.y), 
                                ImVec2(startMarker.x - 5, startMarker.y - 8), 
                                ImVec2(startMarker.x + 5, startMarker.y - 8), 
                                m_workingCopy.timeline.marker_start_end);
    ImGui::SetCursorScreenPos(ImVec2(startMarker.x - 10, startMarker.y - 20));
    ImGui::Text("Start");
    
    // End marker
    ImVec2 endMarker = ImVec2(timelineStart.x + canvasSize.x - 20, timelineStart.y);
    drawList->AddLine(ImVec2(endMarker.x, endMarker.y), 
                     ImVec2(endMarker.x, endMarker.y + timelineHeight), 
                     m_workingCopy.timeline.marker_start_end, 3.0f);
    drawList->AddTriangleFilled(ImVec2(endMarker.x, endMarker.y), 
                                ImVec2(endMarker.x - 5, endMarker.y - 8), 
                                ImVec2(endMarker.x + 5, endMarker.y - 8), 
                                m_workingCopy.timeline.marker_start_end);
    ImGui::SetCursorScreenPos(ImVec2(endMarker.x - 10, endMarker.y - 20));
    ImGui::Text("End");
    
    // Gate markers
    float gateY = timelineStart.y + timelineHeight * 0.3f;
    for (int i = 0; i < 3; ++i)
    {
        float x = timelineStart.x + 60 + i * 40;
        drawList->AddRectFilled(ImVec2(x, gateY), ImVec2(x + 20, gateY + 15), 
                               m_workingCopy.timeline.marker_gate);
    }
    ImGui::SetCursorScreenPos(ImVec2(timelineStart.x + 60, gateY - 15));
    ImGui::Text("Gates");
    
    // Trigger markers
    float triggerY = timelineStart.y + timelineHeight * 0.7f;
    for (int i = 0; i < 5; ++i)
    {
        float x = timelineStart.x + 80 + i * 25;
        drawList->AddLine(ImVec2(x, triggerY), ImVec2(x, triggerY + 10), 
                         m_workingCopy.timeline.marker_trigger, 2.0f);
    }
    ImGui::SetCursorScreenPos(ImVec2(timelineStart.x + 80, triggerY - 15));
    ImGui::Text("Triggers");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderModulesTab()
{
    ImGui::Text("Module-Specific Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ModulesColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("VideoFX Module"))
    {
        colorEdit4("Section Header", m_workingCopy.modules.videofx_section_header);
        colorEdit4("Section Subheader", m_workingCopy.modules.videofx_section_subheader);
    }
    
    if (ImGui::CollapsingHeader("Scope Module"))
    {
        colorEdit4("Section Header", m_workingCopy.modules.scope_section_header);
        colorEditU32("Plot Background", m_workingCopy.modules.scope_plot_bg);
        colorEditU32("Plot Foreground", m_workingCopy.modules.scope_plot_fg);
        colorEditU32("Plot Max", m_workingCopy.modules.scope_plot_max);
        colorEditU32("Plot Min", m_workingCopy.modules.scope_plot_min);
        colorEdit4("Text Max", m_workingCopy.modules.scope_text_max);
        colorEdit4("Text Min", m_workingCopy.modules.scope_text_min);
    }
    
    if (ImGui::CollapsingHeader("Stroke Sequencer"))
    {
        colorEditU32("Border", m_workingCopy.modules.stroke_seq_border);
        colorEditU32("Canvas Background", m_workingCopy.modules.stroke_seq_canvas_bg);
        colorEditU32("Line Inactive", m_workingCopy.modules.stroke_seq_line_inactive);
        colorEditU32("Line Active", m_workingCopy.modules.stroke_seq_line_active);
        colorEditU32("Playhead", m_workingCopy.modules.stroke_seq_playhead);
        colorEditU32("Threshold Floor", m_workingCopy.modules.stroke_seq_thresh_floor);
        colorEditU32("Threshold Mid", m_workingCopy.modules.stroke_seq_thresh_mid);
        colorEditU32("Threshold Ceil", m_workingCopy.modules.stroke_seq_thresh_ceil);
        colorEdit4("Frame Background", m_workingCopy.modules.stroke_seq_frame_bg);
        colorEdit4("Frame Hovered", m_workingCopy.modules.stroke_seq_frame_bg_hovered);
        colorEdit4("Frame Active", m_workingCopy.modules.stroke_seq_frame_bg_active);
    }
    
    if (ImGui::CollapsingHeader("PanVol Module"))
    {
        dragFloat("Node Width", m_workingCopy.modules.panvol_node_width, 1.0f, 120.0f, 400.0f);
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Custom width for PanVol node (default: 180px)");
        colorEditU32("Grid Background", m_workingCopy.modules.panvol_grid_background);
        colorEditU32("Grid Border", m_workingCopy.modules.panvol_grid_border);
        colorEditU32("Grid Lines", m_workingCopy.modules.panvol_grid_lines);
        colorEditU32("Crosshair", m_workingCopy.modules.panvol_crosshair);
        colorEditU32("Circle (Manual)", m_workingCopy.modules.panvol_circle_manual);
        colorEditU32("Circle (Modulated)", m_workingCopy.modules.panvol_circle_modulated);
        colorEditU32("Label Text", m_workingCopy.modules.panvol_label_text);
        colorEditU32("Value Text", m_workingCopy.modules.panvol_value_text);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    
    // VideoFX Preview
    ImGui::TextColored(m_workingCopy.modules.videofx_section_header, "VideoFX Section Header");
    ImGui::TextColored(m_workingCopy.modules.videofx_section_subheader, "VideoFX Section Subheader");
    ImGui::Spacing();
    
    // Scope Preview
    ImGui::TextColored(m_workingCopy.modules.scope_section_header, "Scope Section Header");
    ImVec2 scopePos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 10);
    ImVec2 scopeSize = ImVec2(200, 100);
    
    // Draw scope background
    drawList->AddRectFilled(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                           m_workingCopy.modules.scope_plot_bg);
    drawList->AddRect(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                     IM_COL32(100, 100, 100, 255));
    
    // Draw scope waveform
    for (int i = 0; i < (int)scopeSize.x - 4; i += 2)
    {
        float x = scopePos.x + 2 + i;
        float y = scopePos.y + scopeSize.y * 0.5f + sinf(i * 0.1f) * scopeSize.y * 0.3f;
        drawList->AddLine(ImVec2(x, y), ImVec2(x + 2, y + sinf((i + 2) * 0.1f) * scopeSize.y * 0.3f), 
                         m_workingCopy.modules.scope_plot_fg, 1.5f);
    }
    
    // Draw max/min markers
    drawList->AddLine(ImVec2(scopePos.x + 5, scopePos.y + 5), 
                     ImVec2(scopePos.x + scopeSize.x - 5, scopePos.y + 5), 
                     m_workingCopy.modules.scope_plot_max, 2.0f);
    drawList->AddLine(ImVec2(scopePos.x + 5, scopePos.y + scopeSize.y - 5), 
                     ImVec2(scopePos.x + scopeSize.x - 5, scopePos.y + scopeSize.y - 5), 
                     m_workingCopy.modules.scope_plot_min, 2.0f);
    
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + 5));
    ImGui::TextColored(m_workingCopy.modules.scope_text_max, "MAX");
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + scopeSize.y - 20));
    ImGui::TextColored(m_workingCopy.modules.scope_text_min, "MIN");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, scopePos.y + scopeSize.y + 20));
    ImGui::Spacing();
    
    // Stroke Sequencer Preview
    ImGui::Text("Stroke Sequencer Preview:");
    ImVec2 seqPos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 5);
    ImVec2 seqSize = ImVec2(250, 120);
    
    // Draw canvas background
    drawList->AddRectFilled(seqPos, ImVec2(seqPos.x + seqSize.x, seqPos.y + seqSize.y), 
                           m_workingCopy.modules.stroke_seq_canvas_bg);
    drawList->AddRect(seqPos, ImVec2(seqPos.x + seqSize.x, seqPos.y + seqSize.y), 
                     m_workingCopy.modules.stroke_seq_border, 0.0f, 0, 2.0f);
    
    // Draw lines
    float lineY = seqPos.y + 20;
    for (int i = 0; i < 5; ++i)
    {
        float x1 = seqPos.x + 10 + i * 20;
        float x2 = seqPos.x + 10 + (i + 1) * 20;
        ImU32 lineColor = (i == 2) ? m_workingCopy.modules.stroke_seq_line_active : 
                                     m_workingCopy.modules.stroke_seq_line_inactive;
        drawList->AddLine(ImVec2(x1, lineY + i * 15), ImVec2(x2, lineY + i * 15), lineColor, 2.0f);
    }
    
    // Draw playhead
    float playheadX = seqPos.x + 100;
    drawList->AddLine(ImVec2(playheadX, seqPos.y), ImVec2(playheadX, seqPos.y + seqSize.y), 
                     m_workingCopy.modules.stroke_seq_playhead, 2.0f);
    
    // Draw threshold markers
    float threshY1 = seqPos.y + seqSize.y * 0.3f;
    float threshY2 = seqPos.y + seqSize.y * 0.5f;
    float threshY3 = seqPos.y + seqSize.y * 0.7f;
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY1), ImVec2(seqPos.x + seqSize.x - 5, threshY1), 
                     m_workingCopy.modules.stroke_seq_thresh_floor, 1.0f);
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY2), ImVec2(seqPos.x + seqSize.x - 5, threshY2), 
                     m_workingCopy.modules.stroke_seq_thresh_mid, 1.0f);
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY3), ImVec2(seqPos.x + seqSize.x - 5, threshY3), 
                     m_workingCopy.modules.stroke_seq_thresh_ceil, 1.0f);
    
    // Draw frame preview
    ImVec2 framePos = ImVec2(seqPos.x + seqSize.x - 60, seqPos.y + 10);
    ImVec2 frameSize = ImVec2(50, 30);
    drawList->AddRectFilled(framePos, ImVec2(framePos.x + frameSize.x, framePos.y + frameSize.y), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.modules.stroke_seq_frame_bg));
    drawList->AddRect(framePos, ImVec2(framePos.x + frameSize.x, framePos.y + frameSize.y), 
                     IM_COL32(100, 100, 100, 255));
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, seqPos.y + seqSize.y + 20));
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    // PanVol Preview
    ImGui::Text("PanVol Preview:");
    ImVec2 panvolPos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 5);
    float panvolWidth = m_workingCopy.modules.panvol_node_width;
    if (panvolWidth > 200.0f) panvolWidth = 200.0f; // Limit for preview
    float gridSize = juce::jmin(panvolWidth - 20.0f, 100.0f);
    ImVec2 gridMin = ImVec2(panvolPos.x + (panvolWidth - gridSize) * 0.5f, panvolPos.y + 10);
    ImVec2 gridMax = ImVec2(gridMin.x + gridSize, gridMin.y + gridSize);
    
    // Draw grid
    drawList->AddRectFilled(gridMin, gridMax, m_workingCopy.modules.panvol_grid_background);
    drawList->AddRect(gridMin, gridMax, m_workingCopy.modules.panvol_grid_border, 0.0f, 0, 2.0f);
    
    // Draw grid lines
    for (int i = 1; i < 4; ++i)
    {
        float t = (float)i / 4.0f;
        float x = gridMin.x + t * gridSize;
        float y = gridMin.y + t * gridSize;
        drawList->AddLine(ImVec2(x, gridMin.y), ImVec2(x, gridMax.y), m_workingCopy.modules.panvol_grid_lines, 1.0f);
        drawList->AddLine(ImVec2(gridMin.x, y), ImVec2(gridMax.x, y), m_workingCopy.modules.panvol_grid_lines, 1.0f);
    }
    
    // Draw crosshair
    ImVec2 center = ImVec2(gridMin.x + gridSize * 0.5f, gridMin.y + gridSize * 0.5f);
    drawList->AddLine(ImVec2(center.x, gridMin.y), ImVec2(center.x, gridMax.y), m_workingCopy.modules.panvol_crosshair, 1.0f);
    drawList->AddLine(ImVec2(gridMin.x, center.y), ImVec2(gridMax.x, center.y), m_workingCopy.modules.panvol_crosshair, 1.0f);
    
    // Draw circle (manual state)
    drawList->AddCircleFilled(center, 6.0f, m_workingCopy.modules.panvol_circle_manual, 16);
    drawList->AddCircle(center, 6.0f, IM_COL32(255, 255, 255, 255), 16, 1.5f);
    
    // Draw labels
    drawList->AddText(ImVec2(gridMin.x + 2, gridMin.y + 2), m_workingCopy.modules.panvol_label_text, "Vol");
    ImVec2 panTextSize = ImGui::CalcTextSize("Pan");
    drawList->AddText(ImVec2(gridMax.x - panTextSize.x - 2, gridMin.y + 2), m_workingCopy.modules.panvol_label_text, "Pan");
    
    // Draw value readouts
    drawList->AddText(ImVec2(gridMin.x + 2, gridMin.y + 2 + ImGui::GetFontSize() + 2), m_workingCopy.modules.panvol_value_text, "-55.1dB");
    ImVec2 panValSize = ImGui::CalcTextSize("0.76");
    drawList->AddText(ImVec2(gridMax.x - panValSize.x - 2, gridMin.y + 2 + ImGui::GetFontSize() + 2), m_workingCopy.modules.panvol_value_text, "0.76");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, gridMax.y + 20));
    ImGui::Text("Node Width: %.0fpx", m_workingCopy.modules.panvol_node_width);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderSaveDialog()
{
    ImGui::OpenPopup("Save Theme");
    if (ImGui::BeginPopupModal("Save Theme", nullptr, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("Enter theme name:");
        ImGui::InputText("##ThemeName", m_saveThemeName, sizeof(m_saveThemeName));
        
        ImGui::Separator();
        
        if (ImGui::Button("Save"))
        {
            saveThemeAs();
            m_showSaveDialog = false;
            ImGui::CloseCurrentPopup();
        }
        ImGui::SameLine();
        if (ImGui::Button("Cancel"))
        {
            m_showSaveDialog = false;
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
}

void ThemeEditorComponent::saveTheme()
{
    // Save to current theme file (if one exists)
    if (m_currentThemeFilename.isEmpty())
    {
        // No current theme file, should use Save As instead
        juce::Logger::writeToLog("[ThemeEditor] Cannot save: no current theme file. Use 'Save As...' instead.");
        return;
    }
    
    // Find the current theme file
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    auto themesDir = exeDir.getChildFile("themes");
    auto themeFile = themesDir.getChildFile(m_currentThemeFilename);
    
    // Also check source tree as fallback
    if (!themeFile.existsAsFile())
    {
        auto sourceThemesDir = exeDir.getParentDirectory().getParentDirectory()
            .getChildFile("Source")
            .getChildFile("preset_creator")
            .getChildFile("theme")
            .getChildFile("presets");
        themeFile = sourceThemesDir.getChildFile(m_currentThemeFilename);
    }
    
    if (!themeFile.existsAsFile())
    {
        juce::Logger::writeToLog("[ThemeEditor] ERROR: Current theme file not found: " + m_currentThemeFilename);
        return;
    }
    
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    if (ThemeManager::getInstance().saveTheme(themeFile))
    {
        juce::Logger::writeToLog("[ThemeEditor] Saved theme to: " + themeFile.getFullPathName());
        m_hasChanges = false;
    }
    else
    {
        juce::Logger::writeToLog("[ThemeEditor] ERROR saving theme: " + themeFile.getFullPathName());
    }
}

void ThemeEditorComponent::saveThemeAs()
{
    juce::String themeName(m_saveThemeName);
    if (themeName.isEmpty())
    {
        return;
    }
    
    themeName = themeName.replaceCharacter(' ', '_');
    
    // Save to exe/themes folder
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    auto themesDir = exeDir.getChildFile("themes");
    themesDir.createDirectory();
    auto themeFile = themesDir.getChildFile(themeName + ".json");
    
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    if (ThemeManager::getInstance().saveTheme(themeFile))
    {
        juce::Logger::writeToLog("[ThemeEditor] Saved theme to: " + themeFile.getFullPathName());
        // Update current theme filename
        m_currentThemeFilename = themeFile.getFileName();
        // Persist as last-used
        ThemeManager::getInstance().saveUserThemePreference(themeFile.getFileName());
        m_hasChanges = false;
    }
    else
    {
        juce::Logger::writeToLog("[ThemeEditor] ERROR saving theme: " + themeFile.getFullPathName());
    }
}

void ThemeEditorComponent::resetCurrentTab()
{
    // TODO: Reset current tab to default values
    // For now, just reload from current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_hasChanges = false;
}

void ThemeEditorComponent::applyChanges()
{
    // Apply working copy to ThemeManager
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    ThemeManager::getInstance().applyTheme();
	ThemeManager::getInstance().requestFontReload();
    m_hasChanges = false;
    juce::Logger::writeToLog("[ThemeEditor] Applied theme changes");
    
    // Also save user preference if they want persistence
    // (Theme preference is saved when selecting from menu, not when editing)
}

void ThemeEditorComponent::syncFontBuffersFromWorkingCopy()
{
    const std::string defaultPath = m_workingCopy.fonts.default_path.toStdString();
    std::snprintf(m_defaultFontPathBuffer.data(), m_defaultFontPathBuffer.size(), "%s", defaultPath.c_str());
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::previewFontChanges()
{
    auto& liveFonts = ThemeManager::getInstance().getEditableTheme().fonts;
    liveFonts.default_path = m_workingCopy.fonts.default_path;
    liveFonts.default_size = m_workingCopy.fonts.default_size;
    ThemeManager::getInstance().requestFontReload();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::scanFontFolder()
{
    m_scannedFontFiles.clear();

    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    auto fontsDir = exeDir.getChildFile("fonts");

    juce::Logger::writeToLog("[ThemeEditor] Scanning for fonts in: " + fontsDir.getFullPathName());

    if (fontsDir.isDirectory())
    {
        auto addFontsForPattern = [this, &fontsDir, &exeDir](const juce::String& pattern)
        {
            juce::Array<juce::File> files;
            fontsDir.findChildFiles(files, juce::File::findFiles, false, pattern);
            for (const auto& file : files)
            {
                const juce::String relativePath = file.getRelativePathFrom(exeDir);
                if (!m_scannedFontFiles.contains(relativePath))
                    m_scannedFontFiles.add(relativePath);
            }
        };

        addFontsForPattern("*.ttf");
        addFontsForPattern("*.otf");
        addFontsForPattern("*.ttc");
    }

    m_scannedFontFiles.sort(true);
    juce::Logger::writeToLog("[ThemeEditor] Found " + juce::String(m_scannedFontFiles.size()) + " font files.");
}

int ThemeEditorComponent::findScannedFontIndex(const juce::String& path) const
{
    if (path.isEmpty())
        return -1;

    const juce::String normalised = resolveFontPath(path).getFullPathName();

    for (int i = 0; i < m_scannedFontFiles.size(); ++i)
    {
        if (resolveFontPath(m_scannedFontFiles[i]).getFullPathName() == normalised)
            return i;
    }
    return -1;
}




================================================================================
FILE: USER_MANUAL/Nodes_Dictionary.md
================================================================================

# Collider Modular Synthesizer - Node Dictionary

**Last Updated:** December 18, 2024  
**Version:** 1.2

---

## Table of Contents

### Quick Reference Index

#### 1. SOURCE NODES
- [vco](#vco) - Voltage-Controlled Oscillator
- [polyvco](#polyvco) - Multi-Voice Oscillator Bank
- [noise](#noise) - Noise Generator
- [audio_input](#audio_input) - Hardware Audio Input
- [sample_loader](#sample_loader) - Audio Sample Player
- [value](#value) - Constant Value Generator

#### 2. EFFECT NODES
- [vcf](#vcf) - Voltage-Controlled Filter
- [delay](#delay) - Stereo Delay Effect
- [reverb](#reverb) - Stereo Reverb Effect
- [chorus](#chorus) - Stereo Chorus Effect
- [phaser](#phaser) - Stereo Phaser Effect
- [compressor](#compressor) - Dynamic Range Compressor
- [limiter](#limiter) - Audio Limiter
- [gate](#gate) - Noise Gate
- [drive](#drive) - Waveshaping Distortion
- [graphic_eq](#graphic_eq) - 8-Band Graphic Equalizer
- [waveshaper](#waveshaper) - Multi-Algorithm Waveshaper
- [8bandshaper](#8bandshaper) - Multi-Band Waveshaper
- [granulator](#granulator) - Granular Synthesizer/Effect
- [harmonic_shaper](#harmonic_shaper) - Harmonic Content Shaper
- [timepitch](#timepitch) - Time/Pitch Manipulation
- [de_crackle](#de_crackle) - Click/Pop Reducer
- [vocal_tract_filter](#vocal_tract_filter) - Formant Filter

#### 3. MODULATOR NODES
- [lfo](#lfo) - Low-Frequency Oscillator
- [adsr](#adsr) - Envelope Generator
- [random](#random) - Random Value Generator
- [s_and_h](#s_and_h) - Sample & Hold
- [function_generator](#function_generator) - Drawable Envelope/LFO
- [shaping_oscillator](#shaping_oscillator) - Oscillator with Built-in Waveshaper

#### 4. UTILITY & LOGIC NODES
- [vca](#vca) - Voltage-Controlled Amplifier
- [mixer](#mixer) - Stereo Audio Mixer
- [cv_mixer](#cv_mixer) - Control Voltage Mixer
- [track_mixer](#track_mixer) - Multi-Channel Mixer
- [panvol](#panvol) - 2D Volume and Panning Control
- [attenuverter](#attenuverter) - Attenuate/Invert Signal
- [lag_processor](#lag_processor) - Slew Limiter/Smoother
- [math](#math) - Mathematical Operations
- [map_range](#map_range) - Value Range Mapper
- [quantizer](#quantizer) - Musical Scale Quantizer
- [rate](#rate) - Rate Value Converter
- [comparator](#comparator) - Threshold Comparator
- [logic](#logic) - Boolean Logic Operations
- [clock_divider](#clock_divider) - Clock Division/Multiplication
- [sequential_switch](#sequential_switch) - Signal Router

#### 5. SEQUENCER NODES
- [sequencer](#sequencer) - 16-Step CV/Gate Sequencer
- [multi_sequencer](#multi_sequencer) - Advanced Multi-Output Sequencer
- [snapshot_sequencer](#snapshot_sequencer) - Patch State Sequencer
- [stroke_sequencer](#stroke_sequencer) - Gesture-Based Sequencer
- [tempo_clock](#tempo_clock) - Global Clock Generator
- [timeline](#timeline) - Automation Recorder and Playback

#### 6. MIDI NODES
- [midi_cv](#midi_cv) - MIDI to CV Converter
- [midi_player](#midi_player) - MIDI File Player
- [midi_faders](#midi_faders) - MIDI-Learnable Faders (1-16)
- [midi_knobs](#midi_knobs) - MIDI-Learnable Knobs (1-16)
- [midi_buttons](#midi_buttons) - MIDI-Learnable Buttons (1-32)
- [midi_jog_wheel](#midi_jog_wheel) - MIDI Jog Wheel Control

#### 7. ANALYSIS NODES
- [scope](#scope) - Oscilloscope
- [debug](#debug) - Signal Value Logger
- [input_debug](#input_debug) - Passthrough Debug Logger
- [frequency_graph](#frequency_graph) - Spectrum Analyzer

#### 8. TTS (TEXT-TO-SPEECH) NODES
- [tts_performer](#tts_performer) - Text-to-Speech Engine
- [vocal_tract_filter](#vocal_tract_filter) - Formant Filter

#### 9. SPECIAL NODES
- [physics](#physics) - 2D Physics Simulation
- [animation](#animation) - 3D Animation Player

#### 10. COMPUTER VISION NODES
- [webcam_loader](#webcam_loader) - Webcam Video Source
- [video_file_loader](#video_file_loader) - Video File Source
- [movement_detector](#movement_detector) - Motion Detection
- [human_detector](#human_detector) - Face/Body Detection
- [object_detector](#object_detector) - Object Detection (YOLOv3)
- [pose_estimator](#pose_estimator) - Body Keypoint Detection
- [hand_tracker](#hand_tracker) - Hand Keypoint Tracking
- [face_tracker](#face_tracker) - Facial Landmark Tracking
- [color_tracker](#color_tracker) - Multi-Color Tracking
- [contour_detector](#contour_detector) - Shape Detection
- [semantic_segmentation](#semantic_segmentation) - Scene Segmentation
- [video_fx](#video_fx) - Real-Time Video Effects
- [crop_video](#crop_video) - Video Cropping and Tracking

#### 11. SYSTEM NODES
- [meta](#meta) - Meta Module Container
- [inlet](#inlet) - Meta Module Input
- [outlet](#outlet) - Meta Module Output
- [comment](#comment) - Documentation Node
- [recorder](#recorder) - Audio Recording to File
- [vst_host](#vst_host) - VST Plugin Host
- [bpm_monitor](#bpm_monitor) - Rhythm Detection and BPM Reporting

---

## 1. SOURCE NODES

Source nodes generate or input signals into your patch.

### vco
**Voltage-Controlled Oscillator**

A standard analog-style oscillator that generates periodic waveforms.

**Inputs:**
- `Frequency` (CV) - Frequency modulation input
- `Waveform` (CV) - Waveform selection modulation
- `Gate` (Gate) - Gate input for amplitude control

**Outputs:**
- `Out` (Audio) - Mono audio output

**Parameters:**
- `Frequency` (20 Hz - 20 kHz) - Base oscillator frequency
- `Waveform` (Choice) - Sine, Sawtooth, or Square wave
- `Relative Freq Mod` (Bool) - When enabled, CV modulates Â±4 octaves around slider position. When disabled, CV directly maps to 20 Hz - 20 kHz
- `Portamento` (0-2 seconds) - Frequency glide/smoothing time

**How to Use:**
1. Connect the audio output to an effect or VCA
2. Set the frequency slider to your desired pitch
3. Optionally connect CV (from sequencer, LFO, or ADSR) to modulate frequency
4. Use the Relative Freq Mod toggle to choose between relative (musical) or absolute (full range) modulation
5. Connect a gate signal for amplitude gating if needed
6. Adjust portamento for smooth frequency transitions

---

### polyvco
**Multi-Voice Oscillator Bank**

A polyphonic oscillator module with up to 32 independent voices, ideal for creating rich, layered sounds or building polyphonic synthesizers.

**Inputs:**
- `Num Voices Mod` (Raw) - Control number of active voices (1-32)
- `Freq 1-32 Mod` (CV) - Individual frequency modulation for each voice
- `Wave 1-32 Mod` (CV) - Individual waveform modulation for each voice
- `Gate 1-32 Mod` (Gate) - Individual gate inputs for each voice

**Outputs:**
- `Out 1-32` (Audio) - 32 independent audio outputs (one per voice)

**Parameters:**
- `Num Voices` (1-32) - Number of active voices
- `Base Frequency` (20 Hz - 20 kHz) - Base frequency for all voices
- `Detune Amount` (0-100 cents) - Amount of random detuning between voices
- `Spread` (0-100%) - Frequency spread between voices
- `Waveform` (Choice) - Base waveform for all voices (Sine, Sawtooth, Square)

**How to Use:**
1. Set the number of voices you want active
2. Connect the voice outputs to a Track Mixer or individual effects
3. Use the detune parameter to create a chorus-like effect
4. Connect a Multi Sequencer's parallel outputs to the individual frequency and gate inputs for polyphonic melodies
5. Adjust spread to create harmonic stacks

---

### noise
**Noise Generator**

Generates white, pink, or brown noise for percussion, ambience, or modulation.

**Inputs:**
- `Level Mod` (CV) - Level modulation input
- `Colour Mod` (CV) - Noise color modulation

**Outputs:**
- `Out L` (Audio) - Left channel output
- `Out R` (Audio) - Right channel output

**Parameters:**
- `Colour` (Choice) - White (flat spectrum), Pink (-3 dB/octave), or Brown (-6 dB/octave)
- `Level dB` (-60 to +6 dB) - Output level in decibels

**How to Use:**
1. Select the noise color (white for hi-hats, pink for general noise, brown for low rumble)
2. Adjust the level to taste
3. Optionally modulate the color with CV for dynamic timbral changes
4. Great for percussion synthesis when combined with envelopes and filters
5. Use as a modulation source for subtle random variations

---

### audio_input
**Hardware Audio Input**

Brings external audio from your audio interface into the patch.

**Outputs:**
- `Out 1` (Audio) - Input channel 1
- `Out 2` (Audio) - Input channel 2
- `Gate` (Gate) - Gate signal when audio exceeds threshold
- `Trigger` (Gate) - Trigger signal on transients
- `EOP` (Gate) - End of phrase detection

**Parameters:**
- `Input Gain` (-60 to +20 dB) - Input gain control
- `Gate Threshold` (-60 to 0 dB) - Threshold for gate output
- `Trigger Sensitivity` (Low/Medium/High) - Transient detection sensitivity

**How to Use:**
1. Connect your external audio source (microphone, instrument, etc.) to your audio interface
2. Adjust input gain to get a healthy signal level
3. Use the gate and trigger outputs to create envelope followers or rhythm detection
4. Process the audio through effects or use it as a modulation source via envelope following

---

### sample_loader
**Audio Sample Player**

Loads and plays audio samples with extensive playback control and modulation options.

**Inputs:**
- `Pitch Mod` (CV) - Pitch modulation in semitones
- `Speed Mod` (CV) - Playback speed modulation
- `Gate Mod` (CV) - Gate/trigger modulation
- `Trigger Mod` (Gate) - Retrigger the sample
- `Range Start Mod` (CV) - Modulate sample start point
- `Range End Mod` (CV) - Modulate sample end point
- `Randomize Trig` (Gate) - Randomize sample settings on trigger

**Outputs:**
- `Out L` (Audio) - Left channel output
- `Out R` (Audio) - Right channel output

**Parameters:**
- `File` (Button) - Load audio file (WAV, AIFF, FLAC, MP3)
- `Pitch` (-48 to +48 semitones) - Pitch shift amount
- `Speed` (0.1x to 4x) - Playback speed multiplier
- `Loop Mode` (Choice) - Off, Forward, Ping-Pong
- `Gate Mode` (Choice) - Trigger (one-shot), Gate (held), Free (always play)
- `Range Start` (0-100%) - Sample start position
- `Range End` (0-100%) - Sample end position
- `Reverse` (Bool) - Play sample in reverse
- `Randomize Range` (Bool) - Randomize start/end on each trigger

**How to Use:**
1. Click the "Load File" button and select an audio file
2. Set the pitch and speed for your desired sound
3. Choose a loop mode (Off for one-shots, Forward for sustained sounds)
4. Use Gate Mode: Trigger for drums, Gate for sustained tones, Free for continuous playback
5. Adjust Range Start/End to isolate specific portions of the sample
6. Connect CV to Pitch Mod for melodic playing
7. Use Trigger Mod to retrigger the sample rhythmically
8. Enable Randomize Range for variation on each hit

---

### value
**Constant Value Generator**

Outputs a constant, adjustable numerical value in multiple formats.

**Outputs:**
- `Raw` (Raw) - Unprocessed value as-is
- `Normalized` (CV) - Value normalized to 0-1 range
- `Inverted` (Raw) - Negative of raw value
- `Integer` (Raw) - Truncated integer value
- `CV Out` (CV) - Scaled CV output (0-1 range)

**Parameters:**
- `Value` (-100 to +100) - The constant value to output

**How to Use:**
1. Adjust the value slider to your desired number
2. Connect the appropriate output to the destination:
   - Use `CV Out` for standard 0-1 modulation
   - Use `Raw` for custom ranges or mathematical operations with the Math node
   - Use `Integer` for step/index control
3. Great for setting static modulation amounts, offsets, or reference values
4. Combine multiple Value nodes with Math nodes for complex calculations

---

## 2. EFFECT NODES

Effect nodes process audio signals to shape tone, add space, or create sonic textures.

### vcf
**Voltage-Controlled Filter**

A resonant multi-mode filter for subtractive synthesis and tone shaping.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Cutoff Mod` (CV) - Cutoff frequency modulation
- `Resonance Mod` (CV) - Resonance amount modulation
- `Type Mod` (CV) - Filter type modulation

**Outputs:**
- `Out L` (Audio) - Left filtered output
- `Out R` (Audio) - Right filtered output

**Parameters:**
- `Cutoff` (20 Hz - 20 kHz) - Filter cutoff frequency
- `Resonance` (0.1 - 10.0) - Resonance/Q factor
- `Type` (Choice) - Low-pass, High-pass, or Band-pass
- `Relative Cutoff Mod` (Bool) - When enabled, CV modulates Â±5 octaves around slider. When disabled, CV maps to full 20 Hz - 20 kHz range
- `Relative Resonance Mod` (Bool) - When enabled, CV scales resonance 0.25x-4x. When disabled, CV maps to full 0.1-10.0 range

**How to Use:**
1. Connect audio through the filter
2. Adjust cutoff to set the frequency where filtering occurs
3. Increase resonance for emphasis around the cutoff (be careful, high values can self-oscillate!)
4. Choose filter type: Low-pass removes highs, High-pass removes lows, Band-pass keeps only around cutoff
5. Modulate cutoff with envelopes or LFOs for classic synth sounds
6. Use Relative mode for musical modulation around a set position

---

### delay
**Stereo Delay Effect**

A stereo delay effect with modulation and tempo sync capabilities.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Time Mod` (CV) - Delay time modulation
- `Feedback Mod` (CV) - Feedback amount modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left delayed output
- `Out R` (Audio) - Right delayed output

**Parameters:**
- `Time (ms)` (1-2000 ms) - Delay time in milliseconds
- `Feedback` (0-0.95) - Amount of delayed signal fed back into the delay
- `Mix` (0-1) - Wet/dry balance (0=dry, 1=wet)
- `Relative Time Mod` (Bool) - Enable relative time modulation around slider position
- `Relative Feedback Mod` (Bool) - Enable relative feedback modulation
- `Relative Mix Mod` (Bool) - Enable relative mix modulation

**How to Use:**
1. Send audio through the delay
2. Set delay time to taste (short for slapback, long for echoes)
3. Adjust feedback for the number of repeats (be careful, high values can self-oscillate!)
4. Use mix to blend delayed signal with dry signal
5. Modulate time with LFOs for chorus-like effects
6. Connect to Tempo Clock's clock outputs and use short delay times for rhythmic effects

---

### reverb
**Stereo Reverb Effect**

A stereo reverb effect that simulates acoustic spaces.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Size Mod` (CV) - Room size modulation
- `Damp Mod` (CV) - Damping modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left reverb output
- `Out R` (Audio) - Right reverb output

**Parameters:**
- `Size` (0-1) - Room size (0=small, 1=large)
- `Damping` (0-1) - High frequency damping (0=bright, 1=dark)
- `Width` (0-1) - Stereo width
- `Mix` (0-1) - Wet/dry balance (0=dry, 1=wet)

**How to Use:**
1. Send audio through the reverb
2. Adjust size to set the perceived space (small room to large hall)
3. Use damping to control brightness (low damping=reflective surfaces, high damping=absorptive)
4. Adjust mix to blend reverb with dry signal
5. Great for adding depth and space to sounds
6. Use sparingly on bass-heavy sounds to avoid muddiness

---

### chorus
**Stereo Chorus Effect**

A stereo chorus effect that creates thick, shimmering textures by layering slightly detuned copies of the signal.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Rate Mod` (CV) - LFO rate modulation
- `Depth Mod` (CV) - Effect depth modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left chorus output
- `Out R` (Audio) - Right chorus output

**Parameters:**
- `Rate` (0.1-10 Hz) - LFO speed
- `Depth` (0-1) - Modulation depth
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Send audio through the chorus
2. Set rate for the speed of the sweeping effect (slow=gentle, fast=vibrato)
3. Adjust depth for intensity of detuning
4. Use mix to blend with dry signal
5. Great for thickening synth pads and leads
6. Use on clean guitars for classic 80s sounds

---

### phaser
**Stereo Phaser Effect**

A stereo phaser effect that creates sweeping notches in the frequency spectrum.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Rate Mod` (CV) - LFO rate modulation
- `Depth Mod` (CV) - Effect depth modulation
- `Centre Mod` (CV) - Center frequency modulation
- `Feedback Mod` (CV) - Feedback amount modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left phaser output
- `Out R` (Audio) - Right phaser output

**Parameters:**
- `Rate` (0.1-10 Hz) - LFO speed
- `Depth` (0-1) - Modulation depth
- `Centre Freq` (200-2000 Hz) - Center frequency of the sweep
- `Feedback` (0-0.95) - Amount of feedback (increases resonance)
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Send audio through the phaser
2. Adjust rate for sweep speed (slow=subtle, fast=intense)
3. Set centre frequency to target specific frequency ranges
4. Increase feedback for more pronounced notches
5. Great for adding movement to static sounds
6. Classic effect for electric pianos and guitars

---

### compressor
**Dynamic Range Compressor**

Reduces the dynamic range of audio signals, making quiet parts louder and loud parts quieter.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Thresh Mod` (CV) - Threshold modulation
- `Ratio Mod` (CV) - Ratio modulation
- `Attack Mod` (CV) - Attack time modulation
- `Release Mod` (CV) - Release time modulation
- `Makeup Mod` (CV) - Makeup gain modulation

**Outputs:**
- `Out L` (Audio) - Left compressed output
- `Out R` (Audio) - Right compressed output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Level above which compression starts
- `Ratio` (1:1 to 20:1) - Amount of compression
- `Attack` (0.1-100 ms) - How quickly compression engages
- `Release` (10-1000 ms) - How quickly compression disengages
- `Makeup Gain` (0-24 dB) - Output gain to compensate for level reduction

**How to Use:**
1. Set threshold to the level where you want compression to start
2. Adjust ratio (2:1 for gentle, 10:1+ for heavy compression)
3. Use fast attack to catch transients, slow attack to preserve punch
4. Set release to taste (fast for pumping effects, slow for smooth)
5. Adjust makeup gain to match the output level to the input
6. Great for controlling dynamics, adding sustain, and gluing mixes together

---

### limiter
**Audio Limiter**

Prevents audio from exceeding a set level, acting as a "brick wall" for peaks.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Thresh Mod` (CV) - Threshold modulation
- `Release Mod` (CV) - Release time modulation

**Outputs:**
- `Out L` (Audio) - Left limited output
- `Out R` (Audio) - Right limited output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Maximum allowed level
- `Release` (10-1000 ms) - Recovery time

**How to Use:**
1. Set threshold to the maximum level you want to allow
2. Adjust release time (fast for transparent, slow for smoother)
3. Use at the end of your signal chain to prevent clipping
4. Essential for mastering and protecting speakers
5. Can add punch and loudness when used aggressively

---

### gate
**Noise Gate**

Silences signals below a threshold, useful for removing background noise or creating rhythmic effects.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left gated output
- `Out R` (Audio) - Right gated output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Level below which the gate closes
- `Attack` (0.1-100 ms) - How quickly the gate opens
- `Release` (10-1000 ms) - How quickly the gate closes
- `Range` (-60 to 0 dB) - Amount of attenuation when gate is closed

**How to Use:**
1. Set threshold just above your noise floor
2. Adjust attack and release for smooth or rhythmic gating
3. Use range to set how much the signal is reduced (not necessarily to silence)
4. Great for cleaning up noisy recordings
5. Use creatively with short releases for rhythmic chopping effects

---

### drive
**Waveshaping Distortion**

A waveshaping distortion effect that adds harmonic content and saturation.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left distorted output
- `Out R` (Audio) - Right distorted output

**Parameters:**
- `Drive` (0-100) - Amount of distortion
- `Type` (Choice) - Distortion algorithm (Soft clip, Hard clip, Foldback, etc.)
- `Output Gain` (-12 to +12 dB) - Output level compensation

**How to Use:**
1. Start with low drive and gradually increase
2. Try different distortion types for various tonal characters
3. Adjust output gain to compensate for level changes
4. Great for adding grit and harmonic richness
5. Use before or after filters for different tonal results

---

### graphic_eq
**8-Band Graphic Equalizer**

An 8-band graphic equalizer with CV outputs for frequency-based triggering.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Band 1-8 Mod` (CV) - Individual band gain modulation
- `Gate Thresh Mod` (CV) - Gate threshold modulation
- `Trig Thresh Mod` (CV) - Trigger threshold modulation

**Outputs:**
- `Out L` (Audio) - Left EQ output
- `Out R` (Audio) - Right EQ output
- `Gate Out` (Gate) - Gates when signal exceeds gate threshold
- `Trig Out` (Gate) - Triggers on transients above trigger threshold

**Parameters:**
- `Gain Band 1-8` (-60 to +12 dB) - Gain for each frequency band (centered at: 60, 170, 310, 600, 1000, 3000, 6000, 12000 Hz)
- `Output Level` (-24 to +24 dB) - Overall output level
- `Gate Threshold` (-60 to 0 dB) - Threshold for gate output
- `Trigger Threshold` (-60 to 0 dB) - Threshold for trigger detection

**How to Use:**
1. Boost or cut specific frequency bands to shape your sound
2. Use negative gain to remove unwanted frequencies
3. Use the gate and trigger outputs for frequency-responsive triggering (great for kick/bass triggering)
4. Combine with other modules for frequency-dependent effects

---

### waveshaper
**Multi-Algorithm Waveshaper**

A distortion effect with multiple waveshaping algorithms for varied saturation and distortion effects.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Drive Mod` (CV) - Drive amount modulation
- `Type Mod` (CV) - Algorithm selection modulation

**Outputs:**
- `Out L` (Audio) - Left waveshaped output
- `Out R` (Audio) - Right waveshaped output

**Parameters:**
- `Drive` (0-100) - Amount of waveshaping
- `Type` (Choice) - Waveshaping algorithm (Soft Clip, Hard Clip, Foldback, etc.)
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Choose a waveshaping algorithm
2. Gradually increase drive to add saturation
3. Try different algorithms for different characters
4. Use mix to blend with the dry signal

---

### 8bandshaper
**Multi-Band Waveshaper**

A multi-band waveshaper that applies frequency-specific distortion across 8 bands.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Drive 1-8 Mod` (CV) - Per-band drive modulation
- `Gain Mod` (CV) - Output gain modulation

**Outputs:**
- `Out L` (Audio) - Left processed output
- `Out R` (Audio) - Right processed output

**Parameters:**
- `Drive Band 1-8` (0-10) - Drive amount for each frequency band
- `Output Gain` (-24 to +24 dB) - Overall output level

**How to Use:**
1. Adjust individual band drives to add selective distortion
2. Drive bass frequencies differently than highs for balanced distortion
3. Great for adding harmonics to specific frequency ranges
4. Use sparingly for subtle enhancement or aggressively for heavy distortion

---

### granulator
**Granular Synthesizer/Effect**

A granular processor that plays small grains of audio for textural and rhythmic effects.

**Inputs:**
- `In L` (Audio) - Left audio input (recorded to internal buffer)
- `In R` (Audio) - Right audio input (recorded to internal buffer)
- `Trigger In` (Gate) - Manual grain triggering
- `Density Mod` (CV) - Grain density modulation
- `Size Mod` (CV) - Grain size modulation
- `Position Mod` (CV) - Playback position modulation
- `Pitch Mod` (CV) - Pitch modulation
- `Gate Mod` (CV) - Gate amount modulation

**Outputs:**
- `Out L` (Audio) - Left granulated output
- `Out R` (Audio) - Right granulated output

**Parameters:**
- `Density` (0.1-100 Hz) - How often grains are triggered
- `Size` (5-500 ms) - Length of each grain
- `Position` (0-1) - Where in the buffer to read grains
- `Spread` (0-1) - Random variation in grain position
- `Pitch` (-24 to +24 semitones) - Pitch shift of grains
- `Pitch Random` (0-12 semitones) - Random pitch variation per grain
- `Pan Random` (0-1) - Random stereo placement per grain
- `Gate` (0-1) - Overall output level/gate

**How to Use:**
1. Audio is continuously recorded to a 2-second buffer
2. Adjust density for grain triggering rate (low=sparse, high=dense cloud)
3. Set grain size (small=rhythmic, large=smooth textures)
4. Use position to read from different parts of the buffer
5. Add spread for more random, evolving textures
6. Modulate position with LFOs for scanning effects
7. Great for creating ambient textures from any sound source

---

### harmonic_shaper
**Harmonic Content Shaper**

Shapes the harmonic content of a signal using frequency-specific waveshaping.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Freq Mod` (CV) - Frequency modulation
- `Drive Mod` (CV) - Drive modulation

**Outputs:**
- `Out L` (Audio) - Left shaped output
- `Out R` (Audio) - Right shaped output

**Parameters:**
- `Master Frequency` (20 Hz - 20 kHz) - Center frequency for harmonic shaping
- `Master Drive` (0-10) - Amount of harmonic emphasis

**How to Use:**
1. Set the master frequency to target specific harmonics
2. Increase drive to emphasize those harmonics
3. Great for adding presence and character to sounds
4. Use on bass for sub-harmonic generation

---

### timepitch
**Time/Pitch Manipulation**

Real-time pitch and time manipulation using the RubberBand library for high-quality time stretching and pitch shifting.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Speed Mod` (CV) - Playback speed modulation
- `Pitch Mod` (CV) - Pitch shift modulation

**Outputs:**
- `Out L` (Audio) - Left processed output
- `Out R` (Audio) - Right processed output

**Parameters:**
- `Speed` (0.25x to 4x) - Playback speed without affecting pitch
- `Pitch` (-24 to +24 semitones) - Pitch shift without affecting tempo
- `Formant` (Bool) - Preserve formants when pitch shifting

**How to Use:**
1. Adjust speed to time-stretch audio (0.5x=half speed, 2x=double speed)
2. Adjust pitch to transpose audio independently
3. Enable formant preservation for natural-sounding vocal pitch shifts
4. Great for creative effects and sound design

---

### de_crackle
**Click/Pop Reducer**

A utility to reduce clicks and pops caused by discontinuous CV or audio signals.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left de-clicked output
- `Out R` (Audio) - Right de-clicked output

**Parameters:**
- `Sensitivity` (Low/Medium/High) - How aggressively to detect and reduce clicks

**How to Use:**
1. Insert after modules that produce discontinuous signals
2. Adjust sensitivity based on the severity of clicks
3. Essential for smoothing abrupt parameter changes
4. Use on CV signals as well as audio

---

## 3. MODULATOR NODES

Modulator nodes generate control voltages for animating parameters over time.

### lfo
**Low-Frequency Oscillator**

A versatile LFO for modulating parameters with periodic waveforms.

**Inputs:**
- `Rate Mod` (CV) - Rate modulation input
- `Depth Mod` (CV) - Depth modulation input
- `Wave Mod` (CV) - Waveform selection modulation

**Outputs:**
- `Out` (CV) - CV modulation output

**Parameters:**
- `Rate` (0.05-20 Hz) - LFO frequency
- `Depth` (0-1) - Modulation amount
- `Bipolar` (Bool) - Output range: On = -1 to +1, Off = 0 to 1
- `Wave` (Choice) - Sine, Triangle, or Sawtooth
- `Sync` (Bool) - Sync to global tempo
- `Division` (Choice) - Note division when synced (1/32 to 8 bars)
- `Relative Mod` (Bool) - When enabled, rate CV is additive around slider position

**How to Use:**
1. Set rate to desired modulation speed
2. Choose bipolar for modulation around a center point, unipolar for one-directional
3. Select waveform based on desired modulation shape
4. Enable Sync and set Division for tempo-locked modulation
5. Connect output to any CV modulation input
6. Use multiple LFOs at different rates for complex modulation

---

### adsr
**Attack-Decay-Sustain-Release Envelope Generator**

A classic ADSR envelope generator for shaping sounds over time.

**Inputs:**
- `Gate In` (Gate) - Gate signal to trigger and hold envelope
- `Trigger In` (Gate) - Trigger signal to retrigger envelope
- `Attack Mod` (CV) - Attack time modulation
- `Decay Mod` (CV) - Decay time modulation
- `Sustain Mod` (CV) - Sustain level modulation
- `Release Mod` (CV) - Release time modulation

**Outputs:**
- `Env Out` (CV) - Main envelope output (0-1)
- `Inv Out` (CV) - Inverted envelope output (1-0)
- `EOR Gate` (Gate) - End of Release gate
- `EOC Gate` (Gate) - End of Cycle gate

**Parameters:**
- `Attack` (0.001-5 seconds) - Rise time from 0 to 1
- `Decay` (0.001-5 seconds) - Fall time from 1 to sustain level
- `Sustain` (0-1) - Held level while gate is high
- `Release` (0.001-5 seconds) - Fall time from sustain to 0 after gate goes low
- `Relative Attack/Decay/Sustain/Release Mod` (Bool) - Enable relative modulation modes

**How to Use:**
1. Connect a gate source (sequencer, MIDI CV, etc.) to Gate In
2. Adjust Attack for how quickly sound reaches full volume
3. Set Decay for how quickly it falls to the sustain level
4. Sustain sets the held level while key/gate is pressed
5. Release controls fade-out time after gate is released
6. Connect Env Out to VCA gain for amplitude shaping
7. Use Inv Out for inverted modulation
8. EOR and EOC gates useful for triggering events at envelope completion

---

### random
**Random Value Generator**

Generates random values at a specified rate with multiple output formats and tempo sync.

**Outputs:**
- `Norm Out` (CV) - Normalized random values (0-1 range)
- `Raw Out` (Raw) - Raw random values (custom range)
- `CV Out` (CV) - CV random values (custom CV range)
- `Bool Out` (Gate) - Random boolean (on/off)
- `Trig Out` (Gate) - Trigger pulse on each new random value

**Parameters:**
- `Rate` (0.1-50 Hz) - How often new random values are generated
- `Min` (-100 to 100) - Minimum value for Raw output
- `Max` (-100 to 100) - Maximum value for Raw output
- `CV Min` (0-1) - Minimum value for CV output
- `CV Max` (0-1) - Maximum value for CV output
- `Norm Min` (0-1) - Minimum value for Norm output
- `Norm Max` (0-1) - Maximum value for Norm output
- `Slew` (0-1) - Smoothing between random values
- `Trig Threshold` (0-1) - Threshold for Bool output
- `Sync` (Bool) - Sync to global tempo
- `Division` (Choice) - Note division when synced

**How to Use:**
1. Set rate for how often random values change
2. Adjust min/max ranges for each output type as needed
3. Use slew to smooth transitions between random values (0=stepped, 1=smooth)
4. Connect different outputs for different modulation needs
5. Use Bool Out for random gates/triggers
6. Enable sync for tempo-locked randomness
7. Great for adding unpredictability and variation to patches

---

### s_and_h
**Sample & Hold**

Samples and holds an input signal when triggered.

**Inputs:**
- `Signal In L` (Audio) - Left signal to sample
- `Signal In R` (Audio) - Right signal to sample
- `Trig In L` (Gate) - Trigger for left channel
- `Trig In R` (Gate) - Trigger for right channel
- `Threshold Mod` (CV) - Trigger threshold modulation
- `Edge Mod` (CV) - Trigger edge selection modulation
- `Slew Mod` (CV) - Slew limiting modulation

**Outputs:**
- `Out L` (Audio) - Left sampled & held output
- `Out R` (Audio) - Right sampled & held output

**Parameters:**
- `Threshold` (0-1) - Trigger threshold level
- `Edge` (Choice) - Rising, Falling, or Both edges
- `Slew` (0-1) - Slew limiting between sampled values

**How to Use:**
1. Connect a signal to sample (CV, audio, etc.)
2. Connect a trigger source (LFO, clock, gate)
3. Each trigger samples the current input value and holds it
4. Adjust threshold if using audio-rate triggers
5. Use slew to smooth transitions between held values
6. Classic for creating stepped random modulation (LFO â†’ S&H â†’ destination)

---

### function_generator
**Drawable Envelope/LFO Generator**

A complex, drawable envelope and LFO generator with multiple curve slots and extensive modulation options.

**Inputs:**
- `Gate In` (Gate) - Gate input for envelope triggering
- `Trigger In` (Gate) - Trigger input for envelope
- `Sync In` (Gate) - Sync input for phase reset
- `Rate Mod` (CV) - Rate modulation
- `Slew Mod` (CV) - Slew limiting modulation
- `Gate Thresh Mod` (CV) - Gate threshold modulation
- `Trig Thresh Mod` (CV) - Trigger threshold modulation
- `Pitch Base Mod` (CV) - Pitch base modulation
- `Value Mult Mod` (CV) - Value multiplier modulation
- `Curve Select Mod` (CV) - Curve selection modulation

**Outputs:**
- `Value` (CV) - Main output value
- `Inverted` (CV) - Inverted output
- `Bipolar` (CV) - Bipolar output (-1 to +1)
- `Pitch` (CV) - Pitch CV output (V/Oct)
- `Gate` (Gate) - Gate output based on threshold
- `Trigger` (Gate) - Trigger output
- `End of Cycle` (Gate) - Trigger at cycle end
- `Blue/Red/Green Value` (CV) - Per-curve outputs
- `Blue/Red/Green Pitch` (CV) - Per-curve pitch outputs

**Parameters:**
- `Rate` (0.05-20 Hz) - Cycle speed
- `Slew` (0-1) - Smoothing between points
- `Gate Threshold` (0-1) - Threshold for gate output
- `Trig Threshold` (0-1) - Threshold for trigger output
- `Pitch Base` (-4 to +4 octaves) - Base pitch offset
- `Value Mult` (0-10) - Value scaling multiplier
- `Curve Select` (0-2) - Choose active curve (Blue, Red, or Green)
- Drawing Interface - Click and drag to draw curves

**How to Use:**
1. Click "Draw" to enter drawing mode
2. Draw up to 3 different curves (Blue, Red, Green tabs)
3. Set rate for cycle speed
4. Use as LFO (free-running) or envelope (gate-triggered)
5. Adjust slew for smooth or stepped transitions
6. Multiple outputs allow simultaneous different modulations
7. Per-curve outputs let you route different curves to different destinations
8. Extremely versatile for complex modulation shapes

---

### shaping_oscillator
**Oscillator with Built-in Waveshaper**

An oscillator with integrated waveshaping for generating harmonically rich tones.

**Inputs:**
- `In L` (Audio) - External audio input (optional, can shape external audio)
- `In R` (Audio) - External audio input right channel
- `Freq Mod` (CV) - Frequency modulation
- `Wave Mod` (CV) - Waveform modulation
- `Drive Mod` (CV) - Drive modulation

**Outputs:**
- `Out` (Audio) - Shaped oscillator output

**Parameters:**
- `Frequency` (20 Hz - 20 kHz) - Oscillator frequency
- `Waveform` (Choice) - Base waveform
- `Drive` (0-10) - Waveshaping amount

**How to Use:**
1. Set frequency for desired pitch
2. Choose base waveform
3. Increase drive to add harmonics via waveshaping
4. Can also process external audio through the shaper
5. Great for thick, harmonically rich tones

---

## 4. UTILITY & LOGIC NODES

Utility nodes provide essential signal processing, routing, and logic operations.

### vca
**Voltage-Controlled Amplifier**

A basic amp module for controlling audio levels with CV.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Gain Mod` (CV) - Gain modulation

**Outputs:**
- `Out L` (Audio) - Left amplified output
- `Out R` (Audio) - Right amplified output

**Parameters:**
- `Gain` (-60 to +12 dB) - Base gain level

**How to Use:**
1. Send audio through the VCA
2. Connect an envelope or LFO to Gain Mod for amplitude control
3. Essential for creating dynamic amplitude envelopes
4. The core of any subtractive synthesis voice

---

### mixer
**Stereo Audio Mixer**

A two-input stereo mixer with gain, pan, and crossfade controls.

**Inputs:**
- `In A L/R` (Audio) - Input A stereo pair
- `In B L/R` (Audio) - Input B stereo pair
- `Gain Mod` (CV) - Gain modulation
- `Pan Mod` (CV) - Pan modulation
- `X-Fade Mod` (CV) - Crossfade modulation

**Outputs:**
- `Out L/R` (Audio) - Mixed stereo output

**Parameters:**
- `Gain` (-60 to +12 dB) - Overall output gain
- `Pan` (-1 to +1) - Stereo panning
- `Crossfade` (0-1) - Blend between input A (0) and input B (1)

**How to Use:**
1. Connect two stereo sources
2. Use crossfade to blend between them
3. Adjust gain and pan for final mix
4. Modulate crossfade with LFOs or envelopes for dynamic mixing

---

### cv_mixer
**Control Voltage Mixer**

A mixer specifically designed for mixing CV signals.

**Inputs:**
- `In A/B` (CV) - CV inputs
- `Gain Mod` (CV) - Gain modulation

**Outputs:**
- `Out` (CV) - Mixed CV output

**Parameters:**
- `Gain A/B` (-2 to +2) - Gain for each input

**How to Use:**
1. Mix multiple CV sources together
2. Use negative gain to invert signals
3. Create complex modulation by combining LFOs and envelopes
4. Essential for additive CV processing

---

### track_mixer
**Multi-Channel Mixer**

A mixer for up to 8 monophonic tracks with individual gain and pan controls.

**Inputs:**
- `In 1-8` (Audio) - 8 mono audio inputs
- `Num Tracks Mod` (Raw) - Number of active tracks modulation
- `Gain 1-8 Mod` (CV) - Per-track gain modulation
- `Pan 1-8 Mod` (CV) - Per-track pan modulation

**Outputs:**
- `Out L/R` (Audio) - Stereo mixed output

**Parameters:**
- `Num Tracks` (1-8) - Number of active tracks
- `Gain 1-8` (-60 to +12 dB) - Per-track gain
- `Pan 1-8` (-1 to +1) - Per-track stereo panning

**How to Use:**
1. Connect multiple mono sources (great with PolyVCO outputs)
2. Adjust per-track gain and pan
3. Set Num Tracks to control how many inputs are active
4. Perfect for mixing polyphonic voices

---

### panvol
**2D Volume and Panning Control**

A compact, intuitive control surface that provides simultaneous volume and panning adjustment via a draggable circle on a 2D grid.

**Inputs:**
- `Pan Mod` (CV) - Panning modulation input
- `Vol Mod` (CV) - Volume modulation input

**Outputs:**
- `Pan Out` (CV) - Panning CV output (normalized 0.0 to 1.0, maps to -1.0 to +1.0 in mixers)
- `Vol Out` (CV) - Volume CV output (normalized 0.0 to 1.0, maps to -60dB to +6dB in mixers)

**Parameters:**
- `Pan` (-1.0 to +1.0) - Panning position (-1.0 = Full Left, 0.0 = Center, +1.0 = Full Right)
- `Volume` (-60.0 to +6.0 dB) - Volume level (0.0 dB = Unity gain)

**How to Use:**
1. **Interactive Control:**
   - Click and drag the circle on the grid to adjust both volume and panning simultaneously
   - Vertical movement controls volume (up = louder, down = quieter)
   - Horizontal movement controls panning (left = left, right = right)
   - Click anywhere on the grid to jump the circle to that position

2. **Connecting to Mixers:**
   - Connect `Pan Out` â†’ Mixer's `Pan Mod` input
   - Connect `Vol Out` â†’ Mixer's `Gain Mod` input
   - Or connect to Track Mixer's per-track pan and gain modulation inputs

3. **CV Modulation:**
   - Connect CV sources to `Pan Mod` and `Vol Mod` inputs for automated control
   - When CV is connected, manual control is disabled (indicated by cyan circle color)
   - Perfect for LFO-driven spatial effects or envelope-controlled volume sweeps

4. **Reset Button:**
   - Click "Reset to Center" to instantly return to center pan and unity gain

5. **Creative Applications:**
   - Live performance: Quick volume and pan adjustments during performance
   - Spatial mixing: Precise positioning of sounds in stereo field
   - Automation: Connect to sequencers or LFOs for automated movement
   - Gesture control: Connect to motion sensors or touch controllers for hands-free control

**Visual Feedback:**
- Orange circle = Manual control active
- Cyan circle = CV modulation active
- Grid lines and center crosshair for visual reference
- Axis labels (â†‘ Vol, â† Pan â†’) for orientation

---

### attenuverter
**Attenuate/Invert Signal**

Attenuates (reduces) and/or inverts CV or audio signals.

**Inputs:**
- `In L/R` (Audio) - Stereo inputs
- `Amount Mod` (CV) - Amount modulation

**Outputs:**
- `Out L/R` (Audio) - Processed outputs

**Parameters:**
- `Amount` (-1 to +1) - Attenuation/inversion amount (0=silent, 0.5=half, 1=full, negative=inverted)

**How to Use:**
1. Use positive values (0-1) to reduce signal levels
2. Use negative values (-1-0) to invert and reduce
3. Set to 0 for silence
4. Essential for scaling modulation amounts
5. Use to create inverted versions of CV for opposite modulation

---

### lag_processor
**Slew Limiter/Smoother**

Smooths abrupt changes in signals using independent rise and fall times.

**Inputs:**
- `Signal In` (CV) - CV input to smooth
- `Rise Mod` (CV) - Rise time modulation
- `Fall Mod` (CV) - Fall time modulation

**Outputs:**
- `Smoothed Out` (CV) - Smoothed CV output

**Parameters:**
- `Rise Time` (0.1-1000 ms) - Time to reach rising values
- `Fall Time` (0.1-1000 ms) - Time to reach falling values

**How to Use:**
1. Insert between a CV source and destination to smooth transitions
2. Use equal rise/fall times for symmetrical smoothing
3. Use different rise/fall for attack/release character
4. Great for portamento effects and smoothing stepped sequences
5. Can turn hard gates into smooth envelopes

---

### math
**Mathematical Operations**

Performs mathematical operations on two input signals.

**Inputs:**
- `In A` (CV) - First operand
- `In B` (CV) - Second operand

**Outputs:**
- `Add` (CV) - A + B
- `Subtract` (CV) - A - B
- `Multiply` (CV) - A Ã— B
- `Divide` (CV) - A Ã· B

**Parameters:**
- `Value A` (-100 to 100) - Default value for A (used if not patched)
- `Value B` (-100 to 100) - Default value for B (used if not patched)
- `Operation` (Choice) - Add, Subtract, Multiply, Divide, Min, Max, Power, Sqrt(A), Sin(A), Cos(A), Tan(A), Abs(A), Modulo, Fract(A), Int(A), A>B, A<B

**How to Use:**
1. Connect CV sources or use internal values
2. Choose operation
3. Use outputs for complex CV processing
4. Create custom modulation shapes by combining operations
5. Use comparison operations (A>B, A<B) for logic

---

### map_range
**Value Range Mapper**

Remaps values from one range to another.

**Inputs:**
- `Raw In` (Raw) - Input value to remap

**Outputs:**
- `CV Out` (CV) - Remapped to 0-1 range
- `Audio Out` (Audio) - Remapped to audio-rate

**Parameters:**
- `Min In` (-1000 to 1000) - Input range minimum
- `Max In` (-1000 to 1000) - Input range maximum
- `Min Out` (-1000 to 1000) - Output range minimum
- `Max Out` (-1000 to 1000) - Output range maximum

**How to Use:**
1. Define your input range (min/max in)
2. Define your desired output range (min/max out)
3. Connect input signal
4. Output is linearly scaled to new range
5. Great for converting between different parameter ranges

---

### quantizer
**Musical Scale Quantizer**

Snaps continuous CV to musical scales.

**Inputs:**
- `CV In` (CV) - Continuous pitch CV
- `Scale Mod` (CV) - Scale selection modulation
- `Root Mod` (CV) - Root note modulation

**Outputs:**
- `Out` (CV) - Quantized pitch CV

**Parameters:**
- `Scale` (Choice) - Musical scale (Major, Minor, Chromatic, Pentatonic, etc.)
- `Root` (Choice) - Root note (C, C#, D, etc.)

**How to Use:**
1. Connect a continuous CV source (LFO, random, etc.)
2. Choose a musical scale
3. Set the root note
4. Output will snap to nearest note in the scale
5. Great for creating melodic sequences from random sources

---

### rate
**Rate Value Converter**

Converts raw values to normalized rate values for tempo-related modulation.

**Inputs:**
- `Rate Mod` (CV) - Rate modulation input

**Outputs:**
- `Out` (CV) - Normalized rate output

**Parameters:**
- `Rate` (0.1-20) - Rate multiplier

**How to Use:**
1. Use to convert between different rate representations
2. Useful for tempo-syncing external modulators
3. Provides standardized rate output for consistent timing

---

### comparator
**Threshold Comparator**

Outputs a gate signal when input exceeds a threshold.

**Inputs:**
- `In` (CV) - CV input to compare

**Outputs:**
- `Out` (Gate) - Gate output (high when input > threshold)

**Parameters:**
- `Threshold` (0-1) - Comparison threshold

**How to Use:**
1. Connect a CV source
2. Set threshold
3. Output goes high when input exceeds threshold
4. Great for converting CV to gates
5. Create rhythm from slow LFOs

---

### logic
**Boolean Logic Operations**

Performs boolean logic operations on gate signals.

**Inputs:**
- `In A` (Gate) - First input
- `In B` (Gate) - Second input

**Outputs:**
- `AND` (Gate) - High when both inputs are high
- `OR` (Gate) - High when either input is high
- `XOR` (Gate) - High when inputs differ
- `NOT A` (Gate) - Inverted A

**How to Use:**
1. Connect two gate sources
2. Use outputs for different logic combinations
3. AND: Both gates must be high (good for requiring multiple conditions)
4. OR: Either gate can be high (good for combining triggers)
5. XOR: Only one gate high (good for alternating patterns)
6. NOT A: Invert a gate signal

---

### clock_divider
**Clock Division/Multiplication**

Divides and multiplies clock signals for polyrhythmic patterns.

**Inputs:**
- `Clock In` (Gate) - Clock input to divide/multiply
- `Reset` (Gate) - Reset all divisions to sync

**Outputs:**
- `/2, /4, /8` (Gate) - Divided clocks (half, quarter, eighth speed)
- `x2, x3, x4` (Gate) - Multiplied clocks (double, triple, quadruple speed)

**How to Use:**
1. Connect a clock source
2. Use divided outputs for slower rhythms
3. Use multiplied outputs for faster rhythms
4. Create polyrhythmic patterns by using multiple outputs
5. Use reset to synchronize all divisions

---

### sequential_switch
**Signal Router**

Routes an input signal to one of four outputs based on CV thresholds.

**Inputs:**
- `Gate In` (Audio) - Signal to route
- `Thresh 1-4 CV` (CV) - Threshold values for each output

**Outputs:**
- `Out 1-4` (Audio) - Four possible output destinations

**Parameters:**
- `Threshold 1-4` (0-1) - Threshold levels

**How to Use:**
1. Connect a signal to Gate In
2. Set thresholds for each output
3. As input CV changes, signal routes to different outputs
4. Use with sequencers or LFOs for rhythmic switching
5. Great for creating evolving patterns

---

## 5. SEQUENCER NODES

Sequencer nodes generate rhythmic and melodic patterns.

### sequencer
**16-Step CV/Gate Sequencer**

A classic 16-step sequencer for creating melodies and rhythms.

**Inputs:**
- Extensive per-step modulation inputs for values, triggers, and gates

**Outputs:**
- `Pitch` (CV) - Current step pitch value
- `Gate` (Gate) - Gate output
- `Gate Nuanced` (CV) - Gate with velocity
- `Velocity` (CV) - Velocity value
- `Mod` (CV) - Modulation output
- `Trigger` (Gate) - Trigger on each step

**Parameters:**
- `Rate` (0.1-20 Hz) - Sequence speed
- `Num Steps` (1-16) - Number of active steps
- `Gate Length` (0-1) - Duration of gates
- Per-step: Pitch, Gate, Velocity, Modulation values

**How to Use:**
1. Set number of steps and rate
2. Program pitch values for each step
3. Set gates on/off for rhythm
4. Adjust gate length for articulation
5. Can sync to Tempo Clock for musical timing

---

### multi_sequencer
**Advanced Multi-Output Sequencer**

An advanced sequencer with parallel per-step outputs for polyphonic sequencing.

**Outputs:**
- Live outputs: Pitch, Gate, Trigger, Velocity, Mod
- Parallel outputs: Pitch 1-16, Gate 1-16, Trig 1-16 (all steps output simultaneously)

**How to Use:**
1. Similar to Sequencer but with simultaneous output of all 16 steps
2. Connect parallel outputs to PolyVCO for poly synth
3. Create complex polyphonic arrangements
4. Each step can trigger independently

---

### tempo_clock
**Global Clock Generator**

Master tempo/clock source with transport controls.

**Inputs:**
- `BPM Mod` (CV) - BPM modulation
- `Tap` (Gate) - Tap tempo input
- `Nudge+/-` (Gate) - Fine tempo adjustment
- `Play/Stop/Reset` (Gate) - Transport controls
- `Swing Mod` (CV) - Swing amount modulation

**Outputs:**
- `Clock` (Gate) - Main clock pulse
- `Beat Trig` (Gate) - Trigger on each beat
- `Bar Trig` (Gate) - Trigger on each bar
- `Beat Gate` (Gate) - Gate for beat duration
- `Phase` (CV) - Clock phase (0-1)
- `BPM CV` (CV) - BPM as CV
- `Downbeat` (Gate) - First beat of bar

**Parameters:**
- `BPM` (20-300) - Tempo in beats per minute
- `Time Signature` (Choice) - 4/4, 3/4, 6/8, etc.
- `Swing` (0-100%) - Swing amount
- `Global Division` (Bool) - Override all synced modules' divisions

**How to Use:**
1. Set BPM for your project
2. Use clock outputs to drive sequencers and LFOs
3. Enable Global Division to control all synced modules at once
4. Use transport controls for performance

---

### snapshot_sequencer
**Patch State Sequencer**

Sequences complete patch states, recalling all parameter values.

**How to Use:**
1. Create snapshots of your entire patch at different states
2. Sequence through snapshots for dramatic changes
3. Great for live performance and automation

---

### stroke_sequencer
**Gesture-Based Sequencer**

Records and plays back drawn gestures as CV sequences.

**How to Use:**
1. Draw patterns with your mouse/tablet
2. Playback converts drawing to CV
3. Unique way to create expressive, human-feeling sequences

---

### timeline
**Automation Recorder and Playback**

A transport-synchronized automation recorder that captures and plays back CV, Gate, Trigger, and Raw signals with sample-accurate precision. The Timeline Node serves as the single source of truth for temporal automation in the modular synthesizer.

**Inputs (Dynamic):**
- `[Channel Name] In` (CV) - One input per automation channel (up to 32 channels)

**Outputs (Dynamic):**
- `[Channel Name] Out` (CV) - One output per automation channel (up to 32 channels)

**Parameters:**
- `Record` (Bool) - Enable recording mode (mutually exclusive with Play)
- `Play` (Bool) - Enable playback mode (mutually exclusive with Record)
- `Add Channel` (Button) - Create a new automation channel
- `Remove Channel` (Button) - Remove the last automation channel

**Auto-Connect Shortcuts:**
- **B (CV)**: Chain automation outputs to CV modulation inputs
- **Y (Gate)**: Chain gate/trigger outputs to gate inputs
- **R (Raw)**: Chain raw value outputs

**How to Use:**
1. **Setup Channels:**
   - Click "Add Channel" to create automation channels
   - Each channel can record a separate signal (CV, Gate, Trigger, or Raw)
   - Channels are automatically named (e.g., "Channel 1", "Channel 2")
   
2. **Recording:**
   - Connect signals you want to record to the Timeline's input pins
   - Click the "â— REC" button to enable recording
   - Start the global transport (Tempo Clock)
   - The Timeline records keyframes with sample-accurate timing
   - Recording automatically detects value changes (only stores new keyframes when values change)
   - Click "â— REC" again to stop recording
   
3. **Playback:**
   - Click the "â–¶ PLAY" button to enable playback
   - Start the global transport
   - The Timeline plays back recorded automation, interpolating between keyframes
   - Playback is sample-accurate and synchronized to the global tempo
   
4. **Visualization:**
   - Select a channel from the list to view its keyframes
   - A waveform plot shows the recorded automation curve
   - The UI displays the current playback position in Bar:Beat:Tick format
   
5. **Persistence:**
   - Automation data is automatically saved with presets
   - All channels and keyframes are preserved when saving/loading patches
   
6. **Tips:**
   - Use multiple channels to record different parameters simultaneously
   - Record is mutually exclusive with Play - switch modes as needed
   - The Timeline passes through signals when neither Record nor Play is active (zero-latency monitoring)
   - Great for creating complex automation that syncs perfectly to tempo

**Technical Details:**
- Synchronized with global `TransportState` (from Tempo Clock)
- Sample-accurate keyframe recording and playback
- Linear interpolation between keyframes during playback
- Thread-safe data access (audio thread + UI thread)
- XML persistence via `getExtraStateTree()` / `setExtraStateTree()`
- Dynamic I/O pins based on number of automation channels

---

## 6. MIDI NODES

MIDI nodes handle MIDI input/output and conversion to CV.

### midi_cv
**MIDI to CV Converter**

Converts incoming MIDI notes to CV/Gate signals (monophonic).

**Outputs:**
- `Pitch` (CV) - Note pitch as CV (V/Oct)
- `Gate` (Gate) - Note on/off gate
- `Velocity` (CV) - Note velocity
- `Mod Wheel` (CV) - CC1 modulation wheel
- `Pitch Bend` (CV) - Pitch bend wheel
- `Aftertouch` (CV) - Channel aftertouch

**How to Use:**
1. Connect MIDI controller or use virtual MIDI
2. Play notes â†’ outputs CV/Gate
3. Use with VCO + VCA + ADSR for classic synth voice
4. Monophonic (last note priority)

---

### midi_player
**MIDI File Player**

Plays MIDI files with per-track CV/Gate outputs.

**How to Use:**
1. Load a MIDI file
2. Outputs CV/Gate for each MIDI track
3. Great for backing tracks or complex sequences

---

### midi_faders
**MIDI-Learnable Faders (1-16)**

1-16 MIDI-learnable faders with customizable output ranges.

**Outputs:**
- `Fader 1-16` (CV) - CV outputs (0-1 range)

**Parameters:**
- MIDI Learn for each fader
- Min/Max output range per fader

**How to Use:**
1. Click MIDI Learn
2. Move a fader on your controller
3. Fader is now linked
4. Adjust output ranges as needed

---

### midi_knobs
**MIDI-Learnable Knobs (1-16)**

Similar to MIDI Faders but optimized for rotary controls.

---

### midi_buttons
**MIDI-Learnable Buttons (1-32)**

1-32 MIDI-learnable buttons with Gate/Toggle/Trigger modes.

**Outputs:**
- `Button 1-32` (Gate) - Gate/trigger outputs

**Modes:**
- Gate: High while pressed
- Toggle: Alternates on/off each press
- Trigger: Brief pulse on press

---

### midi_jog_wheel
**MIDI Jog Wheel Control**

A single MIDI-learnable jog wheel for expressive modulation.

**Output:**
- `Value` (CV) - Wheel position/velocity

---

## 7. ANALYSIS NODES

Analysis nodes visualize and inspect signals.

### scope
**Oscilloscope**

Visualizes audio or CV signals over time.

**Inputs/Outputs:**
- `In/Out` (Audio) - Pass-through with visualization

**Parameters:**
- `Window Size` (0.5-20 seconds) - Time window to display
- `Trigger Mode` (Choice) - Free-run, Rising Edge, Falling Edge
- `Trigger Level` (0-1) - Trigger threshold

**How to Use:**
1. Insert in signal path (pass-through)
2. Adjust window size to see desired time range
3. Use trigger modes for stable waveform display
4. Great for debugging and sound design

---

### debug
**Signal Value Logger**

Logs signal value changes to the console.

**How to Use:**
1. Insert in CV path
2. Logs values to console when they change
3. Great for troubleshooting CV routing
4. No audio output (endpoint)

---

### input_debug
**Passthrough Debug Logger**

Like Debug but with pass-through output.

---

### frequency_graph
**Spectrum Analyzer**

High-resolution real-time spectrum analyzer with frequency-based gate outputs.

**Inputs:**
- `In` (Audio) - Mono audio to analyze

**Outputs:**
- `Out L/R` (Audio) - Stereo pass-through
- `Sub/Bass/Mid/High Gate` (Gate) - Per-band gate outputs
- `Sub/Bass/Mid/High Trig` (Gate) - Per-band trigger outputs

**Parameters:**
- `Gate Threshold` per band - Threshold for gate outputs

**How to Use:**
1. Send audio through for visualization
2. Displays frequency spectrum in real-time
3. Use gate/trigger outputs for frequency-reactive triggering
4. Great for kick drum detection, bass triggering, etc.

---

## 8. SPECIAL NODES

Special nodes provide unique functionality beyond traditional synthesis.

### tts_performer
**Text-to-Speech Engine**

Advanced text-to-speech with word-level sequencing.

**Inputs:**
- Per-word trigger inputs (1-16)
- Rate, Gate, Speed, Pitch modulation

**Outputs:**
- `Audio` - Speech audio output
- `Word Gate` - Gate while speaking
- `EOP Gate` - End of phrase gate
- Per-word gates and triggers (1-16)

**Parameters:**
- Text input field
- Voice selection
- Rate, pitch, speed controls

**How to Use:**
1. Type text into text field
2. Choose voice
3. Trigger individual words or play entire phrase
4. Use per-word gates for word-synced events
5. Modulate pitch/speed for effects

---

### vocal_tract_filter
**Formant Filter**

Simulates human vowel sounds through formant filtering.

**Parameters:**
- `Vowel Shape` - Continuous blend between vowels (A, E, I, O, U)
- `Formant Shift` - Shift formant frequencies up/down
- `Instability` - Add human-like variation
- `Gain` - Formant emphasis

**How to Use:**
1. Send audio through (great with sawtooth waves)
2. Adjust vowel shape to morph between vowels
3. Modulate with LFOs for talking/singing effects
4. Use with TTS Performer for enhanced vocal synthesis

---

### physics
**2D Physics Simulation**

A 2D physics engine that outputs collision and contact data as CV.

**How to Use:**
1. Create physics objects in the UI
2. Set gravity, friction, elasticity
3. Objects collide and interact
4. Outputs include position, velocity, collision events
5. Use outputs to drive synthesis parameters
6. Experimental and creative

---

### animation
**3D Animation Player**

Loads and plays 3D animations, outputs joint positions and velocities.

**How to Use:**
1. Load 3D animation file (FBX, etc.)
2. Play animation
3. Outputs joint positions as CV
4. Drive synthesis from motion capture data

---

## 9. COMPUTER VISION NODES

Computer vision nodes process video for audio/CV generation.

### webcam_loader
**Webcam Video Source**

Captures video from webcam and publishes a `Source ID` for vision processing modules.

**Outputs:**
- `Source ID` (Video) - Video source identifier

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect `Source ID` to any `Source In` (Video) input on vision processing modules (e.g., Movement/Human/Object/Color/Pose/Hand/Face/Contour/Segmentation).
- Other chaining keys (**C/G/B/Y/R**) not applicable for this node.

---

### video_file_loader
**Video File Source**

Loads and plays video files; publishes a `Source ID` for vision processing modules.

**Outputs:**
- `Source ID` (Video) - Video source identifier

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect `Source ID` to any `Source In` (Video) input on vision processing modules.
- Other chaining keys (**C/G/B/Y/R**) not applicable for this node.

---

### movement_detector
**Motion Detection**

Analyzes video for motion via optical flow or background subtraction.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Motion X` (CV), `Motion Y` (CV) - Motion vector components
- `Amount` (CV) - Total motion amount
- `Trigger` (Gate) - Trigger on significant motion
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` â†’ next video module
- **B (CV)**: Chain `Motion X/Y/Amount` to CV destinations
- **Y (Gate)**: Chain `Trigger` to gate inputs

**How to Use:**
1. Connect webcam or video file loader
2. Outputs motion as CV
3. Use for interactive installations
4. Motion triggers synthesis events

---

### human_detector
**Face/Body Detection**

Detects faces or bodies in video via Haar Cascades or HOG.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `X` (CV), `Y` (CV) - Center position
- `Width` (CV), `Height` (CV) - Bounding box size
- `Gate` (Gate) - High when person detected
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected face/body

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` or `Cropped Out` â†’ next video module
- **B (CV)**: Chain X/Y/Width/Height to CV inputs
- **Y (Gate)**: Chain `Gate` to gate inputs

**How to Use:**
1. Connect video source
2. Detects faces/bodies
3. Outputs position and size as CV
4. Use for interactive performances

---

### pose_estimator
**Body Keypoint Detection**

Uses OpenPose MPI model to detect 15 body keypoints. Outputs 30 CV pins programmatically (X/Y for each keypoint).

**Inputs:**
- `Source In` (Video) - Video source ID from webcam or video file loader

**Outputs (dynamic/programmatic):**
- `Head X/Y`, `Neck X/Y`, `R Shoulder X/Y`, `R Elbow X/Y`, `R Wrist X/Y`, `L Shoulder X/Y`, `L Elbow X/Y`, `L Wrist X/Y`, `R Hip X/Y`, `R Knee X/Y`, `R Ankle X/Y`, `L Hip X/Y`, `L Knee X/Y`, `L Ankle X/Y`, `Chest X/Y` (all CV)
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected body

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` or `Cropped Out` â†’ next video module
- **B (CV)**: Chain any keypoint X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1). Lower values detect more keypoints but may include false positives
- `Draw Skeleton` (Bool) - Toggle skeleton overlay on video preview
- `Zoom` (+/-) - Toggle between normal (480px) and zoomed (960px) video preview

**How to Use:**
1. **Setup:** Download OpenPose MPI model files (see `guides/POSE_ESTIMATOR_SETUP.md`)
2. **Connect Video Source:** Connect a Webcam Loader or Video File Loader's `Source ID` output to `Source In`
3. **Adjust Confidence:** Lower threshold for more sensitive detection, higher for more reliable detection
4. **Map Keypoints:** Connect individual keypoint X/Y outputs to any CV modulation input
5. **Example Patches:**
   - **Hand-Controlled Oscillator:** Connect `R Wrist X` â†’ VCO Frequency, `R Wrist Y` â†’ VCF Cutoff
   - **Body-Driven Rhythm:** Connect `R Knee Y` â†’ Sequencer Rate, `L Knee Y` â†’ Gate threshold
   - **Dance Performance:** Map multiple keypoints to different parameters for full-body control
6. **Performance Tips:**
   - Good lighting improves detection accuracy
   - Stand 1-3 meters from camera for best results
   - Keep full body in frame for all keypoints to be detected
   - Simple backgrounds work best

**Technical Details:**
- Uses OpenPose MPI (faster) model with 15 keypoints
- Runs at ~15 FPS on CPU (computationally intensive)
- Outputs normalized coordinates (0-1 range)
- Real-time safe: Processing runs on separate thread, lock-free FIFO to audio thread
- Video preview shows skeleton overlay when enabled

**Creative Applications:**
- **Interactive Installations:** Create body-responsive soundscapes
- **Live Performance:** Control synthesis with gestures and movement
- **Accessibility:** Hands-free instrument control for performers with mobility constraints
- **Dance + Music:** Choreography-driven composition
- **Fitness Apps:** Exercise-triggered sound design
- **Game Controllers:** Full-body game audio integration

**Requirements:**
- OpenPose MPI model files (~200 MB download)
- Webcam or video file source
- OpenCV with DNN module (included in build)

---

### hand_tracker
**Hand Keypoint Detection**

Uses OpenPose hand model to detect 21 hand keypoints. Outputs 42 CV pins (X/Y per keypoint).

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic/programmatic):**
- `Wrist X/Y`, `Thumb 1-4 X/Y`, `Index 1-4 X/Y`, `Middle 1-4 X/Y`, `Ring 1-4 X/Y`, `Pinky 1-4 X/Y` (all CV)
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected hand

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` or `Cropped Out` â†’ next video module
- **B (CV)**: Chain any keypoint X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires OpenPose hand model files in `assets/openpose_models/hand/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Adjust Confidence:** Lower values for sensitive detection, higher for reliable detection
4. **Map Gestures:** Connect finger joint positions to synthesis parameters
5. **Example Patches:**
   - **Gesture Control:** Map thumb position to filter cutoff, index position to VCO frequency
   - **Finger Tracking:** Use individual finger tips for multi-parameter control
   - **Hand Size:** Use wrist to fingertip distances for amplitude or volume control
6. **Performance Tips:**
   - Works best with hands clearly visible against contrasting background
   - Keep hands ~30-80cm from camera
   - Good lighting improves detection accuracy

**Technical Details:**
- Uses OpenPose hand detection model
- Detects 21 keypoints per hand
- Runs at ~15 FPS on CPU
- Outputs normalized coordinates (0-1 range)

---

### face_tracker
**Facial Landmark Detection**

Uses OpenPose face model to detect 70 facial landmarks. Outputs 140 CV pins (X/Y per point).

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic/programmatic):**
- `Pt 1-70 X/Y` (CV) - Landmark positions
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected face

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` or `Cropped Out` â†’ next video module
- **B (CV)**: Chain landmark X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires OpenPose face model files in `assets/openpose_models/face/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Adjust Confidence:** Lower values for sensitive detection, higher for reliable detection
4. **Map Landmarks:** Connect facial landmark positions to synthesis parameters
5. **Example Patches:**
   - **Expression Control:** Map mouth width to effect parameters, eyebrow position to filter resonance
   - **Head Tracking:** Use face center for spatial panning
   - **Lip Sync:** Use mouth landmarks for vocoder or formant filtering
6. **Performance Tips:**
   - Face-front camera position works best
   - Keep face well-lit
   - Maintain 50-150cm distance from camera

**Technical Details:**
- Uses Haar Cascade for face detection, OpenPose DNN for landmark estimation
- Detects 70 landmarks per face
- Runs at ~15 FPS on CPU
- Outputs normalized coordinates (0-1 range)

---

### object_detector
**YOLOv3 Object Detection**

Uses YOLOv3 deep learning model to detect objects from 80 COCO classes (person, car, bottle, etc.) in real-time video.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `X` (CV) - Center X position (0-1)
- `Y` (CV) - Center Y position (0-1)
- `Width` (CV) - Width (0-1)
- `Height` (CV) - Height (0-1)
- `Gate` (Gate) - High when target detected
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected object

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` or `Cropped Out` â†’ next video module
- **B (CV)**: Chain X/Y/Width/Height to CV inputs
- **Y (Gate)**: Chain `Gate` to gate inputs

**Parameters:**
- `Target Class` (Choice) - Object class to detect (person, car, bicycle, etc.)
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.5)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires YOLOv3 model files (`yolov3.cfg`, `yolov3.weights`, `coco.names`) in `assets/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Select Target Class:** Choose which object type to detect
4. **Adjust Confidence:** Lower for more detections (may include false positives), higher for reliable detection
5. **Map Coordinates:** Connect X/Y/Width/Height outputs to synthesis parameters
6. **Example Patches:**
   - **Person Tracking:** Use person bounding box to trigger events when person enters/exits frame
   - **Object Size Control:** Use Width Ã— Height to control effect amount
   - **Position-Based Effects:** Map center X to panning, center Y to filter cutoff
7. **Performance Tips:**
   - YOLO is computationally intensive (~10 FPS on CPU)
   - Good lighting and contrast improve detection
   - Larger objects are detected more reliably

**Technical Details:**
- Uses YOLOv3 (You Only Look Once v3) detection model
- 80 COCO object classes supported
- Runs at ~10 FPS on CPU
- Outputs normalized bounding box coordinates
- Falls back to YOLOv3-tiny if standard model not available

---

### color_tracker
**Multi-Color HSV Tracking**

Tracks multiple custom colors in video using HSV color space. Outputs are dynamic: each added color creates three CV outputs.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic):**
- For each tracked color:
  - `[Color] X` (CV) - Center X (0-1)
  - `[Color] Y` (CV) - Center Y (0-1)
  - `[Color] Area` (CV) - Covered area (0-1)
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` â†’ next video module
- **B (CV)**: Chain per-color X/Y/Area to CV inputs

**Parameters:**
- `Add Color...` (Button) - Click to pick a color from the video preview
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
2. **Pick Colors:** Click "Add Color..." and click on the video preview to sample a color
3. **Track Multiple:** Add up to 8 different colors to track simultaneously
4. **Remove Colors:** Click "Remove" button next to each tracked color
5. **Map Coordinates:** Connect individual color outputs to synthesis parameters
6. **Example Patches:**
   - **Two-Object Control:** Track two colored objects for stereo panning or dual oscillator control
   - **Area-Based Effects:** Use Area output to control effect wet/dry mix
   - **Position Automation:** Map color X/Y to sequencer position or filter sweeps
7. **Performance Tips:**
   - Works best with saturated, distinct colors
   - Avoid overlapping colors in similar hues
   - Good lighting maintains consistent HSV values

**Technical Details:**
- Uses HSV color space for robust color detection
- Tracks up to 8 colors simultaneously
- Automatic morphological cleanup for noise reduction
- Runs at ~30 FPS on CPU
- Outputs normalized coordinates and area

---

### contour_detector
**Shape Detection via Background Subtraction**

Detects shapes and their properties using background subtraction and contour analysis.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Area` (CV) - Detected shape area (0-1)
- `Complexity` (CV) - Polygon complexity (0-1)
- `Aspect Ratio` (CV) - Width/height ratio
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` â†’ next video module
- **B (CV)**: Chain outputs to CV inputs

**Parameters:**
- `Threshold` (0-255) - Threshold for foreground/background separation (default: 128)
- `Noise Reduction` (Bool) - Enable morphological filtering to reduce noise (default: On)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
2. **Adjust Threshold:** Set threshold to separate foreground from background
3. **Enable Noise Reduction:** Reduce detection of small, noisy artifacts
4. **Map Shape Properties:** Connect Area, Complexity, and Aspect Ratio to synthesis parameters
5. **Example Patches:**
   - **Size-Based Filtering:** Use Area to control low-pass filter cutoff
   - **Shape Recognition:** Use Complexity to detect simple vs complex shapes
   - **Orientation Control:** Use Aspect Ratio to determine if object is horizontal or vertical
6. **Performance Tips:**
   - Requires relatively static background for best results
   - Good contrast between foreground and background
   - Use noise reduction for clean signal

**Technical Details:**
- Uses MOG2 background subtraction
- Polygon approximation for complexity calculation
- Runs at ~25 FPS on CPU
- Outputs normalized shape properties

---

### semantic_segmentation
**Scene Segmentation via Deep Learning**

Uses semantic segmentation (ENet or DeepLabV3) to identify a target class and output region properties.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Area` (CV) - Frame coverage of target class (0-1)
- `Center X` (CV) - Center X of detected region (0-1)
- `Center Y` (CV) - Center Y of detected region (0-1)
- `Gate` (Gate) - High when target detected
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` â†’ `Source In`; chain `Video Out` â†’ next video module
- **B (CV)**: Chain Area and Center outputs to CV targets.
- **Y (Gate)**: Chain `Gate` to gate inputs.

**Parameters:**
- `Target Class` (Choice) - Semantic class to detect (person, road, car, etc.)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires ENet or DeepLabV3 model files in `assets/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Select Target Class:** Choose which semantic class to track
4. **Map Region Properties:** Connect Area and Center outputs to synthesis parameters
5. **Example Patches:**
   - **Presence Detection:** Use Gate output to trigger events when person enters frame
   - **Coverage-Based Effects:** Use Area to control reverb size or delay feedback
   - **Center Tracking:** Use Center X/Y for spatial effects
6. **Performance Tips:**
   - Computationally intensive (~10 FPS on CPU)
   - Best results with scenes that match training data (Cityscapes, etc.)
   - Works well for large, distinct regions

**Technical Details:**
- Uses ENet (Efficient Neural Network) or DeepLabV3 segmentation models
- Supports Cityscapes dataset classes by default
- Runs at ~10 FPS on CPU
- Outputs normalized region properties with colored preview overlay

---

### video_fx
**Real-Time Video Effects Processor**

A comprehensive video processing node that applies real-time effects to video streams. Supports chaining multiple effects for complex video transformations. All parameters can be modulated via CV inputs.

**Inputs:**
- `Source In` (Video) - Video source ID from webcam, video file, or other video processing nodes

**Outputs:**
- `Output ID` (Video) - Processed video source ID for chaining to other video modules

**Parameters (All CV-Modulatable):**

**Color Adjustments:**
- `Brightness` (-100 to +100) - Brightness adjustment
- `Contrast` (0.0-3.0) - Contrast multiplier
- `Saturation` (0.0-3.0) - Color saturation (0=grayscale, 1=normal, >1=enhanced)
- `Hue Shift` (-180 to +180) - Hue rotation in degrees
- `Red/Green/Blue Gain` (0.0-2.0) - Per-channel gain control
- `Temperature` (-1.0 to +1.0) - Color temperature (cold to warm)
- `Sepia` (Bool) - Apply sepia tone effect

**Filters & Effects:**
- `Sharpen` (0.0-2.0) - Sharpening amount
- `Blur` (0-20) - Blur radius
- `Grayscale` (Bool) - Convert to grayscale
- `Invert Colors` (Bool) - Invert color values
- `Flip Horizontal/Vertical` (Bool) - Mirror frames

**Advanced Effects:**
- `Threshold Enable` (Bool) - Enable threshold effect
- `Threshold Level` (0-255) - Threshold cutoff
- `Posterize Levels` (2-32) - Color quantization (lower = fewer colors)
- `Vignette Amount` (0.0-1.0) - Vignette darkening intensity
- `Vignette Size` (0.1-2.0) - Vignette radius
- `Pixelate Block Size` (1-128) - Pixelation block size
- `Edge Detect (Canny)` (Bool) - Enable Canny edge detection
- `Canny Threshold 1/2` (0-255) - Edge detection thresholds
- `Kaleidoscope` (Choice) - None, 4-Way, or 8-Way mirroring

**System:**
- `Use GPU (CUDA)` (Bool) - Enable GPU acceleration (if available)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**Auto-Connect Shortcuts:**
- **V (Video)**: Chain video source â†’ `Source In`, `Output ID` â†’ next video module
- All color/filter parameters accept CV modulation for dynamic effects

**How to Use:**
1. **Connect Video Source:** Connect Webcam, Video File Loader, or another Video FX node to `Source In`
2. **Chain Effects:** Connect `Output ID` to another Video FX or CV processing module
3. **Adjust Parameters:** Use sliders for real-time preview
4. **Modulate with CV:** Connect LFOs, envelopes, or sequencers to CV inputs for animated effects
5. **Example Chains:**
   - **Color Grading Chain:** Video FX (saturation + temperature) â†’ Video FX (contrast + brightness)
   - **Stylization:** Video FX (posterize + vignette) â†’ Video FX (sepia + blur)
   - **Motion Effects:** LFO â†’ Brightness CV, ADSR â†’ Blur CV for dynamic effects
6. **Performance Tips:**
   - GPU acceleration significantly improves performance (enable if available)
   - Chain multiple Video FX nodes for complex effect combinations
   - Use CV modulation for automated video transformations
   - Preview size affects UI performance (use Small for many nodes)

**Technical Details:**
- Passthrough video processing (zero latency)
- Supports GPU acceleration via CUDA (when compiled with CUDA support)
- Real-time processing at video frame rate
- All effects are composable and can be combined
- Dynamic CV modulation inputs for all parameters
- Creates new video source ID for processed output (enables chaining)

---

### crop_video
**Video Cropping with Automatic Tracking**

Crops video frames to a specified region. Supports three modes: manual cropping, automatic face tracking, and automatic object tracking (YOLOv3). Perfect for following detected objects or isolating regions of interest.

**Inputs:**
- `Source In` (Video) - Video source ID
- `Center X Mod` (CV) - Center X position modulation (0-1)
- `Center Y Mod` (CV) - Center Y position modulation (0-1)
- `Width Mod` (CV) - Crop width modulation (0-1)
- `Height Mod` (CV) - Crop height modulation (0-1)

**Outputs:**
- `Output ID` (Video) - Cropped video source ID for chaining

**Parameters:**
- `Tracking Mode` (Choice) - Manual, Track Face, or Track Object
- `Target Class` (Choice) - Object class when tracking objects (person, car, etc.)
- `Confidence` (0.0-1.0) - Detection confidence threshold
- `Padding` (0.0-2.0) - Padding around tracked region (0.1 = 10% padding)
- `Aspect Ratio` (Choice) - Stretch or Preserve (Fit)
- `Use GPU (CUDA)` (Bool) - Enable GPU acceleration for tracking
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**Manual Crop Controls:**
- `Center X/Y` (0-1) - Crop region center position
- `Width/Height` (0-1) - Crop region size

**Auto-Connect Shortcuts:**
- **V (Video)**: Chain video source â†’ `Source In`, `Output ID` â†’ next video module
- **B (CV)**: Connect CV signals (from Object/Human/Pose detectors) to Center X/Y/Width/Height modulation inputs

**How to Use:**
1. **Manual Mode:**
   - Connect video source to `Source In`
   - Adjust Center X/Y and Width/Height sliders
   - Use Aspect Ratio "Preserve" to maintain original proportions
   
2. **Track Face Mode:**
   - Select "Track Face" from Tracking Mode
   - Automatically detects and tracks faces using Haar Cascade
   - Adjust Padding to add space around face
   - GPU acceleration recommended for better performance

3. **Track Object Mode:**
   - Select "Track Object" from Tracking Mode
   - Choose Target Class (e.g., "person", "car", "bottle")
   - Requires YOLOv3 model files in `assets/`
   - Automatically tracks and crops to detected object bounding box
   - Adjust Confidence threshold to filter detections

4. **CV Modulation:**
   - Connect Object Detector X/Y/Width/Height outputs to Crop Video modulation inputs
   - Connect Pose Estimator keypoint positions for dynamic cropping
   - Use sequencers or LFOs for automated crop animations

5. **Example Patches:**
   - **Face Isolation:** Track Face mode â†’ Cropped output to Face Tracker for detailed analysis
   - **Person Following:** Object Detector (person) â†’ Crop Video CV inputs â†’ Cropped region to Pose Estimator
   - **Dynamic Cropping:** LFO â†’ Center X Mod, ADSR â†’ Width Mod for animated crops
   - **Multi-Stage Processing:** Crop Video â†’ Video FX (stylize cropped region) â†’ Further processing

6. **Performance Tips:**
   - GPU acceleration improves tracking performance (especially for YOLOv3)
   - Lower confidence thresholds detect more objects but may include false positives
   - Padding helps maintain context around tracked objects
   - Use Preserve aspect ratio to avoid distortion

**Technical Details:**
- Three tracking modes: Manual (slider-based), Face (Haar Cascade), Object (YOLOv3)
- YOLOv3 tracking requires model files (`yolov3.cfg`, `yolov3.weights`, `coco.names`)
- Falls back to YOLOv3-tiny if standard model not available
- GPU acceleration via CUDA (optional, improves performance)
- Real-time processing at video frame rate
- Passthrough video processing with zero latency
- CV modulation allows dynamic crop region control

---

## 11. SYSTEM NODES

System nodes provide special functionality for patch organization.

### meta
**Meta Module Container**

A container for creating custom reusable modules from sub-patches.

**How to Use:**
1. Create a patch inside the Meta module
2. Use Inlet/Outlet nodes to define interface
3. Save as reusable module
4. Collapse complex patches into single nodes

---

### inlet
**Meta Module Input**

Defines an input for a Meta module.

---

### outlet
**Meta Module Output**

Defines an output for a Meta module.

---

### comment
**Documentation Node**

A text comment node for documenting patches.

**How to Use:**
1. Add comment node
2. Type documentation text
3. Helps explain complex patches
4. No audio/CV functionality

---

### recorder
**Audio Recording to File**

Records incoming audio to WAV, AIFF, or FLAC files.

**Inputs:**
- `In L/R` (Audio) - Stereo audio to record

**Parameters:**
- File path/name
- Format (WAV, AIFF, FLAC)
- Bit depth (16/24/32)
- Record button

**How to Use:**
1. Set file path and format
2. Connect audio source
3. Click Record to start
4. Click Stop to finish and save

---

### vst_host
**VST Plugin Host**

Hosts VST2/VST3 plugins within the modular environment.

**How to Use:**
1. Load VST plugin
2. Audio routed through plugin
3. Use external effects and instruments
4. Combine modular with traditional plugins

---

### bpm_monitor
**Rhythm Detection and BPM Reporting**

A hybrid smart system that automatically detects and reports BPM from rhythm-producing modules and audio inputs. This node is always present in patches (like the output node) and cannot be deleted. It dynamically generates output pins for each detected rhythm source.

**Inputs (Dynamic):**
- `In 1-16` (Audio) - Audio inputs for beat detection (up to 16 channels)

**Outputs (Dynamic):**
- For each detected rhythm source:
  - `[Source Name] BPM` (Raw) - Absolute BPM value
  - `[Source Name] CV` (CV) - Normalized BPM (0-1 range for modulation)
  - `[Source Name] Active` (Gate) - High when source is active (for introspected sources)
  - `[Source Name] Confidence` (CV) - Detection confidence (0-1, for detected sources)

**Parameters:**
- `Operation Mode` (Choice) - Auto (both methods), Introspection Only, or Detection Only
- `Min BPM` (20-120) - Minimum BPM for normalization (default: 60)
- `Max BPM` (120-300) - Maximum BPM for normalization (default: 240)

**Auto-Connect Shortcuts:**
- **B (CV)**: Chain `[Source] CV` outputs to CV modulation inputs
- **Y (Gate)**: Chain `[Source] Active` outputs to gate inputs
- **R (Raw)**: Chain `[Source] BPM` outputs to raw value inputs
- **G (Audio)**: Connect audio sources to beat detection inputs

**How to Use:**
1. **Operation Modes:**
   - **Auto**: Uses both introspection (fast) and beat detection (universal)
   - **Introspection Only**: Only scans modules that report rhythm info (sequencers, animations)
   - **Detection Only**: Only analyzes audio inputs using tap tempo algorithm
   
2. **Introspection (Recommended):**
   - Automatically detects modules that implement `getRhythmInfo()`
   - Works with: Sequencer, Step Sequencer, Animation, Physics, and other rhythm-producing modules
   - Provides instant, accurate BPM reporting
   - Scans the graph periodically (every 128 audio blocks for efficiency)
   
3. **Beat Detection (Fallback):**
   - Connect any rhythmic audio signal to the inputs
   - Uses tap tempo algorithm with rolling average
   - Works with external audio, VST plugins, or any rhythmic source
   - Outputs confidence level indicating detection stability
   
4. **Using Outputs:**
   - Each detected source generates three outputs:
     - **BPM (Raw)**: Absolute BPM value (e.g., 120.0)
     - **CV**: Normalized 0-1 range for modulation (scaled by Min/Max BPM parameters)
     - **Active/Confidence**: Gate for introspected sources, confidence CV for detected sources
   
5. **Example Patches:**
   - **Sync Effects to Sequencer**: Connect Sequencer â†’ BPM Monitor, use `CV` output to modulate delay time
   - **Beat-Synchronized LFO**: Use `CV` output to sync LFO rate to detected BPM
   - **Multi-Source Tempo**: Monitor multiple sequencers and select the most appropriate one
   - **External Tempo Sync**: Connect audio input from external source, use detected BPM to sync your patch
   
6. **Tips:**
   - Introspection mode is fastest and most accurate for compatible modules
   - Beat detection works with any rhythmic source but may have latency
   - Use Min/Max BPM parameters to set the CV output range for your modulation needs
   - The node automatically updates when new rhythm sources appear or disappear

**Technical Details:**
- Hybrid detection: introspection (via `getRhythmInfo()`) + audio analysis (TapTempo algorithm)
- Graph scanning runs every 128 audio blocks (~2.9ms at 44.1kHz) for efficiency
- Thread-safe access to detected sources (protects dynamic pin queries)
- Dynamic output pins generated based on detected sources
- Always present (logical ID 999, undeletable)
- Supports up to 16 audio detection inputs

**Supported Introspection Sources:**
- Sequencer (reports BPM when active)
- Step Sequencer (reports BPM when running)
- Animation (reports BPM based on animation speed and duration)
- Physics (can report rhythm from collision events)
- Other modules implementing `getRhythmInfo()`

---


## Glossary

**CV (Control Voltage):** A signal (typically 0-1 or -1 to +1) used to modulate parameters.

**Gate:** A binary signal (high/low, on/off) used for triggering and timing.

**Trigger:** A brief pulse signal, typically used to initiate events.

**Audio:** Full-rate audio signals (~44.1kHz or higher).

**Raw:** Unscaled numerical values for custom ranges.

**Video:** Video source identifier for computer vision processing.

**V/Oct:** Volt-per-octave pitch CV standard (1 semitone = 1/12 V).

**Relative Modulation:** CV modulates around a slider position (musical/proportional).

**Absolute Modulation:** CV directly maps to full parameter range.

**Bipolar:** Signal range from -1 to +1 (centered at 0).

**Unipolar:** Signal range from 0 to 1.

---

## Keyboard Shortcuts for Auto-Connection

When multiple nodes are selected, use these keys to chain them by data type:

| Key | Data Type | Color | Use Case |
|-----|-----------|-------|----------|
| **C** | Standard Chaining | White | Stereo audio chain (channels 0â†’0, 1â†’1) |
| **G** | Audio | Green | Audio effects chain |
| **B** | CV (Control Voltage) | Blue | CV signal chain |
| **Y** | Gate | Yellow | Gate/trigger chain |
| **R** | Raw | Red | Raw value chain |
| **V** | Video | Cyan | Video source chain (webcam/video â†’ CV modules) |

**Note:** Auto-connection shortcuts only work when 2+ nodes are selected.

---

## Tips for Using the Dictionary

1. **Search by Function:** Use Ctrl+F to find nodes by keyword (e.g., "distortion", "filter", "envelope")
2. **Follow the Signal Flow:** Start with Sources â†’ Effects â†’ Output
3. **Modulation is Key:** Most parameters can be modulated - experiment!
4. **Save Your Patches:** Use the preset system to save and recall configurations
5. **Start Simple:** Build complexity gradually by adding one module at a time

---

**End of Nodes Dictionary**

*For more information, see the main user manual and individual module guides.*




================================================================================
SPECIFIC QUESTIONS FOR EXPERT
================================================================================

1. TAB SELECTION MECHANISM:
   - How does ImGui::BeginTabItem() with ImGuiTabItemFlags_SetSelected work?
   - Why doesn't it work when applied to the second tab instead of the first?
   - Is there a way to force a specific tab to be selected after the tab bar is created?

2. CORRECT PATTERN:
   - What is the correct pattern for programmatic tab selection in ImGui?
   - Should we render the target tab FIRST when we want it selected?
   - Is there an alternative API or approach we should use?
   - Are there any ImGui examples or demos showing this pattern?

3. WORKAROUNDS:
   - Can we conditionally render tabs in a different order?
   - Should we use ImGui::SetNextItemOpen() or similar APIs?
   - Is there a way to "reset" the tab bar state?

4. ALTERNATIVE APPROACHES:
   - Should we close and reopen the window to force tab selection?
   - Should we use a different UI pattern (e.g., separate windows)?
   - Is there a way to query/set the active tab index directly?

================================================================================
TECHNICAL CONTEXT
================================================================================

- Framework: ImGui (dear imgui) - latest version
- Language: C++17
- Platform: Windows
- Tab Bar API: ImGui::BeginTabBar(), ImGui::BeginTabItem()
- Current approach: Using m_shouldSetTab flag + ImGuiTabItemFlags_SetSelected
- Window state: Persistent across frames (not recreated each frame)

================================================================================
SUCCESS CRITERIA
================================================================================

A solution is successful if:
1. âœ… F1 with no node â†’ Opens to Shortcuts tab (currently works)
2. âŒ F1 with node selected â†’ Opens to Node Dictionary tab (currently broken)
3. âœ… Users can click tabs normally (works after revert)
4. âŒ Tab selection works on first window open (currently broken)
5. âœ… Help Manager scrolls to correct node entry (anchor scrolling works)

================================================================================
END OF CONTEXT BUNDLE
================================================================================
