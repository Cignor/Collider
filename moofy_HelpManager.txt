
================================================================================
FILE: guides\HELP_MANAGER_DESIGN.md
================================================================================


# Help Manager System - Design Concept

## Overview

A centralized, tabbed help system that consolidates documentation, shortcuts, and user assistance into a single, modern interface accessible from the Help menu.

## Architecture

### Core Component: `HelpManagerComponent`

Similar to `ThemeEditorComponent`, this will be a self-contained component that:
- Manages its own window state (`m_isOpen`)
- Renders a tabbed interface using `ImGui::BeginTabBar()`
- Handles content rendering for each tab
- Integrates with existing systems (ShortcutManager, file system for markdown)

### Location in Menu

**Current**: `Settings > Keyboard Shortcuts...`  
**New**: `Help > Help Manager...` (or `Help > Help...`)

The shortcut manager will move from Settings to Help, and become a tab within the Help Manager.

## Tab Structure

### Tab 1: "Shortcuts" 
**Purpose**: Keyboard shortcut management and customization

**Content**:
- Integrate existing `ShortcutManager` functionality
- Same table view as current implementation
- Context selection, search, assign/clear/reset buttons
- All existing shortcut editor features

**Implementation**:
- Reuse `renderShortcutEditorContents()` and related functions
- Remove the modal popup wrapper
- Render directly in tab content area

### Tab 2: "Node Dictionary"
**Purpose**: Interactive documentation browser for all available nodes

**Features**:
- **Markdown Renderer**: Parse and display `Nodes_Dictionary.md`
- **Collapsible Sections**: Use `ImGui::CollapsingHeader()` for each node category
- **Search Functionality**: Filter nodes by name, category, or description
- **Quick Navigation**: Table of contents with jump links
- **Syntax Highlighting**: Code blocks, parameter lists, examples
- **Copy to Clipboard**: Copy node names, examples, etc.

**Content Structure**:
```
[Search Box]
[Table of Contents - Collapsible]
  ‚îú‚îÄ Source Nodes
  ‚îÇ   ‚îú‚îÄ VCO (collapsible)
  ‚îÇ   ‚îú‚îÄ PolyVCO (collapsible)
  ‚îÇ   ‚îî‚îÄ ...
  ‚îú‚îÄ Effect Nodes
  ‚îú‚îÄ Modulator Nodes
  ‚îî‚îÄ ...
```

**Markdown Parsing**:
- Parse headers (`##`, `###`) as collapsible sections
- Parse code blocks (```) with syntax highlighting
- Parse lists and tables
- Parse links and anchors
- Handle special formatting (bold, italic, inline code)

### Tab 3: "Getting Started"
**Purpose**: Tutorials and quick-start guides

**Content**:
- Welcome message
- Quick start tutorial (step-by-step)
- Common workflows
- Tips and tricks
- Video links (if applicable)
- Keyboard shortcuts cheat sheet (quick reference)

**Features**:
- Step-by-step walkthroughs
- Collapsible sections for different topics
- Visual examples/diagrams (if possible)
- Links to external resources

### Tab 4: "About"
**Purpose**: Application information and credits

**Content**:
- Application name and version
- Build information
- Credits and acknowledgments
- License information
- System information (optional)
- Links to:
  - GitHub repository
  - Documentation website
  - Community forums
  - Bug tracker

**Features**:
- Version display
- Copy system info button
- Links to external resources

### Tab 5: "FAQ" (Optional)
**Purpose**: Frequently asked questions

**Content**:
- Common questions and answers
- Troubleshooting tips
- Known issues
- Performance tips
- Collapsible Q&A format

## Technical Implementation

### Class Structure

```cpp
class HelpManagerComponent
{
public:
    HelpManagerComponent(ImGuiNodeEditorComponent* parent);
    void open();
    void close();
    void render();
    
private:
    // Window state
    bool m_isOpen = false;
    int m_currentTab = 0;
    
    // Shortcuts tab
    void renderShortcutsTab();
    
    // Node Dictionary tab
    void renderNodeDictionaryTab();
    void parseMarkdownFile(const juce::File& file);
    void renderMarkdownContent();
    juce::String m_searchTerm;
    std::vector<MarkdownSection> m_parsedSections;
    
    // Getting Started tab
    void renderGettingStartedTab();
    
    // About tab
    void renderAboutTab();
    
    // FAQ tab (optional)
    void renderFaqTab();
    
    // Markdown parsing helpers
    struct MarkdownSection
    {
        juce::String title;
        int level; // 1, 2, 3 for ##, ###, ####
        juce::String content;
        std::vector<MarkdownSection> children;
    };
    
    ImGuiNodeEditorComponent* parentEditor;
};
```

### Markdown Rendering Strategy

**Option 1: Simple Parser (Recommended for MVP)**
- Parse markdown on load
- Convert to ImGui widgets:
  - Headers ‚Üí `CollapsingHeader` or `Text` with styling
  - Code blocks ‚Üí `InputTextMultiline` with read-only flag
  - Lists ‚Üí `BulletText()` or `Text()`
  - Links ‚Üí `Text` with hover tooltip or clickable (if we add URL handling)

**Option 2: Full Markdown Library**
- Use a C++ markdown parser (e.g., `cmark`, `markdown-it`)
- More complex but handles edge cases better
- Better for future extensibility

**Recommendation**: Start with Option 1, upgrade if needed.

### Search Implementation

For Node Dictionary:
```cpp
// Filter sections based on search term
bool matchesSearch(const MarkdownSection& section, const juce::String& term)
{
    return section.title.containsIgnoreCase(term) 
        || section.content.containsIgnoreCase(term);
}

// When rendering, skip non-matching sections
// Auto-expand sections that match
```

### Integration Points

1. **Menu Integration**:
   ```cpp
   // In ImGuiNodeEditorComponent::renderMenuBar()
   if (ImGui::BeginMenu("Help"))
   {
       if (ImGui::MenuItem("Help Manager...", "F1"))
       {
           helpManager.open();
       }
       ImGui::Separator();
       // Keep existing "Keyboard Shortcuts" as shortcut to that tab?
       // Or remove it entirely?
   }
   ```

2. **Shortcut Integration**:
   - F1 opens Help Manager (currently opens old shortcuts window)
   - Focus on "Shortcuts" tab if opened via F1
   - Focus on "Node Dictionary" tab if opened from context menu

3. **Context Menu Integration**:
   - Right-click node ‚Üí "View in Dictionary" ‚Üí Opens Help Manager to Node Dictionary tab, scrolls to that node

## UI/UX Considerations

### Window Behavior
- **Size**: Large enough for content (800x600 minimum, resizable)
- **Position**: Centered on first open, remembers position
- **Modal**: Non-modal window (allows interaction with main editor)
- **Background**: Uses theme's `WindowBg` color (fully opaque)

### Tab Design
- Use `ImGuiTabBarFlags_Reorderable` for user customization?
- Icons for tabs? (optional, adds complexity)
- Keyboard shortcuts to switch tabs? (Ctrl+1, Ctrl+2, etc.)

### Search UX
- Real-time filtering as user types
- Highlight matching text
- "No results" message
- Clear search button (X icon)

### Markdown Rendering UX
- Smooth scrolling
- Auto-expand matching sections when searching
- "Back to top" button for long content
- Copy code blocks button
- Syntax highlighting for code (basic color coding)

## Future Enhancements

1. **Interactive Examples**: Run code snippets in sandbox
2. **Video Embedding**: If we add video support
3. **User Notes**: Allow users to add personal notes to documentation
4. **Bookmarks**: Save favorite sections
5. **Print/Export**: Export documentation to PDF
6. **Multi-language Support**: If we internationalize
7. **Dark/Light Mode Toggle**: Quick theme switcher in About tab
8. **Update Checker**: Check for new versions in About tab

## Migration Path

1. **Phase 1**: Create `HelpManagerComponent` with Shortcuts and About tabs
2. **Phase 2**: Add Node Dictionary tab with basic markdown rendering
3. **Phase 3**: Add Getting Started and FAQ tabs
4. **Phase 4**: Enhance markdown rendering, add search
5. **Phase 5**: Add context menu integration, polish UX

## Files to Create/Modify

### New Files
- `juce/Source/preset_creator/HelpManagerComponent.h`
- `juce/Source/preset_creator/HelpManagerComponent.cpp`
- `juce/Source/preset_creator/MarkdownParser.h` (optional, if we create a parser)
- `juce/Source/preset_creator/MarkdownParser.cpp`

### Modified Files
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.h` - Add HelpManagerComponent member
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp` - Integrate into menu, remove old shortcuts window
- `juce/CMakeLists.txt` - Add new source files

## Design Principles

1. **Consistency**: Follow existing patterns (ThemeEditorComponent)
2. **Performance**: Lazy-load markdown content, cache parsed results
3. **Accessibility**: Keyboard navigation, clear visual hierarchy
4. **Maintainability**: Separate concerns (parsing, rendering, UI)
5. **Extensibility**: Easy to add new tabs or content types



================================================================================
FILE: guides\HELP_MANAGER_CONCEPTUALIZATION.md
================================================================================


# Help Manager System - Conceptualization Summary

## Executive Summary

A centralized, tabbed help system that consolidates all user assistance into a single, modern interface. The Help Manager will replace the current modal shortcuts window and add comprehensive documentation browsing capabilities.

## Core Concept

**Single Window, Multiple Tabs** - Following the pattern established by `ThemeEditorComponent`, the Help Manager will be a non-modal window with a tabbed interface, allowing users to access shortcuts, documentation, tutorials, and app information from one place.

## Tab Structure & Content

### Tab 1: "Shortcuts" ‚å®Ô∏è
**Purpose**: Keyboard shortcut management

**Content**:
- Full integration of existing `ShortcutManager` functionality
- Table view: Category | Action | Binding | Source | Options
- Context selector (Global, Node Editor)
- Search box for filtering actions
- Assign/Clear/Reset buttons per action
- Save Changes button

**Implementation Notes**:
- Reuse `renderShortcutEditorContents()` from `ImGuiNodeEditorComponent`
- Remove modal popup wrapper (`BeginPopupModal`)
- Render directly in tab content area
- Maintain all existing functionality

### Tab 2: "Node Dictionary" üìö
**Purpose**: Interactive documentation browser

**Key Features**:
1. **Markdown Parser**
   - Parse `Nodes_Dictionary.md` on first open
   - Convert headers to collapsible sections
   - Parse code blocks, lists, tables
   - Build hierarchical structure

2. **Search Functionality**
   - Real-time filtering as user types
   - Search in: node names, categories, descriptions
   - Auto-expand matching sections
   - Highlight matching text (if possible)
   - "No results" message

3. **Navigation**
   - Table of Contents (collapsible sidebar or top section)
   - Jump links to major sections
   - Breadcrumb navigation (optional)
   - "Back to top" button

4. **Rendering**
   - Headers ‚Üí `CollapsingHeader` or styled `Text`
   - Code blocks ‚Üí `InputTextMultiline` (read-only) with copy button
   - Lists ‚Üí `BulletText()` or `Text()` with indentation
   - Tables ‚Üí `ImGui::BeginTable()` (if markdown has tables)
   - Links ‚Üí Tooltip on hover, or clickable if we add URL handling

**Markdown Structure Example**:
```markdown
## VCO - Voltage-Controlled Oscillator
Description text...

### Parameters
- Frequency: CV input
- Waveform: Sine, Square, etc.

### Example Usage
```cpp
// Code example
```
```

**Rendered As**:
```
[‚ñº] VCO - Voltage-Controlled Oscillator
    Description text...
    [‚ñº] Parameters
        ‚Ä¢ Frequency: CV input
        ‚Ä¢ Waveform: Sine, Square, etc.
    [‚ñº] Example Usage
        [Code block with copy button]
```

### Tab 3: "Getting Started" üöÄ
**Purpose**: Tutorials and onboarding

**Content Sections**:
1. **Welcome**
   - Brief intro to Collider
   - What makes it unique
   - Quick overview

2. **Quick Start Guide**
   - Step 1: Create your first patch
   - Step 2: Add nodes
   - Step 3: Connect nodes
   - Step 4: Play and experiment
   - Visual examples (screenshots or diagrams)

3. **Common Workflows**
   - Creating a bass patch
   - Building a drum machine
   - Using CV modulation
   - Video processing basics

4. **Tips & Tricks**
   - Keyboard shortcuts cheat sheet
   - Hidden features
   - Performance tips
   - Best practices

5. **Resources**
   - Video tutorials (links)
   - Community forums
   - Example patches
   - External documentation

**UI Pattern**:
- Collapsible sections for each topic
- Step-by-step numbered lists
- Visual separators between major sections
- Links to relevant nodes in Dictionary tab

### Tab 4: "About" ‚ÑπÔ∏è
**Purpose**: Application information

**Content**:
1. **Application Info**
   - Name: Collider Modular Synthesizer
   - Version: [from build system]
   - Build date: [from build system]
   - Platform: Windows/macOS/Linux

2. **Credits**
   - Developers
   - Contributors
   - Libraries used (JUCE, ImGui, ImNodes, etc.)
   - Special thanks

3. **License**
   - License type
   - Copyright notice
   - Link to full license text

4. **System Information** (optional)
   - OS version
   - CPU info
   - Memory info
   - Audio device info
   - Copy system info button

5. **Links**
   - GitHub repository
   - Documentation website
   - Community forums
   - Bug tracker
   - Donate/Support

**UI Pattern**:
- Clean, organized layout
- Version prominently displayed
- Collapsible sections for details
- External links clearly marked

### Tab 5: "FAQ" ‚ùì (Optional - Future)
**Purpose**: Common questions

**Content**:
- Q: How do I...?
- A: [Answer with links to relevant docs]
- Collapsible Q&A format
- Searchable
- Categories: Installation, Usage, Troubleshooting, etc.

## Technical Architecture

### Component Structure

```cpp
class HelpManagerComponent
{
public:
    HelpManagerComponent(ImGuiNodeEditorComponent* parent);
    void open();
    void close();
    void render();
    
    // Tab navigation
    void setActiveTab(int tabIndex);
    int getActiveTab() const { return m_currentTab; }
    
private:
    // Window state
    bool m_isOpen = false;
    int m_currentTab = 0;
    ImVec2 m_windowSize = ImVec2(900, 700);
    ImVec2 m_windowPos = ImVec2(100, 100);
    
    // Shortcuts tab
    void renderShortcutsTab();
    // Reuse existing shortcut editor functions
    
    // Node Dictionary tab
    void renderNodeDictionaryTab();
    void loadMarkdownFile();
    void parseMarkdown(const juce::String& content);
    void renderMarkdownSection(const MarkdownSection& section, int depth = 0);
    juce::String m_searchTerm;
    std::vector<MarkdownSection> m_parsedSections;
    bool m_markdownLoaded = false;
    
    // Getting Started tab
    void renderGettingStartedTab();
    
    // About tab
    void renderAboutTab();
    juce::String getVersionString() const;
    juce::String getBuildInfo() const;
    
    // Markdown data structures
    struct MarkdownSection
    {
        juce::String title;
        int level; // 1, 2, 3 for ##, ###, ####
        juce::String content; // Text before subsections
        std::vector<MarkdownSection> children;
        juce::String anchor; // For jump links
    };
    
    ImGuiNodeEditorComponent* parentEditor;
};
```

### Markdown Parsing Strategy

**Recommended Approach: Simple Custom Parser**

1. **Parse on First Open** (lazy load)
   - Read `Nodes_Dictionary.md` file
   - Parse line by line
   - Build hierarchical structure
   - Cache parsed result

2. **Parsing Rules**:
   - `## Header` ‚Üí Level 1 section
   - `### Header` ‚Üí Level 2 subsection
   - `#### Header` ‚Üí Level 3 sub-subsection
   - Code blocks (```) ‚Üí Extract and store separately
   - Lists (`-` or `*`) ‚Üí Store as array
   - Links `[text](url)` ‚Üí Extract text and URL
   - Bold/italic ‚Üí Store with formatting markers

3. **Rendering**:
   - Level 1 ‚Üí `CollapsingHeader` (always visible when expanded)
   - Level 2+ ‚Üí Nested `CollapsingHeader` or `TreeNode`
   - Code blocks ‚Üí `InputTextMultiline` with read-only + copy button
   - Lists ‚Üí `BulletText()` or indented `Text()`
   - Links ‚Üí `TextColored()` with hover tooltip

### Search Implementation

**Simple Text Matching**:
```cpp
bool matchesSearch(const MarkdownSection& section, const juce::String& term)
{
    if (term.isEmpty()) return true;
    
    juce::String lowerTerm = term.toLowerCase();
    return section.title.toLowerCase().contains(lowerTerm)
        || section.content.toLowerCase().contains(lowerTerm);
}

// When rendering, skip non-matching sections
// Auto-expand sections that match
```

**Performance Considerations**:
- Search is O(n) where n = number of sections
- For ~100 sections, this should be instant
- No need for complex indexing initially
- Can optimize later if needed

### Integration Points

1. **Menu Integration**:
```cpp
// In ImGuiNodeEditorComponent::renderMenuBar()
if (ImGui::BeginMenu("Help"))
{
    if (ImGui::MenuItem("Help Manager...", "F1"))
    {
        helpManager.open();
        helpManager.setActiveTab(0); // Shortcuts tab
    }
    ImGui::Separator();
    
    // Optional: Quick links to specific tabs
    if (ImGui::MenuItem("Keyboard Shortcuts", "F1"))
    {
        helpManager.open();
        helpManager.setActiveTab(0);
    }
    if (ImGui::MenuItem("Node Dictionary"))
    {
        helpManager.open();
        helpManager.setActiveTab(1);
    }
}
```

2. **F1 Shortcut**:
- Currently: Opens shortcuts window
- New: Opens Help Manager, focuses Shortcuts tab
- Update shortcut action to call `helpManager.open()` and `setActiveTab(0)`

3. **Context Menu Integration** (Future):
```cpp
// Right-click node ‚Üí "View in Dictionary"
if (ImGui::MenuItem("View in Dictionary"))
{
    helpManager.open();
    helpManager.setActiveTab(1); // Node Dictionary tab
    helpManager.scrollToNode(nodeName); // Scroll to that node's section
}
```

## UI/UX Design

### Window Appearance
- **Size**: 900x700 (default), resizable
- **Position**: Centered on first open, remembers position
- **Modal**: Non-modal (allows interaction with editor)
- **Background**: Uses theme's `WindowBg` (fully opaque)
- **Title**: "Help Manager" or "‚ñº Help Manager"

### Tab Bar
- Horizontal tab bar at top
- Tab names: "Shortcuts", "Dictionary", "Getting Started", "About"
- Active tab highlighted
- Keyboard shortcuts: Ctrl+1, Ctrl+2, Ctrl+3, Ctrl+4 (optional)

### Content Area
- Scrollable content region
- Consistent padding and spacing
- Follows theme colors
- Responsive to window resize

### Search Box
- Prominent placement (top of Dictionary tab)
- Real-time filtering
- Clear button (X icon)
- Placeholder text: "Search nodes, categories, descriptions..."

## Implementation Phases

### Phase 1: Foundation (MVP)
1. Create `HelpManagerComponent` class
2. Implement window and tab structure
3. Integrate Shortcuts tab (migrate from modal)
4. Add About tab (basic info)
5. Menu integration

### Phase 2: Node Dictionary
1. Implement markdown parser
2. Render markdown as collapsible sections
3. Add search functionality
4. Add table of contents
5. Code block rendering with copy

### Phase 3: Getting Started
1. Create tutorial content
2. Implement Getting Started tab
3. Add visual examples
4. Links to external resources

### Phase 4: Polish
1. Context menu integration
2. Scroll-to-section functionality
3. Performance optimization
4. UI/UX refinements
5. Keyboard shortcuts for tabs

## Additional Considerations

### Performance
- **Lazy Loading**: Parse markdown only when Dictionary tab is first opened
- **Caching**: Cache parsed markdown structure (don't re-parse on every open)
- **Search**: Simple text matching is fast enough for ~100 sections
- **Rendering**: Only render visible sections (virtual scrolling if needed)

### Memory
- Parse markdown once, store in memory
- ~2500 lines ‚âà ~100KB text, very manageable
- Clear cache on close? Or keep for faster reopening?

### Extensibility
- Easy to add new tabs
- Easy to add new content to existing tabs
- Markdown parser can be extended for new features
- Search can be enhanced with fuzzy matching, etc.

### Accessibility
- Keyboard navigation between tabs
- Keyboard shortcuts documented
- Clear visual hierarchy
- High contrast (follows theme)

## Success Metrics

1. ‚úÖ Help Manager opens from Help menu
2. ‚úÖ Shortcuts tab fully functional (migrated from Settings)
3. ‚úÖ Node Dictionary renders markdown with search
4. ‚úÖ Getting Started provides useful tutorials
5. ‚úÖ About tab shows app information
6. ‚úÖ F1 shortcut opens Help Manager
7. ‚úÖ Performance is smooth (no lag)
8. ‚úÖ UI is consistent with existing theme
9. ‚úÖ Code follows existing patterns

## Next Steps

1. Review this conceptualization
2. Decide on markdown parsing approach (custom vs library)
3. Create `HelpManagerComponent` class structure
4. Implement Phase 1 (Foundation)
5. Test and iterate
6. Implement Phase 2 (Node Dictionary)
7. Continue with remaining phases

---

**Note**: This conceptualization is based on existing code patterns (`ThemeEditorComponent`), ImGui best practices (`imgui_demo.cpp`), and the project's design guide (`IMGUI_NODE_DESIGN_GUIDE.md`). The design prioritizes consistency, maintainability, and user experience.



================================================================================
FILE: MOOFYS\moofy_help_manager.md
================================================================================


# Help Manager System - Context Bundle for External Expert

## Project Context

**Project**: Collider Modular Synthesizer  
**Language**: C++17  
**Framework**: JUCE + ImGui + ImNodes  
**Current Task**: Design and implement a centralized Help Manager system with tabbed interface

## Current Situation

### Existing Systems

1. **ShortcutManager** (`juce/Source/preset_creator/ShortcutManager.h/cpp`)
   - Fully functional data-driven shortcut system
   - Supports contexts, rebinding, persistence
   - Currently accessed via `Settings > Keyboard Shortcuts...` (modal popup)
   - Needs to be integrated as a tab in new Help Manager

2. **ThemeEditorComponent** (`juce/Source/preset_creator/theme/ThemeEditorComponent.h/cpp`)
   - Reference implementation for tabbed UI components
   - Uses `ImGui::BeginTabBar()` pattern
   - Manages window state, working copy, apply/reset logic
   - Good pattern to follow for HelpManagerComponent

3. **ImGuiNodeEditorComponent** (`juce/Source/preset_creator/ImGuiNodeEditorComponent.h/cpp`)
   - Main editor component
   - Contains menu bar with Help menu
   - Currently has `showShortcutsWindow` and `renderShortcutEditorWindow()`
   - Needs integration point for HelpManagerComponent

### Documentation Files

1. **Nodes_Dictionary.md** (`USER_MANUAL/Nodes_Dictionary.md`)
   - Large markdown file (~2500+ lines)
   - Contains documentation for all node types
   - Structured with headers (##, ###), code blocks, lists, tables
   - Needs to be rendered in a searchable, collapsible format

2. **IMGUI_NODE_DESIGN_GUIDE.md** (`guides/IMGUI_NODE_DESIGN_GUIDE.md`)
   - Design patterns for ImGui UI
   - Best practices for tabs, collapsing headers, etc.
   - Reference for UI implementation

## Requirements

### Primary Goals

1. **Create HelpManagerComponent** - Tabbed help system
2. **Move Shortcuts to Help Menu** - From Settings to Help
3. **Add Node Dictionary Tab** - Markdown renderer with search
4. **Add Additional Helpful Tabs** - Getting Started, About, FAQ

### Key Features Needed

#### Tab 1: Shortcuts
- Integrate existing ShortcutManager UI
- Remove modal popup wrapper
- Render directly in tab content

#### Tab 2: Node Dictionary
- Parse and render markdown file
- Collapsible sections (by header level)
- Search functionality (filter by name/category/description)
- Table of contents navigation
- Code block rendering
- Copy-to-clipboard for examples

#### Tab 3: Getting Started
- Tutorial content
- Step-by-step guides
- Tips and tricks
- Quick reference

#### Tab 4: About
- Version info
- Credits
- System info
- External links

## Technical Questions for Expert

1. **Markdown Rendering**:
   - Best approach for parsing markdown in C++/JUCE?
   - Should we use a library (cmark, markdown-it) or simple custom parser?
   - How to handle code syntax highlighting in ImGui?
   - Best way to render tables from markdown?

2. **Search Implementation**:
   - Real-time filtering performance with large markdown files?
   - Should we pre-index content or parse on-demand?
   - How to highlight search matches in rendered text?

3. **UI/UX Patterns**:
   - Best way to implement collapsible sections with ImGui?
   - How to handle deep nesting in markdown (multiple header levels)?
   - Scroll-to-section functionality - best approach?
   - Copy-to-clipboard for code blocks - JUCE clipboard API?

4. **Architecture**:
   - Should HelpManagerComponent be a singleton or instance?
   - How to handle markdown parsing - lazy load or parse on open?
   - Memory management for parsed markdown content?
   - Should we cache parsed markdown or re-parse each time?

5. **Integration**:
   - Best way to integrate with existing menu system?
   - How to handle F1 shortcut (currently opens shortcuts)?
   - Context menu integration - "View in Dictionary" from node right-click?

## Files to Review

### Core Architecture
- `juce/Source/preset_creator/ShortcutManager.h` - Shortcut system API
- `juce/Source/preset_creator/ShortcutManager.cpp` - Implementation
- `juce/Source/preset_creator/theme/ThemeEditorComponent.h` - Tabbed UI pattern
- `juce/Source/preset_creator/theme/ThemeEditorComponent.cpp` - Implementation
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.h` - Main editor
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp` - Menu integration

### Documentation
- `USER_MANUAL/Nodes_Dictionary.md` - Content to render
- `guides/IMGUI_NODE_DESIGN_GUIDE.md` - UI patterns
- `guides/HELP_MANAGER_DESIGN.md` - Design document (just created)

### Reference
- `imgui_demo.cpp` - ImGui examples and patterns
- `juce/Source/preset_creator/theme/ThemeManager.cpp` - Singleton pattern example

## Design Constraints

1. **Performance**: Must handle large markdown files smoothly
2. **Memory**: Efficient parsing and caching strategy
3. **UX**: Fast search, smooth scrolling, responsive UI
4. **Maintainability**: Easy to add new tabs or content
5. **Consistency**: Follow existing code patterns (ThemeEditorComponent style)

## Success Criteria

- Help Manager opens from Help menu
- Shortcuts tab fully functional (migrated from Settings)
- Node Dictionary tab renders markdown with search
- Getting Started and About tabs provide useful content
- F1 shortcut opens Help Manager
- Context menu integration works ("View in Dictionary")
- Performance is smooth with large content
- UI is consistent with existing theme system



================================================================================
FILE: MOOFYS\communicate.md
================================================================================


# Communication to External Expert - Help Manager System

## DO NOT EDIT THIS FILE!!!

This file communicates the current situation and questions to an external expert who doesn't have access to the full project context.

---

## Project Overview

We're building a **Help Manager System** for Collider, a modular synthesizer built with C++17, JUCE framework, and ImGui/ImNodes for the UI. The goal is to create a centralized, tabbed help interface that consolidates documentation, shortcuts, and user assistance.

## Current State

### What We Have

1. **Fully functional ShortcutManager** - A data-driven shortcut system with:
   - Action registry with metadata (name, description, category)
   - Context-aware bindings (Global, Node Editor, etc.)
   - User rebinding and persistence (JSON)
   - Currently accessed via `Settings > Keyboard Shortcuts...` (modal popup)

2. **ThemeEditorComponent** - A reference implementation showing:
   - Tabbed UI using `ImGui::BeginTabBar()`
   - Window state management
   - Working copy pattern (apply/reset)
   - Good pattern to follow for our HelpManagerComponent

3. **Large markdown documentation** - `Nodes_Dictionary.md` (~2500+ lines):
   - Structured with headers (##, ###, ####)
   - Code blocks, lists, tables
   - Documentation for 100+ node types
   - Needs to be rendered in a searchable, collapsible format

### What We Need

A **HelpManagerComponent** with these tabs:

1. **Shortcuts Tab** - Integrate existing ShortcutManager UI (remove modal wrapper)
2. **Node Dictionary Tab** - Render markdown with search, collapsible sections
3. **Getting Started Tab** - Tutorials and guides
4. **About Tab** - Version, credits, system info

## Key Questions

### 1. Markdown Rendering Strategy

**Question**: What's the best approach for parsing and rendering markdown in a C++/JUCE/ImGui environment?

**Options we're considering**:
- **Option A**: Simple custom parser (parse headers, code blocks, lists)
  - Pros: Lightweight, full control, no dependencies
  - Cons: May miss edge cases, more work to maintain
- **Option B**: Use existing C++ markdown library (cmark, markdown-it-cpp)
  - Pros: Handles edge cases, well-tested
  - Cons: External dependency, may be overkill

**Specific concerns**:
- How to render code blocks with syntax highlighting in ImGui?
- Best way to handle markdown tables in ImGui?
- How to make text selectable/copyable in ImGui?

### 2. Search Implementation

**Question**: How should we implement real-time search filtering for large markdown content?

**Considerations**:
- File is ~2500 lines, potentially 100+ sections
- Need to filter by node name, category, description
- Should we pre-index content or parse on-demand?
- How to highlight matching text in rendered content?
- Performance implications of real-time filtering?

### 3. Collapsible Sections

**Question**: Best pattern for rendering deeply nested markdown headers as collapsible sections?

**Requirements**:
- Support multiple header levels (##, ###, ####)
- Auto-expand sections that match search
- Smooth scrolling to sections
- Maintain scroll position when expanding/collapsing

**ImGui options**:
- `ImGui::CollapsingHeader()` - Simple but limited nesting
- `ImGui::TreeNode()` - Better for deep nesting
- Custom implementation?

### 4. Architecture Decisions

**Question**: What's the best architecture for HelpManagerComponent?

**Specific questions**:
- Singleton vs instance? (ThemeManager is singleton, ThemeEditorComponent is instance)
- When to parse markdown? (on open, lazy load, cache?)
- Memory management for parsed content?
- Should parsing be separate class (MarkdownParser) or integrated?

### 5. UI/UX Patterns

**Question**: What are best practices for these UI features?

- **Scroll-to-section**: How to scroll ImGui window to specific content?
- **Copy-to-clipboard**: JUCE clipboard API usage for code blocks?
- **Table of contents**: Best way to implement jump links?
- **Search highlighting**: How to highlight matching text in ImGui text rendering?

### 6. Integration Points

**Question**: How should we integrate with existing systems?

- **Menu integration**: Move shortcuts from Settings to Help menu - any concerns?
- **F1 shortcut**: Currently opens shortcuts window - should it open Help Manager to Shortcuts tab?
- **Context menu**: Right-click node ‚Üí "View in Dictionary" ‚Üí Open Help Manager to that node's section - how to implement scroll-to?

## Technical Context

### Framework Details
- **JUCE**: Cross-platform C++ framework (file I/O, clipboard, strings)
- **ImGui**: Immediate-mode GUI (widgets, rendering)
- **ImNodes**: Node editor built on ImGui
- **C++17**: Modern C++ features available

### Existing Patterns
- Components follow similar pattern to `ThemeEditorComponent`
- Use `ImGui::BeginTabBar()` for tabs
- Window state managed with `bool m_isOpen`
- Working copy pattern for editing (apply/reset)

### Performance Requirements
- Smooth scrolling with large content
- Real-time search should feel instant
- No noticeable lag when opening Help Manager
- Memory efficient (don't load everything at once if not needed)

## What We're Looking For

1. **Recommendations** on markdown rendering approach
2. **Best practices** for search implementation
3. **Code patterns** for collapsible sections
4. **Architecture guidance** for component design
5. **UI/UX suggestions** for user experience
6. **Performance tips** for handling large content
7. **Integration advice** for menu and context menu

## Success Criteria

The Help Manager should:
- Open smoothly from Help menu
- Display shortcuts in a tab (migrated from Settings)
- Render markdown documentation with search
- Provide useful Getting Started and About content
- Feel responsive and professional
- Follow existing code patterns and style

---

**Note**: We have a detailed design document at `guides/HELP_MANAGER_DESIGN.md` with more specifics, but we're looking for expert guidance on the technical implementation details, especially around markdown rendering and search performance.



================================================================================
FILE: juce\Source\preset_creator\theme\ThemeEditorComponent.h
================================================================================


#pragma once

#include "Theme.h"
#include "ThemeManager.h"
#include <imgui.h>
#include <array>
#include <memory>
#include <juce_core/juce_core.h>

class ImGuiNodeEditorComponent;

/**
 * Theme Editor Component
 * 
 * Provides a visual editor for modifying theme properties in real-time.
 * Changes are applied immediately and can be saved as custom themes.
 */
class ThemeEditorComponent
{
public:
    ThemeEditorComponent(ImGuiNodeEditorComponent* parent);
    ~ThemeEditorComponent() = default;

    // Connects the eyedropper from host component
    void setStartPicker(std::function<void(std::function<void(ImU32)>)> fn) { m_startPicker = std::move(fn); }

    // Render the theme editor window
    void render();

    // Window state
    void open();
    void close();
    bool isOpen() const { return m_isOpen; }

    /** Refresh internal working copy from ThemeManager after external theme load */
    void refreshThemeFromManager();

private:
    // Tab rendering functions
    void renderTabs();
    void renderImGuiStyleTab();
    void renderImGuiColorsTab();
    void renderAccentTab();
    void renderTextColorsTab();
    void renderStatusColorsTab();
    void renderHeaderColorsTab();
    void renderImNodesTab();
    void renderLinksTab();
    void renderCanvasTab();
    void renderLayoutTab();
    void renderFontsTab();
    void renderWindowsTab();
    void renderModulationTab();
    void renderMetersTab();
    void renderTimelineTab();
    void renderModulesTab();

    // Helper UI components
    bool colorEdit4(const char* label, ImVec4& color, ImGuiColorEditFlags flags = 0);
    bool colorEditU32(const char* label, ImU32& color, ImGuiColorEditFlags flags = 0);
    bool dragFloat(const char* label, float& value, float speed = 0.1f, float min = 0.0f, float max = 0.0f, const char* format = "%.2f");
    bool dragFloat2(const char* label, ImVec2& value, float speed = 0.1f, float min = 0.0f, float max = 0.0f, const char* format = "%.2f");
    bool triStateColorEdit(const char* label, TriStateColor& tsc);
    
    // Eyedropper support
    void renderPickerOverlay();
    void beginPickColor(ImU32* target);
    void beginPickColor(ImVec4* target);
    static bool sampleScreenPixel(int x, int y, unsigned char outRGBA[4]);
    
    // Save/Load
    void renderSaveDialog();
    void saveTheme();  // Save to current theme file
    void saveThemeAs();  // Save to new theme file
    void resetCurrentTab();
    void applyChanges();
    void syncFontBuffersFromWorkingCopy();
    void previewFontChanges();
    void scanFontFolder();
    int findScannedFontIndex(const juce::String& path) const;

    // State
    bool m_isOpen = false;
    Theme m_workingCopy;  // Working copy of theme (modifications applied here)
    bool m_hasChanges = false;
    int m_currentTab = 0;
    juce::String m_currentThemeFilename;  // Filename of currently loaded theme (empty if default)
    
    // Save dialog state
    bool m_showSaveDialog = false;
    char m_saveThemeName[256] = {0};
    
    // Eyedropper state
    bool m_pickerActive = false;
    ImU32* m_pickTargetU32 = nullptr;
    ImVec4* m_pickTargetVec4 = nullptr;
    
    // Tab names
    static constexpr const char* s_tabNames[] = {
        "ImGui Style",
        "ImGui Colors",
        "Accent",
        "Text Colors",
        "Status",
        "Headers",
        "ImNodes",
        "Links",
        "Canvas",
        "Layout",
        "Fonts",
        "Windows",
        "Modulation",
        "Meters",
        "Timeline",
        "Modules"
    };
    
    static constexpr int s_numTabs = 16;

    // Injection from host: start a framebuffer-based picker
    std::function<void(std::function<void(ImU32)>)> m_startPicker;

    // Font editor helpers
    std::array<char, 512> m_defaultFontPathBuffer {};
    std::unique_ptr<juce::FileChooser> m_fontChooser;
    juce::StringArray m_scannedFontFiles;
    int m_selectedFontIndex = -1;
    ImGuiNodeEditorComponent* parentEditor = nullptr;
};



================================================================================
FILE: juce\Source\preset_creator\theme\ThemeEditorComponent.cpp
================================================================================


#include "ThemeEditorComponent.h"
#include <juce_core/juce_core.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <imgui.h>
#include <juce_opengl/juce_opengl.h>
#include <cstring>
#if defined(_WIN32)
  #include <windows.h>
  #include <GL/gl.h>
#else
  #include <GL/gl.h>
#endif
#ifndef GL_RGBA
  #define GL_RGBA 0x1908
#endif
#ifndef GL_UNSIGNED_BYTE
  #define GL_UNSIGNED_BYTE 0x1401
#endif

namespace
{
static juce::File resolveFontPath(const juce::String& path)
{
    juce::File file(path);
    if (path.isNotEmpty() && !juce::File::isAbsolutePath(path))
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        file = exeDir.getChildFile(path);
    }
    return file;
}
}

ThemeEditorComponent::ThemeEditorComponent(ImGuiNodeEditorComponent* parent)
    : parentEditor(parent)
{
    // Initialize working copy with current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    syncFontBuffersFromWorkingCopy();
    scanFontFolder();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::open()
{
    m_isOpen = true;
    // Refresh working copy from current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_currentThemeFilename = ThemeManager::getInstance().getCurrentThemeFilename();  // Get current theme filename
    m_hasChanges = false;
    m_currentTab = 0;
    m_showSaveDialog = false;
    memset(m_saveThemeName, 0, sizeof(m_saveThemeName));
    syncFontBuffersFromWorkingCopy();
    scanFontFolder();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::close()
{
    if (m_hasChanges)
    {
        // TODO: Ask for confirmation if there are unsaved changes
        // For now, just discard
    }
    m_isOpen = false;
    m_showSaveDialog = false;
}

void ThemeEditorComponent::refreshThemeFromManager()
{
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_currentThemeFilename = ThemeManager::getInstance().getCurrentThemeFilename();  // Update current theme filename
    m_hasChanges = false;
    juce::Logger::writeToLog("[ThemeEditor] Refreshed working copy from ThemeManager");
    syncFontBuffersFromWorkingCopy();
    scanFontFolder();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::render()
{
    if (!m_isOpen)
        return;

    // Window flags
    ImGuiWindowFlags flags = ImGuiWindowFlags_None;
    
    // Set window size and position
    ImGui::SetNextWindowSize(ImVec2(900, 700), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);

    // Build window title with current theme name
    juce::String windowTitle = "Theme Editor";
    if (m_currentThemeFilename.isNotEmpty())
    {
        // Remove .json extension and format nicely
        juce::String displayName = m_currentThemeFilename;
        if (displayName.endsWithIgnoreCase(".json"))
            displayName = displayName.substring(0, displayName.length() - 5);
        windowTitle += " - " + displayName;
    }
    else
    {
        windowTitle += " - Default Theme";
    }
    
    if (ImGui::Begin(windowTitle.toRawUTF8(), &m_isOpen, flags))
    {
        // Toolbar
        if (ImGui::Button("Apply Changes"))
        {
            applyChanges();
        }
        ImGui::SameLine();
        if (ImGui::Button("Reset Tab"))
        {
            resetCurrentTab();
        }
        ImGui::SameLine();
        
        // Save button (only enabled if editing an existing theme)
        bool hasCurrentTheme = m_currentThemeFilename.isNotEmpty();
        if (!hasCurrentTheme)
            ImGui::BeginDisabled();
        if (ImGui::Button("Save"))
        {
            saveTheme();
        }
        if (!hasCurrentTheme)
            ImGui::EndDisabled();
        
        ImGui::SameLine();
        if (ImGui::Button("Save As..."))
        {
            m_showSaveDialog = true;
            // Pre-fill with current theme name if available, otherwise use "CustomTheme"
            if (m_currentThemeFilename.isNotEmpty())
            {
                juce::String baseName = m_currentThemeFilename;
                if (baseName.endsWithIgnoreCase(".json"))
                    baseName = baseName.substring(0, baseName.length() - 5);
                strncpy(m_saveThemeName, baseName.toRawUTF8(), sizeof(m_saveThemeName) - 1);
            }
            else
            {
                strncpy(m_saveThemeName, "CustomTheme", sizeof(m_saveThemeName) - 1);
            }
        }
        ImGui::SameLine();
        if (m_hasChanges)
        {
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "* Unsaved changes");
        }

        ImGui::Separator();

        // Tabs
        renderTabs();

        // Save dialog (modal)
        if (m_showSaveDialog)
        {
            renderSaveDialog();
        }

        // Eyedropper overlay if active
        renderPickerOverlay();
    }
    ImGui::End();

    // Close if window X clicked (m_isOpen was set to false by ImGui::Begin)
    if (!m_isOpen)
        close();
}

// ---- Eyedropper utilities ----
void ThemeEditorComponent::beginPickColor(ImU32* target)
{
    m_pickerActive = true;
    m_pickTargetU32 = target;
    m_pickTargetVec4 = nullptr;
}

void ThemeEditorComponent::beginPickColor(ImVec4* target)
{
    m_pickerActive = true;
    m_pickTargetU32 = nullptr;
    m_pickTargetVec4 = target;
}

bool ThemeEditorComponent::sampleScreenPixel(int, int, unsigned char outRGBA[4])
{
    // Disabled: pixel picking handled by ImGuiNodeEditorComponent.
    outRGBA[0]=outRGBA[1]=outRGBA[2]=0; outRGBA[3]=255;
    return false;
}

void ThemeEditorComponent::renderPickerOverlay()
{
    // Disabled: handled by node editor (we keep function for compatibility)
    juce::ignoreUnused(m_pickerActive);
}

void ThemeEditorComponent::renderTabs()
{
    if (ImGui::BeginTabBar("ThemeEditorTabs"))
    {
        // Tab buttons
        const char* tabNames[] = {
            "Style", "Colors", "Accent", "Text", "Status", "Headers",
            "ImNodes", "Links", "Canvas", "Layout", "Fonts", "Windows",
            "Modulation", "Meters", "Timeline", "Modules"
        };

        for (int i = 0; i < s_numTabs; ++i)
        {
            if (ImGui::BeginTabItem(tabNames[i]))
            {
                m_currentTab = i;
                
                // Render tab content
                switch (i)
                {
                    case 0: renderImGuiStyleTab(); break;
                    case 1: renderImGuiColorsTab(); break;
                    case 2: renderAccentTab(); break;
                    case 3: renderTextColorsTab(); break;
                    case 4: renderStatusColorsTab(); break;
                    case 5: renderHeaderColorsTab(); break;
                    case 6: renderImNodesTab(); break;
                    case 7: renderLinksTab(); break;
                    case 8: renderCanvasTab(); break;
                    case 9: renderLayoutTab(); break;
                    case 10: renderFontsTab(); break;
                    case 11: renderWindowsTab(); break;
                    case 12: renderModulationTab(); break;
                    case 13: renderMetersTab(); break;
                    case 14: renderTimelineTab(); break;
                    case 15: renderModulesTab(); break;
                }
                
                ImGui::EndTabItem();
            }
        }
        ImGui::EndTabBar();
    }
}

// Helper implementations
bool ThemeEditorComponent::colorEdit4(const char* label, ImVec4& color, ImGuiColorEditFlags flags)
{
    if (!label)
        return false;

    juce::Logger::writeToLog(juce::String("[ThemeColorPicker] Drawing (ImVec4) picker for: ") + label);

    bool valueChanged = false;
    try
    {
        ImGui::PushID(label);
        valueChanged = ImGui::ColorEdit4("##picker", (float*)&color,
                                         ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

        ImGui::SameLine();
        ImGui::TextUnformatted(label);
        ImGui::PopID();

        if (valueChanged)
            m_hasChanges = true;
    }
    catch (const std::exception& e)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] EXCEPTION (ImVec4) for label '") + label + "': " + e.what());
        ImGui::PopID();
        return false;
    }
    catch (...)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] UNKNOWN EXCEPTION (ImVec4) for label '") + label + "'");
        ImGui::PopID();
        return false;
    }

    return valueChanged;
}

bool ThemeEditorComponent::colorEditU32(const char* label, ImU32& color, ImGuiColorEditFlags flags)
{
    if (!label)
        return false;

    juce::Logger::writeToLog(juce::String("[ThemeColorPicker] Drawing (ImU32) picker for: ") + label);

    ImVec4 floatColor;
    bool valueChanged = false;

    try
    {
        ImGui::PushID(label);

        floatColor = ImGui::ColorConvertU32ToFloat4(color);

        valueChanged = ImGui::ColorEdit4("##picker", (float*)&floatColor,
                                         ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

        if (valueChanged)
        {
            color = ImGui::ColorConvertFloat4ToU32(floatColor);
            m_hasChanges = true;
        }

        ImGui::SameLine();
        ImGui::TextUnformatted(label);

        ImGui::PopID();
    }
    catch (const std::exception& e)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] EXCEPTION (ImU32) for label '") + label + "': " + e.what());
        ImGui::PopID();
        return false;
    }
    catch (...)
    {
        juce::Logger::writeToLog(juce::String("[ThemeColorPicker] UNKNOWN EXCEPTION (ImU32) for label '") + label + "'");
        ImGui::PopID();
        return false;
    }

    return valueChanged;
}

bool ThemeEditorComponent::dragFloat(const char* label, float& value, float speed, float min, float max, const char* format)
{
    bool changed = ImGui::DragFloat(label, &value, speed, min, max, format);
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::dragFloat2(const char* label, ImVec2& value, float speed, float min, float max, const char* format)
{
    bool changed = ImGui::DragFloat2(label, &value.x, speed, min, max, format);
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::triStateColorEdit(const char* label, TriStateColor& tsc)
{
    bool changed = false;
    if (ImGui::TreeNode(label))
    {
        changed |= colorEditU32("Base", tsc.base);
        changed |= colorEditU32("Hovered", tsc.hovered);
        changed |= colorEditU32("Active", tsc.active);
        ImGui::TreePop();
    }
    return changed;
}

// Tab implementations (stubs for now)
void ThemeEditorComponent::renderImGuiStyleTab()
{
    ImGui::Text("ImGui Style Settings");
    ImGui::Separator();
    
    // Split into two columns: controls on left, preview on right
    ImGui::Columns(2, "StyleColumns", true);
    
    // Left column: Controls
    if (ImGui::CollapsingHeader("Padding & Spacing"))
    {
        dragFloat2("Window Padding", m_workingCopy.style.WindowPadding, 1.0f, 0.0f, 50.0f);
        dragFloat2("Frame Padding", m_workingCopy.style.FramePadding, 1.0f, 0.0f, 50.0f);
        dragFloat2("Item Spacing", m_workingCopy.style.ItemSpacing, 1.0f, 0.0f, 50.0f);
        dragFloat2("Item Inner Spacing", m_workingCopy.style.ItemInnerSpacing, 1.0f, 0.0f, 50.0f);
    }
    
    if (ImGui::CollapsingHeader("Rounding"))
    {
        dragFloat("Window Rounding", m_workingCopy.style.WindowRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Child Rounding", m_workingCopy.style.ChildRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Frame Rounding", m_workingCopy.style.FrameRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Popup Rounding", m_workingCopy.style.PopupRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Scrollbar Rounding", m_workingCopy.style.ScrollbarRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Grab Rounding", m_workingCopy.style.GrabRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Tab Rounding", m_workingCopy.style.TabRounding, 0.5f, 0.0f, 20.0f);
    }
    
    if (ImGui::CollapsingHeader("Borders"))
    {
        dragFloat("Window Border Size", m_workingCopy.style.WindowBorderSize, 0.1f, 0.0f, 5.0f);
        dragFloat("Frame Border Size", m_workingCopy.style.FrameBorderSize, 0.1f, 0.0f, 5.0f);
        dragFloat("Popup Border Size", m_workingCopy.style.PopupBorderSize, 0.1f, 0.0f, 5.0f);
    }
    
    ImGui::NextColumn();
    
    // Right column: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Apply working copy style temporarily for preview
    ImGuiStyle& style = ImGui::GetStyle();
    ImGuiStyle backup = style;
    
    style.WindowPadding = m_workingCopy.style.WindowPadding;
    style.FramePadding = m_workingCopy.style.FramePadding;
    style.ItemSpacing = m_workingCopy.style.ItemSpacing;
    style.ItemInnerSpacing = m_workingCopy.style.ItemInnerSpacing;
    style.WindowRounding = m_workingCopy.style.WindowRounding;
    style.ChildRounding = m_workingCopy.style.ChildRounding;
    style.FrameRounding = m_workingCopy.style.FrameRounding;
    style.PopupRounding = m_workingCopy.style.PopupRounding;
    style.ScrollbarRounding = m_workingCopy.style.ScrollbarRounding;
    style.GrabRounding = m_workingCopy.style.GrabRounding;
    style.TabRounding = m_workingCopy.style.TabRounding;
    style.WindowBorderSize = m_workingCopy.style.WindowBorderSize;
    style.FrameBorderSize = m_workingCopy.style.FrameBorderSize;
    style.PopupBorderSize = m_workingCopy.style.PopupBorderSize;
    
    // Preview window
    if (ImGui::BeginChild("StylePreview", ImVec2(0, 0), true))
    {
        ImGui::Text("Preview Window");
        ImGui::Separator();
        
        // Button preview
        if (ImGui::Button("Sample Button"))
        {
            // Button clicked
        }
        ImGui::SameLine();
        if (ImGui::Button("Another Button"))
        {
            // Button clicked
        }
        
        ImGui::Spacing();
        
        // Frame preview
        ImGui::Text("Frame with border:");
        ImGui::BeginChildFrame(ImGui::GetID("preview_frame"), ImVec2(0, 60));
        ImGui::Text("Content inside frame");
        ImGui::Button("Button in Frame");
        ImGui::EndChildFrame();
        
        ImGui::Spacing();
        
        // Tab preview
        if (ImGui::BeginTabBar("PreviewTabs"))
        {
            if (ImGui::BeginTabItem("Tab 1"))
            {
                ImGui::Text("Tab 1 content");
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Tab 2"))
            {
                ImGui::Text("Tab 2 content");
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }
        
        ImGui::Spacing();
        
        // Slider preview
        static float sliderValue = 0.5f;
        ImGui::SliderFloat("Preview Slider", &sliderValue, 0.0f, 1.0f);
        
        ImGui::Spacing();
        
        // Checkbox preview
        static bool check1 = true, check2 = false;
        ImGui::Checkbox("Checkbox 1", &check1);
        ImGui::Checkbox("Checkbox 2", &check2);
        
        ImGui::Spacing();
        
        // Input preview
        static char text[64] = "Sample text";
        ImGui::InputText("Text Input", text, sizeof(text));
    }
    ImGui::EndChild();
    
    // Restore original style
    style = backup;
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderImGuiColorsTab()
{
    ImGui::Text("ImGui Colors");
    ImGui::Separator();
    ImGui::TextWrapped("Edit core ImGui colors. These affect all ImGui windows and widgets.");
    
    ImGui::Columns(2, "ImGuiColorsColumns", true);
    
    // Left: Controls organized by category
    if (ImGui::CollapsingHeader("Window Colors"))
    {
        ImVec4& windowBg = m_workingCopy.style.Colors[ImGuiCol_WindowBg];
        ImVec4& childBg = m_workingCopy.style.Colors[ImGuiCol_ChildBg];
        ImVec4& popupBg = m_workingCopy.style.Colors[ImGuiCol_PopupBg];
        ImVec4& titleBg = m_workingCopy.style.Colors[ImGuiCol_TitleBg];
        ImVec4& titleBgActive = m_workingCopy.style.Colors[ImGuiCol_TitleBgActive];
        ImVec4& titleBgCollapsed = m_workingCopy.style.Colors[ImGuiCol_TitleBgCollapsed];
        
        colorEdit4("Window Background", windowBg);
        colorEdit4("Node Background (ChildBg)", childBg);
        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("Controls the background color used for node editors and child regions.");
        colorEdit4("Popup Background", popupBg);
        colorEdit4("Title Background", titleBg);
        colorEdit4("Title Active", titleBgActive);
        colorEdit4("Title Collapsed", titleBgCollapsed);
    }
    
    if (ImGui::CollapsingHeader("Text Colors"))
    {
        ImVec4& text = m_workingCopy.style.Colors[ImGuiCol_Text];
        ImVec4& textDisabled = m_workingCopy.style.Colors[ImGuiCol_TextDisabled];
        ImVec4& textSelectedBg = m_workingCopy.style.Colors[ImGuiCol_TextSelectedBg];
        
        colorEdit4("Text", text);
        colorEdit4("Text Disabled", textDisabled);
        colorEdit4("Text Selected Background", textSelectedBg);
    }
    
    if (ImGui::CollapsingHeader("Button & Frame Colors"))
    {
        ImVec4& button = m_workingCopy.style.Colors[ImGuiCol_Button];
        ImVec4& buttonHovered = m_workingCopy.style.Colors[ImGuiCol_ButtonHovered];
        ImVec4& buttonActive = m_workingCopy.style.Colors[ImGuiCol_ButtonActive];
        ImVec4& frameBg = m_workingCopy.style.Colors[ImGuiCol_FrameBg];
        ImVec4& frameBgHovered = m_workingCopy.style.Colors[ImGuiCol_FrameBgHovered];
        ImVec4& frameBgActive = m_workingCopy.style.Colors[ImGuiCol_FrameBgActive];
        
        colorEdit4("Button", button);
        colorEdit4("Button Hovered", buttonHovered);
        colorEdit4("Button Active", buttonActive);
        colorEdit4("Frame Background", frameBg);
        colorEdit4("Frame Hovered", frameBgHovered);
        colorEdit4("Frame Active", frameBgActive);
    }
    
    if (ImGui::CollapsingHeader("Slider & Scrollbar"))
    {
        ImVec4& sliderGrab = m_workingCopy.style.Colors[ImGuiCol_SliderGrab];
        ImVec4& sliderGrabActive = m_workingCopy.style.Colors[ImGuiCol_SliderGrabActive];
        ImVec4& scrollbarBg = m_workingCopy.style.Colors[ImGuiCol_ScrollbarBg];
        ImVec4& scrollbarGrab = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrab];
        ImVec4& scrollbarGrabHovered = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrabHovered];
        ImVec4& scrollbarGrabActive = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrabActive];
        
        colorEdit4("Slider Grab", sliderGrab);
        colorEdit4("Slider Grab Active", sliderGrabActive);
        colorEdit4("Scrollbar Background", scrollbarBg);
        colorEdit4("Scrollbar Grab", scrollbarGrab);
        colorEdit4("Scrollbar Grab Hovered", scrollbarGrabHovered);
        colorEdit4("Scrollbar Grab Active", scrollbarGrabActive);
    }
    
    if (ImGui::CollapsingHeader("Border & Separator"))
    {
        ImVec4& border = m_workingCopy.style.Colors[ImGuiCol_Border];
        ImVec4& borderShadow = m_workingCopy.style.Colors[ImGuiCol_BorderShadow];
        ImVec4& separator = m_workingCopy.style.Colors[ImGuiCol_Separator];
        ImVec4& separatorHovered = m_workingCopy.style.Colors[ImGuiCol_SeparatorHovered];
        ImVec4& separatorActive = m_workingCopy.style.Colors[ImGuiCol_SeparatorActive];
        
        colorEdit4("Border", border);
        colorEdit4("Border Shadow", borderShadow);
        colorEdit4("Separator", separator);
        colorEdit4("Separator Hovered", separatorHovered);
        colorEdit4("Separator Active", separatorActive);
    }
    
    if (ImGui::CollapsingHeader("Tab & Menu"))
    {
        ImVec4& tab = m_workingCopy.style.Colors[ImGuiCol_Tab];
        ImVec4& tabHovered = m_workingCopy.style.Colors[ImGuiCol_TabHovered];
        ImVec4& tabActive = m_workingCopy.style.Colors[ImGuiCol_TabActive];
        ImVec4& tabUnfocused = m_workingCopy.style.Colors[ImGuiCol_TabUnfocused];
        ImVec4& tabUnfocusedActive = m_workingCopy.style.Colors[ImGuiCol_TabUnfocusedActive];
        ImVec4& menuBarBg = m_workingCopy.style.Colors[ImGuiCol_MenuBarBg];
        
        colorEdit4("Tab", tab);
        colorEdit4("Tab Hovered", tabHovered);
        colorEdit4("Tab Active", tabActive);
        colorEdit4("Tab Unfocused", tabUnfocused);
        colorEdit4("Tab Unfocused Active", tabUnfocusedActive);
        colorEdit4("Menu Bar Background", menuBarBg);
    }
    
    if (ImGui::CollapsingHeader("Other"))
    {
        ImVec4& checkMark = m_workingCopy.style.Colors[ImGuiCol_CheckMark];
        ImVec4& dragDropTarget = m_workingCopy.style.Colors[ImGuiCol_DragDropTarget];
        ImVec4& header = m_workingCopy.style.Colors[ImGuiCol_Header];
        ImVec4& headerHovered = m_workingCopy.style.Colors[ImGuiCol_HeaderHovered];
        ImVec4& headerActive = m_workingCopy.style.Colors[ImGuiCol_HeaderActive];
        ImVec4& resizeGrip = m_workingCopy.style.Colors[ImGuiCol_ResizeGrip];
        ImVec4& resizeGripHovered = m_workingCopy.style.Colors[ImGuiCol_ResizeGripHovered];
        ImVec4& resizeGripActive = m_workingCopy.style.Colors[ImGuiCol_ResizeGripActive];
        
        colorEdit4("Check Mark", checkMark);
        colorEdit4("Drag Drop Target", dragDropTarget);
        colorEdit4("Header", header);
        colorEdit4("Header Hovered", headerHovered);
        colorEdit4("Header Active", headerActive);
        colorEdit4("Resize Grip", resizeGrip);
        colorEdit4("Resize Grip Hovered", resizeGripHovered);
        colorEdit4("Resize Grip Active", resizeGripActive);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Apply working copy colors temporarily for preview
    ImGuiStyle& style = ImGui::GetStyle();
    ImGuiStyle backup = style;
    style = m_workingCopy.style;
    
    if (ImGui::BeginChild("ImGuiColorsPreview", ImVec2(0, 0), true))
    {
        // Window preview
        ImGui::Text("Window Preview");
        ImGui::Separator();
        
        if (ImGui::Button("Sample Button"))
        {
            // Button clicked
        }
        ImGui::SameLine();
        if (ImGui::Button("Another Button"))
        {
            // Button clicked
        }
        
        ImGui::Spacing();
        
        // Frame preview
        ImGui::Text("Frame with border:");
        ImGui::BeginChildFrame(ImGui::GetID("preview_frame2"), ImVec2(0, 60));
        ImGui::Text("Content inside frame");
        ImGui::Button("Button in Frame");
        ImGui::EndChildFrame();
        
        ImGui::Spacing();
        
        // Slider preview
        static float sliderValue = 0.5f;
        ImGui::SliderFloat("Preview Slider", &sliderValue, 0.0f, 1.0f);
        
        ImGui::Spacing();
        
        // Checkbox preview
        static bool check1 = true, check2 = false;
        ImGui::Checkbox("Checkbox 1", &check1);
        ImGui::Checkbox("Checkbox 2", &check2);
        
        ImGui::Spacing();
        
        // Input preview
        static char text[64] = "Sample text";
        ImGui::InputText("Text Input", text, sizeof(text));
        
        ImGui::Spacing();
        
        // Tab preview
        if (ImGui::BeginTabBar("PreviewTabs2"))
        {
            if (ImGui::BeginTabItem("Tab 1"))
            {
                ImGui::Text("Tab 1 content");
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Tab 2"))
            {
                ImGui::Text("Tab 2 content");
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }
    }
    ImGui::EndChild();
    
    // Restore original style
    style = backup;
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderAccentTab()
{
    ImGui::Text("Accent Color");
    ImGui::Separator();
    ImGui::TextWrapped("The accent color is used throughout the UI for highlights and interactive elements.");
    
    ImGui::Columns(2, "AccentColumns", true);
    
    // Left: Color picker
    colorEdit4("Accent", m_workingCopy.accent);
    
    ImGui::Spacing();
    ImGui::Text("RGB Values:");
    ImGui::Text("R: %.3f", m_workingCopy.accent.x);
    ImGui::Text("G: %.3f", m_workingCopy.accent.y);
    ImGui::Text("B: %.3f", m_workingCopy.accent.z);
    ImGui::Text("A: %.3f", m_workingCopy.accent.w);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Large color swatch
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.accent));
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + ImGui::GetStyle().ItemSpacing.y));
    
    ImGui::Spacing();
    
    // Preview accent in UI elements
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_CheckMark, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_SliderGrabActive, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_TabHovered, ImVec4(m_workingCopy.accent.x, m_workingCopy.accent.y, m_workingCopy.accent.z, 0.8f));
    
    if (ImGui::Button("Button (hovered color)"))
    {
        // Button clicked
    }
    
    static bool previewCheck = true;
    ImGui::Checkbox("Checkbox (checkmark color)", &previewCheck);
    
    static float previewSlider = 0.5f;
    ImGui::SliderFloat("Slider (grab color)", &previewSlider, 0.0f, 1.0f);
    
    if (ImGui::BeginTabBar("AccentTabs"))
    {
        if (ImGui::BeginTabItem("Tab (hover)"))
        {
            ImGui::Text("Tab content");
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }
    
    ImGui::PopStyleColor(4);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderTextColorsTab()
{
    ImGui::Text("Text Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "TextColorsColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Text Colors"))
    {
        colorEdit4("Section Header", m_workingCopy.text.section_header);
        colorEdit4("Warning", m_workingCopy.text.warning);
        colorEdit4("Success", m_workingCopy.text.success);
        colorEdit4("Error", m_workingCopy.text.error);
        colorEdit4("Disabled", m_workingCopy.text.disabled);
        colorEdit4("Active", m_workingCopy.text.active);
    }
    
    if (ImGui::CollapsingHeader("Tooltip Settings"))
    {
        dragFloat("Tooltip Wrap (Standard)", m_workingCopy.text.tooltip_wrap_standard, 1.0f, 10.0f, 100.0f);
        dragFloat("Tooltip Wrap (Compact)", m_workingCopy.text.tooltip_wrap_compact, 1.0f, 10.0f, 100.0f);
    }
    
    if (ImGui::CollapsingHeader("Text Rendering"))
    {
        // Add the master toggle checkbox
        if (ImGui::Checkbox("Enable Text Glow / Shadow", &m_workingCopy.text.enable_text_glow))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enable a soft shadow/glow effect for all themed text");
        
        // Add the color picker for the glow
        colorEdit4("Glow / Shadow Color", m_workingCopy.text.text_glow_color);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImGui::TextColored(m_workingCopy.text.section_header, "Section Header Text");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.warning, "‚ö† Warning Message");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.success, "‚úì Success Message");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.error, "‚úó Error Message");
    ImGui::Spacing();
    
    ImGui::PushStyleColor(ImGuiCol_Text, m_workingCopy.text.disabled);
    ImGui::Text("Disabled Text (grayed out)");
    ImGui::PopStyleColor();
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.active, "‚óè Active/Enabled Text");
    ImGui::Spacing();
    
    ImGui::Separator();
    ImGui::Text("Tooltip Preview:");
    ImGui::TextDisabled("(Hover over this text)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * m_workingCopy.text.tooltip_wrap_standard);
        ImGui::Text("This is a tooltip with the wrap width you set. It demonstrates how tooltips will wrap at the specified character count.");
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderStatusColorsTab()
{
    ImGui::Text("Status Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "StatusColumns", true);
    
    // Left: Controls
    colorEdit4("Edited", m_workingCopy.status.edited);
    colorEdit4("Saved", m_workingCopy.status.saved);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImGui::Text("Status: ");
    ImGui::SameLine();
    ImGui::TextColored(m_workingCopy.status.edited, "EDITED");
    
    ImGui::Spacing();
    
    ImGui::Text("Status: ");
    ImGui::SameLine();
    ImGui::TextColored(m_workingCopy.status.saved, "SAVED");
    
    ImGui::Spacing();
    ImGui::Separator();
    
    // Preview as overlay-style status indicator
    ImGui::BeginChild("StatusPreview", ImVec2(0, 80), true);
    ImGui::SetCursorPos(ImVec2(10, 10));
    ImGui::TextColored(m_workingCopy.status.edited, "Status: EDITED");
    
    ImGui::SetCursorPos(ImVec2(10, 40));
    ImGui::TextColored(m_workingCopy.status.saved, "Status: SAVED");
    ImGui::EndChild();
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderHeaderColorsTab()
{
    ImGui::Text("Header Colors (TriState)");
    ImGui::Separator();
    
    ImGui::Columns(2, "HeaderColumns", true);
    
    // Left: Controls
    triStateColorEdit("Recent", m_workingCopy.headers.recent);
    triStateColorEdit("Samples", m_workingCopy.headers.samples);
    triStateColorEdit("Presets", m_workingCopy.headers.presets);
    triStateColorEdit("System", m_workingCopy.headers.system);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Preview Recent header
    ImVec2 pos = ImGui::GetCursorScreenPos();
    ImVec2 size = ImVec2(ImGui::GetContentRegionAvail().x, 30);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview Samples header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.samples.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Samples (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview Presets header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.presets.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Presets (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview System header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.system.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("System (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Text("Hover states:");
    
    // Hover preview
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.hovered);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Hovered)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.active);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Active)");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderImNodesTab()
{
    ImGui::Text("ImNodes Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ImNodesColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Category Colors"))
    {
        // Module categories
        const char* categoryNames[] = {
            "Source", "Effect", "Modulator", "Utility", "Seq", "MIDI",
            "Analysis", "TTS_Voice", "Special_Exp", "OpenCV", "Sys", "Comment", "Plugin", "Default"
        };
        
        ModuleCategory categories[] = {
            ModuleCategory::Source, ModuleCategory::Effect, ModuleCategory::Modulator,
            ModuleCategory::Utility, ModuleCategory::Seq, ModuleCategory::MIDI,
            ModuleCategory::Analysis, ModuleCategory::TTS_Voice, ModuleCategory::Special_Exp,
            ModuleCategory::OpenCV, ModuleCategory::Sys, ModuleCategory::Comment,
            ModuleCategory::Plugin, ModuleCategory::Default
        };
        
        for (int i = 0; i < 14; ++i)
        {
            ImU32& color = m_workingCopy.imnodes.category_colors[categories[i]];
            if (colorEditU32(categoryNames[i], color))
            {
                m_hasChanges = true;
            }
        }
    }
    
    if (ImGui::CollapsingHeader("Pin Colors"))
    {
        // Pin data types
        const char* pinTypeNames[] = { "CV", "Audio", "Gate", "Raw", "Video" };
        PinDataType pinTypes[] = {
            PinDataType::CV, PinDataType::Audio, PinDataType::Gate,
            PinDataType::Raw, PinDataType::Video
        };
        
        for (int i = 0; i < 5; ++i)
        {
            ImU32& color = m_workingCopy.imnodes.pin_colors[pinTypes[i]];
            if (colorEditU32(pinTypeNames[i], color))
            {
                m_hasChanges = true;
            }
        }
        
        ImGui::Separator();
        colorEditU32("Pin Connected", m_workingCopy.imnodes.pin_connected);
        colorEditU32("Pin Disconnected", m_workingCopy.imnodes.pin_disconnected);
    }
    
    if (ImGui::CollapsingHeader("Node States"))
    {
        colorEditU32("Node Muted", m_workingCopy.imnodes.node_muted);
        dragFloat("Node Muted Alpha", m_workingCopy.imnodes.node_muted_alpha, 0.01f, 0.0f, 1.0f);
        colorEditU32("Node Hovered Link Highlight", m_workingCopy.imnodes.node_hovered_link_highlight);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 300);
    
    // Draw category color previews
    ImGui::Text("Category Colors:");
    float y = canvasPos.y + 20;
    float boxSize = 20.0f;
    float spacing = 5.0f;
    
    const char* categoryNames[] = {
        "Source", "Effect", "Modulator", "Utility", "Seq", "MIDI",
        "Analysis", "TTS_Voice", "Special_Exp", "OpenCV", "Sys", "Comment", "Plugin", "Default"
    };
    
    ModuleCategory categories[] = {
        ModuleCategory::Source, ModuleCategory::Effect, ModuleCategory::Modulator,
        ModuleCategory::Utility, ModuleCategory::Seq, ModuleCategory::MIDI,
        ModuleCategory::Analysis, ModuleCategory::TTS_Voice, ModuleCategory::Special_Exp,
        ModuleCategory::OpenCV, ModuleCategory::Sys, ModuleCategory::Comment,
        ModuleCategory::Plugin, ModuleCategory::Default
    };
    
    for (int i = 0; i < 14; ++i)
    {
        float x = canvasPos.x + (i % 7) * (boxSize + spacing + 60);
        float rowY = y + (i / 7) * (boxSize + spacing + 15);
        
        ImU32 color = m_workingCopy.imnodes.category_colors[categories[i]];
        drawList->AddRectFilled(ImVec2(x, rowY), ImVec2(x + boxSize, rowY + boxSize), color);
        drawList->AddRect(ImVec2(x, rowY), ImVec2(x + boxSize, rowY + boxSize), IM_COL32(100, 100, 100, 255));
        ImGui::SetCursorScreenPos(ImVec2(x + boxSize + 5, rowY));
        ImGui::Text("%s", categoryNames[i]);
    }
    
    y += 80;
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, y));
    ImGui::Text("Pin Colors:");
    y += 20;
    
    // Draw pin color previews
    const char* pinTypeNames[] = { "CV", "Audio", "Gate", "Raw", "Video" };
    PinDataType pinTypes[] = {
        PinDataType::CV, PinDataType::Audio, PinDataType::Gate,
        PinDataType::Raw, PinDataType::Video
    };
    
    for (int i = 0; i < 5; ++i)
    {
        float x = canvasPos.x + i * 80;
        ImU32 color = m_workingCopy.imnodes.pin_colors[pinTypes[i]];
        
        // Draw pin circle
        ImVec2 center = ImVec2(x + 15, y + 10);
        drawList->AddCircleFilled(center, 8.0f, color, 0);
        drawList->AddCircle(center, 8.0f, IM_COL32(100, 100, 100, 255), 0, 1.0f);
        
        ImGui::SetCursorScreenPos(ImVec2(x, y + 25));
        ImGui::Text("%s", pinTypeNames[i]);
    }
    
    y += 60;
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, y));
    
    // Node muted preview
    ImGui::Text("Node Muted Preview:");
    ImVec2 nodePos = ImVec2(canvasPos.x, y + 20);
    ImVec2 nodeSize = ImVec2(150, 60);
    ImU32 nodeColor = m_workingCopy.imnodes.node_muted;
    ImU32 nodeColorAlpha = IM_COL32(
        (int)((nodeColor & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        (int)(((nodeColor >> 8) & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        (int)(((nodeColor >> 16) & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        255
    );
    drawList->AddRectFilled(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), nodeColorAlpha);
    drawList->AddRect(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), IM_COL32(100, 100, 100, 255));
    ImGui::SetCursorScreenPos(ImVec2(nodePos.x + 5, nodePos.y + 20));
    ImGui::Text("Muted Node");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderLinksTab()
{
    ImGui::Text("Link Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "LinksColumns", true);
    
    // Left: Controls
    colorEditU32("Link Hovered", m_workingCopy.links.link_hovered);
    colorEditU32("Link Selected", m_workingCopy.links.link_selected);
    colorEditU32("Link Highlighted", m_workingCopy.links.link_highlighted);
    colorEditU32("Preview Color", m_workingCopy.links.preview_color);
    dragFloat("Preview Width", m_workingCopy.links.preview_width, 0.1f, 1.0f, 10.0f);
    colorEditU32("Label Background", m_workingCopy.links.label_background);
    colorEditU32("Label Text", m_workingCopy.links.label_text);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    
    // Draw link previews
    float y = canvasPos.y;
    float x = canvasPos.x + 20;
    
    // Hovered link
    ImVec2 p1 = ImVec2(x, y + 20);
    ImVec2 p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_hovered, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Hovered Link");
    
    // Selected link
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_selected, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Selected Link");
    
    // Highlighted link
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_highlighted, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Highlighted Link");
    
    // Preview color
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.preview_color, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Preview Color");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    // Label preview
    ImGui::Text("Link Label Preview:");
    ImVec2 labelPos = ImGui::GetCursorScreenPos();
    ImVec2 labelSize = ImVec2(120, 30);
    drawList->AddRectFilled(labelPos, ImVec2(labelPos.x + labelSize.x, labelPos.y + labelSize.y), 
                           m_workingCopy.links.label_background);
    ImGui::SetCursorScreenPos(ImVec2(labelPos.x + 5, labelPos.y + 8));
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(m_workingCopy.links.label_text));
    ImGui::Text("Link Label");
    ImGui::PopStyleColor();
    ImGui::SetCursorScreenPos(ImVec2(labelPos.x, labelPos.y + labelSize.y + 5));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderCanvasTab()
{
    ImGui::Text("Canvas Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "CanvasColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Canvas Background"))
    {
        colorEditU32("Canvas Background", m_workingCopy.canvas.canvas_background);
    }
    
    if (ImGui::CollapsingHeader("Grid Settings"))
    {
        colorEditU32("Grid Color", m_workingCopy.canvas.grid_color);
        colorEditU32("Grid Origin Color", m_workingCopy.canvas.grid_origin_color);
        dragFloat("Grid Size", m_workingCopy.canvas.grid_size, 1.0f, 10.0f, 200.0f);
        colorEditU32("Scale Text Color", m_workingCopy.canvas.scale_text_color);
        dragFloat("Scale Interval", m_workingCopy.canvas.scale_interval, 10.0f, 50.0f, 1000.0f);
    }
    
    if (ImGui::CollapsingHeader("Overlays & UI"))
    {
        colorEditU32("Drop Target Overlay", m_workingCopy.canvas.drop_target_overlay);
        colorEditU32("Mouse Position Text", m_workingCopy.canvas.mouse_position_text);
    }
    
    if (ImGui::CollapsingHeader("Node Styling"))
    {
        colorEditU32("Node Background", m_workingCopy.canvas.node_background);
        colorEditU32("Node Frame", m_workingCopy.canvas.node_frame);
        colorEditU32("Node Frame Hovered", m_workingCopy.canvas.node_frame_hovered);
        colorEditU32("Node Frame Selected", m_workingCopy.canvas.node_frame_selected);
        dragFloat("Node Rounding", m_workingCopy.canvas.node_rounding, 0.1f, 0.0f, 20.0f);
        dragFloat("Node Border Width", m_workingCopy.canvas.node_border_width, 0.1f, 0.0f, 10.0f);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 300);
    
    // Draw canvas background
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           m_workingCopy.canvas.canvas_background);
    
    // Draw grid preview
    float gridSize = m_workingCopy.canvas.grid_size;
    float scaleInterval = m_workingCopy.canvas.scale_interval;
    
    // Draw grid lines
    for (float x = canvasPos.x; x < canvasPos.x + canvasSize.x; x += gridSize)
    {
        drawList->AddLine(ImVec2(x, canvasPos.y), ImVec2(x, canvasPos.y + canvasSize.y), 
                         m_workingCopy.canvas.grid_color);
    }
    for (float y = canvasPos.y; y < canvasPos.y + canvasSize.y; y += gridSize)
    {
        drawList->AddLine(ImVec2(canvasPos.x, y), ImVec2(canvasPos.x + canvasSize.x, y), 
                         m_workingCopy.canvas.grid_color);
    }
    
    // Draw origin (center)
    ImVec2 center = ImVec2(canvasPos.x + canvasSize.x * 0.5f, canvasPos.y + canvasSize.y * 0.5f);
    drawList->AddCircle(center, 3.0f, m_workingCopy.canvas.grid_origin_color, 0, 2.0f);
    drawList->AddLine(ImVec2(center.x - 10, center.y), ImVec2(center.x + 10, center.y), 
                     m_workingCopy.canvas.grid_origin_color, 2.0f);
    drawList->AddLine(ImVec2(center.x, center.y - 10), ImVec2(center.x, center.y + 10), 
                     m_workingCopy.canvas.grid_origin_color, 2.0f);
    
    // Draw scale markers
    for (float x = canvasPos.x; x < canvasPos.x + canvasSize.x; x += scaleInterval)
    {
        ImVec2 textPos = ImVec2(x, canvasPos.y + 5);
        char label[32];
        snprintf(label, sizeof(label), "%.0f", (x - canvasPos.x));
        drawList->AddText(textPos, m_workingCopy.canvas.scale_text_color, label);
    }
    
    // Draw drop target overlay preview
    ImVec2 dropPos = ImVec2(canvasPos.x + canvasSize.x * 0.3f, canvasPos.y + canvasSize.y * 0.3f);
    ImVec2 dropSize = ImVec2(80, 60);
    drawList->AddRectFilled(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), 
                           m_workingCopy.canvas.drop_target_overlay);
    drawList->AddRect(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), 
                     m_workingCopy.canvas.drop_target_overlay, 0.0f, 0, 2.0f);
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    // Mouse position text preview
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(m_workingCopy.canvas.mouse_position_text));
    ImGui::Text("Mouse: 1234, 567");
    ImGui::PopStyleColor();
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    // Node preview
    ImGui::Text("Node Preview");
    ImVec2 nodePreviewPos = ImGui::GetCursorScreenPos();
    ImVec2 nodeSize = ImVec2(150, 80);
    ImVec2 nodeMin = ImVec2(nodePreviewPos.x + 20, nodePreviewPos.y + 20);
    ImVec2 nodeMax = ImVec2(nodeMin.x + nodeSize.x, nodeMin.y + nodeSize.y);
    
    // Draw node background
    drawList->AddRectFilled(nodeMin, nodeMax, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    
    // Draw node frame (normal state)
    drawList->AddRect(nodeMin, nodeMax, m_workingCopy.canvas.node_frame, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    
    // Draw node title bar
    ImVec2 titleBarMin = nodeMin;
    ImVec2 titleBarMax = ImVec2(nodeMax.x, nodeMin.y + 25);
    drawList->AddRectFilled(titleBarMin, titleBarMax, m_workingCopy.canvas.node_frame, m_workingCopy.canvas.node_rounding);
    
    drawList->AddText(ImVec2(nodeMin.x + 8, nodeMin.y + 5), IM_COL32(255, 255, 255, 255), "Example Node");
    
    // Draw hovered state preview (second node)
    ImVec2 node2Min = ImVec2(nodePreviewPos.x + 200, nodePreviewPos.y + 20);
    ImVec2 node2Max = ImVec2(node2Min.x + nodeSize.x, node2Min.y + nodeSize.y);
    drawList->AddRectFilled(node2Min, node2Max, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    drawList->AddRect(node2Min, node2Max, m_workingCopy.canvas.node_frame_hovered, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    drawList->AddRectFilled(node2Min, ImVec2(node2Max.x, node2Min.y + 25), m_workingCopy.canvas.node_frame_hovered, m_workingCopy.canvas.node_rounding);
    drawList->AddText(ImVec2(node2Min.x + 8, node2Min.y + 5), IM_COL32(255, 255, 255, 255), "Hovered");
    
    // Draw selected state preview (third node)
    ImVec2 node3Min = ImVec2(nodePreviewPos.x + 380, nodePreviewPos.y + 20);
    ImVec2 node3Max = ImVec2(node3Min.x + nodeSize.x, node3Min.y + nodeSize.y);
    drawList->AddRectFilled(node3Min, node3Max, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    drawList->AddRect(node3Min, node3Max, m_workingCopy.canvas.node_frame_selected, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    drawList->AddRectFilled(node3Min, ImVec2(node3Max.x, node3Min.y + 25), m_workingCopy.canvas.node_frame_selected, m_workingCopy.canvas.node_rounding);
    drawList->AddText(ImVec2(node3Min.x + 8, node3Min.y + 5), IM_COL32(255, 255, 255, 255), "Selected");
    
    ImGui::SetCursorScreenPos(ImVec2(nodePreviewPos.x, nodePreviewPos.y + nodeSize.y + 40));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderLayoutTab()
{
    ImGui::Text("Layout Settings");
    ImGui::Separator();
    
    ImGui::Columns(2, "LayoutColumns", true);
    
    // Left: Controls
    dragFloat("Sidebar Width", m_workingCopy.layout.sidebar_width, 1.0f, 100.0f, 500.0f);
    dragFloat("Window Padding", m_workingCopy.layout.window_padding, 1.0f, 0.0f, 50.0f);
    dragFloat("Node Vertical Padding", m_workingCopy.layout.node_vertical_padding, 1.0f, 0.0f, 200.0f);
    dragFloat("Preset Vertical Padding", m_workingCopy.layout.preset_vertical_padding, 1.0f, 0.0f, 300.0f);
    dragFloat("Node Default Width", m_workingCopy.layout.node_default_width, 1.0f, 100.0f, 1000.0f);
    dragFloat2("Node Default Padding", m_workingCopy.layout.node_default_padding, 1.0f, 0.0f, 50.0f);
    dragFloat2("Node Muted Padding", m_workingCopy.layout.node_muted_padding, 1.0f, 0.0f, 50.0f);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 250);
    
    // Draw sidebar
    float sidebarWidth = m_workingCopy.layout.sidebar_width;
    if (sidebarWidth > canvasSize.x * 0.4f) sidebarWidth = canvasSize.x * 0.4f; // Limit for preview
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + sidebarWidth, canvasPos.y + canvasSize.y), 
                           IM_COL32(40, 40, 40, 255));
    drawList->AddLine(ImVec2(canvasPos.x + sidebarWidth, canvasPos.y), 
                     ImVec2(canvasPos.x + sidebarWidth, canvasPos.y + canvasSize.y), 
                     IM_COL32(60, 60, 60, 255), 1.0f);
    
    // Draw main area with padding
    float padding = m_workingCopy.layout.window_padding;
    ImVec2 mainAreaStart = ImVec2(canvasPos.x + sidebarWidth + padding, canvasPos.y + padding);
    ImVec2 mainAreaSize = ImVec2(canvasSize.x - sidebarWidth - padding * 2, canvasSize.y - padding * 2);
    
    // Draw node preview
    float nodeWidth = m_workingCopy.layout.node_default_width;
    if (nodeWidth > mainAreaSize.x * 0.8f) nodeWidth = mainAreaSize.x * 0.8f;
    float nodeHeight = 60.0f;
    ImVec2 nodePos = ImVec2(mainAreaStart.x + m_workingCopy.layout.node_default_padding.x, 
                           mainAreaStart.y + m_workingCopy.layout.node_default_padding.y);
    ImVec2 nodeSize = ImVec2(nodeWidth, nodeHeight);
    
    drawList->AddRectFilled(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), 
                           IM_COL32(50, 50, 50, 255));
    drawList->AddRect(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), 
                     IM_COL32(100, 100, 100, 255), 0.0f, 0, 1.0f);
    
    // Draw second node with vertical padding
    ImVec2 node2Pos = ImVec2(nodePos.x, 
                             nodePos.y + nodeHeight + m_workingCopy.layout.node_vertical_padding);
    drawList->AddRectFilled(node2Pos, ImVec2(node2Pos.x + nodeSize.x, node2Pos.y + nodeSize.y), 
                           IM_COL32(50, 50, 50, 255));
    drawList->AddRect(node2Pos, ImVec2(node2Pos.x + nodeSize.x, node2Pos.y + nodeSize.y), 
                     IM_COL32(100, 100, 100, 255), 0.0f, 0, 1.0f);
    
    // Labels
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x + 5, canvasPos.y + 5));
    ImGui::Text("Sidebar");
    
    ImGui::SetCursorScreenPos(ImVec2(nodePos.x + 5, nodePos.y + 5));
    ImGui::Text("Node");
    
    ImGui::SetCursorScreenPos(ImVec2(node2Pos.x + 5, node2Pos.y + 5));
    ImGui::Text("Node");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    ImGui::Text("Sidebar: %.0fpx | Node Width: %.0fpx | Padding: %.0fpx", 
                m_workingCopy.layout.sidebar_width, 
                m_workingCopy.layout.node_default_width,
                m_workingCopy.layout.window_padding);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderFontsTab()
{
    ImGui::Text("Font Settings");
    ImGui::Separator();
    ImGui::TextWrapped("Select a font from the bundled 'fonts' folder or browse for a custom font. Click 'Apply Changes' to rebuild the font atlas.");

    ImGui::Spacing();

    if (ImGui::CollapsingHeader("Default Font", ImGuiTreeNodeFlags_DefaultOpen))
    {
        ImGui::Text("Scanned Fonts (from 'fonts' folder')");

        juce::String selectionLabel = "<None (ImGui Default)>";
        const juce::String currentPath = m_workingCopy.fonts.default_path;

        if (m_selectedFontIndex >= 0 && m_selectedFontIndex < m_scannedFontFiles.size())
        {
            selectionLabel = juce::File(m_scannedFontFiles[m_selectedFontIndex]).getFileName();
        }
        else if (currentPath.isNotEmpty())
        {
            selectionLabel = juce::File(currentPath).getFileName();
        }

        float availableWidth = ImGui::GetContentRegionAvail().x;
        float comboWidth = availableWidth - 70.0f;
        if (comboWidth < 150.0f)
            comboWidth = availableWidth;

        ImGui::SetNextItemWidth(comboWidth);
        if (ImGui::BeginCombo("##DefaultFontCombo", selectionLabel.toRawUTF8()))
        {
            const bool defaultSelected = (m_selectedFontIndex == -1 && currentPath.isEmpty());
            if (ImGui::Selectable("<None (ImGui Default)>", defaultSelected))
            {
                m_selectedFontIndex = -1;
                m_workingCopy.fonts.default_path.clear();
                m_hasChanges = true;
                previewFontChanges();
            }
            if (defaultSelected)
                ImGui::SetItemDefaultFocus();

            for (int i = 0; i < m_scannedFontFiles.size(); ++i)
            {
                const bool isSelected = (m_selectedFontIndex == i);
                juce::String filename = juce::File(m_scannedFontFiles[i]).getFileName();

                if (ImGui::Selectable(filename.toRawUTF8(), isSelected))
                {
                    m_selectedFontIndex = i;
                    m_workingCopy.fonts.default_path = m_scannedFontFiles[i];
                    m_hasChanges = true;
                    previewFontChanges();
                }

                if (isSelected)
                    ImGui::SetItemDefaultFocus();
            }

            ImGui::EndCombo();
        }

        ImGui::SameLine();
        if (ImGui::Button("Scan"))
        {
            scanFontFolder();
            m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
        }

        ImGui::Spacing();
        if (ImGui::Button("Browse for other font..."))
        {
            auto fontsFolder = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory().getChildFile("fonts");
            juce::File initialDir = fontsFolder.exists() ? fontsFolder : juce::File();
            m_fontChooser = std::make_unique<juce::FileChooser>("Select custom font", initialDir, "*.ttf;*.otf;*.ttc");

            auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;
            m_fontChooser->launchAsync(chooserFlags,
                                       [this](const juce::FileChooser& fc)
                                       {
                                           auto file = fc.getResult();
                                           if (file.existsAsFile())
                                           {
                                               m_workingCopy.fonts.default_path = file.getFullPathName();
                                               m_hasChanges = true;
                                               m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
                                               previewFontChanges();
                                           }
                                       });
        }

        ImGui::Spacing();
        if (dragFloat("Default Font Size", m_workingCopy.fonts.default_size, 0.5f, 8.0f, 72.0f))
        {
            if (ImGui::IsItemDeactivatedAfterEdit())
                previewFontChanges();
        }
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    ImGui::Text("Preview");
    ImGui::BeginChild("FontPreview", ImVec2(0, 200), true);

    const float baseSize = ImGui::GetFontSize();
    const float desiredSize = m_workingCopy.fonts.default_size;
    const float scale = (baseSize > 0.0f) ? (desiredSize / baseSize) : 1.0f;
    ImGui::SetWindowFontScale(scale);

    ImGui::Text("Default Font Size (%.1f):", m_workingCopy.fonts.default_size);
    ImGui::Text("The quick brown fox jumps over the lazy dog.");
    ImGui::Text("0123456789 !@#$%%^&*()");

    ImGui::SetWindowFontScale(1.0f);
    ImGui::EndChild();
}

void ThemeEditorComponent::renderWindowsTab()
{
    ImGui::Text("Window Settings");
    ImGui::Separator();
    
    ImGui::Columns(2, "WindowsColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Window Transparency"))
    {
        // Slider for the main Status Overlay
        if (ImGui::SliderFloat("Status Overlay", &m_workingCopy.windows.status_overlay_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for the 'Status: EDITED' overlay");
        
        // Slider for the Probe Scope
        if (ImGui::SliderFloat("Probe Scope", &m_workingCopy.windows.probe_scope_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for the üî¨ Probe Scope window");
        
        // Slider for Notifications
        if (ImGui::SliderFloat("Notifications", &m_workingCopy.windows.notifications_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for pop-up notifications (Success, Error, etc.)");
        
        // Slider for Preset Status (kept for backward compatibility)
        if (ImGui::SliderFloat("Preset Status", &m_workingCopy.windows.preset_status_alpha, 0.0f, 1.0f, "%.2f"))
        {
            m_hasChanges = true;
        }
        if (ImGui::IsItemHovered()) ImGui::SetTooltip("Transparency for the Preset Status overlay");
    }
    
    if (ImGui::CollapsingHeader("Probe Scope Size"))
    {
        dragFloat("Probe Scope Width", m_workingCopy.windows.probe_scope_width, 1.0f, 100.0f, 500.0f);
        dragFloat("Probe Scope Height", m_workingCopy.windows.probe_scope_height, 1.0f, 50.0f, 500.0f);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 250);
    
    // Draw background
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           IM_COL32(10, 10, 10, 255));
    
    // Status overlay preview
    ImVec2 statusPos = ImVec2(canvasPos.x + 10, canvasPos.y + 10);
    ImVec2 statusSize = ImVec2(150, 40);
    ImU32 statusColor = IM_COL32(255, 255, 255, (int)(m_workingCopy.windows.status_overlay_alpha * 255));
    drawList->AddRectFilled(statusPos, ImVec2(statusPos.x + statusSize.x, statusPos.y + statusSize.y), 
                           statusColor);
    drawList->AddRect(statusPos, ImVec2(statusPos.x + statusSize.x, statusPos.y + statusSize.y), 
                     IM_COL32(200, 200, 200, 255), 0.0f, 0, 1.0f);
    ImGui::SetCursorScreenPos(ImVec2(statusPos.x + 5, statusPos.y + 12));
    ImGui::Text("Status Overlay");
    ImGui::SetCursorScreenPos(ImVec2(statusPos.x, statusPos.y + statusSize.y + 5));
    
    // Probe scope preview
    float scopeWidth = m_workingCopy.windows.probe_scope_width;
    float scopeHeight = m_workingCopy.windows.probe_scope_height;
    if (scopeWidth > canvasSize.x * 0.8f) scopeWidth = canvasSize.x * 0.8f;
    if (scopeHeight > canvasSize.y * 0.5f) scopeHeight = canvasSize.y * 0.5f;
    
    ImVec2 scopePos = ImVec2(canvasPos.x + 10, ImGui::GetCursorScreenPos().y);
    ImVec2 scopeSize = ImVec2(scopeWidth, scopeHeight);
    ImU32 scopeColor = IM_COL32(0, 200, 255, (int)(m_workingCopy.windows.probe_scope_alpha * 255));
    drawList->AddRectFilled(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                           IM_COL32(20, 20, 20, 255));
    drawList->AddRect(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                     scopeColor, 0.0f, 0, 2.0f);
    
    // Draw scope waveform
    for (int i = 0; i < (int)scopeSize.x - 4; i += 2)
    {
        float x = scopePos.x + 2 + i;
        float y = scopePos.y + scopeSize.y * 0.5f + sinf(i * 0.1f) * scopeSize.y * 0.3f;
        drawList->AddLine(ImVec2(x, y), ImVec2(x + 2, y + sinf((i + 2) * 0.1f) * scopeSize.y * 0.3f), 
                         scopeColor, 1.5f);
    }
    
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + 5));
    ImGui::Text("Probe Scope");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    ImGui::Text("Scope: %.0fx%.0fpx | Alpha: %.2f", 
                m_workingCopy.windows.probe_scope_width,
                m_workingCopy.windows.probe_scope_height,
                m_workingCopy.windows.probe_scope_alpha);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderModulationTab()
{
    ImGui::Text("Modulation Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ModulationColumns", true);
    
    // Left: Controls
    colorEdit4("Frequency", m_workingCopy.modulation.frequency);
    colorEdit4("Timbre", m_workingCopy.modulation.timbre);
    colorEdit4("Amplitude", m_workingCopy.modulation.amplitude);
    colorEdit4("Filter", m_workingCopy.modulation.filter);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    
    // Draw waveform previews for each modulation type
    float waveHeight = 30.0f;
    float ySpacing = 40.0f;
    
    // Frequency
    ImVec2 freqStart = ImVec2(canvasPos.x, canvasPos.y);
    ImGui::SetCursorScreenPos(freqStart);
    ImGui::Text("Frequency:");
    for (int i = 0; i < 50; ++i)
    {
        float x = freqStart.x + i * 5.0f;
        float y = freqStart.y + 20.0f + sinf(i * 0.2f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.frequency), 0);
    }
    
    // Timbre
    ImVec2 timbreStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing);
    ImGui::SetCursorScreenPos(timbreStart);
    ImGui::Text("Timbre:");
    for (int i = 0; i < 50; ++i)
    {
        float x = timbreStart.x + i * 5.0f;
        float y = timbreStart.y + 20.0f + sinf(i * 0.15f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.timbre), 0);
    }
    
    // Amplitude
    ImVec2 ampStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing * 2);
    ImGui::SetCursorScreenPos(ampStart);
    ImGui::Text("Amplitude:");
    for (int i = 0; i < 50; ++i)
    {
        float x = ampStart.x + i * 5.0f;
        float y = ampStart.y + 20.0f + sinf(i * 0.3f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.amplitude), 0);
    }
    
    // Filter
    ImVec2 filterStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing * 3);
    ImGui::SetCursorScreenPos(filterStart);
    ImGui::Text("Filter:");
    for (int i = 0; i < 50; ++i)
    {
        float x = filterStart.x + i * 5.0f;
        float y = filterStart.y + 20.0f + sinf(i * 0.1f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.filter), 0);
    }
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderMetersTab()
{
    ImGui::Text("Meter Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "MetersColumns", true);
    
    // Left: Controls
    colorEdit4("Safe", m_workingCopy.meters.safe);
    colorEdit4("Warning", m_workingCopy.meters.warning);
    colorEdit4("Clipping", m_workingCopy.meters.clipping);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    
    // Draw meter bars
    float meterWidth = ImGui::GetContentRegionAvail().x;
    float meterHeight = 20.0f;
    float spacing = 5.0f;
    
    // Safe level meter
    ImVec2 safePos = canvasPos;
    float safeLevel = 0.6f; // 60% full
    drawList->AddRectFilled(safePos, ImVec2(safePos.x + meterWidth, safePos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(safePos, ImVec2(safePos.x + meterWidth * safeLevel, safePos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    ImGui::SetCursorScreenPos(ImVec2(safePos.x, safePos.y));
    ImGui::Text("Safe (60%):");
    ImGui::SetCursorScreenPos(ImVec2(safePos.x, safePos.y + meterHeight + spacing));
    
    // Warning level meter
    ImVec2 warnPos = ImGui::GetCursorScreenPos();
    float warnLevel = 0.85f; // 85% full
    drawList->AddRectFilled(warnPos, ImVec2(warnPos.x + meterWidth, warnPos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(warnPos, ImVec2(warnPos.x + meterWidth * 0.8f, warnPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    drawList->AddRectFilled(ImVec2(warnPos.x + meterWidth * 0.8f, warnPos.y), 
                           ImVec2(warnPos.x + meterWidth * warnLevel, warnPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.warning));
    ImGui::SetCursorScreenPos(ImVec2(warnPos.x, warnPos.y));
    ImGui::Text("Warning (85%):");
    ImGui::SetCursorScreenPos(ImVec2(warnPos.x, warnPos.y + meterHeight + spacing));
    
    // Clipping level meter
    ImVec2 clipPos = ImGui::GetCursorScreenPos();
    float clipLevel = 1.0f; // 100% full (clipping)
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + meterWidth, clipPos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + meterWidth * 0.8f, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    drawList->AddRectFilled(ImVec2(clipPos.x + meterWidth * 0.8f, clipPos.y), 
                           ImVec2(clipPos.x + meterWidth * 0.95f, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.warning));
    drawList->AddRectFilled(ImVec2(clipPos.x + meterWidth * 0.95f, clipPos.y), 
                           ImVec2(clipPos.x + meterWidth * clipLevel, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.clipping));
    ImGui::SetCursorScreenPos(ImVec2(clipPos.x, clipPos.y));
    ImGui::Text("Clipping (100%):");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderTimelineTab()
{
    ImGui::Text("Timeline Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "TimelineColumns", true);
    
    // Left: Controls
    colorEditU32("Marker Start/End", m_workingCopy.timeline.marker_start_end);
    colorEditU32("Marker Gate", m_workingCopy.timeline.marker_gate);
    colorEditU32("Marker Trigger", m_workingCopy.timeline.marker_trigger);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 150);
    
    // Draw timeline preview
    float timelineHeight = 40.0f;
    ImVec2 timelineStart = ImVec2(canvasPos.x, canvasPos.y + 20);
    
    // Draw timeline background
    drawList->AddRectFilled(timelineStart, 
                           ImVec2(timelineStart.x + canvasSize.x, timelineStart.y + timelineHeight), 
                           IM_COL32(20, 20, 20, 255));
    
    // Draw markers
    // Start marker
    ImVec2 startMarker = ImVec2(timelineStart.x + 20, timelineStart.y);
    drawList->AddLine(ImVec2(startMarker.x, startMarker.y), 
                     ImVec2(startMarker.x, startMarker.y + timelineHeight), 
                     m_workingCopy.timeline.marker_start_end, 3.0f);
    drawList->AddTriangleFilled(ImVec2(startMarker.x, startMarker.y), 
                                ImVec2(startMarker.x - 5, startMarker.y - 8), 
                                ImVec2(startMarker.x + 5, startMarker.y - 8), 
                                m_workingCopy.timeline.marker_start_end);
    ImGui::SetCursorScreenPos(ImVec2(startMarker.x - 10, startMarker.y - 20));
    ImGui::Text("Start");
    
    // End marker
    ImVec2 endMarker = ImVec2(timelineStart.x + canvasSize.x - 20, timelineStart.y);
    drawList->AddLine(ImVec2(endMarker.x, endMarker.y), 
                     ImVec2(endMarker.x, endMarker.y + timelineHeight), 
                     m_workingCopy.timeline.marker_start_end, 3.0f);
    drawList->AddTriangleFilled(ImVec2(endMarker.x, endMarker.y), 
                                ImVec2(endMarker.x - 5, endMarker.y - 8), 
                                ImVec2(endMarker.x + 5, endMarker.y - 8), 
                                m_workingCopy.timeline.marker_start_end);
    ImGui::SetCursorScreenPos(ImVec2(endMarker.x - 10, endMarker.y - 20));
    ImGui::Text("End");
    
    // Gate markers
    float gateY = timelineStart.y + timelineHeight * 0.3f;
    for (int i = 0; i < 3; ++i)
    {
        float x = timelineStart.x + 60 + i * 40;
        drawList->AddRectFilled(ImVec2(x, gateY), ImVec2(x + 20, gateY + 15), 
                               m_workingCopy.timeline.marker_gate);
    }
    ImGui::SetCursorScreenPos(ImVec2(timelineStart.x + 60, gateY - 15));
    ImGui::Text("Gates");
    
    // Trigger markers
    float triggerY = timelineStart.y + timelineHeight * 0.7f;
    for (int i = 0; i < 5; ++i)
    {
        float x = timelineStart.x + 80 + i * 25;
        drawList->AddLine(ImVec2(x, triggerY), ImVec2(x, triggerY + 10), 
                         m_workingCopy.timeline.marker_trigger, 2.0f);
    }
    ImGui::SetCursorScreenPos(ImVec2(timelineStart.x + 80, triggerY - 15));
    ImGui::Text("Triggers");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderModulesTab()
{
    ImGui::Text("Module-Specific Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ModulesColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("VideoFX Module"))
    {
        colorEdit4("Section Header", m_workingCopy.modules.videofx_section_header);
        colorEdit4("Section Subheader", m_workingCopy.modules.videofx_section_subheader);
    }
    
    if (ImGui::CollapsingHeader("Scope Module"))
    {
        colorEdit4("Section Header", m_workingCopy.modules.scope_section_header);
        colorEditU32("Plot Background", m_workingCopy.modules.scope_plot_bg);
        colorEditU32("Plot Foreground", m_workingCopy.modules.scope_plot_fg);
        colorEditU32("Plot Max", m_workingCopy.modules.scope_plot_max);
        colorEditU32("Plot Min", m_workingCopy.modules.scope_plot_min);
        colorEdit4("Text Max", m_workingCopy.modules.scope_text_max);
        colorEdit4("Text Min", m_workingCopy.modules.scope_text_min);
    }
    
    if (ImGui::CollapsingHeader("Stroke Sequencer"))
    {
        colorEditU32("Border", m_workingCopy.modules.stroke_seq_border);
        colorEditU32("Canvas Background", m_workingCopy.modules.stroke_seq_canvas_bg);
        colorEditU32("Line Inactive", m_workingCopy.modules.stroke_seq_line_inactive);
        colorEditU32("Line Active", m_workingCopy.modules.stroke_seq_line_active);
        colorEditU32("Playhead", m_workingCopy.modules.stroke_seq_playhead);
        colorEditU32("Threshold Floor", m_workingCopy.modules.stroke_seq_thresh_floor);
        colorEditU32("Threshold Mid", m_workingCopy.modules.stroke_seq_thresh_mid);
        colorEditU32("Threshold Ceil", m_workingCopy.modules.stroke_seq_thresh_ceil);
        colorEdit4("Frame Background", m_workingCopy.modules.stroke_seq_frame_bg);
        colorEdit4("Frame Hovered", m_workingCopy.modules.stroke_seq_frame_bg_hovered);
        colorEdit4("Frame Active", m_workingCopy.modules.stroke_seq_frame_bg_active);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    
    // VideoFX Preview
    ImGui::TextColored(m_workingCopy.modules.videofx_section_header, "VideoFX Section Header");
    ImGui::TextColored(m_workingCopy.modules.videofx_section_subheader, "VideoFX Section Subheader");
    ImGui::Spacing();
    
    // Scope Preview
    ImGui::TextColored(m_workingCopy.modules.scope_section_header, "Scope Section Header");
    ImVec2 scopePos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 10);
    ImVec2 scopeSize = ImVec2(200, 100);
    
    // Draw scope background
    drawList->AddRectFilled(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                           m_workingCopy.modules.scope_plot_bg);
    drawList->AddRect(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                     IM_COL32(100, 100, 100, 255));
    
    // Draw scope waveform
    for (int i = 0; i < (int)scopeSize.x - 4; i += 2)
    {
        float x = scopePos.x + 2 + i;
        float y = scopePos.y + scopeSize.y * 0.5f + sinf(i * 0.1f) * scopeSize.y * 0.3f;
        drawList->AddLine(ImVec2(x, y), ImVec2(x + 2, y + sinf((i + 2) * 0.1f) * scopeSize.y * 0.3f), 
                         m_workingCopy.modules.scope_plot_fg, 1.5f);
    }
    
    // Draw max/min markers
    drawList->AddLine(ImVec2(scopePos.x + 5, scopePos.y + 5), 
                     ImVec2(scopePos.x + scopeSize.x - 5, scopePos.y + 5), 
                     m_workingCopy.modules.scope_plot_max, 2.0f);
    drawList->AddLine(ImVec2(scopePos.x + 5, scopePos.y + scopeSize.y - 5), 
                     ImVec2(scopePos.x + scopeSize.x - 5, scopePos.y + scopeSize.y - 5), 
                     m_workingCopy.modules.scope_plot_min, 2.0f);
    
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + 5));
    ImGui::TextColored(m_workingCopy.modules.scope_text_max, "MAX");
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + scopeSize.y - 20));
    ImGui::TextColored(m_workingCopy.modules.scope_text_min, "MIN");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, scopePos.y + scopeSize.y + 20));
    ImGui::Spacing();
    
    // Stroke Sequencer Preview
    ImGui::Text("Stroke Sequencer Preview:");
    ImVec2 seqPos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 5);
    ImVec2 seqSize = ImVec2(250, 120);
    
    // Draw canvas background
    drawList->AddRectFilled(seqPos, ImVec2(seqPos.x + seqSize.x, seqPos.y + seqSize.y), 
                           m_workingCopy.modules.stroke_seq_canvas_bg);
    drawList->AddRect(seqPos, ImVec2(seqPos.x + seqSize.x, seqPos.y + seqSize.y), 
                     m_workingCopy.modules.stroke_seq_border, 0.0f, 0, 2.0f);
    
    // Draw lines
    float lineY = seqPos.y + 20;
    for (int i = 0; i < 5; ++i)
    {
        float x1 = seqPos.x + 10 + i * 20;
        float x2 = seqPos.x + 10 + (i + 1) * 20;
        ImU32 lineColor = (i == 2) ? m_workingCopy.modules.stroke_seq_line_active : 
                                     m_workingCopy.modules.stroke_seq_line_inactive;
        drawList->AddLine(ImVec2(x1, lineY + i * 15), ImVec2(x2, lineY + i * 15), lineColor, 2.0f);
    }
    
    // Draw playhead
    float playheadX = seqPos.x + 100;
    drawList->AddLine(ImVec2(playheadX, seqPos.y), ImVec2(playheadX, seqPos.y + seqSize.y), 
                     m_workingCopy.modules.stroke_seq_playhead, 2.0f);
    
    // Draw threshold markers
    float threshY1 = seqPos.y + seqSize.y * 0.3f;
    float threshY2 = seqPos.y + seqSize.y * 0.5f;
    float threshY3 = seqPos.y + seqSize.y * 0.7f;
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY1), ImVec2(seqPos.x + seqSize.x - 5, threshY1), 
                     m_workingCopy.modules.stroke_seq_thresh_floor, 1.0f);
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY2), ImVec2(seqPos.x + seqSize.x - 5, threshY2), 
                     m_workingCopy.modules.stroke_seq_thresh_mid, 1.0f);
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY3), ImVec2(seqPos.x + seqSize.x - 5, threshY3), 
                     m_workingCopy.modules.stroke_seq_thresh_ceil, 1.0f);
    
    // Draw frame preview
    ImVec2 framePos = ImVec2(seqPos.x + seqSize.x - 60, seqPos.y + 10);
    ImVec2 frameSize = ImVec2(50, 30);
    drawList->AddRectFilled(framePos, ImVec2(framePos.x + frameSize.x, framePos.y + frameSize.y), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.modules.stroke_seq_frame_bg));
    drawList->AddRect(framePos, ImVec2(framePos.x + frameSize.x, framePos.y + frameSize.y), 
                     IM_COL32(100, 100, 100, 255));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderSaveDialog()
{
    ImGui::OpenPopup("Save Theme");
    if (ImGui::BeginPopupModal("Save Theme", nullptr, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("Enter theme name:");
        ImGui::InputText("##ThemeName", m_saveThemeName, sizeof(m_saveThemeName));
        
        ImGui::Separator();
        
        if (ImGui::Button("Save"))
        {
            saveThemeAs();
            m_showSaveDialog = false;
            ImGui::CloseCurrentPopup();
        }
        ImGui::SameLine();
        if (ImGui::Button("Cancel"))
        {
            m_showSaveDialog = false;
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
}

void ThemeEditorComponent::saveTheme()
{
    // Save to current theme file (if one exists)
    if (m_currentThemeFilename.isEmpty())
    {
        // No current theme file, should use Save As instead
        juce::Logger::writeToLog("[ThemeEditor] Cannot save: no current theme file. Use 'Save As...' instead.");
        return;
    }
    
    // Find the current theme file
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    auto themesDir = exeDir.getChildFile("themes");
    auto themeFile = themesDir.getChildFile(m_currentThemeFilename);
    
    // Also check source tree as fallback
    if (!themeFile.existsAsFile())
    {
        auto sourceThemesDir = exeDir.getParentDirectory().getParentDirectory()
            .getChildFile("Source")
            .getChildFile("preset_creator")
            .getChildFile("theme")
            .getChildFile("presets");
        themeFile = sourceThemesDir.getChildFile(m_currentThemeFilename);
    }
    
    if (!themeFile.existsAsFile())
    {
        juce::Logger::writeToLog("[ThemeEditor] ERROR: Current theme file not found: " + m_currentThemeFilename);
        return;
    }
    
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    if (ThemeManager::getInstance().saveTheme(themeFile))
    {
        juce::Logger::writeToLog("[ThemeEditor] Saved theme to: " + themeFile.getFullPathName());
        m_hasChanges = false;
    }
    else
    {
        juce::Logger::writeToLog("[ThemeEditor] ERROR saving theme: " + themeFile.getFullPathName());
    }
}

void ThemeEditorComponent::saveThemeAs()
{
    juce::String themeName(m_saveThemeName);
    if (themeName.isEmpty())
    {
        return;
    }
    
    themeName = themeName.replaceCharacter(' ', '_');
    
    // Save to exe/themes folder
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    auto themesDir = exeDir.getChildFile("themes");
    themesDir.createDirectory();
    auto themeFile = themesDir.getChildFile(themeName + ".json");
    
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    if (ThemeManager::getInstance().saveTheme(themeFile))
    {
        juce::Logger::writeToLog("[ThemeEditor] Saved theme to: " + themeFile.getFullPathName());
        // Update current theme filename
        m_currentThemeFilename = themeFile.getFileName();
        // Persist as last-used
        ThemeManager::getInstance().saveUserThemePreference(themeFile.getFileName());
        m_hasChanges = false;
    }
    else
    {
        juce::Logger::writeToLog("[ThemeEditor] ERROR saving theme: " + themeFile.getFullPathName());
    }
}

void ThemeEditorComponent::resetCurrentTab()
{
    // TODO: Reset current tab to default values
    // For now, just reload from current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_hasChanges = false;
}

void ThemeEditorComponent::applyChanges()
{
    // Apply working copy to ThemeManager
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    ThemeManager::getInstance().applyTheme();
	ThemeManager::getInstance().requestFontReload();
    m_hasChanges = false;
    juce::Logger::writeToLog("[ThemeEditor] Applied theme changes");
    
    // Also save user preference if they want persistence
    // (Theme preference is saved when selecting from menu, not when editing)
}

void ThemeEditorComponent::syncFontBuffersFromWorkingCopy()
{
    const std::string defaultPath = m_workingCopy.fonts.default_path.toStdString();
    std::snprintf(m_defaultFontPathBuffer.data(), m_defaultFontPathBuffer.size(), "%s", defaultPath.c_str());
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::previewFontChanges()
{
    auto& liveFonts = ThemeManager::getInstance().getEditableTheme().fonts;
    liveFonts.default_path = m_workingCopy.fonts.default_path;
    liveFonts.default_size = m_workingCopy.fonts.default_size;
    ThemeManager::getInstance().requestFontReload();
    m_selectedFontIndex = findScannedFontIndex(m_workingCopy.fonts.default_path);
}

void ThemeEditorComponent::scanFontFolder()
{
    m_scannedFontFiles.clear();

    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    auto fontsDir = exeDir.getChildFile("fonts");

    juce::Logger::writeToLog("[ThemeEditor] Scanning for fonts in: " + fontsDir.getFullPathName());

    if (fontsDir.isDirectory())
    {
        auto addFontsForPattern = [this, &fontsDir, &exeDir](const juce::String& pattern)
        {
            juce::Array<juce::File> files;
            fontsDir.findChildFiles(files, juce::File::findFiles, false, pattern);
            for (const auto& file : files)
            {
                const juce::String relativePath = file.getRelativePathFrom(exeDir);
                if (!m_scannedFontFiles.contains(relativePath))
                    m_scannedFontFiles.add(relativePath);
            }
        };

        addFontsForPattern("*.ttf");
        addFontsForPattern("*.otf");
        addFontsForPattern("*.ttc");
    }

    m_scannedFontFiles.sort(true);
    juce::Logger::writeToLog("[ThemeEditor] Found " + juce::String(m_scannedFontFiles.size()) + " font files.");
}

int ThemeEditorComponent::findScannedFontIndex(const juce::String& path) const
{
    if (path.isEmpty())
        return -1;

    const juce::String normalised = resolveFontPath(path).getFullPathName();

    for (int i = 0; i < m_scannedFontFiles.size(); ++i)
    {
        if (resolveFontPath(m_scannedFontFiles[i]).getFullPathName() == normalised)
            return i;
    }
    return -1;
}



================================================================================
FILE: juce\Source\preset_creator\theme\ThemeManager.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <imgui.h>
#include <atomic>
#include <cmath>
#include "Theme.h"

class ThemeManager
{
public:
	static ThemeManager& getInstance();

	bool loadTheme(const juce::File& themeFile);
	bool saveTheme(const juce::File& themeFile);
	void applyTheme();
	void resetToDefault();
	void applyFonts(ImGuiIO& io);
	void requestFontReload();
	bool consumeFontReloadRequest();
	void rebuildFontsNow();
	
	// Persistence
	void saveUserThemePreference(const juce::String& themeFilename);
	bool loadUserThemePreference();

	const Theme& getCurrentTheme() const;
	Theme& getEditableTheme();  // For theme editor - returns mutable reference
	juce::String getCurrentThemeFilename() const { return m_currentThemeFilename; }  // Get filename of currently loaded theme

	// Colors
	ImU32 getCategoryColor(ModuleCategory cat, bool hovered = false);
	ImU32 getPinColor(PinDataType type);
	ImU32 getPinConnectedColor();
	ImU32 getPinDisconnectedColor();
	ImU32 getCategoryColor(ModuleCategory category) const;

	// Layout
	float getSidebarWidth() const;
	float getNodeDefaultWidth() const;
	float getWindowPadding() const;
	
	// Canvas
	ImU32 getCanvasBackground() const;
	ImU32 getGridColor() const;
	ImU32 getGridOriginColor() const;
	float getGridSize() const;
	ImU32 getScaleTextColor() const;
	float getScaleInterval() const;
	ImU32 getDropTargetOverlay() const;
	ImU32 getMousePositionText() const;
	ImU32 getSelectionRect() const;
	ImU32 getSelectionRectOutline() const;
	
	// Node styling
	ImU32 getNodeBackground() const;
	ImU32 getNodeFrame() const;
	ImU32 getNodeFrameHovered() const;
	ImU32 getNodeFrameSelected() const;
	float getNodeRounding() const;
	float getNodeBorderWidth() const;

private:
	ThemeManager();
	~ThemeManager() = default;
	ThemeManager(const ThemeManager&) = delete;
	ThemeManager& operator=(const ThemeManager&) = delete;
	ThemeManager(ThemeManager&&) = delete;
	ThemeManager& operator=(ThemeManager&&) = delete;

	void loadDefaultTheme();
	void applyImGuiStyle();

	// JSON helpers
	static juce::var colorToVar(ImU32 c);
	static ImU32 varToColor(const juce::var& v, ImU32 fallback);
	static juce::var vec4ToVar(const ImVec4& v);
	static ImVec4 varToVec4(const juce::var& v, const ImVec4& fallback);

	static juce::String moduleCategoryToString(ModuleCategory c);
	static bool stringToModuleCategory(const juce::String& s, ModuleCategory& out);
	static juce::String pinTypeToString(PinDataType t);
	static bool stringToPinType(const juce::String& s, PinDataType& out);

	Theme currentTheme;
	Theme defaultTheme;
	juce::String m_currentThemeFilename;  // Filename of currently loaded theme (empty if default)

	std::atomic<bool> fontReloadPending { false };
};

/**
 * A theme-aware replacement for ImGui::TextColored.
 * It automatically applies a text glow/shadow if enabled in the theme.
 */
inline void ThemeText(const char* text, ImVec4 color)
{
	const auto& theme = ThemeManager::getInstance().getCurrentTheme();

	if (theme.text.enable_text_glow)
	{
		// --- DRAW GLOW/SHADOW ---
		// Get the current cursor, draw the shadows offset,
		// then reset the cursor to draw the main text on top.
		
		ImVec2 pos = ImGui::GetCursorPos();
		ImVec4 glowColor = theme.text.text_glow_color;

		ImGui::PushStyleColor(ImGuiCol_Text, glowColor);
		
		// Draw 4 shadow layers for a soft "glow" effect.
		// We must use ImGui::TextUnformatted and handle newlines
		// manually to prevent formatting issues with ImGui::Text.
		ImGui::SetCursorPos(ImVec2(pos.x - 1, pos.y)); ImGui::TextUnformatted(text);
		ImGui::SetCursorPos(ImVec2(pos.x + 1, pos.y)); ImGui::TextUnformatted(text);
		ImGui::SetCursorPos(ImVec2(pos.x, pos.y - 1)); ImGui::TextUnformatted(text);
		ImGui::SetCursorPos(ImVec2(pos.x, pos.y + 1)); ImGui::TextUnformatted(text);

		ImGui::PopStyleColor();

		// Reset cursor to the original position
		ImGui::SetCursorPos(pos);
	}
	
	// --- DRAW MAIN TEXT ---
	// This draws the main text and advances the cursor normally.
	ImGui::PushStyleColor(ImGuiCol_Text, color);
	ImGui::TextUnformatted(text); // Use TextUnformatted for consistency
	ImGui::PopStyleColor();
}

/**
 * Overload for non-colored text (uses default theme text color)
 */
inline void ThemeText(const char* text)
{
	// Get the default text color from ImGui style settings
	ImVec4 defaultColor = ImGui::GetStyle().Colors[ImGuiCol_Text];
	ThemeText(text, defaultColor);
}

/**
 * Utility functions for automatic text color adjustment based on background luminance.
 * Implements WCAG 2.1 relative luminance calculation for accessibility.
 */
namespace ThemeUtils
{
	/**
	 * Calculate relative luminance of a color using WCAG 2.1 formula.
	 * Returns a value between 0.0 (black) and 1.0 (white).
	 * 
	 * @param color ImU32 color in format IM_COL32(R, G, B, A)
	 * @return Relative luminance (0.0 = darkest, 1.0 = lightest)
	 */
	inline float calculateRelativeLuminance(ImU32 color)
	{
		// Extract RGB components (ImU32 is typically ARGB or RGBA depending on endianness)
		// ImGui uses IM_COL32(R, G, B, A) which creates RGBA format
		ImVec4 rgba = ImGui::ColorConvertU32ToFloat4(color);
		
		// Convert sRGB to linear RGB (gamma correction)
		auto toLinear = [](float c) -> float
		{
			if (c <= 0.04045f)
				return c / 12.92f;
			return std::pow((c + 0.055f) / 1.055f, 2.4f);
		};
		
		float r = toLinear(rgba.x);
		float g = toLinear(rgba.y);
		float b = toLinear(rgba.z);
		
		// Calculate relative luminance using WCAG 2.1 coefficients
		// These weights account for human eye sensitivity to different colors
		return 0.2126f * r + 0.7152f * g + 0.0722f * b;
	}
	
	/**
	 * Calculate contrast ratio between two colors using WCAG 2.1 formula.
	 * Returns a value >= 1.0, where higher values indicate better contrast.
	 * WCAG AA requires 4.5:1 for normal text, 3:1 for large text.
	 * 
	 * @param color1 First color (lighter should be first for accurate ratio)
	 * @param color2 Second color (darker should be second)
	 * @return Contrast ratio (1.0 = no contrast, 21.0 = maximum contrast)
	 */
	inline float calculateContrastRatio(ImU32 color1, ImU32 color2)
	{
		float l1 = calculateRelativeLuminance(color1);
		float l2 = calculateRelativeLuminance(color2);
		
		// Ensure lighter color is first
		if (l1 < l2)
		{
			float temp = l1;
			l1 = l2;
			l2 = temp;
		}
		
		// WCAG contrast ratio formula: (L1 + 0.05) / (L2 + 0.05)
		return (l1 + 0.05f) / (l2 + 0.05f);
	}
	
	/**
	 * Get optimal text color (black or white) for a given background color.
	 * Uses contrast ratio calculation to ensure WCAG-compliant legibility.
	 * Chooses the text color (black or white) that provides the best contrast.
	 * 
	 * @param backgroundColor Background color in ImU32 format
	 * @param minContrast Minimum contrast ratio required (default 4.5 for WCAG AA)
	 * @return IM_COL32(0, 0, 0, 255) for black text, IM_COL32(255, 255, 255, 255) for white text
	 */
	inline ImU32 getOptimalTextColor(ImU32 backgroundColor, float minContrast = 4.5f)
	{
		// Define pure black and white
		const ImU32 blackText = IM_COL32(0, 0, 0, 255);
		const ImU32 whiteText = IM_COL32(255, 255, 255, 255);
		
		// Calculate contrast ratios for both text color options
		// calculateContrastRatio ensures lighter color is first, so order doesn't matter
		float contrastWithBlack = calculateContrastRatio(backgroundColor, blackText);
		float contrastWithWhite = calculateContrastRatio(whiteText, backgroundColor);
		
		// Choose the option with better contrast
		// This handles edge cases like bright yellow where white text has poor contrast
		if (contrastWithBlack >= contrastWithWhite)
		{
			// Black text provides better or equal contrast
			// This will be chosen for light backgrounds (yellow, light green, etc.)
			return blackText;
		}
		else
		{
			// White text provides better contrast
			// This will be chosen for dark backgrounds
			return whiteText;
		}
	}
}




================================================================================
FILE: juce\Source\preset_creator\theme\ThemeManager.cpp
================================================================================


#include "ThemeManager.h"

#include <imgui.h>
#include <imnodes.h>
#include <backends/imgui_impl_opengl2.h>
#include <map>

// Singleton
ThemeManager& ThemeManager::getInstance()
{
	static ThemeManager instance;
	return instance;
}

ThemeManager::ThemeManager()
{
	loadDefaultTheme();
	currentTheme = defaultTheme;
	m_currentThemeFilename = juce::String();  // Default theme has no filename
}

void ThemeManager::applyTheme()
{
	applyImGuiStyle();

	// Apply accent to common ImGui colors
	ImVec4 acc = currentTheme.accent;
	ImGuiStyle& st = ImGui::GetStyle();
	st.Colors[ImGuiCol_CheckMark] = acc;
	st.Colors[ImGuiCol_SliderGrabActive] = acc;
	st.Colors[ImGuiCol_TextSelectedBg] = ImVec4(acc.x, acc.y, acc.z, 0.35f);
	st.Colors[ImGuiCol_DragDropTarget] = ImVec4(acc.x, acc.y, acc.z, 0.95f);
	st.Colors[ImGuiCol_SeparatorHovered] = ImVec4(acc.x, acc.y, acc.z, 0.9f);
	st.Colors[ImGuiCol_TabHovered] = ImVec4(acc.x, acc.y, acc.z, 0.8f);
	st.Colors[ImGuiCol_ButtonHovered] = ImVec4(acc.x, acc.y, acc.z, 1.0f);
	
	// Note: ImNodes style properties are set in newOpenGLContextCreated() after ImNodes context is created
	// ImNodes colors are applied per-draw via PushColorStyle
}

void ThemeManager::requestFontReload()
{
	fontReloadPending.store(true, std::memory_order_relaxed);
}

bool ThemeManager::consumeFontReloadRequest()
{
	return fontReloadPending.exchange(false, std::memory_order_acq_rel);
}

void ThemeManager::rebuildFontsNow()
{
	if (ImGui::GetCurrentContext() == nullptr)
		return;

	ImGuiIO& io = ImGui::GetIO();
	applyFonts(io);
}

void ThemeManager::resetToDefault()
{
	currentTheme = defaultTheme;
	m_currentThemeFilename = juce::String();  // Clear filename when using default
	applyTheme();
	requestFontReload();
}

const Theme& ThemeManager::getCurrentTheme() const
{
	return currentTheme;
}

Theme& ThemeManager::getEditableTheme()
{
	return currentTheme;
}

ImU32 ThemeManager::getCategoryColor(ModuleCategory cat, bool hovered)
{
	auto it = currentTheme.imnodes.category_colors.find(cat);
	ImU32 base = (it != currentTheme.imnodes.category_colors.end())
		? it->second
		: IM_COL32(70, 70, 70, 255);

	if (hovered)
	{
		ImVec4 c = ImGui::ColorConvertU32ToFloat4(base);
		c.x = juce::jmin(c.x * 1.3f, 1.0f);
		c.y = juce::jmin(c.y * 1.3f, 1.0f);
		c.z = juce::jmin(c.z * 1.3f, 1.0f);
		return ImGui::ColorConvertFloat4ToU32(c);
	}
	return base;
}

ImU32 ThemeManager::getPinColor(PinDataType type)
{
	auto it = currentTheme.imnodes.pin_colors.find(type);
	if (it != currentTheme.imnodes.pin_colors.end())
		return it->second;
	return IM_COL32(150, 150, 150, 255);
}

ImU32 ThemeManager::getPinConnectedColor()
{
	return currentTheme.imnodes.pin_connected;
}

ImU32 ThemeManager::getPinDisconnectedColor()
{
	return currentTheme.imnodes.pin_disconnected;
}

ImU32 ThemeManager::getCategoryColor(ModuleCategory category) const
{
	if (auto it = currentTheme.imnodes.category_colors.find(category); it != currentTheme.imnodes.category_colors.end())
		return it->second;
	if (auto fallback = currentTheme.imnodes.category_colors.find(ModuleCategory::Default); fallback != currentTheme.imnodes.category_colors.end())
		return fallback->second;
	return IM_COL32(70, 70, 70, 255);
}

float ThemeManager::getSidebarWidth() const
{
	return currentTheme.layout.sidebar_width;
}

float ThemeManager::getNodeDefaultWidth() const
{
	return currentTheme.layout.node_default_width;
}

float ThemeManager::getWindowPadding() const
{
	return currentTheme.layout.window_padding;
}

// Canvas getters
ImU32 ThemeManager::getCanvasBackground() const
{
	return currentTheme.canvas.canvas_background;
}

ImU32 ThemeManager::getGridColor() const
{
	return currentTheme.canvas.grid_color;
}

ImU32 ThemeManager::getGridOriginColor() const
{
	return currentTheme.canvas.grid_origin_color;
}

float ThemeManager::getGridSize() const
{
	return currentTheme.canvas.grid_size;
}

ImU32 ThemeManager::getScaleTextColor() const
{
	return currentTheme.canvas.scale_text_color;
}

float ThemeManager::getScaleInterval() const
{
	return currentTheme.canvas.scale_interval;
}

ImU32 ThemeManager::getDropTargetOverlay() const
{
	return currentTheme.canvas.drop_target_overlay;
}

ImU32 ThemeManager::getMousePositionText() const
{
	return currentTheme.canvas.mouse_position_text;
}

ImU32 ThemeManager::getSelectionRect() const
{
	return currentTheme.canvas.selection_rect;
}

ImU32 ThemeManager::getSelectionRectOutline() const
{
	return currentTheme.canvas.selection_rect_outline;
}

// Node styling getters
ImU32 ThemeManager::getNodeBackground() const
{
	return currentTheme.canvas.node_background;
}

ImU32 ThemeManager::getNodeFrame() const
{
	return currentTheme.canvas.node_frame;
}

ImU32 ThemeManager::getNodeFrameHovered() const
{
	return currentTheme.canvas.node_frame_hovered;
}

ImU32 ThemeManager::getNodeFrameSelected() const
{
	return currentTheme.canvas.node_frame_selected;
}

float ThemeManager::getNodeRounding() const
{
	return currentTheme.canvas.node_rounding;
}

float ThemeManager::getNodeBorderWidth() const
{
	return currentTheme.canvas.node_border_width;
}

// JSON save/load (Phase 5)
bool ThemeManager::loadTheme(const juce::File& themeFile)
{
	if (!themeFile.existsAsFile())
		return false;
	juce::var parsed = juce::JSON::parse(themeFile);
	if (parsed.isVoid() || !parsed.isObject())
		return false;
	auto* root = parsed.getDynamicObject();
	Theme t = defaultTheme; // start from defaults

	// Load ImGui style from JSON
	if (auto styleVar = root->getProperty("style"); styleVar.isObject())
	{
		auto* styleObj = styleVar.getDynamicObject();
		
		// Load style properties
		auto loadVec2 = [&](const char* name, ImVec2& dst)
		{
			if (auto v = styleObj->getProperty(name); v.isArray())
			{
				auto* arr = v.getArray();
				if (arr->size() >= 2)
					dst = ImVec2((float) arr->getReference(0), (float) arr->getReference(1));
			}
		};
		
		auto loadFloat = [&](const char* name, float& dst)
		{
			if (styleObj->hasProperty(name))
				dst = (float) styleObj->getProperty(name);
		};
		
		loadVec2("WindowPadding", t.style.WindowPadding);
		loadVec2("FramePadding", t.style.FramePadding);
		loadVec2("ItemSpacing", t.style.ItemSpacing);
		loadVec2("ItemInnerSpacing", t.style.ItemInnerSpacing);
		loadFloat("WindowRounding", t.style.WindowRounding);
		loadFloat("ChildRounding", t.style.ChildRounding);
		loadFloat("FrameRounding", t.style.FrameRounding);
		loadFloat("PopupRounding", t.style.PopupRounding);
		loadFloat("ScrollbarRounding", t.style.ScrollbarRounding);
		loadFloat("GrabRounding", t.style.GrabRounding);
		loadFloat("TabRounding", t.style.TabRounding);
		loadFloat("WindowBorderSize", t.style.WindowBorderSize);
		loadFloat("FrameBorderSize", t.style.FrameBorderSize);
		loadFloat("PopupBorderSize", t.style.PopupBorderSize);
		
		// Load ImGui colors - map string names to ImGuiCol enum
		if (auto colorsVar = styleObj->getProperty("Colors"); colorsVar.isObject())
		{
			auto* colorsObj = colorsVar.getDynamicObject();
			static std::map<juce::String, ImGuiCol> colorMap = {
				{ "Text", ImGuiCol_Text }, { "TextDisabled", ImGuiCol_TextDisabled },
				{ "WindowBg", ImGuiCol_WindowBg }, { "ChildBg", ImGuiCol_ChildBg },
				{ "PopupBg", ImGuiCol_PopupBg }, { "Border", ImGuiCol_Border },
				{ "BorderShadow", ImGuiCol_BorderShadow }, { "FrameBg", ImGuiCol_FrameBg },
				{ "FrameBgHovered", ImGuiCol_FrameBgHovered }, { "FrameBgActive", ImGuiCol_FrameBgActive },
				{ "TitleBg", ImGuiCol_TitleBg }, { "TitleBgActive", ImGuiCol_TitleBgActive },
				{ "TitleBgCollapsed", ImGuiCol_TitleBgCollapsed }, { "MenuBarBg", ImGuiCol_MenuBarBg },
				{ "ScrollbarBg", ImGuiCol_ScrollbarBg }, { "ScrollbarGrab", ImGuiCol_ScrollbarGrab },
				{ "ScrollbarGrabHovered", ImGuiCol_ScrollbarGrabHovered }, { "ScrollbarGrabActive", ImGuiCol_ScrollbarGrabActive },
				{ "CheckMark", ImGuiCol_CheckMark }, { "SliderGrab", ImGuiCol_SliderGrab },
				{ "SliderGrabActive", ImGuiCol_SliderGrabActive }, { "Button", ImGuiCol_Button },
				{ "ButtonHovered", ImGuiCol_ButtonHovered }, { "ButtonActive", ImGuiCol_ButtonActive },
				{ "Header", ImGuiCol_Header }, { "HeaderHovered", ImGuiCol_HeaderHovered },
				{ "HeaderActive", ImGuiCol_HeaderActive }, { "Separator", ImGuiCol_Separator },
				{ "SeparatorHovered", ImGuiCol_SeparatorHovered }, { "SeparatorActive", ImGuiCol_SeparatorActive },
				{ "ResizeGrip", ImGuiCol_ResizeGrip }, { "ResizeGripHovered", ImGuiCol_ResizeGripHovered },
				{ "ResizeGripActive", ImGuiCol_ResizeGripActive }, { "Tab", ImGuiCol_Tab },
				{ "TabHovered", ImGuiCol_TabHovered }, { "TabActive", ImGuiCol_TabActive },
				{ "TabUnfocused", ImGuiCol_TabUnfocused }, { "TabUnfocusedActive", ImGuiCol_TabUnfocusedActive },
				{ "PlotLines", ImGuiCol_PlotLines }, { "PlotLinesHovered", ImGuiCol_PlotLinesHovered },
				{ "PlotHistogram", ImGuiCol_PlotHistogram }, { "PlotHistogramHovered", ImGuiCol_PlotHistogramHovered },
				{ "TableHeaderBg", ImGuiCol_TableHeaderBg }, { "TableBorderStrong", ImGuiCol_TableBorderStrong },
				{ "TableBorderLight", ImGuiCol_TableBorderLight }, { "TableRowBg", ImGuiCol_TableRowBg },
				{ "TableRowBgAlt", ImGuiCol_TableRowBgAlt }, { "TextSelectedBg", ImGuiCol_TextSelectedBg },
				{ "DragDropTarget", ImGuiCol_DragDropTarget }, { "NavHighlight", ImGuiCol_NavHighlight },
				{ "NavWindowingHighlight", ImGuiCol_NavWindowingHighlight }, { "NavWindowingDimBg", ImGuiCol_NavWindowingDimBg },
				{ "ModalWindowDimBg", ImGuiCol_ModalWindowDimBg }
			};
			
			for (auto& prop : colorsObj->getProperties())
			{
				auto it = colorMap.find(prop.name.toString());
				if (it != colorMap.end())
				{
					t.style.Colors[it->second] = varToVec4(prop.value, t.style.Colors[it->second]);
				}
			}
		}
	}

	// accent
	if (auto v = root->getProperty("accent"); v.isArray())
	{
		t.accent = varToVec4(v, t.accent);
	}

	// text
	if (auto v = root->getProperty("text"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.text.section_header = varToVec4(o->getProperty("section_header"), t.text.section_header);
		t.text.warning = varToVec4(o->getProperty("warning"), t.text.warning);
		t.text.success = varToVec4(o->getProperty("success"), t.text.success);
		t.text.error = varToVec4(o->getProperty("error"), t.text.error);
		t.text.disabled = varToVec4(o->getProperty("disabled"), t.text.disabled);
		t.text.active = varToVec4(o->getProperty("active"), t.text.active);
		// Floats with default fallbacks
		if (o->hasProperty("tooltip_wrap_standard")) t.text.tooltip_wrap_standard = (float) o->getProperty("tooltip_wrap_standard");
		if (o->hasProperty("tooltip_wrap_compact"))  t.text.tooltip_wrap_compact  = (float) o->getProperty("tooltip_wrap_compact");
		// Text glow settings
		if (o->hasProperty("enable_text_glow")) t.text.enable_text_glow = (bool) o->getProperty("enable_text_glow");
		t.text.text_glow_color = varToVec4(o->getProperty("text_glow_color"), t.text.text_glow_color);
	}

	// status
	if (auto v = root->getProperty("status"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.status.edited = varToVec4(o->getProperty("edited"), t.status.edited);
		t.status.saved = varToVec4(o->getProperty("saved"), t.status.saved);
	}

	// headers (TriState)
	if (auto v = root->getProperty("headers"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		auto loadTri = [&](const char* name, TriStateColor& dst)
		{
			if (auto* h = o->getProperty(name).getDynamicObject())
			{
				dst.base = varToColor(h->getProperty("base"), dst.base);
				dst.hovered = varToColor(h->getProperty("hovered"), dst.hovered);
				dst.active = varToColor(h->getProperty("active"), dst.active);
			}
		};
		loadTri("recent", t.headers.recent);
		loadTri("samples", t.headers.samples);
		loadTri("presets", t.headers.presets);
		loadTri("system", t.headers.system);
	}

	// imnodes.category_colors
	if (auto v = root->getProperty("imnodes"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		if (auto cats = o->getProperty("category_colors"); cats.isObject())
		{
			auto* m = cats.getDynamicObject();
			for (auto& p : m->getProperties())
			{
				ModuleCategory catEnum;
				bool ok = stringToModuleCategory(p.name.toString(), catEnum);
				if (!ok)
				{
					int id = p.name.toString().getIntValue();
					catEnum = (ModuleCategory) id;
					ok = true;
				}
				if (ok)
					t.imnodes.category_colors[catEnum] = varToColor(p.value, t.imnodes.category_colors[catEnum]);
			}
		}
		if (auto pins = o->getProperty("pin_colors"); pins.isObject())
		{
			auto* m = pins.getDynamicObject();
			for (auto& p : m->getProperties())
			{
				PinDataType tp;
				bool ok = stringToPinType(p.name.toString(), tp);
				if (!ok)
				{
					int id = p.name.toString().getIntValue();
					tp = (PinDataType) id;
					ok = true;
				}
				if (ok)
					t.imnodes.pin_colors[tp] = varToColor(p.value, t.imnodes.pin_colors[tp]);
			}
		}
		t.imnodes.pin_connected = varToColor(o->getProperty("pin_connected"), t.imnodes.pin_connected);
		t.imnodes.pin_disconnected = varToColor(o->getProperty("pin_disconnected"), t.imnodes.pin_disconnected);
		t.imnodes.node_muted = varToColor(o->getProperty("node_muted"), t.imnodes.node_muted);
		t.imnodes.node_muted_alpha = o->hasProperty("node_muted_alpha") ? (float) o->getProperty("node_muted_alpha") : t.imnodes.node_muted_alpha;
		t.imnodes.node_hovered_link_highlight = varToColor(o->getProperty("node_hovered_link_highlight"), t.imnodes.node_hovered_link_highlight);
	}

	// links
	if (auto v = root->getProperty("links"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.links.link_hovered = varToColor(o->getProperty("link_hovered"), t.links.link_hovered);
		t.links.link_selected = varToColor(o->getProperty("link_selected"), t.links.link_selected);
		t.links.link_highlighted = varToColor(o->getProperty("link_highlighted"), t.links.link_highlighted);
		t.links.preview_color = varToColor(o->getProperty("preview_color"), t.links.preview_color);
		t.links.preview_width = o->hasProperty("preview_width") ? (float) o->getProperty("preview_width") : t.links.preview_width;
		t.links.label_background = varToColor(o->getProperty("label_background"), t.links.label_background);
		t.links.label_text = varToColor(o->getProperty("label_text"), t.links.label_text);
	}

	// canvas
	if (auto v = root->getProperty("canvas"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.canvas.canvas_background = varToColor(o->getProperty("canvas_background"), t.canvas.canvas_background);
		t.canvas.grid_color = varToColor(o->getProperty("grid_color"), t.canvas.grid_color);
		t.canvas.grid_origin_color = varToColor(o->getProperty("grid_origin_color"), t.canvas.grid_origin_color);
		t.canvas.grid_size = o->hasProperty("grid_size") ? (float) o->getProperty("grid_size") : t.canvas.grid_size;
		t.canvas.scale_text_color = varToColor(o->getProperty("scale_text_color"), t.canvas.scale_text_color);
		t.canvas.scale_interval = o->hasProperty("scale_interval") ? (float) o->getProperty("scale_interval") : t.canvas.scale_interval;
		t.canvas.drop_target_overlay = varToColor(o->getProperty("drop_target_overlay"), t.canvas.drop_target_overlay);
		t.canvas.mouse_position_text = varToColor(o->getProperty("mouse_position_text"), t.canvas.mouse_position_text);
		t.canvas.node_background = varToColor(o->getProperty("node_background"), t.canvas.node_background);
		t.canvas.node_frame = varToColor(o->getProperty("node_frame"), t.canvas.node_frame);
		t.canvas.node_frame_hovered = varToColor(o->getProperty("node_frame_hovered"), t.canvas.node_frame_hovered);
		t.canvas.node_frame_selected = varToColor(o->getProperty("node_frame_selected"), t.canvas.node_frame_selected);
		t.canvas.node_rounding = o->hasProperty("node_rounding") ? (float) o->getProperty("node_rounding") : t.canvas.node_rounding;
		t.canvas.node_border_width = o->hasProperty("node_border_width") ? (float) o->getProperty("node_border_width") : t.canvas.node_border_width;
		t.canvas.selection_rect = varToColor(o->getProperty("selection_rect"), t.canvas.selection_rect);
		t.canvas.selection_rect_outline = varToColor(o->getProperty("selection_rect_outline"), t.canvas.selection_rect_outline);
	}

	// layout
	if (auto v = root->getProperty("layout"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		// layout floats
		if (o->hasProperty("sidebar_width"))          t.layout.sidebar_width = (float) o->getProperty("sidebar_width");
		if (o->hasProperty("window_padding"))         t.layout.window_padding = (float) o->getProperty("window_padding");
		if (o->hasProperty("node_vertical_padding"))  t.layout.node_vertical_padding = (float) o->getProperty("node_vertical_padding");
		if (o->hasProperty("preset_vertical_padding"))t.layout.preset_vertical_padding = (float) o->getProperty("preset_vertical_padding");
		if (o->hasProperty("node_default_width"))    t.layout.node_default_width = (float) o->getProperty("node_default_width");
		if (auto pad = o->getProperty("node_default_padding"); pad.isArray())
		{
			auto* a = pad.getArray();
			if (a->size() >= 2) t.layout.node_default_padding = ImVec2((float) a->getReference(0), (float) a->getReference(1));
		}
		if (auto padm = o->getProperty("node_muted_padding"); padm.isArray())
		{
			auto* a = padm.getArray();
			if (a->size() >= 2) t.layout.node_muted_padding = ImVec2((float) a->getReference(0), (float) a->getReference(1));
		}
	}

	// fonts
	if (auto v = root->getProperty("fonts"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		if (o->hasProperty("default_size"))  t.fonts.default_size = (float) o->getProperty("default_size");
		if (o->hasProperty("default_path"))  t.fonts.default_path = o->getProperty("default_path");
	}

	// windows
	if (auto v = root->getProperty("windows"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		if (o->hasProperty("status_overlay_alpha"))  t.windows.status_overlay_alpha = (float) o->getProperty("status_overlay_alpha");
		if (o->hasProperty("probe_scope_alpha"))     t.windows.probe_scope_alpha = (float) o->getProperty("probe_scope_alpha");
		if (o->hasProperty("preset_status_alpha"))   t.windows.preset_status_alpha = (float) o->getProperty("preset_status_alpha");
		if (o->hasProperty("notifications_alpha"))   t.windows.notifications_alpha = (float) o->getProperty("notifications_alpha");
		if (o->hasProperty("probe_scope_width"))     t.windows.probe_scope_width = (float) o->getProperty("probe_scope_width");
		if (o->hasProperty("probe_scope_height"))    t.windows.probe_scope_height = (float) o->getProperty("probe_scope_height");
	}

	// modulation
	if (auto v = root->getProperty("modulation"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.modulation.frequency = varToVec4(o->getProperty("frequency"), t.modulation.frequency);
		t.modulation.timbre = varToVec4(o->getProperty("timbre"), t.modulation.timbre);
		t.modulation.amplitude = varToVec4(o->getProperty("amplitude"), t.modulation.amplitude);
		t.modulation.filter = varToVec4(o->getProperty("filter"), t.modulation.filter);
	}

	// meters
	if (auto v = root->getProperty("meters"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.meters.safe = varToVec4(o->getProperty("safe"), t.meters.safe);
		t.meters.warning = varToVec4(o->getProperty("warning"), t.meters.warning);
		t.meters.clipping = varToVec4(o->getProperty("clipping"), t.meters.clipping);
	}

	// timeline
	if (auto v = root->getProperty("timeline"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.timeline.marker_start_end = varToColor(o->getProperty("marker_start_end"), t.timeline.marker_start_end);
		t.timeline.marker_gate = varToColor(o->getProperty("marker_gate"), t.timeline.marker_gate);
		t.timeline.marker_trigger = varToColor(o->getProperty("marker_trigger"), t.timeline.marker_trigger);
	}

	// modules
	if (auto v = root->getProperty("modules"); v.isObject())
	{
		auto* o = v.getDynamicObject();
		t.modules.videofx_section_header = varToVec4(o->getProperty("videofx_section_header"), t.modules.videofx_section_header);
		t.modules.videofx_section_subheader = varToVec4(o->getProperty("videofx_section_subheader"), t.modules.videofx_section_subheader);
		t.modules.scope_section_header = varToVec4(o->getProperty("scope_section_header"), t.modules.scope_section_header);
		t.modules.sequencer_section_header = varToVec4(o->getProperty("sequencer_section_header"), t.modules.sequencer_section_header);
		t.modules.sequencer_step_active_frame = varToVec4(o->getProperty("sequencer_step_active_frame"), t.modules.sequencer_step_active_frame);
		t.modules.sequencer_step_active_grab = varToVec4(o->getProperty("sequencer_step_active_grab"), t.modules.sequencer_step_active_grab);
		t.modules.sequencer_gate_active_frame = varToVec4(o->getProperty("sequencer_gate_active_frame"), t.modules.sequencer_gate_active_frame);
		t.modules.sequencer_threshold_line = varToColor(o->getProperty("sequencer_threshold_line"), t.modules.sequencer_threshold_line);
		t.modules.scope_plot_bg = varToColor(o->getProperty("scope_plot_bg"), t.modules.scope_plot_bg);
		t.modules.scope_plot_fg = varToColor(o->getProperty("scope_plot_fg"), t.modules.scope_plot_fg);
		t.modules.scope_plot_max = varToColor(o->getProperty("scope_plot_max"), t.modules.scope_plot_max);
		t.modules.scope_plot_min = varToColor(o->getProperty("scope_plot_min"), t.modules.scope_plot_min);
		t.modules.scope_text_max = varToVec4(o->getProperty("scope_text_max"), t.modules.scope_text_max);
		t.modules.scope_text_min = varToVec4(o->getProperty("scope_text_min"), t.modules.scope_text_min);
		t.modules.stroke_seq_border = varToColor(o->getProperty("stroke_seq_border"), t.modules.stroke_seq_border);
		t.modules.stroke_seq_canvas_bg = varToColor(o->getProperty("stroke_seq_canvas_bg"), t.modules.stroke_seq_canvas_bg);
		t.modules.stroke_seq_line_inactive = varToColor(o->getProperty("stroke_seq_line_inactive"), t.modules.stroke_seq_line_inactive);
		t.modules.stroke_seq_line_active = varToColor(o->getProperty("stroke_seq_line_active"), t.modules.stroke_seq_line_active);
		t.modules.stroke_seq_playhead = varToColor(o->getProperty("stroke_seq_playhead"), t.modules.stroke_seq_playhead);
		t.modules.stroke_seq_thresh_floor = varToColor(o->getProperty("stroke_seq_thresh_floor"), t.modules.stroke_seq_thresh_floor);
		t.modules.stroke_seq_thresh_mid = varToColor(o->getProperty("stroke_seq_thresh_mid"), t.modules.stroke_seq_thresh_mid);
		t.modules.stroke_seq_thresh_ceil = varToColor(o->getProperty("stroke_seq_thresh_ceil"), t.modules.stroke_seq_thresh_ceil);
		t.modules.stroke_seq_frame_bg = varToVec4(o->getProperty("stroke_seq_frame_bg"), t.modules.stroke_seq_frame_bg);
		t.modules.stroke_seq_frame_bg_hovered = varToVec4(o->getProperty("stroke_seq_frame_bg_hovered"), t.modules.stroke_seq_frame_bg_hovered);
		t.modules.stroke_seq_frame_bg_active = varToVec4(o->getProperty("stroke_seq_frame_bg_active"), t.modules.stroke_seq_frame_bg_active);
		if (auto freqVar = o->getProperty("frequency_graph"); freqVar.isObject())
		{
			auto* freqObj = freqVar.getDynamicObject();
			t.modules.frequency_graph.background = varToColor(freqObj->getProperty("background"), t.modules.frequency_graph.background);
			t.modules.frequency_graph.grid = varToColor(freqObj->getProperty("grid"), t.modules.frequency_graph.grid);
			t.modules.frequency_graph.label = varToColor(freqObj->getProperty("label"), t.modules.frequency_graph.label);
			t.modules.frequency_graph.peak_line = varToColor(freqObj->getProperty("peak_line"), t.modules.frequency_graph.peak_line);
			t.modules.frequency_graph.live_line = varToColor(freqObj->getProperty("live_line"), t.modules.frequency_graph.live_line);
			t.modules.frequency_graph.border = varToColor(freqObj->getProperty("border"), t.modules.frequency_graph.border);
			t.modules.frequency_graph.threshold = varToColor(freqObj->getProperty("threshold"), t.modules.frequency_graph.threshold);
		}
		if (auto physVar = o->getProperty("physics"); physVar.isObject())
		{
			auto* physObj = physVar.getDynamicObject();
			t.modules.physics.sandbox_title = varToVec4(physObj->getProperty("sandbox_title"), t.modules.physics.sandbox_title);
			t.modules.physics.stroke_label = varToVec4(physObj->getProperty("stroke_label"), t.modules.physics.stroke_label);
			t.modules.physics.physics_section = varToVec4(physObj->getProperty("physics_section"), t.modules.physics.physics_section);
			t.modules.physics.spawn_section = varToVec4(physObj->getProperty("spawn_section"), t.modules.physics.spawn_section);
			t.modules.physics.count_ok = varToVec4(physObj->getProperty("count_ok"), t.modules.physics.count_ok);
			t.modules.physics.count_warn = varToVec4(physObj->getProperty("count_warn"), t.modules.physics.count_warn);
			t.modules.physics.count_alert = varToVec4(physObj->getProperty("count_alert"), t.modules.physics.count_alert);
			t.modules.physics.stroke_metal = varToVec4(physObj->getProperty("stroke_metal"), t.modules.physics.stroke_metal);
			t.modules.physics.stroke_wood = varToVec4(physObj->getProperty("stroke_wood"), t.modules.physics.stroke_wood);
			t.modules.physics.stroke_soil = varToVec4(physObj->getProperty("stroke_soil"), t.modules.physics.stroke_soil);
			t.modules.physics.stroke_conveyor = varToVec4(physObj->getProperty("stroke_conveyor"), t.modules.physics.stroke_conveyor);
			t.modules.physics.stroke_bouncy = varToVec4(physObj->getProperty("stroke_bouncy"), t.modules.physics.stroke_bouncy);
			t.modules.physics.stroke_sticky = varToVec4(physObj->getProperty("stroke_sticky"), t.modules.physics.stroke_sticky);
			t.modules.physics.stroke_emitter = varToVec4(physObj->getProperty("stroke_emitter"), t.modules.physics.stroke_emitter);
			t.modules.physics.spawn_ball = varToVec4(physObj->getProperty("spawn_ball"), t.modules.physics.spawn_ball);
			t.modules.physics.spawn_square = varToVec4(physObj->getProperty("spawn_square"), t.modules.physics.spawn_square);
			t.modules.physics.spawn_triangle = varToVec4(physObj->getProperty("spawn_triangle"), t.modules.physics.spawn_triangle);
			t.modules.physics.spawn_vortex = varToVec4(physObj->getProperty("spawn_vortex"), t.modules.physics.spawn_vortex);
			t.modules.physics.spawn_clear = varToVec4(physObj->getProperty("spawn_clear"), t.modules.physics.spawn_clear);
			t.modules.physics.spawn_clear_hover = varToVec4(physObj->getProperty("spawn_clear_hover"), t.modules.physics.spawn_clear_hover);
			t.modules.physics.spawn_clear_active = varToVec4(physObj->getProperty("spawn_clear_active"), t.modules.physics.spawn_clear_active);
			t.modules.physics.canvas_background = varToVec4(physObj->getProperty("canvas_background"), t.modules.physics.canvas_background);
			t.modules.physics.canvas_border = varToVec4(physObj->getProperty("canvas_border"), t.modules.physics.canvas_border);
			t.modules.physics.drag_indicator_fill = varToVec4(physObj->getProperty("drag_indicator_fill"), t.modules.physics.drag_indicator_fill);
			t.modules.physics.drag_indicator_outline = varToVec4(physObj->getProperty("drag_indicator_outline"), t.modules.physics.drag_indicator_outline);
			t.modules.physics.eraser_fill = varToVec4(physObj->getProperty("eraser_fill"), t.modules.physics.eraser_fill);
			t.modules.physics.eraser_outline = varToVec4(physObj->getProperty("eraser_outline"), t.modules.physics.eraser_outline);
			t.modules.physics.crosshair_idle = varToVec4(physObj->getProperty("crosshair_idle"), t.modules.physics.crosshair_idle);
			t.modules.physics.crosshair_active = varToVec4(physObj->getProperty("crosshair_active"), t.modules.physics.crosshair_active);
			t.modules.physics.magnet_north = varToVec4(physObj->getProperty("magnet_north"), t.modules.physics.magnet_north);
			t.modules.physics.magnet_south = varToVec4(physObj->getProperty("magnet_south"), t.modules.physics.magnet_south);
			t.modules.physics.magnet_link = varToVec4(physObj->getProperty("magnet_link"), t.modules.physics.magnet_link);
			t.modules.physics.vector_outline = varToVec4(physObj->getProperty("vector_outline"), t.modules.physics.vector_outline);
			t.modules.physics.vector_fill = varToVec4(physObj->getProperty("vector_fill"), t.modules.physics.vector_fill);
			t.modules.physics.soil_detail = varToVec4(physObj->getProperty("soil_detail"), t.modules.physics.soil_detail);
			t.modules.physics.overlay_text = varToVec4(physObj->getProperty("overlay_text"), t.modules.physics.overlay_text);
			t.modules.physics.overlay_line = varToVec4(physObj->getProperty("overlay_line"), t.modules.physics.overlay_line);
			t.modules.physics.separator_line = varToVec4(physObj->getProperty("separator_line"), t.modules.physics.separator_line);
		}
	}

	currentTheme = t;
	m_currentThemeFilename = themeFile.getFileName();  // Store the filename
	applyTheme();
	return true;
}

bool ThemeManager::saveTheme(const juce::File& themeFile)
{
	juce::DynamicObject::Ptr root = new juce::DynamicObject();
	
	// ImGui style (padding, rounding, borders, etc.)
	{
		juce::DynamicObject::Ptr styleObj = new juce::DynamicObject();
		styleObj->setProperty("WindowPadding", vec4ToVar(ImVec4(currentTheme.style.WindowPadding.x, currentTheme.style.WindowPadding.y, 0, 0)));
		styleObj->setProperty("FramePadding", vec4ToVar(ImVec4(currentTheme.style.FramePadding.x, currentTheme.style.FramePadding.y, 0, 0)));
		styleObj->setProperty("ItemSpacing", vec4ToVar(ImVec4(currentTheme.style.ItemSpacing.x, currentTheme.style.ItemSpacing.y, 0, 0)));
		styleObj->setProperty("ItemInnerSpacing", vec4ToVar(ImVec4(currentTheme.style.ItemInnerSpacing.x, currentTheme.style.ItemInnerSpacing.y, 0, 0)));
		styleObj->setProperty("WindowRounding", currentTheme.style.WindowRounding);
		styleObj->setProperty("ChildRounding", currentTheme.style.ChildRounding);
		styleObj->setProperty("FrameRounding", currentTheme.style.FrameRounding);
		styleObj->setProperty("PopupRounding", currentTheme.style.PopupRounding);
		styleObj->setProperty("ScrollbarRounding", currentTheme.style.ScrollbarRounding);
		styleObj->setProperty("GrabRounding", currentTheme.style.GrabRounding);
		styleObj->setProperty("TabRounding", currentTheme.style.TabRounding);
		styleObj->setProperty("WindowBorderSize", currentTheme.style.WindowBorderSize);
		styleObj->setProperty("FrameBorderSize", currentTheme.style.FrameBorderSize);
		styleObj->setProperty("PopupBorderSize", currentTheme.style.PopupBorderSize);
		
		// Save ImGui colors - map ImGuiCol enum to string names
		juce::DynamicObject::Ptr colorsObj = new juce::DynamicObject();
		static std::map<ImGuiCol, juce::String> colorMap = {
			{ ImGuiCol_Text, "Text" }, { ImGuiCol_TextDisabled, "TextDisabled" },
			{ ImGuiCol_WindowBg, "WindowBg" }, { ImGuiCol_ChildBg, "ChildBg" },
			{ ImGuiCol_PopupBg, "PopupBg" }, { ImGuiCol_Border, "Border" },
			{ ImGuiCol_BorderShadow, "BorderShadow" }, { ImGuiCol_FrameBg, "FrameBg" },
			{ ImGuiCol_FrameBgHovered, "FrameBgHovered" }, { ImGuiCol_FrameBgActive, "FrameBgActive" },
			{ ImGuiCol_TitleBg, "TitleBg" }, { ImGuiCol_TitleBgActive, "TitleBgActive" },
			{ ImGuiCol_TitleBgCollapsed, "TitleBgCollapsed" }, { ImGuiCol_MenuBarBg, "MenuBarBg" },
			{ ImGuiCol_ScrollbarBg, "ScrollbarBg" }, { ImGuiCol_ScrollbarGrab, "ScrollbarGrab" },
			{ ImGuiCol_ScrollbarGrabHovered, "ScrollbarGrabHovered" }, { ImGuiCol_ScrollbarGrabActive, "ScrollbarGrabActive" },
			{ ImGuiCol_CheckMark, "CheckMark" }, { ImGuiCol_SliderGrab, "SliderGrab" },
			{ ImGuiCol_SliderGrabActive, "SliderGrabActive" }, { ImGuiCol_Button, "Button" },
			{ ImGuiCol_ButtonHovered, "ButtonHovered" }, { ImGuiCol_ButtonActive, "ButtonActive" },
			{ ImGuiCol_Header, "Header" }, { ImGuiCol_HeaderHovered, "HeaderHovered" },
			{ ImGuiCol_HeaderActive, "HeaderActive" }, { ImGuiCol_Separator, "Separator" },
			{ ImGuiCol_SeparatorHovered, "SeparatorHovered" }, { ImGuiCol_SeparatorActive, "SeparatorActive" },
			{ ImGuiCol_ResizeGrip, "ResizeGrip" }, { ImGuiCol_ResizeGripHovered, "ResizeGripHovered" },
			{ ImGuiCol_ResizeGripActive, "ResizeGripActive" }, { ImGuiCol_Tab, "Tab" },
			{ ImGuiCol_TabHovered, "TabHovered" }, { ImGuiCol_TabActive, "TabActive" },
			{ ImGuiCol_TabUnfocused, "TabUnfocused" }, { ImGuiCol_TabUnfocusedActive, "TabUnfocusedActive" },
			{ ImGuiCol_PlotLines, "PlotLines" }, { ImGuiCol_PlotLinesHovered, "PlotLinesHovered" },
			{ ImGuiCol_PlotHistogram, "PlotHistogram" }, { ImGuiCol_PlotHistogramHovered, "PlotHistogramHovered" },
			{ ImGuiCol_TableHeaderBg, "TableHeaderBg" }, { ImGuiCol_TableBorderStrong, "TableBorderStrong" },
			{ ImGuiCol_TableBorderLight, "TableBorderLight" }, { ImGuiCol_TableRowBg, "TableRowBg" },
			{ ImGuiCol_TableRowBgAlt, "TableRowBgAlt" }, { ImGuiCol_TextSelectedBg, "TextSelectedBg" },
			{ ImGuiCol_DragDropTarget, "DragDropTarget" }, { ImGuiCol_NavHighlight, "NavHighlight" },
			{ ImGuiCol_NavWindowingHighlight, "NavWindowingHighlight" }, { ImGuiCol_NavWindowingDimBg, "NavWindowingDimBg" },
			{ ImGuiCol_ModalWindowDimBg, "ModalWindowDimBg" }
		};
		
		for (auto& pair : colorMap)
		{
			colorsObj->setProperty(pair.second, vec4ToVar(currentTheme.style.Colors[pair.first]));
		}
		
		styleObj->setProperty("Colors", juce::var(colorsObj.get()));
		root->setProperty("style", juce::var(styleObj.get()));
	}
	
	// headers
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		auto putTri = [&](const char* name, const TriStateColor& tsc)
		{
			juce::DynamicObject::Ptr h = new juce::DynamicObject();
			h->setProperty("base", colorToVar(tsc.base));
			h->setProperty("hovered", colorToVar(tsc.hovered));
			h->setProperty("active", colorToVar(tsc.active));
			o->setProperty(name, juce::var(h.get()));
		};
		putTri("recent", currentTheme.headers.recent);
		putTri("samples", currentTheme.headers.samples);
		putTri("presets", currentTheme.headers.presets);
		putTri("system", currentTheme.headers.system);
		root->setProperty("headers", juce::var(o.get()));
	}

	// text
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("section_header", vec4ToVar(currentTheme.text.section_header));
		o->setProperty("warning", vec4ToVar(currentTheme.text.warning));
		o->setProperty("success", vec4ToVar(currentTheme.text.success));
		o->setProperty("error", vec4ToVar(currentTheme.text.error));
		o->setProperty("disabled", vec4ToVar(currentTheme.text.disabled));
		o->setProperty("active", vec4ToVar(currentTheme.text.active));
		o->setProperty("tooltip_wrap_standard", currentTheme.text.tooltip_wrap_standard);
		o->setProperty("tooltip_wrap_compact", currentTheme.text.tooltip_wrap_compact);
		o->setProperty("enable_text_glow", currentTheme.text.enable_text_glow);
		o->setProperty("text_glow_color", vec4ToVar(currentTheme.text.text_glow_color));
		root->setProperty("text", juce::var(o.get()));
	}

	// accent
	root->setProperty("accent", vec4ToVar(currentTheme.accent));

	// status
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("edited", vec4ToVar(currentTheme.status.edited));
		o->setProperty("saved", vec4ToVar(currentTheme.status.saved));
		root->setProperty("status", juce::var(o.get()));
	}

	// imnodes
	{
		juce::DynamicObject::Ptr imn = new juce::DynamicObject();
		juce::DynamicObject::Ptr cats = new juce::DynamicObject();
		for (auto& kv : currentTheme.imnodes.category_colors)
			cats->setProperty(moduleCategoryToString(kv.first), colorToVar(kv.second));
		imn->setProperty("category_colors", juce::var(cats.get()));

		juce::DynamicObject::Ptr pins = new juce::DynamicObject();
		for (auto& kv : currentTheme.imnodes.pin_colors)
			pins->setProperty(pinTypeToString(kv.first), colorToVar(kv.second));
		imn->setProperty("pin_colors", juce::var(pins.get()));

		imn->setProperty("pin_connected", colorToVar(currentTheme.imnodes.pin_connected));
		imn->setProperty("pin_disconnected", colorToVar(currentTheme.imnodes.pin_disconnected));
		imn->setProperty("node_muted", colorToVar(currentTheme.imnodes.node_muted));
		imn->setProperty("node_muted_alpha", currentTheme.imnodes.node_muted_alpha);
		imn->setProperty("node_hovered_link_highlight", colorToVar(currentTheme.imnodes.node_hovered_link_highlight));
		root->setProperty("imnodes", juce::var(imn.get()));
	}

	// links
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("link_hovered", colorToVar(currentTheme.links.link_hovered));
		o->setProperty("link_selected", colorToVar(currentTheme.links.link_selected));
		o->setProperty("link_highlighted", colorToVar(currentTheme.links.link_highlighted));
		o->setProperty("preview_color", colorToVar(currentTheme.links.preview_color));
		o->setProperty("preview_width", currentTheme.links.preview_width);
		o->setProperty("label_background", colorToVar(currentTheme.links.label_background));
		o->setProperty("label_text", colorToVar(currentTheme.links.label_text));
		root->setProperty("links", juce::var(o.get()));
	}

	// canvas
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("canvas_background", colorToVar(currentTheme.canvas.canvas_background));
		o->setProperty("grid_color", colorToVar(currentTheme.canvas.grid_color));
		o->setProperty("grid_origin_color", colorToVar(currentTheme.canvas.grid_origin_color));
		o->setProperty("grid_size", currentTheme.canvas.grid_size);
		o->setProperty("scale_text_color", colorToVar(currentTheme.canvas.scale_text_color));
		o->setProperty("scale_interval", currentTheme.canvas.scale_interval);
		o->setProperty("drop_target_overlay", colorToVar(currentTheme.canvas.drop_target_overlay));
		o->setProperty("mouse_position_text", colorToVar(currentTheme.canvas.mouse_position_text));
		o->setProperty("node_background", colorToVar(currentTheme.canvas.node_background));
		o->setProperty("node_frame", colorToVar(currentTheme.canvas.node_frame));
		o->setProperty("node_frame_hovered", colorToVar(currentTheme.canvas.node_frame_hovered));
		o->setProperty("node_frame_selected", colorToVar(currentTheme.canvas.node_frame_selected));
		o->setProperty("node_rounding", currentTheme.canvas.node_rounding);
		o->setProperty("node_border_width", currentTheme.canvas.node_border_width);
		o->setProperty("selection_rect", colorToVar(currentTheme.canvas.selection_rect));
		o->setProperty("selection_rect_outline", colorToVar(currentTheme.canvas.selection_rect_outline));
		root->setProperty("canvas", juce::var(o.get()));
	}

	// layout
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("sidebar_width", currentTheme.layout.sidebar_width);
		o->setProperty("window_padding", currentTheme.layout.window_padding);
		o->setProperty("node_vertical_padding", currentTheme.layout.node_vertical_padding);
		o->setProperty("preset_vertical_padding", currentTheme.layout.preset_vertical_padding);
		o->setProperty("node_default_width", currentTheme.layout.node_default_width);
		juce::Array<juce::var> pad; pad.add(currentTheme.layout.node_default_padding.x); pad.add(currentTheme.layout.node_default_padding.y);
		o->setProperty("node_default_padding", juce::var(pad));
		juce::Array<juce::var> padm; padm.add(currentTheme.layout.node_muted_padding.x); padm.add(currentTheme.layout.node_muted_padding.y);
		o->setProperty("node_muted_padding", juce::var(padm));
		root->setProperty("layout", juce::var(o.get()));
	}

	// fonts
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("default_size", currentTheme.fonts.default_size);
		o->setProperty("default_path", currentTheme.fonts.default_path);
		root->setProperty("fonts", juce::var(o.get()));
	}

	// windows
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("status_overlay_alpha", currentTheme.windows.status_overlay_alpha);
		o->setProperty("probe_scope_alpha", currentTheme.windows.probe_scope_alpha);
		o->setProperty("preset_status_alpha", currentTheme.windows.preset_status_alpha);
		o->setProperty("notifications_alpha", currentTheme.windows.notifications_alpha);
		o->setProperty("probe_scope_width", currentTheme.windows.probe_scope_width);
		o->setProperty("probe_scope_height", currentTheme.windows.probe_scope_height);
		root->setProperty("windows", juce::var(o.get()));
	}

	// modulation
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("frequency", vec4ToVar(currentTheme.modulation.frequency));
		o->setProperty("timbre", vec4ToVar(currentTheme.modulation.timbre));
		o->setProperty("amplitude", vec4ToVar(currentTheme.modulation.amplitude));
		o->setProperty("filter", vec4ToVar(currentTheme.modulation.filter));
		root->setProperty("modulation", juce::var(o.get()));
	}

	// meters
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("safe", vec4ToVar(currentTheme.meters.safe));
		o->setProperty("warning", vec4ToVar(currentTheme.meters.warning));
		o->setProperty("clipping", vec4ToVar(currentTheme.meters.clipping));
		root->setProperty("meters", juce::var(o.get()));
	}

	// timeline
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("marker_start_end", colorToVar(currentTheme.timeline.marker_start_end));
		o->setProperty("marker_gate", colorToVar(currentTheme.timeline.marker_gate));
		o->setProperty("marker_trigger", colorToVar(currentTheme.timeline.marker_trigger));
		root->setProperty("timeline", juce::var(o.get()));
	}

	// modules
	{
		juce::DynamicObject::Ptr o = new juce::DynamicObject();
		o->setProperty("videofx_section_header", vec4ToVar(currentTheme.modules.videofx_section_header));
		o->setProperty("videofx_section_subheader", vec4ToVar(currentTheme.modules.videofx_section_subheader));
		o->setProperty("scope_section_header", vec4ToVar(currentTheme.modules.scope_section_header));
		o->setProperty("sequencer_section_header", vec4ToVar(currentTheme.modules.sequencer_section_header));
		o->setProperty("sequencer_step_active_frame", vec4ToVar(currentTheme.modules.sequencer_step_active_frame));
		o->setProperty("sequencer_step_active_grab", vec4ToVar(currentTheme.modules.sequencer_step_active_grab));
		o->setProperty("sequencer_gate_active_frame", vec4ToVar(currentTheme.modules.sequencer_gate_active_frame));
		o->setProperty("sequencer_threshold_line", colorToVar(currentTheme.modules.sequencer_threshold_line));
		o->setProperty("scope_plot_bg", colorToVar(currentTheme.modules.scope_plot_bg));
		o->setProperty("scope_plot_fg", colorToVar(currentTheme.modules.scope_plot_fg));
		o->setProperty("scope_plot_max", colorToVar(currentTheme.modules.scope_plot_max));
		o->setProperty("scope_plot_min", colorToVar(currentTheme.modules.scope_plot_min));
		o->setProperty("scope_text_max", vec4ToVar(currentTheme.modules.scope_text_max));
		o->setProperty("scope_text_min", vec4ToVar(currentTheme.modules.scope_text_min));
		o->setProperty("stroke_seq_border", colorToVar(currentTheme.modules.stroke_seq_border));
		o->setProperty("stroke_seq_canvas_bg", colorToVar(currentTheme.modules.stroke_seq_canvas_bg));
		o->setProperty("stroke_seq_line_inactive", colorToVar(currentTheme.modules.stroke_seq_line_inactive));
		o->setProperty("stroke_seq_line_active", colorToVar(currentTheme.modules.stroke_seq_line_active));
		o->setProperty("stroke_seq_playhead", colorToVar(currentTheme.modules.stroke_seq_playhead));
		o->setProperty("stroke_seq_thresh_floor", colorToVar(currentTheme.modules.stroke_seq_thresh_floor));
		o->setProperty("stroke_seq_thresh_mid", colorToVar(currentTheme.modules.stroke_seq_thresh_mid));
		o->setProperty("stroke_seq_thresh_ceil", colorToVar(currentTheme.modules.stroke_seq_thresh_ceil));
		o->setProperty("stroke_seq_frame_bg", vec4ToVar(currentTheme.modules.stroke_seq_frame_bg));
		o->setProperty("stroke_seq_frame_bg_hovered", vec4ToVar(currentTheme.modules.stroke_seq_frame_bg_hovered));
		o->setProperty("stroke_seq_frame_bg_active", vec4ToVar(currentTheme.modules.stroke_seq_frame_bg_active));
		{
			juce::DynamicObject::Ptr freqObj = new juce::DynamicObject();
			freqObj->setProperty("background", colorToVar(currentTheme.modules.frequency_graph.background));
			freqObj->setProperty("grid", colorToVar(currentTheme.modules.frequency_graph.grid));
			freqObj->setProperty("label", colorToVar(currentTheme.modules.frequency_graph.label));
			freqObj->setProperty("peak_line", colorToVar(currentTheme.modules.frequency_graph.peak_line));
			freqObj->setProperty("live_line", colorToVar(currentTheme.modules.frequency_graph.live_line));
			freqObj->setProperty("border", colorToVar(currentTheme.modules.frequency_graph.border));
			freqObj->setProperty("threshold", colorToVar(currentTheme.modules.frequency_graph.threshold));
			o->setProperty("frequency_graph", juce::var(freqObj.get()));
		}
		{
			juce::DynamicObject::Ptr physObj = new juce::DynamicObject();
			physObj->setProperty("sandbox_title", vec4ToVar(currentTheme.modules.physics.sandbox_title));
			physObj->setProperty("stroke_label", vec4ToVar(currentTheme.modules.physics.stroke_label));
			physObj->setProperty("physics_section", vec4ToVar(currentTheme.modules.physics.physics_section));
			physObj->setProperty("spawn_section", vec4ToVar(currentTheme.modules.physics.spawn_section));
			physObj->setProperty("count_ok", vec4ToVar(currentTheme.modules.physics.count_ok));
			physObj->setProperty("count_warn", vec4ToVar(currentTheme.modules.physics.count_warn));
			physObj->setProperty("count_alert", vec4ToVar(currentTheme.modules.physics.count_alert));
			physObj->setProperty("stroke_metal", vec4ToVar(currentTheme.modules.physics.stroke_metal));
			physObj->setProperty("stroke_wood", vec4ToVar(currentTheme.modules.physics.stroke_wood));
			physObj->setProperty("stroke_soil", vec4ToVar(currentTheme.modules.physics.stroke_soil));
			physObj->setProperty("stroke_conveyor", vec4ToVar(currentTheme.modules.physics.stroke_conveyor));
			physObj->setProperty("stroke_bouncy", vec4ToVar(currentTheme.modules.physics.stroke_bouncy));
			physObj->setProperty("stroke_sticky", vec4ToVar(currentTheme.modules.physics.stroke_sticky));
			physObj->setProperty("stroke_emitter", vec4ToVar(currentTheme.modules.physics.stroke_emitter));
			physObj->setProperty("spawn_ball", vec4ToVar(currentTheme.modules.physics.spawn_ball));
			physObj->setProperty("spawn_square", vec4ToVar(currentTheme.modules.physics.spawn_square));
			physObj->setProperty("spawn_triangle", vec4ToVar(currentTheme.modules.physics.spawn_triangle));
			physObj->setProperty("spawn_vortex", vec4ToVar(currentTheme.modules.physics.spawn_vortex));
			physObj->setProperty("spawn_clear", vec4ToVar(currentTheme.modules.physics.spawn_clear));
			physObj->setProperty("spawn_clear_hover", vec4ToVar(currentTheme.modules.physics.spawn_clear_hover));
			physObj->setProperty("spawn_clear_active", vec4ToVar(currentTheme.modules.physics.spawn_clear_active));
			physObj->setProperty("canvas_background", vec4ToVar(currentTheme.modules.physics.canvas_background));
			physObj->setProperty("canvas_border", vec4ToVar(currentTheme.modules.physics.canvas_border));
			physObj->setProperty("drag_indicator_fill", vec4ToVar(currentTheme.modules.physics.drag_indicator_fill));
			physObj->setProperty("drag_indicator_outline", vec4ToVar(currentTheme.modules.physics.drag_indicator_outline));
			physObj->setProperty("eraser_fill", vec4ToVar(currentTheme.modules.physics.eraser_fill));
			physObj->setProperty("eraser_outline", vec4ToVar(currentTheme.modules.physics.eraser_outline));
			physObj->setProperty("crosshair_idle", vec4ToVar(currentTheme.modules.physics.crosshair_idle));
			physObj->setProperty("crosshair_active", vec4ToVar(currentTheme.modules.physics.crosshair_active));
			physObj->setProperty("magnet_north", vec4ToVar(currentTheme.modules.physics.magnet_north));
			physObj->setProperty("magnet_south", vec4ToVar(currentTheme.modules.physics.magnet_south));
			physObj->setProperty("magnet_link", vec4ToVar(currentTheme.modules.physics.magnet_link));
			physObj->setProperty("vector_outline", vec4ToVar(currentTheme.modules.physics.vector_outline));
			physObj->setProperty("vector_fill", vec4ToVar(currentTheme.modules.physics.vector_fill));
			physObj->setProperty("soil_detail", vec4ToVar(currentTheme.modules.physics.soil_detail));
			physObj->setProperty("overlay_text", vec4ToVar(currentTheme.modules.physics.overlay_text));
			physObj->setProperty("overlay_line", vec4ToVar(currentTheme.modules.physics.overlay_line));
			physObj->setProperty("separator_line", vec4ToVar(currentTheme.modules.physics.separator_line));
			o->setProperty("physics", juce::var(physObj.get()));
		}
		root->setProperty("modules", juce::var(o.get()));
	}

	juce::String json = juce::JSON::toString(juce::var(root.get()), true);
	if (themeFile.replaceWithText(json))
	{
		m_currentThemeFilename = themeFile.getFileName();  // Update current theme filename after successful save
		return true;
	}
	return false;
}

void ThemeManager::applyImGuiStyle()
{
	ImGuiStyle& style = ImGui::GetStyle();
	style = currentTheme.style;

	for (int i = 0; i < ImGuiCol_COUNT; ++i)
	{
		style.Colors[i] = currentTheme.style.Colors[i];
	}
}

void ThemeManager::applyFonts(ImGuiIO& io)
{
	juce::Logger::writeToLog("[ThemeManager] Rebuilding font atlas...");

	io.Fonts->Clear();

	const auto& fontSettings = currentTheme.fonts;
	const float baseSize = 16.0f;
	const float desiredSize = fontSettings.default_size > 0.0f ? fontSettings.default_size : baseSize;

	auto resolveFontPath = [] (const juce::String& path) -> juce::File
	{
		juce::File file(path);
		if (path.isNotEmpty() && !juce::File::isAbsolutePath(path))
		{
			auto baseDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
			file = baseDir.getChildFile(path);
		}
		return file;
	};

	bool fontLoaded = false;
	juce::File fontFile;
	if (fontSettings.default_path.isNotEmpty())
	{
		fontFile = resolveFontPath(fontSettings.default_path);
		if (fontFile.existsAsFile())
		{
			ImFontConfig cfg;
			cfg.SizePixels = baseSize;
			fontLoaded = io.Fonts->AddFontFromFileTTF(fontFile.getFullPathName().toRawUTF8(), baseSize, &cfg) != nullptr;
			if (fontLoaded)
				juce::Logger::writeToLog("[ThemeManager] Added font: " + fontFile.getFileName());
			else
				juce::Logger::writeToLog("[ThemeManager] Failed to load font: " + fontFile.getFullPathName());
		}
		else
		{
			juce::Logger::writeToLog("[ThemeManager] Font file not found: " + fontFile.getFullPathName());
		}
	}
	else
	{
		fontFile = juce::File();
	}

	if (!fontLoaded)
	{
		io.Fonts->AddFontDefault();
		juce::Logger::writeToLog("[ThemeManager] WARNING: Using ImGui default font.");
	}

	if (desiredSize > 0.0f && baseSize > 0.0f)
	{
		io.FontGlobalScale = desiredSize / baseSize;
		juce::Logger::writeToLog("[ThemeManager] FontGlobalScale = " + juce::String(io.FontGlobalScale, 2));
	}
	else
	{
		io.FontGlobalScale = 1.0f;
	}
}

// Helpers
juce::var ThemeManager::colorToVar(ImU32 c)
{
	// Store as float array [r,g,b,a] in 0..1 for interoperability
	ImVec4 f = ImGui::ColorConvertU32ToFloat4(c);
	juce::Array<juce::var> a;
	a.add(f.x);
	a.add(f.y);
	a.add(f.z);
	a.add(f.w);
	return juce::var(a);
}

ImU32 ThemeManager::varToColor(const juce::var& v, ImU32 fallback)
{
	if (!v.isArray()) return fallback;
	auto* arr = v.getArray(); if (arr->size() < 4) return fallback;
	// Accept either 0..1 floats or 0..255 ints
	auto getf = [&](int idx) -> float {
		auto& ref = arr->getReference(idx);
		if (ref.isDouble() || ref.isInt() || ref.isInt64())
		{
			double d = (double) ref;
			if (d > 1.0) return (float) (d / 255.0);
			return (float) d;
		}
		return 0.0f;
	};
	float r = getf(0), g = getf(1), b = getf(2), apha = getf(3);
	return ImGui::ColorConvertFloat4ToU32(ImVec4(r, g, b, apha));
}

juce::var ThemeManager::vec4ToVar(const ImVec4& v)
{
	juce::Array<juce::var> a; a.add(v.x); a.add(v.y); a.add(v.z); a.add(v.w);
	return juce::var(a);
}

ImVec4 ThemeManager::varToVec4(const juce::var& v, const ImVec4& fallback)
{
	if (!v.isArray()) return fallback;
	auto* a = v.getArray(); if (a->size() < 4) return fallback;
	return ImVec4((float) a->getReference(0), (float) a->getReference(1), (float) a->getReference(2), (float) a->getReference(3));
}

juce::String ThemeManager::moduleCategoryToString(ModuleCategory c)
{
	switch (c)
	{
		case ModuleCategory::Source: return "Source";
		case ModuleCategory::Effect: return "Effect";
		case ModuleCategory::Modulator: return "Modulator";
		case ModuleCategory::Utility: return "Utility";
		case ModuleCategory::Seq: return "Seq";
		case ModuleCategory::MIDI: return "MIDI";
		case ModuleCategory::Analysis: return "Analysis";
		case ModuleCategory::TTS_Voice: return "TTS_Voice";
		case ModuleCategory::Special_Exp: return "Special_Exp";
		case ModuleCategory::OpenCV: return "OpenCV";
		case ModuleCategory::Sys: return "Sys";
		case ModuleCategory::Comment: return "Comment";
		case ModuleCategory::Plugin: return "Plugin";
		default: return "Default";
	}
}

bool ThemeManager::stringToModuleCategory(const juce::String& s, ModuleCategory& out)
{
	static std::map<juce::String, ModuleCategory> m = {
		{ "Source", ModuleCategory::Source },
		{ "Effect", ModuleCategory::Effect },
		{ "Modulator", ModuleCategory::Modulator },
		{ "Utility", ModuleCategory::Utility },
		{ "Seq", ModuleCategory::Seq },
		{ "MIDI", ModuleCategory::MIDI },
		{ "Analysis", ModuleCategory::Analysis },
		{ "TTS_Voice", ModuleCategory::TTS_Voice },
		{ "Special_Exp", ModuleCategory::Special_Exp },
		{ "OpenCV", ModuleCategory::OpenCV },
		{ "Sys", ModuleCategory::Sys },
		{ "Comment", ModuleCategory::Comment },
		{ "Plugin", ModuleCategory::Plugin },
		{ "Default", ModuleCategory::Default }
	};
	if (auto it = m.find(s); it != m.end()) { out = it->second; return true; }
	return false;
}

juce::String ThemeManager::pinTypeToString(PinDataType t)
{
	switch (t)
	{
		case PinDataType::CV: return "CV";
		case PinDataType::Audio: return "Audio";
		case PinDataType::Gate: return "Gate";
		case PinDataType::Raw: return "Raw";
		case PinDataType::Video: return "Video";
		default: return "Default";
	}
}

bool ThemeManager::stringToPinType(const juce::String& s, PinDataType& out)
{
	static std::map<juce::String, PinDataType> m = {
		{ "CV", PinDataType::CV },
		{ "Audio", PinDataType::Audio },
		{ "Gate", PinDataType::Gate },
		{ "Raw", PinDataType::Raw },
		{ "Video", PinDataType::Video },
		{ "Default", PinDataType::Raw }
	};
	if (auto it = m.find(s); it != m.end()) { out = it->second; return true; }
	return false;
}

void ThemeManager::loadDefaultTheme()
{
	ImGui::StyleColorsDark(&defaultTheme.style);
	defaultTheme.accent = ImVec4(0.0f, 0.8f, 1.0f, 1.0f);

	// Category colors
	defaultTheme.imnodes.category_colors[ModuleCategory::Source] = IM_COL32(50, 120, 50, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Effect] = IM_COL32(130, 60, 60, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Modulator] = IM_COL32(50, 50, 130, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Utility] = IM_COL32(110, 80, 50, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Seq] = IM_COL32(90, 140, 90, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::MIDI] = IM_COL32(180, 120, 255, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Analysis] = IM_COL32(100, 50, 110, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::TTS_Voice] = IM_COL32(255, 180, 100, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Special_Exp] = IM_COL32(50, 200, 200, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::OpenCV] = IM_COL32(255, 140, 0, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Sys] = IM_COL32(120, 100, 140, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Comment] = IM_COL32(80, 80, 80, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Plugin] = IM_COL32(50, 110, 110, 255);
	defaultTheme.imnodes.category_colors[ModuleCategory::Default] = IM_COL32(70, 70, 70, 255);

	// Pin colors
	defaultTheme.imnodes.pin_colors[PinDataType::CV] = IM_COL32(100, 150, 255, 255);
	defaultTheme.imnodes.pin_colors[PinDataType::Audio] = IM_COL32(100, 255, 150, 255);
	defaultTheme.imnodes.pin_colors[PinDataType::Gate] = IM_COL32(255, 220, 100, 255);
	defaultTheme.imnodes.pin_colors[PinDataType::Raw] = IM_COL32(255, 100, 100, 255);
	defaultTheme.imnodes.pin_colors[PinDataType::Video] = IM_COL32(0, 200, 255, 255);
	defaultTheme.imnodes.pin_connected = IM_COL32(120, 255, 120, 255);
	defaultTheme.imnodes.pin_disconnected = IM_COL32(150, 150, 150, 255);

	// Links
	defaultTheme.links.link_hovered = IM_COL32(255, 255, 0, 255);
	defaultTheme.links.link_selected = IM_COL32(255, 255, 0, 255);
	defaultTheme.links.link_highlighted = IM_COL32(255, 255, 0, 255);
	defaultTheme.links.preview_color = IM_COL32(255, 255, 0, 200);
	defaultTheme.links.preview_width = 3.0f;
	defaultTheme.links.label_background = IM_COL32(50, 50, 50, 200);
	defaultTheme.links.label_text = IM_COL32(255, 255, 100, 255);

	// Canvas
	defaultTheme.canvas.canvas_background = IM_COL32(25, 25, 25, 255); // Dark background
	defaultTheme.canvas.grid_color = IM_COL32(50, 50, 50, 255);
	defaultTheme.canvas.grid_origin_color = IM_COL32(80, 80, 80, 255);
	defaultTheme.canvas.grid_size = 64.0f;
	defaultTheme.canvas.scale_text_color = IM_COL32(150, 150, 150, 80);
	defaultTheme.canvas.scale_interval = 400.0f;
	defaultTheme.canvas.drop_target_overlay = IM_COL32(218, 165, 32, 80);
	defaultTheme.canvas.mouse_position_text = IM_COL32(200, 200, 200, 150);
	
	// Node styling (ImNodes defaults)
	defaultTheme.canvas.node_background = IM_COL32(40, 40, 40, 255);
	defaultTheme.canvas.node_frame = IM_COL32(100, 100, 100, 255);
	defaultTheme.canvas.node_frame_hovered = IM_COL32(150, 150, 150, 255);
	defaultTheme.canvas.node_frame_selected = IM_COL32(255, 200, 0, 255);
	defaultTheme.canvas.node_rounding = 4.0f;
	defaultTheme.canvas.node_border_width = 1.0f;
	defaultTheme.canvas.selection_rect = IM_COL32(80, 140, 255, 64);
	defaultTheme.canvas.selection_rect_outline = IM_COL32(80, 140, 255, 200);

	// Windows
	defaultTheme.windows.status_overlay_alpha = 0.5f;
	defaultTheme.windows.probe_scope_alpha = 0.85f;
	defaultTheme.windows.preset_status_alpha = 0.7f;
	defaultTheme.windows.notifications_alpha = 0.92f;
	defaultTheme.windows.probe_scope_width = 260.0f;
	defaultTheme.windows.probe_scope_height = 180.0f;

	// Module defaults
	defaultTheme.modules.sequencer_section_header = ImVec4(0.5f, 1.0f, 0.7f, 1.0f);
	defaultTheme.modules.sequencer_step_active_frame = ImVec4(0.3f, 0.7f, 1.0f, 1.0f);
	defaultTheme.modules.sequencer_step_active_grab = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);
	defaultTheme.modules.sequencer_gate_active_frame = ImVec4(1.0f, 0.7f, 0.3f, 1.0f);
	defaultTheme.modules.sequencer_threshold_line = IM_COL32(255, 255, 0, 200);
	defaultTheme.modules.frequency_graph.background = IM_COL32(20, 22, 24, 255);
	defaultTheme.modules.frequency_graph.grid = IM_COL32(50, 55, 60, 255);
	defaultTheme.modules.frequency_graph.label = IM_COL32(150, 150, 150, 255);
	defaultTheme.modules.frequency_graph.peak_line = IM_COL32(255, 150, 80, 150);
	defaultTheme.modules.frequency_graph.live_line = IM_COL32(120, 170, 255, 220);
	defaultTheme.modules.frequency_graph.border = IM_COL32(80, 80, 80, 255);
	defaultTheme.modules.frequency_graph.threshold = IM_COL32(255, 100, 100, 150);
	defaultTheme.modules.physics.sandbox_title = ImVec4(0.3f, 0.9f, 1.0f, 1.0f);
	defaultTheme.modules.physics.stroke_label = ImVec4(0.9f, 0.9f, 0.5f, 1.0f);
	defaultTheme.modules.physics.physics_section = ImVec4(0.7f, 0.9f, 0.7f, 1.0f);
	defaultTheme.modules.physics.spawn_section = ImVec4(0.5f, 0.9f, 1.0f, 1.0f);
	defaultTheme.modules.physics.count_ok = ImVec4(0.6f, 0.9f, 0.6f, 1.0f);
	defaultTheme.modules.physics.count_warn = ImVec4(1.0f, 0.9f, 0.4f, 1.0f);
	defaultTheme.modules.physics.count_alert = ImVec4(1.0f, 0.4f, 0.4f, 1.0f);
	defaultTheme.modules.physics.stroke_metal = ImVec4(0.53f, 0.81f, 0.92f, 1.0f);
	defaultTheme.modules.physics.stroke_wood = ImVec4(0.96f, 0.64f, 0.38f, 1.0f);
	defaultTheme.modules.physics.stroke_soil = ImVec4(0.0f, 0.39f, 0.0f, 1.0f);
	defaultTheme.modules.physics.stroke_conveyor = ImVec4(0.58f, 0.44f, 0.86f, 1.0f);
	defaultTheme.modules.physics.stroke_bouncy = ImVec4(0.0f, 0.98f, 0.6f, 1.0f);
	defaultTheme.modules.physics.stroke_sticky = ImVec4(0.54f, 0.27f, 0.07f, 1.0f);
	defaultTheme.modules.physics.stroke_emitter = ImVec4(1.0f, 0.84f, 0.0f, 1.0f);
	defaultTheme.modules.physics.spawn_ball = ImVec4(1.0f, 0.4f, 0.4f, 1.0f);
	defaultTheme.modules.physics.spawn_square = ImVec4(0.4f, 1.0f, 0.4f, 1.0f);
	defaultTheme.modules.physics.spawn_triangle = ImVec4(0.4f, 0.4f, 1.0f, 1.0f);
	defaultTheme.modules.physics.spawn_vortex = ImVec4(0.7f, 0.4f, 1.0f, 1.0f);
	defaultTheme.modules.physics.spawn_clear = ImVec4(0.6f, 0.2f, 0.2f, 0.8f);
	defaultTheme.modules.physics.spawn_clear_hover = ImVec4(0.8f, 0.3f, 0.3f, 1.0f);
	defaultTheme.modules.physics.spawn_clear_active = ImVec4(1.0f, 0.4f, 0.4f, 1.0f);
	defaultTheme.modules.physics.canvas_background = ImVec4(0.12f, 0.12f, 0.12f, 1.0f);
	defaultTheme.modules.physics.canvas_border = ImVec4(0.39f, 0.39f, 0.39f, 1.0f);
	defaultTheme.modules.physics.drag_indicator_fill = ImVec4(1.0f, 1.0f, 0.0f, 0.4f);
	defaultTheme.modules.physics.drag_indicator_outline = ImVec4(1.0f, 1.0f, 0.0f, 0.8f);
	defaultTheme.modules.physics.eraser_fill = ImVec4(1.0f, 0.39f, 0.39f, 0.24f);
	defaultTheme.modules.physics.eraser_outline = ImVec4(0.86f, 0.08f, 0.08f, 0.7f);
	defaultTheme.modules.physics.crosshair_idle = ImVec4(1.0f, 1.0f, 1.0f, 0.5f);
	defaultTheme.modules.physics.crosshair_active = ImVec4(1.0f, 1.0f, 0.0f, 1.0f);
	defaultTheme.modules.physics.magnet_north = ImVec4(1.0f, 0.39f, 0.39f, 0.78f);
	defaultTheme.modules.physics.magnet_south = ImVec4(0.39f, 0.39f, 1.0f, 0.78f);
	defaultTheme.modules.physics.magnet_link = ImVec4(1.0f, 1.0f, 0.0f, 0.78f);
	defaultTheme.modules.physics.vector_outline = ImVec4(1.0f, 1.0f, 1.0f, 0.78f);
	defaultTheme.modules.physics.vector_fill = ImVec4(1.0f, 1.0f, 1.0f, 0.6f);
	defaultTheme.modules.physics.soil_detail = ImVec4(0.55f, 0.27f, 0.07f, 0.7f);
	defaultTheme.modules.physics.overlay_text = ImVec4(0.0f, 0.0f, 0.0f, 0.78f);
	defaultTheme.modules.physics.overlay_line = ImVec4(1.0f, 1.0f, 1.0f, 0.5f);
	defaultTheme.modules.physics.separator_line = ImVec4(1.0f, 0.84f, 0.0f, 0.78f);
}

void ThemeManager::saveUserThemePreference(const juce::String& themeFilename)
{
	// Save to exe/themes/.last_theme
	auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
	auto exeDir = exeFile.getParentDirectory();
	auto themesDir = exeDir.getChildFile("themes");
	themesDir.createDirectory(); // Ensure it exists
	auto preferenceFile = themesDir.getChildFile(".last_theme");
	
	if (preferenceFile.replaceWithText(themeFilename))
	{
		juce::Logger::writeToLog("[Theme] Saved preference: " + themeFilename);
	}
	else
	{
		juce::Logger::writeToLog("[Theme] Failed to save preference");
	}
}

bool ThemeManager::loadUserThemePreference()
{
	// Load from exe/themes/.last_theme
	auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
	auto exeDir = exeFile.getParentDirectory();
	auto themesDir = exeDir.getChildFile("themes");
	auto preferenceFile = themesDir.getChildFile(".last_theme");
	
	if (!preferenceFile.existsAsFile())
		return false;
	
	juce::String themeFilename = preferenceFile.loadFileAsString().trim();
	if (themeFilename.isEmpty())
		return false;
	
	// Try to find and load the theme
	std::vector<juce::File> candidateDirs;
	
	// 1. currentExecutableFile/themes (primary)
	{
		candidateDirs.push_back(exeDir);
	}
	
	// 2. currentApplicationFile/themes (fallback)
	{
		auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
		auto appDir = appFile.getParentDirectory();
		candidateDirs.push_back(appDir);
	}
	
	// 3. Source tree (development fallback)
	{
		auto sourceDir = exeDir.getParentDirectory().getParentDirectory()
			.getChildFile("Source")
			.getChildFile("preset_creator").getChildFile("theme").getChildFile("presets");
		if (sourceDir.exists())
			candidateDirs.push_back(sourceDir.getParentDirectory().getParentDirectory().getParentDirectory());
	}
	
	for (auto& dir : candidateDirs)
	{
		auto themesDir = dir.getChildFile("themes");
		auto themeFile = themesDir.getChildFile(themeFilename);
		
		if (themeFile.existsAsFile())
		{
			if (loadTheme(themeFile))
			{
				// loadTheme() already sets m_currentThemeFilename, so we're good
				juce::Logger::writeToLog("[Theme] Loaded saved preference: " + themeFilename);
				return true;
			}
		}
	}
	
	juce::Logger::writeToLog("[Theme] Saved preference theme not found: " + themeFilename);
	return false;
}




================================================================================
FILE: juce\Source\preset_creator\theme\Theme.h
================================================================================


#pragma once

#include <imgui.h>
#include <map>
#include <juce_core/juce_core.h>

#include "../../audio/modules/ModuleProcessor.h" // For PinDataType

// Shared module category enum for theming (mirrors UI categories)
enum class ModuleCategory { Source, Effect, Modulator, Utility, Seq, MIDI, Analysis, TTS_Voice, Special_Exp, OpenCV, Sys, Comment, Plugin, Default };

struct TriStateColor
{
	ImU32 base { 0 };
	ImU32 hovered { 0 };
	ImU32 active { 0 };
};

struct Theme
{
	// ImGui base style (padding/rounding etc.)
	ImGuiStyle style {};

	// Global accent color used across highlights
	ImVec4 accent { 0.0f, 0.8f, 1.0f, 1.0f };

	struct TextColors
	{
		ImVec4 section_header { 0.7f, 0.7f, 0.7f, 1.0f };
		ImVec4 warning { 1.0f, 0.8f, 0.0f, 1.0f };
		ImVec4 success { 0.0f, 1.0f, 0.0f, 1.0f };
		ImVec4 error { 1.0f, 0.5f, 0.0f, 1.0f };
		ImVec4 disabled { 100/255.f, 100/255.f, 100/255.f, 1.0f };
		ImVec4 active { 100/255.f, 255/255.f, 100/255.f, 1.0f };
		float tooltip_wrap_standard { 35.0f };
		float tooltip_wrap_compact { 25.0f };
		bool enable_text_glow { false };
		ImVec4 text_glow_color { 0.0f, 0.0f, 0.0f, 0.5f };
	} text;

	struct StatusColors
	{
		ImVec4 edited { 1.0f, 1.0f, 0.0f, 1.0f };
		ImVec4 saved { 0.0f, 1.0f, 0.0f, 1.0f };
	} status;

	struct HeaderColors
	{
		TriStateColor recent {};
		TriStateColor samples {};
		TriStateColor presets {};
		TriStateColor system {};
	} headers;

	struct ImNodesColors
	{
		std::map<ModuleCategory, ImU32> category_colors;
		std::map<PinDataType, ImU32> pin_colors;
		ImU32 pin_connected { 0 };
		ImU32 pin_disconnected { 0 };
		ImU32 node_muted { 0 };
		float node_muted_alpha { 0.5f };
		ImU32 node_hovered_link_highlight { 0 };
	} imnodes;

	struct LinkColors
	{
		ImU32 link_hovered { 0 };
		ImU32 link_selected { 0 };
		ImU32 link_highlighted { 0 };
		ImU32 preview_color { 0 };
		float preview_width { 3.0f };
		ImU32 label_background { 0 };
		ImU32 label_text { 0 };
	} links;

	struct CanvasColors
	{
		// Canvas background (drawn behind grid)
		ImU32 canvas_background { 0 };
		// Grid settings (custom drawn)
		ImU32 grid_color { 0 };
		ImU32 grid_origin_color { 0 };
		float grid_size { 64.0f };
		ImU32 scale_text_color { 0 };
		float scale_interval { 400.0f };
		ImU32 drop_target_overlay { 0 };
		ImU32 mouse_position_text { 0 };
		// Node styling (ImNodes)
		ImU32 node_background { 0 };
		ImU32 node_frame { 0 };
		ImU32 node_frame_hovered { 0 };
		ImU32 node_frame_selected { 0 };
		float node_rounding { 0.0f };
		float node_border_width { 0.0f };
		ImU32 selection_rect { 0 };
		ImU32 selection_rect_outline { 0 };
	} canvas;

	struct LayoutSettings
	{
		float sidebar_width { 260.0f };
		float window_padding { 10.0f };
		float node_vertical_padding { 50.0f };
		float preset_vertical_padding { 100.0f };
		float node_default_width { 240.0f };
		ImVec2 node_default_padding { 8.0f, 8.0f };
		ImVec2 node_muted_padding { 8.0f, 8.0f };
	} layout;

	struct FontSettings
	{
		float default_size { 16.0f };
		juce::String default_path; // empty = ImGui default
	} fonts;

	struct WindowSettings
	{
		float status_overlay_alpha { 0.5f };
		float probe_scope_alpha { 0.85f };
		float preset_status_alpha { 0.7f };
		float notifications_alpha { 0.92f };
		float probe_scope_width { 260.0f };
		float probe_scope_height { 180.0f };
	} windows;

	struct ModulationColors
	{
		ImVec4 frequency { 0.4f, 0.8f, 1.0f, 1.0f };
		ImVec4 timbre { 1.0f, 0.8f, 0.4f, 1.0f };
		ImVec4 amplitude { 1.0f, 0.4f, 1.0f, 1.0f };
		ImVec4 filter { 0.4f, 1.0f, 0.4f, 1.0f };
	} modulation;

	struct MeterColors
	{
		ImVec4 safe { 0.2f, 0.8f, 0.2f, 1.0f };
		ImVec4 warning { 0.9f, 0.7f, 0.0f, 1.0f };
		ImVec4 clipping { 0.9f, 0.2f, 0.2f, 1.0f };
	} meters;

	struct TimelineColors
	{
		ImU32 marker_start_end { 0 };
		ImU32 marker_gate { 0 };
		ImU32 marker_trigger { 0 };
	} timeline;

	struct ModuleColors
	{
		ImVec4 videofx_section_header { 0.7f, 0.7f, 0.7f, 1.0f };
		ImVec4 videofx_section_subheader { 0.9f, 0.9f, 0.5f, 1.0f };
		ImVec4 scope_section_header { 0.7f, 0.7f, 0.7f, 1.0f };
		ImVec4 sequencer_section_header { 0.5f, 1.0f, 0.7f, 1.0f };
		ImVec4 sequencer_step_active_frame { 0.3f, 0.7f, 1.0f, 1.0f };
		ImVec4 sequencer_step_active_grab { 0.9f, 0.9f, 0.9f, 1.0f };
		ImVec4 sequencer_gate_active_frame { 1.0f, 0.7f, 0.3f, 1.0f };
		ImU32 sequencer_threshold_line { IM_COL32(255, 255, 0, 200) };
		ImVec4 stroke_seq_title { 0.9f, 0.95f, 0.2f, 1.0f };
		ImVec4 stroke_seq_section { 0.85f, 0.9f, 0.3f, 1.0f };
		ImU32 scope_plot_bg { 0 };
		ImU32 scope_plot_fg { 0 };
		ImU32 scope_plot_max { 0 };
		ImU32 scope_plot_min { 0 };
		ImVec4 scope_text_max { 1.0f, 0.3f, 0.3f, 1.0f };
		ImVec4 scope_text_min { 1.0f, 0.86f, 0.31f, 1.0f };
		ImU32 stroke_seq_border { 0 };
		ImU32 stroke_seq_canvas_bg { 0 };
		ImU32 stroke_seq_line_inactive { 0 };
		ImU32 stroke_seq_line_active { 0 };
		ImU32 stroke_seq_playhead { 0 };
		ImU32 stroke_seq_thresh_floor { 0 };
		ImU32 stroke_seq_thresh_mid { 0 };
		ImU32 stroke_seq_thresh_ceil { 0 };
		ImVec4 stroke_seq_frame_bg { 0.3f, 0.28f, 0.1f, 0.7f };
		ImVec4 stroke_seq_frame_bg_hovered { 0.4f, 0.38f, 0.15f, 0.8f };
		ImVec4 stroke_seq_frame_bg_active { 0.5f, 0.48f, 0.2f, 0.9f };
		
		struct FrequencyGraphColors
		{
			ImU32 background { IM_COL32(20, 22, 24, 255) };
			ImU32 grid { IM_COL32(50, 55, 60, 255) };
			ImU32 label { IM_COL32(150, 150, 150, 255) };
			ImU32 peak_line { IM_COL32(255, 150, 80, 150) };
			ImU32 live_line { IM_COL32(120, 170, 255, 220) };
			ImU32 border { IM_COL32(80, 80, 80, 255) };
			ImU32 threshold { IM_COL32(255, 100, 100, 150) };
		} frequency_graph;
		
		struct PhysicsColors
		{
			ImVec4 sandbox_title { 0.3f, 0.9f, 1.0f, 1.0f };
			ImVec4 stroke_label { 0.9f, 0.9f, 0.5f, 1.0f };
			ImVec4 physics_section { 0.7f, 0.9f, 0.7f, 1.0f };
			ImVec4 spawn_section { 0.5f, 0.9f, 1.0f, 1.0f };
			ImVec4 count_ok { 0.6f, 0.9f, 0.6f, 1.0f };
			ImVec4 count_warn { 1.0f, 0.9f, 0.4f, 1.0f };
			ImVec4 count_alert { 1.0f, 0.4f, 0.4f, 1.0f };
			ImVec4 stroke_metal { 0.53f, 0.81f, 0.92f, 1.0f };
			ImVec4 stroke_wood { 0.96f, 0.64f, 0.38f, 1.0f };
			ImVec4 stroke_soil { 0.0f, 0.39f, 0.0f, 1.0f };
			ImVec4 stroke_conveyor { 0.58f, 0.44f, 0.86f, 1.0f };
			ImVec4 stroke_bouncy { 0.0f, 0.98f, 0.6f, 1.0f };
			ImVec4 stroke_sticky { 0.54f, 0.27f, 0.07f, 1.0f };
			ImVec4 stroke_emitter { 1.0f, 0.84f, 0.0f, 1.0f };
			ImVec4 spawn_ball { 1.0f, 0.4f, 0.4f, 1.0f };
			ImVec4 spawn_square { 0.4f, 1.0f, 0.4f, 1.0f };
			ImVec4 spawn_triangle { 0.4f, 0.4f, 1.0f, 1.0f };
			ImVec4 spawn_vortex { 0.7f, 0.4f, 1.0f, 1.0f };
			ImVec4 spawn_clear { 0.6f, 0.2f, 0.2f, 0.8f };
			ImVec4 spawn_clear_hover { 0.8f, 0.3f, 0.3f, 1.0f };
			ImVec4 spawn_clear_active { 1.0f, 0.4f, 0.4f, 1.0f };
			ImVec4 canvas_background { 0.12f, 0.12f, 0.12f, 1.0f };
			ImVec4 canvas_border { 0.39f, 0.39f, 0.39f, 1.0f };
			ImVec4 drag_indicator_fill { 1.0f, 1.0f, 0.0f, 0.4f };
			ImVec4 drag_indicator_outline { 1.0f, 1.0f, 0.0f, 0.8f };
			ImVec4 eraser_fill { 1.0f, 0.39f, 0.39f, 0.24f };
			ImVec4 eraser_outline { 0.86f, 0.08f, 0.08f, 0.7f };
			ImVec4 crosshair_idle { 1.0f, 1.0f, 1.0f, 0.5f };
			ImVec4 crosshair_active { 1.0f, 1.0f, 0.0f, 1.0f };
			ImVec4 magnet_north { 1.0f, 0.39f, 0.39f, 0.78f };
			ImVec4 magnet_south { 0.39f, 0.39f, 1.0f, 0.78f };
			ImVec4 magnet_link { 1.0f, 1.0f, 0.0f, 0.78f };
			ImVec4 vector_outline { 1.0f, 1.0f, 1.0f, 0.78f };
			ImVec4 vector_fill { 1.0f, 1.0f, 1.0f, 0.6f };
			ImVec4 soil_detail { 0.55f, 0.27f, 0.07f, 0.7f };
			ImVec4 overlay_text { 0.0f, 0.0f, 0.0f, 0.78f };
			ImVec4 overlay_line { 1.0f, 1.0f, 1.0f, 0.5f };
			ImVec4 separator_line { 1.0f, 0.84f, 0.0f, 0.78f };
		} physics;
	} modules;
};




================================================================================
FILE: juce\Source\preset_creator\ShortcutManager.h
================================================================================


#pragma once

#include <imgui.h>
#include <juce_core/juce_core.h>
#include <juce_data_structures/juce_data_structures.h>
#include <functional>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace collider
{
    /** Represents a single key chord (modifiers + main key). */
    struct KeyChord
    {
        ImGuiKey key { ImGuiKey_None };
        bool ctrl { false };
        bool shift { false };
        bool alt { false };
        bool superKey { false };

        [[nodiscard]] bool isValid() const noexcept { return key != ImGuiKey_None; }

        bool operator==(const KeyChord& other) const noexcept
        {
            return key == other.key && ctrl == other.ctrl && shift == other.shift &&
                   alt == other.alt && superKey == other.superKey;
        }

        [[nodiscard]] juce::String toString() const;

        static KeyChord fromImGui(const ImGuiIO& io, ImGuiKey keyPressed);
    };

    struct KeyChordHash
    {
        std::size_t operator()(const KeyChord& chord) const noexcept
        {
            std::size_t seed = static_cast<std::size_t>(chord.key);
            seed = (seed * 1315423911u) ^ (chord.ctrl ? 0x1u : 0x0u);
            seed = (seed * 1315423911u) ^ (chord.shift ? 0x10u : 0x0u);
            seed = (seed * 1315423911u) ^ (chord.alt ? 0x100u : 0x0u);
            seed = (seed * 1315423911u) ^ (chord.superKey ? 0x1000u : 0x0u);
            return seed;
        }
    };

    struct ShortcutAction
    {
        juce::Identifier id;
        juce::String name;
        juce::String description;
        juce::String category;
    };

    struct ShortcutBinding
    {
        juce::Identifier actionId;
        juce::Identifier context; // e.g., "Global", "NodeEditor"
        KeyChord chord;
    };

    struct IdentifierHash
    {
        std::size_t operator()(const juce::Identifier& id) const noexcept
        {
            return static_cast<std::size_t>(id.toString().hashCode());
        }
    };

    class ShortcutManager final
    {
    public:
        using ActionCallback = std::function<void()>;

        static ShortcutManager& getInstance();

        void clear();

        void registerAction(const ShortcutAction& action, ActionCallback onTrigger);
        void unregisterAction(const juce::Identifier& actionId);

        void setDefaultBinding(const juce::Identifier& actionId,
                               const juce::Identifier& context,
                               const KeyChord& chord);

        void setUserBinding(const juce::Identifier& actionId,
                            const juce::Identifier& context,
                            const KeyChord& chord);

        bool removeUserBinding(const juce::Identifier& actionId,
                               const juce::Identifier& context);

        [[nodiscard]] std::vector<ShortcutBinding> getBindingsForAction(const juce::Identifier& actionId) const;
        [[nodiscard]] KeyChord getActiveBinding(const juce::Identifier& actionId) const;

        void setContext(const juce::Identifier& newContext);
        [[nodiscard]] juce::Identifier getContext() const noexcept { return currentContext; }

        void rebuildActiveMap();

        bool processKeyChord(const KeyChord& chord);
        bool processImGuiIO(const ImGuiIO& io);

        bool loadDefaultBindingsFromFile(const juce::File& file);
        bool loadUserBindingsFromFile(const juce::File& file);
        bool saveUserBindingsToFile(const juce::File& file) const;

        [[nodiscard]] static const juce::Identifier& getGlobalContextIdentifier() noexcept;

        [[nodiscard]] juce::Optional<KeyChord> getUserBinding(const juce::Identifier& actionId,
                                                              const juce::Identifier& context) const;
        [[nodiscard]] juce::Optional<KeyChord> getDefaultBinding(const juce::Identifier& actionId,
                                                                 const juce::Identifier& context) const;
        [[nodiscard]] KeyChord getBindingForContext(const juce::Identifier& actionId,
                                                    const juce::Identifier& context) const;

        [[nodiscard]] const std::unordered_map<juce::Identifier, ShortcutAction, IdentifierHash>& getRegistry() const noexcept
        {
            return actionRegistry;
        }

        [[nodiscard]] const std::unordered_map<KeyChord, juce::Identifier, KeyChordHash>&
        getActiveKeymap() const noexcept
        {
            return activeKeymap;
        }

    private:
        ShortcutManager() = default;
        ~ShortcutManager() = default;

        static juce::var bindingToVar(const ShortcutBinding& binding);
        static juce::Optional<ShortcutBinding> bindingFromVar(const juce::var& value);

        std::unordered_map<juce::Identifier, ShortcutAction, IdentifierHash> actionRegistry;
        std::unordered_map<juce::Identifier, ActionCallback, IdentifierHash> actionCallbacks;
        std::unordered_map<juce::Identifier, std::vector<ShortcutBinding>, IdentifierHash> defaultBindings;
        std::unordered_map<juce::Identifier, std::vector<ShortcutBinding>, IdentifierHash> userBindings;

        std::unordered_map<KeyChord, juce::Identifier, KeyChordHash> activeKeymap;

        juce::Identifier currentContext { "Global" };

        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ShortcutManager)
    };

    class ScopedShortcutContext
    {
    public:
        ScopedShortcutContext(ShortcutManager& manager, const juce::Identifier& newContext)
            : shortcutManager(manager),
              previousContext(manager.getContext())
        {
            shortcutManager.setContext(newContext);
        }

        ~ScopedShortcutContext()
        {
            shortcutManager.setContext(previousContext);
        }

        ScopedShortcutContext(const ScopedShortcutContext&) = delete;
        ScopedShortcutContext& operator=(const ScopedShortcutContext&) = delete;
        ScopedShortcutContext(ScopedShortcutContext&&) = delete;
        ScopedShortcutContext& operator=(ScopedShortcutContext&&) = delete;

    private:
        ShortcutManager& shortcutManager;
        juce::Identifier previousContext;
    };

} // namespace collider


================================================================================
FILE: juce\Source\preset_creator\ShortcutManager.cpp
================================================================================


#include "ShortcutManager.h"
#include <imgui_internal.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <unordered_set>

namespace std
{
    template <>
    struct hash<juce::Identifier>
    {
        size_t operator()(const juce::Identifier& id) const noexcept
        {
            return static_cast<size_t>(id.toString().hashCode64());
        }
    };
}

namespace collider
{
    namespace
    {
        constexpr const char* kBindingsKey = "bindings";
        constexpr const char* kOverridesKey = "overrides";
        const juce::Identifier kGlobalContext { "Global" };

        juce::String keyToString(ImGuiKey key)
        {
#if IMGUI_VERSION_NUM >= 18900
            return juce::String(ImGui::GetKeyName(key));
#else
            return juce::String((int)key);
#endif
        }
    } // namespace

    //==== KeyChord ==================================================================================

    juce::String KeyChord::toString() const
    {
        if (!isValid())
            return "Unassigned";

        juce::StringArray parts;
        if (ctrl)      parts.add("Ctrl");
        if (shift)     parts.add("Shift");
        if (alt)       parts.add("Alt");
        if (superKey)  parts.add("Super");

        auto keyName = keyToString(key);
        if (keyName.isNotEmpty())
            parts.add(keyName);

        return parts.joinIntoString("+");
    }

    KeyChord KeyChord::fromImGui(const ImGuiIO& io, ImGuiKey keyPressed)
    {
        KeyChord chord;
        chord.key = keyPressed;
        chord.ctrl = io.KeyCtrl;
        chord.shift = io.KeyShift;
        chord.alt = io.KeyAlt;
#if JUCE_MAC
        chord.superKey = io.KeySuper || io.KeyCtrl;
#else
        chord.superKey = io.KeySuper;
#endif
        return chord;
    }

    //==== ShortcutManager ==========================================================================

    ShortcutManager& ShortcutManager::getInstance()
    {
        static ShortcutManager instance;
        return instance;
    }

    void ShortcutManager::clear()
    {
        actionRegistry.clear();
        actionCallbacks.clear();
        defaultBindings.clear();
        userBindings.clear();
        activeKeymap.clear();
    }

    void ShortcutManager::registerAction(const ShortcutAction& action, ActionCallback onTrigger)
    {
        actionRegistry[action.id] = action;
        actionCallbacks[action.id] = std::move(onTrigger);
    }

    void ShortcutManager::unregisterAction(const juce::Identifier& actionId)
    {
        actionRegistry.erase(actionId);
        actionCallbacks.erase(actionId);
        defaultBindings.erase(actionId);
        userBindings.erase(actionId);
        rebuildActiveMap();
    }

    void ShortcutManager::setDefaultBinding(const juce::Identifier& actionId,
                                            const juce::Identifier& context,
                                            const KeyChord& chord)
    {
        auto& bindings = defaultBindings[actionId];
        auto it = std::find_if(bindings.begin(), bindings.end(), [&](const ShortcutBinding& b) {
            return b.context == context;
        });
        if (it != bindings.end())
            it->chord = chord;
        else
            bindings.push_back({ actionId, context, chord });
        rebuildActiveMap();
    }

    void ShortcutManager::setUserBinding(const juce::Identifier& actionId,
                                         const juce::Identifier& context,
                                         const KeyChord& chord)
    {
        auto& bindings = userBindings[actionId];
        auto it = std::find_if(bindings.begin(), bindings.end(), [&](const ShortcutBinding& b) {
            return b.context == context;
        });
        if (it != bindings.end())
            it->chord = chord;
        else
            bindings.push_back({ actionId, context, chord });
        rebuildActiveMap();
    }

    bool ShortcutManager::removeUserBinding(const juce::Identifier& actionId,
                                            const juce::Identifier& context)
    {
        auto found = userBindings.find(actionId);
        if (found == userBindings.end())
            return false;

        auto& bindings = found->second;
        auto sizeBefore = bindings.size();
        bindings.erase(std::remove_if(bindings.begin(), bindings.end(), [&](const ShortcutBinding& binding) {
                          return binding.context == context;
                      }),
                      bindings.end());

        if (bindings.empty())
            userBindings.erase(found);

        if (sizeBefore != bindings.size())
        {
            rebuildActiveMap();
            return true;
        }
        return false;
    }

    std::vector<ShortcutBinding> ShortcutManager::getBindingsForAction(const juce::Identifier& actionId) const
    {
        std::vector<ShortcutBinding> result;
        if (auto it = defaultBindings.find(actionId); it != defaultBindings.end())
            result.insert(result.end(), it->second.begin(), it->second.end());
        if (auto it = userBindings.find(actionId); it != userBindings.end())
            result.insert(result.end(), it->second.begin(), it->second.end());
        return result;
    }

    KeyChord ShortcutManager::getActiveBinding(const juce::Identifier& actionId) const
    {
        auto preferredContext = currentContext;
        KeyChord best;

        if (auto it = userBindings.find(actionId); it != userBindings.end())
        {
            for (const auto& binding : it->second)
            {
                if ((binding.context == preferredContext || binding.context == kGlobalContext) && binding.chord.isValid())
                    return binding.chord;
            }
        }

        if (auto it = defaultBindings.find(actionId); it != defaultBindings.end())
        {
            for (const auto& binding : it->second)
            {
                if ((binding.context == preferredContext || binding.context == kGlobalContext) && binding.chord.isValid())
                    return binding.chord;
            }
        }

        return best;
    }

    void ShortcutManager::setContext(const juce::Identifier& newContext)
    {
        if (currentContext == newContext)
            return;

        currentContext = newContext;
        rebuildActiveMap();
    }

    const juce::Identifier& ShortcutManager::getGlobalContextIdentifier() noexcept
    {
        return kGlobalContext;
    }

    void ShortcutManager::rebuildActiveMap()
    {
        activeKeymap.clear();

        std::unordered_map<juce::Identifier, std::unordered_set<juce::Identifier>, IdentifierHash> overriddenContexts;
        for (const auto& [actionId, bindings] : userBindings)
        {
            auto& contextSet = overriddenContexts[actionId];
            for (const auto& binding : bindings)
                contextSet.insert(binding.context);
        }

        const auto isContextOverridden = [&](const juce::Identifier& actionId, const juce::Identifier& context)
        {
            if (auto it = overriddenContexts.find(actionId); it != overriddenContexts.end())
                return it->second.count(context) > 0;
            return false;
        };

        const auto insertBindings = [&](const auto& source, bool isDefault) {
            for (const auto& [actionId, bindings] : source)
            {
                for (const auto& binding : bindings)
                {
                    if (isDefault && isContextOverridden(actionId, binding.context))
                        continue;

                    if (!binding.chord.isValid())
                        continue;

                    if (binding.context != kGlobalContext && binding.context != currentContext)
                        continue;

                    activeKeymap[binding.chord] = actionId;
                }
            }
        };

        insertBindings(defaultBindings, true);
        insertBindings(userBindings, false);
    }

    juce::Optional<KeyChord> ShortcutManager::getUserBinding(const juce::Identifier& actionId,
                                                             const juce::Identifier& context) const
    {
        if (auto it = userBindings.find(actionId); it != userBindings.end())
        {
            for (const auto& binding : it->second)
            {
                if (binding.context == context)
                    return binding.chord;
            }
        }
        return {};
    }

    juce::Optional<KeyChord> ShortcutManager::getDefaultBinding(const juce::Identifier& actionId,
                                                                const juce::Identifier& context) const
    {
        if (auto it = defaultBindings.find(actionId); it != defaultBindings.end())
        {
            for (const auto& binding : it->second)
            {
                if (binding.context == context)
                    return binding.chord;
            }
        }
        return {};
    }

    KeyChord ShortcutManager::getBindingForContext(const juce::Identifier& actionId,
                                                   const juce::Identifier& context) const
    {
        if (auto user = getUserBinding(actionId, context))
        {
            if (user->isValid())
                return *user;
        }

        if (auto defaults = getDefaultBinding(actionId, context))
        {
            if (defaults->isValid())
                return *defaults;
        }

        return {};
    }

    bool ShortcutManager::processKeyChord(const KeyChord& chord)
    {
        if (!chord.isValid())
            return false;

        if (auto it = activeKeymap.find(chord); it != activeKeymap.end())
        {
            auto actionId = it->second;
            if (auto cb = actionCallbacks.find(actionId); cb != actionCallbacks.end())
            {
                cb->second();
                return true;
            }
        }
        return false;
    }

    bool ShortcutManager::processImGuiIO(const ImGuiIO& io)
    {
        if (io.WantCaptureKeyboard)
            return false;

        bool handled = false;
        for (int keyIndex = ImGuiKey_NamedKey_BEGIN; keyIndex < ImGuiKey_NamedKey_END; ++keyIndex)
        {
            const ImGuiKey key = static_cast<ImGuiKey>(keyIndex);
            const ImGuiKeyData* data = ImGui::GetKeyData(key);
            if (data == nullptr)
                continue;

            if (data->Down && data->DownDuration == 0.0f)
            {
                auto chord = KeyChord::fromImGui(io, key);
                handled = processKeyChord(chord) || handled;
            }
        }
        return handled;
    }

    bool ShortcutManager::loadDefaultBindingsFromFile(const juce::File& file)
    {
        if (!file.existsAsFile())
        {
            juce::Logger::writeToLog("[ShortcutManager] Default bindings file not found: " + file.getFullPathName());
            return false;
        }

        auto json = juce::JSON::parse(file);
        if (json.isVoid() || !json.isObject())
        {
            juce::Logger::writeToLog("[ShortcutManager] Failed to parse default bindings JSON: " + file.getFullPathName());
            return false;
        }

        const auto* object = json.getDynamicObject();
        if (object == nullptr)
        {
            juce::Logger::writeToLog("[ShortcutManager] Default bindings JSON root is not an object: " + file.getFullPathName());
            return false;
        }

        if (auto* list = object->getProperty(kBindingsKey).getArray())
        {
            for (const auto& entry : *list)
            {
                if (auto binding = bindingFromVar(entry))
                    setDefaultBinding(binding->actionId, binding->context, binding->chord);
            }
        }

        return true;
    }

    bool ShortcutManager::loadUserBindingsFromFile(const juce::File& file)
    {
        if (!file.existsAsFile())
            return false;

        auto json = juce::JSON::parse(file);
        if (json.isVoid() || !json.isObject())
        {
            juce::Logger::writeToLog("[ShortcutManager] Failed to parse user bindings JSON: " + file.getFullPathName());
            return false;
        }

        const auto* object = json.getDynamicObject();
        if (object == nullptr)
        {
            juce::Logger::writeToLog("[ShortcutManager] User bindings JSON root is not an object: " + file.getFullPathName());
            return false;
        }

        if (auto* list = object->getProperty(kOverridesKey).getArray())
        {
            for (const auto& entry : *list)
            {
                if (auto binding = bindingFromVar(entry))
                    setUserBinding(binding->actionId, binding->context, binding->chord);
            }
        }

        return true;
    }

    bool ShortcutManager::saveUserBindingsToFile(const juce::File& file) const
    {
        juce::DynamicObject::Ptr root(new juce::DynamicObject());
        juce::Array<juce::var> overrides;

        for (const auto& [actionId, bindings] : userBindings)
        {
            for (const auto& binding : bindings)
                overrides.add(bindingToVar(binding));
        }

        root->setProperty(kOverridesKey, overrides);
        const auto json = juce::JSON::toString(juce::var(root));
        if (!file.replaceWithText(json))
        {
            juce::Logger::writeToLog("[ShortcutManager] Failed to write user bindings JSON: " + file.getFullPathName());
            return false;
        }

        return true;
    }

    juce::var ShortcutManager::bindingToVar(const ShortcutBinding& binding)
    {
        juce::DynamicObject::Ptr obj(new juce::DynamicObject());
        obj->setProperty("actionId", binding.actionId.toString());
        obj->setProperty("context", binding.context.toString());
        obj->setProperty("key", static_cast<int>(binding.chord.key));
        obj->setProperty("ctrl", binding.chord.ctrl);
        obj->setProperty("shift", binding.chord.shift);
        obj->setProperty("alt", binding.chord.alt);
        obj->setProperty("super", binding.chord.superKey);
        return obj.get();
    }

    juce::Optional<ShortcutBinding> ShortcutManager::bindingFromVar(const juce::var& value)
    {
        if (!value.isObject())
            return {};

        if (const auto* obj = value.getDynamicObject())
        {
            ShortcutBinding binding;
            binding.actionId = juce::Identifier(obj->getProperty("actionId"));
            binding.context = juce::Identifier(obj->getProperty("context"));
            binding.chord.key = static_cast<ImGuiKey>(static_cast<int>(obj->getProperty("key")));
            binding.chord.ctrl = static_cast<bool>(obj->getProperty("ctrl"));
            binding.chord.shift = static_cast<bool>(obj->getProperty("shift"));
            binding.chord.alt = static_cast<bool>(obj->getProperty("alt"));
            binding.chord.superKey = static_cast<bool>(obj->getProperty("super"));
            return binding;
        }
        return {};
    }

} // namespace collider


================================================================================
FILE: guides\SHORTCUT_MANAGER_GUIDE.md
================================================================================


# Shortcut Manager Guide

## Overview

Collider now routes keyboard shortcuts through a central manager backed by Dear‚ÄØImGui. Actions register once, provide human-readable metadata, and receive default bindings. At runtime, the manager merges defaults with per-user overrides, resolves conflicts, and dispatches callbacks only when the active context matches. Users can search, rebind, and reset shortcuts through the new editor window.

- **Actions** (`collider::ShortcutAction`) describe what a shortcut does.
- **Bindings** associate an action with a `KeyChord` in a given context.
- **Contexts** scope shortcuts to parts of the UI (e.g. `Global`, `NodeEditor`).
- **Defaults** live in `assets/default_shortcuts.json`. User overrides persist to `%APPDATA%/Collider/user_shortcuts.json`.

The manager exposes a singleton (`ShortcutManager::getInstance()`) that components use to register actions and process key input each frame.

## For Developers

### Registering a new action

1. Define a stable `juce::Identifier` (e.g. `actions.view.toggleGrid`).
2. Call `shortcutManager.registerAction` with the action metadata and a callback. Callbacks can flip atomics, invoke methods, or enqueue work on the UI thread:

```cpp
registerAction(ShortcutActionIds::viewToggleGrid,
               "Toggle Grid Overlay",
               "Show or hide the editor grid.",
               "View",
               { ImGuiKey_G, true, false, false, false },
               shortcutToggleGridRequested);
```

3. Provide a default `KeyChord` matching existing behaviour. Defaults should also be listed in `assets/default_shortcuts.json` (see below).
4. When the shortcut should act, check and consume the atomic flag (or call your handler directly) inside the component‚Äôs render/update loop.

**Important:** resource lifetimes matter. Call `unregisterAction` from the component‚Äôs destructor to avoid dangling callbacks.

### Processing key input

Inside your component‚Äôs frame loop:

```cpp
if (imguiIO != nullptr && !shortcutCaptureState.isCapturing)
    shortcutManager.processImGuiIO(*imguiIO);
```

The manager scans ImGui key events, builds a `KeyChord` for each new press, and dispatches any matching action in the active context.

### Context management

Contexts prevent shortcuts from colliding across panels. Use `ScopedShortcutContext` to set a context for the duration of a render scope:

```cpp
using collider::ScopedShortcutContext;

void TimelinePanel::renderImGui()
{
    ScopedShortcutContext ctx(shortcutManager, timelineContextId);
    shortcutManager.processImGuiIO(io);
    // render panel ‚Ä¶
}
```

For transient popups/modals, create a scoped guard inside `ImGui::BeginPopup‚Ä¶`. When the guard goes out of scope, the previous context is restored automatically.

### Assigning from other UI controls

To expose ‚ÄúAssign Shortcut‚Ä¶‚Äù on right-click:

```cpp
if (ImGui::IsItemClicked(ImGuiMouseButton_Right))
    ImGui::OpenPopup("assign-shortcut");

if (ImGui::BeginPopup("assign-shortcut"))
{
    if (ImGui::MenuItem("Assign Shortcut‚Ä¶"))
    {
        beginShortcutCapture(actionId, contextId);
        showShortcutEditorWindow = true;
    }
    ImGui::EndPopup();
}
```

You can keep action IDs generic (e.g. `params.assignToSelection`) and store the parameter metadata somewhere the callback can access when triggered.

## Default bindings asset

`assets/default_shortcuts.json` is the canonical source for shipping defaults. The schema matches `ShortcutManager::bindingFromVar`:

```json
{
  "version": 1,
  "bindings": [
    {
      "actionId": "actions.file.save",
      "context": "NodeEditor",
      "key": 564,
      "ctrl": true,
      "shift": false,
      "alt": false,
      "super": false
    }
  ]
}
```

- `key` is the integer value of `ImGuiKey` (see Dear‚ÄØImGui‚Äôs `imgui.h`).
- Include every action/context pair you want to ship by default.
- Increment `version` if you change the defaults and add migration handling later if needed.

During startup, the node editor loads this file first, then applies user overrides from `%APPDATA%/Collider/user_shortcuts.json`. If files are missing or invalid, the manager logs the error (`juce::Logger`) and falls back to in-code defaults.

## Shortcut Editor UI

- **Open** via `F1` (toggle help/editor window) or Use the modal triggered by ‚ÄúAssign Shortcut‚Ä¶‚Äù.
- **Search** actions by name, description, or category.
- **Assign**: click `Assign`, press the desired chord. Assignment is immediate; conflicts are replaced automatically. Press `Esc` to cancel capture.
- **Clear** removes the user override (the action falls back to its default/global binding).
- **Reset** removes the user override and restores the default binding explicitly.
- **Save Changes** writes overrides to `%APPDATA%/Collider/user_shortcuts.json`. The file is also saved automatically when the editor closes and bindings are dirty.

## File locations

- Defaults: `assets/default_shortcuts.json` (inside the application bundle).
- User overrides: `%APPDATA%/Collider/user_shortcuts.json` (created on demand).
- Logging: see `juce::Logger` output for parse/write errors.

## Tips

- Keep action IDs stable; changing them breaks user overrides.
- Group related actions with consistent category strings so the editor table sorts cleanly.
- When adding new contexts, document expected usage in code and update this guide.
- For multi-step operations triggered by shortcuts, prefer using atomics or queues so the callback stays lightweight and deterministic.

Questions or enhancements? Ping the UI systems channel so we can keep the manager cohesive. Happy hacking!



================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_opengl/juce_opengl.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <unordered_map>
#include <tuple>
#include <deque>
#include <atomic>
#include <imgui.h>
#include <imnodes.h>
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/graph/ModularSynthProcessor.h"
#include "PresetManager.h"
#include "SampleManager.h"
#include "MidiManager.h"
#include "ControllerPresetManager.h"
#include "NotificationManager.h"
#include "ShortcutManager.h"
#include "theme/ThemeEditorComponent.h"

// Forward declarations from Dear ImGui / imnodes
struct ImGuiContext; struct ImGuiIO; struct ImNodesContext;
class MIDIPlayerModuleProcessor;
class MultiSequencerModuleProcessor;
class StrokeSequencerModuleProcessor;
class AnimationModuleProcessor;
class ColorTrackerModule;
class MetaModuleProcessor;

// Forward declaration (SavePresetJob is now in its own file to avoid circular dependencies)
class SavePresetJob;

// === NODE SIZING SYSTEM ===
// Standardized node width categories for consistent visual layout
enum class NodeWidth 
{ 
    Small,      // 240px - Basic modules (VCO, VCA, simple utilities)
    Medium,     // 360px - Effects with visualizations (Reverb, Chorus, Phaser)
    Big,        // 480px - Complex modules (PolyVCO, advanced effects)
    ExtraWide,  // 840px - Timeline/grid modules (MultiSequencer, MIDI Player)
    Exception   // Custom size - Module defines its own dimensions via getCustomNodeSize()
};

// Helper function to convert NodeWidth category to pixel width
inline float getWidthForCategory(NodeWidth width)
{
    switch (width)
    {
        case NodeWidth::Medium:    return 360.0f;
        case NodeWidth::Big:       return 480.0f;
        case NodeWidth::ExtraWide: return 840.0f;
        case NodeWidth::Exception: return 0.0f;  // Signals that module provides custom size
        case NodeWidth::Small:
        default:                   return 360.0f;
    }
}

// Pin information struct for node editor
struct PinInfo {
    uint32_t id;      // The unique ID of the pin
    juce::String type; // The parsed type ("Pitch", "Gate", "Trig", etc.)
};

class ImGuiNodeEditorComponent : public juce::Component,
                                 private juce::OpenGLRenderer
{
public:
    ImGuiNodeEditorComponent(juce::AudioDeviceManager& deviceManager);
    ~ImGuiNodeEditorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    // Input is handled by imgui_juce backend; no JUCE overrides needed
    
    void setMidiActivityFrames(int frames) { midiActivityFrames = frames; }
    
    void setModel (ModularSynthProcessor* model)
    { 
        synth = model; 
        if (synth)
        {
            synth->setOnModuleCreated([](const juce::String& pretty){
                NotificationManager::post(NotificationManager::Type::Info, "Created " + pretty + " node");
            });
        }
        undoStack.clear(); 
        redoStack.clear(); 
    }
    
    // ADD: Callback for showing audio settings dialog
    std::function<void()> onShowAudioSettings;
    
    // UI state roundtrip
    juce::ValueTree getUiValueTree() const;
    // Thread-safe: queues UI state to be applied on next render frame
    void applyUiValueTree (const juce::ValueTree& uiState);
    void applyUiValueTreeNow (const juce::ValueTree& uiState);
    void rebuildFontAtlas();
    void requestFontAtlasRebuild()
    {
        fontAtlasNeedsRebuild.store(true, std::memory_order_relaxed);
    }

    // --- Helper structs ---
    struct Range { float min; float max; };
    
    // --- Pin ID System Struct (declare before any usage) ---
    struct PinID
    {
        juce::uint32 logicalId = 0;
        int channel = 0;
        bool isInput = false;
        bool isMod = false;
        juce::String paramId; // used for mod pins
    };

    // OpenGLRenderer
    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;

    // Helper functions for pin type checking and UI
    PinDataType getPinDataTypeForPin(const PinID& pin);
    unsigned int getImU32ForType(PinDataType type);
    const char* pinDataTypeToString(PinDataType type);
    
    void handleRandomizePatch();
    void handleRandomizeConnections();
    void handleConnectSelectedToTrackMixer();
    void handleBeautifyLayout();
    void handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleInsertNodeOnSelectedLinks(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin, bool createUndoSnapshot = true);
    void drawInsertNodeOnLinkPopup();
    struct LinkInfo;
    void drawLinkInspectorTooltip(const LinkInfo& link);

    // New intelligent auto-connection system
    void parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex);
    void updateRerouteTypeFromConnections(juce::uint32 rerouteLogicalId);
    
    // Helper functions to get pins from modules
    std::vector<AudioPin> getOutputPins(const juce::String& moduleType);
    std::vector<AudioPin> getInputPins(const juce::String& moduleType);
    AudioPin* findInputPin(const juce::String& moduleType, const juce::String& pinName);
    AudioPin* findOutputPin(const juce::String& moduleType, const juce::String& pinName);
    std::vector<juce::uint32> findNodesOfType(const juce::String& moduleType);
    
    // New dynamic pin-fetching helper
    std::vector<PinInfo> getDynamicOutputPins(ModuleProcessor* module);
    
    template<typename TargetProcessorType>
    void connectToMonophonicTargets(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping, const std::vector<juce::uint32>& targetLids);
    template<typename TargetProcessorType>
    void connectToPolyphonicTarget(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping);
    void handleAutoConnectionRequests();
    
    // MIDI Player Quick Connect handler
    void handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType);
    
    // StrokeSequencer specific handler
    void handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid);
    
    // AnimationModule specific handlers
    void handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid);
    
    // MultiSequencer specific handlers
    void handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    void handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    
    // Color Tracker auto-connect handlers
    void handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid);
    void handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid);

    void renderImGui();
    void handleDeletion();
    void bypassDeleteSelectedNodes();
    void bypassDeleteNode(juce::uint32 logicalId);
    void startSaveDialog();
    void savePresetToFile(const juce::File& file);
    void startLoadDialog();
    std::vector<juce::uint32> getMutedNodeIds() const;
    juce::String getTypeForLogical (juce::uint32 logicalId) const;

    struct MetaModuleEditorSession
    {
        struct ContextDeleter
        {
            void operator()(ImNodesContext* ctx) const noexcept
            {
                if (ctx != nullptr)
                    ImNodes::DestroyContext(ctx);
            }
        };

        std::unique_ptr<ImNodesContext, ContextDeleter> context;
        juce::uint32 metaLogicalId { 0 };
        MetaModuleProcessor* meta { nullptr };
        ModularSynthProcessor* graph { nullptr };
        std::unordered_map<int, ImVec2> nodePositions;
        std::unordered_map<int, std::pair<int, int>> linkIdToAttrs;
        bool dirty { false };
        juce::String moduleSearchTerm;
    };

    void openMetaModuleEditor(MetaModuleProcessor* metaModule, juce::uint32 metaLogicalId);
    void closeMetaModuleEditor();
    void renderMetaModuleEditor(MetaModuleEditorSession& session);

    // --- Collision-Proof Pin ID System ---
    // 32-bit ID with guaranteed separation from node IDs:
    // Bit 31: PIN_ID_FLAG (always 1 for pins, 0 for nodes)
    // Bit 30: IS_INPUT_FLAG (1 for input, 0 for output)
    // Bits 16-29: Channel Index (14 bits, up to 16384 channels)
    // Bits 0-15: Node Logical ID (16 bits, up to 65535 nodes)
    // This ensures pin IDs can never collide with node IDs
    
    static int encodePinId(const PinID& pinId)
    {
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);
        
        juce::uint32 encoded = PIN_ID_FLAG |
                               (pinId.isInput ? IS_INPUT_FLAG : 0) |
                               (((juce::uint32)pinId.channel & 0x3FFF) << 16) |
                               (pinId.logicalId & 0xFFFF);
        
        return (int)encoded;
    }

    static PinID decodePinId(int id)
    {
        PinID pinId;
        const juce::uint32 uid = (juce::uint32)id;
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);

        // Only decode if this is actually a pin ID (has the flag set)
        if ((uid & PIN_ID_FLAG) == 0)
        {
            // This is not a pin ID! Return invalid pin
            juce::Logger::writeToLog("[ERROR] decodePinId called with non-pin ID: " + juce::String((int)id));
            pinId.logicalId = 0;
            pinId.channel = 0;
            pinId.isInput = false;
            pinId.isMod = false;
            return pinId;
        }

        pinId.logicalId = uid & 0xFFFF;
        pinId.channel   = (int)((uid >> 16) & 0x3FFF); // 14-bit mask
        pinId.isInput   = (uid & IS_INPUT_FLAG) != 0;
        pinId.isMod     = false; // handled contextually, not in the bitmask
        return pinId;
    }

    juce::OpenGLContext glContext;
    ImGuiContext* imguiContext { nullptr };
    ImGuiIO* imguiIO { nullptr };
    ImNodesContext* editorContext { nullptr };
    double lastTime { 0.0 };

    juce::AudioDeviceManager& deviceManager;
    collider::ShortcutManager& shortcutManager { collider::ShortcutManager::getInstance() };
    ModularSynthProcessor* synth { nullptr };
    juce::ValueTree uiPending; // applied at next render before drawing nodes
    std::atomic<bool> graphNeedsRebuild { false };
    int midiActivityFrames = 0; // For MIDI activity indicator
    
    // Preset and sample management
    PresetManager m_presetManager;
    SampleManager m_sampleManager;
    juce::String m_presetSearchTerm;
    juce::String m_sampleSearchTerm;
    juce::File m_presetScanPath;
    juce::File m_sampleScanPath;
    std::unique_ptr<juce::FileChooser> presetPathChooser;
    std::unique_ptr<juce::FileChooser> samplePathChooser;
    
    // MIDI file management
    MidiManager m_midiManager;
    juce::File m_midiScanPath;
    juce::String m_midiSearchTerm;
    std::unique_ptr<juce::FileChooser> midiPathChooser;
    
    // Meta module editing state
    juce::uint32 metaModuleToEditLid = 0;
    std::unique_ptr<MetaModuleEditorSession> metaEditorSession;
    
    // Cache of last-known valid node positions (used when graphNeedsRebuild prevents rendering)
    std::unordered_map<int, ImVec2> lastKnownNodePositions;

    // Selection state
    int selectedLogicalId { 0 };

    std::unique_ptr<juce::FileChooser> saveChooser, loadChooser;

    // Map of linkId -> (srcAttr, dstAttr) populated each frame
    std::unordered_map<int, std::pair<int,int>> linkIdToAttrs;
    
    // Link ID registry (cleared each frame for stateless rendering)
    struct LinkKey { int srcAttr; int dstAttr; };
    struct LinkKeyHash { size_t operator()(const LinkKey& k) const noexcept { return ((size_t)k.srcAttr << 32) ^ (size_t)k.dstAttr; } };
    struct LinkKeyEq { bool operator()(const LinkKey& a, const LinkKey& b) const noexcept { return a.srcAttr==b.srcAttr && a.dstAttr==b.dstAttr; } };
    std::unordered_map<LinkKey, int, LinkKeyHash, LinkKeyEq> linkToId;
    int nextLinkId { 1000 };
    int getLinkId(int srcAttr, int dstAttr)
    {
        LinkKey k{ srcAttr, dstAttr };
        auto it = linkToId.find(k);
        if (it != linkToId.end()) return it->second;
        const int id = nextLinkId++;
        linkToId.emplace(k, id);
        return id;
    }

    // Cable inspector highlight state (updated once per frame after EndNodeEditor)
    juce::uint32 hoveredLinkSrcId { 0 };
    juce::uint32 hoveredLinkDstId { 0 };
    static constexpr juce::uint32 kOutputHighlightId = 0xFFFFFFFFu; // sentinel for main output node highlight
    int lastHoveredLinkId { -1 }; // cache inside-editor hovered link id for post-editor use
    int m_currentlyProbedLinkId { -1 }; // caches the last link sent to the probe to avoid redundant graph rebuilds
    static inline const juce::Identifier nodeEditorContextId { "NodeEditor" };

    void registerShortcuts();
    void unregisterShortcuts();

    static bool consumeShortcutFlag(std::atomic<bool>& flag) noexcept
    {
        return flag.exchange(false, std::memory_order_acq_rel);
    }

    struct ShortcutActionIds
    {
        static inline const juce::Identifier fileSave { "actions.file.save" };
        static inline const juce::Identifier fileSaveAs { "actions.file.saveAs" };
        static inline const juce::Identifier fileOpen { "actions.file.open" };
        static inline const juce::Identifier fileRandomizePatch { "actions.file.randomizePatch" };
        static inline const juce::Identifier fileRandomizeConnections { "actions.file.randomizeConnections" };
        static inline const juce::Identifier fileBeautifyLayout { "actions.file.beautifyLayout" };
        static inline const juce::Identifier editCtrlR { "actions.edit.resetOrRecord" };
        static inline const juce::Identifier editMuteSelection { "actions.edit.muteSelection" };
        static inline const juce::Identifier editSelectAll { "actions.edit.selectAll" };
        static inline const juce::Identifier editConnectOutput { "actions.edit.connectToOutput" };
        static inline const juce::Identifier editDisconnectSelection { "actions.edit.disconnectSelection" };
        static inline const juce::Identifier editDuplicate { "actions.edit.duplicate" };
        static inline const juce::Identifier editDuplicateWithRouting { "actions.edit.duplicateWithRouting" };
        static inline const juce::Identifier editDelete { "actions.edit.delete" };
        static inline const juce::Identifier editBypassDelete { "actions.edit.bypassDelete" };
        static inline const juce::Identifier viewFrameSelection { "actions.view.frameSelection" };
        static inline const juce::Identifier viewFrameAll { "actions.view.frameAll" };
        static inline const juce::Identifier viewResetOrigin { "actions.view.resetOrigin" };
        static inline const juce::Identifier viewToggleMinimap { "actions.view.toggleMinimap" };
        static inline const juce::Identifier viewToggleShortcutsWindow { "actions.view.toggleShortcutsWindow" };
        static inline const juce::Identifier historyUndo { "actions.history.undo" };
        static inline const juce::Identifier historyRedo { "actions.history.redo" };
        static inline const juce::Identifier debugToggleOverlay { "actions.debug.toggleDiagnostics" };
        static inline const juce::Identifier graphInsertMixer { "actions.graph.insertMixer" };
        static inline const juce::Identifier graphShowInsertPopup { "actions.graph.showInsertPopup" };
        static inline const juce::Identifier graphInsertOnLink { "actions.graph.insertOnLink" };
        static inline const juce::Identifier graphChainSequential { "actions.graph.chainSequential" };
        static inline const juce::Identifier graphChainAudio { "actions.graph.chainAudio" };
        static inline const juce::Identifier graphChainCv { "actions.graph.chainCv" };
        static inline const juce::Identifier graphChainGate { "actions.graph.chainGate" };
        static inline const juce::Identifier graphChainRaw { "actions.graph.chainRaw" };
        static inline const juce::Identifier graphChainVideo { "actions.graph.chainVideo" };
    };

    std::atomic<bool> shortcutFileSaveRequested { false };
    std::atomic<bool> shortcutFileSaveAsRequested { false };
    std::atomic<bool> shortcutFileOpenRequested { false };
    std::atomic<bool> shortcutRandomizePatchRequested { false };
    std::atomic<bool> shortcutRandomizeConnectionsRequested { false };
    std::atomic<bool> shortcutBeautifyLayoutRequested { false };
    std::atomic<bool> shortcutCtrlRRequested { false };
    std::atomic<bool> shortcutSelectAllRequested { false };
    std::atomic<bool> shortcutMuteSelectionRequested { false };
    std::atomic<bool> shortcutConnectOutputRequested { false };
    std::atomic<bool> shortcutDisconnectRequested { false };
    std::atomic<bool> shortcutDuplicateRequested { false };
    std::atomic<bool> shortcutDuplicateWithRoutingRequested { false };
    std::atomic<bool> shortcutDeleteRequested { false };
    std::atomic<bool> shortcutBypassDeleteRequested { false };
    std::atomic<bool> shortcutFrameSelectionRequested { false };
    std::atomic<bool> shortcutFrameAllRequested { false };
    std::atomic<bool> shortcutResetOriginRequested { false };
    std::atomic<bool> shortcutToggleMinimapRequested { false };
    std::atomic<bool> shortcutToggleShortcutsWindowRequested { false };
    std::atomic<bool> shortcutUndoRequested { false };
    std::atomic<bool> shortcutRedoRequested { false };
    std::atomic<bool> shortcutToggleDebugRequested { false };
    std::atomic<bool> shortcutInsertMixerRequested { false };
    std::atomic<bool> shortcutShowInsertPopupRequested { false };
    std::atomic<bool> shortcutInsertOnLinkRequested { false };
    std::atomic<bool> shortcutChainSequentialRequested { false };
    std::atomic<bool> shortcutChainAudioRequested { false };
    std::atomic<bool> shortcutChainCvRequested { false };
    std::atomic<bool> shortcutChainGateRequested { false };
    std::atomic<bool> shortcutChainRawRequested { false };
    std::atomic<bool> shortcutChainVideoRequested { false };

    // Positions to apply for specific node IDs on the next render (grid space)
    std::unordered_map<int, ImVec2> pendingNodePositions;
    // Screen-space positions queued for just-created nodes (converted after draw)
    std::unordered_map<int, ImVec2> pendingNodeScreenPositions;
    // Sizes to apply for specific node IDs on the next render (for Comment nodes)
    std::unordered_map<int, ImVec2> pendingNodeSizes;
    std::atomic<bool> fontAtlasNeedsRebuild { false };
    std::atomic<bool> isMinimapEnlarged { false };
    float modalMinimapScale = 0.2f;

    // Cable inspector rolling stats (last N seconds) for quick visual validation
    struct ChannelHistory 
    { 
        std::deque<std::pair<double, float>> samples; 
        double lastAccessTime = 0.0; // Track when this history was last accessed
    };
    std::map<std::pair<juce::uint32,int>, ChannelHistory> inspectorHistory; // key: (logicalId, channel)
    float inspectorWindowSeconds { 5.0f };

    // --- NEW STATE FOR CABLE SPLITTING ---
    // Stores the attribute ID of the pin we are splitting from.
    // -1 means no split operation is active.
    int splittingFromAttrId = -1;

    // Drag-to-empty detection state
    bool dragInsertActive { false };
    int dragInsertStartAttrId { -1 };
    PinID dragInsertStartPin {};
    ImVec2 dragInsertDropPos { 0.0f, 0.0f };
    bool shouldOpenDragInsertPopup { false };

    // Module suggestion caches (directional)
    std::map<PinDataType, std::vector<juce::String>> dragInsertSuggestionsInputs;
    std::map<PinDataType, std::vector<juce::String>> dragInsertSuggestionsOutputs;

    // A map to cache the screen position of every pin attribute ID each frame.
    // This is a necessary workaround as ImNodes doesn't provide a public API
    // to get a pin's position by its ID.
    std::unordered_map<int, ImVec2> attrPositions;


    // UI state / hover
    int lastHoveredNodeId { -1 };
    bool isDraggingNode { false };
    bool snapshotAfterEditor { false }; // arm when action requires node to exist (add/duplicate)
    // zoom/pan disabled
    
    // --- Modal Minimap Pan State ---

    // --- Undo/Redo (module ops) ---
    struct Snapshot
    {
        juce::MemoryBlock synthState;
        juce::ValueTree   uiState;
    };
    std::vector<Snapshot> undoStack;
    std::vector<Snapshot> redoStack;
    void pushSnapshot();
    void restoreSnapshot (const Snapshot& s);
    
    // SampleLoader texture management (use JUCE OpenGLTexture to avoid raw GL includes)
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> sampleLoaderTextureIds;
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> visionModuleTextures;
    
    // Accessor for modules that need to render their own preview with interaction
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>>& getVisionModuleTextures() { return visionModuleTextures; }

    // Preset status tracking
    juce::File currentPresetFile;  // Full file path for save operations
    bool isPatchDirty { false };
    
    // Background save/load operations
    std::atomic<bool> isSaveInProgress { false }; // Debouncing flag for save operations
    juce::ThreadPool threadPool { 2 };

    // Help window
    bool showShortcutsWindow { false };
    bool showShortcutEditorWindow { false };
    juce::String shortcutsSearchTerm;
    juce::Identifier shortcutContextSelection { nodeEditorContextId };
    bool shortcutsDirty { false };
    juce::File defaultShortcutFile;
    juce::File userShortcutFile;

    struct ShortcutCaptureState
    {
        bool isCapturing { false };
        juce::Identifier actionId;
        juce::Identifier context;
        collider::KeyChord captured;
        bool hasCaptured { false };
        juce::Identifier conflictActionId;
        juce::Identifier conflictContextId;
        bool conflictIsUserBinding { false };
    };

    ShortcutCaptureState shortcutCaptureState;

    void renderShortcutEditorWindow();
    void renderShortcutEditorTable(const juce::Identifier& context);
    void renderShortcutRow(const collider::ShortcutAction& action,
                           const juce::Identifier& actionId,
                           const juce::Identifier& context,
                           bool categoryChanged);
    void renderShortcutEditorContents(bool includeCloseButton);
    void renderShortcutCapturePanel();
    void beginShortcutCapture(const juce::Identifier& actionId, const juce::Identifier& context);
    void updateShortcutCapture();
    void cancelShortcutCapture();
    void applyShortcutCapture(bool forceReplace);
    void evaluateShortcutCaptureConflict();
    void clearShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context);
    void resetShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context);
    void saveUserShortcutBindings();
    juce::String getBindingLabelForContext(const juce::Identifier& actionId,
                                           const juce::Identifier& context,
                                           juce::String& sourceLabel) const;

    // Shortcut debounce
    bool mixerShortcutCooldown { false };
    bool insertNodeShortcutCooldown { false };
    bool showInsertNodePopup { false };
    bool showDebugMenu { false };
    bool showMidiDeviceManager { false };
    ThemeEditorComponent themeEditor { this };
    int pendingInsertLinkId { -1 };
    
    // Probe tool state
    bool isProbeModeActive { false };
    bool showProbeScope { true };
    
    // Insert node on link state
    struct LinkInfo
    {
        int linkId = -1;
        bool isMod = false;
        // For Audio links:
        PinID srcPin;
        PinID dstPin;
        // For Mod links:
        juce::uint32 srcLogicalId;
        int srcChan;
        juce::uint32 dstLogicalId;
        juce::String paramId;
        // For inspector/probe tooltip:
        juce::uint32 srcNodeId = 0;
        juce::String pinName;
        juce::String sourceNodeName;
        int srcChannel = -1;
        juce::uint32 srcLogicalNodeId = 0;
    };
    LinkInfo linkToInsertOn;
    
    // Mute/Bypass state management (non-destructive)
    struct MutedNodeState {
        std::vector<ModularSynthProcessor::ConnectionInfo> incomingConnections;
        std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
    };
    std::map<juce::uint32, MutedNodeState> mutedNodeStates;
    
    void muteNodeSilent(juce::uint32 logicalId);  // Store mute state without modifying graph (for loading presets)
    void muteNode(juce::uint32 logicalId);
    void unmuteNode(juce::uint32 logicalId);
    void handleMuteToggle();

    // Copy/Paste settings clipboard
    juce::ValueTree nodeSettingsClipboard;
    juce::String clipboardModuleType;

    // Helper functions
    void insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position);
    void insertNodeOnLinkStereo(const juce::String& nodeType, const LinkInfo& linkLeft, const LinkInfo& linkRight, const ImVec2& position);
    juce::File findPresetsDirectory();
    void populateDragInsertSuggestions();

    // --- NEW: Handler for node chaining shortcut ---
    void handleNodeChaining();

    // --- NEW: Handlers for color-coded chaining ---
    void handleColorCodedChaining(PinDataType targetType);
    std::vector<AudioPin> getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType);
    
    // --- Recorder Output Shortcut ---
    void handleRecordOutput();
    
    // --- Unified Preset Loading ---
    void loadPresetFromFile(const juce::File& file);
    void mergePresetFromFile(const juce::File& file, ImVec2 dropPosition);
    const std::vector<juce::String>& getDragInsertSuggestionsFor(const PinID& pin) const;
    void insertNodeFromDragSelection(const juce::String& moduleType);
    
    // --- Meta Module (Sub-Patching) Support ---
    void handleCollapseToMetaModule();
    void expandMetaModule(juce::uint32 metaLogicalId);
    
    // --- Module Category Color Coding ---
    enum class ModuleCategory { Source, Effect, Modulator, Utility, Seq, MIDI, Analysis, TTS_Voice, Special_Exp, OpenCV, Sys, Comment, Plugin };
    ModuleCategory getModuleCategory(const juce::String& moduleType);
    unsigned int getImU32ForCategory(ModuleCategory category, bool hovered = false);
    
    // --- Quick Add Menu ---
    std::map<juce::String, std::pair<const char*, const char*>> getModuleRegistry();
    std::vector<std::pair<juce::String, const char*>> getModuleDescriptions();
    
    // --- VST Plugin Support ---
    void addPluginModules();
    
    // --- Global GPU/CPU Settings ---
    static bool getGlobalGpuEnabled() { return s_globalGpuEnabled; }
    static void setGlobalGpuEnabled(bool enabled) { s_globalGpuEnabled = enabled; }
    
    // --- Eyedropper API ---
public:
    void startColorPicking(std::function<void(ImU32)> onPicked)
    {
        m_isPickingColor = true;
        m_onColorPicked = std::move(onPicked);
    }

private:
    static bool s_globalGpuEnabled; // Global preference for GPU acceleration

    // Cached canvas dimensions for modal pan logic
    ImVec2 lastCanvasP0;      // Cached top-left corner of the canvas
    ImVec2 lastCanvasSize;    // Cached size of the canvas
    ImVec2 lastEditorPanning { 0.0f, 0.0f }; // Cached ImNodes panning for manual grid
    bool hasRenderedAtLeastOnce { false }; // Tracks whether the node editor has completed a full frame

    // Eyedropper state
    bool m_isPickingColor { false };
    std::function<void(ImU32)> m_onColorPicked;
};


================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.cpp
================================================================================


#include "ImGuiNodeEditorComponent.h"
#include "PinDatabase.h"
#include "SavePresetJob.h"
#include "NotificationManager.h"
#include "PresetValidator.h"
#include "PresetAutoHealer.h"

#include <imgui.h>
#include <imgui_internal.h>
#include <imnodes.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <backends/imgui_impl_opengl2.h>
#include <cmath>
#include <cstring>
#include <juce_core/juce_core.h>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <cstdint>
#include <algorithm>
#include <limits>
#include <optional>
#include "theme/ThemeManager.h"

namespace
{
    using collider::KeyChord;

    [[nodiscard]] bool chordsEqual(const KeyChord& a, const KeyChord& b) noexcept
    {
        return a.key == b.key && a.ctrl == b.ctrl && a.shift == b.shift &&
               a.alt == b.alt && a.superKey == b.superKey;
    }

    [[nodiscard]] juce::String contextDisplayName(const juce::Identifier& contextId)
    {
        if (contextId == collider::ShortcutManager::getGlobalContextIdentifier())
            return "Global";
        if (contextId == ImGuiNodeEditorComponent::nodeEditorContextId)
            return "Node Editor";
        return contextId.toString();
    }
}

#if JUCE_DEBUG
namespace
{
struct ImGuiStackBalanceChecker
{
    ImGuiContext* ctx { ImGui::GetCurrentContext() };
    ImGuiWindow* window { ctx ? ctx->CurrentWindow : nullptr };
    float indent { window ? window->DC.Indent.x : 0.0f };
    float groupOffset { window ? window->DC.GroupOffset.x : 0.0f };
    float columnsOffset { window ? window->DC.ColumnsOffset.x : 0.0f };

    void validate(const juce::String& label)
    {
        if (ctx == nullptr)
            return;

        if (window != nullptr)
        {
            constexpr float epsilon = 1.0e-4f;
            auto approxEqual = [](float a, float b, float eps) noexcept
            {
                return std::abs(a - b) <= eps;
            };

            if (!approxEqual(window->DC.Indent.x, indent, epsilon)
                || !approxEqual(window->DC.GroupOffset.x, groupOffset, epsilon)
                || !approxEqual(window->DC.ColumnsOffset.x, columnsOffset, epsilon))
            {
                juce::Logger::writeToLog("[ImGui][IndentLeak] " + label
                                         + " indent=" + juce::String(window->DC.Indent.x)
                                         + " expected=" + juce::String(indent));
                jassertfalse;
                window->DC.Indent.x = indent;
                window->DC.GroupOffset.x = groupOffset;
                window->DC.ColumnsOffset.x = columnsOffset;
            }
        }
    }
};
}
#else
struct ImGuiStackBalanceChecker
{
    ImGuiStackBalanceChecker() = default;
    void validate(const juce::String&) const {}
};
#endif

// Lightweight theme change toast state
static double s_themeToastEndTime = 0.0;
static juce::String s_themeToastText;

// ============================================================================
// Global GPU/CPU Settings (default: GPU enabled for best performance)
// ============================================================================
bool ImGuiNodeEditorComponent::s_globalGpuEnabled = true;
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/modules/RerouteModuleProcessor.h"
#include "../audio/modules/AudioInputModuleProcessor.h"
#include "../audio/modules/AttenuverterModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/RandomModuleProcessor.h"
#include "../audio/modules/ValueModuleProcessor.h"
#include "../audio/modules/SampleLoaderModuleProcessor.h"
#include "../audio/modules/MIDIPlayerModuleProcessor.h"
#include "../audio/modules/PolyVCOModuleProcessor.h"
#include "../audio/modules/TrackMixerModuleProcessor.h"
#include "../audio/modules/MathModuleProcessor.h"
#include "../audio/modules/StepSequencerModuleProcessor.h"
#include "../audio/modules/MultiSequencerModuleProcessor.h"
#include "../audio/modules/StrokeSequencerModuleProcessor.h"
#include "../audio/modules/AnimationModuleProcessor.h"
#include "../audio/modules/TempoClockModuleProcessor.h"
#include "../audio/modules/WebcamLoaderModule.h"
#include "../audio/modules/VideoFileLoaderModule.h"
#include "../audio/modules/MovementDetectorModule.h"
#include "../audio/modules/HumanDetectorModule.h"
#include "../audio/modules/PoseEstimatorModule.h"
#include "../audio/modules/ColorTrackerModule.h"
#include "../audio/modules/ContourDetectorModule.h"
#include "../audio/modules/SemanticSegmentationModule.h"
#include "../audio/modules/ObjectDetectorModule.h"
#include "../audio/modules/HandTrackerModule.h"
#include "../audio/modules/FaceTrackerModule.h"
#include "../audio/modules/VideoFXModule.h"
#include "../audio/modules/CropVideoModule.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/LagProcessorModuleProcessor.h"
#include "../audio/modules/DeCrackleModuleProcessor.h"
#include "../audio/modules/GraphicEQModuleProcessor.h"
#include "../audio/modules/FrequencyGraphModuleProcessor.h"
#include "../audio/modules/ChorusModuleProcessor.h"
#include "../audio/modules/PhaserModuleProcessor.h"
#include "../audio/modules/CompressorModuleProcessor.h"
#include "../audio/modules/RecordModuleProcessor.h"
#include "../audio/modules/CommentModuleProcessor.h"
#include "../audio/modules/LimiterModuleProcessor.h"
#include "../audio/modules/GateModuleProcessor.h"
#include "../audio/modules/DriveModuleProcessor.h"
#include "../audio/modules/VstHostModuleProcessor.h"
// #include "../audio/modules/SnapshotSequencerModuleProcessor.h"  // Commented out - causing build errors
#include "../audio/modules/MIDICVModuleProcessor.h"
#include "../audio/modules/ScopeModuleProcessor.h"
#include "../audio/modules/MetaModuleProcessor.h"
#include "../audio/modules/InletModuleProcessor.h"
#include "../audio/modules/OutletModuleProcessor.h"
#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include <juce_audio_processors/juce_audio_processors.h>
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>
#include <juce_opengl/juce_opengl.h>

#if JUCE_DEBUG
static int gImNodesNodeDepth = 0;
static int gImNodesInputDepth = 0;
static int gImNodesOutputDepth = 0;
static juce::String gLastRenderedNodeLabel;

struct ImNodesDepthSnapshot
{
    int node;
    int input;
    int output;
    juce::String label;

    ImNodesDepthSnapshot(const juce::String& lbl)
        : node(gImNodesNodeDepth),
          input(gImNodesInputDepth),
          output(gImNodesOutputDepth),
          label(lbl) {}

    ~ImNodesDepthSnapshot()
    {
        if (gImNodesNodeDepth != node || gImNodesInputDepth != input || gImNodesOutputDepth != output)
        {
            juce::Logger::writeToLog("[ImNodes][DepthLeak] " + label
                                     + " node=" + juce::String(gImNodesNodeDepth) + " (expected " + juce::String(node) + ")"
                                     + " input=" + juce::String(gImNodesInputDepth) + " (expected " + juce::String(input) + ")"
                                     + " output=" + juce::String(gImNodesOutputDepth) + " (expected " + juce::String(output) + ")");
            jassertfalse;

            // Reset to avoid cascading logs
            gImNodesNodeDepth = node;
            gImNodesInputDepth = input;
            gImNodesOutputDepth = output;
        }
    }
};
#endif

#define NODE_DEBUG 0

// --- Module Descriptions for Tooltips ---
static const char* toString(PinDataType t)
{
    switch (t)
    {
        case PinDataType::Audio: return "Audio";
        case PinDataType::CV: return "CV";
        case PinDataType::Gate: return "Gate";
        case PinDataType::Raw: return "Raw";
        case PinDataType::Video: return "Video";
        default: return "Unknown";
    }
}

#define LOG_LINK(msg) do { if (NODE_DEBUG) juce::Logger::writeToLog("[LINK] " + juce::String(msg)); } while(0)

struct Range { float min; float max; };

// Forward declarations
class ModularSynthProcessor;
class RandomModuleProcessor;
class ValueModuleProcessor;
class StepSequencerModuleProcessor;
class MapRangeModuleProcessor;

// Helper methods for MapRange configuration
ImGuiNodeEditorComponent::Range getSourceRange(const ImGuiNodeEditorComponent::PinID& srcPin, ModularSynthProcessor* synth)
{
    if (synth == nullptr) return {0.0f, 1.0f};
    
    auto* module = synth->getModuleForLogical(srcPin.logicalId);
    if (auto* random = dynamic_cast<RandomModuleProcessor*>(module))
    {
        auto& ap = random->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* value = dynamic_cast<ValueModuleProcessor*>(module))
    {
        auto& ap = value->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* stepSeq = dynamic_cast<StepSequencerModuleProcessor*>(module))
    {
        // StepSequencer outputs CV range
        return {0.0f, 1.0f};
    }
    // Fallback: estimate from source's lastOutputValues
    // TODO: implement fallback estimation
    return {0.0f, 1.0f};
}

void configureMapRangeFor(PinDataType srcType, PinDataType dstType, MapRangeModuleProcessor& m, ImGuiNodeEditorComponent::Range inRange)
{
    auto& ap = m.getAPVTS();
    
    // Set input range
    if (auto* inMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin")))
        *inMinParam = inRange.min;
    if (auto* inMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax")))
        *inMaxParam = inRange.max;
    
    // Set output range based on destination type
    if (dstType == PinDataType::Audio)
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = -1.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
    else // CV or Gate
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = 0.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
}




ImGuiNodeEditorComponent::ImGuiNodeEditorComponent(juce::AudioDeviceManager& dm)
    : deviceManager(dm)
{
    juce::Logger::writeToLog("ImGuiNodeEditorComponent constructor starting...");
    
    // --- THIS WILL BE THE SMOKING GUN ---
    juce::Logger::writeToLog("About to populate pin database...");
    populatePinDatabase(); // Initialize the pin database for color coding
    populateDragInsertSuggestions();
    juce::Logger::writeToLog("Pin database populated.");
    
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
    registerShortcuts();

    auto executable = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
    auto exeDir = executable.getParentDirectory();
    auto assetsDir = exeDir.getChildFile("assets");
    defaultShortcutFile = assetsDir.getChildFile("default_shortcuts.json");
    if (defaultShortcutFile.existsAsFile())
        shortcutManager.loadDefaultBindingsFromFile(defaultShortcutFile);

    juce::File userSettingsDir;
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
        userSettingsDir = props->getFile().getParentDirectory();
    else
        userSettingsDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory).getChildFile("Collider");

    if (!userSettingsDir.isDirectory())
        userSettingsDir.createDirectory();

    userShortcutFile = userSettingsDir.getChildFile("user_shortcuts.json");
    shortcutManager.loadUserBindingsFromFile(userShortcutFile);

    // Wire Theme Editor to use framebuffer-based eyedropper
    themeEditor.setStartPicker([this](std::function<void(ImU32)> onPicked){ this->startColorPicking(std::move(onPicked)); });
    
    // Initialize browser paths (load from saved settings or use defaults)
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        // Load the last used paths, providing defaults if they don't exist
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultPresetPath = appFile.getParentDirectory().getChildFile("Presets");
        juce::File defaultSamplePath = appFile.getParentDirectory().getChildFile("Samples");

        m_presetScanPath = juce::File(props->getValue("presetScanPath", defaultPresetPath.getFullPathName()));
        m_sampleScanPath = juce::File(props->getValue("sampleScanPath", defaultSamplePath.getFullPathName()));
    }
    
    // Create these directories if they don't already exist
    if (!m_presetScanPath.exists())
        m_presetScanPath.createDirectory();
    if (!m_sampleScanPath.exists())
        m_sampleScanPath.createDirectory();
    
    juce::Logger::writeToLog("[UI] Preset path set to: " + m_presetScanPath.getFullPathName());
    juce::Logger::writeToLog("[UI] Sample path set to: " + m_sampleScanPath.getFullPathName());
    
    // --- MIDI BROWSER PATH INITIALIZATION ---
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultMidiPath = appFile.getParentDirectory().getChildFile("audio").getChildFile("MIDI");
        m_midiScanPath = juce::File(props->getValue("midiScanPath", defaultMidiPath.getFullPathName()));
    }
    if (!m_midiScanPath.exists())
        m_midiScanPath.createDirectory();
    juce::Logger::writeToLog("[UI] MIDI path set to: " + m_midiScanPath.getFullPathName());
    // --- END OF MIDI INITIALIZATION ---
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    if (shortcutsDirty)
        saveUserShortcutBindings();
    unregisterShortcuts();
    glContext.detach();
}

void ImGuiNodeEditorComponent::registerShortcuts()
{
    auto registerAction = [this](const juce::Identifier& id,
                                 const char* name,
                                 const char* description,
                                 const char* category,
                                 const collider::KeyChord& chord,
                                 std::atomic<bool>& flag)
    {
        collider::ShortcutAction action { id, juce::String(name), juce::String(description), juce::String(category) };
        shortcutManager.registerAction(action, [this, &flag]()
        {
            flag.store(true, std::memory_order_release);
        });
        shortcutManager.setDefaultBinding(id, nodeEditorContextId, chord);
    };

    registerAction(ShortcutActionIds::fileSave,
                   "Save Preset",
                   "Save the current patch to its file.",
                   "File",
                   { ImGuiKey_S, true, false, false, false },
                   shortcutFileSaveRequested);

    registerAction(ShortcutActionIds::fileSaveAs,
                   "Save Preset As‚Ä¶",
                   "Save the current patch to a new file.",
                   "File",
                   { ImGuiKey_S, true, false, true, false },
                   shortcutFileSaveAsRequested);

    registerAction(ShortcutActionIds::fileOpen,
                   "Load Preset",
                   "Open a preset from disk.",
                   "File",
                   { ImGuiKey_O, true, false, false, false },
                   shortcutFileOpenRequested);

    registerAction(ShortcutActionIds::fileRandomizePatch,
                   "Randomize Patch",
                   "Randomize the entire patch.",
                   "File",
                   { ImGuiKey_P, true, false, false, false },
                   shortcutRandomizePatchRequested);

    registerAction(ShortcutActionIds::fileRandomizeConnections,
                   "Randomize Connections",
                   "Randomize node connections.",
                   "File",
                   { ImGuiKey_M, true, false, false, false },
                   shortcutRandomizeConnectionsRequested);

    registerAction(ShortcutActionIds::fileBeautifyLayout,
                   "Beautify Layout",
                   "Automatically tidy the node layout.",
                   "File",
                   { ImGuiKey_B, true, false, false, false },
                   shortcutBeautifyLayoutRequested);

    registerAction(ShortcutActionIds::editCtrlR,
                   "Record Output / Reset Selection",
                   "Record the output when nothing is selected or reset selected nodes to defaults.",
                   "Edit",
                   { ImGuiKey_R, true, false, false, false },
                   shortcutCtrlRRequested);

    registerAction(ShortcutActionIds::editSelectAll,
                   "Select All",
                   "Select every node in the graph.",
                   "Edit",
                   { ImGuiKey_A, true, false, false, false },
                   shortcutSelectAllRequested);

    registerAction(ShortcutActionIds::editMuteSelection,
                   "Toggle Mute",
                   "Mute or bypass the selected nodes.",
                   "Edit",
                   { ImGuiKey_M, false, false, false, false },
                   shortcutMuteSelectionRequested);

    registerAction(ShortcutActionIds::editConnectOutput,
                   "Connect to Output",
                   "Wire the selected node to the main output.",
                   "Edit",
                   { ImGuiKey_O, false, false, false, false },
                   shortcutConnectOutputRequested);

    registerAction(ShortcutActionIds::editDisconnectSelection,
                   "Disconnect Selection",
                   "Remove all connections from selected nodes.",
                   "Edit",
                   { ImGuiKey_D, false, false, true, false },
                   shortcutDisconnectRequested);

    registerAction(ShortcutActionIds::editDuplicate,
                   "Duplicate Selection",
                   "Duplicate selected nodes.",
                   "Edit",
                   { ImGuiKey_D, true, false, false, false },
                   shortcutDuplicateRequested);

    registerAction(ShortcutActionIds::editDuplicateWithRouting,
                   "Duplicate Selection (With Routing)",
                   "Duplicate selected nodes and replicate their connections.",
                   "Edit",
                   { ImGuiKey_D, false, true, false, false },
                   shortcutDuplicateWithRoutingRequested);

    registerAction(ShortcutActionIds::editDelete,
                   "Delete Selection",
                   "Delete selected nodes or links.",
                   "Edit",
                   { ImGuiKey_Delete, false, false, false, false },
                   shortcutDeleteRequested);

    registerAction(ShortcutActionIds::editBypassDelete,
                   "Bypass Delete",
                   "Delete selected nodes while preserving signal flow.",
                   "Edit",
                   { ImGuiKey_Delete, false, true, false, false },
                   shortcutBypassDeleteRequested);

    registerAction(ShortcutActionIds::viewFrameSelection,
                   "Frame Selection",
                   "Frame the currently selected nodes.",
                   "View",
                   { ImGuiKey_F, false, false, false, false },
                   shortcutFrameSelectionRequested);

    registerAction(ShortcutActionIds::viewFrameAll,
                   "Frame All",
                   "Frame the entire graph.",
                   "View",
                   { ImGuiKey_Home, false, false, false, false },
                   shortcutFrameAllRequested);

    registerAction(ShortcutActionIds::viewResetOrigin,
                   "Reset View Origin",
                   "Reset the editor panning to the origin.",
                   "View",
                   { ImGuiKey_Home, true, false, false, false },
                   shortcutResetOriginRequested);

    registerAction(ShortcutActionIds::viewToggleMinimap,
                   "Toggle Minimap Zoom",
                   "Temporarily enlarge the minimap.",
                   "View",
                   { ImGuiKey_Comma, false, false, false, false },
                   shortcutToggleMinimapRequested);

    registerAction(ShortcutActionIds::viewToggleShortcutsWindow,
                   "Toggle Shortcuts Window",
                   "Show or hide the shortcuts reference window.",
                   "Help",
                   { ImGuiKey_F1, false, false, false, false },
                   shortcutToggleShortcutsWindowRequested);

    registerAction(ShortcutActionIds::historyUndo,
                   "Undo",
                   "Revert the last action.",
                   "History",
                   { ImGuiKey_Z, true, false, false, false },
                   shortcutUndoRequested);

    registerAction(ShortcutActionIds::historyRedo,
                   "Redo",
                   "Redo the last undone action.",
                   "History",
                   { ImGuiKey_Y, true, false, false, false },
                   shortcutRedoRequested);

    registerAction(ShortcutActionIds::debugToggleOverlay,
                   "Toggle Debug Menu",
                   "Show or hide the diagnostics window.",
                   "Debug",
                   { ImGuiKey_D, true, true, false, false },
                   shortcutToggleDebugRequested);

    registerAction(ShortcutActionIds::graphInsertMixer,
                   "Insert Mixer",
                   "Insert a mixer after the selected node.",
                   "Graph",
                   { ImGuiKey_T, true, false, false, false },
                   shortcutInsertMixerRequested);

    registerAction(ShortcutActionIds::graphShowInsertPopup,
                   "Open Insert Node Popup",
                   "Open the insert node popup for the selected node.",
                   "Graph",
                   { ImGuiKey_I, true, false, false, false },
                   shortcutShowInsertPopupRequested);

    registerAction(ShortcutActionIds::graphInsertOnLink,
                   "Insert Node On Link",
                   "Insert a node on the hovered link.",
                   "Graph",
                   { ImGuiKey_I, false, false, false, false },
                   shortcutInsertOnLinkRequested);

    registerAction(ShortcutActionIds::graphChainSequential,
                   "Chain Selection (Stereo)",
                   "Connect selected nodes sequentially using stereo outputs.",
                   "Graph",
                   { ImGuiKey_C, false, false, false, false },
                   shortcutChainSequentialRequested);

    registerAction(ShortcutActionIds::graphChainAudio,
                   "Chain Audio Pins",
                   "Connect matching audio pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_G, false, false, false, false },
                   shortcutChainAudioRequested);

    registerAction(ShortcutActionIds::graphChainCv,
                   "Chain CV Pins",
                   "Connect matching CV pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_B, false, false, false, false },
                   shortcutChainCvRequested);

    registerAction(ShortcutActionIds::graphChainGate,
                   "Chain Gate Pins",
                   "Connect matching gate pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_Y, false, false, false, false },
                   shortcutChainGateRequested);

    registerAction(ShortcutActionIds::graphChainRaw,
                   "Chain Raw Pins",
                   "Connect matching raw pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_R, false, false, false, false },
                   shortcutChainRawRequested);

    registerAction(ShortcutActionIds::graphChainVideo,
                   "Chain Video Pins",
                   "Connect matching video pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_V, false, false, false, false },
                   shortcutChainVideoRequested);
}

void ImGuiNodeEditorComponent::unregisterShortcuts()
{
    shortcutManager.unregisterAction(ShortcutActionIds::graphInsertOnLink);
    shortcutManager.unregisterAction(ShortcutActionIds::graphShowInsertPopup);
    shortcutManager.unregisterAction(ShortcutActionIds::graphInsertMixer);
    shortcutManager.unregisterAction(ShortcutActionIds::debugToggleOverlay);
    shortcutManager.unregisterAction(ShortcutActionIds::historyRedo);
    shortcutManager.unregisterAction(ShortcutActionIds::historyUndo);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainVideo);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainRaw);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainGate);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainCv);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainAudio);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainSequential);
    shortcutManager.unregisterAction(ShortcutActionIds::viewToggleShortcutsWindow);
    shortcutManager.unregisterAction(ShortcutActionIds::viewToggleMinimap);
    shortcutManager.unregisterAction(ShortcutActionIds::viewResetOrigin);
    shortcutManager.unregisterAction(ShortcutActionIds::viewFrameAll);
    shortcutManager.unregisterAction(ShortcutActionIds::viewFrameSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editBypassDelete);
    shortcutManager.unregisterAction(ShortcutActionIds::editDelete);
    shortcutManager.unregisterAction(ShortcutActionIds::editDuplicateWithRouting);
    shortcutManager.unregisterAction(ShortcutActionIds::editDuplicate);
    shortcutManager.unregisterAction(ShortcutActionIds::editDisconnectSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editConnectOutput);
    shortcutManager.unregisterAction(ShortcutActionIds::editMuteSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editSelectAll);
    shortcutManager.unregisterAction(ShortcutActionIds::editCtrlR);
    shortcutManager.unregisterAction(ShortcutActionIds::fileBeautifyLayout);
    shortcutManager.unregisterAction(ShortcutActionIds::fileRandomizeConnections);
    shortcutManager.unregisterAction(ShortcutActionIds::fileRandomizePatch);
    shortcutManager.unregisterAction(ShortcutActionIds::fileOpen);
    shortcutManager.unregisterAction(ShortcutActionIds::fileSaveAs);
    shortcutManager.unregisterAction(ShortcutActionIds::fileSave);
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}
// Input handled by imgui_juce backend
void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    
    // Try to load user's saved theme preference, otherwise use default
    if (!ThemeManager::getInstance().loadUserThemePreference())
    {
        // No preference found or failed to load, apply default theme
        ThemeManager::getInstance().applyTheme();
    }
    // If preference was loaded successfully, loadUserThemePreference() already called applyTheme()

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    
    // Enable grid snapping
    ImNodes::GetStyle().GridSpacing = 64.0f;
    
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // ======================================================
    // === üí° FONT REBUILD DEFERRED EXECUTION ===============
    // ======================================================
    if (fontAtlasNeedsRebuild.exchange(false, std::memory_order_acq_rel)
        || ThemeManager::getInstance().consumeFontReloadRequest())
    {
        rebuildFontAtlas();
    }

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    themeEditor.render();  // Render theme editor if open
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);

    // --- Eyedropper sampling after rendering (framebuffer has ImGui drawn) ---
    if (m_isPickingColor)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImVec2 mousePos = ImGui::GetMousePos();

        // Convert to framebuffer Y
        const int fbH = (int) io.DisplaySize.y;
        const int px = juce::jlimit(0, (int)io.DisplaySize.x - 1, (int)mousePos.x);
        const int py = juce::jlimit(0, fbH - 1, fbH - (int)mousePos.y - 1);

        unsigned char rgba[4] { 0, 0, 0, 255 };
        juce::gl::glReadPixels(px, py, 1, 1, juce::gl::GL_RGBA, juce::gl::GL_UNSIGNED_BYTE, rgba);
        ImU32 picked = IM_COL32(rgba[0], rgba[1], rgba[2], 255);

        // Draw cursor overlay
        ImDrawList* fg = ImGui::GetForegroundDrawList();
        const float s = 16.0f;
        ImVec2 tl(mousePos.x + 12, mousePos.y + 12);
        ImVec2 br(tl.x + s, tl.y + s);
        fg->AddRectFilled(tl, br, picked, 3.0f);
        fg->AddRect(tl, br, IM_COL32(0,0,0,255), 3.0f, 0, 1.0f);
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            if (m_onColorPicked) m_onColorPicked(picked);
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
        else if (ImGui::IsKeyPressed(ImGuiKey_Escape) || ImGui::IsMouseClicked(ImGuiMouseButton_Right))
        {
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
    }
}
void ImGuiNodeEditorComponent::renderImGui()
{
    // Ensure the synth always has the creation notification hook registered
    if (synth != nullptr)
    {
        synth->setOnModuleCreated([](const juce::String& pretty){
            NotificationManager::post(NotificationManager::Type::Info, "Created " + pretty + " node");
        });
    }
    static int frameCounter = 0;
    frameCounter++;

    // ========================= THE DEFINITIVE FIX =========================
    //
    // Rebuild the audio graph at the START of the frame if a change is pending.
    // This ensures that the synth model is in a consistent state BEFORE we try
    // to draw the UI, eliminating the "lost frame" that caused nodes to jump.
    //
    if (graphNeedsRebuild.load())
    {
        juce::Logger::writeToLog("[GraphSync] Rebuild flag is set. Committing changes now...");
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false; // Reset the flag immediately after committing.
        
        // CRITICAL: Invalidate hover state to prevent cable inspector from accessing
        // modules that were just deleted/recreated during commitChanges()
        lastHoveredLinkId = -1;
        lastHoveredNodeId = -1;
        hoveredLinkSrcId = 0;
        hoveredLinkDstId = 0;
        
        juce::Logger::writeToLog("[GraphSync] Graph rebuild complete.");
    }
    // ========================== END OF FIX ==========================

    // Frame start
    
    // --- Stateless Frame Rendering ---
    // Clear link registries at start of each frame for fully stateless rendering.
    // Pin IDs are now generated directly via bitmasking, no maps needed.
    linkIdToAttrs.clear();
    linkToId.clear();
    nextLinkId = 1000;

    collider::ScopedShortcutContext contextGuard(shortcutManager, nodeEditorContextId);

    if (imguiIO != nullptr && !shortcutCaptureState.isCapturing)
        shortcutManager.processImGuiIO(*imguiIO);

    // Handle toggling of shortcuts window via ShortcutManager
    if (consumeShortcutFlag(shortcutToggleShortcutsWindowRequested))
    {
        showShortcutsWindow = !showShortcutsWindow;
    }

    // --- ZOOM CONTROL HANDLER (requires imnodes zoom-enabled build) ---
#if defined(IMNODES_ZOOM_ENABLED)
    if (ImNodes::GetCurrentContext())
    {
        const ImGuiIO& io = ImGui::GetIO();
        const float currentZoom = ImNodes::EditorContextGetZoom();
        if (io.KeyCtrl && io.MouseWheel != 0.0f)
        {
            const float zoomFactor = 1.0f + (io.MouseWheel * 0.1f);
            const float newZoom = currentZoom * zoomFactor;
            ImNodes::EditorContextSetZoom(newZoom, ImGui::GetMousePos());
            juce::Logger::writeToLog("[Zoom] New Zoom: " + juce::String(newZoom, 2) + "x");
        }
    }
#endif
    // --- END ZOOM CONTROL HANDLER ---

    // === FIX DOUBLE CANVAS RENDERING ===
    // Make the parent window's background transparent.
    // This ensures that only the ImNodes canvas background (which
    // your theme controls) is the only one visible.
    ImGui::PushStyleColor(ImGuiCol_WindowBg, IM_COL32(0, 0, 0, 0));
    // === END OF FIX ===

    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_MenuBar);

    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    const float sidebarWidth = theme.layout.sidebar_width;
    const float menuBarHeight = ImGui::GetFrameHeight();
    const float padding = theme.layout.window_padding;

    // === PROBE SCOPE OVERLAY ===
    if (synth != nullptr && showProbeScope)
    {
        if (auto* scope = synth->getProbeScopeProcessor())
        {
            const float scopeWidth = theme.windows.probe_scope_width;
            const float scopeHeight = theme.windows.probe_scope_height;
            const float scopePosX = (float)getWidth() - (scopeWidth + padding);
            ImGui::SetNextWindowPos(ImVec2(scopePosX, menuBarHeight + padding), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowSize(ImVec2(scopeWidth, scopeHeight), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowBgAlpha(theme.windows.probe_scope_alpha);
            
            if (ImGui::Begin("üî¨ Probe Scope", &showProbeScope, ImGuiWindowFlags_NoFocusOnAppearing))
            {
                ImGui::Text("Signal Probe");
                ImGui::Separator();
                
                // Get scope buffer
                const auto& buffer = scope->getScopeBuffer();
                
                // Get statistics
                float minVal = 0.0f, maxVal = 0.0f;
                scope->getStatistics(minVal, maxVal);
                
                if (buffer.getNumSamples() > 0 && maxVal - minVal > 0.0001f)
                {
                    // Display stats
                    ImGui::Text("Min: %.3f  Max: %.3f", minVal, maxVal);
                    ImGui::Text("Peak: %.3f", juce::jmax(std::abs(minVal), std::abs(maxVal)));
                    
                    // Draw waveform with explicit width to avoid node expansion feedback
                    ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
                    const int numSamples = buffer.getNumSamples();
                    if (buffer.getNumChannels() > 0)
                    {
                        const float* samples = buffer.getReadPointer(0);
                        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
                    }
                    
                    // Button to clear probe connection
                    if (ImGui::Button("Clear Probe"))
                    {
                        synth->clearProbeConnection();
                    }
                }
                else
                {
                    ThemeText("No signal probed", theme.text.disabled);
                    ImGui::Text("Right-click > Probe Signal");
                    ImGui::Text("Then click any output pin");
                }
            }
            ImGui::End();
        }
    }
    // === END OF PROBE SCOPE OVERLAY ===

    // Clean up textures for deleted sample loaders
    if (synth != nullptr)
    {
        auto infos = synth->getModulesInfo();
        std::unordered_set<int> activeSampleLoaderIds;
        for (const auto& info : infos)
        {
            if (info.second.equalsIgnoreCase("sample_loader"))
            {
                activeSampleLoaderIds.insert((int)info.first);
            }
        }

        for (auto it = sampleLoaderTextureIds.begin(); it != sampleLoaderTextureIds.end(); )
        {
            if (activeSampleLoaderIds.find(it->first) == activeSampleLoaderIds.end())
            {
                if (it->second)
                    it->second.reset();
                it = sampleLoaderTextureIds.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }
    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { 
                if (currentPresetFile.existsAsFile()) {
                    savePresetToFile(currentPresetFile);
                } else {
                    startSaveDialog();
                }
            }
            if (ImGui::MenuItem("Save Preset As...", "Ctrl+Alt+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            
            ImGui::Separator();
            
            // Plugin scanning menu item
            if (ImGui::MenuItem("Scan for Plugins..."))
            {
                // Get the application instance to access plugin management
                auto& app = PresetCreatorApplication::getApp();
                auto& formatManager = app.getPluginFormatManager();
                auto& knownPluginList = app.getKnownPluginList();

                // 1. Find the VST3 format
                juce::VST3PluginFormat* vst3Format = nullptr;
                for (int i = 0; i < formatManager.getNumFormats(); ++i)
                {
                    if (auto* format = formatManager.getFormat(i); format->getName() == "VST3")
                    {
                        vst3Format = dynamic_cast<juce::VST3PluginFormat*>(format);
                        break;
                    }
                }

                if (vst3Format != nullptr)
                {
                    // 2. Define the specific folder to scan
                    juce::File vstDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile)
                                            .getParentDirectory().getChildFile("VST");

                    juce::FileSearchPath searchPath;
                    if (vstDir.isDirectory())
                    {
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Starting scan in: " + vstDir.getFullPathName());
                    }
                    else
                    {
                        vstDir.createDirectory();
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Created VST directory at: " + vstDir.getFullPathName());
                    }

                    // 3. Scan for plugins
                    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                        .getChildFile(app.getApplicationName());
                    
                    juce::PluginDirectoryScanner scanner(knownPluginList, *vst3Format, searchPath, true,
                                                         appDataDir.getChildFile("dead_plugins.txt"), true);

                    // 4. Perform the scan
                    juce::String pluginBeingScanned;
                    int numFound = 0;
                    while (scanner.scanNextFile(true, pluginBeingScanned))
                    {
                        juce::Logger::writeToLog("[VST Scan] Scanning: " + pluginBeingScanned);
                        ++numFound;
                    }
                    
                    juce::Logger::writeToLog("[VST Scan] Scan complete. Found " + juce::String(numFound) + " plugin(s).");
                    juce::Logger::writeToLog("[VST Scan] Total plugins in list: " + juce::String(knownPluginList.getNumTypes()));
                    
                    // 5. Save the updated plugin list
                    auto pluginListFile = appDataDir.getChildFile("known_plugins.xml");
                    if (auto pluginListXml = knownPluginList.createXml())
                    {
                        if (pluginListXml->writeTo(pluginListFile))
                        {
                            juce::Logger::writeToLog("[VST Scan] Saved plugin list to: " + pluginListFile.getFullPathName());
                        }
                    }
                }
                else
                {
                    juce::Logger::writeToLog("[VST Scan] ERROR: VST3 format not found in format manager.");
                }
            }
            
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }
        
        // ========================================================================
        // SETTINGS MENU - Global GPU/CPU Configuration, Audio, and MIDI
        // ========================================================================
        if (ImGui::BeginMenu("Settings"))
        {
            // Audio Settings
            if (ImGui::MenuItem("Audio Settings..."))
            {
                if (onShowAudioSettings)
                    onShowAudioSettings();
            }
            
            // MIDI Device Manager
            if (ImGui::MenuItem("MIDI Device Manager..."))
            {
                showMidiDeviceManager = !showMidiDeviceManager;
            }

            if (ImGui::MenuItem("Keyboard Shortcuts..."))
            {
                showShortcutEditorWindow = true;
            }
            
            ImGui::Separator();

                if (ImGui::BeginMenu("Theme"))
                {
                    if (ImGui::MenuItem("Edit Current Theme..."))
                    {
                        themeEditor.open();
                    }
                    ImGui::Separator();
                    
                    // Dynamic theme scanning - refreshes each time menu is opened
                    auto loadThemePreset = [&](const char* label, const juce::String& filename)
                    {
                        if (ImGui::MenuItem(label))
                        {
                            juce::File presetFile;
                            auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                            auto exeDir = exeFile.getParentDirectory();
                            auto themesDir = exeDir.getChildFile("themes");
                            auto candidate = themesDir.getChildFile(filename);
                            
                            if (candidate.existsAsFile())
                            {
                                if (ThemeManager::getInstance().loadTheme(candidate))
                                {
                                    // Save user preference
                                    ThemeManager::getInstance().saveUserThemePreference(filename);
                                    themeEditor.refreshThemeFromManager();
                                    juce::Logger::writeToLog("[Theme] Loaded: " + juce::String(label));
                                    s_themeToastText = "Theme Loaded: " + juce::String(label);
                                    s_themeToastEndTime = ImGui::GetTime() + 2.0;
                                }
                            }
                        }
                    };
                    
                    // Helper to convert filename to display name
                    auto filenameToDisplayName = [](const juce::String& filename) -> juce::String
                    {
                        juce::String name = filename;
                        // Remove .json extension
                        if (name.endsWithIgnoreCase(".json"))
                            name = name.substring(0, name.length() - 5);
                        
                        // Special case for MoofyDark
                        if (name.equalsIgnoreCase("MoofyDark"))
                            return "Moofy Dark (Default)";
                        
                        // Convert camelCase/PascalCase to Title Case with spaces
                        // e.g., "AtomOneLight" -> "Atom One Light", "ClassicTheme" -> "Classic Theme"
                        juce::String result;
                        for (int i = 0; i < name.length(); ++i)
                        {
                            juce::juce_wchar c = name[i];
                            // Insert space before uppercase letters (except first character)
                            if (i > 0 && juce::CharacterFunctions::isUpperCase(c))
                                result += " ";
                            result += c;
                        }
                        
                        // Handle special cases
                        result = result.replace("Synthwave 84", "Synthwave '84");
                        result = result.replace("Ros√© Pine", "Ros√© Pine Moon");
                        result = result.replace("Night Owl", "Night Owl Neo");
                        result = result.replace("Everforest", "Everforest Night");
                        result = result.replace("Dracula Midnight", "Dracula Midnight");
                        
                        return result;
                    };
                    
                    // Scan themes directory for all .json files
                    auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                    auto exeDir = exeFile.getParentDirectory();
                    auto themesDir = exeDir.getChildFile("themes");
                    
                    std::vector<std::pair<juce::String, juce::String>> foundThemes; // {displayName, filename}
                    
                    if (themesDir.exists() && themesDir.isDirectory())
                    {
                        juce::Array<juce::File> themeFiles;
                        themesDir.findChildFiles(themeFiles, juce::File::findFiles, false, "*.json");
                        
                        for (const auto& themeFile : themeFiles)
                        {
                            juce::String filename = themeFile.getFileName();
                            // Skip hidden/system files
                            if (filename.startsWithChar('.'))
                                continue;
                            
                            juce::String displayName = filenameToDisplayName(filename);
                            foundThemes.push_back({displayName, filename});
                        }
                    }
                    
                    // Also check source tree for development (fallback)
                    {
                        auto sourceThemesDir = exeDir.getParentDirectory().getParentDirectory()
                            .getChildFile("Source")
                            .getChildFile("preset_creator")
                            .getChildFile("theme")
                            .getChildFile("presets");
                        
                        if (sourceThemesDir.exists() && sourceThemesDir.isDirectory())
                        {
                            juce::Array<juce::File> sourceThemeFiles;
                            sourceThemesDir.findChildFiles(sourceThemeFiles, juce::File::findFiles, false, "*.json");
                            
                            for (const auto& themeFile : sourceThemeFiles)
                            {
                                juce::String filename = themeFile.getFileName();
                                if (filename.startsWithChar('.'))
                                    continue;
                                
                                // Check if we already have this theme from exe/themes
                                bool alreadyFound = false;
                                for (const auto& existing : foundThemes)
                                {
                                    if (existing.second.equalsIgnoreCase(filename))
                                    {
                                        alreadyFound = true;
                                        break;
                                    }
                                }
                                
                                if (!alreadyFound)
                                {
                                    juce::String displayName = filenameToDisplayName(filename);
                                    foundThemes.push_back({displayName, filename});
                                }
                            }
                        }
                    }
                    
                    // Sort themes alphabetically by display name
                    std::sort(foundThemes.begin(), foundThemes.end(), [](const auto& a, const auto& b)
                    {
                        return a.first.compareIgnoreCase(b.first) < 0;
                    });
                    
                    // Render menu items from dynamically found themes
                    for (const auto& theme : foundThemes)
                    {
                        loadThemePreset(theme.first.toRawUTF8(), theme.second);
                    }
                    
                    // If no themes found, show a message
                    if (foundThemes.empty())
                    {
                        ImGui::TextDisabled("No themes found in themes/ directory");
                    }

                    ImGui::EndMenu();
                }
            
            ImGui::Separator();
            
            #if WITH_CUDA_SUPPORT
                bool gpuEnabled = getGlobalGpuEnabled();
                if (ImGui::Checkbox("Enable GPU Acceleration (CUDA)", &gpuEnabled))
                {
                    setGlobalGpuEnabled(gpuEnabled);
                    juce::Logger::writeToLog("[Settings] Global GPU: " + juce::String(gpuEnabled ? "ENABLED" : "DISABLED"));
                }
                
                ImGui::TextDisabled("This setting controls all vision nodes:");
                ImGui::TextDisabled("  - Pose Estimator");
                ImGui::TextDisabled("  - Hand Tracker");
                ImGui::TextDisabled("  - Face Tracker");
                ImGui::TextDisabled("  - Object Detector");
                ImGui::TextDisabled("  - Human Detector");
                ImGui::TextDisabled("  - Color Tracker");
                ImGui::TextDisabled("  - Contour Detector");
                ImGui::TextDisabled("  - Movement Detector");
                ImGui::TextDisabled("  - Semantic Segmentation");
                
                ImGui::Separator();
                
                // Show CUDA device info
                #if WITH_CUDA_SUPPORT
                    int deviceCount = cv::cuda::getCudaEnabledDeviceCount();
                    if (deviceCount > 0)
                    {
                        ThemeText("CUDA Available", theme.text.success);
                        ImGui::Text("GPU Devices: %d", deviceCount);
                    }
                    else
                    {
                        ThemeText("CUDA compiled but no devices found", theme.text.warning);
                    }
                #endif
            #else
                ImGui::TextDisabled("GPU Acceleration: Not Compiled");
                ImGui::TextDisabled("Rebuild with CUDA support to enable");
            #endif
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Actions"))
        {
            // This item should only be enabled if at least one node is selected
            bool anyNodesSelected = ImNodes::NumSelectedNodes() > 0;
            bool multipleNodesSelected = ImNodes::NumSelectedNodes() > 1;
            
            if (ImGui::MenuItem("Connect Selected to Track Mixer", nullptr, false, anyNodesSelected))
            {
                handleConnectSelectedToTrackMixer();
            }
            
            // Meta Module: Collapse selected nodes into a reusable sub-patch
            // if (ImGui::MenuItem("Collapse to Meta Module", "Ctrl+Shift+M", false, multipleNodesSelected))
            // {
            //     handleCollapseToMetaModule();
            // }
            
            if (ImGui::MenuItem("Record Output", "Ctrl+R"))
            {
                handleRecordOutput();
            }
            
            if (ImGui::MenuItem("Beautify Layout", "Ctrl+B"))
            {
                handleBeautifyLayout();
            }
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Recording"))
        {
            if (synth != nullptr)
            {
                bool isAnyRecording = synth->isAnyModuleRecording();
                const char* label = isAnyRecording ? "Stop All Recordings" : "Start All Recordings";
                if (ImGui::MenuItem(label))
                {
                    if (isAnyRecording)
                    {
                        synth->stopAllRecorders();
                    }
                    else
                    {
                        synth->startAllRecorders();
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Insert Node"))
        {
            bool isNodeSelected = (selectedLogicalId != 0);
            
            if (ImGui::BeginMenu("Effects", isNodeSelected))
            {
                if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); }
                if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); }
                if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); }
                if (ImGui::MenuItem("Chorus")) { insertNodeBetween("chorus"); }
                if (ImGui::MenuItem("Phaser")) { insertNodeBetween("phaser"); }
                if (ImGui::MenuItem("Compressor")) { insertNodeBetween("compressor"); }
                if (ImGui::MenuItem("Limiter")) { insertNodeBetween("limiter"); }
                if (ImGui::MenuItem("Noise Gate")) { insertNodeBetween("gate"); }
                if (ImGui::MenuItem("Reroute")) { insertNodeBetween("reroute"); }
                if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
                if (ImGui::MenuItem("Graphic EQ")) { insertNodeBetween("graphic_eq"); }
                if (ImGui::MenuItem("Waveshaper")) { insertNodeBetween("waveshaper"); }
                if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); }
                if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); }
                if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); }
                if (ImGui::MenuItem("Time/Pitch Shifter")) { insertNodeBetween("timepitch"); }
                if (ImGui::MenuItem("De-Crackle")) { insertNodeBetween("de_crackle"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Modulators", isNodeSelected))
            {
                if (ImGui::MenuItem("LFO")) { insertNodeBetween("lfo"); }
                if (ImGui::MenuItem("ADSR")) { insertNodeBetween("adsr"); }
                if (ImGui::MenuItem("Random")) { insertNodeBetween("random"); }
                if (ImGui::MenuItem("S&H")) { insertNodeBetween("s_and_h"); }
                if (ImGui::MenuItem("Function Generator")) { insertNodeBetween("function_generator"); }
                if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Utilities & Logic", isNodeSelected))
            {
                if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); }
                if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); }
                if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); }
                if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); }
                if (ImGui::MenuItem("Lag Processor")) { insertNodeBetween("lag_processor"); }
                if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); }
                if (ImGui::MenuItem("Map Range")) { insertNodeBetween("map_range"); }
                if (ImGui::MenuItem("Quantizer")) { insertNodeBetween("quantizer"); }
                if (ImGui::MenuItem("Rate")) { insertNodeBetween("rate"); }
                if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); }
                if (ImGui::MenuItem("Logic")) { insertNodeBetween("logic"); }
                if (ImGui::MenuItem("Reroute")) { insertNodeBetween("reroute"); }
                if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Computer Vision", isNodeSelected))
            {
                if (ImGui::MenuItem("Video FX")) { insertNodeBetween("video_fx"); }
                if (ImGui::MenuItem("Crop Video")) { insertNodeBetween("crop_video"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("TTS", isNodeSelected))
            {
                if (ImGui::MenuItem("TTS Performer")) { insertNodeBetween("tts_performer"); }
                if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Analysis", isNodeSelected))
            {
                if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); }
                if (ImGui::MenuItem("Frequency Graph")) { insertNodeBetween("frequency_graph"); }
                ImGui::EndMenu();
            }
            
            ImGui::EndMenu();
        }
        // === DEBUG MENU ===
        if (ImGui::BeginMenu("Debug"))
        {
            if (ImGui::MenuItem("Show System Diagnostics", "Ctrl+Shift+D")) 
            {
                showDebugMenu = !showDebugMenu;
            }
            
            
            if (ImGui::MenuItem("Log System State"))
            {
                if (synth != nullptr)
                {
                    juce::Logger::writeToLog("=== SYSTEM DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getSystemDiagnostics());
                }
            }
            
            if (ImGui::MenuItem("Log Selected Module Diagnostics"))
            {
                if (synth != nullptr && selectedLogicalId != 0)
                {
                    juce::Logger::writeToLog("=== MODULE DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getModuleDiagnostics(selectedLogicalId));
                }
            }
            
            ImGui::EndMenu();
        }
        
        // === TRANSPORT CONTROLS ===
        if (synth != nullptr)
        {
            // Get current transport state
            auto transportState = synth->getTransportState();
            
            // Add some spacing before transport controls
            ImGui::Separator();
            ImGui::Spacing();
            
            // Play/Pause button
            if (transportState.isPlaying)
            {
                if (ImGui::Button("Pause"))
                    synth->setPlaying(false);
            }
            else
            {
                if (ImGui::Button("Play"))
                    synth->setPlaying(true);
            }
            
            ImGui::SameLine();
            
            // Stop button (resets position)
            if (ImGui::Button("Stop"))
            {
                synth->setPlaying(false);
                synth->resetTransportPosition();
            }
            
            ImGui::SameLine();
            
            // BPM control (greyed out if controlled by Tempo Clock module)
            float bpm = static_cast<float>(transportState.bpm);
            ImGui::SetNextItemWidth(80.0f);
            
            bool isControlled = transportState.isTempoControlledByModule.load();
            if (isControlled)
                ImGui::BeginDisabled();
                
            if (ImGui::DragFloat("BPM", &bpm, 0.1f, 20.0f, 999.0f, "%.1f"))
                synth->setBPM(static_cast<double>(bpm));
                
            if (isControlled)
            {
                ImGui::EndDisabled();
                if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
                {
                    ImGui::BeginTooltip();
                    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                    ThemeText("Tempo Clock Module Active", theme.text.warning);
                    ImGui::TextUnformatted("A Tempo Clock node with 'Sync to Host' disabled is controlling the global BPM.");
                    ImGui::PopTextWrapPos();
                    ImGui::EndTooltip();
                }
            }
            
            ImGui::SameLine();
            
            // Position display
            ImGui::Text("%.2f beats", transportState.songPositionBeats);
        }
        // === MULTI-MIDI DEVICE ACTIVITY INDICATOR ===
        ImGui::SameLine();
        ImGui::Separator();
        ImGui::SameLine();
        if (synth != nullptr)
        {
            auto activityState = synth->getMidiActivityState();
            
            if (activityState.deviceNames.empty())
            {
                // No MIDI devices connected
                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                ImGui::Text("MIDI: No Devices");
                ImGui::PopStyleColor();
            }
            else
            {
                ImGui::Text("MIDI:");
                ImGui::SameLine();
                
                // Display each device with active channels
                for (const auto& [deviceIndex, deviceName] : activityState.deviceNames)
                {
                    ImGui::SameLine();
                    
                    bool hasActivity = false;
                    if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                    {
                        const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                        for (bool active : channels)
                        {
                            if (active)
                            {
                                hasActivity = true;
                                break;
                            }
                        }
                    }
                    
                    // Abbreviated device name (max 12 chars)
                    juce::String abbrevName = deviceName;
                    if (abbrevName.length() > 12)
                        abbrevName = abbrevName.substring(0, 12) + "...";
                    
                    // Color: bright green if active, dim gray if inactive
                    if (hasActivity)
                        ImGui::PushStyleColor(ImGuiCol_Text, theme.text.active);
                    else
                        ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                    
                    ImGui::Text("[%s]", abbrevName.toRawUTF8());
                    ImGui::PopStyleColor();
                    
                    // Tooltip with full name and active channels
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("%s", deviceName.toRawUTF8());
                        ImGui::Separator();
                        
                        if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                        {
                            const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                            ImGui::Text("Active Channels:");
                            juce::String activeChannels;
                            for (int ch = 0; ch < 16; ++ch)
                            {
                                if (channels[ch])
                                {
                                    if (activeChannels.isNotEmpty())
                                        activeChannels += ", ";
                                    activeChannels += juce::String(ch + 1);
                                }
                            }
                            if (activeChannels.isEmpty())
                                activeChannels = "None";
                            ImGui::Text("%s", activeChannels.toRawUTF8());
                        }
                        
                        ImGui::EndTooltip();
                    }
                }
            }
        }
        else
        {
            ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
            ImGui::Text("MIDI: ---");
            ImGui::PopStyleColor();
        }
        // === END OF MULTI-MIDI INDICATOR ===

        // --- ZOOM DISPLAY (menu bar, right side) ---
#if defined(IMNODES_ZOOM_ENABLED)
        if (ImNodes::GetCurrentContext())
        {
            ImGui::SameLine();
            ImGui::Separator();
            ImGui::SameLine();
            ImGui::Text("Zoom: %.2fx", ImNodes::EditorContextGetZoom());
        }
#endif
        // --- END ZOOM DISPLAY ---

        ImGui::EndMainMenuBar();
    }

    // --- PRESET STATUS OVERLAY ---
    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(ThemeManager::getInstance().getCurrentTheme().windows.preset_status_alpha);
    ImGui::Begin("Preset Status", nullptr, 
                 ImGuiWindowFlags_NoDecoration | 
                 ImGuiWindowFlags_NoMove | 
                 ImGuiWindowFlags_NoFocusOnAppearing | 
                 ImGuiWindowFlags_NoNav | 
                 ImGuiWindowFlags_AlwaysAutoResize);

    if (currentPresetFile.existsAsFile()) {
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    // Get the theme colors
    if (isPatchDirty) {
        ThemeText("Status: EDITED", theme.status.edited);
    } else {
        ThemeText("Status: SAVED", theme.status.saved);
    }
    ImGui::End();
    // --- END OF PRESET STATUS OVERLAY ---
    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, sidebarWidth);
    // Zoom removed
    // ADD THIS BLOCK:
    ImGui::Text("Browser");
    // Create a scrolling child window to contain the entire browser
    ImGui::BeginChild("BrowserScrollRegion", ImVec2(0, 0), true);
    // Helper lambda to recursively draw the directory tree for presets
    std::function<void(const PresetManager::DirectoryNode*)> drawPresetTree = 
        [&](const PresetManager::DirectoryNode* node)
    {
        if (!node || (node->presets.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawPresetTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw presets in this directory with drag-and-drop support
        for (const auto& preset : node->presets)
        {
            if (m_presetSearchTerm.isEmpty() || preset.name.containsIgnoreCase(m_presetSearchTerm))
            {
                // Draw the selectable item and capture its return value
                bool clicked = ImGui::Selectable(preset.name.toRawUTF8());

                // --- THIS IS THE FIX ---
                // Check if this item is the source of a drag operation
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload type and data (the preset's file path)
                    const juce::String path = preset.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_PRESET_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback while dragging
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Merge Preset: %s", preset.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // If a drag did NOT occur, and the item was clicked, load the preset
                else if (clicked)
                {
                    loadPresetFromFile(preset.file);
                }
                // --- END OF FIX ---
                
                // Tooltip (only shown when hovering, not dragging)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0) && preset.description.isNotEmpty())
                {
                    ImGui::BeginTooltip();
                    ImGui::TextUnformatted(preset.description.toRawUTF8());
                    if (!preset.tags.isEmpty())
                        ImGui::Text("Tags: %s", preset.tags.joinIntoString(", ").toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // Helper to push category colors (used for all module category headers)
    auto pushCategoryColor = [&](ModuleCategory cat) {
        ImU32 color = getImU32ForCategory(cat);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        ImGui::PushStyleColor(ImGuiCol_Header, color);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
        
        // Automatically adjust text color based on background contrast for optimal legibility
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(color);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
    };
    auto pushHeaderColors = [&](const TriStateColor& tri)
    {
        const ImGuiStyle& styleRef = ImGui::GetStyle();
        auto toVec4 = [&](ImU32 value, ImGuiCol fallback) -> ImVec4
        {
            if (value != 0)
                return ImGui::ColorConvertU32ToFloat4(value);
            return styleRef.Colors[fallback];
        };
        ImGui::PushStyleColor(ImGuiCol_Header, toVec4(tri.base, ImGuiCol_Header));
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, toVec4(tri.hovered, ImGuiCol_HeaderHovered));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, toVec4(tri.active, ImGuiCol_HeaderActive));
        
        // Automatically adjust text color based on background luminance for optimal legibility
        // Use the base background color to determine text color (Option B: single text color)
        ImU32 baseBgColor = tri.base != 0 ? tri.base : ImGui::ColorConvertFloat4ToU32(styleRef.Colors[ImGuiCol_Header]);
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(baseBgColor);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
    };
    // === PRESET BROWSER ===
    pushHeaderColors(theme.headers.presets);
    bool presetsExpanded = ImGui::CollapsingHeader("Presets");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (presetsExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_presetScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##presetpath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##preset"))
        {
            presetPathChooser = std::make_unique<juce::FileChooser>("Select Preset Directory", m_presetScanPath);
            presetPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_presetScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("presetScanPath", m_presetScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##preset"))
        {
            m_presetManager.clearCache();
            m_presetManager.scanDirectory(m_presetScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_presetSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##preset", searchBuf, sizeof(searchBuf)))
            m_presetSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical preset tree
        drawPresetTree(m_presetManager.getRootNode());
    }
    
    // Helper lambda to recursively draw the directory tree for samples
    std::function<void(const SampleManager::DirectoryNode*)> drawSampleTree = 
        [&](const SampleManager::DirectoryNode* node)
    {
        if (!node || (node->samples.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawSampleTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw samples in this directory with drag-and-drop support
        for (const auto& sample : node->samples)
        {
            if (m_sampleSearchTerm.isEmpty() || sample.name.containsIgnoreCase(m_sampleSearchTerm))
            {
                // --- THIS IS THE HEROIC FIX ---

                // A. Draw the selectable item and capture its return value (which is true on mouse release).
                bool clicked = ImGui::Selectable(sample.name.toRawUTF8());

                // B. Check if this item is the source of a drag operation. This takes priority.
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload (the data we are transferring is the sample's file path).
                    const juce::String path = sample.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_SAMPLE_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback during the drag.
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Dragging: %s", sample.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // C. If a drag did NOT occur, and the item was clicked (mouse released on it), then create the node.
                else if (clicked)
                {
                    if (synth != nullptr)
                    {
                        auto newNodeId = synth->addModule("sample_loader");
                        auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                        pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                        if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                        {
                            sampleLoader->loadSample(sample.file);
                        }
                        snapshotAfterEditor = true;
                    }
                }
                
                // --- END OF FIX ---

                // (Existing tooltip for sample info remains the same)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Duration: %.2f s", sample.durationSeconds);
                    ImGui::Text("Rate: %d Hz", sample.sampleRate);
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // === SAMPLE BROWSER ===
    pushHeaderColors(theme.headers.samples);
    bool samplesExpanded = ImGui::CollapsingHeader("Samples");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (samplesExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_sampleScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##samplepath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##sample"))
        {
            samplePathChooser = std::make_unique<juce::FileChooser>("Select Sample Directory", m_sampleScanPath);
            samplePathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_sampleScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("sampleScanPath", m_sampleScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##sample"))
        {
            m_sampleManager.clearCache();
            m_sampleManager.scanDirectory(m_sampleScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_sampleSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##sample", searchBuf, sizeof(searchBuf)))
            m_sampleSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical sample tree
        drawSampleTree(m_sampleManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MIDI BROWSER ===
    pushHeaderColors(theme.headers.recent);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI Files");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (midiExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_midiScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##midipath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##midi"))
        {
            midiPathChooser = std::make_unique<juce::FileChooser>("Select MIDI Directory", m_midiScanPath);
            midiPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_midiScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("midiScanPath", m_midiScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##midi"))
        {
            m_midiManager.clearCache();
            m_midiManager.scanDirectory(m_midiScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_midiSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##midi", searchBuf, sizeof(searchBuf)))
            m_midiSearchTerm = juce::String(searchBuf);
        ImGui::Separator();
        // 5. Display hierarchical MIDI tree
        std::function<void(const MidiManager::DirectoryNode*)> drawMidiTree = 
            [&](const MidiManager::DirectoryNode* node)
        {
            if (!node || (node->midiFiles.empty() && node->subdirectories.empty())) return;

            // Draw subdirectories first
            for (const auto& subdir : node->subdirectories)
            {
                if (ImGui::TreeNode(subdir->name.toRawUTF8()))
                {
                    drawMidiTree(subdir.get());
                    ImGui::TreePop();
                }
            }
            
            // Then draw MIDI files in this directory with drag-and-drop support
            for (const auto& midi : node->midiFiles)
            {
                if (m_midiSearchTerm.isEmpty() || midi.name.containsIgnoreCase(m_midiSearchTerm))
                {
                    // Draw the selectable item and capture its return value
                    bool clicked = ImGui::Selectable(midi.name.toRawUTF8());

                    // Check if this item is the source of a drag operation
                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                    {
                        // Set the payload (the MIDI file path)
                        const juce::String path = midi.file.getFullPathName();
                        const std::string pathStr = path.toStdString();
                        ImGui::SetDragDropPayload("DND_MIDI_PATH", pathStr.c_str(), pathStr.length() + 1);
                        
                        // Provide visual feedback during the drag
                        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                        ImGui::Text("Dragging: %s", midi.name.toRawUTF8());
                        
                        ImGui::EndDragDropSource();
                    }
                    // If a drag did NOT occur, and the item was clicked, create a new MIDI Player node
                    else if (clicked)
                    {
                        if (synth != nullptr)
                        {
                            auto newNodeId = synth->addModule("midi_player");
                            auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                            pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                            
                            // Load the MIDI file into the new player
                            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                            {
                                midiPlayer->loadMIDIFile(midi.file);
                            }
                            
                            snapshotAfterEditor = true;
                        }
                    }
                    
                    // Tooltip for MIDI info (only shown when hovering, not dragging)
                    if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("MIDI File: %s", midi.file.getFileName().toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
            }
        };
        
        drawMidiTree(m_midiManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MODULE BROWSER ===
    pushHeaderColors(theme.headers.system);
    bool modulesExpanded = ImGui::CollapsingHeader("Modules", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (modulesExpanded)
    {
    
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
        
        // --- FIX: Show tooltip with module description on hover ---
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            
            // Find the description in our list using the module's internal 'type'
            bool found = false;
            for (const auto& pair : getModuleDescriptions())
            {
                if (pair.first.equalsIgnoreCase(type))
                {
                    // If found, display it
                    ImGui::TextUnformatted(pair.second);
                    found = true;
                    break;
                }
            }
            if (!found)
            {
                // Fallback text if a description is missing
                ImGui::TextUnformatted("No description available.");
            }
            
            ImGui::EndTooltip();
        }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODULE NAMING CONVENTION:
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
    // ALL module type names MUST follow this strict naming convention:
    //   ‚Ä¢ Use ONLY lowercase letters (a-z)
    //   ‚Ä¢ Use ONLY numbers (0-9) where appropriate
    //   ‚Ä¢ Replace ALL spaces with underscores (_)
    //   ‚Ä¢ NO capital letters allowed
    //   ‚Ä¢ NO hyphens or other special characters
    //
    // Examples:
    //   ‚úì CORRECT:   "midi_player", "sample_loader", "graphic_eq", "vco"
    //   ‚úó INCORRECT: "MIDI Player", "Sample Loader", "Graphic EQ", "VCO"
    //
    // This ensures consistent module identification across the system.
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. SOURCES - Signal generators and inputs
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Source);
    bool sourcesExpanded = ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (sourcesExpanded) {
        addModuleButton("VCO", "vco");
        addModuleButton("Polyphonic VCO", "polyvco");
        addModuleButton("Noise", "noise");
        addModuleButton("Audio Input", "audio_input");
        addModuleButton("Sample Loader", "sample_loader");
        addModuleButton("Value", "value");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. EFFECTS - Audio processing and tone shaping
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Effect);
    bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (effectsExpanded) {
        addModuleButton("VCF", "vcf");
        addModuleButton("Delay", "delay");
        addModuleButton("Reverb", "reverb");
        addModuleButton("Chorus", "chorus");
        addModuleButton("Phaser", "phaser");
        addModuleButton("Compressor", "compressor");
        addModuleButton("Limiter", "limiter");
        addModuleButton("Noise Gate", "gate");
        addModuleButton("Drive", "drive");
        addModuleButton("Graphic EQ", "graphic_eq");
        addModuleButton("Waveshaper", "waveshaper");
        addModuleButton("8-Band Shaper", "8bandshaper");
        addModuleButton("Granulator", "granulator");
        addModuleButton("Harmonic Shaper", "harmonic_shaper");
        addModuleButton("Time/Pitch Shifter", "timepitch");
        addModuleButton("De-Crackle", "de_crackle");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. MODULATORS - CV generation and modulation sources
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Modulator);
    bool modulatorsExpanded = ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (modulatorsExpanded) {
        addModuleButton("LFO", "lfo");
        addModuleButton("ADSR", "adsr");
        addModuleButton("Random", "random");
        addModuleButton("S&H", "s_and_h");
        addModuleButton("Function Generator", "function_generator");
        addModuleButton("Shaping Oscillator", "shaping_oscillator");
    }
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. UTILITIES & LOGIC - Signal processing and routing
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Utility);
    bool utilitiesExpanded = ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (utilitiesExpanded) {
        addModuleButton("VCA", "vca");
        addModuleButton("Mixer", "mixer");
        addModuleButton("CV Mixer", "cv_mixer");
        addModuleButton("Track Mixer", "track_mixer");
        addModuleButton("Attenuverter", "attenuverter");
        addModuleButton("Reroute", "reroute");
        addModuleButton("Lag Processor", "lag_processor");
        addModuleButton("Math", "math");
        addModuleButton("Map Range", "map_range");
        addModuleButton("Quantizer", "quantizer");
        addModuleButton("Rate", "rate");
        addModuleButton("Comparator", "comparator");
        addModuleButton("Logic", "logic");
        addModuleButton("Clock Divider", "clock_divider");
        addModuleButton("Sequential Switch", "sequential_switch");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. SEQUENCERS - Pattern and rhythm generation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Seq);
    bool sequencersExpanded = ImGui::CollapsingHeader("Sequencers", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (sequencersExpanded) {
        addModuleButton("Sequencer", "sequencer");
        addModuleButton("Multi Sequencer", "multi_sequencer");
        addModuleButton("Tempo Clock", "tempo_clock");
        addModuleButton("Snapshot Sequencer", "snapshot_sequencer");
        addModuleButton("Stroke Sequencer", "stroke_sequencer");
        addModuleButton("Timeline", "timeline");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. MIDI - MIDI input/output and controllers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::MIDI);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (midiExpanded) {
        addModuleButton("MIDI CV", "midi_cv");
        addModuleButton("MIDI Player", "midi_player");
        ImGui::Separator();
        addModuleButton("MIDI Faders", "midi_faders");
        addModuleButton("MIDI Knobs", "midi_knobs");
        addModuleButton("MIDI Buttons", "midi_buttons");
        addModuleButton("MIDI Jog Wheel", "midi_jog_wheel");
        addModuleButton("MIDI Pads", "midi_pads");
        ImGui::Separator();
        addModuleButton("MIDI Logger", "midi_logger");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 7. ANALYSIS - Signal visualization and debugging
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Analysis);
    bool analysisExpanded = ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (analysisExpanded) {
        addModuleButton("Scope", "scope");
        addModuleButton("Debug", "debug");
        addModuleButton("Input Debug", "input_debug");
        addModuleButton("Frequency Graph", "frequency_graph");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 8. TTS - Text-to-Speech and vocal synthesis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::TTS_Voice);
    bool ttsExpanded = ImGui::CollapsingHeader("TTS", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (ttsExpanded) {
        addModuleButton("TTS Performer", "tts_performer");
        addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 9. SPECIAL - Physics, animation, and experimental
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Special_Exp);
    bool specialExpanded = ImGui::CollapsingHeader("Special", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (specialExpanded) {
        addModuleButton("Physics", "physics");
        addModuleButton("Animation", "animation");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 10. COMPUTER VISION - Video processing and analysis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::OpenCV);
    bool openCVExpanded = ImGui::CollapsingHeader("Computer Vision", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (openCVExpanded) {
        ThemeText("Sources:", theme.text.section_header);
        addModuleButton("Webcam Loader", "webcam_loader");
        addModuleButton("Video File Loader", "video_file_loader");
        ImGui::Spacing();
        ThemeText("Processors:", theme.text.section_header);
        addModuleButton("Video FX", "video_fx");
        addModuleButton("Movement Detector", "movement_detector");
        addModuleButton("Human Detector", "human_detector");
        addModuleButton("Object Detector", "object_detector");
        addModuleButton("Pose Estimator", "pose_estimator");
        addModuleButton("Hand Tracker", "hand_tracker");
        addModuleButton("Face Tracker", "face_tracker");
        addModuleButton("Color Tracker", "color_tracker");
        addModuleButton("Contour Detector", "contour_detector");
        addModuleButton("Semantic Segmentation", "semantic_segmentation");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 11. PLUGINS / VST - Third-party audio plugins
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Plugin);
    bool pluginsExpanded = ImGui::CollapsingHeader("Plugins / VST", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (pluginsExpanded) {
        addPluginModules();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 12. SYSTEM - Patch organization and system utilities
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Sys);
    bool systemExpanded = ImGui::CollapsingHeader("System", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (systemExpanded) {
        // addModuleButton("Meta", "meta");
        // addModuleButton("Inlet", "inlet");
        // addModuleButton("Outlet", "outlet");
        addModuleButton("Comment", "comment");
        addModuleButton("Recorder", "recorder");
        addModuleButton("VST Host", "vst_host");
        ImGui::Separator();
        addModuleButton("Best Practice", "best_practice");
    }
    
    } // End of Modules collapsing header

    // End the scrolling region
    ImGui::EndChild();
    ImGui::NextColumn();
    // --- DEFINITIVE FIX FOR PRESET DRAG-AND-DROP WITH VISUAL FEEDBACK ---
    // Step 1: Define canvas dimensions first (needed for the drop target)
    // Get grid/canvas colors from theme
    auto& themeMgr = ThemeManager::getInstance();
    const ImU32 GRID_COLOR = themeMgr.getGridColor();
    const ImU32 GRID_ORIGIN_COLOR = themeMgr.getGridOriginColor();
    const float GRID_SIZE = themeMgr.getGridSize();
    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Cache canvas dimensions for modal pan logic later
    lastCanvasP0 = canvas_p0;
    lastCanvasSize = canvas_sz;

    // Step 2: Create a full-canvas invisible button to act as our drop area
    ImGui::SetCursorScreenPos(canvas_p0);
    ImGui::InvisibleButton("##canvas_drop_target", canvas_sz);

    const ImGuiStyle& style = ImGui::GetStyle();
    const ImU32 nodeBackground      = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_ChildBg]);
    const ImU32 nodeBackgroundHover = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_FrameBgHovered]);
    const ImU32 nodeBackgroundSel   = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_FrameBgActive]);
    const ImU32 nodeOutline         = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_Border]);

    auto& imnodesStyle = ImNodes::GetStyle();
    imnodesStyle.NodeCornerRounding = style.ChildRounding;
    imnodesStyle.NodeBorderThickness = style.FrameBorderSize;

    ImNodes::PushColorStyle(ImNodesCol_NodeBackground, nodeBackground);
    ImNodes::PushColorStyle(ImNodesCol_NodeBackgroundHovered, nodeBackgroundHover);
    ImNodes::PushColorStyle(ImNodesCol_NodeBackgroundSelected, nodeBackgroundSel);
    ImNodes::PushColorStyle(ImNodesCol_NodeOutline, nodeOutline);

    // Step 3: Make this area a drop target with visual feedback
    if (ImGui::BeginDragDropTarget())
    {
        // Check if a preset payload is being hovered over the canvas
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_PRESET_PATH", ImGuiDragDropFlags_AcceptBeforeDelivery))
        {
            // Draw a semi-transparent overlay to show the canvas is a valid drop zone
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            drawList->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getDropTargetOverlay());
            
            // Check if the mouse button was released to complete the drop
            if (payload->IsDelivery())
            {
                const char* path = (const char*)payload->Data;
                ImVec2 dropPos = ImGui::GetMousePos(); // Get the exact drop position
                mergePresetFromFile(juce::File(path), dropPos);
            }
        }
        ImGui::EndDragDropTarget();
    }
    // --- END OF DEFINITIVE FIX ---

    // Reset cursor position for subsequent drawing
    ImGui::SetCursorScreenPos(canvas_p0);

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinId({0, c.dstChan, true}) : 
                encodePinId({c.dstLogicalId, c.dstChan, true});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = themeMgr.getPinDisconnectedColor();
    const ImU32 colPinConnected = themeMgr.getPinConnectedColor();
    // <<< END OF BLOCK >>>

    // Pre-register is no longer needed - stateless encoding generates IDs on-the-fly
    // (Removed the old pre-registration loop)

    // --- BACKGROUND GRID AND COORDINATE DISPLAY ---
    // (Canvas dimensions already defined above in the drop target code)
    // Draw into the window draw list so colors aren't obscured by window bg
    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    // Note: EditorContextGetPanning() can only be called AFTER BeginNodeEditor()
    // Since we draw the grid before BeginNodeEditor, we use zero panning here
    // The grid will be drawn correctly after BeginNodeEditor is called
    ImVec2 panning = lastEditorPanning;

    // Node canvas bound to the underlying model if available
    // Hide ImNodes' own grid so we only render the custom one above.
    ImNodes::PushColorStyle(ImNodesCol_GridBackground, IM_COL32(0, 0, 0, 0));
    ImNodes::PushColorStyle(ImNodesCol_GridLine, IM_COL32(0, 0, 0, 0));
    ImNodes::PushColorStyle(ImNodesCol_GridLinePrimary, IM_COL32(0, 0, 0, 0));

    // Draw canvas background (behind everything)
    draw_list->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getCanvasBackground());

    // Draw grid lines
    for (float x = fmodf(panning.x, GRID_SIZE); x < canvas_sz.x; x += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p0.y + canvas_sz.y), GRID_COLOR);
    for (float y = fmodf(panning.y, GRID_SIZE); y < canvas_sz.y; y += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + y), GRID_SIZE);
    // Draw thicker lines for the origin (0,0)
    ImVec2 origin_on_screen = ImVec2(canvas_p0.x + panning.x, canvas_p0.y + panning.y);
    draw_list->AddLine(ImVec2(origin_on_screen.x, canvas_p0.y), ImVec2(origin_on_screen.x, canvas_p1.y), GRID_ORIGIN_COLOR, 2.0f);
    draw_list->AddLine(ImVec2(canvas_p0.x, origin_on_screen.y), ImVec2(canvas_p1.x, origin_on_screen.y), GRID_ORIGIN_COLOR, 2.0f);
    // Draw scale markers every SCALE_INTERVAL grid units as a grid (not a cross)
    const float SCALE_INTERVAL = themeMgr.getScaleInterval();
    const ImU32 SCALE_TEXT_COLOR = themeMgr.getScaleTextColor();
    ImDrawList* fg_draw_list = ImGui::GetForegroundDrawList();
    // X-axis scale markers - always at the bottom edge
    float gridLeft = -panning.x;
    float gridRight = canvas_sz.x - panning.x;
    int startX = (int)std::floor(gridLeft / SCALE_INTERVAL);
    int endX = (int)std::ceil(gridRight / SCALE_INTERVAL);
    for (int i = startX; i <= endX; ++i)
    {
        float gridX = i * SCALE_INTERVAL;
        float screenX = canvas_p0.x + panning.x + gridX;
        
        // Only draw if visible on screen
        if (screenX >= canvas_p0.x && screenX <= canvas_p1.x)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridX);
            // Always draw at bottom edge
            fg_draw_list->AddText(ImVec2(screenX + 2, canvas_p1.y - 45), SCALE_TEXT_COLOR, label);
        }
    }
    
    // Y-axis scale markers - always at the left edge
    float gridTop = -panning.y;
    float gridBottom = canvas_sz.y - panning.y;
    int startY = (int)std::floor(gridTop / SCALE_INTERVAL);
    int endY = (int)std::ceil(gridBottom / SCALE_INTERVAL);
    
    for (int i = startY; i <= endY; ++i)
    {
        float gridY = i * SCALE_INTERVAL;
        float screenY = canvas_p0.y + panning.y + gridY;
        
        // Only draw if visible on screen
        if (screenY >= canvas_p0.y && screenY <= canvas_p1.y)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridY);
            // Always draw at left edge
            fg_draw_list->AddText(ImVec2(canvas_p0.x + 5, screenY + 2), SCALE_TEXT_COLOR, label);
        }
    }
    // Mouse coordinate display overlay (bottom-left)
    ImVec2 mouseScreenPos = ImGui::GetMousePos();
    ImVec2 mouseGridPos = ImVec2(mouseScreenPos.x - canvas_p0.x - panning.x, mouseScreenPos.y - canvas_p0.y - panning.y);
    char posStr[32];
    snprintf(posStr, sizeof(posStr), "%.0f, %.0f", mouseGridPos.x, mouseGridPos.y);
    // Use the foreground draw list to ensure text is on top of everything
    // Position at bottom-left: canvas_p1.y is bottom edge, subtract text height plus padding
    ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), themeMgr.getMousePositionText(), posStr);
    // --- END OF BACKGROUND GRID AND COORDINATE DISPLAY ---
    // Node canvas bound to the underlying model if available
    // Keep ImNodes' background/panning grid visible, but colour-match to theme overrides.
    ImNodes::PushColorStyle(ImNodesCol_GridBackground, themeMgr.getCanvasBackground());
    ImNodes::PushColorStyle(ImNodesCol_GridLine, GRID_COLOR);
    ImNodes::PushColorStyle(ImNodesCol_GridLinePrimary, GRID_ORIGIN_COLOR);
    ImNodes::PushColorStyle(ImNodesCol_BoxSelector, themeMgr.getSelectionRect());
    ImNodes::PushColorStyle(ImNodesCol_BoxSelectorOutline, themeMgr.getSelectionRectOutline());
    // === END OF FIX ===
    ImNodes::BeginNodeEditor();
    lastEditorPanning = ImNodes::EditorContextGetPanning();
    // Now we can safely get the actual panning for any future use
    // (Grid is already drawn with zero panning above, which is fine for background)
    // Begin the editor
    // +++ ADD THIS LINE AT THE START OF THE RENDER LOOP +++
    attrPositions.clear(); // Clear the cache at the beginning of each frame.
    auto cancelDragInsert = [this]()
    {
        dragInsertActive = false;
        dragInsertStartAttrId = -1;
        dragInsertStartPin = PinID{};
        shouldOpenDragInsertPopup = false;
    };
    // Rebuild mod attribute mapping from currently drawn nodes only
    // modAttrToParam.clear(); // TODO: Remove when fully migrated
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    // Track duplicates to diagnose disappearing pins
    std::unordered_set<int> seenAttrs;
    auto linkIdOf = [this] (int srcAttr, int dstAttr) -> int
    {
        return getLinkId(srcAttr, dstAttr);
    };
    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                if (!(x == 0.0f && y == 0.0f))
                    pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        // Graph is now always in consistent state since we rebuild at frame start
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;
            juce::String moduleLabel = type + " [lid=" + juce::String((int) lid) + "]";

            // Color-code modules by category (base colors)
            const auto moduleCategory = getModuleCategory(type);
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, getImU32ForCategory(moduleCategory));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));

            // Highlight nodes participating in the hovered link (overrides category color)
            const bool isHoveredSource = (hoveredLinkSrcId != 0 && hoveredLinkSrcId == (juce::uint32) lid);
            const bool isHoveredDest   = (hoveredLinkDstId != 0 && hoveredLinkDstId == (juce::uint32) lid);
            if (isHoveredSource || isHoveredDest)
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));

            // Visual feedback for muted nodes (overrides category color and hover)
            const bool isMuted = mutedNodeStates.count(lid) > 0;
            if (isMuted) {
                ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(80, 80, 80, 255));
            }

#if JUCE_DEBUG
            gLastRenderedNodeLabel = moduleLabel;
#endif
            ImNodes::BeginNode ((int) lid);
#if JUCE_DEBUG
            ++gImNodesNodeDepth;
#endif
            ImNodes::BeginNodeTitleBar();
            // Special handling for reroute nodes: show dynamic type in name
            if (type.equalsIgnoreCase("reroute"))
            {
                if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(lid)))
                {
                    PinDataType passthroughType = reroute->getPassthroughType();
                    juce::String typeName;
                    switch (passthroughType)
                    {
                        case PinDataType::CV:    typeName = "CV"; break;
                        case PinDataType::Audio: typeName = "Audio"; break;
                        case PinDataType::Gate:  typeName = "Gate"; break;
                        case PinDataType::Raw:   typeName = "Raw"; break;
                        case PinDataType::Video: typeName = "Video"; break;
                        default:                 typeName = "Audio"; break;
                    }
                    juce::String displayName = "Reroute " + typeName;
                    ImGui::TextUnformatted(displayName.toRawUTF8());
                }
                else
                {
                    ImGui::TextUnformatted(type.toRawUTF8());
                }
            }
            else
            {
                ImGui::TextUnformatted(type.toRawUTF8());
            }
            ImNodes::EndNodeTitleBar();

            // Get node content width - check if module has custom size, otherwise use default
            float nodeContentWidth = 240.0f; // Default width
            if (auto* mp = synth->getModuleForLogical(lid))
            {
                ImVec2 customSize = mp->getCustomNodeSize();
                if (customSize.x > 0.0f) // Module specified a custom width
                {
                    nodeContentWidth = customSize.x;
                }
            }

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
if (auto* mp = synth->getModuleForLogical (lid))
{
    ImGui::PushID ((int) lid);
#if JUCE_DEBUG
    ImGuiStackBalanceChecker parameterStackGuard;
    ImNodesDepthSnapshot depthSnapshot(moduleLabel + "::drawParametersInNode");
#endif

    // This new lambda function checks if a parameter is being modulated
    auto isParamModulated = [&](const juce::String& paramId) -> bool {
        if (!synth) return false;
        if (auto* mp = synth->getModuleForLogical(lid))
        {
            int busIdx = -1, chInBus = -1;
            // Use the new standardized routing API on the module itself
            if (!mp->getParamRouting(paramId, busIdx, chInBus)) 
                return false;

            // Calculate the absolute channel index that the graph uses for this bus/channel pair
            const int absoluteChannelIndex = mp->getChannelIndexInProcessBlockBuffer(true, busIdx, chInBus);
            if (absoluteChannelIndex < 0) return false;
            
            // Scan the simple graph connections for a match
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == lid && c.dstChan == absoluteChannelIndex)
                    return true;
            }
        }
        return false;
    };

    // Helper to read a live, modulated value if available (respects _mod alias)
    auto getLiveValueOr = [&](const juce::String& paramId, float fallback) -> float
    {
        if (!synth) return fallback;
        if (auto* mp = synth->getModuleForLogical(lid))
            return mp->getLiveParamValueFor(paramId + "_mod", paramId + "_live", fallback);
        return fallback;
    };
    // Create a new function that calls pushSnapshot
    auto onModificationEnded = [&](){ this->pushSnapshot(); };
    // --- SPECIAL RENDERING FOR SAMPLE LOADER ---
    if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (buttons, sliders, etc.)
        // We pass a modified onModificationEnded to avoid creating undo states while dragging.
        sampleLoader->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);

        // Now, handle the spectrogram texture and drawing
        juce::OpenGLTexture* texturePtr = nullptr;
        if (auto it = sampleLoaderTextureIds.find((int)lid); it != sampleLoaderTextureIds.end())
            texturePtr = it->second.get();

        juce::Image spectrogram = sampleLoader->getSpectrogramImage();
        if (spectrogram.isValid())
        {
            if (texturePtr == nullptr)
            {
                auto tex = std::make_unique<juce::OpenGLTexture>();
                texturePtr = tex.get();
                sampleLoaderTextureIds[(int)lid] = std::move(tex);
            }
            // Upload or update texture from JUCE image (handles format & parameters internally)
            texturePtr->loadImage(spectrogram);

            ImGui::Image((void*)(intptr_t) texturePtr->getTextureID(), ImVec2(nodeContentWidth, 100.0f));

            // Drag state is tracked per Sample Loader node to avoid cross-node interference
            static std::unordered_map<int,int> draggedHandleByNode; // lid -> -1,0,1
            int& draggedHandle = draggedHandleByNode[(int) lid];
            if (draggedHandle != 0 && draggedHandle != 1) draggedHandle = -1;
            ImGui::SetCursorScreenPos(ImGui::GetItemRectMin());
            ImGui::InvisibleButton("##spectrogram_interaction", ImVec2(nodeContentWidth, 100.0f));

            auto* drawList = ImGui::GetWindowDrawList();
            const ImVec2 rectMin = ImGui::GetItemRectMin();
            const ImVec2 rectMax = ImGui::GetItemRectMax();

            float startNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeStart")->load();
            float endNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeEnd")->load();

            // Use live telemetry values when modulated
            startNorm = sampleLoader->getLiveParamValueFor("rangeStart_mod", "rangeStart_live", startNorm);
            endNorm = sampleLoader->getLiveParamValueFor("rangeEnd_mod", "rangeEnd_live", endNorm);

            // Visual guard even when modulated
            const float kMinGap = 0.001f;
            startNorm = juce::jlimit(0.0f, 1.0f, startNorm);
            endNorm   = juce::jlimit(0.0f, 1.0f, endNorm);
            if (startNorm >= endNorm)
            {
                if (startNorm <= 1.0f - kMinGap)
                    endNorm = juce::jmin(1.0f, startNorm + kMinGap);
                else
                    startNorm = juce::jmax(0.0f, endNorm - kMinGap);
            }

            // --- FIX FOR BUG 1: Separate modulation checks for each handle ---
            bool startIsModulated = isParamModulated("rangeStart_mod");
            bool endIsModulated = isParamModulated("rangeEnd_mod");

            const bool itemHovered = ImGui::IsItemHovered();
            const bool itemActive  = ImGui::IsItemActive();
            if (itemHovered)
            {
                ImVec2 mousePos = ImGui::GetMousePos();
                float startHandleX = rectMin.x + startNorm * nodeContentWidth;
                float endHandleX = rectMin.x + endNorm * nodeContentWidth;

                bool canDragStart = !startIsModulated && (std::abs(mousePos.x - startHandleX) < 5);
                bool canDragEnd = !endIsModulated && (std::abs(mousePos.x - endHandleX) < 5);

                if (draggedHandle == -1 && (canDragStart || canDragEnd))
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                }

                if (ImGui::IsItemClicked())
                {
                    // Only allow dragging to start if the corresponding handle is not modulated
                    if (canDragStart && canDragEnd)
                        draggedHandle = (std::abs(mousePos.x - startHandleX) < std::abs(mousePos.x - endHandleX)) ? 0 : 1;
                    else if (canDragStart)
                        draggedHandle = 0;
                    else if (canDragEnd)
                        draggedHandle = 1;
                }
            }

            if (itemActive && ImGui::IsMouseReleased(0))
            {
                if (draggedHandle != -1) onModificationEnded();
                draggedHandle = -1;
            }

            // Handle the drag update, checking the specific modulation flag for the active handle
            if (itemActive && draggedHandle != -1 && ImGui::IsMouseDragging(0))
            {
                float newNormX = juce::jlimit(0.0f, 1.0f, (ImGui::GetMousePos().x - rectMin.x) / nodeContentWidth);
                if (draggedHandle == 0 && !startIsModulated)
                {
                    // Guard: start cannot be >= end
                    startNorm = juce::jmin(newNormX, endNorm - 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeStart")->setValueNotifyingHost(startNorm);
                }
                else if (draggedHandle == 1 && !endIsModulated)
                {
                    // Guard: end cannot be <= start
                    endNorm = juce::jmax(newNormX, startNorm + 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeEnd")->setValueNotifyingHost(endNorm);
                }
            }

            float startX = rectMin.x + startNorm * nodeContentWidth;
            float endX = rectMin.x + endNorm * nodeContentWidth;
            drawList->AddRectFilled(rectMin, ImVec2(startX, rectMax.y), IM_COL32(0, 0, 0, 120));
            drawList->AddRectFilled(ImVec2(endX, rectMin.y), rectMax, IM_COL32(0, 0, 0, 120));
            drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
            drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
        }
    }
    // --- SPECIAL RENDERING FOR AUDIO INPUT (MULTI-CHANNEL) ---
    else if (auto* audioIn = dynamic_cast<AudioInputModuleProcessor*>(mp))
    {
        auto& apvts = audioIn->getAPVTS();

        // --- Device Selectors ---
        juce::AudioDeviceManager::AudioDeviceSetup setup;
        deviceManager.getAudioDeviceSetup(setup);
        
        // Input Device
        juce::StringArray availableInputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableInputDevices = deviceType->getDeviceNames(true);
        }
        std::vector<const char*> inputDeviceItems;
        for (const auto& name : availableInputDevices) inputDeviceItems.push_back(name.toRawUTF8());
        int currentInputDeviceIndex = availableInputDevices.indexOf(setup.inputDeviceName);
        if (currentInputDeviceIndex < 0) currentInputDeviceIndex = 0;

        ImGui::PushItemWidth(nodeContentWidth);
        if (ImGui::Combo("Input Device", &currentInputDeviceIndex, inputDeviceItems.data(), (int)inputDeviceItems.size())) {
            if (currentInputDeviceIndex < availableInputDevices.size()) {
                setup.inputDeviceName = availableInputDevices[currentInputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }

        // Output Device
        juce::StringArray availableOutputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableOutputDevices = deviceType->getDeviceNames(false);
        }
        std::vector<const char*> outputDeviceItems;
        for (const auto& name : availableOutputDevices) outputDeviceItems.push_back(name.toRawUTF8());
        int currentOutputDeviceIndex = availableOutputDevices.indexOf(setup.outputDeviceName);
        if (currentOutputDeviceIndex < 0) currentOutputDeviceIndex = 0;
        
        if (ImGui::Combo("Output Device", &currentOutputDeviceIndex, outputDeviceItems.data(), (int)outputDeviceItems.size())) {
            if (currentOutputDeviceIndex < availableOutputDevices.size()) {
                setup.outputDeviceName = availableOutputDevices[currentOutputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }
        
        // --- Channel Count ---
        auto* numChannelsParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("numChannels"));
        int numChannels = numChannelsParam->get();
        if (ImGui::SliderInt("Channels", &numChannels, 1, AudioInputModuleProcessor::MAX_CHANNELS)) {
            *numChannelsParam = numChannels;
            onModificationEnded();
        }
        
        // --- Threshold Sliders ---
        auto* gateThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"));
        float gateThresh = gateThreshParam->get();
        if (ImGui::SliderFloat("Gate Threshold", &gateThresh, 0.0f, 1.0f, "%.3f")) {
            *gateThreshParam = gateThresh;
            onModificationEnded();
        }
        
        auto* trigThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("triggerThreshold"));
        float trigThresh = trigThreshParam->get();
        if (ImGui::SliderFloat("Trigger Threshold", &trigThresh, 0.0f, 1.0f, "%.3f")) {
            *trigThreshParam = trigThresh;
            onModificationEnded();
        }
        
        ImGui::PopItemWidth();

        // --- Dynamic Channel Selectors & VU Meters ---
        auto hardwareChannels = deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getInputChannelNames() : juce::StringArray{};
        if (!hardwareChannels.isEmpty())
        {
            std::vector<const char*> hwChannelItems;
            for (const auto& name : hardwareChannels) hwChannelItems.push_back(name.toRawUTF8());
            
            for (int i = 0; i < numChannels; ++i) {
                auto* mappingParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(i)));
                int selectedHwChannel = mappingParam->get();
                selectedHwChannel = juce::jlimit(0, (int)hwChannelItems.size() - 1, selectedHwChannel);

                ImGui::PushID(i);
                ImGui::PushItemWidth(nodeContentWidth * 0.6f);
                if (ImGui::Combo(("Input for Out " + juce::String(i + 1)).toRawUTF8(), &selectedHwChannel, hwChannelItems.data(), (int)hwChannelItems.size())) {
                    *mappingParam = selectedHwChannel;
                    std::vector<int> newMapping(numChannels);
                    for (int j = 0; j < numChannels; ++j) {
                        auto* p = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(j)));
                        newMapping[j] = p->get();
                    }
                    synth->setAudioInputChannelMapping(synth->getNodeIdForLogical(lid), newMapping);
                    onModificationEnded();
                }
                ImGui::PopItemWidth();

                ImGui::SameLine();
                
                // --- VU Meter with Threshold Lines ---
                float level = (i < (int)audioIn->channelLevels.size() && audioIn->channelLevels[i]) ? audioIn->channelLevels[i]->load() : 0.0f;
                ImVec2 meterSize(nodeContentWidth * 0.38f, ImGui::GetTextLineHeightWithSpacing() * 0.8f);
                ImGui::ProgressBar(level, meterSize, "");

                // Draw threshold lines on top of the progress bar
                ImVec2 p_min = ImGui::GetItemRectMin();
                ImVec2 p_max = ImGui::GetItemRectMax();
                ImDrawList* draw_list = ImGui::GetWindowDrawList();

                // Gate Threshold (Yellow)
                float gateLineX = p_min.x + gateThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);

                // Trigger Threshold (Orange)
                float trigLineX = p_min.x + trigThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
                
                ImGui::PopID();
            }
        }
    }
    // --- SPECIAL RENDERING FOR OPENCV MODULES (WITH VIDEO FEED) ---
    else if (auto* webcamModule = dynamic_cast<WebcamLoaderModule*>(mp))
    {
        juce::Image frame = webcamModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        webcamModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* videoFileModule = dynamic_cast<VideoFileLoaderModule*>(mp))
    {
        juce::Image frame = videoFileModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        videoFileModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* movementModule = dynamic_cast<MovementDetectorModule*>(mp))
    {
        juce::Image frame = movementModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        movementModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* humanModule = dynamic_cast<HumanDetectorModule*>(mp))
    {
        juce::Image frame = humanModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        humanModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* poseModule = dynamic_cast<PoseEstimatorModule*>(mp))
    {
        juce::Image frame = poseModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        poseModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* colorModule = dynamic_cast<ColorTrackerModule*>(mp))
    {
        juce::Image frame = colorModule->getLatestFrame();
        if (!frame.isNull())
        {
            static std::map<int, int> hoverRadiusByNode; // logicalId -> radius (half-size), default 2 => 5x5
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));

                // Handle color picker clicks when active
                if (colorModule->isPickerActive() && ImGui::IsItemHovered())
                {
                    ImGui::SetTooltip("Click to pick a color from the video");
                    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
                    {
                        ImVec2 mousePos = ImGui::GetMousePos();
                        ImVec2 itemMin = ImGui::GetItemRectMin();
                        ImVec2 itemSize = ImGui::GetItemRectSize();
                        float nx = (mousePos.x - itemMin.x) / itemSize.x;
                        float ny = (mousePos.y - itemMin.y) / itemSize.y;
                        nx = juce::jlimit(0.0f, 1.0f, nx);
                        ny = juce::jlimit(0.0f, 1.0f, ny);
                        // Use ny directly (no flip) to align clicks with displayed image
                        int px = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                        int py = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());
                        juce::Logger::writeToLog(juce::String("[ColorTracker][UI] nx=") + juce::String(nx, 3) + ", ny=" + juce::String(ny, 3) +
                                                  ", px=" + juce::String(px) + ", py=" + juce::String(py));
                        colorModule->addColorAt(px, py);
                        colorModule->exitPickerMode();
                    }
                }

                // Hover preview: median/average color swatch and scroll-wheel radius control
                if (ImGui::IsItemHovered())
                {
                    // Update radius by mouse wheel
                    int& rad = hoverRadiusByNode[(int)lid]; if (rad <= 0) rad = 2;
                    float wheel = ImGui::GetIO().MouseWheel;
                    if (wheel != 0.0f)
                    {
                        rad += (wheel > 0) ? 1 : -1;
                        rad = juce::jlimit(1, 30, rad); // (2*rad+1)^2 window, max 61x61
                    }

                    // Map mouse to pixel
                    ImVec2 mousePos = ImGui::GetMousePos();
                    ImVec2 itemMin = ImGui::GetItemRectMin();
                    ImVec2 itemSize = ImGui::GetItemRectSize();
                    float nx = (mousePos.x - itemMin.x) / itemSize.x;
                    float ny = (mousePos.y - itemMin.y) / itemSize.y;
                    nx = juce::jlimit(0.0f, 1.0f, nx);
                    ny = juce::jlimit(0.0f, 1.0f, ny);
                    int cx = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                    int cy = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());

                    // Sample ROI from juce::Image
                    std::vector<int> vr, vg, vb; vr.reserve((2*rad+1)*(2*rad+1)); vg.reserve(vr.capacity()); vb.reserve(vr.capacity());
                    juce::Image::BitmapData bd(frame, juce::Image::BitmapData::readOnly);
                    auto clampi = [](int v, int lo, int hi){ return (v < lo) ? lo : (v > hi ? hi : v); };
                    for (int y = cy - rad; y <= cy + rad; ++y)
                    {
                        int yy = clampi(y, 0, frame.getHeight()-1);
                        const juce::PixelARGB* row = (const juce::PixelARGB*)(bd.getLinePointer(yy));
                        for (int x = cx - rad; x <= cx + rad; ++x)
                        {
                            int xx = clampi(x, 0, frame.getWidth()-1);
                            const juce::PixelARGB& p = row[xx];
                            vr.push_back(p.getRed());
                            vg.push_back(p.getGreen());
                            vb.push_back(p.getBlue());
                        }
                    }
                    auto median = [](std::vector<int>& v){ std::nth_element(v.begin(), v.begin()+v.size()/2, v.end()); return v[v.size()/2]; };
                    int mr = median(vr), mg = median(vg), mb = median(vb);
                    juce::Colour mc((juce::uint8)mr, (juce::uint8)mg, (juce::uint8)mb);
                    float h = mc.getHue(), s = mc.getSaturation(), b = mc.getBrightness();

                    // Tooltip near cursor with swatch and numbers
                    ImGui::BeginTooltip();
                    ImGui::Text("(%d,%d) rad=%d", cx, cy, rad);
                    ImGui::ColorButton("##hoverSwatch", ImVec4(mc.getFloatRed(), mc.getFloatGreen(), mc.getFloatBlue(), 1.0f), 0, ImVec2(22,22));
                    ImGui::SameLine();
                    ImGui::Text("RGB %d,%d,%d\nHSV %d,%d,%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f));
                    ImGui::EndTooltip();

                    // Textual summary under the image (lightweight)
                    ImGui::TextDisabled("Hover RGB %d,%d,%d  HSV %d,%d,%d  rad=%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f), rad);
                }
            }
        }
        colorModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* contourModule = dynamic_cast<ContourDetectorModule*>(mp))
    {
        juce::Image frame = contourModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        contourModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* segModule = dynamic_cast<SemanticSegmentationModule*>(mp))
    {
        juce::Image frame = segModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        segModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* objModule = dynamic_cast<ObjectDetectorModule*>(mp))
    {
        juce::Image frame = objModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        objModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* handModule = dynamic_cast<HandTrackerModule*>(mp))
    {
        juce::Image frame = handModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        handModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* faceModule = dynamic_cast<FaceTrackerModule*>(mp))
    {
        juce::Image frame = faceModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        faceModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* fxModule = dynamic_cast<VideoFXModule*>(mp))
    {
        juce::Image frame = fxModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                // Flip Y-coords for correct orientation
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        // Now draw the regular parameters below the video
        fxModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* cropVideoModule = dynamic_cast<CropVideoModule*>(mp))
    {
        // CropVideoModule handles its own preview rendering with interaction in drawParametersInNode
        cropVideoModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else
    {
        mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);
    }
#if JUCE_DEBUG
    parameterStackGuard.validate(moduleLabel + "::drawParametersInNode");
#endif
    ImGui::Spacing();
    ImGui::PopID();
}
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
            
            // Helper to draw right-aligned text within a node's content width
            // From imnodes examples (color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73):
            // Use ImGui::Indent() for right-alignment - this is the CORRECT ImNodes pattern!
            auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
            {
                const ImVec2 textSize = ImGui::CalcTextSize(txt);
                
                // Indent by (nodeWidth - textWidth) to right-align the text
                // CRITICAL: Must call Unindent() to prevent indent from persisting!
                const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
                ImGui::Indent(indentAmount);
                ImGui::TextUnformatted(txt);
                ImGui::Unindent(indentAmount);  // Reset indent!
            };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinId({lid, channel, true});
                seenAttrs.insert(attr);
                availableAttrs.insert(attr);

                // Get pin data type for color coding
                PinID pinId = { lid, channel, true, false, "" };
                PinDataType pinType = this->getPinDataTypeForPin(pinId);
                unsigned int pinColor = this->getImU32ForType(pinType);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                ImNodes::BeginInputAttribute(attr);
#if JUCE_DEBUG
                ++gImNodesInputDepth;
#endif
                ImGui::TextUnformatted(label);
                ImNodes::EndInputAttribute();
#if JUCE_DEBUG
                --gImNodesInputDepth;
                jassert(gImNodesInputDepth >= 0);
#endif

                // --- THIS IS THE DEFINITIVE FIX ---
                // Get the bounding box of the pin circle that was just drawn.
                ImVec2 pinMin = ImGui::GetItemRectMin();
                ImVec2 pinMax = ImGui::GetItemRectMax();
                // Calculate the exact center and cache it.
                float centerX = (pinMin.x + pinMax.x) * 0.5f;
                float centerY = (pinMin.y + pinMax.y) * 0.5f;
                attrPositions[attr] = ImVec2(centerX, centerY);
                // --- END OF FIX ---

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ThemeText("Connected", theme.text.active);
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                // CRASH FIX: Verify module exists before accessing it
                                if (c.srcLogicalId != 0 && synth != nullptr)
                                {
                                    bool moduleExists = false;
                                    for (const auto& modInfo : synth->getModulesInfo())
                                    {
                                        if (modInfo.first == c.srcLogicalId)
                                        {
                                            moduleExists = true;
                                            break;
                                        }
                                    }
                                    
                                    if (moduleExists)
                                    {
                                        if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                        {
                                            float value = srcMod->getOutputChannelValue(c.srcChan);
                                            ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                            ImGui::Text("Value: %.3f", value);
                                        }
                                    }
                                }
                                break; 
                            }
                        }
                    } else {
                        ThemeText("Not Connected", theme.text.disabled);
                    }
                    // Show pin data type
                    ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                    ImGui::EndTooltip();
                }
            };

                // NEW CLEAN OUTPUT PIN TEXT FUNCTION - FIXED SPACING
                helpers.drawAudioOutputPin = [&](const char* label, int channel)
                {
                    const int attr = encodePinId({(juce::uint32)lid, channel, false});
                    seenAttrs.insert(attr);
                    availableAttrs.insert(attr);

                    PinID pinId = {(juce::uint32)lid, channel, false, false, ""};
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(attr) > 0;

                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                    // EXACT OFFICIAL PATTERN: Text right-aligned, pin touches text edge
                    ImNodes::BeginOutputAttribute(attr);
#if JUCE_DEBUG
                    ++gImNodesOutputDepth;
#endif
                    const float label_width = ImGui::CalcTextSize(label).x;
                    ImGui::Indent(nodeContentWidth - label_width);  // Right-align to content width
                    ImGui::TextUnformatted(label);
                    ImGui::Unindent(nodeContentWidth - label_width);
                    ImNodes::EndOutputAttribute();
#if JUCE_DEBUG
                    --gImNodesOutputDepth;
                    jassert(gImNodesOutputDepth >= 0);
#endif

                    // Cache pin center
                    {
                        ImVec2 pinMin = ImGui::GetItemRectMin();
                        ImVec2 pinMax = ImGui::GetItemRectMax();
                        float centerY = (pinMin.y + pinMax.y) * 0.5f;
                        float x_pos   = pinMax.x;
                        attrPositions[attr] = ImVec2(x_pos, centerY);
                    }

                    ImNodes::PopColorStyle();

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                    if (isConnected) {
                        ThemeText("Connected", theme.text.active);
                    } else {
                        ThemeText("Not Connected", theme.text.disabled);
                        }
                        ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                        if (auto* mp = synth->getModuleForLogical(lid))
                        {
                            float value = mp->getOutputChannelValue(channel);
                            ImGui::Text("Value: %.3f", value);
                        }
                        ImGui::EndTooltip();
                    }
                };

            // ADD THE NEW drawParallelPins HELPER
            helpers.drawParallelPins = [&](const char* inLabel, int inChannel, const char* outLabel, int outChannel)
            {
                // 3-column layout: [InputPin] [Right-aligned Output Label] [Output Pin]
                ImGui::PushID((inChannel << 16) ^ outChannel ^ lid);
                ImGui::Columns(3, "parallel_io_layout", false);

                const float pinW = 18.0f;
                const float spacing = ImGui::GetStyle().ItemSpacing.x;
                // CRITICAL FIX: Use stable nodeContentWidth to set ALL column widths explicitly
                // This prevents the feedback loop that causes position-dependent node scaling
                
                // Calculate column widths to fill exactly nodeContentWidth
                float inTextW = inLabel ? ImGui::CalcTextSize(inLabel).x : 0.0f;
                float inColW = inLabel ? (inTextW + pinW + spacing) : 0.0f;  // Input label + pin + spacing
                float outPinColW = 20.0f;  // Output pin column (fixed narrow width)
                float labelColW = nodeContentWidth - inColW - outPinColW - spacing;  // Middle fills remaining space

                ImGui::SetColumnWidth(0, inColW);
                ImGui::SetColumnWidth(1, labelColW);
                ImGui::SetColumnWidth(2, outPinColW);

                // Column 0: Input pin with label
                if (inLabel != nullptr)
                {
                    int inAttr = encodePinId({lid, inChannel, true});
                    seenAttrs.insert(inAttr);
                    availableAttrs.insert(inAttr);
                    PinID pinId = { lid, inChannel, true, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedInputAttrs.count(inAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginInputAttribute(inAttr);
#if JUCE_DEBUG
                    ++gImNodesInputDepth;
#endif
                    ImGui::TextUnformatted(inLabel);
                    ImNodes::EndInputAttribute();
#if JUCE_DEBUG
                    --gImNodesInputDepth;
                    jassert(gImNodesInputDepth >= 0);
#endif
                    ImNodes::PopColorStyle();
                }

                // Column 1: Output label (right-aligned within this column)
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    // EXACT OFFICIAL PATTERN: Same as regular output pins
                    const float textW = ImGui::CalcTextSize(outLabel).x;
                    ImGui::Indent(labelColW - textW);  // Right-align to column width
                    ImGui::TextUnformatted(outLabel);
                    ImGui::Unindent(labelColW - textW);
                }

                // Column 2: Output pin
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    int outAttr = encodePinId({lid, outChannel, false});
                    seenAttrs.insert(outAttr);
                    availableAttrs.insert(outAttr);
                    PinID pinId = { lid, outChannel, false, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(outAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
#if JUCE_DEBUG
                    ++gImNodesOutputDepth;
#endif
                    ImNodes::BeginOutputAttribute(outAttr);
                    ImGui::Dummy(ImVec2(1.0f, ImGui::GetTextLineHeight()));
                    ImNodes::EndOutputAttribute();
#if JUCE_DEBUG
                    --gImNodesOutputDepth;
                    jassert(gImNodesOutputDepth >= 0);
#endif

                    // Cache pin center
                    ImVec2 pinMin = ImGui::GetItemRectMin();
                    ImVec2 pinMax = ImGui::GetItemRectMax();
                    float yCenter = pinMin.y + (pinMax.y - pinMin.y) * 0.5f;
                    float xPos = pinMax.x;
                    attrPositions[outAttr] = ImVec2(xPos, yCenter);
                    ImNodes::PopColorStyle();
                }

                // Restore to single column for the next row
                ImGui::Columns(1);
                ImGui::PopID();
            };

            // --- DYNAMIC PIN FIX ---
            // Add a new helper that uses dynamic pin information from modules
            helpers.drawIoPins = [&](ModuleProcessor* module) {
                if (!module) return;
                const auto logicalId = module->getLogicalId();
                const auto moduleType = synth->getModuleTypeForLogical(logicalId);

                // 1. Get dynamic pins from the module itself.
                auto dynamicInputs = module->getDynamicInputPins();
                auto dynamicOutputs = module->getDynamicOutputPins();

                // 2. Get static pins from the database as a fallback.
                const auto& pinDb = getModulePinDatabase();
                auto pinInfoIt = pinDb.find(moduleType.toLowerCase());
                const bool hasStaticPinInfo = (pinInfoIt != pinDb.end());
                const auto& staticPinInfo = hasStaticPinInfo ? pinInfoIt->second : ModulePinInfo{};

                // 3. If the module has dynamic pins, use the new system
                const bool hasDynamicPins = !dynamicInputs.empty() || !dynamicOutputs.empty();
                
                if (hasDynamicPins)
                {
                    // Draw inputs (dynamic if available, otherwise static)
                    if (!dynamicInputs.empty())
                    {
                        for (const auto& pin : dynamicInputs)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioIns)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    
                    // Draw outputs (dynamic if available, otherwise static)
                    if (!dynamicOutputs.empty())
                    {
                        for (const auto& pin : dynamicOutputs)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioOuts)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                }
                else
                {
                    // 4. Otherwise, fall back to the module's custom drawIoPins implementation
                    module->drawIoPins(helpers);
                }
            };
            // --- END OF DYNAMIC PIN FIX ---

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                {
#if JUCE_DEBUG
                    ImGuiStackBalanceChecker ioStackGuard;
                    ImNodesDepthSnapshot ioDepthSnapshot(moduleLabel + "::drawIoPins");
#endif
                    helpers.drawIoPins(mp);
#if JUCE_DEBUG
                    ioStackGuard.validate(type + " [lid=" + juce::String((int)lid) + "]::drawIoPins");
#endif
                }

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
#if JUCE_DEBUG
            --gImNodesNodeDepth;
            jassert(gImNodesNodeDepth >= 0);
#endif
            
            // Cache position for snapshot safety
            // Graph is always in consistent state since we rebuild at frame start
            lastKnownNodePositions[(int)lid] = ImNodes::GetNodeGridSpacePos((int)lid);
            
            // Pop muted node styles (in reverse order of push)
            if (isMuted) {
                ImNodes::PopColorStyle();      // Mute TitleBar
                ImGui::PopStyleVar();          // Alpha
                ImNodes::PopStyleVar();        // NodePadding
            }
            
            // Pop hover highlight color
            if (isHoveredSource || isHoveredDest)
                ImNodes::PopColorStyle();      // Hover TitleBar
            
            // Pop category colors (in reverse order of push)
            ImNodes::PopColorStyle();          // TitleBarSelected
            ImNodes::PopColorStyle();          // TitleBarHovered
            ImNodes::PopColorStyle();          // TitleBar
            
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
        if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
        {
            // Apply saved position once; do not write (0,0) defaults
            const ImVec2 p = it->second;
            if (!(p.x == 0.0f && p.y == 0.0f))
            {
                ImNodes::SetNodeGridSpacePos((int) lid, p);
                juce::Logger::writeToLog("[PositionRestore] Applied pending position for node " + juce::String((int)lid) + ": (" + juce::String(p.x) + ", " + juce::String(p.y) + ")");
            }
            pendingNodePositions.erase(it);
        }
            // Apply pending size if queued (for Comment nodes to prevent feedback loop)
            if (auto itSize = pendingNodeSizes.find((int) lid); itSize != pendingNodeSizes.end())
            {
                // Store the desired size in the Comment module itself
                if (auto* comment = dynamic_cast<CommentModuleProcessor*>(synth->getModuleForLogical((juce::uint32)lid)))
                {
                    comment->nodeWidth = itSize->second.x;
                    comment->nodeHeight = itSize->second.y;
                }
                pendingNodeSizes.erase(itSize);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        bool triggerInsertMixer = false;
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            const juce::String selectedType = selectedLogicalId != 0 ? getTypeForLogical((juce::uint32)selectedLogicalId) : juce::String();
            const bool selectedIsMeta = selectedType.equalsIgnoreCase("meta_module") || selectedType.equalsIgnoreCase("meta");

            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0 && selectedLogicalId != 999)
            {
                mutedNodeStates.erase((juce::uint32)selectedLogicalId); // Clean up muted state if exists
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                pushSnapshot();
                NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(1) + " node(s)");
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    pushSnapshot();
                }
            }
            if (ImGui::MenuItem("Expand Meta Module", nullptr, false, selectedIsMeta))
            {
                expandMetaModule((juce::uint32)selectedLogicalId);
            }
            if (ImGui::MenuItem("Insert Mixer", "Ctrl+T") && selectedLogicalId != 0) { triggerInsertMixer = true; }
            ImGui::EndPopup();
        }

        // Shortcut: Ctrl+T to insert a Mixer after selected node and reroute
        // Debounced Ctrl+T
        const bool ctrlDown = ImGui::GetIO().KeyCtrl;
        if (!ctrlDown)
        {
            mixerShortcutCooldown = false;
            insertNodeShortcutCooldown = false;
        }

        const bool insertMixerShortcut = consumeShortcutFlag(shortcutInsertMixerRequested);
        if ((triggerInsertMixer || (selectedLogicalId != 0 && insertMixerShortcut)) && !mixerShortcutCooldown)
        {
            mixerShortcutCooldown = true; // Prevent re-triggering in the same frame
            const juce::uint32 srcLid = (juce::uint32) selectedLogicalId;

            juce::Logger::writeToLog("--- [InsertMixer] Start ---");
            juce::Logger::writeToLog("[InsertMixer] Selected Node Logical ID: " + juce::String(srcLid));

            auto srcNodeId = synth->getNodeIdForLogical(srcLid);
            if (srcNodeId.uid == 0) 
            {
                juce::Logger::writeToLog("[InsertMixer] ABORT: Source node with logical ID " + juce::String(srcLid) + " is invalid or could not be found.");
            } 
            else 
            {
                // 1. Collect all outgoing connections from the selected node
                std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
                for (const auto& c : synth->getConnectionsInfo()) {
                    if (c.srcLogicalId == srcLid) {
                        outgoingConnections.push_back(c);
                    }
                }
                juce::Logger::writeToLog("[InsertMixer] Found " + juce::String(outgoingConnections.size()) + " outgoing connections to reroute.");
                for (const auto& c : outgoingConnections) {
                    juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                    juce::Logger::writeToLog("  - Stored connection: [Src: " + juce::String(c.srcLogicalId) + ":" + juce::String(c.srcChan) + "] -> [Dst: " + destStr + ":" + juce::String(c.dstChan) + "]");
                }

                // 2. Create and position the new mixer node intelligently
                auto mixNodeIdGraph = synth->addModule("mixer");
                const juce::uint32 mixLid = synth->getLogicalIdForNode(mixNodeIdGraph);
                
                ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(selectedLogicalId);
                ImVec2 avgDestPos = srcPos; // Default to source pos if no outputs
                
                if (!outgoingConnections.empty())
                {
                    float totalX = 0.0f, totalY = 0.0f;
                    for (const auto& c : outgoingConnections)
                    {
                        int destId = c.dstIsOutput ? 0 : (int)c.dstLogicalId;
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(destId);
                        totalX += pos.x;
                        totalY += pos.y;
                    }
                    avgDestPos = ImVec2(totalX / outgoingConnections.size(), totalY / outgoingConnections.size());
                }
                else
                {
                    // If there are no outgoing connections, place it to the right
                    avgDestPos.x += 600.0f;
                }
                
                // Place the new mixer halfway between the source and the average destination
                pendingNodePositions[(int)mixLid] = ImVec2((srcPos.x + avgDestPos.x) * 0.5f, (srcPos.y + avgDestPos.y) * 0.5f);
                juce::Logger::writeToLog("[InsertMixer] Added new Mixer. Logical ID: " + juce::String(mixLid) + ", Node ID: " + juce::String(mixNodeIdGraph.uid));

                // 3. Disconnect all original outgoing links
                juce::Logger::writeToLog("[InsertMixer] Disconnecting original links...");
                for (const auto& c : outgoingConnections) {
                    auto currentSrcNodeId = synth->getNodeIdForLogical(c.srcLogicalId);
                    auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);

                    if (currentSrcNodeId.uid != 0 && dstNodeId.uid != 0) {
                        bool success = synth->disconnect(currentSrcNodeId, c.srcChan, dstNodeId, c.dstChan);
                        juce::Logger::writeToLog("  - Disconnecting [" + juce::String(currentSrcNodeId.uid) + ":" + juce::String(c.srcChan) + "] -> [" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                    } else {
                        juce::Logger::writeToLog("  - SKIPPING Disconnect due to invalid node ID.");
                    }
                }

                // 4. Connect the source node to the new mixer's first input
                juce::Logger::writeToLog("[InsertMixer] Connecting source node to new mixer...");
                bool c1 = synth->connect(srcNodeId, 0, mixNodeIdGraph, 0); // L to In A L
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":0] -> [" + juce::String(mixNodeIdGraph.uid) + ":0]... " + (c1 ? "SUCCESS" : "FAILED"));
                bool c2 = synth->connect(srcNodeId, 1, mixNodeIdGraph, 1); // R to In A R
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":1] -> [" + juce::String(mixNodeIdGraph.uid) + ":1]... " + (c2 ? "SUCCESS" : "FAILED"));


                // 5. Connect the mixer's output to all the original destinations (maintaining the chain)
                juce::Logger::writeToLog("[InsertMixer] Connecting mixer to original destinations to maintain chain...");
                if (outgoingConnections.empty()) {
                    juce::Logger::writeToLog("  - No original outgoing connections. Connecting mixer to Main Output by default.");
                    auto outNode = synth->getOutputNodeID();
                    if (outNode.uid != 0) {
                        bool o1 = synth->connect(mixNodeIdGraph, 0, outNode, 0);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":0] -> [Output:0]... " + (o1 ? "SUCCESS" : "FAILED"));
                        bool o2 = synth->connect(mixNodeIdGraph, 1, outNode, 1);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":1] -> [Output:1]... " + (o2 ? "SUCCESS" : "FAILED"));
                    }
                } else {
                    for (const auto& c : outgoingConnections) {
                        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                        if (dstNodeId.uid != 0) {
                            // Connect mixer output to the same destination the original node was connected to
                            // This maintains the chain: original -> mixer -> destination
                            bool success = synth->connect(mixNodeIdGraph, c.srcChan, dstNodeId, c.dstChan);
                            juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                            juce::Logger::writeToLog("  - Maintaining chain: Mixer [" + juce::String(mixNodeIdGraph.uid) + ":" + juce::String(c.srcChan) + "] -> " + destStr + "[" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                        } else {
                            juce::Logger::writeToLog("  - SKIPPING Reconnect due to invalid destination node ID for original logical ID " + juce::String(c.dstLogicalId));
                        }
                    }
                }

                graphNeedsRebuild = true;
                pushSnapshot(); // Make the entire operation undoable
                juce::Logger::writeToLog("[InsertMixer] Rerouting complete. Flagging for graph rebuild.");
            }
            juce::Logger::writeToLog("--- [InsertMixer] End ---");
        }

        // Shortcut: Ctrl+I to show Insert Node popup menu
        const bool showInsertPopupShortcut = consumeShortcutFlag(shortcutShowInsertPopupRequested);
        if (selectedLogicalId != 0 && showInsertPopupShortcut && !insertNodeShortcutCooldown)
        {
            insertNodeShortcutCooldown = true;
            showInsertNodePopup = true;
        }

        // Insert Node popup menu
        if (showInsertNodePopup)
        {
            ImGui::OpenPopup("InsertNodePopup");
            showInsertNodePopup = false;
        }

        if (ImGui::BeginPopup("InsertNodePopup"))
        {
            ImGui::Text("Insert Node Between Connections");
            
            // Audio Path
            if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); ImGui::CloseCurrentPopup(); }
            
            ImGui::Separator();
            
            // Modulation Path
            if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); ImGui::CloseCurrentPopup(); }
            
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        const bool isOutputHovered = (hoveredLinkDstId == kOutputHighlightId);
        if (isOutputHovered)
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted ("Output");
        ImNodes::EndNodeTitleBar();
        if (isOutputHovered)
            ImNodes::PopColorStyle();
        
        // In L pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 0, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 0, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
#if JUCE_DEBUG
            ++gImNodesInputDepth;
#endif
            ImGui::Text ("In L");
            ImNodes::EndInputAttribute();
#if JUCE_DEBUG
            --gImNodesInputDepth;
            jassert(gImNodesInputDepth >= 0);
#endif
            ImNodes::PopColorStyle();
        }
        
        // In R pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 1, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 1, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
#if JUCE_DEBUG
            ++gImNodesInputDepth;
#endif
            ImGui::Text ("In R");
            ImNodes::EndInputAttribute();
#if JUCE_DEBUG
            --gImNodesInputDepth;
            jassert(gImNodesInputDepth >= 0);
#endif
            ImNodes::PopColorStyle();
        }
        
        ImNodes::EndNode();
        
        // Cache output node position for snapshot safety
        // Graph is always in consistent state since we rebuild at frame start
        lastKnownNodePositions[0] = ImNodes::GetNodeGridSpacePos(0);
        
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            juce::Logger::writeToLog("[PositionRestore] Applied pending position for output node 0: (" + juce::String(it->second.x) + ", " + juce::String(it->second.y) + ")");
            pendingNodePositions.erase(it);
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections (IDs stable via bitmasking)
        int cableIdx = 0;
        for (const auto& c : synth->getConnectionsInfo())
        {
            
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) {
                continue;
            }
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) {
                continue;
            }
            
            const int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            const int dstAttr = c.dstIsOutput ? encodePinId({0, c.dstChan, true}) : encodePinId({c.dstLogicalId, c.dstChan, true});
            
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
            {
                static std::unordered_set<std::string> skipOnce;
                const std::string key = std::to_string((int)c.srcLogicalId) + ":" + std::to_string(c.srcChan) + "->" +
                                         (c.dstIsOutput? std::string("0") : std::to_string((int)c.dstLogicalId)) + ":" + std::to_string(c.dstChan);
                if (skipOnce.insert(key).second)
                {
                    juce::Logger::writeToLog(
                        juce::String("[ImNodes][SKIP] missing attr: srcPresent=") + (availableAttrs.count(srcAttr)?"1":"0") +
                        " dstPresent=" + (availableAttrs.count(dstAttr)?"1":"0") +
                        " srcKey=(lid=" + juce::String((int)c.srcLogicalId) + ",ch=" + juce::String(c.srcChan) + ")" +
                        " dstKey=(lid=" + juce::String(c.dstIsOutput?0:(int)c.dstLogicalId) + ",ch=" + juce::String(c.dstChan) + ",in=1) id(s)=" +
                        juce::String(srcAttr) + "," + juce::String(dstAttr));
                }
                continue;
            }
            
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            
            // --- THIS IS THE DEFINITIVE FIX ---
            // 1. Determine the base color and check for signal activity.
            auto srcPin = decodePinId(srcAttr);
            PinDataType linkDataType = getPinDataTypeForPin(srcPin);
            ImU32 linkColor = getImU32ForType(linkDataType);
            float magnitude = 0.0f;
            bool hasThicknessModification = false;

            // CRASH FIX: Verify module still exists before accessing it.
            // During preset loading, modules may be destroyed while we're iterating connections.
            if (synth != nullptr && srcPin.logicalId != 0)
            {
                // First verify the module exists in the current module list
                bool moduleExists = false;
                for (const auto& modInfo : synth->getModulesInfo())
                {
                    if (modInfo.first == srcPin.logicalId)
                    {
                        moduleExists = true;
                        break;
                    }
                }
                
                // Only access if module still exists
                if (moduleExists)
                {
                    if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                    {
                        magnitude = srcModule->getOutputChannelValue(srcPin.channel);
                    }
                }
            }

            // 2. If the signal is active, calculate a glowing/blinking color.
            if (magnitude > 0.01f)
            {
                const float blinkSpeed = 8.0f;
                float blinkFactor = (std::sin((float)ImGui::GetTime() * blinkSpeed) + 1.0f) * 0.5f;
                float glowIntensity = juce::jlimit(0.0f, 1.0f, blinkFactor * magnitude * 2.0f);

                // Brighten the base color and modulate alpha for glow effect
                ImVec4 colorVec = ImGui::ColorConvertU32ToFloat4(linkColor);
                colorVec.x = juce::jmin(1.0f, colorVec.x + glowIntensity * 0.4f);
                colorVec.y = juce::jmin(1.0f, colorVec.y + glowIntensity * 0.4f);
                colorVec.z = juce::jmin(1.0f, colorVec.z + glowIntensity * 0.4f);
                colorVec.w = juce::jlimit(0.5f, 1.0f, 0.5f + glowIntensity * 0.5f);
                linkColor = ImGui::ColorConvertFloat4ToU32(colorVec);

                // Make active cables slightly thicker (keep constant in screen space under zoom)
                {
                    float currentZoom = 1.0f;
#if defined(IMNODES_ZOOM_ENABLED)
                    if (ImNodes::GetCurrentContext())
                        currentZoom = ImNodes::EditorContextGetZoom();
#endif
                    ImNodes::PushStyleVar(ImNodesStyleVar_LinkThickness, 3.0f / currentZoom);
                }
                hasThicknessModification = true;
            }

            // 3. Push the chosen color (either normal or glowing) to the style stack.
            const auto& theme = ThemeManager::getInstance().getCurrentTheme();
            ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);
            ImNodes::PushColorStyle(ImNodesCol_LinkHovered, theme.links.link_hovered);
            ImNodes::PushColorStyle(ImNodesCol_LinkSelected, theme.links.link_selected);

            // 4. Check for node hover highlight (this should override the glow).
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle(ImNodesCol_Link, theme.links.link_highlighted);
            }
            
            // 5. Tell imnodes to draw the link. It will use the color we just pushed.
            ImNodes::Link(linkId, srcAttr, dstAttr);
            
            // 6. Pop ALL style modifications to restore the defaults for the next link.
            if (hl) ImNodes::PopColorStyle();
            ImNodes::PopColorStyle(); // LinkSelected
            ImNodes::PopColorStyle(); // LinkHovered
            ImNodes::PopColorStyle(); // Link
            if (hasThicknessModification) ImNodes::PopStyleVar(); // LinkThickness
            
            // --- END OF FIX ---
        }

        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    // --- Handle Auto-Connect Requests from MIDI Players ---
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
        {
            // Check for initial button presses
            if (midiPlayer->autoConnectTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Samplers;
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO;
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Hybrid;
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            // --- THIS IS THE NEW LOGIC ---
            // Check if an update was requested after a new file was loaded
            else if (midiPlayer->connectionUpdateRequested.exchange(false))
            {
                // Re-run the correct handler based on the saved state
                switch (midiPlayer->lastAutoConnectState.load())
                {
                    case MIDIPlayerModuleProcessor::AutoConnectState::Samplers:
                        handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO:
                        handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::Hybrid:
                        handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::None:
                    default:
                        // Do nothing if it wasn't auto-connected before
                        break;
                }
            }
            // --- END OF NEW LOGIC ---
        }
    }
    // --- Handle Auto-Connect Requests using new intelligent system ---
    handleAutoConnectionRequests();

    // Capture hover state for drag/drop logic before we leave the node editor scope
    int hoverPinIdForDrop = -1;
    int hoverNodeIdForDrop = -1;
    int hoverLinkIdForDrop = -1;
    bool pinHoveredDuringEditor = false;
    bool nodeHoveredDuringEditor = false;
    bool linkHoveredDuringEditor = false;

    // ======================================================
    // === üí° MODAL MINIMAP (v13 - Scale-on-Press) ==========
    // ======================================================
    if (isMinimapEnlarged.load())
    {
        ImNodes::MiniMap(modalMinimapScale, ImNodesMiniMapLocation_BottomRight);
    }
    else
    {
        ImNodes::MiniMap(0.2f, ImNodesMiniMapLocation_BottomRight);
    }
    // ======================================================
    // === üí° END MODAL MINIMAP =============================
    // ======================================================

    ImNodes::EndNodeEditor();
#if JUCE_DEBUG
    if (gImNodesNodeDepth != 0 || gImNodesInputDepth != 0 || gImNodesOutputDepth != 0)
    {
        juce::Logger::writeToLog(
            "[ImNodes][DepthLeak][Frame] nodeDepth=" + juce::String(gImNodesNodeDepth) +
            " inputDepth=" + juce::String(gImNodesInputDepth) +
            " outputDepth=" + juce::String(gImNodesOutputDepth) +
            " lastNode=" + gLastRenderedNodeLabel);
        jassertfalse;
        gImNodesNodeDepth = 0;
        gImNodesInputDepth = 0;
        gImNodesOutputDepth = 0;
    }
#endif
    pinHoveredDuringEditor = ImNodes::IsPinHovered(&hoverPinIdForDrop);
    nodeHoveredDuringEditor = ImNodes::IsNodeHovered(&hoverNodeIdForDrop);
    linkHoveredDuringEditor = ImNodes::IsLinkHovered(&hoverLinkIdForDrop);
    juce::ignoreUnused(hoverPinIdForDrop, hoverNodeIdForDrop, hoverLinkIdForDrop);
    int linkStartAttr = -1;
    if (ImNodes::IsLinkStarted(&linkStartAttr))
    {
        dragInsertActive = true;
        dragInsertStartAttrId = linkStartAttr;
        dragInsertStartPin = decodePinId(linkStartAttr);
        shouldOpenDragInsertPopup = false;
        juce::Logger::writeToLog("[DragInsert] Started drag from attr " + juce::String(linkStartAttr));
    }
    if (dragInsertActive)
    {
        const bool cancelRequested = ImGui::IsKeyPressed(ImGuiKey_Escape, false) ||
                                     ImGui::IsMouseReleased(ImGuiMouseButton_Right);
        if (cancelRequested)
        {
            juce::Logger::writeToLog("[DragInsert] Drag cancelled.");
            cancelDragInsert();
        }
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            const bool editorHovered = ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows |
                                                              ImGuiHoveredFlags_AllowWhenBlockedByPopup);
            if (!pinHoveredDuringEditor && !nodeHoveredDuringEditor && !linkHoveredDuringEditor && editorHovered)
            {
                dragInsertDropPos = ImGui::GetMousePos();
                shouldOpenDragInsertPopup = true;
                juce::Logger::writeToLog("[DragInsert] Drop captured on canvas (logicalId="
                                         + juce::String((int)dragInsertStartPin.logicalId)
                                         + ", channel=" + juce::String(dragInsertStartPin.channel) + ").");
            }
            else
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                shouldOpenDragInsertPopup = false;
            }
            dragInsertActive = false;
        }
    }
    else if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
    {
        shouldOpenDragInsertPopup = false;
    }
    // === POP THE TRANSPARENT GRID BACKGROUND STYLE ===
    ImNodes::PopColorStyle(); // Pop BoxSelectorOutline
    ImNodes::PopColorStyle(); // Pop BoxSelector
    ImNodes::PopColorStyle(); // Pop GridLinePrimary
    ImNodes::PopColorStyle(); // Pop GridLine
    ImNodes::PopColorStyle(); // Pop GridBackground
    ImNodes::PopColorStyle(); // Pop NodeOutline
    ImNodes::PopColorStyle(); // Pop NodeBackgroundSelected
    ImNodes::PopColorStyle(); // Pop NodeBackgroundHovered
    ImNodes::PopColorStyle(); // Pop NodeBackground
    // === END OF FIX ===
    hasRenderedAtLeastOnce = true;
    
    if (shouldOpenDragInsertPopup)
    {
        shouldOpenDragInsertPopup = false;
        ImGui::SetNextWindowPos(dragInsertDropPos, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
        ImGui::OpenPopup("DragInsertPopup");
    }
    if (ImGui::BeginPopup("DragInsertPopup"))
    {
        const PinDataType displayType = dragInsertStartPin.isMod
            ? PinDataType::CV
            : getPinDataTypeForPin(dragInsertStartPin);
        const auto& suggestions = getDragInsertSuggestionsFor(dragInsertStartPin);

        if (suggestions.empty())
        {
            ImGui::TextDisabled("No compatible modules found.");
            if (ImGui::MenuItem("Close"))
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                ImGui::CloseCurrentPopup();
            }
        }
        else
        {
            ImGui::Text("Insert node for %s", pinDataTypeToString(displayType));
            ImGui::Separator();

            for (const auto& moduleType : suggestions)
            {
                if (ImGui::MenuItem(moduleType.toRawUTF8()))
                {
                    insertNodeFromDragSelection(moduleType);
                    ImGui::CloseCurrentPopup();
                    break;
                }
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Cancel"))
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                ImGui::CloseCurrentPopup();
            }
        }

        ImGui::EndPopup();
    }

    // VST Plugin Selection Popup
    if (ImGui::BeginPopup("VSTPluginSelection"))
    {
        ImGui::Text("Select VST Plugin");
        ImGui::Separator();
        addPluginModules();
        ImGui::Separator();
        if (ImGui::MenuItem("Cancel"))
        {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }

    // ======================================================
    // === üí° MODAL MINIMAP LOGIC (v13 - Scale-on-Press) ====
    // ======================================================
    ImGuiIO& io = ImGui::GetIO();
    bool isEditorHovered = ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows |
                                                 ImGuiHoveredFlags_AllowWhenBlockedByPopup);

    if (consumeShortcutFlag(shortcutToggleMinimapRequested) && !isMinimapEnlarged.load() && isEditorHovered)
    {
        isMinimapEnlarged.store(true);

        ImVec2 minimapCorner = ImVec2(lastCanvasP0.x + lastCanvasSize.x,
                                      lastCanvasP0.y + lastCanvasSize.y);
        ImVec2 mousePos = io.MousePos;
        float dist_x = minimapCorner.x - mousePos.x;
        float dist_y = minimapCorner.y - mousePos.y;
        float distance = std::sqrt(dist_x * dist_x + dist_y * dist_y);
        float max_dist = std::sqrt(lastCanvasSize.x * lastCanvasSize.x +
                                   lastCanvasSize.y * lastCanvasSize.y);

        float norm_dist = 0.0f;
        if (max_dist > 0.0f)
            norm_dist = juce::jlimit(0.0f, 1.0f, distance / max_dist);

        modalMinimapScale = 0.2f + (norm_dist * 0.6f);
    }

    if (ImGui::IsKeyReleased(ImGuiKey_Comma))
    {
        isMinimapEnlarged.store(false);
        modalMinimapScale = 0.2f;
    }

    if (isMinimapEnlarged.load() && !ImGui::IsWindowFocused(ImGuiHoveredFlags_RootAndChildWindows))
    {
        isMinimapEnlarged.store(false);
        modalMinimapScale = 0.2f;
    }
    // ======================================================
    // === üí° END MODAL MINIMAP LOGIC =======================
    // ======================================================
    
    // ================== MIDI PLAYER QUICK CONNECT LOGIC ==================
    // Poll all MIDI Player modules for connection requests
    if (synth != nullptr)
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                int requestType = midiPlayer->getAndClearConnectionRequest();
                if (requestType > 0)
                {
                    handleMIDIPlayerConnectionRequest(modInfo.first, midiPlayer, requestType);
                    break; // Only handle one request per frame
                }
            }
        }
    }
    // ================== END MIDI PLAYER QUICK CONNECT ==================
    // ================== META MODULE EDITING LOGIC ==================
    // Check if any Meta Module has requested to be edited
    if (synth != nullptr && metaModuleToEditLid == 0) // Only check if not already editing one
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                // Atomically check and reset the flag
                if (metaModule->editRequested.exchange(false))
                {
                    metaModuleToEditLid = modInfo.first;
                    juce::Logger::writeToLog("[MetaEdit] Opening editor for Meta Module L-ID " + juce::String((int)metaModuleToEditLid));
                    ImGui::OpenPopup("Edit Meta Module");
                    break; // Only handle one request per frame
                }
            }
        }
    }
    
    // Draw the modal popup for the internal editor if one is selected
    if (metaModuleToEditLid != 0)
    {
        ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
        if (ImGui::BeginPopupModal("Edit Meta Module", nullptr, ImGuiWindowFlags_MenuBar))
        {
            ImGui::PushID((int)metaModuleToEditLid);
            auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaModuleToEditLid));
            if (metaModule && metaModule->getInternalGraph())
            {
                if (!metaEditorSession || metaEditorSession->metaLogicalId != metaModuleToEditLid)
                    openMetaModuleEditor(metaModule, metaModuleToEditLid);

                if (metaEditorSession)
                    renderMetaModuleEditor(*metaEditorSession);

                ImGui::Separator();
                if (ImGui::Button("Apply Changes"))
                {
                    if (metaEditorSession && metaEditorSession->dirty)
                    {
                        metaModule->refreshCachedLayout();
                        graphNeedsRebuild = true;
                        snapshotAfterEditor = true;
                    }
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("Close"))
                {
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
            }
            else
            {
                ImGui::Text("Meta module %d has no internal graph to edit.", (int)metaModuleToEditLid);
                if (ImGui::Button("Close"))
                {
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
            }
            ImGui::PopID();
            ImGui::EndPopup();
        }
        else
        {
            closeMetaModuleEditor();
            metaModuleToEditLid = 0;
        }
    }
    // ======================= END OF META MODULE LOGIC =======================

    // --- CONSOLIDATED HOVERED LINK DETECTION ---
    // Declare these variables ONCE, immediately after the editor has ended.
    // All subsequent features that need to know about hovered links can now
    // safely reuse these results without causing redefinition or scope errors.
    // Graph is always in consistent state since we rebuild at frame start
    int hoveredLinkId = -1;
    bool isLinkHovered = ImNodes::IsLinkHovered(&hoveredLinkId);
    // --- END OF CONSOLIDATED DECLARATION ---
    
    // Smart cable visualization is now integrated directly into the link drawing loop above.
    // No separate overlay needed - cables glow by modifying their own color.
    
    // === PROBE TOOL MODE HANDLING ===
    if (isProbeModeActive)
    {
        // Change cursor to indicate probe mode is active
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        
        // Draw "PROBE ACTIVE" indicator at mouse position
        auto* drawList = ImGui::GetForegroundDrawList();
        ImVec2 mousePos = ImGui::GetMousePos();
        const char* text = "PROBE MODE: Click output pin";
        auto textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImVec2(mousePos.x + 20, mousePos.y - 20);
        const auto& theme = ThemeManager::getInstance().getCurrentTheme();
        drawList->AddRectFilled(
            ImVec2(textPos.x - 5, textPos.y - 2),
            ImVec2(textPos.x + textSize.x + 5, textPos.y + textSize.y + 2),
            theme.links.label_background
        );
        drawList->AddText(textPos, theme.links.label_text, text);
        
        // Check for pin clicks
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                auto pinId = decodePinId(hoveredPinId);
                // Check if it's an output pin (not input, not mod)
                if (!pinId.isInput && !pinId.isMod && pinId.logicalId != 0)
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on valid output pin. LogicalID: " + juce::String(pinId.logicalId) + ", Channel: " + juce::String(pinId.channel));
                    auto nodeId = synth->getNodeIdForLogical(pinId.logicalId);
                    synth->setProbeConnection(nodeId, pinId.channel);
                    isProbeModeActive = false; // Deactivate after probing
                }
                else
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on an invalid pin (input or output node). Cancelling.");
                    isProbeModeActive = false;
                }
            }
            else
            {
                // Clicked on empty space, cancel probe mode
                juce::Logger::writeToLog("[PROBE_UI] Probe clicked on empty space. Cancelling.");
                isProbeModeActive = false;
            }
        }
        
        // Allow ESC to cancel probe mode
        if (ImGui::IsKeyPressed(ImGuiKey_Escape))
        {
            isProbeModeActive = false;
            juce::Logger::writeToLog("[PROBE_UI] Cancelled with ESC");
        }
    }
    // --- CONTEXTUAL RIGHT-CLICK HANDLER ---
    // A cable was right-clicked. Store its info and open the insert popup.
    if (isLinkHovered && hoveredLinkId != -1)
    {
        if (ImGui::GetIO().KeyCtrl && ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            // User initiated a split. Find the source pin of the hovered link.
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                splittingFromAttrId = it->second.first; // The source attribute ID
                juce::Logger::writeToLog("[CableSplit] Starting split from attr ID: " + juce::String(splittingFromAttrId));
            }
        }
    }
    // --- END OF CABLE SPLITTING ---

    // 2. If a split-drag is active, handle drawing and completion.
    if (splittingFromAttrId != -1)
    {
        // Draw a line from the source pin to the mouse cursor for visual feedback.
        if (auto it = attrPositions.find(splittingFromAttrId); it != attrPositions.end())
        {
            ImVec2 sourcePos = it->second;
            ImVec2 mousePos = ImGui::GetMousePos();
            const auto& theme = ThemeManager::getInstance().getCurrentTheme();
            ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, theme.links.preview_color, theme.links.preview_width);
        }

        // 3. Handle completion or cancellation of the drag.
        // We use Left-click to complete the link, matching ImNodes' default behavior.
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                // User dropped the link on a pin.
                auto srcPin = decodePinId(splittingFromAttrId);
                auto dstPin = decodePinId(hoveredPinId);

                // Ensure the connection is valid (Output -> Input).
                if (!srcPin.isInput && dstPin.isInput)
                {
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    graphNeedsRebuild = true;
                    pushSnapshot(); // Make it undoable
                }
            }

            // ALWAYS reset the state, whether the connection was successful or not.
            splittingFromAttrId = -1;
        }
        // Also allow cancellation with a right-click.
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            splittingFromAttrId = -1; // Cancel the operation.
        }
    }
    // --- END OF NEW LOGIC ---

    // Open popup now (outside editor) if requested this frame
    if (showInsertNodePopup)
    {
        showInsertNodePopup = false;
        // Validate the link still exists
        if (pendingInsertLinkId != -1)
        {
            bool stillValid = (/* modLinkIdToRoute.count(pendingInsertLinkId) || */ linkIdToAttrs.count(pendingInsertLinkId));
            if (!stillValid)
            {
                juce::Logger::writeToLog("[InsertNode] Skipping popup: link disappeared this frame");
                pendingInsertLinkId = -1;
            }
        }
        if (pendingInsertLinkId != -1)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            // Consume the mouse release/click so the popup stays open
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode] Opened popup (post-editor)");
        }
        else
        {
            linkToInsertOn = {}; // safety
        }
        pendingInsertLinkId = -1;
    }
    // Fallback: If user right-clicked and a link was hovered this frame, open popup using cached hover
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Right)
        && lastHoveredLinkId != -1
        && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        int id = lastHoveredLinkId;
        linkToInsertOn = {}; linkToInsertOn.linkId = id;
        bool captured = false;
        // TODO: Handle modulation link deletion for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(id); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][RC-Fallback] Mod link captured id=" + juce::String(id));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            // Infer modulation vs audio vs video list from pin data types
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Link captured id=" + juce::String(id));
        }
        if (captured)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Opened popup");
        }
        else
        {
            linkToInsertOn.linkId = -1;
        }
    }
    // This function draws the popup if the popup is open.
    drawInsertNodeOnLinkPopup();

    // --- Cable Inspector: Stateless, rebuild-safe implementation ---
    hoveredLinkSrcId = 0;
    hoveredLinkDstId = 0;

    // Skip inspector if popups are open (graph is always in consistent state now)
    const bool anyPopupOpen = ImGui::IsPopupOpen("InsertNodeOnLinkPopup") || ImGui::IsPopupOpen("AddModulePopup");
    // Do not early-return here; we still need to finish the frame and close any ImGui scopes.

    if (!anyPopupOpen && synth != nullptr)
    {
        if (isLinkHovered && hoveredLinkId != -1)
        {
            // Safety: Re-verify link still exists in our mapping
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                // Set highlight IDs for this frame only
                hoveredLinkSrcId = srcPin.logicalId;
                hoveredLinkDstId = (dstPin.logicalId == 0) ? kOutputHighlightId : dstPin.logicalId;

                if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                {
                    const int numOutputs = srcModule->getTotalNumOutputChannels();
                    if (srcPin.channel >= 0 && srcPin.channel < numOutputs)
                    {
                        if (hoveredLinkId != m_currentlyProbedLinkId)
                        {
                            auto sourceNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
                            synth->setProbeConnection(sourceNodeId, srcPin.channel);
                            m_currentlyProbedLinkId = hoveredLinkId;
                        }

                        // Create link info for the tooltip
                        LinkInfo linkInfo;
                        linkInfo.srcLogicalNodeId = srcPin.logicalId;
                        linkInfo.srcNodeId = srcPin.logicalId;
                        linkInfo.srcChannel = srcPin.channel;
                        linkInfo.sourceNodeName = srcModule->getName();
                        linkInfo.pinName = srcModule->getAudioOutputLabel(srcPin.channel);
                        if (linkInfo.pinName.isEmpty())
                            linkInfo.pinName = "Channel " + juce::String(srcPin.channel);

                        ImGui::BeginTooltip();
                        drawLinkInspectorTooltip(linkInfo);
                        ImGui::EndTooltip();
                    }
                    else if (m_currentlyProbedLinkId != -1 && m_currentlyProbedLinkId != hoveredLinkId)
                    {
                        synth->clearProbeConnection();
                        m_currentlyProbedLinkId = -1;
                    }
                }
            }
        }
        else if (m_currentlyProbedLinkId != -1)
        {
            int hoveredNodeId = -1;
            bool isNodeHovered = ImNodes::IsNodeHovered(&hoveredNodeId);

            int hoveredPinId = -1;
            bool isPinHovered = ImNodes::IsPinHovered(&hoveredPinId);

            if (!isLinkHovered && !isNodeHovered && !isPinHovered)
            {
                synth->clearProbeConnection();
                m_currentlyProbedLinkId = -1;
            }
        }
    }
    else if (m_currentlyProbedLinkId != -1 && synth != nullptr)
    {
        synth->clearProbeConnection();
        m_currentlyProbedLinkId = -1;
    }
    // Update hovered node/link id for next frame (must be called outside editor scope)
    // Graph is always in consistent state since we rebuild at frame start
    int hv = -1;
    if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    int hl = -1;
    if (ImNodes::IsLinkHovered(&hl)) lastHoveredLinkId = hl; else lastHoveredLinkId = -1;
    // Shortcut: press 'I' while hovering a link to open Insert-on-Link popup (bypasses mouse handling)
    if (consumeShortcutFlag(shortcutInsertOnLinkRequested) && lastHoveredLinkId != -1 && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        linkToInsertOn = {}; // reset
        linkToInsertOn.linkId = lastHoveredLinkId;
        bool captured = false;
        // TODO: Handle modulation link hover end for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(lastHoveredLinkId); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][KeyI] Mod link captured id=" + juce::String(lastHoveredLinkId));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(lastHoveredLinkId); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][KeyI] Link captured id=" + juce::String(lastHoveredLinkId));
        }
        if (captured)
        {
            pendingInsertLinkId = lastHoveredLinkId;
            showInsertNodePopup = true; // will open next lines
        }
        else
        {
            linkToInsertOn.linkId = -1;
            juce::Logger::writeToLog("[InsertNode][KeyI] No link data found for id=" + juce::String(lastHoveredLinkId));
        }
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }
    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        // Avoid passing nullptr to ImNodes::IsLinkHovered; some builds may write to the pointer
        int dummyHoveredLinkId = -1;
        const bool anyLinkHovered = ImNodes::IsLinkHovered(&dummyHoveredLinkId);
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered()
            && !anyLinkHovered
            && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup")
            && linkToInsertOn.linkId == -1) // avoid conflict with insert-on-link popup
        {
                ImGui::OpenPopup("AddModulePopup");
        }
        // --- REVISED AND IMPROVED "QUICK ADD" POPUP ---
        if (ImGui::BeginPopup("AddModulePopup"))
        {
            static char searchQuery[128] = "";
            static int selectedIndex = 0;  // Track keyboard navigation

            // Auto-focus the search bar when the popup opens and clear any previous search
            if (ImGui::IsWindowAppearing())
            {
                ImGui::SetWindowFocus();

                if (dragInsertStartAttrId != -1)
                {
                    PinID displayPin = dragInsertStartPin;
                    auto type = displayPin.isMod ? PinDataType::CV : getPinDataTypeForPin(displayPin);

                    juce::String seed = ":" + juce::String(pinDataTypeToString(type));
                    juce::String modules;
                    const auto& suggestions = getDragInsertSuggestionsFor(displayPin);
                    for (size_t i = 0; i < suggestions.size(); ++i)
                        modules += ":" + suggestions[i];

                    juce::String tokenized = seed + modules;
                    auto truncated = tokenized.substring(0, juce::jmin((int)tokenized.length(), (int)sizeof(searchQuery) - 1));
                    std::memset(searchQuery, 0, sizeof(searchQuery));
                    std::memcpy(searchQuery, truncated.toRawUTF8(), (size_t)truncated.getNumBytesAsUTF8());
                }
                else
                {
                    searchQuery[0] = '\0';
                }

                ImGui::SetKeyboardFocusHere(0);
                selectedIndex = 0;
            }
            
            ImGui::Text("Add Module");
            ImGui::PushItemWidth(250.0f);
            
            // Enable Enter key detection for instant module creation
            bool enterPressed = ImGui::InputText("Search##addmodule", searchQuery, sizeof(searchQuery), 
                                                  ImGuiInputTextFlags_EnterReturnsTrue);
            
            ImGui::PopItemWidth();
            ImGui::Separator();
            
            // --- PROBE TOOL ---
            if (ImGui::MenuItem("üî¨ Probe Signal (Click any output pin)"))
            {
                isProbeModeActive = true;
                ImGui::CloseCurrentPopup();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Activate probe mode to instantly visualize any signal without manual patching.\nClick on any output pin to route it to the probe scope.");
            }
            ImGui::Separator();

            auto addAtMouse = [this](const char* type) {
                // Special handling for VST Host - open plugin selection popup
                if (juce::String(type).equalsIgnoreCase("vst_host"))
                {
                    ImGui::OpenPopup("VSTPluginSelection");
                    ImGui::CloseCurrentPopup();
                    return;
                }
                
                auto nodeId = synth->addModule(type);
                juce::String nodeName = juce::String(type).replaceCharacter('_', ' ');
                // Capitalize first letter of each word
                nodeName = nodeName.toLowerCase();
                bool capitalizeNext = true;
                for (int i = 0; i < nodeName.length(); ++i)
                {
                    if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
                    {
                        nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                        capitalizeNext = false;
                    }
                    else if (nodeName[i] == ' ')
                        capitalizeNext = true;
                }
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                // This places the new node exactly where the user right-clicked
                pendingNodeScreenPositions[logicalId] = ImGui::GetMousePosOnOpeningCurrentPopup();
                
                // Special handling for recorder module
                if (juce::String(type).equalsIgnoreCase("recorder"))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical((juce::uint32)logicalId)))
                    {
                        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
                    }
                }
                
                // Give comment nodes a default size to prevent feedback loop
                if (juce::String(type).equalsIgnoreCase("comment"))
                {
                    pendingNodeSizes[logicalId] = ImVec2(250.f, 150.f);
                }
                
                snapshotAfterEditor = true;
                ImGui::CloseCurrentPopup();
            };
            
            juce::String filter(searchQuery);

            ImGui::BeginChild("ModuleList", ImVec2(280, 350), true);

            if (filter.isEmpty())
            {
                // --- BROWSE MODE (No text in search bar) ---
                // Reorganized to match the new category structure
                
                if (ImGui::BeginMenu("Sources")) {
                    if (ImGui::MenuItem("VCO")) addAtMouse("vco");
                    if (ImGui::MenuItem("Polyphonic VCO")) addAtMouse("polyvco");
                    if (ImGui::MenuItem("Noise")) addAtMouse("noise");
                    if (ImGui::MenuItem("Audio Input")) addAtMouse("audio_input");
                    if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample_loader");
                    if (ImGui::MenuItem("Value")) addAtMouse("value");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Effects")) {
                    if (ImGui::MenuItem("VCF")) addAtMouse("vcf");
                    if (ImGui::MenuItem("Delay")) addAtMouse("delay");
                    if (ImGui::MenuItem("Reverb")) addAtMouse("reverb");
                    if (ImGui::MenuItem("Chorus")) addAtMouse("chorus");
                    if (ImGui::MenuItem("Phaser")) addAtMouse("phaser");
                    if (ImGui::MenuItem("Compressor")) addAtMouse("compressor");
                    if (ImGui::MenuItem("Limiter")) addAtMouse("limiter");
                    if (ImGui::MenuItem("Noise Gate")) addAtMouse("gate");
                    if (ImGui::MenuItem("Reroute")) addAtMouse("reroute");
                    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
                    if (ImGui::MenuItem("Graphic EQ")) addAtMouse("graphic_eq");
                    if (ImGui::MenuItem("Waveshaper")) addAtMouse("waveshaper");
                    if (ImGui::MenuItem("8-Band Shaper")) addAtMouse("8bandshaper");
                    if (ImGui::MenuItem("Granulator")) addAtMouse("granulator");
                    if (ImGui::MenuItem("Harmonic Shaper")) addAtMouse("harmonic_shaper");
                    if (ImGui::MenuItem("Time/Pitch Shifter")) addAtMouse("timepitch");
                    if (ImGui::MenuItem("De-Crackle")) addAtMouse("de_crackle");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Modulators")) {
                    if (ImGui::MenuItem("LFO")) addAtMouse("lfo");
                    if (ImGui::MenuItem("ADSR")) addAtMouse("adsr");
                    if (ImGui::MenuItem("Random")) addAtMouse("random");
                    if (ImGui::MenuItem("S&H")) addAtMouse("s_and_h");
                    if (ImGui::MenuItem("Function Generator")) addAtMouse("function_generator");
                    if (ImGui::MenuItem("Shaping Oscillator")) addAtMouse("shaping_oscillator");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Utilities & Logic")) {
                    if (ImGui::MenuItem("VCA")) addAtMouse("vca");
                    if (ImGui::MenuItem("Mixer")) addAtMouse("mixer");
                    if (ImGui::MenuItem("CV Mixer")) addAtMouse("cv_mixer");
                    if (ImGui::MenuItem("Track Mixer")) addAtMouse("track_mixer");
                    if (ImGui::MenuItem("Attenuverter")) addAtMouse("attenuverter");
                    if (ImGui::MenuItem("Lag Processor")) addAtMouse("lag_processor");
                    if (ImGui::MenuItem("Math")) addAtMouse("math");
                    if (ImGui::MenuItem("Map Range")) addAtMouse("map_range");
                    if (ImGui::MenuItem("Quantizer")) addAtMouse("quantizer");
                    if (ImGui::MenuItem("Rate")) addAtMouse("rate");
                    if (ImGui::MenuItem("Comparator")) addAtMouse("comparator");
                    if (ImGui::MenuItem("Logic")) addAtMouse("logic");
                    if (ImGui::MenuItem("Reroute")) addAtMouse("reroute");
                    if (ImGui::MenuItem("Clock Divider")) addAtMouse("clock_divider");
                    if (ImGui::MenuItem("Sequential Switch")) addAtMouse("sequential_switch");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Sequencers")) {
                    if (ImGui::MenuItem("Sequencer")) addAtMouse("sequencer");
                    if (ImGui::MenuItem("Multi Sequencer")) addAtMouse("multi_sequencer");
                    if (ImGui::MenuItem("Tempo Clock")) addAtMouse("tempo_clock");
                    if (ImGui::MenuItem("Snapshot Sequencer")) addAtMouse("snapshot_sequencer");
                    if (ImGui::MenuItem("Stroke Sequencer")) addAtMouse("stroke_sequencer");
                    if (ImGui::MenuItem("Timeline")) addAtMouse("timeline");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("MIDI")) {
                    if (ImGui::MenuItem("MIDI CV")) addAtMouse("midi_cv");
                    if (ImGui::MenuItem("MIDI Player")) addAtMouse("midi_player");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Faders")) addAtMouse("midi_faders");
                    if (ImGui::MenuItem("MIDI Knobs")) addAtMouse("midi_knobs");
                    if (ImGui::MenuItem("MIDI Buttons")) addAtMouse("midi_buttons");
                    if (ImGui::MenuItem("MIDI Jog Wheel")) addAtMouse("midi_jog_wheel");
                    if (ImGui::MenuItem("MIDI Pads")) addAtMouse("midi_pads");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Logger")) addAtMouse("midi_logger");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Analysis")) {
                    if (ImGui::MenuItem("Scope")) addAtMouse("scope");
                    if (ImGui::MenuItem("Debug")) addAtMouse("debug");
                    if (ImGui::MenuItem("Input Debug")) addAtMouse("input_debug");
                    if (ImGui::MenuItem("Frequency Graph")) addAtMouse("frequency_graph");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("TTS")) {
                    if (ImGui::MenuItem("TTS Performer")) addAtMouse("tts_performer");
                    if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("vocal_tract_filter");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Special")) {
                    if (ImGui::MenuItem("Physics")) addAtMouse("physics");
                    if (ImGui::MenuItem("Animation")) addAtMouse("animation");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Computer Vision")) {
                    if (ImGui::MenuItem("Webcam Loader")) addAtMouse("webcam_loader");
                    if (ImGui::MenuItem("Video File Loader")) addAtMouse("video_file_loader");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Video FX")) addAtMouse("video_fx");
                    if (ImGui::MenuItem("Crop Video")) addAtMouse("crop_video");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Movement Detector")) addAtMouse("movement_detector");
                    if (ImGui::MenuItem("Human Detector")) addAtMouse("human_detector");
                    if (ImGui::MenuItem("Object Detector")) addAtMouse("object_detector");
                    if (ImGui::MenuItem("Pose Estimator")) addAtMouse("pose_estimator");
                    if (ImGui::MenuItem("Hand Tracker")) addAtMouse("hand_tracker");
                    if (ImGui::MenuItem("Face Tracker")) addAtMouse("face_tracker");
                    if (ImGui::MenuItem("Color Tracker")) addAtMouse("color_tracker");
                    if (ImGui::MenuItem("Contour Detector")) addAtMouse("contour_detector");
                    if (ImGui::MenuItem("Semantic Segmentation")) addAtMouse("semantic_segmentation");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Plugins / VST")) {
                    addPluginModules(); // Re-use your existing plugin menu logic
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("System")) {
                    // if (ImGui::MenuItem("Meta")) addAtMouse("meta");
                    // if (ImGui::MenuItem("Inlet")) addAtMouse("inlet");
                    // if (ImGui::MenuItem("Outlet")) addAtMouse("outlet");
                    if (ImGui::MenuItem("Comment")) addAtMouse("comment");
                    if (ImGui::MenuItem("Recorder")) addAtMouse("recorder");
                    if (ImGui::MenuItem("VST Host")) addAtMouse("vst_host");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Best Practice")) addAtMouse("best_practice");
                    ImGui::EndMenu();
                }
            }
            else
            {
                // --- SEARCH MODE (Text has been entered) ---
                struct MatchedModule {
                    juce::String displayName;
                    const char* internalType;
                    const char* description;
                };
                std::vector<MatchedModule> matches;

                auto registry = getModuleRegistry();
                std::unordered_set<juce::String> matchedInternals;

                auto addMatchByInternal = [&](const juce::String& internal)
                {
                    if (!matchedInternals.insert(internal).second)
                        return;
                    for (const auto& entry : registry)
                    {
                        if (juce::String(entry.second.first).equalsIgnoreCase(internal))
                        {
                            matches.push_back({entry.first, entry.second.first, entry.second.second});
                            break;
                        }
                    }
                };

                bool usingTokenFilter = false;
                juce::String tokenType;

                if (filter.startsWithChar(':'))
                {
                    juce::StringArray tokens;
                    tokens.addTokens(filter, ":", "");
                    tokens.removeEmptyStrings();

                    if (!tokens.isEmpty())
                    {
                        usingTokenFilter = true;
                        tokenType = tokens[0];

                        auto parsePinTypeToken = [](const juce::String& token, PinDataType& outType) -> bool
                        {
                            if (token.equalsIgnoreCase("audio")) { outType = PinDataType::Audio; return true; }
                            if (token.equalsIgnoreCase("cv") || token.equalsIgnoreCase("mod")) { outType = PinDataType::CV; return true; }
                            if (token.equalsIgnoreCase("gate") || token.equalsIgnoreCase("trigger")) { outType = PinDataType::Gate; return true; }
                            if (token.equalsIgnoreCase("raw")) { outType = PinDataType::Raw; return true; }
                            if (token.equalsIgnoreCase("video")) { outType = PinDataType::Video; return true; }
                            return false;
                        };

                        PinDataType parsedType = PinDataType::Raw;
                        const bool typeParsed = parsePinTypeToken(tokenType, parsedType);

                        for (int i = 1; i < tokens.size(); ++i)
                        {
                            juce::String internal = tokens[i].trim();
                            if (internal.isNotEmpty())
                                addMatchByInternal(internal);
                        }

                        if (matches.empty() && typeParsed)
                        {
                            auto appendFromMap = [&](const std::map<PinDataType, std::vector<juce::String>>& source)
                            {
                                if (auto it = source.find(parsedType); it != source.end())
                                {
                                    for (const auto& internal : it->second)
                                        addMatchByInternal(internal);
                                }
                            };
                            appendFromMap(dragInsertSuggestionsInputs);
                            appendFromMap(dragInsertSuggestionsOutputs);
                        }

                        if (matches.empty())
                        {
                            usingTokenFilter = false;
                        }
                        else
                        {
                            juce::String label = tokenType.isNotEmpty() ? tokenType : "signal";
                            ImGui::TextDisabled("Suggestions for %s", label.toRawUTF8());
                            ImGui::Separator();
                        }
                    }
                }

                if (!usingTokenFilter)
                {
                    for (const auto& entry : registry)
                    {
                        const juce::String& displayName = entry.first;
                        const char* internalType = entry.second.first;
                        const char* description = entry.second.second;

                        if (displayName.containsIgnoreCase(filter)
                            || juce::String(internalType).containsIgnoreCase(filter))
                        {
                            if (matchedInternals.insert(juce::String(internalType)).second)
                                matches.push_back({displayName, internalType, description});
                        }
                    }
                }

                if (ImGui::IsKeyPressed(ImGuiKey_DownArrow))
                {
                    selectedIndex++;
                    if (selectedIndex >= (int)matches.size())
                        selectedIndex = (int)matches.size() - 1;
                }
                if (ImGui::IsKeyPressed(ImGuiKey_UpArrow))
                {
                    selectedIndex--;
                    if (selectedIndex < 0)
                        selectedIndex = 0;
                }
                if (enterPressed && !matches.empty())
                {
                    if (selectedIndex >= 0 && selectedIndex < (int)matches.size())
                    {
                        addAtMouse(matches[selectedIndex].internalType);
                    }
                }

                for (int i = 0; i < (int)matches.size(); ++i)
                {
                    const auto& match = matches[i];
                    bool isSelected = (i == selectedIndex);

                    if (ImGui::Selectable(match.displayName.toRawUTF8(), isSelected))
                    {
                        addAtMouse(match.internalType);
                    }

                    if (isSelected && !ImGui::IsItemVisible())
                        ImGui::SetScrollHereY(0.5f);

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::TextUnformatted(match.description);
                        ImGui::EndTooltip();
                    }
                }

                if (selectedIndex >= (int)matches.size())
                    selectedIndex = (int)matches.size() - 1;
                if (selectedIndex < 0 && !matches.empty())
                    selectedIndex = 0;
            }

            ImGui::EndChild();
            ImGui::EndPopup();
        }

        // Helper functions are now class methods

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinId(startAttr);
            auto endPin = decodePinId(endAttr);
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // Ensure connection is always Output -> Input
            if (!srcPin.isInput && dstPin.isInput)
            {
                PinDataType srcType = getPinDataTypeForPin(srcPin);
                
                // CRITICAL: Update reroute node type BEFORE checking compatibility
                // This ensures reroute nodes adopt the source type before type checks
                if (dstPin.logicalId != 0 && getTypeForLogical(dstPin.logicalId).equalsIgnoreCase("reroute"))
                {
                    if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(dstPin.logicalId)))
                    {
                        reroute->setPassthroughType(srcType);
                    }
                }
                
                // Re-query dstType after potential reroute update
                PinDataType dstType = getPinDataTypeForPin(dstPin);

                bool conversionHandled = false;

                // Determine if a converter is needed based on pin types
                if (srcType == PinDataType::Audio && dstType == PinDataType::CV)
                {
                    insertNodeBetween("attenuverter", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::CV && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Audio && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Raw && dstType != PinDataType::Raw)
                {
                    insertNodeBetween("map_range", srcPin, dstPin);
                    conversionHandled = true;
                }

                if (conversionHandled)
                {
                    pushSnapshot();
                }
                else
                {
                    // All other combinations are considered directly compatible.
                    if (!dstPin.isMod && dstPin.isInput && dstPin.logicalId != 0)
                    {
                        if (getTypeForLogical(dstPin.logicalId).equalsIgnoreCase("reroute"))
                            updateRerouteTypeFromConnections(dstPin.logicalId);
                    }

                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    // Immediate commit for RecordModuleProcessor filename update
                    synth->commitChanges();

                    if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId)) {
                        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule)) {
                            juce::String sourceName;
                            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId)) {
                                sourceName = srcModule->getName();
                            }
                            recorder->updateSuggestedFilename(sourceName);
                        }
                    }

                    auto updateRerouteForPin = [&](const PinID& pin)
                    {
                        if (pin.logicalId != 0 && getTypeForLogical(pin.logicalId).equalsIgnoreCase("reroute"))
                            updateRerouteTypeFromConnections(pin.logicalId);
                    };
                    updateRerouteForPin(srcPin);
                    updateRerouteForPin(dstPin);

                    pushSnapshot();
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                // Debug log disconnect intent
                juce::Logger::writeToLog(
                    juce::String("[LinkDelete] src(lid=") + juce::String((int)srcPin.logicalId) + ",ch=" + juce::String(srcPin.channel) +
                    ") -> dst(lid=" + juce::String((int)dstPin.logicalId) + ",ch=" + juce::String(dstPin.channel) + ")");

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                
                // Immediate commit for RecordModuleProcessor filename update
                synth->commitChanges();
                
                auto updateRerouteForPin = [&](const PinID& pin)
                {
                    if (pin.logicalId != 0 && getTypeForLogical(pin.logicalId).equalsIgnoreCase("reroute"))
                        updateRerouteTypeFromConnections(pin.logicalId);
                };
                updateRerouteForPin(srcPin);
                updateRerouteForPin(dstPin);
                
                // After disconnecting, tell the recorder to update (pass empty string for unconnected)
                if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule))
                    {
                        recorder->updateSuggestedFilename(""); // Empty = unconnected
                    }
                }
                
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)
        // Keyboard shortcuts
        // Only process global keyboard shortcuts if no ImGui widget wants the keyboard
        if (!ImGui::GetIO().WantCaptureKeyboard)
        {
            if (consumeShortcutFlag(shortcutFileSaveAsRequested))
            {
                startSaveDialog();
            }
            if (consumeShortcutFlag(shortcutFileSaveRequested))
            {
                if (currentPresetFile.existsAsFile())
                    savePresetToFile(currentPresetFile);
                else
                    startSaveDialog();
            }
            if (consumeShortcutFlag(shortcutFileOpenRequested))
            {
                startLoadDialog();
            }
            if (consumeShortcutFlag(shortcutRandomizePatchRequested))
            {
                handleRandomizePatch();
            }
            if (consumeShortcutFlag(shortcutRandomizeConnectionsRequested))
            {
                handleRandomizeConnections();
            }
            if (consumeShortcutFlag(shortcutBeautifyLayoutRequested))
            {
                handleBeautifyLayout();
            }
        
            if (consumeShortcutFlag(shortcutMuteSelectionRequested) && ImNodes::NumSelectedNodes() > 0)
            {
                handleMuteToggle();
            }

            if (consumeShortcutFlag(shortcutSelectAllRequested))
            {
                if (synth != nullptr)
                {
                    const auto& modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0);
                    for (const auto& mod : modules)
                        allNodeIds.push_back((int)mod.first);

                    ImNodes::ClearNodeSelection();
                    for (int id : allNodeIds)
                        ImNodes::SelectNode(id);
                }
            }

            if (consumeShortcutFlag(shortcutChainSequentialRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleNodeChaining();
            }

            if (consumeShortcutFlag(shortcutChainAudioRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Audio);
            }

            if (consumeShortcutFlag(shortcutChainCvRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::CV);
            }

            if (consumeShortcutFlag(shortcutChainGateRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Gate);
            }

            if (consumeShortcutFlag(shortcutChainRawRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Raw);
            }

            if (consumeShortcutFlag(shortcutChainVideoRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Video);
            }
        
            if (consumeShortcutFlag(shortcutCtrlRRequested))
            {
                const int numSelected = ImNodes::NumSelectedNodes();
                if (numSelected > 0 && synth != nullptr)
                {
                    pushSnapshot();

                    std::vector<int> selectedNodeIds(numSelected);
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());

                    for (int lid : selectedNodeIds)
                    {
                        if (auto* module = synth->getModuleForLogical((juce::uint32)lid))
                        {
                            auto& params = module->getParameters();
                            for (auto* paramBase : params)
                            {
                                if (auto* param = dynamic_cast<juce::RangedAudioParameter*>(paramBase))
                                    param->setValueNotifyingHost(param->getDefaultValue());
                            }
                            juce::Logger::writeToLog("[Reset] Reset parameters for node " + juce::String(lid));
                        }
                    }
                }
                else
                {
                    handleRecordOutput();
                }
            }
            if (consumeShortcutFlag(shortcutConnectOutputRequested) && ImNodes::NumSelectedNodes() == 1)
            {
                if (synth != nullptr)
                {
                    int selectedId = 0;
                    ImNodes::GetSelectedNodes(&selectedId);
                    if (selectedId != 0)
                    {
                        synth->connect(synth->getNodeIdForLogical(selectedId), 0, synth->getOutputNodeID(), 0);
                        synth->connect(synth->getNodeIdForLogical(selectedId), 1, synth->getOutputNodeID(), 1);
                        graphNeedsRebuild = true;
                        pushSnapshot();
                    }
                }
            }

            if (consumeShortcutFlag(shortcutDisconnectRequested) && ImNodes::NumSelectedNodes() > 0)
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    for (int id : selectedNodeIds)
                        synth->clearConnectionsForNode(synth->getNodeIdForLogical(id));

                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
            }
            auto frameNodes = [&](const std::vector<int>& nodeIds)
            {
                if (nodeIds.empty() || synth == nullptr)
                    return;

                juce::Rectangle<float> bounds;
                bool foundAny = false;

                std::unordered_set<int> validNodes;
                validNodes.insert(0);
                for (const auto& mod : synth->getModulesInfo())
                    validNodes.insert((int)mod.first);

                for (int nodeId : nodeIds)
                {
                    if (validNodes.find(nodeId) != validNodes.end())
                    {
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
                        if (!foundAny)
                        {
                            bounds = juce::Rectangle<float>(pos.x, pos.y, 1, 1);
                            foundAny = true;
                        }
                        else
                        {
                            bounds = bounds.getUnion(juce::Rectangle<float>(pos.x, pos.y, 1, 1));
                        }
                    }
                }

                if (!foundAny)
                    return;

                if (!nodeIds.empty() && validNodes.find(nodeIds[0]) != validNodes.end())
                    bounds = bounds.expanded(ImNodes::GetNodeDimensions(nodeIds[0]).x, ImNodes::GetNodeDimensions(nodeIds[0]).y);

                ImVec2 center((bounds.getX() + bounds.getRight()) * 0.5f,
                              (bounds.getY() + bounds.getBottom()) * 0.5f);
                ImNodes::EditorContextResetPanning(center);
            };

            if (consumeShortcutFlag(shortcutFrameSelectionRequested))
            {
                const int numSelected = ImNodes::NumSelectedNodes();
                if (numSelected > 0)
                {
                    std::vector<int> selectedNodeIds(numSelected);
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    frameNodes(selectedNodeIds);
                }
            }

            if (consumeShortcutFlag(shortcutFrameAllRequested))
            {
                if (synth != nullptr)
                {
                    auto modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0);
                    for (const auto& mod : modules)
                        allNodeIds.push_back((int)mod.first);
                    frameNodes(allNodeIds);
                }
            }

            if (consumeShortcutFlag(shortcutResetOriginRequested))
            {
                ImNodes::EditorContextResetPanning(ImVec2(0, 0));
            }

            if (consumeShortcutFlag(shortcutToggleDebugRequested))
            {
                showDebugMenu = !showDebugMenu;
            }

            if (consumeShortcutFlag(shortcutUndoRequested))
            {
                if (undoStack.size() > 1)
                {
                    Snapshot current = undoStack.back();
                    redoStack.push_back(current);
                    undoStack.pop_back();
                    restoreSnapshot(undoStack.back());
                    linkIdToAttrs.clear();
                    NotificationManager::post(NotificationManager::Type::Info, "Undo");
                }
            }

            if (consumeShortcutFlag(shortcutRedoRequested))
            {
                if (!redoStack.empty())
                {
                    Snapshot s = redoStack.back();
                    redoStack.pop_back();
                    restoreSnapshot(s);
                    undoStack.push_back(s);
                    linkIdToAttrs.clear();
                    NotificationManager::post(NotificationManager::Type::Info, "Redo");
                }
            }

            const bool duplicateRequested = consumeShortcutFlag(shortcutDuplicateRequested);
            const bool duplicateWithRoutingRequested = consumeShortcutFlag(shortcutDuplicateWithRoutingRequested);
            if (duplicateRequested || duplicateWithRoutingRequested)
            {
                const bool copyConnections = duplicateWithRoutingRequested;
                const int n = ImNodes::NumSelectedNodes();
                if (n > 0)
                {
                    std::vector<int> sel((size_t)n);
                    ImNodes::GetSelectedNodes(sel.data());
                    for (int oldId : sel)
                    {
                        if (oldId == 0)
                            continue;

                        const juce::String type = getTypeForLogical((juce::uint32)oldId);
                        if (type.isEmpty())
                            continue;

                        auto newNodeId = synth->addModule(type);
                        graphNeedsRebuild = true;
                        const juce::uint32 newLogical = synth->getLogicalIdForNode(newNodeId);
                        if (newLogical != 0)
                        {
                            if (auto* src = synth->getModuleForLogical((juce::uint32)oldId))
                                if (auto* dst = synth->getModuleForLogical(newLogical))
                                    dst->getAPVTS().replaceState(src->getAPVTS().copyState());

                            ImVec2 pos = ImNodes::GetNodeGridSpacePos(oldId);
                            pendingNodePositions[(int)newLogical] = ImVec2(pos.x + 40.0f, pos.y + 40.0f);

                            if (copyConnections)
                            {
                                const auto oldNode = synth->getNodeIdForLogical((juce::uint32)oldId);
                                const auto newNode = newNodeId;
                                for (const auto& c : synth->getConnectionsInfo())
                                {
                                    if ((int)c.srcLogicalId == oldId)
                                    {
                                        auto dstNode = (c.dstLogicalId == 0)
                                                            ? synth->getOutputNodeID()
                                                            : synth->getNodeIdForLogical(c.dstLogicalId);
                                        synth->connect(newNode, c.srcChan, dstNode, c.dstChan);
                                    }
                                    if ((int)c.dstLogicalId == oldId)
                                    {
                                        auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                                        synth->connect(srcNode, c.srcChan, newNode, c.dstChan);
                                    }
                                }
                                // TODO: Implement modulation route duplication for new bus-based system
                            }
                        }
                    }

                    pushSnapshot();
                    NotificationManager::post(NotificationManager::Type::Info, "Duplicated " + juce::String(n) + " node(s)");
                }
            }
        
        } // End of keyboard shortcuts (WantCaptureKeyboard check)

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }
    // === MIDI DEVICE MANAGER WINDOW ===
    if (showMidiDeviceManager)
    {
        if (ImGui::Begin("MIDI Device Manager", &showMidiDeviceManager, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ThemeText("MIDI Input Devices", theme.text.section_header);
            ImGui::Separator();
            
            // Access MidiDeviceManager from PresetCreatorComponent
            auto* presetCreator = dynamic_cast<PresetCreatorComponent*>(getParentComponent());
            if (presetCreator && presetCreator->midiDeviceManager)
            {
                auto& midiMgr = *presetCreator->midiDeviceManager;
                const auto& devices = midiMgr.getDevices();
                
                if (devices.empty())
                {
                    ImGui::TextDisabled("No MIDI devices found");
                }
                else
                {
                    ImGui::Text("Found %d device(s):", (int)devices.size());
                    ImGui::Spacing();
                    
                    // Display each device
                    for (const auto& device : devices)
                    {
                        ImGui::PushID(device.identifier.toRawUTF8());
                        
                        // Checkbox to enable/disable device
                        bool enabled = device.enabled;
                        if (ImGui::Checkbox("##enabled", &enabled))
                        {
                            if (enabled)
                                midiMgr.enableDevice(device.identifier);
                            else
                                midiMgr.disableDevice(device.identifier);
                        }
                        
                        ImGui::SameLine();
                        
                        // Device name
                        ImGui::Text("%s", device.name.toRawUTF8());
                        
                        // Activity indicator
                        auto activity = midiMgr.getDeviceActivity(device.identifier);
                        if (activity.lastMessageTime > 0)
                        {
                            ImGui::SameLine();
                            float timeSinceMessage = (juce::Time::getMillisecondCounter() - activity.lastMessageTime) / 1000.0f;
                            if (timeSinceMessage < 1.0f)
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.active);
                                ImGui::Text("ACTIVE");
                                ImGui::PopStyleColor();
                            }
                            else
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                                ImGui::Text("idle");
                                ImGui::PopStyleColor();
                            }
                        }
                        
                        ImGui::PopID();
                    }
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                // Rescan button
                if (ImGui::Button("Rescan Devices"))
                {
                    midiMgr.scanDevices();
                }
                
                ImGui::SameLine();
                
                // Enable/Disable all buttons
                if (ImGui::Button("Enable All"))
                {
                    midiMgr.enableAllDevices();
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Disable All"))
                {
                    midiMgr.disableAllDevices();
                }
            }
            else
            {
                ImGui::TextDisabled("MIDI Manager not available");
            }
        }
        ImGui::End();
    }

    // === DEBUG WINDOW ===
    if (showDebugMenu)
    {
        if (ImGui::Begin("System Diagnostics", &showDebugMenu))
        {
            if (synth != nullptr)
            {
                ImGui::Text("=== SYSTEM OVERVIEW ===");
                if (ImGui::Button("Refresh"))
                {
                    // Force refresh of diagnostics
                }
                
                
                // System diagnostics
                ImGui::Text("System State:");
                juce::String systemDiag = synth->getSystemDiagnostics();
                ImGui::TextWrapped("%s", systemDiag.toUTF8());
                
                
                // Module selector
                ImGui::Text("Module Diagnostics:");
                auto modules = synth->getModulesInfo();
                if (!modules.empty())
                {
                    static int selectedModuleIndex = 0;
                    if (selectedModuleIndex >= (int)modules.size()) selectedModuleIndex = 0;
                    
                    juce::String moduleList = "";
                    for (size_t i = 0; i < modules.size(); ++i)
                    {
                        if (i > 0) moduleList += "\0";
                        moduleList += "Logical " + juce::String((int)modules[i].first) + ": " + modules[i].second;
                    }
                    moduleList += "\0";
                    
                    if (ImGui::Combo("Select Module", &selectedModuleIndex, moduleList.toUTF8()))
                    {
                        if (selectedModuleIndex < (int)modules.size())
                        {
                            juce::String moduleDiag = synth->getModuleDiagnostics(modules[selectedModuleIndex].first);
                            ImGui::TextWrapped("%s", moduleDiag.toUTF8());
                        }
                    }
                }
                else
                {
                    ImGui::Text("No modules found.");
                }
            }
            else
            {
                ImGui::Text("No synth processor available.");
            }
        }
        ImGui::End();
    }

    // Keyboard Shortcuts Help Window (F1)
    if (showShortcutsWindow)
    {
        if (ImGui::Begin("Keyboard Shortcuts", &showShortcutsWindow, ImGuiWindowFlags_AlwaysAutoResize))
        {
            renderShortcutEditorContents(false);
        }
        ImGui::End();
    }

    ImGui::End();
    
    // === POP THE TRANSPARENT BACKGROUND STYLE ===
    ImGui::PopStyleColor();
    // === END OF FIX ===
    
    renderShortcutEditorWindow();

    // Render notification system (must be called at the end to appear on top)
    NotificationManager::render();
    // --- Phase 5: Periodic Stale History Cleanup ---
    static double lastCleanupTime = 0.0;
    const double currentTimeSec = juce::Time::getMillisecondCounterHiRes() / 1000.0;
    if (currentTimeSec - lastCleanupTime > 10.0) // Run every 10 seconds
    {
        lastCleanupTime = currentTimeSec;
        // Set cutoff for "stale" entries (2x the max window size = 40 seconds)
        const double staleCutoffTime = currentTimeSec - (20.0 * 2.0);
        
        for (auto it = inspectorHistory.begin(); it != inspectorHistory.end(); /* no increment */)
        {
            if (it->second.lastAccessTime < staleCutoffTime)
            {
                it = inspectorHistory.erase(it); // Erase stale entry
            }
            else
            {
                ++it;
            }
        }
    }

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::rebuildFontAtlas()
{
    ImGuiIO& io = ImGui::GetIO();
    ThemeManager::getInstance().applyFonts(io);
    ImGui_ImplOpenGL2_DestroyDeviceObjects();
    ImGui_ImplOpenGL2_CreateDeviceObjects();
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        // Temporarily mask rebuild flag to avoid ImNodes queries during capture
        const bool rebuilding = graphNeedsRebuild.load();
        if (rebuilding) {
            // getUiValueTree will still avoid ImNodes now, but assert safety
        }
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        // Do not commit pending positions of (0,0) which are placeholders
        for (int i = 0; i < applied.getNumChildren(); ++i)
        {
            auto n = applied.getChild(i);
            if (! n.hasType("node")) continue;
            const float x = (float) n.getProperty("x", 0.0f);
            const float y = (float) n.getProperty("y", 0.0f);
            if (x == 0.0f && y == 0.0f) {
                // Try to recover from last-known or pending
                const int nid = (int) n.getProperty("id", -1);
                auto itL = lastKnownNodePositions.find(nid);
                if (itL != lastKnownNodePositions.end()) { n.setProperty("x", itL->second.x, nullptr); n.setProperty("y", itL->second.y, nullptr); }
                else if (auto itP = pendingNodePositions.find(nid); itP != pendingNodePositions.end()) { n.setProperty("x", itP->second.x, nullptr); n.setProperty("y", itP->second.y, nullptr); }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        isPatchDirty = true; // Mark patch as dirty
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
    
    // Mark patch as dirty whenever a change is made
    isPatchDirty = true;
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed


juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        
        // Prefer cached position if available; never query ImNodes while rebuilding
        ImVec2 pos;
        if (lastKnownNodePositions.count(nid) > 0)
        {
            pos = lastKnownNodePositions.at(nid);
        }
        else if (auto it = pendingNodePositions.find(nid); it != pendingNodePositions.end())
        {
            pos = it->second;
        }
        else if (!graphNeedsRebuild.load() && hasRenderedAtLeastOnce)
        {
            pos = ImNodes::GetNodeGridSpacePos(nid);
        }
        else
        {
            pos = ImVec2(0.0f, 0.0f);
        }
        
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        
        // --- FIX: Save muted/bypassed state ---
        // If this node's ID is in our map of muted nodes, add the property to the XML
        if (mutedNodeStates.count(nid) > 0)
        {
            n.setProperty("muted", true, nullptr);
        }
        
        ui.addChild (n, -1, nullptr);
    }
    
    // --- FIX: Explicitly save the output node position (ID 0) ---
    // The main output node is not part of getModulesInfo(), so we need to save it separately
    
    // Prefer cached output position; avoid ImNodes when rebuilding
    ImVec2 outputPos;
    if (lastKnownNodePositions.count(0) > 0)
    {
        outputPos = lastKnownNodePositions.at(0);
    }
    else if (auto it0 = pendingNodePositions.find(0); it0 != pendingNodePositions.end())
    {
        outputPos = it0->second;
    }
    else if (!graphNeedsRebuild.load() && hasRenderedAtLeastOnce)
    {
        outputPos = ImNodes::GetNodeGridSpacePos(0);
    }
    else
    {
        outputPos = ImVec2(0.0f, 0.0f);
    }
    
    juce::ValueTree outputNode("node");
    outputNode.setProperty("id", 0, nullptr);
    outputNode.setProperty("x", outputPos.x, nullptr);
    outputNode.setProperty("y", outputPos.y, nullptr);
    ui.addChild(outputNode, -1, nullptr);
    // --- END OF FIX ---
    
    return ui;
}
void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid() || synth == nullptr) return;
    
    juce::Logger::writeToLog("[UI_RESTORE] Applying UI ValueTree now...");

    // This is the core of the crash: the synth graph has already been rebuilt by setStateInformation.
    // We must clear our stale UI data (like muted nodes) before applying the new state from the preset.
    mutedNodeStates.clear();
    
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);

        // ========================= THE FIX STARTS HERE =========================
        //
        // Before applying any property, VERIFY that this node ID actually exists
        // in the synth. This prevents crashes when loading presets that contain
        // modules which are not available in the current build.
        //
        bool nodeExistsInSynth = (nid == 0); // Node 0 is always the output node.
        if (!nodeExistsInSynth) {
            for (const auto& modInfo : synth->getModulesInfo()) {
                if ((int)modInfo.first == nid) {
                    nodeExistsInSynth = true;
                    break;
                }
            }
        }

        if (!nodeExistsInSynth)
        {
            juce::Logger::writeToLog("[UI_RESTORE] WARNING: Skipping UI properties for non-existent node ID " + juce::String(nid) + ". The module may be missing or failed to load.");
            continue; // Skip to the next node in the preset.
        }
        // ========================== END OF FIX ==========================

        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        if (!(x == 0.0f && y == 0.0f))
        {
            pendingNodePositions[nid] = ImVec2(x, y);
            juce::Logger::writeToLog("[UI_RESTORE] Queued position for node " + juce::String(nid) + ": (" + juce::String(x) + ", " + juce::String(y) + ")");
        }
        
        // Read and apply muted state from preset for existing nodes.
        if ((bool) n.getProperty("muted", false))
        {
            // Use muteNodeSilent to store the original connections first,
            // then apply the mute (which creates bypass connections)
            muteNodeSilent(nid);
            muteNode(nid);
        }
    }
    
    // Muting/unmuting modifies graph connections, so we must tell the
    // synth to rebuild its processing order.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[UI_RESTORE] UI state applied. Flagging for graph rebuild.");
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::renderShortcutEditorWindow()
{
    if (showShortcutEditorWindow)
    {
        ImGui::OpenPopup("Shortcut Editor");
        showShortcutEditorWindow = false;
    }

    // Ensure popup background is fully opaque (uses ImGuiCol_PopupBg from theme)
    ImGui::SetNextWindowBgAlpha(1.0f);
    
    if (ImGui::BeginPopupModal("Shortcut Editor", nullptr, ImGuiWindowFlags_AlwaysAutoResize))
    {
        renderShortcutEditorContents(true);

        ImGui::EndPopup();
    }

    if (!ImGui::IsPopupOpen("Shortcut Editor"))
    {
        if (shortcutsDirty)
            saveUserShortcutBindings();
        if (shortcutCaptureState.isCapturing)
            cancelShortcutCapture();
    }
}
void ImGuiNodeEditorComponent::renderShortcutEditorTable(const juce::Identifier& context)
{
    const auto& registry = shortcutManager.getRegistry();
    std::vector<std::pair<juce::Identifier, collider::ShortcutAction>> actions;
    actions.reserve(registry.size());
    for (const auto& entry : registry)
        actions.emplace_back(entry.first, entry.second);

    std::sort(actions.begin(), actions.end(), [](const auto& a, const auto& b)
    {
        int categoryCompare = a.second.category.compareIgnoreCase(b.second.category);
        if (categoryCompare != 0)
            return categoryCompare < 0;
        return a.second.name.compareIgnoreCase(b.second.name) < 0;
    });

    if (ImGui::BeginTable("shortcut-editor-table", 5, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable))
    {
        ImGui::TableSetupColumn("Category", ImGuiTableColumnFlags_WidthFixed, 140.0f);
        ImGui::TableSetupColumn("Action", ImGuiTableColumnFlags_WidthStretch);
        ImGui::TableSetupColumn("Binding", ImGuiTableColumnFlags_WidthFixed, 160.0f);
        ImGui::TableSetupColumn("Source", ImGuiTableColumnFlags_WidthFixed, 160.0f);
        ImGui::TableSetupColumn("Options", ImGuiTableColumnFlags_WidthFixed, 200.0f);
        ImGui::TableHeadersRow();

        juce::String previousCategory;
        for (const auto& [actionId, action] : actions)
        {
            if (shortcutsSearchTerm.isNotEmpty())
            {
                const juce::String search = shortcutsSearchTerm;
                if (!action.name.containsIgnoreCase(search)
                    && !action.description.containsIgnoreCase(search)
                    && !action.category.containsIgnoreCase(search))
                {
                    continue;
                }
            }

            const bool categoryChanged = previousCategory != action.category;
            renderShortcutRow(action, actionId, context, categoryChanged);
            previousCategory = action.category;
        }

        ImGui::EndTable();
    }
}

void ImGuiNodeEditorComponent::renderShortcutRow(const collider::ShortcutAction& action,
                                                 const juce::Identifier& actionId,
                                                 const juce::Identifier& context,
                                                 bool categoryChanged)
{
    ImGui::TableNextRow();

    ImGui::TableSetColumnIndex(0);
    if (categoryChanged)
        ImGui::TextUnformatted(action.category.toRawUTF8());

    ImGui::TableSetColumnIndex(1);
    ImGui::TextUnformatted(action.name.toRawUTF8());
    if (!action.description.isEmpty() && ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::TextUnformatted(action.description.toRawUTF8());
        ImGui::EndTooltip();
    }

    ImGui::TableSetColumnIndex(2);
    juce::String sourceLabel;
    juce::String bindingLabel = getBindingLabelForContext(actionId, context, sourceLabel);
    ImGui::TextUnformatted(bindingLabel.toRawUTF8());

    ImGui::TableSetColumnIndex(3);
    ImGui::TextUnformatted(sourceLabel.toRawUTF8());

    ImGui::TableSetColumnIndex(4);
    juce::String assignId = "Assign##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(assignId.toRawUTF8()))
    {
        beginShortcutCapture(actionId, context);
    }

    ImGui::SameLine();
    juce::String clearId = "Clear##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(clearId.toRawUTF8()))
    {
        clearShortcutForContext(actionId, context);
    }

    ImGui::SameLine();
    juce::String resetId = "Reset##" + actionId.toString() + ":" + context.toString();
    if (ImGui::Button(resetId.toRawUTF8()))
    {
        resetShortcutForContext(actionId, context);
    }
}

void ImGuiNodeEditorComponent::renderShortcutEditorContents(bool includeCloseButton)
{
    updateShortcutCapture();

    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    const juce::Identifier contexts[] = { globalContext, nodeEditorContextId };
    int selectedIndex = (shortcutContextSelection == globalContext) ? 0 : 1;

    if (ImGui::BeginCombo("Context", contextDisplayName(shortcutContextSelection).toRawUTF8()))
    {
        for (int i = 0; i < 2; ++i)
        {
            const bool isSelected = (selectedIndex == i);
            if (ImGui::Selectable(contextDisplayName(contexts[i]).toRawUTF8(), isSelected))
                shortcutContextSelection = contexts[i];
            if (isSelected)
                ImGui::SetItemDefaultFocus();
        }
        ImGui::EndCombo();
    }

    char searchBuffer[128] = {};
    std::strncpy(searchBuffer, shortcutsSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    if (ImGui::InputTextWithHint("##shortcut-search", "Search actions‚Ä¶", searchBuffer, sizeof(searchBuffer)))
    {
        shortcutsSearchTerm = juce::String(searchBuffer).trim();
    }

    ImGui::Separator();
    renderShortcutEditorTable(shortcutContextSelection);

    renderShortcutCapturePanel();

    ImGui::Separator();
    if (ImGui::Button("Save Changes"))
    {
        saveUserShortcutBindings();
    }

    if (includeCloseButton)
    {
        ImGui::SameLine();
        if (ImGui::Button("Close"))
        {
            ImGui::CloseCurrentPopup();
        }
    }
}

void ImGuiNodeEditorComponent::renderShortcutCapturePanel()
{
    if (!shortcutCaptureState.isCapturing)
        return;

    const auto& registry = shortcutManager.getRegistry();
    juce::String actionName = shortcutCaptureState.actionId.toString();
    if (auto it = registry.find(shortcutCaptureState.actionId); it != registry.end())
        actionName = it->second.name;

    ImGui::Text("Assigning: %s (%s)",
                actionName.toRawUTF8(),
                contextDisplayName(shortcutCaptureState.context).toRawUTF8());
    ImGui::TextUnformatted("Press a key combination‚Ä¶ (Esc to cancel)");
}

void ImGuiNodeEditorComponent::beginShortcutCapture(const juce::Identifier& actionId, const juce::Identifier& context)
{
    shortcutCaptureState = {};
    shortcutCaptureState.isCapturing = true;
    shortcutCaptureState.actionId = actionId;
    shortcutCaptureState.context = context;
}

void ImGuiNodeEditorComponent::updateShortcutCapture()
{
    if (!shortcutCaptureState.isCapturing)
        return;

    if (ImGui::IsKeyPressed(ImGuiKey_Escape, false))
    {
        cancelShortcutCapture();
        return;
    }

    const ImGuiIO& io = ImGui::GetIO();
    for (int keyIndex = ImGuiKey_NamedKey_BEGIN; keyIndex < ImGuiKey_NamedKey_END; ++keyIndex)
    {
        const ImGuiKey key = static_cast<ImGuiKey>(keyIndex);

        if (key >= ImGuiKey_MouseLeft && key <= ImGuiKey_MouseWheelY)
            continue;
        if (key >= ImGuiKey_ReservedForModCtrl)
            continue;

        const ImGuiKeyData* data = ImGui::GetKeyData(key);
        if (data == nullptr)
            continue;

        if (data->Down && data->DownDuration == 0.0f)
        {
            shortcutCaptureState.captured = collider::KeyChord::fromImGui(io, key);
            shortcutCaptureState.hasCaptured = shortcutCaptureState.captured.isValid();
            evaluateShortcutCaptureConflict();
            applyShortcutCapture(true);
            break;
        }
    }
}

void ImGuiNodeEditorComponent::cancelShortcutCapture()
{
    shortcutCaptureState = {};
}

void ImGuiNodeEditorComponent::applyShortcutCapture(bool forceReplace)
{
    if (!shortcutCaptureState.isCapturing || !shortcutCaptureState.hasCaptured || !shortcutCaptureState.captured.isValid())
        return;

    const auto& actionId = shortcutCaptureState.actionId;
    const auto& context = shortcutCaptureState.context;

    if (auto userBinding = shortcutManager.getUserBinding(actionId, context))
    {
        if (userBinding->isValid() && chordsEqual(*userBinding, shortcutCaptureState.captured))
        {
            cancelShortcutCapture();
            return;
        }
    }

    if (auto defaultBinding = shortcutManager.getDefaultBinding(actionId, context))
    {
        if (defaultBinding->isValid() && chordsEqual(*defaultBinding, shortcutCaptureState.captured))
        {
            if (shortcutManager.removeUserBinding(actionId, context))
                shortcutsDirty = true;
            cancelShortcutCapture();
            return;
        }
    }

    if (shortcutCaptureState.conflictActionId.isValid())
    {
        if (!forceReplace)
            return;

        clearShortcutForContext(shortcutCaptureState.conflictActionId, shortcutCaptureState.conflictContextId);
    }

    shortcutManager.setUserBinding(actionId, context, shortcutCaptureState.captured);
    shortcutsDirty = true;
    cancelShortcutCapture();
}

void ImGuiNodeEditorComponent::evaluateShortcutCaptureConflict()
{
    shortcutCaptureState.conflictActionId = {};
    shortcutCaptureState.conflictContextId = {};
    shortcutCaptureState.conflictIsUserBinding = false;

    if (!shortcutCaptureState.hasCaptured || !shortcutCaptureState.captured.isValid())
        return;

    const auto& chord = shortcutCaptureState.captured;
    const auto& targetAction = shortcutCaptureState.actionId;
    const auto& targetContext = shortcutCaptureState.context;
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();

    const auto& registry = shortcutManager.getRegistry();
    const juce::Identifier contextsToCheck[] = { globalContext, nodeEditorContextId };

    auto isSameChord = [&](const juce::Identifier& actionId, const juce::Identifier& contextId, const juce::Optional<collider::KeyChord>& chordOpt, bool isUser)
    {
        if (!chordOpt.hasValue() || !chordOpt->isValid())
            return false;
        if (!chordsEqual(*chordOpt, chord))
            return false;

        shortcutCaptureState.conflictActionId = actionId;
        shortcutCaptureState.conflictContextId = contextId;
        shortcutCaptureState.conflictIsUserBinding = isUser;
        return true;
    };

    // Ignore if chord matches current binding for this action/context
    auto currentBinding = shortcutManager.getBindingForContext(targetAction, targetContext);
    if (currentBinding.isValid() && chordsEqual(currentBinding, chord))
        return;

    for (const auto& [actionId, action] : registry)
    {
        for (const auto& ctx : contextsToCheck)
        {
            if (ctx != targetContext && targetContext == globalContext && ctx != globalContext)
                continue; // when editing global, only check global + other contexts once

            auto userBinding = shortcutManager.getUserBinding(actionId, ctx);
            if (isSameChord(actionId, ctx, userBinding, true))
                return;

            auto defaultBinding = shortcutManager.getDefaultBinding(actionId, ctx);
            // Only check default if no user override
            if (!userBinding.hasValue())
            {
                if (isSameChord(actionId, ctx, defaultBinding, false))
                    return;
            }
        }
    }
}

void ImGuiNodeEditorComponent::clearShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context)
{
    collider::KeyChord cleared;
    shortcutManager.setUserBinding(actionId, context, cleared);
    shortcutsDirty = true;

    if (shortcutCaptureState.isCapturing &&
        shortcutCaptureState.actionId == actionId &&
        shortcutCaptureState.context == context)
    {
        cancelShortcutCapture();
    }
}

void ImGuiNodeEditorComponent::resetShortcutForContext(const juce::Identifier& actionId, const juce::Identifier& context)
{
    if (shortcutManager.removeUserBinding(actionId, context))
    {
        shortcutsDirty = true;
    }

    if (shortcutCaptureState.isCapturing &&
        shortcutCaptureState.actionId == actionId &&
        shortcutCaptureState.context == context)
    {
        cancelShortcutCapture();
    }
}

void ImGuiNodeEditorComponent::saveUserShortcutBindings()
{
    if (userShortcutFile.getFullPathName().isEmpty())
        return;

    auto parent = userShortcutFile.getParentDirectory();
    if (!parent.isDirectory())
        parent.createDirectory();

    shortcutManager.saveUserBindingsToFile(userShortcutFile);
    shortcutsDirty = false;
}

juce::String ImGuiNodeEditorComponent::getBindingLabelForContext(const juce::Identifier& actionId,
                                                                 const juce::Identifier& context,
                                                                 juce::String& sourceLabel) const
{
    const auto& globalContext = collider::ShortcutManager::getGlobalContextIdentifier();
    auto userBinding = shortcutManager.getUserBinding(actionId, context);
    if (userBinding.hasValue())
    {
        if (userBinding->isValid())
        {
            sourceLabel = "User";
            return userBinding->toString();
        }

        sourceLabel = "User (cleared)";
        return "Unassigned";
    }

    auto defaultBinding = shortcutManager.getDefaultBinding(actionId, context);
    if (defaultBinding.hasValue() && defaultBinding->isValid())
    {
        sourceLabel = "Default";
        return defaultBinding->toString();
    }

    if (context != globalContext)
    {
        auto userGlobal = shortcutManager.getUserBinding(actionId, globalContext);
        if (userGlobal.hasValue())
        {
            if (userGlobal->isValid())
            {
                sourceLabel = "Global (user)";
                return userGlobal->toString();
            }

            sourceLabel = "Global (user cleared)";
            return "Unassigned";
        }

        auto defaultGlobal = shortcutManager.getDefaultBinding(actionId, globalContext);
        if (defaultGlobal.hasValue() && defaultGlobal->isValid())
        {
            sourceLabel = "Global (default)";
            return defaultGlobal->toString();
        }
    }

    sourceLabel = "Unassigned";
    return "Unassigned";
}
void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    const bool bypassRequested = consumeShortcutFlag(shortcutBypassDeleteRequested);
    const bool deleteRequested = consumeShortcutFlag(shortcutDeleteRequested);

    if (!bypassRequested && !deleteRequested)
        return;

    if (bypassRequested)
    {
        bypassDeleteSelectedNodes();
        return;
    }

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            // TODO: Handle modulation link deletion for new bus-based system
            // if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
            // {
            //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
            //     // TODO: Handle modulation route removal
            //     // if (paramId.isNotEmpty())
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL, paramId);
            //     // else
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            // }
            // else 
            if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            
            // Clean up vision module textures if exists
            if (visionModuleTextures.count(nid))
            {
                visionModuleTextures.erase(nid);
            }
            
            // Clean up sample loader textures if exists
            if (sampleLoaderTextureIds.count(nid))
            {
                sampleLoaderTextureIds.erase(nid);
            }
            
            mutedNodeStates.erase((juce::uint32)nid); // Clean up muted state if exists
            lastKnownNodePositions.erase(nid); // Clean up position cache
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}
void ImGuiNodeEditorComponent::bypassDeleteSelectedNodes()
{
    const int numSelNodes = ImNodes::NumSelectedNodes();
    if (numSelNodes <= 0 || synth == nullptr)
        return;

    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    std::vector<int> nodeIds((size_t) numSelNodes);
    ImNodes::GetSelectedNodes(nodeIds.data());

    for (int nid : nodeIds)
    {
        if (nid == 0)
            continue;

        bypassDeleteNode((juce::uint32) nid);
    }

    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}

void ImGuiNodeEditorComponent::bypassDeleteNode(juce::uint32 logicalId)
{
    // Collect all incoming/outgoing audio links for this node
    std::vector<decltype(synth->getConnectionsInfo())::value_type> inputs, outputs;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) inputs.push_back(c);
        if (c.srcLogicalId == logicalId) outputs.push_back(c);
    }

    // For each output channel, find matching input channel to splice
    for (const auto& out : outputs)
    {
        // Try to find input with same channel index, else fallback to first input
        const auto* inPtr = (const decltype(inputs)::value_type*) nullptr;
        for (const auto& in : inputs) { if (in.dstChan == out.srcChan) { inPtr = &in; break; } }
        if (inPtr == nullptr && !inputs.empty()) inPtr = &inputs.front();

        // Disconnect out link first
        auto srcNode = synth->getNodeIdForLogical(out.srcLogicalId);
        auto dstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
        synth->disconnect(srcNode, out.srcChan, dstNode, out.dstChan);

        if (inPtr != nullptr)
        {
            // Disconnect incoming link from the node
            auto inSrcNode = synth->getNodeIdForLogical(inPtr->srcLogicalId);
            auto inDstNode = synth->getNodeIdForLogical(inPtr->dstLogicalId);
            synth->disconnect(inSrcNode, inPtr->srcChan, inDstNode, inPtr->dstChan);

            // Connect source of incoming directly to destination of outgoing
            auto finalDstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
            synth->connect(inSrcNode, inPtr->srcChan, finalDstNode, out.dstChan);
        }
    }

    // TODO: Remove modulation routes targeting or originating this node using new bus-based system

    // Finally remove the node itself
    mutedNodeStates.erase(logicalId); // Clean up muted state if exists
    synth->removeModule(synth->getNodeIdForLogical(logicalId));
}

// === Non-Destructive Mute/Bypass Implementation ===

void ImGuiNodeEditorComponent::muteNodeSilent(juce::uint32 logicalId)
{
    // This function is used when loading presets. It records the connections that were
    // loaded from the XML without modifying the graph or creating bypass connections.
    // This preserves the original "unmuted" connections for later use.
    
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // Store all connections attached to this node
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // Store the state, but DON'T modify the graph or create bypass connections
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[MuteSilent] Node " + juce::String(logicalId) + 
                            " marked as muted, stored " + juce::String(state.incomingConnections.size()) + 
                            " incoming and " + juce::String(state.outgoingConnections.size()) + 
                            " outgoing connections.");
}
void ImGuiNodeEditorComponent::muteNode(juce::uint32 logicalId)
{
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // 1. Find and store all connections attached to this node.
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // 2. Disconnect all of them.
    for (const auto& c : state.incomingConnections) {
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }
    
    // --- FIX: More robust bypass splicing logic ---
    // 3. Splice the connections to bypass the node.
    // Connect the FIRST input source to ALL output destinations.
    // This correctly handles cases where input channel != output channel (e.g., Mixer input 3 ‚Üí output 0).
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Connect the primary input's source directly to the original output's destination
            synth->connect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Mute] Splicing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 4. Store the original state.
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " muted and bypassed.");
}

void ImGuiNodeEditorComponent::unmuteNode(juce::uint32 logicalId)
{
    if (!synth || mutedNodeStates.find(logicalId) == mutedNodeStates.end()) return;

    MutedNodeState state = mutedNodeStates[logicalId];

    // --- FIX: Remove bypass connections matching the new mute logic ---
    // 1. Find and remove the bypass connections.
    // The bypass connected the first input source to all output destinations.
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Disconnect the bypass connection
            synth->disconnect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Unmute] Removing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 2. Restore the original connections.
    for (const auto& c : state.incomingConnections) {
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }

    // 3. Remove from muted state.
    mutedNodeStates.erase(logicalId);
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " unmuted.");
}
void ImGuiNodeEditorComponent::handleMuteToggle()
{
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected == 0) return;

    pushSnapshot(); // Create a single undo state for the whole operation.

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    for (int lid : selectedNodeIds) {
        if (mutedNodeStates.count(lid)) {
            unmuteNode(lid);
        } else {
            muteNode(lid);
        }
    }

    graphNeedsRebuild = true;
}
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    bool wasAlreadyInProgress = isSaveInProgress.exchange(true); // Atomically check and set
    if (wasAlreadyInProgress)
    {
        juce::Logger::writeToLog("[SaveWorkflow] Save action ignored (already in progress). Current flag state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Flag set to TRUE. Starting save workflow for: " + file.getFullPathName());

    if (synth == nullptr) {
        juce::Logger::writeToLog("[SaveWorkflow] ERROR: Synth is null! Resetting flag and aborting.");
        NotificationManager::post(NotificationManager::Type::Error, "ERROR: Synth not ready!");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after synth null check.");
        return;
    }

    juce::Logger::writeToLog("--- [Save Workflow] Initiated for: " + file.getFullPathName() + " ---");
    
    // Post status notification (long duration since it will be replaced by Success/Error when complete)
    NotificationManager::post(NotificationManager::Type::Status, "Saving: " + file.getFileNameWithoutExtension(), 1000.0f);
    
    // --- All fast operations now happen on the UI thread BEFORE the job is launched ---
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Capturing state...");
    auto mutedNodeIDs = getMutedNodeIds();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Found " + juce::String((int)mutedNodeIDs.size()) + " muted nodes.");

    // Temporarily unmute to get correct connections
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Temporarily unmuting nodes for state capture...");
    for (auto lid : mutedNodeIDs) unmuteNode(lid);
    synth->commitChanges();

    // Capture state while unmuted
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling synth->getStateInformation()...");
    juce::MemoryBlock synthState;
    try {
        synth->getStateInformation(synthState);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Synth state captured (" + juce::String(synthState.getSize()) + " bytes).");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION in getStateInformation: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION in getStateInformation");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    }
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling editor->getUiValueTree()...");
    juce::ValueTree uiState = getUiValueTree();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UI state captured (valid: " + juce::String(uiState.isValid() ? 1 : 0) + ").");

    // Immediately re-mute to restore visual state
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Re-muting nodes to restore visual state...");
    for (auto lid : mutedNodeIDs) muteNode(lid);
    synth->commitChanges();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] State captured. Offloading to background thread.");

    // Launch the background job with the captured data
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Creating SavePresetJob...");
    auto* job = new SavePresetJob(synthState, uiState, file);

    job->onSaveComplete = [this, filePath = file.getFullPathName()](const juce::File& savedFile, bool success) {
        juce::Logger::writeToLog("[SaveWorkflow] onSaveComplete callback called (success: " + juce::String(success ? 1 : 0) + ") for: " + savedFile.getFullPathName());
        
        if (success) {
            NotificationManager::post(NotificationManager::Type::Success, "Saved: " + savedFile.getFileNameWithoutExtension());
            isPatchDirty = false;
            currentPresetFile = savedFile;
            juce::Logger::writeToLog("[SaveWorkflow] Save completed successfully. Flag will be reset.");
        } else {
            juce::Logger::writeToLog("[SaveWorkflow] Save FAILED. Flag will be reset.");
            NotificationManager::post(NotificationManager::Type::Error, "Failed to save preset!");
        }
        
        juce::Logger::writeToLog("[SaveWorkflow] Resetting isSaveInProgress flag to FALSE.");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset complete. Current state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    };

    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Adding job to thread pool...");
    try {
        threadPool.addJob(job, true);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Job added to thread pool successfully.");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION adding job to thread pool: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION adding job to thread pool");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    }
}
void ImGuiNodeEditorComponent::startSaveDialog()
{
    juce::Logger::writeToLog("[SaveWorkflow] startSaveDialog() called. isSaveInProgress: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    
    // Check if a save is already in progress to avoid opening multiple dialogs
    if (isSaveInProgress.load()) {
        juce::Logger::writeToLog("[SaveWorkflow] 'Save As' action ignored (a save is already in progress).");
        NotificationManager::post(NotificationManager::Type::Warning, "A save operation is already in progress. Please wait...", 3.0f);
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Opening file chooser dialog...");
    auto presetsDir = findPresetsDirectory();
    juce::Logger::writeToLog("[SaveWorkflow] Presets directory: " + presetsDir.getFullPathName());
    
    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      presetsDir, 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        juce::Logger::writeToLog("[SaveWorkflow] File chooser callback invoked.");
        auto fileToSave = fc.getResult();
        
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            juce::Logger::writeToLog("[SaveWorkflow] User selected file: " + fileToSave.getFullPathName());
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
        else
        {
            juce::Logger::writeToLog("[SaveWorkflow] User cancelled file chooser dialog.");
        }
    });
    juce::Logger::writeToLog("[SaveWorkflow] File chooser launched (async).");
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::getMutedNodeIds() const
{
    std::vector<juce::uint32> ids;
    // MutedNodeState is a map, so we don't need a lock if we're just reading keys
    for (const auto& pair : mutedNodeStates)
    {
        ids.push_back(pair.first);
    }
    return ids;
}


void ImGuiNodeEditorComponent::startLoadDialog()
{
    NotificationManager::post(NotificationManager::Type::Info, "Opening Load Preset dialog...", 3.0f);
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", findPresetsDirectory(), "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (!file.existsAsFile()) return;
        NotificationManager::post(NotificationManager::Type::Info, "Loading: " + file.getFileName(), 5.0f);

        auto xml = juce::XmlDocument::parse(file);
        if (!xml)
        {
            NotificationManager::post(NotificationManager::Type::Error, "Preset failed to load: Not a valid XML file.");
            return;
        }
        juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);

        // === STAGE 1 & 2: HEAL THE PRESET (RULE-BASED) ===
        PresetAutoHealer healer;
        auto healingMessages = healer.heal(presetVT);

        // === STAGE 3: VALIDATE THE (NOW HEALED) PRESET ===
        PresetValidator validator;
        auto issues = validator.validate(presetVT);
        int errorCount = 0;
        int warningCount = 0;
        for (const auto& issue : issues)
        {
            if (issue.severity == PresetValidator::Issue::Error) errorCount++; else warningCount++;
        }

        // Report errors/warnings but proceed to load to match built-in loader behavior
        if (errorCount > 0)
        {
            juce::String summary = "Validation found " + juce::String(errorCount) + " error(s). Attempting load anyway.";
            if (!healingMessages.empty()) summary += " (" + juce::String((int)healingMessages.size()) + " issue(s) auto-healed).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 12.0f);
            for (const auto& issue : issues)
            {
                if (issue.severity == PresetValidator::Issue::Error)
                    NotificationManager::post(NotificationManager::Type::Warning, issue.message, 12.0f);
            }
        }

        // === STAGE 4: LOAD THE HEALED DATA ===
        juce::MemoryBlock mb;
        juce::MemoryOutputStream mos(mb, false);
        if (auto healedXml = presetVT.createXml()) healedXml->writeTo(mos);
        synth->setStateInformation(mb.getData(), (int)mb.getSize());
        auto uiState = presetVT.getChildWithName("NodeEditorUI");
        if (uiState.isValid()) applyUiValueTree(uiState);
        isPatchDirty = false;
        currentPresetFile = file;
        pushSnapshot();

        // === STAGE 5: NOTIFY ===
        if (!healingMessages.empty() || warningCount > 0 || errorCount > 0)
        {
            juce::String summary = "Loaded with " + juce::String(warningCount + errorCount) + " issue(s).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 8.0f);
            for (const auto& msg : healingMessages)
                NotificationManager::post(NotificationManager::Type::Info, msg, 8.0f);
            for (const auto& issue : issues)
                NotificationManager::post(
                    issue.severity == PresetValidator::Issue::Warning ? NotificationManager::Type::Warning
                                                                       : NotificationManager::Type::Warning,
                    issue.message, 8.0f);
        }
        else
        {
            NotificationManager::post(NotificationManager::Type::Success, "Loaded: " + file.getFileNameWithoutExtension());
        }
    });
}
void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "vco", "noise", "sequencer", "vcf", "delay", "reverb", "waveshaper",
        "lfo", "adsr", "random", "s_and_h", "math", "map_range", "quantizer", "clock_divider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    addedModules.push_back({mixerId, "mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));
    addedModules.push_back({scopeId, "scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "mixer") finalMixerId = mod.first;
        if (mod.second == "scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "mixer") mixerId = mod.first;
        if (mod.second == "scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}
void ImGuiNodeEditorComponent::handleBeautifyLayout()
{
    if (synth == nullptr) return;

    // Graph is always in consistent state since we rebuild at frame start
    // Create an undo state so the action can be reversed
    pushSnapshot();
    juce::Logger::writeToLog("--- [Beautify Layout] Starting ---");

    // --- STEP 1: Build Graph Representation ---
    // Adjacency list: map<source_lid, vector<destination_lid>>
    std::map<juce::uint32, std::vector<juce::uint32>> adjacencyList;
    std::map<juce::uint32, int> inDegree; // Counts incoming connections for each node
    std::vector<juce::uint32> sourceNodes;

    auto modules = synth->getModulesInfo();
    for (const auto& mod : modules)
    {
        inDegree[mod.first] = 0;
        adjacencyList[mod.first] = {};
    }
    // Include the output node in the graph
    inDegree[0] = 0; // Output node ID is 0
    adjacencyList[0] = {}; // Output node has no outgoing connections

    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput)
        {
            adjacencyList[conn.srcLogicalId].push_back(0); // Connect to output node
            inDegree[0]++;
        }
        else
        {
            adjacencyList[conn.srcLogicalId].push_back(conn.dstLogicalId);
            inDegree[conn.dstLogicalId]++;
        }
    }

    for (const auto& mod : modules)
    {
        if (inDegree[mod.first] == 0)
        {
            sourceNodes.push_back(mod.first);
        }
    }

    juce::Logger::writeToLog("[Beautify] Found " + juce::String(sourceNodes.size()) + " source nodes");

    // --- STEP 2: Assign Nodes to Columns (Topological Sort) ---
    std::map<juce::uint32, int> nodeColumn;
    std::vector<std::vector<juce::uint32>> columns;
    int maxColumn = 0;

    // Initialize source nodes in column 0
    for (juce::uint32 nodeId : sourceNodes)
    {
        nodeColumn[nodeId] = 0;
    }
    columns.push_back(sourceNodes);

    // Process each column and assign children to appropriate columns
    std::queue<juce::uint32> processQueue;
    for (juce::uint32 srcNode : sourceNodes)
        processQueue.push(srcNode);

    while (!processQueue.empty())
    {
        juce::uint32 u = processQueue.front();
        processQueue.pop();

        for (juce::uint32 v : adjacencyList[u])
        {
            // The column for node 'v' is the maximum of its predecessors' columns + 1
            int newColumn = nodeColumn[u] + 1;
            if (nodeColumn.count(v) == 0 || newColumn > nodeColumn[v])
            {
                nodeColumn[v] = newColumn;
                maxColumn = std::max(maxColumn, newColumn);
                processQueue.push(v);
            }
        }
    }

    // Re-populate columns based on assignments
    columns.assign(maxColumn + 1, {});
    for (const auto& pair : nodeColumn)
    {
        columns[pair.second].push_back(pair.first);
    }

    juce::Logger::writeToLog("[Beautify] Arranged nodes into " + juce::String(maxColumn + 1) + " columns");

    // --- STEP 3: Optimize Node Ordering Within Columns ---
    // Sort nodes in each column based on median position of their parents
    for (int c = 1; c <= maxColumn; ++c)
    {
        std::map<juce::uint32, float> medianPositions;
        
        for (juce::uint32 nodeId : columns[c])
        {
            std::vector<float> parentPositions;
            
            // Find all parents in previous columns
            for (const auto& pair : adjacencyList)
            {
                for (juce::uint32 dest : pair.second)
                {
                    if (dest == nodeId)
                    {
                        // Find the vertical index of the parent node
                        int parentColumn = nodeColumn[pair.first];
                        auto& parentColVec = columns[parentColumn];
                        auto it = std::find(parentColVec.begin(), parentColVec.end(), pair.first);
                        if (it != parentColVec.end())
                        {
                            parentPositions.push_back((float)std::distance(parentColVec.begin(), it));
                        }
                    }
                }
            }
            
            if (!parentPositions.empty())
            {
                std::sort(parentPositions.begin(), parentPositions.end());
                medianPositions[nodeId] = parentPositions[parentPositions.size() / 2];
            }
            else
            {
                medianPositions[nodeId] = 0.0f;
            }
        }
        
        // Sort the column based on median positions
        std::sort(columns[c].begin(), columns[c].end(), [&](juce::uint32 a, juce::uint32 b) {
            return medianPositions[a] < medianPositions[b];
        });
    }

    // --- STEP 4: Calculate Final Coordinates ---
    const float COLUMN_WIDTH = 400.0f;
    const float NODE_VERTICAL_PADDING = 50.0f;

    // Find the tallest column to center shorter ones
    float tallestColumnHeight = 0.0f;
    for (const auto& col : columns)
    {
        float height = 0.0f;
        for (juce::uint32 lid : col)
        {
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            height += nodeSize.y + NODE_VERTICAL_PADDING;
        }
        tallestColumnHeight = std::max(tallestColumnHeight, height);
    }

    // --- STEP 5: Apply Positions ---
    for (int c = 0; c <= maxColumn; ++c)
    {
        // Calculate column height for centering
        float columnHeight = 0.0f;
        for (juce::uint32 lid : columns[c])
        {
            columnHeight += ImNodes::GetNodeDimensions((int)lid).y + NODE_VERTICAL_PADDING;
        }
        
        // Start Y position (centered vertically)
        float currentY = (tallestColumnHeight - columnHeight) / 2.0f;

        for (juce::uint32 lid : columns[c])
        {
            float x = c * COLUMN_WIDTH;
            pendingNodePositions[(int)lid] = ImVec2(x, currentY);
            
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            currentY += nodeSize.y + NODE_VERTICAL_PADDING;
        }
    }

    // Position the output node to the right of all other modules
    float finalX = (maxColumn + 1) * COLUMN_WIDTH;
    float outputNodeY = (tallestColumnHeight - ImNodes::GetNodeDimensions(0).y) / 2.0f;
    pendingNodePositions[0] = ImVec2(finalX, outputNodeY);
    juce::Logger::writeToLog("[Beautify] Applied position to Output Node");
    
    juce::Logger::writeToLog("[Beautify] Applied positions to " + juce::String(modules.size()) + " nodes");
    juce::Logger::writeToLog("--- [Beautify Layout] Complete ---");
}
void ImGuiNodeEditorComponent::handleConnectSelectedToTrackMixer()
{
    if (synth == nullptr || ImNodes::NumSelectedNodes() <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: No synth or no nodes selected.");
        return;
    }

    // This is a significant action, so create an undo state first.
    pushSnapshot();
    juce::Logger::writeToLog("--- [Connect to Mixer] Starting routine ---");

    // 1. Get all selected node IDs.
    const int numSelectedNodes = ImNodes::NumSelectedNodes();
    std::vector<int> selectedNodeLids(numSelectedNodes);
    ImNodes::GetSelectedNodes(selectedNodeLids.data());

    // 2. Find the geometric center of the selected nodes to position our new modules.
    float totalX = 0.0f, maxX = 0.0f, totalY = 0.0f;
    for (int lid : selectedNodeLids)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(lid);
        totalX += pos.x;
        totalY += pos.y;
        if (pos.x > maxX) {
            maxX = pos.x;
        }
    }
    ImVec2 centerPos = ImVec2(totalX / numSelectedNodes, totalY / numSelectedNodes);
    
    // 3. Create the Value node and set its value to the number of selected nodes.
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    if (auto* valueProc = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(valueProc->getAPVTS().getParameter("value")))
        {
            *p = (float)numSelectedNodes;
            juce::Logger::writeToLog("[AutoConnect] Created Value node " + juce::String(valueLid) + " and set its value to " + juce::String(numSelectedNodes));
        }
    }
    // Position it slightly to the right of the center of the selection.
    pendingNodePositions[(int)valueLid] = ImVec2(centerPos.x + 400.0f, centerPos.y);

    // 4. Create the Track Mixer node.
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    // Position it to the right of the right-most selected node for a clean signal flow.
    pendingNodePositions[(int)mixerLid] = ImVec2(maxX + 800.0f, centerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 5. Connect the Value node to the Track Mixer's "Num Tracks Mod" input.
    // The Value module's "Raw" output is channel 0 (provides the exact value entered by the user).
    // The Track Mixer's "Num Tracks Mod" is on Bus 1, Channel 0, which is absolute channel 64.
    synth->connect(valueNodeId, 0, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected Value node 'Raw' output to Track Mixer's Num Tracks Mod input.");

    // 6. Connect the primary audio output of each selected node to a unique input on the Track Mixer.
    int mixerInputChannel = 0;
    for (int lid : selectedNodeLids)
    {
        if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;

        auto sourceNodeId = synth->getNodeIdForLogical((juce::uint32)lid);
        
        // We will connect the first audio output (channel 0) of the source to the next available mixer input.
        synth->connect(sourceNodeId, 0, mixerNodeId, mixerInputChannel);
        juce::Logger::writeToLog("[AutoConnect] Connected node " + juce::String(lid) + " (Out 0) to Track Mixer (In " + juce::String(mixerInputChannel + 1) + ")");
        
        mixerInputChannel++;
    }

    // 7. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [Connect to Mixer] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: MIDI Player not ready.");
        return;
    }

    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);

    // --- FIX: Create and position the Track Mixer first ---
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 1200.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // --- FIX: Connect MIDI Player "Num Tracks" output to Track Mixer "Num Tracks Mod" input ---
    // This ensures the Track Mixer automatically adjusts its track count based on the MIDI file content
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected MIDI Player Num Tracks to Track Mixer Num Tracks Mod");

    // 2. Create and connect a Sample Loader for each active MIDI track.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnect] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks.");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= MIDIPlayerModuleProcessor::kMaxTracks) break;

        // A. Create and position the new modules.
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y + (i * 350.0f));

        auto mapRangeNodeId = synth->addModule("map_range");
        auto mapRangeLid = synth->getLogicalIdForNode(mapRangeNodeId);
        pendingNodePositions[(int)mapRangeLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y + (i * 350.0f));
        
        // B. Configure the MapRange module for Pitch CV conversion.
        if (auto* mapRangeProc = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(mapRangeLid)))
        {
            auto& ap = mapRangeProc->getAPVTS();
            // MIDI Player Pitch Out (0..1) -> Sample Loader Pitch Mod (-24..+24 semitones)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = 0.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = 1.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = -24.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = 24.0f;
        }

        // C. Connect the outputs for this track.
        const int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        const int gateChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 1;
        const int trigChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 3;

        // Pitch: MIDI Player -> MapRange -> Sample Loader
        synth->connect(midiPlayerNodeId, pitchChan, mapRangeNodeId, 0); // Pitch Out -> MapRange In
        synth->connect(mapRangeNodeId, 1, samplerNodeId, 0);             // MapRange Raw Out -> SampleLoader Pitch Mod In

        // Gate: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, gateChan, samplerNodeId, 2);    // Gate Out -> SampleLoader Gate Mod In

        // Trigger: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, trigChan, samplerNodeId, 3);    // Trigger Out -> SampleLoader Trigger Mod In

        // --- FIX: Connect the Sample Loader's audio output to the Track Mixer ---
        // The Sample Loader's main audio output is channel 0.
        // The Track Mixer's inputs are mono channels 0, 1, 2...
        synth->connect(samplerNodeId, 0, mixerNodeId, i);
    }

    // --- FIX: Connect the mixer to the main output so you can hear it! ---
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R

    // 3. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnectVCO] Aborted: MIDI Player not ready.");
        return;
    }
    
    juce::Logger::writeToLog("--- [AutoConnectVCO] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear all existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);
    
    // 2. Create and position the PolyVCO and Track Mixer.
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created PolyVCO with logical ID " + juce::String(polyVcoLid));

    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 3. Connect the track count outputs to control both new modules.
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, polyVcoNodeId, 0); // Raw Num Tracks -> PolyVCO Num Voices Mod
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS); // Raw Num Tracks -> Mixer Num Tracks Mod
    juce::Logger::writeToLog("[AutoConnectVCO] Connected MIDI Player raw track counts to PolyVCO and Track Mixer modulation inputs.");
    
    // 4. Loop through active MIDI tracks to connect CV routes and audio.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnectVCO] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks. Patching voices...");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= PolyVCOModuleProcessor::MAX_VOICES) break; // Don't try to connect more voices than the PolyVCO has

        int sourceTrackIndex = activeTrackIndices[i];

        // A. Connect CV modulation routes from MIDI Player to the corresponding PolyVCO voice.
        int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        int velChan   = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 2;
        
        // Connect MIDI CV to the corresponding PolyVCO voice inputs
        synth->connect(midiPlayerNodeId, pitchChan, polyVcoNodeId, 1 + i); // Pitch -> Freq Mod
        synth->connect(midiPlayerNodeId, velChan,   polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Velocity -> Gate Mod

        // B. Connect the PolyVCO voice's audio output to the Track Mixer's input.
        synth->connect(polyVcoNodeId, i, mixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, mixerNodeId, i * 2 + 1);
    }
    
    // 5. Connect the Track Mixer to the main audio output.
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R
    
    // 6. Flag the graph for a rebuild.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnectVCO] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer) return;

    pushSnapshot();

    const int numTracks = midiPlayer->getNumTracks();
    if (numTracks == 0) return;

    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);

    // --- THIS IS THE NEW "FIND-BY-TRACING" LOGIC ---

    juce::uint32 polyVcoLid = 0;
    juce::uint32 trackMixerLid = 0;

    // 1. Scan existing connections to find modules to reuse by tracing backwards.
    // First, find a TrackMixer connected to the output.
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("track_mixer"))
        {
            trackMixerLid = conn.srcLogicalId; // Found a TrackMixer to reuse!
            break;
        }
    }
    // If we found a TrackMixer, now find a PolyVCO connected to it.
    if (trackMixerLid != 0)
    {
        for (const auto& conn : synth->getConnectionsInfo())
        {
            if (conn.dstLogicalId == trackMixerLid && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("polyvco"))
            {
                polyVcoLid = conn.srcLogicalId; // Found a PolyVCO to reuse!
                break;
            }
        }
    }

    // 2. Clear all old Pitch/Gate/Velocity connections from the MIDI Player.
    std::vector<ModularSynthProcessor::ConnectionInfo> oldConnections;
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.srcLogicalId == midiPlayerLid && conn.srcChan < 16 * 3)
            oldConnections.push_back(conn);
    }
    for (const auto& conn : oldConnections)
    {
        synth->disconnect(synth->getNodeIdForLogical(conn.srcLogicalId), conn.srcChan,
                          synth->getNodeIdForLogical(conn.dstLogicalId), conn.dstChan);
    }

    // 3. If we didn't find a PolyVCO to reuse after tracing, create a new one.
    if (polyVcoLid == 0)
    {
        auto polyVcoNodeId = synth->addModule("polyvco", false);
        polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
        pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPos.x + 400.0f, midiPos.y);
    }

    // 4. If we didn't find a TrackMixer to reuse after tracing, create a new one.
    if (trackMixerLid == 0)
    {
        auto trackMixerNodeId = synth->addModule("track_mixer", false);
        trackMixerLid = synth->getLogicalIdForNode(trackMixerNodeId);
        pendingNodePositions[(int)trackMixerLid] = ImVec2(midiPos.x + 800.0f, midiPos.y);
    }
    // --- END OF NEW LOGIC ---

    auto polyVcoNodeId = synth->getNodeIdForLogical(polyVcoLid);
    auto trackMixerNodeId = synth->getNodeIdForLogical(trackMixerLid);

    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numTracks;
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(trackMixerLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numTracks;

    int voicesToConnect = std::min({numTracks, PolyVCOModuleProcessor::MAX_VOICES, 64});
    for (int i = 0; i < voicesToConnect; ++i)
    {
        synth->connect(midiPlayerNodeId, i, polyVcoNodeId, 1 + i);
        synth->connect(midiPlayerNodeId, i + 16, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2 + 1);
    }
    
    synth->connect(trackMixerNodeId, 0, synth->getOutputNodeID(), 0);
    synth->connect(trackMixerNodeId, 1, synth->getOutputNodeID(), 1);

    synth->commitChanges();
}

void ImGuiNodeEditorComponent::handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid)
{
    if (!synth || !strokeSeq) return;

    juce::Logger::writeToLog("ü•Å BUILD DRUM KIT handler called! Creating modules...");

    // 1. Get Stroke Sequencer position
    auto seqNodeId = synth->getNodeIdForLogical(strokeSeqLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)strokeSeqLid);

    // 2. Create 3 Sample Loaders (for Floor, Mid, Ceiling triggers)
    auto sampler1NodeId = synth->addModule("sample_loader");
    auto sampler2NodeId = synth->addModule("sample_loader");
    auto sampler3NodeId = synth->addModule("sample_loader");
    
    auto sampler1Lid = synth->getLogicalIdForNode(sampler1NodeId);
    auto sampler2Lid = synth->getLogicalIdForNode(sampler2NodeId);
    auto sampler3Lid = synth->getLogicalIdForNode(sampler3NodeId);
    
    // Position samplers in a vertical stack to the right
    pendingNodePositions[(int)sampler1Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    pendingNodePositions[(int)sampler2Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 220.0f);
    pendingNodePositions[(int)sampler3Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 440.0f);

    // 3. Create Track Mixer (will be set to 6 tracks by Value node)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 200.0f);

    // 4. Create Value node set to 6.0 (for 3 stereo tracks = 6 channels)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(seqPos.x + 600.0f, seqPos.y + 550.0f);
    
    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = 6.0f;
    }

    // 5. Connect Stroke Sequencer TRIGGERS to Sample Loader TRIGGER MOD inputs (channel 3)
    synth->connect(seqNodeId, 0, sampler1NodeId, 3); // Floor Trig   -> Sampler 1 Trigger Mod
    synth->connect(seqNodeId, 1, sampler2NodeId, 3); // Mid Trig     -> Sampler 2 Trigger Mod
    synth->connect(seqNodeId, 2, sampler3NodeId, 3); // Ceiling Trig -> Sampler 3 Trigger Mod

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    // Sampler 1 (L+R) -> Mixer Audio 1+2
    synth->connect(sampler1NodeId, 0, mixerNodeId, 0); // Sampler 1 L -> Mixer Audio 1
    synth->connect(sampler1NodeId, 1, mixerNodeId, 1); // Sampler 1 R -> Mixer Audio 2
    
    // Sampler 2 (L+R) -> Mixer Audio 3+4
    synth->connect(sampler2NodeId, 0, mixerNodeId, 2); // Sampler 2 L -> Mixer Audio 3
    synth->connect(sampler2NodeId, 1, mixerNodeId, 3); // Sampler 2 R -> Mixer Audio 4
    
    // Sampler 3 (L+R) -> Mixer Audio 5+6
    synth->connect(sampler3NodeId, 0, mixerNodeId, 4); // Sampler 3 L -> Mixer Audio 5
    synth->connect(sampler3NodeId, 1, mixerNodeId, 5); // Sampler 3 R -> Mixer Audio 6

    // 7. Connect Value node (6.0) to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value (6) -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid)
{
    if (!synth || !animModule) return;

    // Query the dynamic output pins to determine how many bones are tracked
    auto dynamicPins = animModule->getDynamicOutputPins();
    
    // Each bone has 3 outputs: Vel X, Vel Y, Hit
    // So number of bones = number of pins / 3
    int numTrackedBones = (int)dynamicPins.size() / 3;
    
    if (numTrackedBones == 0)
    {
        juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO: No tracked bones! Add bones first.");
        return;
    }

    juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO handler called! Creating modules for " + 
                             juce::String(numTrackedBones) + " tracked bones...");

    // 1. Get Animation Module position
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    ImVec2 animPos = ImNodes::GetNodeGridSpacePos((int)animModuleLid);

    // 2. Create one Sample Loader per tracked bone
    std::vector<juce::AudioProcessorGraph::NodeID> samplerNodeIds;
    std::vector<juce::uint32> samplerLids;
    
    for (int i = 0; i < numTrackedBones; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        samplerNodeIds.push_back(samplerNodeId);
        samplerLids.push_back(synth->getLogicalIdForNode(samplerNodeId));
        
        // Position samplers in a vertical stack to the right
        pendingNodePositions[(int)samplerLids[i]] = ImVec2(animPos.x + 400.0f, animPos.y + i * 220.0f);
    }

    // 3. Create Track Mixer (num_bones * 2 for stereo pairs)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(animPos.x + 800.0f, animPos.y + (numTrackedBones * 110.0f));

    // 4. Create Value node for mixer track count
    int numMixerTracks = numTrackedBones * 2; // 2 channels per sampler (stereo)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(animPos.x + 600.0f, animPos.y + (numTrackedBones * 220.0f));

    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = (float)numMixerTracks;
    }

    // 5. Connect Animation Module TRIGGERS to Sample Loader TRIGGER MOD inputs
    // Animation Module Output Channels (per bone):
    //   i*3 + 0: Bone Vel X
    //   i*3 + 1: Bone Vel Y
    //   i*3 + 2: Bone Hit (trigger) ‚Üê Connect this to sampler
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int triggerChannel = i * 3 + 2; // Every 3rd channel starting at 2 (2, 5, 8, 11, ...)
        synth->connect(animNodeId, triggerChannel, samplerNodeIds[i], 3); // Bone Hit -> Sampler Trigger Mod
    }

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int mixerChannelL = i * 2;       // 0, 2, 4, 6, ...
        int mixerChannelR = i * 2 + 1;   // 1, 3, 5, 7, ...
        
        synth->connect(samplerNodeIds[i], 0, mixerNodeId, mixerChannelL); // Sampler L -> Mixer Audio L
        synth->connect(samplerNodeIds[i], 1, mixerNodeId, mixerChannelR); // Sampler R -> Mixer Audio R
    }

    // 7. Connect Value node to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
    
    juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO complete! " + juce::String(numTrackedBones) + 
                             " samplers + mixer + wiring created.");
}
void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. Create the necessary Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 100.0f);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        *dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")) = numSteps;
    }

    // 3. CREATE a Sample Loader for each step and connect its audio to the mixer
    for (int i = 0; i < numSteps; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(seqPos.x + 400.0f, seqPos.y + (i * 220.0f));

        // Connect this sampler's audio output to the mixer's input
        synth->connect(samplerNodeId, 0 /*Audio Output*/, mixerNodeId, i);
        
        // Connect the Sequencer's CV/Trig for this step directly to the new sampler
        synth->connect(seqNodeId, 7 + i * 3 + 0, samplerNodeId, 0); // Pitch N -> Pitch Mod
        synth->connect(seqNodeId, 1, samplerNodeId, 2); // Main Gate -> Gate Mod
        synth->connect(seqNodeId, 7 + i * 3 + 2, samplerNodeId, 3); // Trig N  -> Trigger Mod
    }
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod

    // 4. Connect the mixer to the main output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. CREATE the PolyVCO and Track Mixer
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numSteps;
    }
    
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numSteps;
    }

    // 3. Connect CV, Audio, and Main Output
    for (int i = 0; i < numSteps; ++i)
    {
        // Connect CV: Sequencer -> PolyVCO
        synth->connect(seqNodeId, 7 + i * 3 + 0, polyVcoNodeId, 1 + i);                                  // Pitch N -> Freq N Mod
        synth->connect(seqNodeId, 1, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Main Gate -> Gate N Mod

        // Connect Audio: PolyVCO -> Mixer
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // Connect Num Steps output (channel 6) to PolyVCO's Num Voices Mod input (channel 0)
    synth->connect(seqNodeId, 6, polyVcoNodeId, 0); // Num Steps -> Num Voices Mod
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod
    
    // Connect Mixer -> Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::openMetaModuleEditor(MetaModuleProcessor* metaModule, juce::uint32 metaLogicalId)
{
    closeMetaModuleEditor();

    if (metaModule == nullptr)
        return;

    auto session = std::make_unique<MetaModuleEditorSession>();
    session->context.reset(ImNodes::CreateContext());
    if (session->context == nullptr)
        return;

    ImNodes::SetCurrentContext(session->context.get());
    ImNodes::StyleColorsDark();
    ImNodesIO& io = ImNodes::GetIO();
    io.LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyAlt;

    session->meta = metaModule;
    session->metaLogicalId = metaLogicalId;
    session->graph = metaModule->getInternalGraph();

    if (session->graph != nullptr)
    {
        auto modules = session->graph->getModulesInfo();
        int index = 0;
        for (const auto& mod : modules)
        {
            const int logicalId = (int)mod.first;
            const int row = index / 5;
            const int col = index % 5;
            session->nodePositions.emplace(logicalId, ImVec2(220.0f * col, 140.0f * row));
            ++index;
        }
    }

    ImNodes::SetCurrentContext(editorContext);
    metaEditorSession = std::move(session);
}

void ImGuiNodeEditorComponent::closeMetaModuleEditor()
{
    if (metaEditorSession)
    {
        if (metaEditorSession->context)
        {
            ImNodes::SetCurrentContext(metaEditorSession->context.get());
            ImNodes::DestroyContext(metaEditorSession->context.release());
        }
        metaEditorSession.reset();
    }
    if (editorContext != nullptr)
        ImNodes::SetCurrentContext(editorContext);
}

void ImGuiNodeEditorComponent::renderMetaModuleEditor(MetaModuleEditorSession& session)
{
    if (session.context == nullptr || session.meta == nullptr || session.graph == nullptr)
    {
        ImGui::TextUnformatted("Internal graph is unavailable.");
        return;
    }

    ImNodes::SetCurrentContext(session.context.get());

    auto modules = session.graph->getModulesInfo();

    if (session.nodePositions.empty())
    {
        int index = 0;
        for (const auto& mod : modules)
        {
            const int logicalId = (int)mod.first;
            const int row = index / 5;
            const int col = index % 5;
            session.nodePositions.emplace(logicalId, ImVec2(220.0f * col, 140.0f * row));
            ++index;
        }
    }

    ImVec2 canvasSize = ImGui::GetContentRegionAvail();
    canvasSize.x = juce::jmax(canvasSize.x, 640.0f);
    canvasSize.y = juce::jmax(canvasSize.y, 360.0f);

    ImGui::BeginChild("MetaEditorCanvas", canvasSize, true, ImGuiWindowFlags_NoScrollWithMouse);
    ImNodes::BeginNodeEditor();

    const auto& pinDb = getModulePinDatabase();

    auto drawPinsForModule = [&](ModuleProcessor* module, const ModulePinInfo* info)
    {
        std::vector<AudioPin> audioIns;
        std::vector<AudioPin> audioOuts;
        std::vector<ModPin> modIns;

        if (info != nullptr)
        {
            audioIns.assign(info->audioIns.begin(), info->audioIns.end());
            audioOuts.assign(info->audioOuts.begin(), info->audioOuts.end());
            modIns.assign(info->modIns.begin(), info->modIns.end());
        }

        if (module != nullptr)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            auto dynamicOutputs = module->getDynamicOutputPins();

            for (const auto& dyn : dynamicInputs)
                audioIns.emplace_back(dyn.name, dyn.channel, dyn.type);
            for (const auto& dyn : dynamicOutputs)
                audioOuts.emplace_back(dyn.name, dyn.channel, dyn.type);
        }

        for (const auto& pin : audioIns)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = pin.channel;
            pinId.isInput = true;
            pinId.isMod = (pin.type != PinDataType::Audio);

            ImNodes::BeginInputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndInputAttribute();
        }

        for (const auto& pin : modIns)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = (int)pin.paramId.hashCode();
            pinId.isInput = true;
            pinId.isMod = true;

            ImNodes::BeginInputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndInputAttribute();
        }

        for (const auto& pin : audioOuts)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = pin.channel;
            pinId.isInput = false;
            pinId.isMod = (pin.type != PinDataType::Audio);

            ImNodes::BeginOutputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndOutputAttribute();
        }
    };

    for (const auto& mod : modules)
    {
        const int logicalId = (int)mod.first;
        const juce::String type = mod.second;
        ModuleProcessor* module = session.graph->getModuleForLogical(mod.first);

        ImNodes::BeginNode(logicalId);
        ImGui::Text("%s", type.toRawUTF8());

        const ModulePinInfo* info = nullptr;
        auto it = pinDb.find(type);
        if (it != pinDb.end())
            info = &it->second;

        drawPinsForModule(module, info);

        ImNodes::EndNode();

        const auto posIt = session.nodePositions.find(logicalId);
        if (posIt != session.nodePositions.end())
            ImNodes::SetNodeGridSpacePos(logicalId, posIt->second);
    }

    session.linkIdToAttrs.clear();
    const auto connections = session.graph->getConnectionsInfo();
    for (const auto& conn : connections)
    {
        PinID srcPin;
        srcPin.logicalId = conn.srcLogicalId;
        srcPin.channel = conn.srcChan;
        srcPin.isInput = false;
        srcPin.isMod = false;

        PinID dstPin;
        if (conn.dstIsOutput)
        {
            dstPin.logicalId = 0;
        }
        else
        {
            dstPin.logicalId = conn.dstLogicalId;
        }
        dstPin.channel = conn.dstChan;
        dstPin.isInput = true;
        dstPin.isMod = false;

        const int srcAttr = encodePinId(srcPin);
        const int dstAttr = encodePinId(dstPin);

        const int linkId = (int)(((conn.srcLogicalId & 0xFFFF) << 16)
                            ^ ((conn.dstLogicalId & 0xFFFF) << 1)
                            ^ ((conn.srcChan & 0xFF) << 8)
                            ^ (conn.dstChan & 0xFF)
                            ^ (conn.dstIsOutput ? 0x4000 : 0x0));

        session.linkIdToAttrs[linkId] = { srcAttr, dstAttr };
        ImNodes::Link(linkId, srcAttr, dstAttr);
    }

    if (ImGui::BeginPopupContextWindow("MetaNodeEditorContext", ImGuiPopupFlags_MouseButtonRight))
    {
        if (ImGui::MenuItem("Delete Selected"))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                std::vector<int> selected(numSelected);
                ImNodes::GetSelectedNodes(selected.data());
                for (int nodeId : selected)
                {
                    auto node = session.graph->getNodeIdForLogical((juce::uint32)nodeId);
                    if (node.uid != 0)
                        session.graph->removeModule(node);
                }
                session.graph->commitChanges();
                session.meta->refreshCachedLayout();
                session.dirty = true;
                ImNodes::ClearNodeSelection();
            }
        }
        ImGui::EndPopup();
    }

    ImNodes::MiniMap(0.2f);
    ImNodes::EndNodeEditor();

    int startAttr = 0;
    int endAttr = 0;
    if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
    {
        PinID a = decodePinId(startAttr);
        PinID b = decodePinId(endAttr);

        PinID src = a;
        PinID dst = b;
        if (src.isInput && !dst.isInput)
            std::swap(src, dst);

        if (!src.isInput && dst.isInput)
        {
            auto srcNodeId = session.graph->getNodeIdForLogical(src.logicalId);
            juce::AudioProcessorGraph::NodeID dstNodeId;
            if (dst.logicalId == 0)
                dstNodeId = session.graph->getOutputNodeID();
            else
                dstNodeId = session.graph->getNodeIdForLogical(dst.logicalId);

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                if (session.graph->connect(srcNodeId, src.channel, dstNodeId, dst.channel))
                {
                    session.graph->commitChanges();
                    session.meta->refreshCachedLayout();
                    session.dirty = true;
                }
            }
        }
    }

    int destroyedLink = 0;
    if (ImNodes::IsLinkDestroyed(&destroyedLink))
    {
        auto linkIt = session.linkIdToAttrs.find(destroyedLink);
        if (linkIt != session.linkIdToAttrs.end())
        {
            PinID src = decodePinId(linkIt->second.first);
            PinID dst = decodePinId(linkIt->second.second);

            auto srcNodeId = session.graph->getNodeIdForLogical(src.logicalId);
            juce::AudioProcessorGraph::NodeID dstNodeId;
            if (dst.logicalId == 0)
                dstNodeId = session.graph->getOutputNodeID();
            else
                dstNodeId = session.graph->getNodeIdForLogical(dst.logicalId);

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                if (session.graph->disconnect(srcNodeId, src.channel, dstNodeId, dst.channel))
                {
                    session.graph->commitChanges();
                    session.meta->refreshCachedLayout();
                    session.dirty = true;
                }
            }
        }
    }

    for (const auto& mod : modules)
    {
        const int logicalId = (int)mod.first;
        session.nodePositions[logicalId] = ImNodes::GetNodeGridSpacePos(logicalId);
    }

    ImGui::EndChild();

    char searchBuffer[128];
    std::memset(searchBuffer, 0, sizeof(searchBuffer));
    std::strncpy(searchBuffer, session.moduleSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    if (ImGui::InputTextWithHint("##MetaModuleSearch", "Module type (e.g. vco)", searchBuffer, sizeof(searchBuffer)))
    {
        session.moduleSearchTerm = juce::String(searchBuffer);
    }

    if (ImGui::Button("Create Module"))
    {
        juce::String moduleType = session.moduleSearchTerm.trim();
        if (moduleType.isNotEmpty())
        {
            auto nodeId = session.graph->addModule(moduleType);
            if (nodeId.uid != 0)
            {
                auto logicalId = session.graph->getLogicalIdForNode(nodeId);
                session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
                session.graph->commitChanges();
                session.meta->refreshCachedLayout();
                session.dirty = true;
            }
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Add Inlet"))
    {
        auto nodeId = session.graph->addModule("inlet");
        if (nodeId.uid != 0)
        {
            auto logicalId = session.graph->getLogicalIdForNode(nodeId);
            session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
            session.graph->commitChanges();
            session.meta->refreshCachedLayout();
            session.dirty = true;
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Add Outlet"))
    {
        auto nodeId = session.graph->addModule("outlet");
        if (nodeId.uid != 0)
        {
            auto logicalId = session.graph->getLogicalIdForNode(nodeId);
            session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
            session.graph->commitChanges();
            session.meta->refreshCachedLayout();
            session.dirty = true;
        }
    }

    ImNodes::SetCurrentContext(editorContext);
}
void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info and get number of tracked colors
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count using the new helper method
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create PolyVCO with matching number of voices
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y);
    
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices")))
            *p = numColors;
    }
    
    // 3. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 4. Connect Num Colors output to PolyVCO's NumVoices Mod and TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, polyVcoNodeId, 0); // Num Colors -> NumVoices Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64);  // Num Colors -> Num Tracks Mod
    
    // 5. Connect ColorTracker outputs to PolyVCO inputs
    for (int i = 0; i < numColors; ++i)
    {
        // Map X position to pitch/frequency for voice i
        synth->connect(colorTrackerNodeId, i * 3 + 0, polyVcoNodeId, 1 + i); // X -> Freq Mod
        
        // Map Area to gate level for voice i
        const int gateModChannel = 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i;
        synth->connect(colorTrackerNodeId, i * 3 + 2, polyVcoNodeId, gateModChannel); // Area -> Gate Mod
    }
    
    // 6. Connect PolyVCO audio outputs to Track Mixer inputs
    for (int i = 0; i < numColors; ++i)
    {
        synth->connect(polyVcoNodeId, i, mixerNodeId, i); // Voice i -> Mixer Track i
    }
    
    // 7. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to PolyVCO.");
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y + 100.0f);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 3. Connect Num Colors output to TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64); // Num Colors -> Num Tracks Mod

    // 4. Create a Sample Loader for each tracked color
    for (int i = 0; i < numColors; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y + (i * 220.0f));

        // Connect Sample Loader audio output to mixer
        synth->connect(samplerNodeId, 0, mixerNodeId, i); // Audio -> Mixer Track i
        
        // Connect ColorTracker CV outputs to Sample Loader modulation inputs
        synth->connect(colorTrackerNodeId, i * 3 + 0, samplerNodeId, 0); // X -> Pitch Mod
        synth->connect(colorTrackerNodeId, i * 3 + 2, samplerNodeId, 2); // Area -> Gate Mod
    }
    
    // 5. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to Sample Loaders.");
}

// Add this exact helper function to the class
void ImGuiNodeEditorComponent::parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex)
{
    outIndex = -1; // Default to no index
    outType = fullName;

    if (fullName.contains(" "))
    {
        const juce::String lastWord = fullName.substring(fullName.lastIndexOfChar(' ') + 1);
        if (lastWord.containsOnly("0123456789"))
        {
            outIndex = lastWord.getIntValue();
            outType = fullName.substring(0, fullName.lastIndexOfChar(' '));
        }
    }
}

void ImGuiNodeEditorComponent::updateRerouteTypeFromConnections(juce::uint32 rerouteLogicalId)
{
    if (synth == nullptr)
        return;

    auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(rerouteLogicalId));
    if (reroute == nullptr)
        return;

    std::optional<PinDataType> resolvedType;
    const auto connections = synth->getConnectionsInfo();

    for (const auto& conn : connections)
    {
        if (!conn.dstIsOutput && conn.dstLogicalId == rerouteLogicalId)
        {
            PinID srcPin { conn.srcLogicalId, conn.srcChan, false, false, {} };
            resolvedType = getPinDataTypeForPin(srcPin);
            break;
        }
    }

    if (!resolvedType.has_value())
    {
        for (const auto& conn : connections)
        {
            if (conn.srcLogicalId == rerouteLogicalId && !conn.dstIsOutput)
            {
                PinID dstPin { conn.dstLogicalId, conn.dstChan, true, false, {} };
                resolvedType = getPinDataTypeForPin(dstPin);
                break;
            }
        }
    }

    if (resolvedType.has_value())
        reroute->setPassthroughType(*resolvedType);
    else
        reroute->setPassthroughType(PinDataType::Audio);
}

// Helper functions to get pins from modules
std::vector<AudioPin> ImGuiNodeEditorComponent::getOutputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioOuts;
    return {};
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getInputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioIns;
    return {};
}

AudioPin* ImGuiNodeEditorComponent::findInputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getInputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

AudioPin* ImGuiNodeEditorComponent::findOutputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getOutputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::findNodesOfType(const juce::String& moduleType)
{
    std::vector<juce::uint32> result;
    if (!synth) return result;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleTypeForLogical(modInfo.first) == moduleType)
        {
            result.push_back(modInfo.first);
        }
    }
    return result;
}

// New dynamic pin-fetching helper
std::vector<PinInfo> ImGuiNodeEditorComponent::getDynamicOutputPins(ModuleProcessor* module)
{
    std::vector<PinInfo> pins;
    if (!module) return pins;

    const int numOutputChannels = module->getBus(false, 0)->getNumberOfChannels();
    for (int i = 0; i < numOutputChannels; ++i)
    {
        juce::String pinName = module->getAudioOutputLabel(i);
        if (pinName.isNotEmpty())
        {
            pins.push_back({(uint32_t)i, pinName}); // Store the full pin name in the type field
        }
    }
    return pins;
}
// Template function implementations
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToMonophonicTargets(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping,
    const std::vector<juce::uint32>& targetLids)
{
    if (!synth || !sourceNode || targetLids.empty()) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToMonophonicTargets called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    // Use provided target logical IDs explicitly
    auto targetNodes = targetLids;

    int currentTargetIndex = 0;

    // First, group all of the source node's output pins by their index number.
    // For example, "Pitch 1" and "Trig 1" will both be in the group for index 1.
    std::map<int, std::vector<PinInfo>> pinsByIndex;
    
    // THE FIX: Get pins directly from the module instance.
    auto outputPins = getDynamicOutputPins(sourceNode);
    
    for (const auto& pin : outputPins)
    {
        juce::String type;
        int index = -1;
        parsePinName(pin.type, type, index); // Use pin.type instead of pin.name
        if (index != -1) {
            // Store channel ID as the pin's ID
            pinsByIndex[index].push_back({(uint32_t)pin.id, type}); 
        }
    }

    // Now, loop through each group of pins (each voice).
    for (auto const& [index, pinsInGroup] : pinsByIndex)
    {
        if (currentTargetIndex >= (int)targetNodes.size()) break; // Stop if we run out of targets
        auto targetNodeId = targetNodes[currentTargetIndex];

        // For each pin in the group (e.g., for "Pitch 1" and "Trig 1")...
        for (const auto& pinInfo : pinsInGroup)
        {
            // Check if we have a connection rule for this pin type (e.g., "Pitch").
            if (pinNameMapping.count(pinInfo.type))
            {
                juce::String targetPinName = pinNameMapping.at(pinInfo.type);
                auto* targetPin = findInputPin("sample_loader", targetPinName);

                // If the target pin exists, create the connection.
                if (targetPin)
                {
                    juce::uint32 sourceLogicalId = 0;
                    for (const auto& modInfo : synth->getModulesInfo())
                    {
                        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
                        {
                            sourceLogicalId = modInfo.first;
                            break;
                        }
                    }
                    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);
                    synth->connect(sourceNodeId, pinInfo.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
                }
            }
        }
        // IMPORTANT: Move to the next target module for the next voice.
        currentTargetIndex++;
    }
}
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToPolyphonicTarget(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping)
{
    if (!synth || !sourceNode) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToPolyphonicTarget called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    juce::uint32 sourceLogicalId = 0;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            sourceLogicalId = modInfo.first;
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    auto targetNodes = findNodesOfType("polyvco");
    if (targetNodes.empty()) return;
    auto targetNodeId = targetNodes[0]; // Use the first available PolyVCO

    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);

    // THE FIX: Get pins directly from the module instance, not the database.
    auto outputPins = getDynamicOutputPins(sourceNode);

    // Loop through every output pin on the source module.
    for (const auto& sourcePin : outputPins)
    {
        // Parse the source pin's name to get its type and index.
        juce::String sourceType;
        int sourceIndex = -1;
        parsePinName(sourcePin.type, sourceType, sourceIndex); // Use pin.type instead of pin.name

        if (sourceIndex == -1) continue; // Skip pins that aren't numbered.

        // Check if we have a rule for this pin type (e.g., "Pitch" maps to "Freq").
        if (pinNameMapping.count(sourceType))
        {
            juce::String targetType = pinNameMapping.at(sourceType);
            // PolyVCO inputs use the format "Freq 1 Mod", "Gate 1 Mod", etc.
            juce::String targetPinName = targetType + " " + juce::String(sourceIndex) + " Mod";

            // Find that pin on the target and connect it if available.
            auto* targetPin = findInputPin("polyvco", targetPinName);
            if (targetPin)
            {
                synth->connect(sourceNodeId, sourcePin.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleAutoConnectionRequests()
{
    if (!synth) return;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* module = synth->getModuleForLogical(modInfo.first);
        if (!module) continue;

        // --- Check MultiSequencer Flags ---
        if (auto* multiSeq = dynamic_cast<MultiSequencerModuleProcessor*>(module))
        {
            if (multiSeq->autoConnectSamplersTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectSamplers(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
            if (multiSeq->autoConnectVCOTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectVCO(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
        }
        
        // --- Check ColorTracker Flags ---
        if (auto* colorTracker = dynamic_cast<ColorTrackerModule*>(module))
        {
            if (colorTracker->autoConnectPolyVCOTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectPolyVCO(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
            if (colorTracker->autoConnectSamplersTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectSamplers(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check StrokeSequencer Flags ---
        if (auto* strokeSeq = dynamic_cast<StrokeSequencerModuleProcessor*>(module))
        {
            if (strokeSeq->autoBuildDrumKitTriggered.exchange(false))
            {
                handleStrokeSeqBuildDrumKit(strokeSeq, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check AnimationModule Flags ---
        if (auto* animModule = dynamic_cast<AnimationModuleProcessor*>(module))
        {
            if (animModule->autoBuildTriggersAudioTriggered.exchange(false))
            {
                handleAnimationBuildTriggersAudio(animModule, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check MIDIPlayer Flags ---
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(module))
        {
            if (midiPlayer->autoConnectTriggered.exchange(false)) // Samplers
            {
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType)
{
    if (!synth || !midiPlayer) return;
    
    juce::Logger::writeToLog("[MIDI Player Quick Connect] Request type: " + juce::String(requestType));
    
    // Get ALL tracks (don't filter by whether they have notes)
    const auto& notesByTrack = midiPlayer->getNotesByTrack();
    int numTracks = (int)notesByTrack.size();
    
    if (numTracks == 0)
    {
        juce::Logger::writeToLog("[MIDI Player Quick Connect] No tracks in MIDI file");
        return;
    }
    
    // Get MIDI Player position for positioning new nodes
    ImVec2 playerPos = ImNodes::GetNodeEditorSpacePos(static_cast<int>(midiPlayerLid));
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    
    // Request Type: 1=PolyVCO, 2=Samplers, 3=Both
    juce::uint32 polyVCOLid = 0;
    juce::uint32 mixerLid = 0;
    
    if (requestType == 1 || requestType == 3) // PolyVCO or Both
    {
        // 1. Create PolyVCO
        auto polyVCONodeId = synth->addModule("polyvco");
        polyVCOLid = synth->getLogicalIdForNode(polyVCONodeId);
        pendingNodeScreenPositions[(int)polyVCOLid] = ImVec2(playerPos.x + 400.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created PolyVCO at LID " + juce::String((int)polyVCOLid));
        
        // 2. Create Track Mixer
        auto mixerNodeId = synth->addModule("track_mixer");
        mixerLid = synth->getLogicalIdForNode(mixerNodeId);
        pendingNodeScreenPositions[(int)mixerLid] = ImVec2(playerPos.x + 700.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        
        // 3. Connect MIDI Player tracks to PolyVCO
        // Connect ALL tracks, regardless of whether they have notes
        int trackIdx = 0;
        for (size_t i = 0; i < notesByTrack.size() && trackIdx < 32; ++i)
        {
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiVeloPin = trackIdx * 4 + 2;
            
            const int vcoFreqPin = trackIdx + 1;
            const int vcoWavePin = 32 + trackIdx + 1;
            const int vcoGatePin = 64 + trackIdx + 1;
            
            synth->connect(midiPlayerNodeId, midiPitchPin, polyVCONodeId, vcoFreqPin);
            synth->connect(midiPlayerNodeId, midiGatePin, polyVCONodeId, vcoGatePin);
            synth->connect(midiPlayerNodeId, midiVeloPin, polyVCONodeId, vcoWavePin);
            trackIdx++;
        }
        
        // 4. Connect Num Tracks to PolyVCO (Num Voices Mod on channel 0)
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       polyVCONodeId, 0);
        
        // 5. Connect PolyVCO outputs to Track Mixer inputs
        for (int i = 0; i < trackIdx; ++i)
        {
            synth->connect(polyVCONodeId, i, mixerNodeId, i);
        }
        
        // 6. Connect Num Tracks output to mixer's Num Tracks Mod input
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
        
        // 7. Connect Track Mixer to main output
        auto outputNodeId = synth->getOutputNodeID();
        synth->connect(mixerNodeId, 0, outputNodeId, 0); // L
        synth->connect(mixerNodeId, 1, outputNodeId, 1); // R
        
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                " tracks: MIDI Player ‚Üí PolyVCO ‚Üí Track Mixer ‚Üí Output");
    }
    if (requestType == 2 || requestType == 3) // Samplers or Both
    {
        float samplerX = playerPos.x + 400.0f;
        float mixerX = playerPos.x + 700.0f;
        
        // If PolyVCO mode (Both), offset samplers and use same mixer
        if (requestType == 3)
        {
            samplerX += 300.0f; // Offset samplers if PolyVCO exists
            // Reuse existing mixer created in PolyVCO section
        }
        else
        {
            // 1. Create Track Mixer for Samplers-only mode
            auto mixerNodeId = synth->addModule("track_mixer");
            mixerLid = synth->getLogicalIdForNode(mixerNodeId);
            pendingNodeScreenPositions[(int)mixerLid] = ImVec2(mixerX, playerPos.y);
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        }
        
        // 2. Create samplers and connect
        // Connect ALL tracks, regardless of whether they have notes
        auto mixerNodeId = synth->getNodeIdForLogical(mixerLid);
        int trackIdx = 0;
        int totalTracks = (int)notesByTrack.size();
        int mixerStartChannel = (requestType == 3) ? totalTracks : 0; // Offset for "Both" mode
        
        for (size_t i = 0; i < notesByTrack.size(); ++i)
        {
            // Create SampleLoader
            float samplerY = playerPos.y + (trackIdx * 150.0f);
            auto samplerNodeId = synth->addModule("sample_loader");
            juce::uint32 samplerLid = synth->getLogicalIdForNode(samplerNodeId);
            pendingNodeScreenPositions[(int)samplerLid] = ImVec2(samplerX, samplerY);
            
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiTrigPin = trackIdx * 4 + 3;
            
            // Connect MIDI Player to Sampler
            synth->connect(midiPlayerNodeId, midiPitchPin, samplerNodeId, 0);
            synth->connect(midiPlayerNodeId, midiGatePin, samplerNodeId, 2);
            synth->connect(midiPlayerNodeId, midiTrigPin, samplerNodeId, 3);
            
            // Connect Sampler output to Track Mixer input
            synth->connect(samplerNodeId, 0, mixerNodeId, mixerStartChannel + trackIdx);
            
            trackIdx++;
        }
        
        // 3. Connect Num Tracks to mixer and route to output (only if not already done in PolyVCO mode)
        if (requestType != 3)
        {
            synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                           mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
            
            // 4. Connect Track Mixer to output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(mixerNodeId, 0, outputNodeId, 0);
            synth->connect(mixerNodeId, 1, outputNodeId, 1);
            
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Complete chain: " + juce::String(trackIdx) + 
                                    " SampleLoaders ‚Üí Track Mixer (with Num Tracks) ‚Üí Stereo Output");
        }
        else
        {
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                    " SampleLoaders ‚Üí Track Mixer (channels " + juce::String(mixerStartChannel) + 
                                    "-" + juce::String(mixerStartChannel + trackIdx - 1) + 
                                    ") [Mixer already connected in PolyVCO section]");
        }
    }
    
    // Commit changes
    if (synth)
    {
        synth->commitChanges();
        graphNeedsRebuild = true;
    }
    
    pushSnapshot();
}

void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        const int numSelected = ImNodes::NumSelectedLinks();
        const bool isMultiInsert = numSelected > 1;

        // --- Module Insertion on Cables (Organized by Category) ---
        // Map format: {Display Name, Internal Type}
        // Internal types use lowercase with underscores for spaces
        const std::map<const char*, const char*> audioInsertable = {
            // Effects
            {"VCF", "vcf"}, {"Delay", "delay"}, {"Reverb", "reverb"},
            {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
            {"Limiter", "limiter"}, {"Noise Gate", "gate"}, {"Drive", "drive"},
            {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"}, 
            {"8-Band Shaper", "8bandshaper"}, {"Granulator", "granulator"}, 
            {"Harmonic Shaper", "harmonic_shaper"}, {"Time/Pitch Shifter", "timepitch"},
            {"De-Crackle", "de_crackle"},
            // Utilities
            {"VCA", "vca"}, {"Mixer", "mixer"}, {"Attenuverter", "attenuverter"},
            {"Reroute", "reroute"},
            // Modulators
            {"Function Generator", "function_generator"}, {"Shaping Oscillator", "shaping_oscillator"},
            // TTS
            {"Vocal Tract Filter", "vocal_tract_filter"},
            // Analysis
            {"Scope", "scope"}, {"Frequency Graph", "frequency_graph"}
        };
        const std::map<const char*, const char*> modInsertable = {
            // Utilities
            {"Attenuverter", "attenuverter"}, {"Lag Processor", "lag_processor"}, 
            {"Math", "math"}, {"Map Range", "map_range"}, {"Quantizer", "quantizer"},
            {"Rate", "rate"}, {"Comparator", "comparator"}, {"Logic", "logic"},
            {"Reroute", "reroute"},
            {"CV Mixer", "cv_mixer"}, {"Sequential Switch", "sequential_switch"},
            // Modulators
            {"S&H", "s_and_h"}, {"Function Generator", "function_generator"},
            // Sequencers
            {"Timeline", "timeline"}
        };
        const std::map<const char*, const char*> videoInsertable = {
            // Computer Vision (Video processing)
            // Passthrough nodes (Video In ‚Üí Video Out)
            {"Video FX", "video_fx"}, {"Crop Video", "crop_video"},
            {"Reroute", "reroute"},
            {"Movement Detector", "movement_detector"},
            {"Human Detector", "human_detector"}, {"Object Detector", "object_detector"},
            {"Pose Estimator", "pose_estimator"}, {"Hand Tracker", "hand_tracker"},
            {"Face Tracker", "face_tracker"}, {"Color Tracker", "color_tracker"},
            {"Contour Detector", "contour_detector"}, {"Semantic Segmentation", "semantic_segmentation"}
        };
        
        // Determine which list to show based on cable type
        const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
        const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
        const bool isVideoCable = (srcType == PinDataType::Video && dstType == PinDataType::Video);
        const auto& listToShow = isVideoCable ? videoInsertable : (linkToInsertOn.isMod ? modInsertable : audioInsertable);

        if (isMultiInsert)
            ImGui::Text("Insert Node on %d Cables", numSelected);
        else
            ImGui::Text("Insert Node on Cable");

        // --- FIX: Iterate over map pairs instead of simple strings ---
        for (const auto& pair : listToShow)
        {
            // pair.first = display label, pair.second = internal type
            if (ImGui::MenuItem(pair.first))
            {
                if (isMultiInsert)
                {
                    handleInsertNodeOnSelectedLinks(pair.second);
                }
                else
                {
                    insertNodeBetween(pair.second);
                }
                ImGui::CloseCurrentPopup();
            }
        }
        
        // VST Plugins submenu (only for audio cables, not video cables)
        if (!linkToInsertOn.isMod && !isVideoCable)
        {
            ImGui::Separator();
            if (ImGui::BeginMenu("VST"))
            {
                auto& app = PresetCreatorApplication::getApp();
                auto& knownPluginList = app.getKnownPluginList();
                
                for (const auto& desc : knownPluginList.getTypes())
                {
                    if (ImGui::MenuItem(desc.name.toRawUTF8()))
                    {
                        if (isMultiInsert)
                        {
                            handleInsertNodeOnSelectedLinks(desc.name);
                        }
                        else
                        {
                            insertNodeBetween(desc.name);
                        }
                        ImGui::CloseCurrentPopup();
                    }
                    
                    // Show tooltip with plugin info
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
                        ImGui::Text("Version: %s", desc.version.toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
                ImGui::EndMenu();
            }
        }
        
        ImGui::EndPopup();
    }
    else
    {
        // --- FIX: Reset state when popup is closed ---
        // If the popup is not open (i.e., it was closed or the user clicked away),
        // we must reset the state variable. This ensures that the application
        // is no longer "stuck" in the insert-on-link mode and right-click on
        // empty canvas will work again.
        linkToInsertOn.linkId = -1;
    }
}
void ImGuiNodeEditorComponent::drawLinkInspectorTooltip(const LinkInfo& link)
{
    if (synth == nullptr) return;
    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    
    // Get the probe scope processor
    auto* scope = synth->getProbeScopeProcessor();
    if (scope == nullptr) return;

    // Get the statistics from the scope module
    float minVal, maxVal;
    scope->getStatistics(minVal, maxVal);

    // Get the scope buffer for waveform
    const auto& scopeBuffer = scope->getScopeBuffer();

    // Draw the text info
    ImGui::Text("Inspecting: %s", link.pinName.toRawUTF8());
    ImGui::Text("From: %s (ID %d)", link.sourceNodeName.toRawUTF8(), (int)link.srcNodeId);
    ImGui::Text("Pin: %s", link.pinName.toRawUTF8());
    
    ImGui::Separator();
    
    juce::String peakMaxText = juce::String::formatted("Peak Max: %.3f", maxVal);
    juce::String peakMinText = juce::String::formatted("Peak Min: %.3f", minVal);
    ThemeText(peakMaxText.toRawUTF8(), theme.modules.scope_text_max);
    ThemeText(peakMinText.toRawUTF8(), theme.modules.scope_text_min);
    
    float peakToPeak = maxVal - minVal;
    ImGui::Text("P-P: %.3f", peakToPeak);
    
    float dBMax = maxVal > 0.0001f ? 20.0f * std::log10(maxVal) : -100.0f;
    ImGui::Text("Max dBFS: %.1f", dBMax);

    ImGui::Separator();

    // Draw the waveform using ImGui PlotLines
    const int numSamples = scopeBuffer.getNumSamples();
    if (scopeBuffer.getNumChannels() > 0 && numSamples > 0)
    {
        const float* samples = scopeBuffer.getReadPointer(0);
        ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 80.0f);
        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
    }
}
// --- NEW HELPER FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position)
{
    if (synth == nullptr) return;

    PinDataType srcType = getPinDataTypeForPin(linkInfo.srcPin);
    PinDataType dstType = getPinDataTypeForPin(linkInfo.dstPin);

    // 1. Create and Position the New Node
    // Check if this is a VST plugin by checking against known plugins
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // This is a VST plugin - use addVstModule
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        // Regular module - use addModule
        newNodeId = synth->addModule(nodeType);
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    if (!linkInfo.srcPin.isMod)
    {
        if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
            reroute->setPassthroughType(srcType);
    }

    // 2. Get Original Connection Points
    auto originalSrcNodeId = synth->getNodeIdForLogical(linkInfo.srcPin.logicalId);
    auto originalDstNodeId = (linkInfo.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkInfo.dstPin.logicalId);

    // 3. Disconnect the Original Link
    synth->disconnect(originalSrcNodeId, linkInfo.srcPin.channel, originalDstNodeId, linkInfo.dstPin.channel);

    // 4. Configure newly inserted node if necessary (e.g., MapRange)
    int newNodeOutputChannel = 0;
    if (nodeType == "map_range")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(linkInfo.srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    // 5. Reconnect through the New Node
    synth->connect(originalSrcNodeId, linkInfo.srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, linkInfo.dstPin.channel);

    if (getTypeForLogical(newNodeLid).equalsIgnoreCase("reroute"))
        updateRerouteTypeFromConnections((juce::uint32)newNodeLid);
}
void ImGuiNodeEditorComponent::insertNodeOnLinkStereo(const juce::String& nodeType, 
                                                       const LinkInfo& linkLeft, 
                                                       const LinkInfo& linkRight, 
                                                       const ImVec2& position)
{
    if (synth == nullptr) return;

    juce::Logger::writeToLog("[InsertStereo] Inserting stereo node: " + nodeType);
    juce::Logger::writeToLog("[InsertStereo] Left cable: " + juce::String(linkLeft.srcPin.logicalId) + 
                            " ch" + juce::String(linkLeft.srcPin.channel) + " -> " + 
                            juce::String(linkLeft.dstPin.logicalId) + " ch" + juce::String(linkLeft.dstPin.channel));
    juce::Logger::writeToLog("[InsertStereo] Right cable: " + juce::String(linkRight.srcPin.logicalId) + 
                            " ch" + juce::String(linkRight.srcPin.channel) + " -> " + 
                            juce::String(linkRight.dstPin.logicalId) + " ch" + juce::String(linkRight.dstPin.channel));

    // 1. Create ONE node for both channels
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points for LEFT cable (first cable)
    auto leftSrcNodeId = synth->getNodeIdForLogical(linkLeft.srcPin.logicalId);
    auto leftDstNodeId = (linkLeft.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkLeft.dstPin.logicalId);

    // 3. Get Original Connection Points for RIGHT cable (second cable)
    auto rightSrcNodeId = synth->getNodeIdForLogical(linkRight.srcPin.logicalId);
    auto rightDstNodeId = (linkRight.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkRight.dstPin.logicalId);

    // 4. Disconnect BOTH Original Links (using their actual source/dest channels)
    synth->disconnect(leftSrcNodeId, linkLeft.srcPin.channel, leftDstNodeId, linkLeft.dstPin.channel);
    synth->disconnect(rightSrcNodeId, linkRight.srcPin.channel, rightDstNodeId, linkRight.dstPin.channel);

    // 5. Reconnect Through the New Node
    // Left cable -> new node's LEFT input (ch0)
    bool leftInConnected = synth->connect(leftSrcNodeId, linkLeft.srcPin.channel, newNodeId, 0);
    
    // Right cable -> new node's RIGHT input (ch1)
    bool rightInConnected = synth->connect(rightSrcNodeId, linkRight.srcPin.channel, newNodeId, 1);
    
    // New node's outputs -> original destinations
    // Note: We'll connect both outputs to their respective destinations
    bool leftOutConnected = synth->connect(newNodeId, 0, leftDstNodeId, linkLeft.dstPin.channel);
    bool rightOutConnected = synth->connect(newNodeId, 1, rightDstNodeId, linkRight.dstPin.channel);

    if (leftInConnected && rightInConnected && leftOutConnected && rightOutConnected)
    {
        juce::Logger::writeToLog("[InsertStereo] Successfully inserted stereo node: both channels connected");
    }
    else
    {
        juce::Logger::writeToLog("[InsertStereo] WARNING: Some connections failed - leftIn=" + juce::String(leftInConnected ? 1 : 0) +
                                ", rightIn=" + juce::String(rightInConnected ? 1 : 0) +
                                ", leftOut=" + juce::String(leftOutConnected ? 1 : 0) +
                                ", rightOut=" + juce::String(rightOutConnected ? 1 : 0));
    }
}
void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin, bool createUndoSnapshot)
{
    if (synth == nullptr)
        return;

    PinDataType srcType = getPinDataTypeForPin(srcPin);
    PinDataType dstType = getPinDataTypeForPin(dstPin);

    ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(srcPin.logicalId);
    ImVec2 dstPos = ImNodes::GetNodeGridSpacePos(dstPin.logicalId == 0 ? 0 : dstPin.logicalId);
    ImVec2 newNodePos = ImVec2((srcPos.x + dstPos.x) * 0.5f, (srcPos.y + dstPos.y) * 0.5f);

    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;

    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }

    if (! isVst)
        newNodeId = synth->addModule(nodeType);

    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodePositions[(int)newNodeLid] = newNodePos;

    if (!srcPin.isMod)
    {
        if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
            reroute->setPassthroughType(srcType);
    }

    auto originalSrcNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
    auto originalDstNodeId = (dstPin.logicalId == 0)
        ? synth->getOutputNodeID()
        : synth->getNodeIdForLogical(dstPin.logicalId);

    int newNodeOutputChannel = 0;
    if (nodeType == "map_range")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    synth->connect(originalSrcNodeId, srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, dstPin.channel);

    if (getTypeForLogical(newNodeLid).equalsIgnoreCase("reroute"))
        updateRerouteTypeFromConnections((juce::uint32)newNodeLid);

    juce::Logger::writeToLog("[AutoConvert] Inserted '" + nodeType + "' between "
                             + juce::String(srcPin.logicalId) + " and " + juce::String(dstPin.logicalId));

    if (createUndoSnapshot)
    {
        pushSnapshot();
        graphNeedsRebuild = true;
    }
}

void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType)
{
    if (linkToInsertOn.linkId != -1)
    {
        insertNodeOnLink(nodeType, linkToInsertOn, ImGui::GetMousePos());
        graphNeedsRebuild = true;
        pushSnapshot();
        linkToInsertOn.linkId = -1;
    }
}
void ImGuiNodeEditorComponent::handleInsertNodeOnSelectedLinks(const juce::String& nodeType)
{
    if (synth == nullptr || ImNodes::NumSelectedLinks() == 0)
        return;

    pushSnapshot();

    const int numSelectedLinks = ImNodes::NumSelectedLinks();
    std::vector<int> selectedLinkIds(numSelectedLinks);
    ImNodes::GetSelectedLinks(selectedLinkIds.data());

    ImVec2 basePosition = ImGui::GetMousePos();
    float xOffset = 0.0f;

    if (numSelectedLinks == 2)
    {
        auto it0 = linkIdToAttrs.find(selectedLinkIds[0]);
        auto it1 = linkIdToAttrs.find(selectedLinkIds[1]);

        if (it0 != linkIdToAttrs.end() && it1 != linkIdToAttrs.end())
        {
            LinkInfo firstLink;
            firstLink.linkId = selectedLinkIds[0];
            firstLink.srcPin = decodePinId(it0->second.first);
            firstLink.dstPin = decodePinId(it0->second.second);
            firstLink.isMod = firstLink.srcPin.isMod || firstLink.dstPin.isMod;

            LinkInfo secondLink;
            secondLink.linkId = selectedLinkIds[1];
            secondLink.srcPin = decodePinId(it1->second.first);
            secondLink.dstPin = decodePinId(it1->second.second);
            secondLink.isMod = secondLink.srcPin.isMod || secondLink.dstPin.isMod;

            if (!firstLink.isMod && !secondLink.isMod)
            {
                auto isStereoCandidate = [&]() -> bool
                {
                    // Both links must be from the same source node
                    if (firstLink.srcPin.logicalId != secondLink.srcPin.logicalId)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: different source nodes");
                        return false;
                    }

                    // Both links must go to the same destination (or both to main output)
                    const bool bothToMainOutput = (firstLink.dstPin.logicalId == 0 && secondLink.dstPin.logicalId == 0);
                    if (!bothToMainOutput && firstLink.dstPin.logicalId != secondLink.dstPin.logicalId)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: different destination nodes");
                        return false;
                    }

                    // Source channels should be consecutive (0-1, 1-2, etc.) for stereo
                    const int srcDelta = std::abs(firstLink.srcPin.channel - secondLink.srcPin.channel);
                    const int dstDelta = std::abs(firstLink.dstPin.channel - secondLink.dstPin.channel);
                    
                    // For stereo, we expect channels 0 and 1, but allow other consecutive pairs
                    if (srcDelta != 1)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: source channels not consecutive (delta=" + juce::String(srcDelta) + ")");
                        return false;
                    }
                    
                    // Destination channels should also be consecutive
                    if (dstDelta != 1)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: destination channels not consecutive (delta=" + juce::String(dstDelta) + ")");
                        return false;
                    }

                    // All pins must be audio type
                    const auto srcTypeA = getPinDataTypeForPin(firstLink.srcPin);
                    const auto srcTypeB = getPinDataTypeForPin(secondLink.srcPin);
                    const auto dstTypeA = getPinDataTypeForPin(firstLink.dstPin);
                    const auto dstTypeB = getPinDataTypeForPin(secondLink.dstPin);
                    const bool allAudio = srcTypeA == PinDataType::Audio && srcTypeB == PinDataType::Audio
                                          && dstTypeA == PinDataType::Audio && dstTypeB == PinDataType::Audio;
                    
                    if (!allAudio)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: not all audio pins");
                        return false;
                    }

                    juce::Logger::writeToLog("[InsertNode] Detected stereo pair: ch" + juce::String(firstLink.srcPin.channel) + 
                                            " and ch" + juce::String(secondLink.srcPin.channel));
                    return true;
                };

                if (isStereoCandidate())
                {
                    LinkInfo leftLink = firstLink;
                    LinkInfo rightLink = secondLink;
                    
                    // Ensure left link has the lower channel number
                    if (rightLink.srcPin.channel < leftLink.srcPin.channel)
                        std::swap(leftLink, rightLink);

                    juce::Logger::writeToLog("[InsertNode] Inserting STEREO node: left=ch" + juce::String(leftLink.srcPin.channel) + 
                                            ", right=ch" + juce::String(rightLink.srcPin.channel));
                    insertNodeOnLinkStereo(nodeType, leftLink, rightLink, basePosition);
                    juce::Logger::writeToLog("[InsertNode] Successfully inserted STEREO node for 2 selected audio cables");
                    graphNeedsRebuild = true;
                    return;
                }
            }
        }
    }

    std::set<int> processedLinks;

    for (int linkId : selectedLinkIds)
    {
        if (processedLinks.count(linkId) != 0)
            continue;

        auto it = linkIdToAttrs.find(linkId);
        if (it == linkIdToAttrs.end())
            continue;

        LinkInfo link;
        link.linkId = linkId;
        link.srcPin = decodePinId(it->second.first);
        link.dstPin = decodePinId(it->second.second);
        link.isMod = link.srcPin.isMod || link.dstPin.isMod;

        ImVec2 newPosition(basePosition.x + xOffset, basePosition.y);
        insertNodeOnLink(nodeType, link, newPosition);
        processedLinks.insert(linkId);
        juce::Logger::writeToLog("[InsertNode] Inserted MONO node for link " + juce::String(linkId));

        xOffset += 40.0f;
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::expandMetaModule(juce::uint32 metaLogicalId)
{
    if (!synth)
        return;

    const auto metaNodeId = synth->getNodeIdForLogical(metaLogicalId);
    if (metaNodeId.uid == 0)
        return;

    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule == nullptr)
        return;

    const auto metaState = metaModule->getExtraStateTree();
    const juce::String encoded = metaState.getProperty("internalGraphState").toString();
    if (encoded.isEmpty())
    {
        NotificationManager::post(NotificationManager::Type::Warning, "Meta module has no internal patch to expand.");
        return;
    }

    juce::MemoryOutputStream decoded;
    if (!juce::Base64::convertFromBase64(decoded, encoded))
    {
        NotificationManager::post(NotificationManager::Type::Warning, "Failed to decode meta module state.");
        return;
    }

    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(decoded.toString()));
    if (xml == nullptr)
        return;

    juce::ValueTree internalRoot = juce::ValueTree::fromXml(*xml);
    auto modulesVT = internalRoot.getChildWithName("modules");
    auto connsVT = internalRoot.getChildWithName("connections");
    if (!modulesVT.isValid() || !connsVT.isValid())
        return;

    pushSnapshot();

    struct CollapsedInlet { int oldId{}; int pinIndex{}; int channelCount{1}; juce::uint32 externalLogicalId{}; int externalChannel{}; int metaChannel{}; };
    struct CollapsedOutlet { int oldId{}; int pinIndex{}; int channelCount{1}; juce::uint32 externalLogicalId{}; int externalChannel{}; bool externalIsOutput{}; int metaChannel{}; };
    struct InternalConnection { int srcId; int srcChan; int dstId; int dstChan; };
    struct InboundConnection { int inletOldId; int dstId; int dstChan; };
    struct OutboundConnection { int srcId; int srcChan; int outletOldId; };

    std::vector<CollapsedInlet> collapsedInlets;
    std::vector<CollapsedOutlet> collapsedOutlets;
    std::vector<InternalConnection> internalConnections;
    std::vector<InboundConnection> inboundConnections;
    std::vector<OutboundConnection> outboundConnections;
    std::map<int, juce::uint32> oldToNew;
    std::vector<juce::uint32> createdLogicalIds;

    auto readChannelCount = [](const juce::ValueTree& moduleVT, const juce::Identifier& paramId) -> int
    {
        if (auto paramsWrapper = moduleVT.getChildWithName("params"); paramsWrapper.isValid())
        {
            if (paramsWrapper.getNumChildren() > 0)
            {
                auto params = paramsWrapper.getChild(0);
                for (int i = 0; i < params.getNumChildren(); ++i)
                {
                    auto paramNode = params.getChild(i);
                    if (paramNode.getProperty("id").toString().equalsIgnoreCase(paramId.toString()))
                        return (int)paramNode.getProperty("value", 1.0);
                }
            }
        }
        return 1;
    };

    std::unordered_set<int> inletIds;
    std::unordered_set<int> outletIds;

    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleVT = modulesVT.getChild(i);
        if (!moduleVT.hasType("module"))
            continue;

        const int oldId = (int)moduleVT.getProperty("logicalId", 0);
        const juce::String type = moduleVT.getProperty("type").toString();

        auto extraWrapper = moduleVT.getChildWithName("extra");
        auto extraState = (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0) ? extraWrapper.getChild(0) : juce::ValueTree();

        if (type.equalsIgnoreCase("inlet"))
        {
            CollapsedInlet inlet;
            inlet.oldId = oldId;
            inlet.pinIndex = (int)extraState.getProperty("pinIndex", (int)collapsedInlets.size());
            inlet.channelCount = readChannelCount(moduleVT, InletModuleProcessor::paramIdChannelCount);
            inlet.externalLogicalId = (juce::uint32)(int)extraState.getProperty("externalLogicalId", 0);
            inlet.externalChannel = (int)extraState.getProperty("externalChannel", 0);
            collapsedInlets.push_back(inlet);
            inletIds.insert(oldId);
            continue;
        }

        if (type.equalsIgnoreCase("outlet"))
        {
            CollapsedOutlet outlet;
            outlet.oldId = oldId;
            outlet.pinIndex = (int)extraState.getProperty("pinIndex", (int)collapsedOutlets.size());
            outlet.channelCount = readChannelCount(moduleVT, OutletModuleProcessor::paramIdChannelCount);
            outlet.externalLogicalId = (juce::uint32)(int)extraState.getProperty("externalLogicalId", 0);
            outlet.externalChannel = (int)extraState.getProperty("externalChannel", 0);
            outlet.externalIsOutput = (bool)(int)extraState.getProperty("externalIsOutput", outlet.externalLogicalId == 0 ? 1 : 0);
            collapsedOutlets.push_back(outlet);
            outletIds.insert(oldId);
            continue;
        }

        const auto nodeId = synth->addModule(type);
        const juce::uint32 newLogical = synth->getLogicalIdForNode(nodeId);
        oldToNew[oldId] = newLogical;
        createdLogicalIds.push_back(newLogical);

        if (auto* module = synth->getModuleForLogical(newLogical))
        {
            if (auto paramsWrapper = moduleVT.getChildWithName("params"); paramsWrapper.isValid())
                if (paramsWrapper.getNumChildren() > 0)
                    module->getAPVTS().replaceState(paramsWrapper.getChild(0));
            if (extraState.isValid())
                module->setExtraStateTree(extraState);
        }
    }

    for (int i = 0; i < connsVT.getNumChildren(); ++i)
    {
        auto cv = connsVT.getChild(i);
        if (!cv.hasType("connection"))
            continue;

        const int srcId = (int)cv.getProperty("srcId", 0);
        const int dstId = (int)cv.getProperty("dstId", 0);
        const int srcChan = (int)cv.getProperty("srcChan", 0);
        const int dstChan = (int)cv.getProperty("dstChan", 0);

        const bool srcIsInlet = inletIds.count(srcId) > 0;
        const bool dstIsOutlet = outletIds.count(dstId) > 0;

        if (srcIsInlet && !dstIsOutlet)
            inboundConnections.push_back({ srcId, dstId, dstChan });
        else if (!srcIsInlet && dstIsOutlet)
            outboundConnections.push_back({ srcId, srcChan, dstId });
        else if (!srcIsInlet && !dstIsOutlet)
            internalConnections.push_back({ srcId, srcChan, dstId, dstChan });
    }

    std::sort(collapsedInlets.begin(), collapsedInlets.end(), [](const CollapsedInlet& a, const CollapsedInlet& b)
    {
        if (a.pinIndex != b.pinIndex)
            return a.pinIndex < b.pinIndex;
        return a.oldId < b.oldId;
    });

    int runningChannel = 0;
    for (auto& inlet : collapsedInlets)
    {
        inlet.metaChannel = runningChannel;
        runningChannel += inlet.channelCount;
    }

    std::sort(collapsedOutlets.begin(), collapsedOutlets.end(), [](const CollapsedOutlet& a, const CollapsedOutlet& b)
    {
        if (a.pinIndex != b.pinIndex)
            return a.pinIndex < b.pinIndex;
        return a.oldId < b.oldId;
    });

    runningChannel = 0;
    for (auto& outlet : collapsedOutlets)
    {
        outlet.metaChannel = runningChannel;
        runningChannel += outlet.channelCount;
    }

    std::unordered_map<int, std::pair<juce::uint32, int>> metaInputs;
    std::unordered_map<int, std::tuple<juce::uint32, int, bool>> metaOutputs;

    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstLogicalId == metaLogicalId && !c.dstIsOutput)
            metaInputs.emplace(c.dstChan, std::make_pair(c.srcLogicalId, c.srcChan));
        if (c.srcLogicalId == metaLogicalId)
            metaOutputs.emplace(c.srcChan, std::make_tuple(c.dstLogicalId, c.dstChan, c.dstIsOutput));
    }

    for (auto& inlet : collapsedInlets)
    {
        if (inlet.externalLogicalId == 0 && metaInputs.count(inlet.metaChannel) > 0)
        {
            auto external = metaInputs[inlet.metaChannel];
            inlet.externalLogicalId = external.first;
            inlet.externalChannel = external.second;
        }
    }

    for (auto& outlet : collapsedOutlets)
    {
        if (metaOutputs.count(outlet.metaChannel) > 0)
        {
            auto external = metaOutputs[outlet.metaChannel];
            if ((outlet.externalLogicalId == 0 || std::get<0>(external) != 0))
                outlet.externalLogicalId = std::get<0>(external);
            outlet.externalChannel = std::get<1>(external);
            outlet.externalIsOutput = std::get<2>(external) || outlet.externalLogicalId == 0;
        }
    }

    std::unordered_map<int, CollapsedInlet> inletLookup;
    for (const auto& inlet : collapsedInlets)
        inletLookup.emplace(inlet.oldId, inlet);

    std::unordered_map<int, CollapsedOutlet> outletLookup;
    for (const auto& outlet : collapsedOutlets)
        outletLookup.emplace(outlet.oldId, outlet);

    for (const auto& conn : internalConnections)
    {
        auto srcIt = oldToNew.find(conn.srcId);
        auto dstIt = oldToNew.find(conn.dstId);
        if (srcIt == oldToNew.end() || dstIt == oldToNew.end())
            continue;

        auto srcNode = synth->getNodeIdForLogical(srcIt->second);
        auto dstNode = synth->getNodeIdForLogical(dstIt->second);
        if (srcNode.uid == 0 || dstNode.uid == 0)
            continue;

        synth->connect(srcNode, conn.srcChan, dstNode, conn.dstChan);
    }

    for (const auto& inbound : inboundConnections)
    {
        auto inletIt = inletLookup.find(inbound.inletOldId);
        auto dstIt = oldToNew.find(inbound.dstId);
        if (inletIt == inletLookup.end() || dstIt == oldToNew.end())
            continue;

        const auto& inlet = inletIt->second;
        if (inlet.externalLogicalId == 0)
            continue;

        auto srcNode = synth->getNodeIdForLogical(inlet.externalLogicalId);
        auto dstNode = synth->getNodeIdForLogical(dstIt->second);
        if (srcNode.uid == 0 || dstNode.uid == 0)
            continue;

        synth->connect(srcNode, inlet.externalChannel, dstNode, inbound.dstChan);
    }

    for (const auto& outbound : outboundConnections)
    {
        auto outletIt = outletLookup.find(outbound.outletOldId);
        auto srcIt = oldToNew.find(outbound.srcId);
        if (outletIt == outletLookup.end() || srcIt == oldToNew.end())
            continue;

        const auto& outlet = outletIt->second;
        auto srcNode = synth->getNodeIdForLogical(srcIt->second);
        if (srcNode.uid == 0)
            continue;

        juce::AudioProcessorGraph::NodeID dstNode;
        if (outlet.externalIsOutput || outlet.externalLogicalId == 0)
            dstNode = synth->getOutputNodeID();
        else
            dstNode = synth->getNodeIdForLogical(outlet.externalLogicalId);

        if (dstNode.uid == 0)
            continue;

        synth->connect(srcNode, outbound.srcChan, dstNode, outlet.externalChannel);
    }

    const ImVec2 metaPos = ImNodes::GetNodeGridSpacePos((int)metaLogicalId);
    synth->removeModule(metaNodeId);

    const float spacing = 160.0f;
    for (std::size_t idx = 0; idx < createdLogicalIds.size(); ++idx)
    {
        const auto lid = createdLogicalIds[idx];
        const int ix = (int)(idx % 4);
        const int iy = (int)(idx / 4);
        pendingNodePositions[(int)lid] = ImVec2(metaPos.x + ix * spacing, metaPos.y + iy * spacing);
    }

    selectedLogicalId = 0;
    graphNeedsRebuild = true;
    synth->commitChanges();

    NotificationManager::post(NotificationManager::Type::Info, "Expanded Meta Module");
}

juce::File ImGuiNodeEditorComponent::findPresetsDirectory()
{
    // Search upwards from the executable's location for a sibling directory
    // named "Synth_presets". This is robust to different build configurations.
    juce::File dir = juce::File::getSpecialLocation(juce::File::currentExecutableFile);

    for (int i = 0; i < 8; ++i) // Limit search depth to 8 levels
    {
        dir = dir.getParentDirectory();
        if (!dir.exists()) break;

        juce::File candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.isDirectory())
        {
            return candidate;
        }
    }
    
    // Fallback to an empty file (system default) if not found
    return {};
}
// Helper function implementations
PinDataType ImGuiNodeEditorComponent::getPinDataTypeForPin(const PinID& pin)
{
    if (synth == nullptr) return PinDataType::Raw;

    // Handle the main output node as a special case
    if (pin.logicalId == 0)
    {
        return PinDataType::Audio;
    }

    juce::String moduleType = getTypeForLogical(pin.logicalId);
    if (moduleType.isEmpty()) return PinDataType::Raw;

    // *** NEW: Check dynamic pins FIRST ***
    if (auto* module = synth->getModuleForLogical(pin.logicalId))
    {
        // Check dynamic input pins
        if (pin.isInput && !pin.isMod)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            for (const auto& dynPin : dynamicInputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
        // Check dynamic output pins
        else if (!pin.isInput && !pin.isMod)
        {
            auto dynamicOutputs = module->getDynamicOutputPins();
            for (const auto& dynPin : dynamicOutputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
    }
    // *** END NEW CODE ***

    auto it = getModulePinDatabase().find(moduleType);
    if (it == getModulePinDatabase().end())
    {
        // Fallback: case-insensitive lookup (module registry may use different casing)
        juce::String moduleTypeLower = moduleType.toLowerCase();
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0 || kv.first.toLowerCase() == moduleTypeLower)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
        if (it == getModulePinDatabase().end())
        {
            // If the module type is not in our static database, it's likely a VST plugin.
            // A safe assumption is that its pins are for audio.
            if (auto* module = synth->getModuleForLogical(pin.logicalId))
            {
                if (dynamic_cast<VstHostModuleProcessor*>(module))
                {
                    return PinDataType::Audio; // Green for VST pins
                }
            }
            return PinDataType::Raw;
        }
    }

    const auto& pinInfo = it->second;

    if (pin.isMod)
    {
        for (const auto& modPin : pinInfo.modIns)
        {
            if (modPin.paramId == pin.paramId)
            {
                return modPin.type;
            }
        }
    }
    else // It's an audio pin
    {
        const auto& pins = pin.isInput ? pinInfo.audioIns : pinInfo.audioOuts;
        for (const auto& audioPin : pins)
        {
            if (audioPin.channel == pin.channel)
            {
                return audioPin.type;
            }
        }
    }
    return PinDataType::Raw; // Fallback
}

unsigned int ImGuiNodeEditorComponent::getImU32ForType(PinDataType type)
{
	const ImU32 themedColor = ThemeManager::getInstance().getPinColor(type);
	if (themedColor != 0)
		return themedColor;

	switch (type)
	{
		case PinDataType::CV:    return IM_COL32(100, 150, 255, 255); // Blue
		case PinDataType::Audio: return IM_COL32(100, 255, 150, 255); // Green
		case PinDataType::Gate:  return IM_COL32(255, 220, 100, 255); // Yellow
		case PinDataType::Raw:   return IM_COL32(255, 100, 100, 255); // Red
		case PinDataType::Video: return IM_COL32(0, 200, 255, 255);   // Cyan
		default:                 return IM_COL32(150, 150, 150, 255); // Grey
	}
}

const char* ImGuiNodeEditorComponent::pinDataTypeToString(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return "CV (0 to 1)";
        case PinDataType::Audio: return "Audio (-1 to 1)";
        case PinDataType::Gate:  return "Gate/Trigger";
        case PinDataType::Raw:   return "Raw";
        case PinDataType::Video: return "Video Source";
        default:                 return "Unknown";
    }
}
std::vector<AudioPin> ImGuiNodeEditorComponent::getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType)
{
    std::vector<AudioPin> matchingPins;
    juce::String moduleType = getTypeForLogical(logicalId);

    if (moduleType.isEmpty())
    {
        return matchingPins;
    }

    auto it = getModulePinDatabase().find(moduleType);

    // --- CASE-INSENSITIVE LOOKUP ---
    if (it == getModulePinDatabase().end())
    {
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
    }

    if (it != getModulePinDatabase().end())
    {
        // --- Standard path for built-in modules ---
        const auto& pins = isInput ? it->second.audioIns : it->second.audioOuts;
        for (const auto& pin : pins)
        {
            if (pin.type == targetType)
            {
                matchingPins.push_back(pin);
            }
        }
    }

    // If no static pins matched (or none defined), fall back to dynamic pins from the module
    if (matchingPins.empty())
    {
        if (auto* module = synth->getModuleForLogical(logicalId))
        {
            // --- DYNAMIC PATH FOR MODULES WITH getDynamicInputPins/getDynamicOutputPins ---
            auto dynamicPins = isInput ? module->getDynamicInputPins() : module->getDynamicOutputPins();
            
            if (!dynamicPins.empty())
            {
                // Module provides dynamic pins - filter by type
                for (const auto& pin : dynamicPins)
                {
                    if (pin.type == targetType)
                    {
                        matchingPins.emplace_back(pin.name, pin.channel, pin.type);
                    }
                }
            }
            else if (auto* vst = dynamic_cast<VstHostModuleProcessor*>(module))
            {
                // For VSTs without dynamic pins, assume all pins are 'Audio' type for chaining.
                if (targetType == PinDataType::Audio)
                {
                    const int numChannels = isInput ? vst->getTotalNumInputChannels() : vst->getTotalNumOutputChannels();
                    for (int i = 0; i < numChannels; ++i)
                    {
                        juce::String pinName = isInput ? vst->getAudioInputLabel(i) : vst->getAudioOutputLabel(i);
                        if (pinName.isNotEmpty())
                        {
                            matchingPins.emplace_back(pinName, i, PinDataType::Audio);
                        }
                    }
                }
            }
        }
    }

    return matchingPins;
}

void ImGuiNodeEditorComponent::handleNodeChaining()
{
    if (synth == nullptr)
        return;

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
        return;

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    sortedNodes.reserve(selectedNodeIds.size());

    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0)
            continue;
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.emplace_back(pos.x, nodeId);
    }

    if (sortedNodes.size() <= 1)
        return;

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    pushSnapshot();

    for (size_t i = 0; i + 1 < sortedNodes.size(); ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
            continue;

        synth->connect(sourceNodeId, 0, destNodeId, 0);
        synth->connect(sourceNodeId, 1, destNodeId, 1);

        if (auto* destModule = synth->getModuleForLogical(destLid))
        {
            if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
            {
                if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                    recorder->updateSuggestedFilename(sourceModule->getName());
            }
        }
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleRecordOutput()
{
    if (!synth) return;

    pushSnapshot();
    juce::Logger::writeToLog("[Record Output] Initiated.");

    // 1. Find connections going to the main output node.
    std::vector<ModularSynthProcessor::ConnectionInfo> outputFeeds;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstIsOutput)
        {
            outputFeeds.push_back(c);
        }
    }

    if (outputFeeds.empty())
    {
        juce::Logger::writeToLog("[Record Output] No connections to main output found.");
        return;
    }

    // 2. Create and position the recorder.
    auto recorderNodeId = synth->addModule("recorder");
    auto recorderLid = synth->getLogicalIdForNode(recorderNodeId);
    ImVec2 outPos = ImNodes::GetNodeGridSpacePos(0);
    pendingNodePositions[(int)recorderLid] = ImVec2(outPos.x - 400.0f, outPos.y);
    
    auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical(recorderLid));
    if (recorder)
    {
        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
    }

    // 3. "Tap" the signals by connecting the original sources to the recorder.
    juce::String sourceName;
    for (const auto& feed : outputFeeds)
    {
        auto srcNodeId = synth->getNodeIdForLogical(feed.srcLogicalId);
        synth->connect(srcNodeId, feed.srcChan, recorderNodeId, feed.dstChan); // dstChan will be 0 or 1
        
        // Get the name of the first source for the filename prefix
        if (sourceName.isEmpty())
        {
            if (auto* srcModule = synth->getModuleForLogical(feed.srcLogicalId))
            {
                sourceName = srcModule->getName();
            }
        }
    }
    
    if (recorder)
    {
        recorder->updateSuggestedFilename(sourceName);
    }

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[Record Output] Recorder added and connected.");
}
void ImGuiNodeEditorComponent::handleColorCodedChaining(PinDataType targetType)
{
    if (synth == nullptr)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: synth is nullptr");
        return;
    }

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: numSelected <= 1 (" + juce::String(numSelected) + ")");
        return;
    }

    juce::Logger::writeToLog("[Color Chaining] Started for " + juce::String(toString(targetType)) + " with " + juce::String(numSelected) + " nodes");

    // 1. Get and sort selected nodes by their horizontal position.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0) continue; // Exclude the output node.
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    if (sortedNodes.empty())
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: No valid nodes after filtering");
        return;
    }

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    int totalConnectionsMade = 0;
    int totalConnectionAttempts = 0;

    // 2. Iterate through sorted nodes and connect matching pins.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[Color Chaining] Skipping invalid node pair: " + juce::String(sourceLid) + " -> " + juce::String(destLid));
            continue;
        }

        // Find all matching output pins on the source and input pins on the destination.
        auto sourcePins = getPinsOfType(sourceLid, false, targetType);
        auto destPins   = getPinsOfType(destLid, true, targetType);

        if (sourcePins.empty() || destPins.empty())
        {
            juce::Logger::writeToLog("[Color Chaining] No matching pins: " + juce::String(sourcePins.size()) + " src, " + juce::String(destPins.size()) + " dst");
            continue;
        }

        // Connect them one-to-one until we run out of available pins on either side.
        int connectionsToMake = std::min((int)sourcePins.size(), (int)destPins.size());

        for (int j = 0; j < connectionsToMake; ++j)
        {
            totalConnectionAttempts++;
            bool connectResult = synth->connect(sourceNodeId, sourcePins[j].channel, destNodeId, destPins[j].channel);
            if (connectResult)
            {
                totalConnectionsMade++;
                juce::Logger::writeToLog("[Color Chaining] Connected " + getTypeForLogical(sourceLid) + " -> " + getTypeForLogical(destLid));

                // Check if the destination is a recorder and update its filename
                if (auto* destModule = synth->getModuleForLogical(destLid))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                    {
                        if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                        {
                            recorder->updateSuggestedFilename(sourceModule->getName());
                        }
                    }
                }
            }
        }
    }

    juce::Logger::writeToLog("[Color Chaining] Completed: " + juce::String(totalConnectionsMade) + "/" + juce::String(totalConnectionAttempts) + " connections made");

    // 3. Apply all new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Module Category Color Coding
ImGuiNodeEditorComponent::ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleType)
{
    juce::String lower = moduleType.toLowerCase();
    
    // === CATEGORY CLASSIFICATION (Following Dictionary Structure) ===
    
    // --- 1. SOURCES (Green) ---
    if (lower.contains("vco") || lower.contains("polyvco") ||
        lower.contains("noise") || lower == "audio_input" || 
        lower.contains("sample") || lower == "value")
        return ModuleCategory::Source;
    
    // --- 2. EFFECTS (Red) ---
    // Note: Recorder moved to System, Vocal Tract Filter moved to TTS
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("reverb") || lower.contains("chorus") || 
        lower.contains("phaser") || lower.contains("compressor") || 
        lower.contains("limiter") || lower == "gate" ||
        lower.contains("drive") || lower.contains("eq") ||
        lower.contains("waveshaper") || lower.contains("8bandshaper") ||
        lower.contains("granulator") || lower.contains("harmonic_shaper") ||
        lower.contains("timepitch") || lower.contains("crackle"))
        return ModuleCategory::Effect;
    
    // --- 3. MODULATORS (Blue) ---
    if (lower.contains("lfo") || lower.contains("adsr") || 
        lower.contains("random") || lower.contains("s&h") || 
        lower.contains("function_generator") || lower.contains("shaping_oscillator"))
        return ModuleCategory::Modulator;
    
    // --- 4. UTILITIES & LOGIC (Orange) ---
    if (lower.contains("vca") || lower.contains("mixer") || 
        lower.contains("attenuverter") || lower.contains("lag_processor") ||
        lower.contains("math") || lower.contains("map_range") ||
        lower.contains("quantizer") || lower.contains("rate") ||
        lower.contains("comparator") || lower.contains("logic") ||
        lower.contains("reroute") ||
        lower.contains("clock_divider") || lower.contains("sequential_switch"))
        return ModuleCategory::Utility;
    
    // --- 5. SEQUENCERS (Light Green) ---
    if (lower.contains("sequencer") || lower.contains("tempo_clock") || lower == "timeline")
        return ModuleCategory::Seq;
    
    // --- 6. MIDI (Vibrant Purple) ---
    if (lower.contains("midi"))
        return ModuleCategory::MIDI;
    
    // --- 7. ANALYSIS (Purple) ---
    if (lower.contains("scope") || lower.contains("debug") || 
        lower.contains("frequency_graph"))
        return ModuleCategory::Analysis;
    
    // --- 8. TTS (Peach/Coral) ---
    if (lower.contains("tts") || lower.contains("vocal_tract"))
        return ModuleCategory::TTS_Voice;
    
    // --- 9. SPECIAL (Cyan) - Physics & Animation ---
    if (lower.contains("physics") || lower.contains("animation"))
        return ModuleCategory::Special_Exp;
    
    // --- 10. COMPUTER VISION (Bright Orange) ---
    if (lower.contains("webcam") || lower.contains("video_file") ||
        lower == "video_fx" || lower == "crop_video" ||
        lower.contains("movement") || lower.contains("detector") || 
        lower.contains("opencv") || lower.contains("vision") ||
        lower.contains("tracker") || lower.contains("segmentation") ||
        lower.contains("pose_estimator"))
        return ModuleCategory::OpenCV;
    
    // --- 11. SYSTEM (Lavender) ---
    if (lower.contains("meta") || lower.contains("inlet") || 
        lower.contains("outlet") || lower.contains("comment") ||
        lower.contains("recorder") || lower.contains("vst_host") ||
        lower.contains("best_practice") || lower == "bpm_monitor" || lower.contains("bpm monitor"))
        return ModuleCategory::Sys;
    
    // --- 12. PLUGINS (Teal) ---
    if (lower.contains("vst") || lower.contains("plugin"))
        return ModuleCategory::Plugin;
    
    // --- Default: Utility ---
    return ModuleCategory::Utility;
}

unsigned int ImGuiNodeEditorComponent::getImU32ForCategory(ModuleCategory category, bool hovered)
{
    ImU32 color = ThemeManager::getInstance().getCategoryColor(static_cast<::ModuleCategory>(category));
    
    if (hovered) 
    { 
        // Brighten on hover
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        c.x = juce::jmin(c.x * 1.3f, 1.0f);
        c.y = juce::jmin(c.y * 1.3f, 1.0f);
        c.z = juce::jmin(c.z * 1.3f, 1.0f);
        return ImGui::ColorConvertFloat4ToU32(c);
    }
    return color;
}

// Quick Add Menu - Module Registry - Dictionary
// Maps Display Name -> { Internal Type, Description }
std::map<juce::String, std::pair<const char*, const char*>> ImGuiNodeEditorComponent::getModuleRegistry()
{
    return {
        // Sources
        {"Audio Input", {"audio_input", "Records audio from your audio interface"}},
        {"VCO", {"vco", "Voltage Controlled Oscillator - generates waveforms"}},
        {"Polyphonic VCO", {"polyvco", "Polyphonic VCO with multiple voices"}},
        {"Noise", {"noise", "White, pink, or brown noise generator"}},
        {"Sequencer", {"sequencer", "Step sequencer for creating patterns"}},
        {"Multi Sequencer", {"multi_sequencer", "Multi-track step sequencer"}},
        {"Stroke Sequencer", {"stroke_sequencer", "Freeform visual rhythmic and CV generator"}},
        {"MIDI Player", {"midi_player", "Plays MIDI files"}},
        {"MIDI CV", {"midi_cv", "Converts MIDI Note/CC messages to CV signals. (Monophonic)"}},
        {"MIDI Faders", {"midi_faders", "Up to 16 MIDI faders with CC learning"}},
        {"MIDI Knobs", {"midi_knobs", "Up to 16 MIDI knobs/rotary encoders with CC learning"}},
        {"MIDI Buttons", {"midi_buttons", "Up to 32 MIDI buttons with Gate/Toggle/Trigger modes"}},
        {"MIDI Jog Wheel", {"midi_jog_wheel", "Single MIDI jog wheel/rotary encoder"}},
        {"MIDI Pads", {"midi_pads", "16-pad MIDI controller with polyphonic triggers and velocity outputs"}},
        {"MIDI Logger", {"midi_logger", "Records CV/Gate to MIDI events with piano roll editor and .mid export"}},
        {"Value", {"value", "Constant CV value output"}},
        {"Sample Loader", {"sample_loader", "Loads and plays audio samples"}},
        
        // TTS
        {"TTS Performer", {"tts_performer", "Text-to-speech synthesizer"}},
        {"Vocal Tract Filter", {"vocal_tract_filter", "Physical model vocal tract filter"}},
        
        // Physics & Animation
        {"Physics", {"physics", "2D physics simulation for audio modulation"}},
        {"Animation", {"animation", "Skeletal animation system with glTF file support"}},
        
        // OpenCV (Computer Vision)
        {"Webcam Loader", {"webcam_loader", "Captures video from a webcam and publishes it as a source for vision processing modules"}},
        {"Video File Loader", {"video_file_loader", "Loads and plays a video file, publishes it as a source for vision processing modules"}},
        {"Video FX", {"video_fx", "Applies real-time video effects (brightness, contrast, saturation, blur, sharpen, etc.) to video sources, chainable"}},
        {"Crop Video", {"crop_video", "Crops and resizes video frames to a specified region, chainable video processor"}},
        {"Movement Detector", {"movement_detector", "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV"}},
        {"Human Detector", {"human_detector", "Detects faces or bodies in video source via Haar Cascades or HOG, outputs position and size as CV"}},
        {"Object Detector", {"object_detector", "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV"}},
        {"Pose Estimator", {"pose_estimator", "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals"}},
        {"Hand Tracker", {"hand_tracker", "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels)"}},
        {"Face Tracker", {"face_tracker", "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels)"}},
        {"Color Tracker", {"color_tracker", "Tracks multiple colors in video and outputs their positions and sizes as CV"}},
        {"Contour Detector", {"contour_detector", "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV"}},
        {"Semantic Segmentation", {"semantic_segmentmentation", "Uses deep learning to segment video into semantic regions and outputs detected areas as CV"}},
        
        // Effects
        {"VCF", {"vcf", "Voltage Controlled Filter"}},
        {"Delay", {"delay", "Echo/delay effect"}},
        {"Reverb", {"reverb", "Reverb effect"}},
        {"Chorus", {"chorus", "Chorus effect for thickening sound"}},
        {"Phaser", {"phaser", "Phaser modulation effect"}},
        {"Compressor", {"compressor", "Dynamic range compressor"}},
        {"Recorder", {"recorder", "Records audio to disk"}},
        {"Limiter", {"limiter", "Peak limiter"}},
        {"Noise Gate", {"gate", "Noise gate"}},
        {"Drive", {"drive", "Distortion/overdrive"}},
        {"Graphic EQ", {"graphic_eq", "Graphic equalizer"}},
        {"Waveshaper", {"waveshaper", "Waveshaping distortion"}},
        {"8-Band Shaper", {"8bandshaper", "8-band spectral shaper"}},
        {"Granulator", {"granulator", "Granular synthesis effect"}},
        {"Harmonic Shaper", {"harmonic_shaper", "Harmonic content shaper"}},
        {"Time/Pitch Shifter", {"timepitch", "Time stretching and pitch shifting"}},
        {"De-Crackle", {"de_crackle", "Removes clicks and pops"}},
        
        // Modulators
        {"LFO", {"lfo", "Low Frequency Oscillator for modulation"}},
        {"ADSR", {"adsr", "Attack Decay Sustain Release envelope"}},
        {"Random", {"random", "Random value generator"}},
        {"S&H", {"s_and_h", "Sample and Hold"}},
        {"Tempo Clock", {"tempo_clock", "Global clock with BPM control, transport (play/stop/reset), division, swing, and clock/gate outputs. Use External Takeover to drive the master transport."}},
        {"Function Generator", {"function_generator", "Custom function curves"}},
        {"Shaping Oscillator", {"shaping_oscillator", "Oscillator with waveshaping"}},
        
        // Utilities
        {"VCA", {"vca", "Voltage Controlled Amplifier"}},
        {"Mixer", {"mixer", "Audio/CV mixer"}},
        {"CV Mixer", {"cv_mixer", "CV signal mixer"}},
        {"Track Mixer", {"track_mixer", "Multi-track mixer with panning"}},
        {"Attenuverter", {"attenuverter", "Attenuate and invert signals"}},
        {"Reroute", {"reroute", "A polymorphic passthrough node. Pin color adapts to the input signal."}},
        {"Lag Processor", {"lag_processor", "Slew rate limiter/smoother"}},
        {"Math", {"math", "Mathematical operations"}},
        {"Map Range", {"map_range", "Map values from one range to another"}},
        {"Quantizer", {"quantizer", "Quantize CV to scales"}},
        {"Rate", {"rate", "Rate/frequency divider"}},
        {"Comparator", {"comparator", "Compare and threshold signals"}},
        {"Logic", {"logic", "Boolean logic operations"}},
        {"Clock Divider", {"clock_divider", "Clock division and multiplication"}},
        {"Sequential Switch", {"sequential_switch", "Sequential signal router"}},
        {"Comment", {"comment", "Text comment box"}},
        {"Best Practice", {"best_practice", "Best practice node template"}},
        {"Snapshot Sequencer", {"snapshot_sequencer", "Snapshot sequencer for parameter automation"}},
        {"Timeline", {"timeline", "Transport-synchronized automation recorder for CV, Gate, Trigger, and Raw signals"}},
        {"BPM Monitor", {"bpm_monitor", "Hybrid rhythm detection and BPM reporting from sequencers and audio inputs"}},
        
        // Analysis
        {"Scope", {"scope", "Oscilloscope display"}},
        {"Debug", {"debug", "Debug value display"}},
        {"Input Debug", {"input_debug", "Input signal debugger"}},
        {"Frequency Graph", {"frequency_graph", "Spectrum analyzer display"}}
    };
}

// Legacy function for backwards compatibility with tooltip display
std::vector<std::pair<juce::String, const char*>> ImGuiNodeEditorComponent::getModuleDescriptions()
{
    std::vector<std::pair<juce::String, const char*>> result;
    for (const auto& entry : getModuleRegistry())
    {
        // Return {internal type, description} for compatibility
        result.push_back({entry.second.first, entry.second.second});
    }
    return result;
}

// VST Plugin Support
void ImGuiNodeEditorComponent::addPluginModules()
{
    if (synth == nullptr)
        return;
    
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    auto& formatManager = app.getPluginFormatManager();
    
    // Set the plugin format manager and known plugin list on the synth if not already set
    synth->setPluginFormatManager(&formatManager);
    synth->setKnownPluginList(&knownPluginList);
    
    // Display each known plugin as a button
    const auto& plugins = knownPluginList.getTypes();
    
    if (plugins.isEmpty())
    {
        ImGui::TextDisabled("No plugins found.");
        ImGui::TextDisabled("Use 'Scan for Plugins...' in the File menu.");
        return;
    }
    
    for (const auto& desc : plugins)
    {
        juce::String buttonLabel = desc.name;
        if (desc.manufacturerName.isNotEmpty())
        {
            buttonLabel += " (" + desc.manufacturerName + ")";
        }
        
        if (ImGui::Selectable(buttonLabel.toRawUTF8()))
        {
            auto nodeId = synth->addVstModule(formatManager, desc);
            if (nodeId.uid != 0)
            {
                const ImVec2 mouse = ImGui::GetMousePos();
                const auto logicalId = synth->getLogicalIdForNode(nodeId);
                pendingNodeScreenPositions[(int)logicalId] = mouse;
                snapshotAfterEditor = true;
                juce::Logger::writeToLog("[VST] Added plugin: " + desc.name);
                // Close popup if we're in a popup context (safe to call even if not in popup)
                ImGui::CloseCurrentPopup();
            }
            else
            {
                juce::Logger::writeToLog("[VST] ERROR: Failed to add plugin: " + desc.name);
            }
        }
        
        // Show tooltip with plugin info on hover
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("Name: %s", desc.name.toRawUTF8());
            ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
            ImGui::Text("Version: %s", desc.version.toRawUTF8());
            ImGui::Text("Format: %s", desc.pluginFormatName.toRawUTF8());
            ImGui::Text("Type: %s", desc.isInstrument ? "Instrument" : "Effect");
            ImGui::Text("Inputs: %d", desc.numInputChannels);
            ImGui::Text("Outputs: %d", desc.numOutputChannels);
            ImGui::EndTooltip();
        }
    }
}
void ImGuiNodeEditorComponent::handleCollapseToMetaModule()
{
    if (!synth)
        return;
    
    juce::Logger::writeToLog("[Meta Module] Starting collapse operation...");
    
    // 1. Get selected nodes
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected < 2)
    {
        juce::Logger::writeToLog("[Meta Module] ERROR: Need at least 2 nodes selected");
        return;
    }
    
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());
    
    // Convert to logical IDs
    std::set<juce::uint32> selectedLogicalIds;
    for (int nodeId : selectedNodeIds)
    {
        selectedLogicalIds.insert((juce::uint32)nodeId);
    }
    
    juce::Logger::writeToLog("[Meta Module] Selected " + juce::String(numSelected) + " nodes");
    
    // 2. Analyze boundary connections
    struct BoundaryConnection
    {
        juce::uint32 externalLogicalId;
        int externalChannel;
        juce::uint32 internalLogicalId;
        int internalChannel;
        bool isInput; // true = external -> internal, false = internal -> external
    };
    std::vector<BoundaryConnection> boundaries;
    using InletKey = std::pair<juce::uint32, int>;
    using OutletKey = std::pair<juce::uint32, int>;
    struct InletInfo { juce::uint32 logicalId; int pinIndex; int channelCount; juce::uint32 externalLogicalId; int externalChannel; };
    struct OutletInfo { juce::uint32 logicalId; int pinIndex; int channelCount; juce::uint32 externalLogicalId; int externalChannel; bool externalIsOutput; };
    std::map<InletKey, InletInfo> inletInfoMap;
    std::map<OutletKey, OutletInfo> outletInfoMap;
    std::unordered_map<juce::uint32, InletInfo> inletInfoByLogical;
    std::unordered_map<juce::uint32, OutletInfo> outletInfoByLogical;
    int inletPinIndexCounter = 0;
    int outletPinIndexCounter = 0;
    auto allConnections = synth->getConnectionsInfo();
    for (const auto& conn : allConnections)
    {
        bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
        bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0 && !conn.dstIsOutput;
        bool dstIsOutput = conn.dstIsOutput;
        
        // Inlet: external -> selected
        if (!srcIsSelected && dstIsSelected)
        {
            BoundaryConnection bc;
            bc.externalLogicalId = conn.srcLogicalId;
            bc.externalChannel = conn.srcChan;
            bc.internalLogicalId = conn.dstLogicalId;
            bc.internalChannel = conn.dstChan;
            bc.isInput = true;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found inlet: " + juce::String(bc.externalLogicalId) + 
                                    " -> " + juce::String(bc.internalLogicalId));
        }
        // Outlet: selected -> external or output
        else if (srcIsSelected && (!dstIsSelected || dstIsOutput))
        {
            BoundaryConnection bc;
            bc.externalLogicalId = dstIsOutput ? 0 : conn.dstLogicalId;
            bc.externalChannel = conn.dstChan;
            bc.internalLogicalId = conn.srcLogicalId;
            bc.internalChannel = conn.srcChan;
            bc.isInput = false;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found outlet: " + juce::String(bc.internalLogicalId) + 
                                    " -> " + (dstIsOutput ? "OUTPUT" : juce::String(bc.externalLogicalId)));
        }
    }
    
    // Count inlets and outlets
    int numInlets = 0;
    int numOutlets = 0;
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            numInlets++;
        else
            numOutlets++;
    }
    
    juce::Logger::writeToLog("[META] Boundary Detection: Found " + juce::String(numInlets) + " inlets and " + juce::String(numOutlets) + " outlets.");
    juce::Logger::writeToLog("[META] Found " + juce::String(boundaries.size()) + " boundary connections");
    
    if (boundaries.empty())
    {
        juce::Logger::writeToLog("[META] WARNING: No boundary connections - creating isolated meta module");
    }
    
    // 3. Create the internal graph state
    pushSnapshot(); // Make undoable
    
    // Save the state of selected nodes
    juce::MemoryBlock internalState;
    {
        // Create a temporary state containing only selected nodes
        juce::ValueTree internalRoot("ModularSynthPreset");
        internalRoot.setProperty("version", 1, nullptr);
        
        juce::ValueTree modsVT("modules");
        juce::ValueTree connsVT("connections");
        
        // Add selected modules
        std::map<juce::uint32, juce::uint32> oldToNewLogicalId;
        juce::uint32 newLogicalId = 1;
        
        for (juce::uint32 oldId : selectedLogicalIds)
        {
            oldToNewLogicalId[oldId] = newLogicalId++;
            
            auto* module = synth->getModuleForLogical(oldId);
            if (!module)
                continue;
            
            juce::String moduleType = synth->getModuleTypeForLogical(oldId);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)oldToNewLogicalId[oldId], nullptr);
            mv.setProperty("type", moduleType, nullptr);
            
            // Save parameters
            juce::ValueTree params = module->getAPVTS().copyState();
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(params, -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            // Save extra state
            if (auto extra = module->getExtraStateTree(); extra.isValid())
            {
                juce::ValueTree extraWrapper("extra");
                extraWrapper.addChild(extra, -1, nullptr);
                mv.addChild(extraWrapper, -1, nullptr);
            }
            
            modsVT.addChild(mv, -1, nullptr);
        }
        
        auto createParameterState = [](const juce::String& paramId, int value)
        {
            juce::ValueTree params("Parameters");
            juce::ValueTree paramNode("Parameter");
            paramNode.setProperty("id", paramId, nullptr);
            paramNode.setProperty("value", (double)value, nullptr);
            params.addChild(paramNode, -1, nullptr);
            return params;
        };
        
        // Add inlet modules for each unique input
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
                continue;
            
            InletKey key { bc.externalLogicalId, bc.externalChannel };
            if (inletInfoMap.find(key) != inletInfoMap.end())
                continue;
            
            const juce::uint32 inletId = newLogicalId++;
            const int pinIndex = inletPinIndexCounter++;
            const int channelCount = 1;
            
            InletInfo info { inletId, pinIndex, channelCount, bc.externalLogicalId, bc.externalChannel };
            inletInfoMap[key] = info;
            inletInfoByLogical.emplace(inletId, info);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)inletId, nullptr);
            mv.setProperty("type", "inlet", nullptr);
            
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(createParameterState(InletModuleProcessor::paramIdChannelCount, channelCount), -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            juce::ValueTree extra("InletState");
            juce::String inletLabel;
            if (auto* srcModule = synth->getModuleForLogical(bc.externalLogicalId))
            {
                inletLabel = srcModule->getName();
                const juce::String channelLabel = srcModule->getAudioOutputLabel(bc.externalChannel);
                if (channelLabel.isNotEmpty())
                    inletLabel += " :: " + channelLabel;
                else
                    inletLabel += " :: Out " + juce::String(bc.externalChannel + 1);
            }
            else
            {
                inletLabel = "In " + juce::String(pinIndex + 1);
            }
            extra.setProperty("customLabel", inletLabel, nullptr);
            extra.setProperty("pinIndex", pinIndex, nullptr);
            extra.setProperty("externalLogicalId", (int)bc.externalLogicalId, nullptr);
            extra.setProperty("externalChannel", bc.externalChannel, nullptr);
            juce::ValueTree extraWrapper("extra");
            extraWrapper.addChild(extra, -1, nullptr);
            mv.addChild(extraWrapper, -1, nullptr);
            
            modsVT.addChild(mv, -1, nullptr);
            juce::Logger::writeToLog("[Meta Module] Created inlet node ID=" + juce::String(inletId));
        }
        
        // Add outlet modules for each unique output
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
                continue;
            
            OutletKey key { bc.internalLogicalId, bc.internalChannel };
            if (outletInfoMap.find(key) != outletInfoMap.end())
                continue;
            
            const juce::uint32 outletId = newLogicalId++;
            const int pinIndex = outletPinIndexCounter++;
            const int channelCount = 1;
            
            OutletInfo info { outletId, pinIndex, channelCount, bc.externalLogicalId, bc.externalChannel, bc.externalLogicalId == 0 };
            outletInfoMap[key] = info;
            outletInfoByLogical.emplace(outletId, info);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)outletId, nullptr);
            mv.setProperty("type", "outlet", nullptr);
            
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(createParameterState(OutletModuleProcessor::paramIdChannelCount, channelCount), -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            juce::ValueTree extra("OutletState");
            juce::String outletLabel;
            if (bc.externalLogicalId == 0)
            {
                outletLabel = "Main Output :: Ch " + juce::String(bc.externalChannel + 1);
            }
            else if (auto* dstModule = synth->getModuleForLogical(bc.externalLogicalId))
            {
                outletLabel = dstModule->getName();
                const juce::String channelLabel = dstModule->getAudioInputLabel(bc.externalChannel);
                if (channelLabel.isNotEmpty())
                    outletLabel += " :: " + channelLabel;
                else
                    outletLabel += " :: In " + juce::String(bc.externalChannel + 1);
            }
            else
            {
                outletLabel = "Out " + juce::String(pinIndex + 1);
            }
            extra.setProperty("customLabel", outletLabel, nullptr);
            extra.setProperty("pinIndex", pinIndex, nullptr);
            extra.setProperty("externalLogicalId", (int)bc.externalLogicalId, nullptr);
            extra.setProperty("externalChannel", bc.externalChannel, nullptr);
            extra.setProperty("externalIsOutput", bc.externalLogicalId == 0, nullptr);
            juce::ValueTree extraWrapper("extra");
            extraWrapper.addChild(extra, -1, nullptr);
            mv.addChild(extraWrapper, -1, nullptr);
            
            modsVT.addChild(mv, -1, nullptr);
            juce::Logger::writeToLog("[Meta Module] Created outlet node ID=" + juce::String(outletId));
        }
        
        // Add internal connections (between selected nodes)
        for (const auto& conn : allConnections)
        {
            bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
            bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0;
            
            if (srcIsSelected && dstIsSelected)
            {
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[conn.srcLogicalId], nullptr);
                cv.setProperty("srcChan", conn.srcChan, nullptr);
                cv.setProperty("dstId", (int)oldToNewLogicalId[conn.dstLogicalId], nullptr);
                cv.setProperty("dstChan", conn.dstChan, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from inlets to internal nodes
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                InletKey key { bc.externalLogicalId, bc.externalChannel };
                auto it = inletInfoMap.find(key);
                if (it == inletInfoMap.end())
                    continue;
                juce::uint32 inletId = it->second.logicalId;
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)inletId, nullptr);
                cv.setProperty("srcChan", 0, nullptr); // Inlets output on channel 0
                cv.setProperty("dstId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("dstChan", bc.internalChannel, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from internal nodes to outlets
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                OutletKey key { bc.internalLogicalId, bc.internalChannel };
                auto it = outletInfoMap.find(key);
                if (it == outletInfoMap.end())
                    continue;
                juce::uint32 outletId = it->second.logicalId;
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("srcChan", bc.internalChannel, nullptr);
                cv.setProperty("dstId", (int)outletId, nullptr);
                cv.setProperty("dstChan", 0, nullptr); // Outlets input on channel 0
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        internalRoot.addChild(modsVT, -1, nullptr);
        internalRoot.addChild(connsVT, -1, nullptr);
        
        // Serialize to memory block
        if (auto xml = internalRoot.createXml())
        {
            juce::MemoryOutputStream mos(internalState, false);
            xml->writeTo(mos);
            juce::Logger::writeToLog("[META] Generated state for sub-patch.");
        }
    }
    
    // 4. Calculate average position for the meta module
    ImVec2 avgPos(0.0f, 0.0f);
    int posCount = 0;
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos((int)logicalId);
        avgPos.x += pos.x;
        avgPos.y += pos.y;
        posCount++;
    }
    if (posCount > 0)
    {
        avgPos.x /= posCount;
        avgPos.y /= posCount;
    }
    
    // 5. Delete selected nodes
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        auto nodeId = synth->getNodeIdForLogical(logicalId);
        synth->removeModule(nodeId);
    }
    
    // 6. Create meta module
    auto metaNodeId = synth->addModule("meta_module");
    auto metaLogicalId = synth->getLogicalIdForNode(metaNodeId);
    pendingNodePositions[(int)metaLogicalId] = avgPos;
    
    juce::Logger::writeToLog("[META] Created new MetaModule with logical ID: " + juce::String((int)metaLogicalId));
    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule)
    {
        juce::ValueTree metaState("MetaModuleState");
        metaState.setProperty("label", "Meta Module", nullptr);

        if (internalState.getSize() > 0)
        {
            juce::MemoryOutputStream base64Stream;
            juce::Base64::convertToBase64(base64Stream, internalState.getData(), internalState.getSize());
            metaState.setProperty("internalGraphState", base64Stream.toString(), nullptr);
        }

        metaModule->setExtraStateTree(metaState);
        juce::Logger::writeToLog("[META] Loaded internal state into meta module");
    }
    else
    {
        juce::Logger::writeToLog("[META] ERROR: Failed to create meta module");
        return;
    }
    // 7. Reconnect external connections
    auto sortedInlets = metaModule->getInletNodes();
    std::sort(sortedInlets.begin(), sortedInlets.end(), [](auto* a, auto* b)
    {
        if (a->getPinIndex() != b->getPinIndex())
            return a->getPinIndex() < b->getPinIndex();
        return a->getLogicalId() < b->getLogicalId();
    });
    std::unordered_map<int, int> inletBaseChannels;
    std::unordered_map<int, int> inletChannelCounts;
    int runningInputChannel = 0;
    for (auto* inlet : sortedInlets)
    {
        const int pinIndex = inlet->getPinIndex();
        int channelCount = 1;
        if (auto* param = dynamic_cast<juce::AudioParameterInt*>(
                inlet->getAPVTS().getParameter(InletModuleProcessor::paramIdChannelCount)))
        {
            channelCount = juce::jmax(1, param->get());
        }
        if (auto logicalIt = inletInfoByLogical.find(inlet->getLogicalId()); logicalIt != inletInfoByLogical.end())
        {
            inlet->setExternalMapping(logicalIt->second.externalLogicalId, logicalIt->second.externalChannel);
        }
        inletBaseChannels[pinIndex] = runningInputChannel;
        inletChannelCounts[pinIndex] = channelCount;
        runningInputChannel += channelCount;
    }

    auto sortedOutlets = metaModule->getOutletNodes();
    std::sort(sortedOutlets.begin(), sortedOutlets.end(), [](auto* a, auto* b)
    {
        if (a->getPinIndex() != b->getPinIndex())
            return a->getPinIndex() < b->getPinIndex();
        return a->getLogicalId() < b->getLogicalId();
    });

    std::unordered_map<int, int> outletBaseChannels;
    std::unordered_map<int, int> outletChannelCounts;
    int runningOutputChannel = 0;
    for (auto* outlet : sortedOutlets)
    {
        const int pinIndex = outlet->getPinIndex();
        int channelCount = 1;
        if (auto* param = dynamic_cast<juce::AudioParameterInt*>(
                outlet->getAPVTS().getParameter(OutletModuleProcessor::paramIdChannelCount)))
        {
            channelCount = juce::jmax(1, param->get());
        }
        if (auto logicalIt = outletInfoByLogical.find(outlet->getLogicalId()); logicalIt != outletInfoByLogical.end())
        {
            outlet->setExternalMapping(logicalIt->second.externalLogicalId,
                                       logicalIt->second.externalChannel,
                                       logicalIt->second.externalIsOutput);
        }
        outletBaseChannels[pinIndex] = runningOutputChannel;
        outletChannelCounts[pinIndex] = channelCount;
        runningOutputChannel += channelCount;
    }

    // Connect unique external sources to meta inputs
    for (const auto& entry : inletInfoMap)
    {
        const InletKey& key = entry.first;
        const InletInfo& info = entry.second;

        auto extNodeId = synth->getNodeIdForLogical(key.first);
        if (extNodeId.uid == 0)
            continue;

        auto baseIt = inletBaseChannels.find(info.pinIndex);
        auto countIt = inletChannelCounts.find(info.pinIndex);
        if (baseIt == inletBaseChannels.end() || countIt == inletChannelCounts.end())
            continue;

        const int baseChannel = baseIt->second;
        const int channelCount = countIt->second;

        for (int ch = 0; ch < channelCount; ++ch)
        {
            synth->connect(extNodeId, key.second + ch, metaNodeId, baseChannel + ch);
        }
    }

    const auto outputNodeId = synth->getOutputNodeID();

    // Reconnect meta outputs to their original destinations
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            continue;

        OutletKey key { bc.internalLogicalId, bc.internalChannel };
        auto infoIt = outletInfoMap.find(key);
        if (infoIt == outletInfoMap.end())
            continue;

        const OutletInfo& info = infoIt->second;
        auto destNodeId = (bc.externalLogicalId == 0)
            ? outputNodeId
            : synth->getNodeIdForLogical(bc.externalLogicalId);

        if (destNodeId.uid == 0)
            continue;

        auto baseIt = outletBaseChannels.find(info.pinIndex);
        auto countIt = outletChannelCounts.find(info.pinIndex);
        if (baseIt == outletBaseChannels.end() || countIt == outletChannelCounts.end())
            continue;

        const int baseChannel = baseIt->second;
        const int channelCount = countIt->second;

        for (int ch = 0; ch < channelCount; ++ch)
        {
            synth->connect(metaNodeId, baseChannel + ch, destNodeId, bc.externalChannel + ch);
        }
    }
    
    graphNeedsRebuild = true;
    synth->commitChanges();
    
    juce::Logger::writeToLog("[META] Reconnected external cables. Collapse complete!");
    NotificationManager::post(NotificationManager::Type::Info, "Collapsed to Meta Module");
}

void ImGuiNodeEditorComponent::populateDragInsertSuggestions()
{
    dragInsertSuggestionsInputs.clear();
    dragInsertSuggestionsOutputs.clear();

    const auto& pinDb = getModulePinDatabase();

    auto addUnique = [](auto& mapRef, PinDataType type, const juce::String& moduleType)
    {
        auto& modules = mapRef[type];
        if (std::find(modules.begin(), modules.end(), moduleType) == modules.end())
            modules.push_back(moduleType);
    };

    auto addInputModule = [&](PinDataType type, const juce::String& moduleType)
    {
        addUnique(dragInsertSuggestionsInputs, type, moduleType);
    };

    auto addOutputModule = [&](PinDataType type, const juce::String& moduleType)
    {
        addUnique(dragInsertSuggestionsOutputs, type, moduleType);
    };

    // Seed curated utilities for fast access when connecting FROM outputs (needs inputs).
    addInputModule(PinDataType::Audio, "attenuverter");
    addInputModule(PinDataType::Audio, "comparator");
    addInputModule(PinDataType::Audio, "mixer");

    addInputModule(PinDataType::CV, "attenuverter");
    addInputModule(PinDataType::CV, "lag_processor");
    addInputModule(PinDataType::CV, "math");

    addInputModule(PinDataType::Gate, "comparator");
    addInputModule(PinDataType::Gate, "logic");
    addInputModule(PinDataType::Gate, "sequential_switch");

    addInputModule(PinDataType::Raw, "map_range");
    addInputModule(PinDataType::Raw, "scope");

    addInputModule(PinDataType::Video, "video_fx");
    addInputModule(PinDataType::Video, "crop_video");

    // Seed curated sources for fast access when connecting INTO inputs (needs outputs).
    addOutputModule(PinDataType::Audio, "vco");
    addOutputModule(PinDataType::Audio, "polyvco");
    addOutputModule(PinDataType::Audio, "noise");
    addOutputModule(PinDataType::Audio, "sample_loader");
    addOutputModule(PinDataType::Audio, "midi_player");

    addOutputModule(PinDataType::CV, "lfo");
    addOutputModule(PinDataType::CV, "adsr");
    addOutputModule(PinDataType::CV, "function_generator");
    addOutputModule(PinDataType::CV, "value");

    addOutputModule(PinDataType::Gate, "adsr");
    addOutputModule(PinDataType::Gate, "random");

    addOutputModule(PinDataType::Raw, "value");

    addOutputModule(PinDataType::Video, "webcam_loader");
    addOutputModule(PinDataType::Video, "video_file_loader");

    for (auto type : { PinDataType::Audio, PinDataType::CV, PinDataType::Gate, PinDataType::Raw, PinDataType::Video })
    {
        addInputModule(type, "reroute");
        addOutputModule(type, "reroute");
    }

    for (const auto& entry : pinDb)
    {
        const juce::String& moduleType = entry.first;
        const auto& info = entry.second;

        for (const auto& pin : info.audioIns)
            addInputModule(pin.type, moduleType);

        for (const auto& pin : info.modIns)
            addInputModule(pin.type, moduleType);

        for (const auto& pin : info.audioOuts)
            addOutputModule(pin.type, moduleType);
    }

    auto sortMapVectors = [](auto& mapRef)
    {
        for (auto& entry : mapRef)
        {
            auto& modules = entry.second;
            std::sort(modules.begin(), modules.end(),
                      [](const juce::String& a, const juce::String& b)
                      {
                          return a.compareIgnoreCase(b) < 0;
                      });
        }
    };

    sortMapVectors(dragInsertSuggestionsInputs);
    sortMapVectors(dragInsertSuggestionsOutputs);
}

const std::vector<juce::String>& ImGuiNodeEditorComponent::getDragInsertSuggestionsFor(const PinID& pin) const
{
    PinID localPin = pin;
    PinDataType type = localPin.isMod ? PinDataType::CV
                                      : const_cast<ImGuiNodeEditorComponent*>(this)->getPinDataTypeForPin(localPin);

    const auto& sourceMap = localPin.isInput ? dragInsertSuggestionsOutputs
                                             : dragInsertSuggestionsInputs;
    if (auto it = sourceMap.find(type); it != sourceMap.end())
        return it->second;

    static const std::vector<juce::String> empty;
    return empty;
}
void ImGuiNodeEditorComponent::insertNodeFromDragSelection(const juce::String& moduleType)
{
    if (synth == nullptr || dragInsertStartAttrId == -1)
        return;

    auto newNodeId = synth->addModule(moduleType);
    auto newLogicalId = synth->getLogicalIdForNode(newNodeId);

    pendingNodeScreenPositions[(int)newLogicalId] = dragInsertDropPos;

    const PinDataType primaryType = dragInsertStartPin.isMod
        ? PinDataType::CV
        : getPinDataTypeForPin(dragInsertStartPin);

    auto getSortedPinsForType = [&](juce::uint32 logicalId, bool isInput) -> std::vector<AudioPin>
    {
        std::vector<AudioPin> pins;

        if (logicalId == 0)
        {
            if (primaryType == PinDataType::Audio)
            {
                pins.emplace_back("Main L", 0, PinDataType::Audio);
                pins.emplace_back("Main R", 1, PinDataType::Audio);
            }
            return pins;
        }

        pins = getPinsOfType(logicalId, isInput, primaryType);
        std::sort(pins.begin(), pins.end(),
                  [](const AudioPin& a, const AudioPin& b)
                  {
                      return a.channel < b.channel;
                  });
        return pins;
    };

    auto findChannelIndex = [](const std::vector<AudioPin>& pins, int channel) -> int
    {
        for (int i = 0; i < (int)pins.size(); ++i)
        {
            if (pins[(size_t)i].channel == channel)
                return i;
        }
        return -1;
    };

    auto logNoCompatiblePins = [&](const char* role)
    {
        juce::Logger::writeToLog("[DragInsert] No compatible "
                                 + juce::String(toString(primaryType))
                                 + " " + juce::String(role)
                                 + " found for '" + moduleType + "', skipping auto-wire.");
    };

    bool connected = false;
    if (!dragInsertStartPin.isMod)
    {
        if (!dragInsertStartPin.isInput)
        {
            auto srcNodeId = synth->getNodeIdForLogical(dragInsertStartPin.logicalId);
            if (srcNodeId.uid != 0)
            {
                const auto sourcePins = getSortedPinsForType(dragInsertStartPin.logicalId, false);
                const auto targetPins = getSortedPinsForType((juce::uint32)newLogicalId, true);

        if (!sourcePins.empty() && !targetPins.empty())
        {
            if (primaryType == PinDataType::Audio)
            {
                std::vector<int> sourceChannels;
                sourceChannels.reserve(sourcePins.size());
                for (const auto& pin : sourcePins)
                    sourceChannels.push_back(pin.channel);
                if (sourceChannels.empty())
                    sourceChannels.push_back(dragInsertStartPin.channel);
                if (sourceChannels.size() > 2)
                    sourceChannels.resize(2);

                std::vector<int> targetChannels;
                targetChannels.reserve(targetPins.size());
                for (const auto& pin : targetPins)
                    targetChannels.push_back(pin.channel);
                if (targetChannels.size() > 2)
                    targetChannels.resize(2);

                std::set<std::pair<int,int>> madeConnections;
                auto connectAudioPair = [&](int srcChan, int dstChan)
                {
                    if (srcChan < 0 || dstChan < 0)
                        return;
                    std::pair<int,int> key{srcChan, dstChan};
                    if (madeConnections.insert(key).second)
                    {
                        synth->connect(srcNodeId, srcChan, newNodeId, dstChan);
                        connected = true;
                    }
                };

                if (!sourceChannels.empty() && !targetChannels.empty())
                {
                    const bool sourceStereo = sourceChannels.size() >= 2;
                    const bool targetStereo = targetChannels.size() >= 2;

                    if (!sourceStereo && targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                        connectAudioPair(sourceChannels[0], targetChannels[1]);
                    }
                    else if (sourceStereo && !targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                    }
                    else if (sourceStereo && targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                        connectAudioPair(sourceChannels[1], targetChannels[1]);
                    }
                    else
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                    }
                }
                if (!connected)
                    logNoCompatiblePins("input");
            }
            else
            {
                const int sourceIndex = juce::jmax(0, findChannelIndex(sourcePins, dragInsertStartPin.channel));
                const int targetIndex = juce::jlimit(0, (int)targetPins.size() - 1, sourceIndex);

                synth->connect(srcNodeId,
                               sourcePins[(size_t)sourceIndex].channel,
                               newNodeId,
                               targetPins[(size_t)targetIndex].channel);
                connected = true;
            }
        }
        else
        {
            logNoCompatiblePins("input");
        }
            }
        }
        else
        {
            auto dstNodeId = dragInsertStartPin.logicalId == 0
                             ? synth->getOutputNodeID()
                             : synth->getNodeIdForLogical(dragInsertStartPin.logicalId);
            if (dstNodeId.uid != 0)
            {
                const auto sourcePins = getSortedPinsForType((juce::uint32)newLogicalId, false);
                const auto destinationPins = getSortedPinsForType(dragInsertStartPin.logicalId, true);

                if (!sourcePins.empty() && !destinationPins.empty())
                {
                    const int destinationIndex = findChannelIndex(destinationPins, dragInsertStartPin.channel);
                    if (destinationIndex >= 0)
                    {
                        const int sourceIndex = juce::jlimit(0, (int)sourcePins.size() - 1, destinationIndex);

                        synth->connect(newNodeId,
                                       sourcePins[(size_t)sourceIndex].channel,
                                       dstNodeId,
                                       destinationPins[(size_t)destinationIndex].channel);
                        connected = true;

                        if (primaryType == PinDataType::Audio)
                        {
                            const int stereoSourceIndex = sourceIndex + 1;
                            const int stereoDestinationIndex = destinationIndex + 1;

                            if (stereoSourceIndex < (int)sourcePins.size() &&
                                stereoDestinationIndex < (int)destinationPins.size())
                            {
                                synth->connect(newNodeId,
                                               sourcePins[(size_t)stereoSourceIndex].channel,
                                               dstNodeId,
                                               destinationPins[(size_t)stereoDestinationIndex].channel);
                            }
                        }
                    }
                }
                else
                {
                    logNoCompatiblePins("output");
                }
            }
        }
    }

    synth->commitChanges();

    graphNeedsRebuild = true;
    pushSnapshot();

    juce::Logger::writeToLog("[DragInsert] Added '" + moduleType + "' (LID "
                             + juce::String((int)newLogicalId) + ")"
                             + (connected ? " and auto-wired input." : "."));

    dragInsertStartAttrId = -1;
    dragInsertStartPin = PinID{};
    shouldOpenDragInsertPopup = false;
}

void ImGuiNodeEditorComponent::loadPresetFromFile(const juce::File& file)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    // 1. Load the file content.
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);

    // 2. Set the synthesizer's state. This rebuilds the audio graph.
    synth->setStateInformation(mb.getData(), (int)mb.getSize());

    // 3. Parse the XML to find the UI state.
    juce::ValueTree uiState;
    if (auto xml = juce::XmlDocument::parse(mb.toString()))
    {
        auto vt = juce::ValueTree::fromXml(*xml);
        uiState = vt.getChildWithName("NodeEditorUI");
        if (uiState.isValid())
        {
            // 4. Apply the UI state (node positions, muted status, etc.).
            // This queues the changes to be applied on the next frame.
            applyUiValueTree(uiState);
        }
    }

    // 5. Create an undo snapshot for this action.
    Snapshot s;
    synth->getStateInformation(s.synthState);
    s.uiState = uiState.isValid() ? uiState : getUiValueTree();
    undoStack.push_back(std::move(s));
    redoStack.clear();

    // 5. Update the UI status trackers.
    isPatchDirty = false;
    currentPresetFile = file; // Store full file path
    
    // No notification here; the calling function will handle it.
}
void ImGuiNodeEditorComponent::mergePresetFromFile(const juce::File& file, ImVec2 dropPosition)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    auto xml = juce::XmlDocument::parse(file);
    if (xml == nullptr) return;

    juce::ValueTree preset = juce::ValueTree::fromXml(*xml);
    auto modulesVT = preset.getChildWithName("modules");
    auto connectionsVT = preset.getChildWithName("connections");
    auto uiVT = preset.getChildWithName("NodeEditorUI");

    if (!modulesVT.isValid()) return;

    pushSnapshot(); // Create an undo state before we start merging.

    // --- THIS IS THE NEW LOGIC ---
    // 1. Find the top-most Y coordinate of all existing nodes on the canvas.
    float topMostY = FLT_MAX;
    auto currentUiState = getUiValueTree();
    bool canvasHasNodes = false;
    for (int i = 0; i < currentUiState.getNumChildren(); ++i)
    {
        auto nodePosVT = currentUiState.getChild(i);
        if (nodePosVT.hasType("node"))
        {
            canvasHasNodes = true;
            float y = (float)nodePosVT.getProperty("y");
            if (y < topMostY)
            {
                topMostY = y;
            }
        }
    }
    // If the canvas is empty, use the drop position as the reference.
    if (!canvasHasNodes)
    {
        topMostY = dropPosition.y;
    }

    // 2. Find the bounding box of the nodes within the preset we are dropping.
    float presetMinX = FLT_MAX;
    float presetMaxY = -FLT_MAX;
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                float x = (float)nodePosVT.getProperty("x");
                float y = (float)nodePosVT.getProperty("y");
                if (x < presetMinX) presetMinX = x;
                if (y > presetMaxY) presetMaxY = y; // We need the lowest point (max Y) of the preset group.
            }
        }
    }
    
    // 3. Calculate the necessary offsets.
    const float verticalPadding = 100.0f;
    const float yOffset = topMostY - presetMaxY - verticalPadding;
    const float xOffset = dropPosition.x - presetMinX;
    // --- END OF NEW LOGIC ---

    // This map will track how we remap old IDs from the file to new, unique IDs on the canvas.
    std::map<juce::uint32, juce::uint32> oldIdToNewId;

    // First pass: create all the new modules from the preset.
    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleNode = modulesVT.getChild(i);
        if (moduleNode.hasType("module"))
        {
            juce::uint32 oldLogicalId = (juce::uint32)(int)moduleNode.getProperty("logicalId");
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Add the module without committing the graph changes yet.
            auto newNodeId = synth->addModule(type, false);
            juce::uint32 newLogicalId = synth->getLogicalIdForNode(newNodeId);

            oldIdToNewId[oldLogicalId] = newLogicalId; // Store the mapping

            // Restore the new module's parameters and extra state.
            if (auto* proc = synth->getModuleForLogical(newLogicalId))
            {
                auto paramsWrapper = moduleNode.getChildWithName("params");
                if (paramsWrapper.isValid()) proc->getAPVTS().replaceState(paramsWrapper.getChild(0));
                
                auto extraWrapper = moduleNode.getChildWithName("extra");
                if (extraWrapper.isValid()) proc->setExtraStateTree(extraWrapper.getChild(0));
            }
        }
    }

    // Second pass: recreate the internal connections between the new modules.
    if (connectionsVT.isValid())
    {
        for (int i = 0; i < connectionsVT.getNumChildren(); ++i)
        {
            auto connNode = connectionsVT.getChild(i);
            if (connNode.hasType("connection"))
            {
                juce::uint32 oldSrcId = (juce::uint32)(int)connNode.getProperty("srcId");
                int srcChan = (int)connNode.getProperty("srcChan");
                juce::uint32 oldDstId = (juce::uint32)(int)connNode.getProperty("dstId");
                int dstChan = (int)connNode.getProperty("dstChan");

                // Only connect if both source and destination are part of the preset we're merging.
                if (oldIdToNewId.count(oldSrcId) && oldIdToNewId.count(oldDstId))
                {
                    auto newSrcNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldSrcId]);
                    auto newDstNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldDstId]);
                    synth->connect(newSrcNodeId, srcChan, newDstNodeId, dstChan);
                }
            }
        }
    }
    
    // Third pass: Apply UI positions using our new calculated offsets.
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                juce::uint32 oldId = (juce::uint32)(int)nodePosVT.getProperty("id");
                if (oldIdToNewId.count(oldId)) // Check if it's one of our new nodes
                {
                    ImVec2 pos = ImVec2((float)nodePosVT.getProperty("x"), (float)nodePosVT.getProperty("y"));
                    
                    // Apply the smart offsets
                    ImVec2 newPos = ImVec2(pos.x + xOffset, pos.y + yOffset);
                    
                    pendingNodeScreenPositions[(int)oldIdToNewId[oldId]] = newPos;
                }
            }
        }
    }

    // Finally, commit all the changes to the audio graph at once.
    synth->commitChanges();
    isPatchDirty = true; // Mark the patch as edited.
    
    juce::Logger::writeToLog("[Preset] Successfully merged preset: " + file.getFullPathName() + 
                             " above existing nodes with offsets (" + juce::String(xOffset) + ", " + juce::String(yOffset) + ")");
}

================================================================================
FILE: USER_MANUAL\Nodes_Dictionary.md
================================================================================


# Collider Modular Synthesizer - Node Dictionary

**Last Updated:** December 18, 2024  
**Version:** 1.2

---

## Table of Contents

### Quick Reference Index

#### 1. SOURCE NODES
- [vco](#vco) - Voltage-Controlled Oscillator
- [polyvco](#polyvco) - Multi-Voice Oscillator Bank
- [noise](#noise) - Noise Generator
- [audio_input](#audio_input) - Hardware Audio Input
- [sample_loader](#sample_loader) - Audio Sample Player
- [value](#value) - Constant Value Generator

#### 2. EFFECT NODES
- [vcf](#vcf) - Voltage-Controlled Filter
- [delay](#delay) - Stereo Delay Effect
- [reverb](#reverb) - Stereo Reverb Effect
- [chorus](#chorus) - Stereo Chorus Effect
- [phaser](#phaser) - Stereo Phaser Effect
- [compressor](#compressor) - Dynamic Range Compressor
- [limiter](#limiter) - Audio Limiter
- [gate](#gate) - Noise Gate
- [drive](#drive) - Waveshaping Distortion
- [graphic_eq](#graphic_eq) - 8-Band Graphic Equalizer
- [waveshaper](#waveshaper) - Multi-Algorithm Waveshaper
- [8bandshaper](#8bandshaper) - Multi-Band Waveshaper
- [granulator](#granulator) - Granular Synthesizer/Effect
- [harmonic_shaper](#harmonic_shaper) - Harmonic Content Shaper
- [timepitch](#timepitch) - Time/Pitch Manipulation
- [de_crackle](#de_crackle) - Click/Pop Reducer
- [vocal_tract_filter](#vocal_tract_filter) - Formant Filter

#### 3. MODULATOR NODES
- [lfo](#lfo) - Low-Frequency Oscillator
- [adsr](#adsr) - Envelope Generator
- [random](#random) - Random Value Generator
- [s_and_h](#s_and_h) - Sample & Hold
- [function_generator](#function_generator) - Drawable Envelope/LFO
- [shaping_oscillator](#shaping_oscillator) - Oscillator with Built-in Waveshaper

#### 4. UTILITY & LOGIC NODES
- [vca](#vca) - Voltage-Controlled Amplifier
- [mixer](#mixer) - Stereo Audio Mixer
- [cv_mixer](#cv_mixer) - Control Voltage Mixer
- [track_mixer](#track_mixer) - Multi-Channel Mixer
- [attenuverter](#attenuverter) - Attenuate/Invert Signal
- [lag_processor](#lag_processor) - Slew Limiter/Smoother
- [math](#math) - Mathematical Operations
- [map_range](#map_range) - Value Range Mapper
- [quantizer](#quantizer) - Musical Scale Quantizer
- [rate](#rate) - Rate Value Converter
- [comparator](#comparator) - Threshold Comparator
- [logic](#logic) - Boolean Logic Operations
- [clock_divider](#clock_divider) - Clock Division/Multiplication
- [sequential_switch](#sequential_switch) - Signal Router

#### 5. SEQUENCER NODES
- [sequencer](#sequencer) - 16-Step CV/Gate Sequencer
- [multi_sequencer](#multi_sequencer) - Advanced Multi-Output Sequencer
- [snapshot_sequencer](#snapshot_sequencer) - Patch State Sequencer
- [stroke_sequencer](#stroke_sequencer) - Gesture-Based Sequencer
- [tempo_clock](#tempo_clock) - Global Clock Generator
- [timeline](#timeline) - Automation Recorder and Playback

#### 6. MIDI NODES
- [midi_cv](#midi_cv) - MIDI to CV Converter
- [midi_player](#midi_player) - MIDI File Player
- [midi_faders](#midi_faders) - MIDI-Learnable Faders (1-16)
- [midi_knobs](#midi_knobs) - MIDI-Learnable Knobs (1-16)
- [midi_buttons](#midi_buttons) - MIDI-Learnable Buttons (1-32)
- [midi_jog_wheel](#midi_jog_wheel) - MIDI Jog Wheel Control

#### 7. ANALYSIS NODES
- [scope](#scope) - Oscilloscope
- [debug](#debug) - Signal Value Logger
- [input_debug](#input_debug) - Passthrough Debug Logger
- [frequency_graph](#frequency_graph) - Spectrum Analyzer

#### 8. TTS (TEXT-TO-SPEECH) NODES
- [tts_performer](#tts_performer) - Text-to-Speech Engine
- [vocal_tract_filter](#vocal_tract_filter) - Formant Filter

#### 9. SPECIAL NODES
- [physics](#physics) - 2D Physics Simulation
- [animation](#animation) - 3D Animation Player

#### 10. COMPUTER VISION NODES
- [webcam_loader](#webcam_loader) - Webcam Video Source
- [video_file_loader](#video_file_loader) - Video File Source
- [movement_detector](#movement_detector) - Motion Detection
- [human_detector](#human_detector) - Face/Body Detection
- [object_detector](#object_detector) - Object Detection (YOLOv3)
- [pose_estimator](#pose_estimator) - Body Keypoint Detection
- [hand_tracker](#hand_tracker) - Hand Keypoint Tracking
- [face_tracker](#face_tracker) - Facial Landmark Tracking
- [color_tracker](#color_tracker) - Multi-Color Tracking
- [contour_detector](#contour_detector) - Shape Detection
- [semantic_segmentation](#semantic_segmentation) - Scene Segmentation
- [video_fx](#video_fx) - Real-Time Video Effects
- [crop_video](#crop_video) - Video Cropping and Tracking

#### 11. SYSTEM NODES
- [meta](#meta) - Meta Module Container
- [inlet](#inlet) - Meta Module Input
- [outlet](#outlet) - Meta Module Output
- [comment](#comment) - Documentation Node
- [recorder](#recorder) - Audio Recording to File
- [vst_host](#vst_host) - VST Plugin Host
- [bpm_monitor](#bpm_monitor) - Rhythm Detection and BPM Reporting

---

## 1. SOURCE NODES

Source nodes generate or input signals into your patch.

### vco
**Voltage-Controlled Oscillator**

A standard analog-style oscillator that generates periodic waveforms.

**Inputs:**
- `Frequency` (CV) - Frequency modulation input
- `Waveform` (CV) - Waveform selection modulation
- `Gate` (Gate) - Gate input for amplitude control

**Outputs:**
- `Out` (Audio) - Mono audio output

**Parameters:**
- `Frequency` (20 Hz - 20 kHz) - Base oscillator frequency
- `Waveform` (Choice) - Sine, Sawtooth, or Square wave
- `Relative Freq Mod` (Bool) - When enabled, CV modulates ¬±4 octaves around slider position. When disabled, CV directly maps to 20 Hz - 20 kHz
- `Portamento` (0-2 seconds) - Frequency glide/smoothing time

**How to Use:**
1. Connect the audio output to an effect or VCA
2. Set the frequency slider to your desired pitch
3. Optionally connect CV (from sequencer, LFO, or ADSR) to modulate frequency
4. Use the Relative Freq Mod toggle to choose between relative (musical) or absolute (full range) modulation
5. Connect a gate signal for amplitude gating if needed
6. Adjust portamento for smooth frequency transitions

---

### polyvco
**Multi-Voice Oscillator Bank**

A polyphonic oscillator module with up to 32 independent voices, ideal for creating rich, layered sounds or building polyphonic synthesizers.

**Inputs:**
- `Num Voices Mod` (Raw) - Control number of active voices (1-32)
- `Freq 1-32 Mod` (CV) - Individual frequency modulation for each voice
- `Wave 1-32 Mod` (CV) - Individual waveform modulation for each voice
- `Gate 1-32 Mod` (Gate) - Individual gate inputs for each voice

**Outputs:**
- `Out 1-32` (Audio) - 32 independent audio outputs (one per voice)

**Parameters:**
- `Num Voices` (1-32) - Number of active voices
- `Base Frequency` (20 Hz - 20 kHz) - Base frequency for all voices
- `Detune Amount` (0-100 cents) - Amount of random detuning between voices
- `Spread` (0-100%) - Frequency spread between voices
- `Waveform` (Choice) - Base waveform for all voices (Sine, Sawtooth, Square)

**How to Use:**
1. Set the number of voices you want active
2. Connect the voice outputs to a Track Mixer or individual effects
3. Use the detune parameter to create a chorus-like effect
4. Connect a Multi Sequencer's parallel outputs to the individual frequency and gate inputs for polyphonic melodies
5. Adjust spread to create harmonic stacks

---

### noise
**Noise Generator**

Generates white, pink, or brown noise for percussion, ambience, or modulation.

**Inputs:**
- `Level Mod` (CV) - Level modulation input
- `Colour Mod` (CV) - Noise color modulation

**Outputs:**
- `Out L` (Audio) - Left channel output
- `Out R` (Audio) - Right channel output

**Parameters:**
- `Colour` (Choice) - White (flat spectrum), Pink (-3 dB/octave), or Brown (-6 dB/octave)
- `Level dB` (-60 to +6 dB) - Output level in decibels

**How to Use:**
1. Select the noise color (white for hi-hats, pink for general noise, brown for low rumble)
2. Adjust the level to taste
3. Optionally modulate the color with CV for dynamic timbral changes
4. Great for percussion synthesis when combined with envelopes and filters
5. Use as a modulation source for subtle random variations

---

### audio_input
**Hardware Audio Input**

Brings external audio from your audio interface into the patch.

**Outputs:**
- `Out 1` (Audio) - Input channel 1
- `Out 2` (Audio) - Input channel 2
- `Gate` (Gate) - Gate signal when audio exceeds threshold
- `Trigger` (Gate) - Trigger signal on transients
- `EOP` (Gate) - End of phrase detection

**Parameters:**
- `Input Gain` (-60 to +20 dB) - Input gain control
- `Gate Threshold` (-60 to 0 dB) - Threshold for gate output
- `Trigger Sensitivity` (Low/Medium/High) - Transient detection sensitivity

**How to Use:**
1. Connect your external audio source (microphone, instrument, etc.) to your audio interface
2. Adjust input gain to get a healthy signal level
3. Use the gate and trigger outputs to create envelope followers or rhythm detection
4. Process the audio through effects or use it as a modulation source via envelope following

---

### sample_loader
**Audio Sample Player**

Loads and plays audio samples with extensive playback control and modulation options.

**Inputs:**
- `Pitch Mod` (CV) - Pitch modulation in semitones
- `Speed Mod` (CV) - Playback speed modulation
- `Gate Mod` (CV) - Gate/trigger modulation
- `Trigger Mod` (Gate) - Retrigger the sample
- `Range Start Mod` (CV) - Modulate sample start point
- `Range End Mod` (CV) - Modulate sample end point
- `Randomize Trig` (Gate) - Randomize sample settings on trigger

**Outputs:**
- `Out L` (Audio) - Left channel output
- `Out R` (Audio) - Right channel output

**Parameters:**
- `File` (Button) - Load audio file (WAV, AIFF, FLAC, MP3)
- `Pitch` (-48 to +48 semitones) - Pitch shift amount
- `Speed` (0.1x to 4x) - Playback speed multiplier
- `Loop Mode` (Choice) - Off, Forward, Ping-Pong
- `Gate Mode` (Choice) - Trigger (one-shot), Gate (held), Free (always play)
- `Range Start` (0-100%) - Sample start position
- `Range End` (0-100%) - Sample end position
- `Reverse` (Bool) - Play sample in reverse
- `Randomize Range` (Bool) - Randomize start/end on each trigger

**How to Use:**
1. Click the "Load File" button and select an audio file
2. Set the pitch and speed for your desired sound
3. Choose a loop mode (Off for one-shots, Forward for sustained sounds)
4. Use Gate Mode: Trigger for drums, Gate for sustained tones, Free for continuous playback
5. Adjust Range Start/End to isolate specific portions of the sample
6. Connect CV to Pitch Mod for melodic playing
7. Use Trigger Mod to retrigger the sample rhythmically
8. Enable Randomize Range for variation on each hit

---

### value
**Constant Value Generator**

Outputs a constant, adjustable numerical value in multiple formats.

**Outputs:**
- `Raw` (Raw) - Unprocessed value as-is
- `Normalized` (CV) - Value normalized to 0-1 range
- `Inverted` (Raw) - Negative of raw value
- `Integer` (Raw) - Truncated integer value
- `CV Out` (CV) - Scaled CV output (0-1 range)

**Parameters:**
- `Value` (-100 to +100) - The constant value to output

**How to Use:**
1. Adjust the value slider to your desired number
2. Connect the appropriate output to the destination:
   - Use `CV Out` for standard 0-1 modulation
   - Use `Raw` for custom ranges or mathematical operations with the Math node
   - Use `Integer` for step/index control
3. Great for setting static modulation amounts, offsets, or reference values
4. Combine multiple Value nodes with Math nodes for complex calculations

---

## 2. EFFECT NODES

Effect nodes process audio signals to shape tone, add space, or create sonic textures.

### vcf
**Voltage-Controlled Filter**

A resonant multi-mode filter for subtractive synthesis and tone shaping.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Cutoff Mod` (CV) - Cutoff frequency modulation
- `Resonance Mod` (CV) - Resonance amount modulation
- `Type Mod` (CV) - Filter type modulation

**Outputs:**
- `Out L` (Audio) - Left filtered output
- `Out R` (Audio) - Right filtered output

**Parameters:**
- `Cutoff` (20 Hz - 20 kHz) - Filter cutoff frequency
- `Resonance` (0.1 - 10.0) - Resonance/Q factor
- `Type` (Choice) - Low-pass, High-pass, or Band-pass
- `Relative Cutoff Mod` (Bool) - When enabled, CV modulates ¬±5 octaves around slider. When disabled, CV maps to full 20 Hz - 20 kHz range
- `Relative Resonance Mod` (Bool) - When enabled, CV scales resonance 0.25x-4x. When disabled, CV maps to full 0.1-10.0 range

**How to Use:**
1. Connect audio through the filter
2. Adjust cutoff to set the frequency where filtering occurs
3. Increase resonance for emphasis around the cutoff (be careful, high values can self-oscillate!)
4. Choose filter type: Low-pass removes highs, High-pass removes lows, Band-pass keeps only around cutoff
5. Modulate cutoff with envelopes or LFOs for classic synth sounds
6. Use Relative mode for musical modulation around a set position

---

### delay
**Stereo Delay Effect**

A stereo delay effect with modulation and tempo sync capabilities.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Time Mod` (CV) - Delay time modulation
- `Feedback Mod` (CV) - Feedback amount modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left delayed output
- `Out R` (Audio) - Right delayed output

**Parameters:**
- `Time (ms)` (1-2000 ms) - Delay time in milliseconds
- `Feedback` (0-0.95) - Amount of delayed signal fed back into the delay
- `Mix` (0-1) - Wet/dry balance (0=dry, 1=wet)
- `Relative Time Mod` (Bool) - Enable relative time modulation around slider position
- `Relative Feedback Mod` (Bool) - Enable relative feedback modulation
- `Relative Mix Mod` (Bool) - Enable relative mix modulation

**How to Use:**
1. Send audio through the delay
2. Set delay time to taste (short for slapback, long for echoes)
3. Adjust feedback for the number of repeats (be careful, high values can self-oscillate!)
4. Use mix to blend delayed signal with dry signal
5. Modulate time with LFOs for chorus-like effects
6. Connect to Tempo Clock's clock outputs and use short delay times for rhythmic effects

---

### reverb
**Stereo Reverb Effect**

A stereo reverb effect that simulates acoustic spaces.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Size Mod` (CV) - Room size modulation
- `Damp Mod` (CV) - Damping modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left reverb output
- `Out R` (Audio) - Right reverb output

**Parameters:**
- `Size` (0-1) - Room size (0=small, 1=large)
- `Damping` (0-1) - High frequency damping (0=bright, 1=dark)
- `Width` (0-1) - Stereo width
- `Mix` (0-1) - Wet/dry balance (0=dry, 1=wet)

**How to Use:**
1. Send audio through the reverb
2. Adjust size to set the perceived space (small room to large hall)
3. Use damping to control brightness (low damping=reflective surfaces, high damping=absorptive)
4. Adjust mix to blend reverb with dry signal
5. Great for adding depth and space to sounds
6. Use sparingly on bass-heavy sounds to avoid muddiness

---

### chorus
**Stereo Chorus Effect**

A stereo chorus effect that creates thick, shimmering textures by layering slightly detuned copies of the signal.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Rate Mod` (CV) - LFO rate modulation
- `Depth Mod` (CV) - Effect depth modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left chorus output
- `Out R` (Audio) - Right chorus output

**Parameters:**
- `Rate` (0.1-10 Hz) - LFO speed
- `Depth` (0-1) - Modulation depth
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Send audio through the chorus
2. Set rate for the speed of the sweeping effect (slow=gentle, fast=vibrato)
3. Adjust depth for intensity of detuning
4. Use mix to blend with dry signal
5. Great for thickening synth pads and leads
6. Use on clean guitars for classic 80s sounds

---

### phaser
**Stereo Phaser Effect**

A stereo phaser effect that creates sweeping notches in the frequency spectrum.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Rate Mod` (CV) - LFO rate modulation
- `Depth Mod` (CV) - Effect depth modulation
- `Centre Mod` (CV) - Center frequency modulation
- `Feedback Mod` (CV) - Feedback amount modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left phaser output
- `Out R` (Audio) - Right phaser output

**Parameters:**
- `Rate` (0.1-10 Hz) - LFO speed
- `Depth` (0-1) - Modulation depth
- `Centre Freq` (200-2000 Hz) - Center frequency of the sweep
- `Feedback` (0-0.95) - Amount of feedback (increases resonance)
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Send audio through the phaser
2. Adjust rate for sweep speed (slow=subtle, fast=intense)
3. Set centre frequency to target specific frequency ranges
4. Increase feedback for more pronounced notches
5. Great for adding movement to static sounds
6. Classic effect for electric pianos and guitars

---

### compressor
**Dynamic Range Compressor**

Reduces the dynamic range of audio signals, making quiet parts louder and loud parts quieter.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Thresh Mod` (CV) - Threshold modulation
- `Ratio Mod` (CV) - Ratio modulation
- `Attack Mod` (CV) - Attack time modulation
- `Release Mod` (CV) - Release time modulation
- `Makeup Mod` (CV) - Makeup gain modulation

**Outputs:**
- `Out L` (Audio) - Left compressed output
- `Out R` (Audio) - Right compressed output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Level above which compression starts
- `Ratio` (1:1 to 20:1) - Amount of compression
- `Attack` (0.1-100 ms) - How quickly compression engages
- `Release` (10-1000 ms) - How quickly compression disengages
- `Makeup Gain` (0-24 dB) - Output gain to compensate for level reduction

**How to Use:**
1. Set threshold to the level where you want compression to start
2. Adjust ratio (2:1 for gentle, 10:1+ for heavy compression)
3. Use fast attack to catch transients, slow attack to preserve punch
4. Set release to taste (fast for pumping effects, slow for smooth)
5. Adjust makeup gain to match the output level to the input
6. Great for controlling dynamics, adding sustain, and gluing mixes together

---

### limiter
**Audio Limiter**

Prevents audio from exceeding a set level, acting as a "brick wall" for peaks.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Thresh Mod` (CV) - Threshold modulation
- `Release Mod` (CV) - Release time modulation

**Outputs:**
- `Out L` (Audio) - Left limited output
- `Out R` (Audio) - Right limited output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Maximum allowed level
- `Release` (10-1000 ms) - Recovery time

**How to Use:**
1. Set threshold to the maximum level you want to allow
2. Adjust release time (fast for transparent, slow for smoother)
3. Use at the end of your signal chain to prevent clipping
4. Essential for mastering and protecting speakers
5. Can add punch and loudness when used aggressively

---

### gate
**Noise Gate**

Silences signals below a threshold, useful for removing background noise or creating rhythmic effects.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left gated output
- `Out R` (Audio) - Right gated output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Level below which the gate closes
- `Attack` (0.1-100 ms) - How quickly the gate opens
- `Release` (10-1000 ms) - How quickly the gate closes
- `Range` (-60 to 0 dB) - Amount of attenuation when gate is closed

**How to Use:**
1. Set threshold just above your noise floor
2. Adjust attack and release for smooth or rhythmic gating
3. Use range to set how much the signal is reduced (not necessarily to silence)
4. Great for cleaning up noisy recordings
5. Use creatively with short releases for rhythmic chopping effects

---

### drive
**Waveshaping Distortion**

A waveshaping distortion effect that adds harmonic content and saturation.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left distorted output
- `Out R` (Audio) - Right distorted output

**Parameters:**
- `Drive` (0-100) - Amount of distortion
- `Type` (Choice) - Distortion algorithm (Soft clip, Hard clip, Foldback, etc.)
- `Output Gain` (-12 to +12 dB) - Output level compensation

**How to Use:**
1. Start with low drive and gradually increase
2. Try different distortion types for various tonal characters
3. Adjust output gain to compensate for level changes
4. Great for adding grit and harmonic richness
5. Use before or after filters for different tonal results

---

### graphic_eq
**8-Band Graphic Equalizer**

An 8-band graphic equalizer with CV outputs for frequency-based triggering.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Band 1-8 Mod` (CV) - Individual band gain modulation
- `Gate Thresh Mod` (CV) - Gate threshold modulation
- `Trig Thresh Mod` (CV) - Trigger threshold modulation

**Outputs:**
- `Out L` (Audio) - Left EQ output
- `Out R` (Audio) - Right EQ output
- `Gate Out` (Gate) - Gates when signal exceeds gate threshold
- `Trig Out` (Gate) - Triggers on transients above trigger threshold

**Parameters:**
- `Gain Band 1-8` (-60 to +12 dB) - Gain for each frequency band (centered at: 60, 170, 310, 600, 1000, 3000, 6000, 12000 Hz)
- `Output Level` (-24 to +24 dB) - Overall output level
- `Gate Threshold` (-60 to 0 dB) - Threshold for gate output
- `Trigger Threshold` (-60 to 0 dB) - Threshold for trigger detection

**How to Use:**
1. Boost or cut specific frequency bands to shape your sound
2. Use negative gain to remove unwanted frequencies
3. Use the gate and trigger outputs for frequency-responsive triggering (great for kick/bass triggering)
4. Combine with other modules for frequency-dependent effects

---

### waveshaper
**Multi-Algorithm Waveshaper**

A distortion effect with multiple waveshaping algorithms for varied saturation and distortion effects.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Drive Mod` (CV) - Drive amount modulation
- `Type Mod` (CV) - Algorithm selection modulation

**Outputs:**
- `Out L` (Audio) - Left waveshaped output
- `Out R` (Audio) - Right waveshaped output

**Parameters:**
- `Drive` (0-100) - Amount of waveshaping
- `Type` (Choice) - Waveshaping algorithm (Soft Clip, Hard Clip, Foldback, etc.)
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Choose a waveshaping algorithm
2. Gradually increase drive to add saturation
3. Try different algorithms for different characters
4. Use mix to blend with the dry signal

---

### 8bandshaper
**Multi-Band Waveshaper**

A multi-band waveshaper that applies frequency-specific distortion across 8 bands.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Drive 1-8 Mod` (CV) - Per-band drive modulation
- `Gain Mod` (CV) - Output gain modulation

**Outputs:**
- `Out L` (Audio) - Left processed output
- `Out R` (Audio) - Right processed output

**Parameters:**
- `Drive Band 1-8` (0-10) - Drive amount for each frequency band
- `Output Gain` (-24 to +24 dB) - Overall output level

**How to Use:**
1. Adjust individual band drives to add selective distortion
2. Drive bass frequencies differently than highs for balanced distortion
3. Great for adding harmonics to specific frequency ranges
4. Use sparingly for subtle enhancement or aggressively for heavy distortion

---

### granulator
**Granular Synthesizer/Effect**

A granular processor that plays small grains of audio for textural and rhythmic effects.

**Inputs:**
- `In L` (Audio) - Left audio input (recorded to internal buffer)
- `In R` (Audio) - Right audio input (recorded to internal buffer)
- `Trigger In` (Gate) - Manual grain triggering
- `Density Mod` (CV) - Grain density modulation
- `Size Mod` (CV) - Grain size modulation
- `Position Mod` (CV) - Playback position modulation
- `Pitch Mod` (CV) - Pitch modulation
- `Gate Mod` (CV) - Gate amount modulation

**Outputs:**
- `Out L` (Audio) - Left granulated output
- `Out R` (Audio) - Right granulated output

**Parameters:**
- `Density` (0.1-100 Hz) - How often grains are triggered
- `Size` (5-500 ms) - Length of each grain
- `Position` (0-1) - Where in the buffer to read grains
- `Spread` (0-1) - Random variation in grain position
- `Pitch` (-24 to +24 semitones) - Pitch shift of grains
- `Pitch Random` (0-12 semitones) - Random pitch variation per grain
- `Pan Random` (0-1) - Random stereo placement per grain
- `Gate` (0-1) - Overall output level/gate

**How to Use:**
1. Audio is continuously recorded to a 2-second buffer
2. Adjust density for grain triggering rate (low=sparse, high=dense cloud)
3. Set grain size (small=rhythmic, large=smooth textures)
4. Use position to read from different parts of the buffer
5. Add spread for more random, evolving textures
6. Modulate position with LFOs for scanning effects
7. Great for creating ambient textures from any sound source

---

### harmonic_shaper
**Harmonic Content Shaper**

Shapes the harmonic content of a signal using frequency-specific waveshaping.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Freq Mod` (CV) - Frequency modulation
- `Drive Mod` (CV) - Drive modulation

**Outputs:**
- `Out L` (Audio) - Left shaped output
- `Out R` (Audio) - Right shaped output

**Parameters:**
- `Master Frequency` (20 Hz - 20 kHz) - Center frequency for harmonic shaping
- `Master Drive` (0-10) - Amount of harmonic emphasis

**How to Use:**
1. Set the master frequency to target specific harmonics
2. Increase drive to emphasize those harmonics
3. Great for adding presence and character to sounds
4. Use on bass for sub-harmonic generation

---

### timepitch
**Time/Pitch Manipulation**

Real-time pitch and time manipulation using the RubberBand library for high-quality time stretching and pitch shifting.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Speed Mod` (CV) - Playback speed modulation
- `Pitch Mod` (CV) - Pitch shift modulation

**Outputs:**
- `Out L` (Audio) - Left processed output
- `Out R` (Audio) - Right processed output

**Parameters:**
- `Speed` (0.25x to 4x) - Playback speed without affecting pitch
- `Pitch` (-24 to +24 semitones) - Pitch shift without affecting tempo
- `Formant` (Bool) - Preserve formants when pitch shifting

**How to Use:**
1. Adjust speed to time-stretch audio (0.5x=half speed, 2x=double speed)
2. Adjust pitch to transpose audio independently
3. Enable formant preservation for natural-sounding vocal pitch shifts
4. Great for creative effects and sound design

---

### de_crackle
**Click/Pop Reducer**

A utility to reduce clicks and pops caused by discontinuous CV or audio signals.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left de-clicked output
- `Out R` (Audio) - Right de-clicked output

**Parameters:**
- `Sensitivity` (Low/Medium/High) - How aggressively to detect and reduce clicks

**How to Use:**
1. Insert after modules that produce discontinuous signals
2. Adjust sensitivity based on the severity of clicks
3. Essential for smoothing abrupt parameter changes
4. Use on CV signals as well as audio

---

## 3. MODULATOR NODES

Modulator nodes generate control voltages for animating parameters over time.

### lfo
**Low-Frequency Oscillator**

A versatile LFO for modulating parameters with periodic waveforms.

**Inputs:**
- `Rate Mod` (CV) - Rate modulation input
- `Depth Mod` (CV) - Depth modulation input
- `Wave Mod` (CV) - Waveform selection modulation

**Outputs:**
- `Out` (CV) - CV modulation output

**Parameters:**
- `Rate` (0.05-20 Hz) - LFO frequency
- `Depth` (0-1) - Modulation amount
- `Bipolar` (Bool) - Output range: On = -1 to +1, Off = 0 to 1
- `Wave` (Choice) - Sine, Triangle, or Sawtooth
- `Sync` (Bool) - Sync to global tempo
- `Division` (Choice) - Note division when synced (1/32 to 8 bars)
- `Relative Mod` (Bool) - When enabled, rate CV is additive around slider position

**How to Use:**
1. Set rate to desired modulation speed
2. Choose bipolar for modulation around a center point, unipolar for one-directional
3. Select waveform based on desired modulation shape
4. Enable Sync and set Division for tempo-locked modulation
5. Connect output to any CV modulation input
6. Use multiple LFOs at different rates for complex modulation

---

### adsr
**Attack-Decay-Sustain-Release Envelope Generator**

A classic ADSR envelope generator for shaping sounds over time.

**Inputs:**
- `Gate In` (Gate) - Gate signal to trigger and hold envelope
- `Trigger In` (Gate) - Trigger signal to retrigger envelope
- `Attack Mod` (CV) - Attack time modulation
- `Decay Mod` (CV) - Decay time modulation
- `Sustain Mod` (CV) - Sustain level modulation
- `Release Mod` (CV) - Release time modulation

**Outputs:**
- `Env Out` (CV) - Main envelope output (0-1)
- `Inv Out` (CV) - Inverted envelope output (1-0)
- `EOR Gate` (Gate) - End of Release gate
- `EOC Gate` (Gate) - End of Cycle gate

**Parameters:**
- `Attack` (0.001-5 seconds) - Rise time from 0 to 1
- `Decay` (0.001-5 seconds) - Fall time from 1 to sustain level
- `Sustain` (0-1) - Held level while gate is high
- `Release` (0.001-5 seconds) - Fall time from sustain to 0 after gate goes low
- `Relative Attack/Decay/Sustain/Release Mod` (Bool) - Enable relative modulation modes

**How to Use:**
1. Connect a gate source (sequencer, MIDI CV, etc.) to Gate In
2. Adjust Attack for how quickly sound reaches full volume
3. Set Decay for how quickly it falls to the sustain level
4. Sustain sets the held level while key/gate is pressed
5. Release controls fade-out time after gate is released
6. Connect Env Out to VCA gain for amplitude shaping
7. Use Inv Out for inverted modulation
8. EOR and EOC gates useful for triggering events at envelope completion

---

### random
**Random Value Generator**

Generates random values at a specified rate with multiple output formats and tempo sync.

**Outputs:**
- `Norm Out` (CV) - Normalized random values (0-1 range)
- `Raw Out` (Raw) - Raw random values (custom range)
- `CV Out` (CV) - CV random values (custom CV range)
- `Bool Out` (Gate) - Random boolean (on/off)
- `Trig Out` (Gate) - Trigger pulse on each new random value

**Parameters:**
- `Rate` (0.1-50 Hz) - How often new random values are generated
- `Min` (-100 to 100) - Minimum value for Raw output
- `Max` (-100 to 100) - Maximum value for Raw output
- `CV Min` (0-1) - Minimum value for CV output
- `CV Max` (0-1) - Maximum value for CV output
- `Norm Min` (0-1) - Minimum value for Norm output
- `Norm Max` (0-1) - Maximum value for Norm output
- `Slew` (0-1) - Smoothing between random values
- `Trig Threshold` (0-1) - Threshold for Bool output
- `Sync` (Bool) - Sync to global tempo
- `Division` (Choice) - Note division when synced

**How to Use:**
1. Set rate for how often random values change
2. Adjust min/max ranges for each output type as needed
3. Use slew to smooth transitions between random values (0=stepped, 1=smooth)
4. Connect different outputs for different modulation needs
5. Use Bool Out for random gates/triggers
6. Enable sync for tempo-locked randomness
7. Great for adding unpredictability and variation to patches

---

### s_and_h
**Sample & Hold**

Samples and holds an input signal when triggered.

**Inputs:**
- `Signal In L` (Audio) - Left signal to sample
- `Signal In R` (Audio) - Right signal to sample
- `Trig In L` (Gate) - Trigger for left channel
- `Trig In R` (Gate) - Trigger for right channel
- `Threshold Mod` (CV) - Trigger threshold modulation
- `Edge Mod` (CV) - Trigger edge selection modulation
- `Slew Mod` (CV) - Slew limiting modulation

**Outputs:**
- `Out L` (Audio) - Left sampled & held output
- `Out R` (Audio) - Right sampled & held output

**Parameters:**
- `Threshold` (0-1) - Trigger threshold level
- `Edge` (Choice) - Rising, Falling, or Both edges
- `Slew` (0-1) - Slew limiting between sampled values

**How to Use:**
1. Connect a signal to sample (CV, audio, etc.)
2. Connect a trigger source (LFO, clock, gate)
3. Each trigger samples the current input value and holds it
4. Adjust threshold if using audio-rate triggers
5. Use slew to smooth transitions between held values
6. Classic for creating stepped random modulation (LFO ‚Üí S&H ‚Üí destination)

---

### function_generator
**Drawable Envelope/LFO Generator**

A complex, drawable envelope and LFO generator with multiple curve slots and extensive modulation options.

**Inputs:**
- `Gate In` (Gate) - Gate input for envelope triggering
- `Trigger In` (Gate) - Trigger input for envelope
- `Sync In` (Gate) - Sync input for phase reset
- `Rate Mod` (CV) - Rate modulation
- `Slew Mod` (CV) - Slew limiting modulation
- `Gate Thresh Mod` (CV) - Gate threshold modulation
- `Trig Thresh Mod` (CV) - Trigger threshold modulation
- `Pitch Base Mod` (CV) - Pitch base modulation
- `Value Mult Mod` (CV) - Value multiplier modulation
- `Curve Select Mod` (CV) - Curve selection modulation

**Outputs:**
- `Value` (CV) - Main output value
- `Inverted` (CV) - Inverted output
- `Bipolar` (CV) - Bipolar output (-1 to +1)
- `Pitch` (CV) - Pitch CV output (V/Oct)
- `Gate` (Gate) - Gate output based on threshold
- `Trigger` (Gate) - Trigger output
- `End of Cycle` (Gate) - Trigger at cycle end
- `Blue/Red/Green Value` (CV) - Per-curve outputs
- `Blue/Red/Green Pitch` (CV) - Per-curve pitch outputs

**Parameters:**
- `Rate` (0.05-20 Hz) - Cycle speed
- `Slew` (0-1) - Smoothing between points
- `Gate Threshold` (0-1) - Threshold for gate output
- `Trig Threshold` (0-1) - Threshold for trigger output
- `Pitch Base` (-4 to +4 octaves) - Base pitch offset
- `Value Mult` (0-10) - Value scaling multiplier
- `Curve Select` (0-2) - Choose active curve (Blue, Red, or Green)
- Drawing Interface - Click and drag to draw curves

**How to Use:**
1. Click "Draw" to enter drawing mode
2. Draw up to 3 different curves (Blue, Red, Green tabs)
3. Set rate for cycle speed
4. Use as LFO (free-running) or envelope (gate-triggered)
5. Adjust slew for smooth or stepped transitions
6. Multiple outputs allow simultaneous different modulations
7. Per-curve outputs let you route different curves to different destinations
8. Extremely versatile for complex modulation shapes

---

### shaping_oscillator
**Oscillator with Built-in Waveshaper**

An oscillator with integrated waveshaping for generating harmonically rich tones.

**Inputs:**
- `In L` (Audio) - External audio input (optional, can shape external audio)
- `In R` (Audio) - External audio input right channel
- `Freq Mod` (CV) - Frequency modulation
- `Wave Mod` (CV) - Waveform modulation
- `Drive Mod` (CV) - Drive modulation

**Outputs:**
- `Out` (Audio) - Shaped oscillator output

**Parameters:**
- `Frequency` (20 Hz - 20 kHz) - Oscillator frequency
- `Waveform` (Choice) - Base waveform
- `Drive` (0-10) - Waveshaping amount

**How to Use:**
1. Set frequency for desired pitch
2. Choose base waveform
3. Increase drive to add harmonics via waveshaping
4. Can also process external audio through the shaper
5. Great for thick, harmonically rich tones

---

## 4. UTILITY & LOGIC NODES

Utility nodes provide essential signal processing, routing, and logic operations.

### vca
**Voltage-Controlled Amplifier**

A basic amp module for controlling audio levels with CV.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Gain Mod` (CV) - Gain modulation

**Outputs:**
- `Out L` (Audio) - Left amplified output
- `Out R` (Audio) - Right amplified output

**Parameters:**
- `Gain` (-60 to +12 dB) - Base gain level

**How to Use:**
1. Send audio through the VCA
2. Connect an envelope or LFO to Gain Mod for amplitude control
3. Essential for creating dynamic amplitude envelopes
4. The core of any subtractive synthesis voice

---

### mixer
**Stereo Audio Mixer**

A two-input stereo mixer with gain, pan, and crossfade controls.

**Inputs:**
- `In A L/R` (Audio) - Input A stereo pair
- `In B L/R` (Audio) - Input B stereo pair
- `Gain Mod` (CV) - Gain modulation
- `Pan Mod` (CV) - Pan modulation
- `X-Fade Mod` (CV) - Crossfade modulation

**Outputs:**
- `Out L/R` (Audio) - Mixed stereo output

**Parameters:**
- `Gain` (-60 to +12 dB) - Overall output gain
- `Pan` (-1 to +1) - Stereo panning
- `Crossfade` (0-1) - Blend between input A (0) and input B (1)

**How to Use:**
1. Connect two stereo sources
2. Use crossfade to blend between them
3. Adjust gain and pan for final mix
4. Modulate crossfade with LFOs or envelopes for dynamic mixing

---

### cv_mixer
**Control Voltage Mixer**

A mixer specifically designed for mixing CV signals.

**Inputs:**
- `In A/B` (CV) - CV inputs
- `Gain Mod` (CV) - Gain modulation

**Outputs:**
- `Out` (CV) - Mixed CV output

**Parameters:**
- `Gain A/B` (-2 to +2) - Gain for each input

**How to Use:**
1. Mix multiple CV sources together
2. Use negative gain to invert signals
3. Create complex modulation by combining LFOs and envelopes
4. Essential for additive CV processing

---

### track_mixer
**Multi-Channel Mixer**

A mixer for up to 8 monophonic tracks with individual gain and pan controls.

**Inputs:**
- `In 1-8` (Audio) - 8 mono audio inputs
- `Num Tracks Mod` (Raw) - Number of active tracks modulation
- `Gain 1-8 Mod` (CV) - Per-track gain modulation
- `Pan 1-8 Mod` (CV) - Per-track pan modulation

**Outputs:**
- `Out L/R` (Audio) - Stereo mixed output

**Parameters:**
- `Num Tracks` (1-8) - Number of active tracks
- `Gain 1-8` (-60 to +12 dB) - Per-track gain
- `Pan 1-8` (-1 to +1) - Per-track stereo panning

**How to Use:**
1. Connect multiple mono sources (great with PolyVCO outputs)
2. Adjust per-track gain and pan
3. Set Num Tracks to control how many inputs are active
4. Perfect for mixing polyphonic voices

---

### attenuverter
**Attenuate/Invert Signal**

Attenuates (reduces) and/or inverts CV or audio signals.

**Inputs:**
- `In L/R` (Audio) - Stereo inputs
- `Amount Mod` (CV) - Amount modulation

**Outputs:**
- `Out L/R` (Audio) - Processed outputs

**Parameters:**
- `Amount` (-1 to +1) - Attenuation/inversion amount (0=silent, 0.5=half, 1=full, negative=inverted)

**How to Use:**
1. Use positive values (0-1) to reduce signal levels
2. Use negative values (-1-0) to invert and reduce
3. Set to 0 for silence
4. Essential for scaling modulation amounts
5. Use to create inverted versions of CV for opposite modulation

---

### lag_processor
**Slew Limiter/Smoother**

Smooths abrupt changes in signals using independent rise and fall times.

**Inputs:**
- `Signal In` (CV) - CV input to smooth
- `Rise Mod` (CV) - Rise time modulation
- `Fall Mod` (CV) - Fall time modulation

**Outputs:**
- `Smoothed Out` (CV) - Smoothed CV output

**Parameters:**
- `Rise Time` (0.1-1000 ms) - Time to reach rising values
- `Fall Time` (0.1-1000 ms) - Time to reach falling values

**How to Use:**
1. Insert between a CV source and destination to smooth transitions
2. Use equal rise/fall times for symmetrical smoothing
3. Use different rise/fall for attack/release character
4. Great for portamento effects and smoothing stepped sequences
5. Can turn hard gates into smooth envelopes

---

### math
**Mathematical Operations**

Performs mathematical operations on two input signals.

**Inputs:**
- `In A` (CV) - First operand
- `In B` (CV) - Second operand

**Outputs:**
- `Add` (CV) - A + B
- `Subtract` (CV) - A - B
- `Multiply` (CV) - A √ó B
- `Divide` (CV) - A √∑ B

**Parameters:**
- `Value A` (-100 to 100) - Default value for A (used if not patched)
- `Value B` (-100 to 100) - Default value for B (used if not patched)
- `Operation` (Choice) - Add, Subtract, Multiply, Divide, Min, Max, Power, Sqrt(A), Sin(A), Cos(A), Tan(A), Abs(A), Modulo, Fract(A), Int(A), A>B, A<B

**How to Use:**
1. Connect CV sources or use internal values
2. Choose operation
3. Use outputs for complex CV processing
4. Create custom modulation shapes by combining operations
5. Use comparison operations (A>B, A<B) for logic

---

### map_range
**Value Range Mapper**

Remaps values from one range to another.

**Inputs:**
- `Raw In` (Raw) - Input value to remap

**Outputs:**
- `CV Out` (CV) - Remapped to 0-1 range
- `Audio Out` (Audio) - Remapped to audio-rate

**Parameters:**
- `Min In` (-1000 to 1000) - Input range minimum
- `Max In` (-1000 to 1000) - Input range maximum
- `Min Out` (-1000 to 1000) - Output range minimum
- `Max Out` (-1000 to 1000) - Output range maximum

**How to Use:**
1. Define your input range (min/max in)
2. Define your desired output range (min/max out)
3. Connect input signal
4. Output is linearly scaled to new range
5. Great for converting between different parameter ranges

---

### quantizer
**Musical Scale Quantizer**

Snaps continuous CV to musical scales.

**Inputs:**
- `CV In` (CV) - Continuous pitch CV
- `Scale Mod` (CV) - Scale selection modulation
- `Root Mod` (CV) - Root note modulation

**Outputs:**
- `Out` (CV) - Quantized pitch CV

**Parameters:**
- `Scale` (Choice) - Musical scale (Major, Minor, Chromatic, Pentatonic, etc.)
- `Root` (Choice) - Root note (C, C#, D, etc.)

**How to Use:**
1. Connect a continuous CV source (LFO, random, etc.)
2. Choose a musical scale
3. Set the root note
4. Output will snap to nearest note in the scale
5. Great for creating melodic sequences from random sources

---

### rate
**Rate Value Converter**

Converts raw values to normalized rate values for tempo-related modulation.

**Inputs:**
- `Rate Mod` (CV) - Rate modulation input

**Outputs:**
- `Out` (CV) - Normalized rate output

**Parameters:**
- `Rate` (0.1-20) - Rate multiplier

**How to Use:**
1. Use to convert between different rate representations
2. Useful for tempo-syncing external modulators
3. Provides standardized rate output for consistent timing

---

### comparator
**Threshold Comparator**

Outputs a gate signal when input exceeds a threshold.

**Inputs:**
- `In` (CV) - CV input to compare

**Outputs:**
- `Out` (Gate) - Gate output (high when input > threshold)

**Parameters:**
- `Threshold` (0-1) - Comparison threshold

**How to Use:**
1. Connect a CV source
2. Set threshold
3. Output goes high when input exceeds threshold
4. Great for converting CV to gates
5. Create rhythm from slow LFOs

---

### logic
**Boolean Logic Operations**

Performs boolean logic operations on gate signals.

**Inputs:**
- `In A` (Gate) - First input
- `In B` (Gate) - Second input

**Outputs:**
- `AND` (Gate) - High when both inputs are high
- `OR` (Gate) - High when either input is high
- `XOR` (Gate) - High when inputs differ
- `NOT A` (Gate) - Inverted A

**How to Use:**
1. Connect two gate sources
2. Use outputs for different logic combinations
3. AND: Both gates must be high (good for requiring multiple conditions)
4. OR: Either gate can be high (good for combining triggers)
5. XOR: Only one gate high (good for alternating patterns)
6. NOT A: Invert a gate signal

---

### clock_divider
**Clock Division/Multiplication**

Divides and multiplies clock signals for polyrhythmic patterns.

**Inputs:**
- `Clock In` (Gate) - Clock input to divide/multiply
- `Reset` (Gate) - Reset all divisions to sync

**Outputs:**
- `/2, /4, /8` (Gate) - Divided clocks (half, quarter, eighth speed)
- `x2, x3, x4` (Gate) - Multiplied clocks (double, triple, quadruple speed)

**How to Use:**
1. Connect a clock source
2. Use divided outputs for slower rhythms
3. Use multiplied outputs for faster rhythms
4. Create polyrhythmic patterns by using multiple outputs
5. Use reset to synchronize all divisions

---

### sequential_switch
**Signal Router**

Routes an input signal to one of four outputs based on CV thresholds.

**Inputs:**
- `Gate In` (Audio) - Signal to route
- `Thresh 1-4 CV` (CV) - Threshold values for each output

**Outputs:**
- `Out 1-4` (Audio) - Four possible output destinations

**Parameters:**
- `Threshold 1-4` (0-1) - Threshold levels

**How to Use:**
1. Connect a signal to Gate In
2. Set thresholds for each output
3. As input CV changes, signal routes to different outputs
4. Use with sequencers or LFOs for rhythmic switching
5. Great for creating evolving patterns

---

## 5. SEQUENCER NODES

Sequencer nodes generate rhythmic and melodic patterns.

### sequencer
**16-Step CV/Gate Sequencer**

A classic 16-step sequencer for creating melodies and rhythms.

**Inputs:**
- Extensive per-step modulation inputs for values, triggers, and gates

**Outputs:**
- `Pitch` (CV) - Current step pitch value
- `Gate` (Gate) - Gate output
- `Gate Nuanced` (CV) - Gate with velocity
- `Velocity` (CV) - Velocity value
- `Mod` (CV) - Modulation output
- `Trigger` (Gate) - Trigger on each step

**Parameters:**
- `Rate` (0.1-20 Hz) - Sequence speed
- `Num Steps` (1-16) - Number of active steps
- `Gate Length` (0-1) - Duration of gates
- Per-step: Pitch, Gate, Velocity, Modulation values

**How to Use:**
1. Set number of steps and rate
2. Program pitch values for each step
3. Set gates on/off for rhythm
4. Adjust gate length for articulation
5. Can sync to Tempo Clock for musical timing

---

### multi_sequencer
**Advanced Multi-Output Sequencer**

An advanced sequencer with parallel per-step outputs for polyphonic sequencing.

**Outputs:**
- Live outputs: Pitch, Gate, Trigger, Velocity, Mod
- Parallel outputs: Pitch 1-16, Gate 1-16, Trig 1-16 (all steps output simultaneously)

**How to Use:**
1. Similar to Sequencer but with simultaneous output of all 16 steps
2. Connect parallel outputs to PolyVCO for poly synth
3. Create complex polyphonic arrangements
4. Each step can trigger independently

---

### tempo_clock
**Global Clock Generator**

Master tempo/clock source with transport controls.

**Inputs:**
- `BPM Mod` (CV) - BPM modulation
- `Tap` (Gate) - Tap tempo input
- `Nudge+/-` (Gate) - Fine tempo adjustment
- `Play/Stop/Reset` (Gate) - Transport controls
- `Swing Mod` (CV) - Swing amount modulation

**Outputs:**
- `Clock` (Gate) - Main clock pulse
- `Beat Trig` (Gate) - Trigger on each beat
- `Bar Trig` (Gate) - Trigger on each bar
- `Beat Gate` (Gate) - Gate for beat duration
- `Phase` (CV) - Clock phase (0-1)
- `BPM CV` (CV) - BPM as CV
- `Downbeat` (Gate) - First beat of bar

**Parameters:**
- `BPM` (20-300) - Tempo in beats per minute
- `Time Signature` (Choice) - 4/4, 3/4, 6/8, etc.
- `Swing` (0-100%) - Swing amount
- `Global Division` (Bool) - Override all synced modules' divisions

**How to Use:**
1. Set BPM for your project
2. Use clock outputs to drive sequencers and LFOs
3. Enable Global Division to control all synced modules at once
4. Use transport controls for performance

---

### snapshot_sequencer
**Patch State Sequencer**

Sequences complete patch states, recalling all parameter values.

**How to Use:**
1. Create snapshots of your entire patch at different states
2. Sequence through snapshots for dramatic changes
3. Great for live performance and automation

---

### stroke_sequencer
**Gesture-Based Sequencer**

Records and plays back drawn gestures as CV sequences.

**How to Use:**
1. Draw patterns with your mouse/tablet
2. Playback converts drawing to CV
3. Unique way to create expressive, human-feeling sequences

---

### timeline
**Automation Recorder and Playback**

A transport-synchronized automation recorder that captures and plays back CV, Gate, Trigger, and Raw signals with sample-accurate precision. The Timeline Node serves as the single source of truth for temporal automation in the modular synthesizer.

**Inputs (Dynamic):**
- `[Channel Name] In` (CV) - One input per automation channel (up to 32 channels)

**Outputs (Dynamic):**
- `[Channel Name] Out` (CV) - One output per automation channel (up to 32 channels)

**Parameters:**
- `Record` (Bool) - Enable recording mode (mutually exclusive with Play)
- `Play` (Bool) - Enable playback mode (mutually exclusive with Record)
- `Add Channel` (Button) - Create a new automation channel
- `Remove Channel` (Button) - Remove the last automation channel

**Auto-Connect Shortcuts:**
- **B (CV)**: Chain automation outputs to CV modulation inputs
- **Y (Gate)**: Chain gate/trigger outputs to gate inputs
- **R (Raw)**: Chain raw value outputs

**How to Use:**
1. **Setup Channels:**
   - Click "Add Channel" to create automation channels
   - Each channel can record a separate signal (CV, Gate, Trigger, or Raw)
   - Channels are automatically named (e.g., "Channel 1", "Channel 2")
   
2. **Recording:**
   - Connect signals you want to record to the Timeline's input pins
   - Click the "‚óè REC" button to enable recording
   - Start the global transport (Tempo Clock)
   - The Timeline records keyframes with sample-accurate timing
   - Recording automatically detects value changes (only stores new keyframes when values change)
   - Click "‚óè REC" again to stop recording
   
3. **Playback:**
   - Click the "‚ñ∂ PLAY" button to enable playback
   - Start the global transport
   - The Timeline plays back recorded automation, interpolating between keyframes
   - Playback is sample-accurate and synchronized to the global tempo
   
4. **Visualization:**
   - Select a channel from the list to view its keyframes
   - A waveform plot shows the recorded automation curve
   - The UI displays the current playback position in Bar:Beat:Tick format
   
5. **Persistence:**
   - Automation data is automatically saved with presets
   - All channels and keyframes are preserved when saving/loading patches
   
6. **Tips:**
   - Use multiple channels to record different parameters simultaneously
   - Record is mutually exclusive with Play - switch modes as needed
   - The Timeline passes through signals when neither Record nor Play is active (zero-latency monitoring)
   - Great for creating complex automation that syncs perfectly to tempo

**Technical Details:**
- Synchronized with global `TransportState` (from Tempo Clock)
- Sample-accurate keyframe recording and playback
- Linear interpolation between keyframes during playback
- Thread-safe data access (audio thread + UI thread)
- XML persistence via `getExtraStateTree()` / `setExtraStateTree()`
- Dynamic I/O pins based on number of automation channels

---

## 6. MIDI NODES

MIDI nodes handle MIDI input/output and conversion to CV.

### midi_cv
**MIDI to CV Converter**

Converts incoming MIDI notes to CV/Gate signals (monophonic).

**Outputs:**
- `Pitch` (CV) - Note pitch as CV (V/Oct)
- `Gate` (Gate) - Note on/off gate
- `Velocity` (CV) - Note velocity
- `Mod Wheel` (CV) - CC1 modulation wheel
- `Pitch Bend` (CV) - Pitch bend wheel
- `Aftertouch` (CV) - Channel aftertouch

**How to Use:**
1. Connect MIDI controller or use virtual MIDI
2. Play notes ‚Üí outputs CV/Gate
3. Use with VCO + VCA + ADSR for classic synth voice
4. Monophonic (last note priority)

---

### midi_player
**MIDI File Player**

Plays MIDI files with per-track CV/Gate outputs.

**How to Use:**
1. Load a MIDI file
2. Outputs CV/Gate for each MIDI track
3. Great for backing tracks or complex sequences

---

### midi_faders
**MIDI-Learnable Faders (1-16)**

1-16 MIDI-learnable faders with customizable output ranges.

**Outputs:**
- `Fader 1-16` (CV) - CV outputs (0-1 range)

**Parameters:**
- MIDI Learn for each fader
- Min/Max output range per fader

**How to Use:**
1. Click MIDI Learn
2. Move a fader on your controller
3. Fader is now linked
4. Adjust output ranges as needed

---

### midi_knobs
**MIDI-Learnable Knobs (1-16)**

Similar to MIDI Faders but optimized for rotary controls.

---

### midi_buttons
**MIDI-Learnable Buttons (1-32)**

1-32 MIDI-learnable buttons with Gate/Toggle/Trigger modes.

**Outputs:**
- `Button 1-32` (Gate) - Gate/trigger outputs

**Modes:**
- Gate: High while pressed
- Toggle: Alternates on/off each press
- Trigger: Brief pulse on press

---

### midi_jog_wheel
**MIDI Jog Wheel Control**

A single MIDI-learnable jog wheel for expressive modulation.

**Output:**
- `Value` (CV) - Wheel position/velocity

---

## 7. ANALYSIS NODES

Analysis nodes visualize and inspect signals.

### scope
**Oscilloscope**

Visualizes audio or CV signals over time.

**Inputs/Outputs:**
- `In/Out` (Audio) - Pass-through with visualization

**Parameters:**
- `Window Size` (0.5-20 seconds) - Time window to display
- `Trigger Mode` (Choice) - Free-run, Rising Edge, Falling Edge
- `Trigger Level` (0-1) - Trigger threshold

**How to Use:**
1. Insert in signal path (pass-through)
2. Adjust window size to see desired time range
3. Use trigger modes for stable waveform display
4. Great for debugging and sound design

---

### debug
**Signal Value Logger**

Logs signal value changes to the console.

**How to Use:**
1. Insert in CV path
2. Logs values to console when they change
3. Great for troubleshooting CV routing
4. No audio output (endpoint)

---

### input_debug
**Passthrough Debug Logger**

Like Debug but with pass-through output.

---

### frequency_graph
**Spectrum Analyzer**

High-resolution real-time spectrum analyzer with frequency-based gate outputs.

**Inputs:**
- `In` (Audio) - Mono audio to analyze

**Outputs:**
- `Out L/R` (Audio) - Stereo pass-through
- `Sub/Bass/Mid/High Gate` (Gate) - Per-band gate outputs
- `Sub/Bass/Mid/High Trig` (Gate) - Per-band trigger outputs

**Parameters:**
- `Gate Threshold` per band - Threshold for gate outputs

**How to Use:**
1. Send audio through for visualization
2. Displays frequency spectrum in real-time
3. Use gate/trigger outputs for frequency-reactive triggering
4. Great for kick drum detection, bass triggering, etc.

---

## 8. SPECIAL NODES

Special nodes provide unique functionality beyond traditional synthesis.

### tts_performer
**Text-to-Speech Engine**

Advanced text-to-speech with word-level sequencing.

**Inputs:**
- Per-word trigger inputs (1-16)
- Rate, Gate, Speed, Pitch modulation

**Outputs:**
- `Audio` - Speech audio output
- `Word Gate` - Gate while speaking
- `EOP Gate` - End of phrase gate
- Per-word gates and triggers (1-16)

**Parameters:**
- Text input field
- Voice selection
- Rate, pitch, speed controls

**How to Use:**
1. Type text into text field
2. Choose voice
3. Trigger individual words or play entire phrase
4. Use per-word gates for word-synced events
5. Modulate pitch/speed for effects

---

### vocal_tract_filter
**Formant Filter**

Simulates human vowel sounds through formant filtering.

**Parameters:**
- `Vowel Shape` - Continuous blend between vowels (A, E, I, O, U)
- `Formant Shift` - Shift formant frequencies up/down
- `Instability` - Add human-like variation
- `Gain` - Formant emphasis

**How to Use:**
1. Send audio through (great with sawtooth waves)
2. Adjust vowel shape to morph between vowels
3. Modulate with LFOs for talking/singing effects
4. Use with TTS Performer for enhanced vocal synthesis

---

### physics
**2D Physics Simulation**

A 2D physics engine that outputs collision and contact data as CV.

**How to Use:**
1. Create physics objects in the UI
2. Set gravity, friction, elasticity
3. Objects collide and interact
4. Outputs include position, velocity, collision events
5. Use outputs to drive synthesis parameters
6. Experimental and creative

---

### animation
**3D Animation Player**

Loads and plays 3D animations, outputs joint positions and velocities.

**How to Use:**
1. Load 3D animation file (FBX, etc.)
2. Play animation
3. Outputs joint positions as CV
4. Drive synthesis from motion capture data

---

## 9. COMPUTER VISION NODES

Computer vision nodes process video for audio/CV generation.

### webcam_loader
**Webcam Video Source**

Captures video from webcam and publishes a `Source ID` for vision processing modules.

**Outputs:**
- `Source ID` (Video) - Video source identifier

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect `Source ID` to any `Source In` (Video) input on vision processing modules (e.g., Movement/Human/Object/Color/Pose/Hand/Face/Contour/Segmentation).
- Other chaining keys (**C/G/B/Y/R**) not applicable for this node.

---

### video_file_loader
**Video File Source**

Loads and plays video files; publishes a `Source ID` for vision processing modules.

**Outputs:**
- `Source ID` (Video) - Video source identifier

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect `Source ID` to any `Source In` (Video) input on vision processing modules.
- Other chaining keys (**C/G/B/Y/R**) not applicable for this node.

---

### movement_detector
**Motion Detection**

Analyzes video for motion via optical flow or background subtraction.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Motion X` (CV), `Motion Y` (CV) - Motion vector components
- `Amount` (CV) - Total motion amount
- `Trigger` (Gate) - Trigger on significant motion
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain `Motion X/Y/Amount` to CV destinations
- **Y (Gate)**: Chain `Trigger` to gate inputs

**How to Use:**
1. Connect webcam or video file loader
2. Outputs motion as CV
3. Use for interactive installations
4. Motion triggers synthesis events

---

### human_detector
**Face/Body Detection**

Detects faces or bodies in video via Haar Cascades or HOG.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `X` (CV), `Y` (CV) - Center position
- `Width` (CV), `Height` (CV) - Bounding box size
- `Gate` (Gate) - High when person detected
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected face/body

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain X/Y/Width/Height to CV inputs
- **Y (Gate)**: Chain `Gate` to gate inputs

**How to Use:**
1. Connect video source
2. Detects faces/bodies
3. Outputs position and size as CV
4. Use for interactive performances

---

### pose_estimator
**Body Keypoint Detection**

Uses OpenPose MPI model to detect 15 body keypoints. Outputs 30 CV pins programmatically (X/Y for each keypoint).

**Inputs:**
- `Source In` (Video) - Video source ID from webcam or video file loader

**Outputs (dynamic/programmatic):**
- `Head X/Y`, `Neck X/Y`, `R Shoulder X/Y`, `R Elbow X/Y`, `R Wrist X/Y`, `L Shoulder X/Y`, `L Elbow X/Y`, `L Wrist X/Y`, `R Hip X/Y`, `R Knee X/Y`, `R Ankle X/Y`, `L Hip X/Y`, `L Knee X/Y`, `L Ankle X/Y`, `Chest X/Y` (all CV)
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected body

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain any keypoint X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1). Lower values detect more keypoints but may include false positives
- `Draw Skeleton` (Bool) - Toggle skeleton overlay on video preview
- `Zoom` (+/-) - Toggle between normal (480px) and zoomed (960px) video preview

**How to Use:**
1. **Setup:** Download OpenPose MPI model files (see `guides/POSE_ESTIMATOR_SETUP.md`)
2. **Connect Video Source:** Connect a Webcam Loader or Video File Loader's `Source ID` output to `Source In`
3. **Adjust Confidence:** Lower threshold for more sensitive detection, higher for more reliable detection
4. **Map Keypoints:** Connect individual keypoint X/Y outputs to any CV modulation input
5. **Example Patches:**
   - **Hand-Controlled Oscillator:** Connect `R Wrist X` ‚Üí VCO Frequency, `R Wrist Y` ‚Üí VCF Cutoff
   - **Body-Driven Rhythm:** Connect `R Knee Y` ‚Üí Sequencer Rate, `L Knee Y` ‚Üí Gate threshold
   - **Dance Performance:** Map multiple keypoints to different parameters for full-body control
6. **Performance Tips:**
   - Good lighting improves detection accuracy
   - Stand 1-3 meters from camera for best results
   - Keep full body in frame for all keypoints to be detected
   - Simple backgrounds work best

**Technical Details:**
- Uses OpenPose MPI (faster) model with 15 keypoints
- Runs at ~15 FPS on CPU (computationally intensive)
- Outputs normalized coordinates (0-1 range)
- Real-time safe: Processing runs on separate thread, lock-free FIFO to audio thread
- Video preview shows skeleton overlay when enabled

**Creative Applications:**
- **Interactive Installations:** Create body-responsive soundscapes
- **Live Performance:** Control synthesis with gestures and movement
- **Accessibility:** Hands-free instrument control for performers with mobility constraints
- **Dance + Music:** Choreography-driven composition
- **Fitness Apps:** Exercise-triggered sound design
- **Game Controllers:** Full-body game audio integration

**Requirements:**
- OpenPose MPI model files (~200 MB download)
- Webcam or video file source
- OpenCV with DNN module (included in build)

---

### hand_tracker
**Hand Keypoint Detection**

Uses OpenPose hand model to detect 21 hand keypoints. Outputs 42 CV pins (X/Y per keypoint).

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic/programmatic):**
- `Wrist X/Y`, `Thumb 1-4 X/Y`, `Index 1-4 X/Y`, `Middle 1-4 X/Y`, `Ring 1-4 X/Y`, `Pinky 1-4 X/Y` (all CV)
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected hand

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain any keypoint X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires OpenPose hand model files in `assets/openpose_models/hand/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Adjust Confidence:** Lower values for sensitive detection, higher for reliable detection
4. **Map Gestures:** Connect finger joint positions to synthesis parameters
5. **Example Patches:**
   - **Gesture Control:** Map thumb position to filter cutoff, index position to VCO frequency
   - **Finger Tracking:** Use individual finger tips for multi-parameter control
   - **Hand Size:** Use wrist to fingertip distances for amplitude or volume control
6. **Performance Tips:**
   - Works best with hands clearly visible against contrasting background
   - Keep hands ~30-80cm from camera
   - Good lighting improves detection accuracy

**Technical Details:**
- Uses OpenPose hand detection model
- Detects 21 keypoints per hand
- Runs at ~15 FPS on CPU
- Outputs normalized coordinates (0-1 range)

---

### face_tracker
**Facial Landmark Detection**

Uses OpenPose face model to detect 70 facial landmarks. Outputs 140 CV pins (X/Y per point).

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic/programmatic):**
- `Pt 1-70 X/Y` (CV) - Landmark positions
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected face

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain landmark X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires OpenPose face model files in `assets/openpose_models/face/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Adjust Confidence:** Lower values for sensitive detection, higher for reliable detection
4. **Map Landmarks:** Connect facial landmark positions to synthesis parameters
5. **Example Patches:**
   - **Expression Control:** Map mouth width to effect parameters, eyebrow position to filter resonance
   - **Head Tracking:** Use face center for spatial panning
   - **Lip Sync:** Use mouth landmarks for vocoder or formant filtering
6. **Performance Tips:**
   - Face-front camera position works best
   - Keep face well-lit
   - Maintain 50-150cm distance from camera

**Technical Details:**
- Uses Haar Cascade for face detection, OpenPose DNN for landmark estimation
- Detects 70 landmarks per face
- Runs at ~15 FPS on CPU
- Outputs normalized coordinates (0-1 range)

---

### object_detector
**YOLOv3 Object Detection**

Uses YOLOv3 deep learning model to detect objects from 80 COCO classes (person, car, bottle, etc.) in real-time video.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `X` (CV) - Center X position (0-1)
- `Y` (CV) - Center Y position (0-1)
- `Width` (CV) - Width (0-1)
- `Height` (CV) - Height (0-1)
- `Gate` (Gate) - High when target detected
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected object

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain X/Y/Width/Height to CV inputs
- **Y (Gate)**: Chain `Gate` to gate inputs

**Parameters:**
- `Target Class` (Choice) - Object class to detect (person, car, bicycle, etc.)
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.5)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires YOLOv3 model files (`yolov3.cfg`, `yolov3.weights`, `coco.names`) in `assets/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Select Target Class:** Choose which object type to detect
4. **Adjust Confidence:** Lower for more detections (may include false positives), higher for reliable detection
5. **Map Coordinates:** Connect X/Y/Width/Height outputs to synthesis parameters
6. **Example Patches:**
   - **Person Tracking:** Use person bounding box to trigger events when person enters/exits frame
   - **Object Size Control:** Use Width √ó Height to control effect amount
   - **Position-Based Effects:** Map center X to panning, center Y to filter cutoff
7. **Performance Tips:**
   - YOLO is computationally intensive (~10 FPS on CPU)
   - Good lighting and contrast improve detection
   - Larger objects are detected more reliably

**Technical Details:**
- Uses YOLOv3 (You Only Look Once v3) detection model
- 80 COCO object classes supported
- Runs at ~10 FPS on CPU
- Outputs normalized bounding box coordinates
- Falls back to YOLOv3-tiny if standard model not available

---

### color_tracker
**Multi-Color HSV Tracking**

Tracks multiple custom colors in video using HSV color space. Outputs are dynamic: each added color creates three CV outputs.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic):**
- For each tracked color:
  - `[Color] X` (CV) - Center X (0-1)
  - `[Color] Y` (CV) - Center Y (0-1)
  - `[Color] Area` (CV) - Covered area (0-1)
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain per-color X/Y/Area to CV inputs

**Parameters:**
- `Add Color...` (Button) - Click to pick a color from the video preview
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
2. **Pick Colors:** Click "Add Color..." and click on the video preview to sample a color
3. **Track Multiple:** Add up to 8 different colors to track simultaneously
4. **Remove Colors:** Click "Remove" button next to each tracked color
5. **Map Coordinates:** Connect individual color outputs to synthesis parameters
6. **Example Patches:**
   - **Two-Object Control:** Track two colored objects for stereo panning or dual oscillator control
   - **Area-Based Effects:** Use Area output to control effect wet/dry mix
   - **Position Automation:** Map color X/Y to sequencer position or filter sweeps
7. **Performance Tips:**
   - Works best with saturated, distinct colors
   - Avoid overlapping colors in similar hues
   - Good lighting maintains consistent HSV values

**Technical Details:**
- Uses HSV color space for robust color detection
- Tracks up to 8 colors simultaneously
- Automatic morphological cleanup for noise reduction
- Runs at ~30 FPS on CPU
- Outputs normalized coordinates and area

---

### contour_detector
**Shape Detection via Background Subtraction**

Detects shapes and their properties using background subtraction and contour analysis.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Area` (CV) - Detected shape area (0-1)
- `Complexity` (CV) - Polygon complexity (0-1)
- `Aspect Ratio` (CV) - Width/height ratio
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain outputs to CV inputs

**Parameters:**
- `Threshold` (0-255) - Threshold for foreground/background separation (default: 128)
- `Noise Reduction` (Bool) - Enable morphological filtering to reduce noise (default: On)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
2. **Adjust Threshold:** Set threshold to separate foreground from background
3. **Enable Noise Reduction:** Reduce detection of small, noisy artifacts
4. **Map Shape Properties:** Connect Area, Complexity, and Aspect Ratio to synthesis parameters
5. **Example Patches:**
   - **Size-Based Filtering:** Use Area to control low-pass filter cutoff
   - **Shape Recognition:** Use Complexity to detect simple vs complex shapes
   - **Orientation Control:** Use Aspect Ratio to determine if object is horizontal or vertical
6. **Performance Tips:**
   - Requires relatively static background for best results
   - Good contrast between foreground and background
   - Use noise reduction for clean signal

**Technical Details:**
- Uses MOG2 background subtraction
- Polygon approximation for complexity calculation
- Runs at ~25 FPS on CPU
- Outputs normalized shape properties

---

### semantic_segmentation
**Scene Segmentation via Deep Learning**

Uses semantic segmentation (ENet or DeepLabV3) to identify a target class and output region properties.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Area` (CV) - Frame coverage of target class (0-1)
- `Center X` (CV) - Center X of detected region (0-1)
- `Center Y` (CV) - Center Y of detected region (0-1)
- `Gate` (Gate) - High when target detected
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain Area and Center outputs to CV targets.
- **Y (Gate)**: Chain `Gate` to gate inputs.

**Parameters:**
- `Target Class` (Choice) - Semantic class to detect (person, road, car, etc.)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires ENet or DeepLabV3 model files in `assets/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Select Target Class:** Choose which semantic class to track
4. **Map Region Properties:** Connect Area and Center outputs to synthesis parameters
5. **Example Patches:**
   - **Presence Detection:** Use Gate output to trigger events when person enters frame
   - **Coverage-Based Effects:** Use Area to control reverb size or delay feedback
   - **Center Tracking:** Use Center X/Y for spatial effects
6. **Performance Tips:**
   - Computationally intensive (~10 FPS on CPU)
   - Best results with scenes that match training data (Cityscapes, etc.)
   - Works well for large, distinct regions

**Technical Details:**
- Uses ENet (Efficient Neural Network) or DeepLabV3 segmentation models
- Supports Cityscapes dataset classes by default
- Runs at ~10 FPS on CPU
- Outputs normalized region properties with colored preview overlay

---

### video_fx
**Real-Time Video Effects Processor**

A comprehensive video processing node that applies real-time effects to video streams. Supports chaining multiple effects for complex video transformations. All parameters can be modulated via CV inputs.

**Inputs:**
- `Source In` (Video) - Video source ID from webcam, video file, or other video processing nodes

**Outputs:**
- `Output ID` (Video) - Processed video source ID for chaining to other video modules

**Parameters (All CV-Modulatable):**

**Color Adjustments:**
- `Brightness` (-100 to +100) - Brightness adjustment
- `Contrast` (0.0-3.0) - Contrast multiplier
- `Saturation` (0.0-3.0) - Color saturation (0=grayscale, 1=normal, >1=enhanced)
- `Hue Shift` (-180 to +180) - Hue rotation in degrees
- `Red/Green/Blue Gain` (0.0-2.0) - Per-channel gain control
- `Temperature` (-1.0 to +1.0) - Color temperature (cold to warm)
- `Sepia` (Bool) - Apply sepia tone effect

**Filters & Effects:**
- `Sharpen` (0.0-2.0) - Sharpening amount
- `Blur` (0-20) - Blur radius
- `Grayscale` (Bool) - Convert to grayscale
- `Invert Colors` (Bool) - Invert color values
- `Flip Horizontal/Vertical` (Bool) - Mirror frames

**Advanced Effects:**
- `Threshold Enable` (Bool) - Enable threshold effect
- `Threshold Level` (0-255) - Threshold cutoff
- `Posterize Levels` (2-32) - Color quantization (lower = fewer colors)
- `Vignette Amount` (0.0-1.0) - Vignette darkening intensity
- `Vignette Size` (0.1-2.0) - Vignette radius
- `Pixelate Block Size` (1-128) - Pixelation block size
- `Edge Detect (Canny)` (Bool) - Enable Canny edge detection
- `Canny Threshold 1/2` (0-255) - Edge detection thresholds
- `Kaleidoscope` (Choice) - None, 4-Way, or 8-Way mirroring

**System:**
- `Use GPU (CUDA)` (Bool) - Enable GPU acceleration (if available)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**Auto-Connect Shortcuts:**
- **V (Video)**: Chain video source ‚Üí `Source In`, `Output ID` ‚Üí next video module
- All color/filter parameters accept CV modulation for dynamic effects

**How to Use:**
1. **Connect Video Source:** Connect Webcam, Video File Loader, or another Video FX node to `Source In`
2. **Chain Effects:** Connect `Output ID` to another Video FX or CV processing module
3. **Adjust Parameters:** Use sliders for real-time preview
4. **Modulate with CV:** Connect LFOs, envelopes, or sequencers to CV inputs for animated effects
5. **Example Chains:**
   - **Color Grading Chain:** Video FX (saturation + temperature) ‚Üí Video FX (contrast + brightness)
   - **Stylization:** Video FX (posterize + vignette) ‚Üí Video FX (sepia + blur)
   - **Motion Effects:** LFO ‚Üí Brightness CV, ADSR ‚Üí Blur CV for dynamic effects
6. **Performance Tips:**
   - GPU acceleration significantly improves performance (enable if available)
   - Chain multiple Video FX nodes for complex effect combinations
   - Use CV modulation for automated video transformations
   - Preview size affects UI performance (use Small for many nodes)

**Technical Details:**
- Passthrough video processing (zero latency)
- Supports GPU acceleration via CUDA (when compiled with CUDA support)
- Real-time processing at video frame rate
- All effects are composable and can be combined
- Dynamic CV modulation inputs for all parameters
- Creates new video source ID for processed output (enables chaining)

---

### crop_video
**Video Cropping with Automatic Tracking**

Crops video frames to a specified region. Supports three modes: manual cropping, automatic face tracking, and automatic object tracking (YOLOv3). Perfect for following detected objects or isolating regions of interest.

**Inputs:**
- `Source In` (Video) - Video source ID
- `Center X Mod` (CV) - Center X position modulation (0-1)
- `Center Y Mod` (CV) - Center Y position modulation (0-1)
- `Width Mod` (CV) - Crop width modulation (0-1)
- `Height Mod` (CV) - Crop height modulation (0-1)

**Outputs:**
- `Output ID` (Video) - Cropped video source ID for chaining

**Parameters:**
- `Tracking Mode` (Choice) - Manual, Track Face, or Track Object
- `Target Class` (Choice) - Object class when tracking objects (person, car, etc.)
- `Confidence` (0.0-1.0) - Detection confidence threshold
- `Padding` (0.0-2.0) - Padding around tracked region (0.1 = 10% padding)
- `Aspect Ratio` (Choice) - Stretch or Preserve (Fit)
- `Use GPU (CUDA)` (Bool) - Enable GPU acceleration for tracking
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**Manual Crop Controls:**
- `Center X/Y` (0-1) - Crop region center position
- `Width/Height` (0-1) - Crop region size

**Auto-Connect Shortcuts:**
- **V (Video)**: Chain video source ‚Üí `Source In`, `Output ID` ‚Üí next video module
- **B (CV)**: Connect CV signals (from Object/Human/Pose detectors) to Center X/Y/Width/Height modulation inputs

**How to Use:**
1. **Manual Mode:**
   - Connect video source to `Source In`
   - Adjust Center X/Y and Width/Height sliders
   - Use Aspect Ratio "Preserve" to maintain original proportions
   
2. **Track Face Mode:**
   - Select "Track Face" from Tracking Mode
   - Automatically detects and tracks faces using Haar Cascade
   - Adjust Padding to add space around face
   - GPU acceleration recommended for better performance

3. **Track Object Mode:**
   - Select "Track Object" from Tracking Mode
   - Choose Target Class (e.g., "person", "car", "bottle")
   - Requires YOLOv3 model files in `assets/`
   - Automatically tracks and crops to detected object bounding box
   - Adjust Confidence threshold to filter detections

4. **CV Modulation:**
   - Connect Object Detector X/Y/Width/Height outputs to Crop Video modulation inputs
   - Connect Pose Estimator keypoint positions for dynamic cropping
   - Use sequencers or LFOs for automated crop animations

5. **Example Patches:**
   - **Face Isolation:** Track Face mode ‚Üí Cropped output to Face Tracker for detailed analysis
   - **Person Following:** Object Detector (person) ‚Üí Crop Video CV inputs ‚Üí Cropped region to Pose Estimator
   - **Dynamic Cropping:** LFO ‚Üí Center X Mod, ADSR ‚Üí Width Mod for animated crops
   - **Multi-Stage Processing:** Crop Video ‚Üí Video FX (stylize cropped region) ‚Üí Further processing

6. **Performance Tips:**
   - GPU acceleration improves tracking performance (especially for YOLOv3)
   - Lower confidence thresholds detect more objects but may include false positives
   - Padding helps maintain context around tracked objects
   - Use Preserve aspect ratio to avoid distortion

**Technical Details:**
- Three tracking modes: Manual (slider-based), Face (Haar Cascade), Object (YOLOv3)
- YOLOv3 tracking requires model files (`yolov3.cfg`, `yolov3.weights`, `coco.names`)
- Falls back to YOLOv3-tiny if standard model not available
- GPU acceleration via CUDA (optional, improves performance)
- Real-time processing at video frame rate
- Passthrough video processing with zero latency
- CV modulation allows dynamic crop region control

---

## 11. SYSTEM NODES

System nodes provide special functionality for patch organization.

### meta
**Meta Module Container**

A container for creating custom reusable modules from sub-patches.

**How to Use:**
1. Create a patch inside the Meta module
2. Use Inlet/Outlet nodes to define interface
3. Save as reusable module
4. Collapse complex patches into single nodes

---

### inlet
**Meta Module Input**

Defines an input for a Meta module.

---

### outlet
**Meta Module Output**

Defines an output for a Meta module.

---

### comment
**Documentation Node**

A text comment node for documenting patches.

**How to Use:**
1. Add comment node
2. Type documentation text
3. Helps explain complex patches
4. No audio/CV functionality

---

### recorder
**Audio Recording to File**

Records incoming audio to WAV, AIFF, or FLAC files.

**Inputs:**
- `In L/R` (Audio) - Stereo audio to record

**Parameters:**
- File path/name
- Format (WAV, AIFF, FLAC)
- Bit depth (16/24/32)
- Record button

**How to Use:**
1. Set file path and format
2. Connect audio source
3. Click Record to start
4. Click Stop to finish and save

---

### vst_host
**VST Plugin Host**

Hosts VST2/VST3 plugins within the modular environment.

**How to Use:**
1. Load VST plugin
2. Audio routed through plugin
3. Use external effects and instruments
4. Combine modular with traditional plugins

---

### bpm_monitor
**Rhythm Detection and BPM Reporting**

A hybrid smart system that automatically detects and reports BPM from rhythm-producing modules and audio inputs. This node is always present in patches (like the output node) and cannot be deleted. It dynamically generates output pins for each detected rhythm source.

**Inputs (Dynamic):**
- `In 1-16` (Audio) - Audio inputs for beat detection (up to 16 channels)

**Outputs (Dynamic):**
- For each detected rhythm source:
  - `[Source Name] BPM` (Raw) - Absolute BPM value
  - `[Source Name] CV` (CV) - Normalized BPM (0-1 range for modulation)
  - `[Source Name] Active` (Gate) - High when source is active (for introspected sources)
  - `[Source Name] Confidence` (CV) - Detection confidence (0-1, for detected sources)

**Parameters:**
- `Operation Mode` (Choice) - Auto (both methods), Introspection Only, or Detection Only
- `Min BPM` (20-120) - Minimum BPM for normalization (default: 60)
- `Max BPM` (120-300) - Maximum BPM for normalization (default: 240)

**Auto-Connect Shortcuts:**
- **B (CV)**: Chain `[Source] CV` outputs to CV modulation inputs
- **Y (Gate)**: Chain `[Source] Active` outputs to gate inputs
- **R (Raw)**: Chain `[Source] BPM` outputs to raw value inputs
- **G (Audio)**: Connect audio sources to beat detection inputs

**How to Use:**
1. **Operation Modes:**
   - **Auto**: Uses both introspection (fast) and beat detection (universal)
   - **Introspection Only**: Only scans modules that report rhythm info (sequencers, animations)
   - **Detection Only**: Only analyzes audio inputs using tap tempo algorithm
   
2. **Introspection (Recommended):**
   - Automatically detects modules that implement `getRhythmInfo()`
   - Works with: Sequencer, Step Sequencer, Animation, Physics, and other rhythm-producing modules
   - Provides instant, accurate BPM reporting
   - Scans the graph periodically (every 128 audio blocks for efficiency)
   
3. **Beat Detection (Fallback):**
   - Connect any rhythmic audio signal to the inputs
   - Uses tap tempo algorithm with rolling average
   - Works with external audio, VST plugins, or any rhythmic source
   - Outputs confidence level indicating detection stability
   
4. **Using Outputs:**
   - Each detected source generates three outputs:
     - **BPM (Raw)**: Absolute BPM value (e.g., 120.0)
     - **CV**: Normalized 0-1 range for modulation (scaled by Min/Max BPM parameters)
     - **Active/Confidence**: Gate for introspected sources, confidence CV for detected sources
   
5. **Example Patches:**
   - **Sync Effects to Sequencer**: Connect Sequencer ‚Üí BPM Monitor, use `CV` output to modulate delay time
   - **Beat-Synchronized LFO**: Use `CV` output to sync LFO rate to detected BPM
   - **Multi-Source Tempo**: Monitor multiple sequencers and select the most appropriate one
   - **External Tempo Sync**: Connect audio input from external source, use detected BPM to sync your patch
   
6. **Tips:**
   - Introspection mode is fastest and most accurate for compatible modules
   - Beat detection works with any rhythmic source but may have latency
   - Use Min/Max BPM parameters to set the CV output range for your modulation needs
   - The node automatically updates when new rhythm sources appear or disappear

**Technical Details:**
- Hybrid detection: introspection (via `getRhythmInfo()`) + audio analysis (TapTempo algorithm)
- Graph scanning runs every 128 audio blocks (~2.9ms at 44.1kHz) for efficiency
- Thread-safe access to detected sources (protects dynamic pin queries)
- Dynamic output pins generated based on detected sources
- Always present (logical ID 999, undeletable)
- Supports up to 16 audio detection inputs

**Supported Introspection Sources:**
- Sequencer (reports BPM when active)
- Step Sequencer (reports BPM when running)
- Animation (reports BPM based on animation speed and duration)
- Physics (can report rhythm from collision events)
- Other modules implementing `getRhythmInfo()`

---


## Glossary

**CV (Control Voltage):** A signal (typically 0-1 or -1 to +1) used to modulate parameters.

**Gate:** A binary signal (high/low, on/off) used for triggering and timing.

**Trigger:** A brief pulse signal, typically used to initiate events.

**Audio:** Full-rate audio signals (~44.1kHz or higher).

**Raw:** Unscaled numerical values for custom ranges.

**Video:** Video source identifier for computer vision processing.

**V/Oct:** Volt-per-octave pitch CV standard (1 semitone = 1/12 V).

**Relative Modulation:** CV modulates around a slider position (musical/proportional).

**Absolute Modulation:** CV directly maps to full parameter range.

**Bipolar:** Signal range from -1 to +1 (centered at 0).

**Unipolar:** Signal range from 0 to 1.

---

## Keyboard Shortcuts for Auto-Connection

When multiple nodes are selected, use these keys to chain them by data type:

| Key | Data Type | Color | Use Case |
|-----|-----------|-------|----------|
| **C** | Standard Chaining | White | Stereo audio chain (channels 0‚Üí0, 1‚Üí1) |
| **G** | Audio | Green | Audio effects chain |
| **B** | CV (Control Voltage) | Blue | CV signal chain |
| **Y** | Gate | Yellow | Gate/trigger chain |
| **R** | Raw | Red | Raw value chain |
| **V** | Video | Cyan | Video source chain (webcam/video ‚Üí CV modules) |

**Note:** Auto-connection shortcuts only work when 2+ nodes are selected.

---

## Tips for Using the Dictionary

1. **Search by Function:** Use Ctrl+F to find nodes by keyword (e.g., "distortion", "filter", "envelope")
2. **Follow the Signal Flow:** Start with Sources ‚Üí Effects ‚Üí Output
3. **Modulation is Key:** Most parameters can be modulated - experiment!
4. **Save Your Patches:** Use the preset system to save and recall configurations
5. **Start Simple:** Build complexity gradually by adding one module at a time

---

**End of Nodes Dictionary**

*For more information, see the main user manual and individual module guides.*




================================================================================
FILE: guides\IMGUI_NODE_DESIGN_GUIDE.md
================================================================================


# üìê ImGui Node UI Design Guide

**Version**: 2.3.2  
**Last Updated**: 2025-10-24  
**Based on**: `imgui_demo.cpp` best practices + **official imnodes examples**

---

## üéØ Purpose

This guide documents proven UI patterns for designing professional, consistent, and user-friendly node interfaces in our modular synth environment. All patterns are derived from `imgui_demo.cpp` and real-world refinement.

**Golden Rule**: *Every UI element must respect node boundaries and provide clear, immediate feedback to the user.*

---

## üìè 1. Node Layout & Structure

### 1.1 Item Width Management

**Rule**: Always respect the `itemWidth` parameter passed to `drawParametersInNode()`.

```cpp
void drawParametersInNode(float itemWidth, ...) override
{
    ImGui::PushItemWidth(itemWidth);
    
    // All controls here...
    
    ImGui::PopItemWidth();
}
```

**Why**: This ensures controls don't overflow node boundaries.

---

### 1.2 Section Separators (CRITICAL!)

**‚ùå NEVER USE** `ImGui::Separator()` or `ImGui::SeparatorText()` inside nodes!

These functions consume full available width and **extend beyond node boundaries**, creating visual glitches.

**‚úÖ CORRECT APPROACH**:

```cpp
// Option 1: Simple text title + spacing
ImGui::Text("Section Name");
ImGui::Spacing();

// Option 2: Color-coded section title (preferred)
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Section Name");
ImGui::Spacing();

// Option 3: Custom separator (advanced)
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 pos = ImGui::GetCursorScreenPos();
ImVec2 lineEnd = ImVec2(pos.x + itemWidth, pos.y);
drawList->AddLine(pos, lineEnd, IM_COL32(100, 100, 100, 255), 1.0f);
ImGui::Dummy(ImVec2(0, 1)); // Reserve space for line
ImGui::Spacing();
```

**Reference**: See `MIDIFadersModuleProcessor.cpp` lines 180-185 for working examples.

---

### 1.3 Vertical Spacing

**Best Practice**: Use `ImGui::Spacing()` liberally for visual breathing room.

```cpp
// Between major sections
ImGui::Spacing();
ImGui::Spacing();

// Between related controls
ImGui::Spacing();
```

**From imgui_demo.cpp**: Consistent spacing improves readability significantly.

---

## üé® 2. Visual Feedback & Indicators

### 2.1 Color-Coded Modulation States

**Pattern**: Use distinct colors to show when parameters are under CV control.

```cpp
const bool isModulated = isParamModulated(paramId);

if (isModulated)
{
    // Cyan for CV modulation
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
}

if (isModulated) ImGui::BeginDisabled();
// ... slider/control here ...
if (isModulated) ImGui::EndDisabled();

if (isModulated) ImGui::PopStyleColor(3);
```

**Color Scheme**:
- **Cyan** (0.4, 0.8, 1.0): Frequency/Pitch modulation
- **Orange** (1.0, 0.8, 0.4): Timbre/Waveform modulation
- **Magenta** (1.0, 0.4, 1.0): Amplitude/Level modulation
- **Green** (0.4, 1.0, 0.4): Filter/EQ modulation

**Reference**: `VCOModuleProcessor.h` lines 59-64, 151-155

---

### 2.2 Real-Time Meters & Displays

**Pattern**: Use `ImGui::ProgressBar()` for level meters with color coding.

```cpp
float level = lastOutputValues[0]->load();
float absLevel = std::abs(level);

// Color-coded by level
ImVec4 meterColor;
if (absLevel < 0.7f)
    meterColor = ImVec4(0.2f, 0.8f, 0.2f, 1.0f); // Green (safe)
else if (absLevel < 0.9f)
    meterColor = ImVec4(0.9f, 0.7f, 0.0f, 1.0f); // Yellow (hot)
else
    meterColor = ImVec4(0.9f, 0.2f, 0.2f, 1.0f); // Red (clipping!)

ImGui::PushStyleColor(ImGuiCol_PlotHistogram, meterColor);
ImGui::ProgressBar(absLevel, ImVec2(itemWidth, 0), "");
ImGui::PopStyleColor();

ImGui::SameLine(0, 5);
ImGui::Text("%.3f", level);
```

**Reference**: `VCOModuleProcessor.h` lines 202-213

---

### 2.3 Waveform/Data Visualization

**Pattern**: Use `ImGui::PlotLines()` for waveform previews.

```cpp
float waveformData[128];
// ... populate waveformData ...

ImGui::PlotLines(
    "##wavepreview",           // Hidden label (## prefix)
    waveformData,              // Data array
    128,                       // Array size
    0,                         // Values offset
    nullptr,                   // Overlay text
    -1.2f,                     // Scale min
    1.2f,                      // Scale max
    ImVec2(itemWidth, 80)      // Size
);
```

**From imgui_demo.cpp**: Lines 1982-1985, 2012-2013

**Reference**: `VCOModuleProcessor.h` lines 178-192

---

## üí° 3. Tooltips & Help System

### 3.1 HelpMarker Function (Standard)

**REQUIRED**: Implement this helper in every `drawParametersInNode()`:

```cpp
auto HelpMarker = [](const char* desc)
{
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
};
```

**From imgui_demo.cpp**: Lines 273-282

**Usage**:
```cpp
ImGui::SliderFloat("Frequency", &freq, 20.0f, 20000.0f);
HelpMarker("Sets the fundamental frequency.\nCan be modulated by CV input.");
```

---

### 3.2 Tooltip Best Practices

**Do**:
- ‚úÖ Explain what the parameter does
- ‚úÖ Mention CV modulation behavior
- ‚úÖ Provide typical ranges or values
- ‚úÖ Use `\n` for multi-line explanations

**Don't**:
- ‚ùå Write essays (keep under 3 lines)
- ‚ùå Repeat the obvious
- ‚ùå Forget to call `HelpMarker()` after EVERY control

**Reference**: `VCOModuleProcessor.h` lines 85, 175, 217

---

## üéõÔ∏è 4. Control Patterns

### 4.1 Slider with Label Pattern

**Standard**:
```cpp
if (ImGui::SliderFloat("##paramId", &value, min, max, "%.1f", flags))
{
    if (!isModulated)
        *apvtsParam = value;
}
if (ImGui::IsItemDeactivatedAfterEdit())
    onModificationEnded();

ImGui::SameLine();
ImGui::Text("Parameter Name");
HelpMarker("Description here");
```

**Why separate label?**: Allows color-coding the text independently of the slider.

---

### 4.2 Quick Preset Buttons

**Pattern**: Provide common values as one-click buttons.

```cpp
ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 4));
float btnWidth = (itemWidth - 12) / 4.0f;  // 4 buttons with spacing

if (ImGui::Button("A4", ImVec2(btnWidth, 0)))
{
    *frequencyParam = 440.0f;
    onModificationEnded();
}
if (ImGui::IsItemHovered())
    ImGui::SetTooltip("440 Hz (Concert A)");

ImGui::SameLine();
// ... more buttons ...

ImGui::PopStyleVar();
```

**Reference**: `VCOModuleProcessor.h` lines 103-140

---

### 4.3 Combo Box (Dropdown) Pattern

```cpp
const char* items[] = { "Option 1", "Option 2", "Option 3" };
int currentItem = 0;

if (ImGui::Combo("##comboId", &currentItem, items, IM_ARRAYSIZE(items)))
{
    *apvtsParam = currentItem;
}
if (ImGui::IsItemDeactivatedAfterEdit())
    onModificationEnded();

ImGui::SameLine();
ImGui::Text("Selector Name");
HelpMarker("Choose from available options");
```

---

## üîÑ 5. Tables & Multi-Control Layouts

### 5.1 Table Flags (From MIDI Modules Experience)

**REQUIRED FLAGS**:
```cpp
ImGuiTableFlags flags = 
    ImGuiTableFlags_SizingFixedFit |    // Fixed column widths
    ImGuiTableFlags_NoHostExtendX |     // Don't extend beyond itemWidth
    ImGuiTableFlags_Borders |           // Show cell borders
    ImGuiTableFlags_RowBg;              // Alternating row colors

if (ImGui::BeginTable("##tableId", numColumns, flags))
{
    // Setup columns with FIXED width
    ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_WidthFixed, 120.0f);
    // ... content ...
    ImGui::EndTable();
}
```

**Critical**: ALL columns must use `ImGuiTableColumnFlags_WidthFixed` when using `NoHostExtendX`.

**Reference**: `MIDIFadersModuleProcessor.cpp` table implementation (lines ~400-500)

---

### 5.2 Button Grids

**Pattern**: Use calculated widths for perfect alignment.

```cpp
float spacing = 4.0f;
float btnWidth = (itemWidth - spacing * (numButtons - 1)) / numButtons;

ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

for (int i = 0; i < numButtons; ++i)
{
    if (i > 0) ImGui::SameLine();
    
    ImGui::PushID(i);  // CRITICAL for unique IDs!
    if (ImGui::Button("Button", ImVec2(btnWidth, 0)))
    {
        // Action
    }
    ImGui::PopID();
}

ImGui::PopStyleVar();
```

---

## üÜî 6. ID Management

### 6.1 Unique IDs Rule

**Every widget must have a unique ImGui ID!**

**Methods**:

1. **Hidden Label Suffix** (`##`):
```cpp
ImGui::SliderFloat("##freq", &freq, ...);  // ID = "##freq"
ImGui::SameLine();
ImGui::Text("Frequency");  // Visible label separate
```

2. **Push/Pop ID Scope**:
```cpp
for (int i = 0; i < count; ++i)
{
    ImGui::PushID(i);
    ImGui::Button("Learn");  // Unique ID: "Learn/0", "Learn/1", etc.
    ImGui::PopID();
}
```

3. **String ID in Popups/Combos**:
```cpp
ImGui::OpenPopup("SavePreset##nodeId");  // Unique per node
```

**From imgui_demo.cpp**: ID management examples throughout, especially lines 1000-1200 (widgets section)

---

## üé® 7. Custom Drawing (Advanced)

### 7.1 Circular Indicators (Jog Wheel Pattern)

```cpp
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 center = ImGui::GetCursorScreenPos();
center.x += itemWidth * 0.5f;
center.y += 80.0f;

float radius = 40.0f;

// Background circle
drawList->AddCircle(center, radius, IM_COL32(100, 100, 100, 255), 32, 2.0f);

// Indicator needle
float angle = value * 2.0f * M_PI;  // Convert value to radians
ImVec2 needleEnd(
    center.x + std::cos(angle - M_PI / 2.0f) * (radius - 5.0f),
    center.y + std::sin(angle - M_PI / 2.0f) * (radius - 5.0f)
);

drawList->AddLine(center, needleEnd, IM_COL32(100, 200, 255, 255), 3.0f);
drawList->AddCircleFilled(center, 4.0f, IM_COL32(100, 200, 255, 255));

ImGui::Dummy(ImVec2(itemWidth, 160));  // Reserve space
```

**Reference**: `MIDIJogWheelModuleProcessor.cpp` lines 310-340

---

### 7.2 Clipping Regions

**Pattern**: Constrain drawing to specific area.

```cpp
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 pos = ImGui::GetCursorScreenPos();
ImVec2 size(itemWidth, 100);

drawList->PushClipRect(pos, ImVec2(pos.x + size.x, pos.y + size.y), true);
// ... drawing code ...
drawList->PopClipRect();
```

**From imgui_demo.cpp**: Lines 6800-6850 (custom rendering examples)

---

## üì¶ 8. Complete Node Template

```cpp
#if defined(PRESET_CREATOR_UI)
void drawParametersInNode(float itemWidth,
                          const std::function<bool(const juce::String&)>& isParamModulated,
                          const std::function<void()>& onModificationEnded) override
{
    // 1. HelpMarker helper
    auto HelpMarker = [](const char* desc)
    {
        ImGui::SameLine();
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip())
        {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    ImGui::PushItemWidth(itemWidth);

    // 2. Section 1: Main Controls
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Main Controls");
    ImGui::Spacing();
    
    // 3. Modulation-aware slider
    const bool isModulated = isParamModulated("param1");
    
    if (isModulated)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
    }
    
    if (isModulated) ImGui::BeginDisabled();
    
    float param1 = param1Param->load();
    if (ImGui::SliderFloat("##param1", &param1, 0.0f, 1.0f))
    {
        if (!isModulated)
            *param1Param = param1;
    }
    if (ImGui::IsItemDeactivatedAfterEdit())
        onModificationEnded();
    
    if (isModulated) ImGui::EndDisabled();
    
    ImGui::SameLine();
    if (isModulated)
    {
        ImGui::TextColored(ImVec4(0.4f, 0.8f, 1.0f, 1.0f), "Parameter 1 (CV)");
        ImGui::PopStyleColor(3);
    }
    else
    {
        ImGui::Text("Parameter 1");
    }
    HelpMarker("This parameter does something important.\nRange: 0 to 1");

    ImGui::Spacing();
    ImGui::Spacing();

    // 4. Section 2: Visualization
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Output");
    ImGui::Spacing();
    
    // 5. Real-time meter
    float level = lastOutputValues[0]->load();
    ImVec4 color = (std::abs(level) < 0.7f) 
        ? ImVec4(0.2f, 0.8f, 0.2f, 1.0f)   // Green
        : ImVec4(0.9f, 0.2f, 0.2f, 1.0f);  // Red
    
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, color);
    ImGui::ProgressBar(std::abs(level), ImVec2(itemWidth, 0), "");
    ImGui::PopStyleColor();
    
    ImGui::SameLine(0, 5);
    ImGui::Text("%.3f", level);
    HelpMarker("Current output level");

    ImGui::PopItemWidth();
}

void drawIoPins(const NodePinHelpers& helpers) override
{
    helpers.drawAudioInputPin("In", 0);
    helpers.drawAudioOutputPin("Out", 0);
}
#endif
```

---

## üîå 8. Pin Label Spacing (CRITICAL!)

### 8.1 Output Pin Text Alignment

**Problem**: Default spacing between pin labels and pin circles creates visual disconnection.

**From imgui_demo.cpp**: Line 447 shows `ImGui::SameLine(0, 0)` for minimal spacing between elements.

**Best Practice**: Use `ImGui::Indent()` for right-alignment (IMNODES OFFICIAL PATTERN).

```cpp
// ‚úÖ CORRECT: Use Indent() - this is how ALL imnodes examples do it!
// From: color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73
auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
{
    const ImVec2 textSize = ImGui::CalcTextSize(txt);
    
    // Indent by (nodeWidth - textWidth) to right-align
    // ImNodes uses Indent(), NOT Dummy() + SameLine()!
    const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
    ImGui::Indent(indentAmount);
    ImGui::TextUnformatted(txt);
    ImGui::Unindent(indentAmount);  // CRITICAL: Reset indent!
};
```

**‚ö†Ô∏è CRITICAL**: Always call `Unindent()` to match `Indent()`! Indent is **persistent** and will affect all subsequent ImGui elements until reset.

**‚ùå WRONG**: Using Dummy() + SameLine() (imgui_demo.cpp pattern doesn't work for imnodes!)
```cpp
// BAD: This works in regular ImGui windows but NOT in imnodes!
// Causes layout issues and scrollbars in node contexts
ImGui::Dummy(ImVec2(dummyWidth, 0));
ImGui::SameLine(0, 0);
ImGui::TextUnformatted(txt);  // Wrong for imnodes!
```

**‚ùå WRONG**: Manual cursor positioning
```cpp
// BAD: SetCursorPosX() fights with ImNodes' internal layout
const float leftEdge = ImGui::GetCursorPosX();
ImGui::SetCursorPosX(leftEdge + nodeContentWidth - textWidth);  // Breaks!
```

**‚ùå WRONG**: GetContentRegionAvail() causes infinite scrollbars!
```cpp
// BAD: GetContentRegionAvail() changes as you add content!
// Creates feedback loop in fixed-size nodes
const float availWidth = ImGui::GetContentRegionAvail().x;
float x = cursorX + (availWidth - textWidth);  // Infinite scaling!
```

**Why `Indent()` is the Correct Pattern for ImNodes**:
- **Official ImNodes pattern**: Used in ALL official imnodes examples
- **Works with ImNodes layout**: Respects node padding and spacing
- **No side effects**: Doesn't trigger scrollbars or layout recalculation
- **Simple and clean**: Single function call, no SameLine() needed

**Example from Official ImNodes (color_node_editor.cpp:351-356)**:
```cpp
ImNodes::BeginOutputAttribute(node.id);
const float label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - label_width);  // ‚Üê This is the pattern!
ImGui::TextUnformatted("result");
ImNodes::EndOutputAttribute();
```

**Key Insight**: `Dummy()` is used in imnodes to SET node minimum width (line 425), NOT for text alignment!

**Reference**: `ImGuiNodeEditorComponent.cpp` lines 1976-1985

---

### 8.2 Output Pin Circle Positioning (CRITICAL!)

**Problem**: The pin circle itself can be positioned with an offset from the text, creating additional gap.

**‚ùå WRONG**: Adding offset to pin position
```cpp
const float PIN_CIRCLE_OFFSET = 8.0f;  // Creates 8px gap!
float x_pos = pinMax.x + PIN_CIRCLE_OFFSET;
attrPositions[attr] = ImVec2(x_pos, y_center);
```

**‚úÖ CORRECT**: Zero offset - pin circle at text edge
```cpp
// Text is right-aligned to nodeContentWidth
// Pin circle positioned RIGHT at the edge
float x_pos = pinMax.x;  // No offset!
attrPositions[attr] = ImVec2(x_pos, y_center);
```

**Complete Flow**:
1. Text is right-aligned using `rightLabelWithinWidth` (0px padding)
2. `pinMax.x` captures the rightmost edge of the text area
3. Pin circle is positioned AT `pinMax.x` with no additional offset
4. Result: Pin circle touches text, which touches node border

**Reference**: `ImGuiNodeEditorComponent.cpp` lines 2175-2181, 2061-2067

---

### 8.3 SameLine Spacing Patterns

**From imgui_demo.cpp**:

```cpp
// Zero spacing (tight alignment)
ImGui::Text("Label");
ImGui::SameLine(0, 0);  // Second param = 0 removes extra spacing
ImGui::Button("Button");

// Small spacing (5px)
ImGui::ProgressBar(0.5f);
ImGui::SameLine(0, 5);  // 5px gap
ImGui::Text("50%%");

// Default spacing
ImGui::Checkbox("Option", &flag);
ImGui::SameLine();  // Uses style.ItemSpacing.x
HelpMarker("Tooltip text");
```

**Rule**: Use `SameLine(0, 0)` when you want elements visually "touching" (like pin labels to pins).

---

## üì¶ 9. ImNodes-Specific Patterns (FROM OFFICIAL EXAMPLES)

### 9.1 Node Content Width Management

**Pattern**: Use fixed widths, NOT GetContentRegionAvail()

```cpp
// From color_node_editor.cpp:314, 363, 415, 482
const float node_width = 100.0f;  // Fixed width for predictable layout
```

**Use Dummy() to set minimum width**:
```cpp
// From color_node_editor.cpp:425
ImGui::Dummy(ImVec2(node_width, 0.f));  // At START of node content
```

**Why Fixed Width**:
- Nodes don't resize dynamically like windows
- Prevents feedback loops and scrollbars
- All examples use hardcoded values (100.0f, 120.0f)

---

### 9.2 Input Attribute Pattern (Left Side)

**Structure**: Text first, then optional control

```cpp
// From color_node_editor.cpp:321-331
ImNodes::BeginInputAttribute(pin_id);
const float label_width = ImGui::CalcTextSize("left").x;
ImGui::TextUnformatted("left");

// If pin not connected, show input control
if (not_connected)
{
    ImGui::SameLine();
    ImGui::PushItemWidth(node_width - label_width);
    ImGui::DragFloat("##hidelabel", &value, 0.01f);
    ImGui::PopItemWidth();
}
ImNodes::EndInputAttribute();
```

**Key Points**:
- Label first, control after (if shown)
- Use `SameLine()` to put control next to label
- `PushItemWidth(node_width - label_width)` ensures control fits

---

### 9.3 Output Attribute Pattern (Right Side)

**Structure**: Indent first, text, then Unindent (NO SameLine!)

```cpp
// From color_node_editor.cpp:351-356 (with Unindent() added for persistence prevention)
ImNodes::BeginOutputAttribute(pin_id);
const float label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - label_width);  // ‚Üê Right-align!
ImGui::TextUnformatted("result");
ImGui::Unindent(node_width - label_width);  // ‚Üê Reset indent! CRITICAL!
ImNodes::EndOutputAttribute();
```

**Critical**: 
- Use `Indent()` for right-alignment, NOT Dummy() + SameLine()!
- **ALWAYS** call `Unindent()` to match `Indent()` - indent is persistent!

**Why Unindent() is Required**:
The imnodes examples work because they only have ONE output per node, so the indent doesn't affect anything else. In our multi-pin nodes, failing to unindent causes ALL subsequent elements to be indented cumulatively, creating the "red line" alignment bug where all text appears at the same wrong X position.

---

### 9.4 Static Attribute Pattern (No Pin)

**Structure**: For controls that don't connect to anything

```cpp
// From save_load.cpp:69-73, multi_editor.cpp:65-69
ImNodes::BeginStaticAttribute(attr_id);
ImGui::PushItemWidth(120.f);
ImGui::DragFloat("value", &value, 0.01f);
ImGui::PopItemWidth();
ImNodes::EndStaticAttribute();
```

**Use Cases**:
- Node settings/parameters
- Controls that affect node behavior
- UI elements without data flow

---

### 9.5 Node Layout Best Practices

**From ALL imnodes examples**:

1. **Title bar always first**:
```cpp
ImNodes::BeginNode(node_id);
ImNodes::BeginNodeTitleBar();
ImGui::TextUnformatted("node name");
ImNodes::EndNodeTitleBar();
// ... content ...
ImNodes::EndNode();
```

2. **Use Spacing() between sections**:
```cpp
// From color_node_editor.cpp:348, 400, 441, 458, 508
ImGui::Spacing();  // Visual separation
```

3. **Input pins before output pins**:
```cpp
// Input pins (left side)
ImNodes::BeginInputAttribute(...);
// Output pins (right side)  
ImNodes::BeginOutputAttribute(...);
```

4. **Calculate widths based on text**:
```cpp
const float label_width = ImGui::CalcTextSize("label").x;
```

---

### 9.6 Common Mistakes to Avoid

**‚ùå DON'T**: Forget to call Unindent() (CRITICAL BUG!)
```cpp
// BAD: Indent persists and affects all subsequent elements!
ImGui::Indent(node_width - text_width);
ImGui::Text("out");
// Missing Unindent() causes "red line" alignment bug!
```

**‚úÖ DO**: Always match Indent() with Unindent()
```cpp
ImGui::Indent(node_width - text_width);
ImGui::Text("out");
ImGui::Unindent(node_width - text_width);  // CRITICAL!
```

**‚ùå DON'T**: Use Dummy() + SameLine() for output text
```cpp
// This is for ImGui windows, NOT imnodes!
ImGui::Dummy(ImVec2(width, 0));
ImGui::SameLine();
ImGui::Text("out");
```

**‚ùå DON'T**: Use GetContentRegionAvail() or -1 width in nodes
```cpp
float w = ImGui::GetContentRegionAvail().x;  // Causes scrollbars!
ImGui::ProgressBar(progress, ImVec2(-1, 0), "");  // -1 width also causes infinite scaling!
```

**‚úÖ DO**: Use fixed widths from itemWidth parameter
```cpp
const float node_width = 240.0f;
ImGui::ProgressBar(progress, ImVec2(itemWidth, 0), "");  // Fixed width!
```

**Real-world bug**: MIDI Player initially used `ImVec2(-1, 0)` for progress bar, causing infinite right-side scaling. Fixed by using `ImVec2(itemWidth, 0)`.

**‚ùå DON'T**: Manually position with SetCursorPosX()
```cpp
ImGui::SetCursorPosX(x);  // Fights with ImNodes layout
```

**‚úÖ DO**: Let ImNodes handle positioning with Indent()
```cpp
ImGui::Indent(amount);
```

---

### 9.7 Complete Node Example (From Official Examples)

```cpp
const float node_width = 100.0f;
ImNodes::BeginNode(node_id);

// Title
ImNodes::BeginNodeTitleBar();
ImGui::TextUnformatted("add");
ImNodes::EndNodeTitleBar();

// Input pin with optional control
ImNodes::BeginInputAttribute(input_id);
const float label_width = ImGui::CalcTextSize("left").x;
ImGui::TextUnformatted("left");
if (!is_connected)
{
    ImGui::SameLine();
    ImGui::PushItemWidth(node_width - label_width);
    ImGui::DragFloat("##hide", &value, 0.01f);
    ImGui::PopItemWidth();
}
ImNodes::EndInputAttribute();

ImGui::Spacing();  // Visual separation

// Output pin (right-aligned)
ImNodes::BeginOutputAttribute(output_id);
const float out_label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - out_label_width);
ImGui::TextUnformatted("result");
ImNodes::EndOutputAttribute();

ImNodes::EndNode();
```

**Reference**: color_node_editor.cpp:313-359, save_load.cpp:57-82, multi_editor.cpp:54-78

---

## ‚úÖ 10. Pre-Flight Checklist

Before committing any node UI:

- [ ] No `ImGui::Separator()` or `ImGui::SeparatorText()` used
- [ ] All sections use `ImGui::TextColored()` + `ImGui::Spacing()`
- [ ] Every control has a `HelpMarker()` tooltip
- [ ] Modulated parameters have color-coding
- [ ] All tables use `NoHostExtendX` + `WidthFixed` columns
- [ ] Unique IDs for all widgets (check with `##` or `PushID()`)
- [ ] `ImGui::PushItemWidth(itemWidth)` at start
- [ ] `ImGui::PopItemWidth()` at end
- [ ] Real-time feedback where applicable (meters, plots)
- [ ] Output pins use `Indent()` for right-alignment (NOT Dummy() + SameLine!)
- [ ] Fixed node width used (NOT GetContentRegionAvail())
- [ ] Input pins: label first, control after with SameLine()
- [ ] Output pins: Indent() first, then text
- [ ] Tested with modulation connected and disconnected

---

## üìö 11. Reference Examples

**Best Implementations**:
1. **VCOModuleProcessor.h** (lines 28-220): Complete modern node with all patterns
2. **MIDIFadersModuleProcessor.cpp** (lines 180-600): Table layouts, learn modes
3. **MIDIJogWheelModuleProcessor.cpp** (lines 140-340): Custom drawing, circular indicators

**imgui_demo.cpp Sections**:
- Lines 273-282: HelpMarker implementation
- Lines 1982-2032: PlotLines examples
- Lines 3552-3555: TextColored usage
- Lines 6800-7000: Custom drawing with ImDrawList

**imnodes Official Examples** (H:\0000_CODE\01_collider_pyo\imnode_examples\):
- **hello.cpp**: Basic node structure (lines 17-32)
- **color_node_editor.cpp**: Complete node patterns
  - Fixed width pattern (lines 314, 363, 415, 482)
  - Input attribute with control (lines 321-331)
  - Output attribute with Indent() (lines 351-356)
  - Dummy() for minimum width (line 425)
- **save_load.cpp**: Simple node with static attribute (lines 57-82)
- **multi_editor.cpp**: Multi-context management (lines 54-78)

---

## üî¢ 12. Multi-Voice & Collapsible UI Patterns

### 12.1 Collapsible Headers (For Polyphonic/Multi-Instance Modules)

When dealing with many similar controls (e.g., 32 voices in PolyVCO), use collapsible headers with proper state management.

**Pattern**:

```cpp
// Add Expand/Collapse All controls
static bool expandAllState = false;
static bool collapseAllState = false;

if (ImGui::SmallButton("Expand All")) {
    expandAllState = true;
}
ImGui::SameLine();
if (ImGui::SmallButton("Collapse All")) {
    collapseAllState = true;
}

ImGui::Spacing();

for (int i = 0; i < numVoices; ++i)
{
    ImGui::PushID(i);  // CRITICAL: Unique ID per iteration
    
    // CRITICAL: Use else-if to prevent SetNextItemOpen calls from overlapping
    if (expandAllState) {
        ImGui::SetNextItemOpen(true);
    }
    else if (collapseAllState) {
        ImGui::SetNextItemOpen(false);
    }
    else {
        // Default open state (first 4 only, on first use)
        ImGui::SetNextItemOpen(i < 4, ImGuiCond_Once);
    }
    
    // Color-code for visual distinction
    float hue = (float)i / (float)maxVoices;
    ImGui::PushStyleColor(ImGuiCol_Text, ImColor::HSV(hue, 0.7f, 1.0f).Value);
    
    if (ImGui::CollapsingHeader(("Voice " + juce::String(i+1)).toRawUTF8(),
                                ImGuiTreeNodeFlags_None))
    {
        ImGui::PopStyleColor();
        
        // Controls go here (see next section for table layout)
    }
    else
    {
        ImGui::PopStyleColor();
    }
    
    ImGui::PopID();
}

// Reset expand/collapse state after loop
expandAllState = false;
collapseAllState = false;
```

**Key Points**:
- `ImGui::PushID(i)` prevents ID conflicts between similar controls
- **CRITICAL**: Use `else-if` logic to prevent `SetNextItemOpen()` calls from overlapping! Only ONE call should execute per iteration
- `ImGuiCond_Once` ensures default state applies only on first use (but gets overwritten if not protected by else-if)
- **DO NOT** use `ImGuiTreeNodeFlags_SpanAvailWidth` or `ImGuiTreeNodeFlags_FramePadding` - they cause visual bleeding outside node bounds
- Use `ImGuiTreeNodeFlags_None` for clean, minimal headers in fixed-size nodes
- Color-coding helps distinguish voices at a glance

---

### 12.2 Table Layout Inside Collapsible Sections

For compact, multi-column layouts inside headers, use tables instead of Indent().

**Pattern**:

```cpp
if (ImGui::CollapsingHeader("Voice 1", ...))
{
    const float columnWidth = itemWidth / 3.0f;
    
    if (ImGui::BeginTable("voiceTable", 3,
                          ImGuiTableFlags_SizingFixedFit |
                          ImGuiTableFlags_NoBordersInBody,
                          ImVec2(itemWidth, 0)))
    {
        // Column 1
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);  // 8px padding
        ImGui::Combo("##wave", &wave, "Sine\0Saw\0Square\0\0");
        ImGui::TextUnformatted("Wave");
        ImGui::PopItemWidth();
        
        // Column 2
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);
        ImGui::SliderFloat("##freq", &freq, 20.0f, 20000.0f, "%.0f", 
                          ImGuiSliderFlags_Logarithmic);
        ImGui::TextUnformatted("Hz");
        ImGui::PopItemWidth();
        
        // Column 3
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);
        ImGui::SliderFloat("##gate", &gate, 0.0f, 1.0f, "%.2f");
        ImGui::TextUnformatted("Gate");
        ImGui::PopItemWidth();
        
        ImGui::EndTable();
    }
}
```

**Why Tables**:
- Avoids cumulative Indent() bugs
- Provides consistent column widths
- Handles overflow better than manual layout
- **CRITICAL**: Don't use `ImGuiTableFlags_RowBg` with fixed-size tables in nodes! Row backgrounds can bleed outside node boundaries. Use plain tables with `NoBordersInBody` only.

---

### 12.3 Parallel Pin Drawing (Multi-Voice Nodes)

For nodes with multiple voices/channels, use `helpers.drawParallelPins()` to align inputs with outputs.

**Pattern**:

```cpp
void drawIoPins(const NodePinHelpers& helpers) override
{
    // Global input (no output pairing)
    helpers.drawParallelPins("NumVoices Mod", 0, nullptr, -1);
    
    for (int i = 0; i < getEffectiveNumVoices(); ++i)
    {
        juce::String idx = juce::String(i + 1);
        
        // Pair primary input with output on same row
        helpers.drawParallelPins(("Freq " + idx + " Mod").toRawUTF8(), 
                                 1 + i,
                                 ("Voice " + idx).toRawUTF8(), 
                                 i);
        
        // Secondary inputs (no output pairing)
        helpers.drawParallelPins(("Wave " + idx + " Mod").toRawUTF8(), 
                                 1 + MAX_VOICES + i, 
                                 nullptr, -1);
        helpers.drawParallelPins(("Gate " + idx + " Mod").toRawUTF8(), 
                                 1 + (2 * MAX_VOICES) + i, 
                                 nullptr, -1);
    }
}
```

**Why Parallel Pins**:
- Creates visual alignment between related inputs/outputs
- Reduces vertical node height
- Makes signal flow clearer
- Matches MultiSequencer pattern for consistency

**Signature**:
```cpp
void drawParallelPins(const char* inputLabel, int inputChannel,
                     const char* outputLabel, int outputChannel);
```

Pass `nullptr` and `-1` for outputLabel/outputChannel when there's no output on that row.

---

### 12.4 Complete Example: PolyVCO Node

See `juce/Source/audio/modules/PolyVCOModuleProcessor.cpp` for the complete, production-ready implementation featuring:
- Expand/Collapse All buttons
- Color-coded collapsible headers (HSV hue cycling)
- 3-column table layout for voice parameters
- Parallel pin drawing with 3 inputs per voice + 1 output
- Live modulation feedback with "(mod)" indicators
- First 4 voices open by default

---

## üîÑ 13. Update Log

| Date | Version | Changes |
|------|---------|---------|
| 2025-10-24 | **2.3.2** | **üêõ DOUBLE CRITICAL FIX**: Fixed PolyVCO Expand/Collapse buttons + blue bleeding lines!<br>‚Ä¢ **Problem 1**: Expand/Collapse All buttons didn't work<br>‚Ä¢ **Root cause**: Multiple `SetNextItemOpen()` calls - last one wins! `ImGuiCond_Once` was overwriting button state<br>‚Ä¢ **Solution**: Use `else-if` logic to ensure only ONE SetNextItemOpen call executes<br>‚Ä¢ **Problem 2**: Blue lines from collapsing headers bleeding outside node<br>‚Ä¢ **Root cause**: `ImGuiTreeNodeFlags_SpanAvailWidth` and `FramePadding` extend beyond bounds<br>‚Ä¢ **Solution**: Use `ImGuiTreeNodeFlags_None` for minimal, clean headers<br>‚Ä¢ Updated Section 12.1 with critical else-if pattern and flag warnings |
| 2025-10-24 | **2.3.1** | **üêõ CRITICAL FIX**: Removed `ImGuiTableFlags_RowBg` from PolyVCO tables!<br>‚Ä¢ **Problem**: Blue row backgrounds were bleeding outside node boundaries<br>‚Ä¢ **Root cause**: `RowBg` creates backgrounds that extend beyond fixed-size table constraints in nodes<br>‚Ä¢ **Solution**: Use `SizingFixedFit + NoBordersInBody` WITHOUT `RowBg` flag<br>‚Ä¢ Updated Section 12.2 with warning about RowBg in fixed-size nodes<br>‚Ä¢ Based on imgui_demo.cpp analysis: RowBg is for scrollable/dynamic tables, not fixed-size property grids |
| 2025-10-24 | **2.3** | **üéØ NEW PATTERNS**: Multi-Voice & Collapsible UI!<br>‚Ä¢ Added Section 12: Complete patterns for polyphonic nodes<br>‚Ä¢ **12.1**: Collapsible headers with Expand/Collapse All<br>‚Ä¢ **12.2**: Table-based layouts inside headers (avoids Indent bugs)<br>‚Ä¢ **12.3**: Parallel pin drawing for multi-voice nodes<br>‚Ä¢ **12.4**: PolyVCO as reference implementation<br>‚Ä¢ Fixed PolyVCO node (32 voices, 3-column tables, parallel pins)<br>‚Ä¢ Documented stable ID management and HSV color-coding |
| 2025-10-24 | **2.2** | **üö® CRITICAL BUG FIX**: Documented `-1` width issue in ProgressBar!<br>‚Ä¢ **Real-world bug**: MIDI Player used `ImVec2(-1, 0)` for progress bar width<br>‚Ä¢ **Symptom**: Infinite right-side scaling, unusable node<br>‚Ä¢ **Fix**: Use `ImVec2(itemWidth, 0)` with fixed width parameter<br>‚Ä¢ Updated Section 9.6 with progress bar example<br>‚Ä¢ Added warning about `-1` width alongside `GetContentRegionAvail()` issue |
| 2025-10-24 | **2.1** | **üö® CRITICAL BUG FIX**: Added `Unindent()` to match every `Indent()` call!<br>‚Ä¢ **Root cause**: Indent() is persistent and was affecting all subsequent elements<br>‚Ä¢ **Symptom**: All output labels appeared at same X position ("red line" bug)<br>‚Ä¢ **Fix**: Always call `ImGui::Unindent(amount)` after `ImGui::Indent(amount)`<br>‚Ä¢ Updated Section 9.3 with Unindent() requirement<br>‚Ä¢ Added new Common Mistake #1: Forgetting Unindent()<br>**Why imnodes examples didn't show this**: They only have ONE output per node! |
| 2025-10-24 | **2.0** | **üéØ MAJOR UPDATE**: Analyzed ALL official imnodes examples. Discovered `ImGui::Indent()` is the CORRECT pattern (NOT Dummy()!).<br>‚Ä¢ Added comprehensive Section 9: ImNodes-Specific Patterns<br>‚Ä¢ Documented input/output attribute patterns from official examples<br>‚Ä¢ Added complete node example with all best practices<br>‚Ä¢ Updated all code to use Indent() for output pin alignment<br>‚Ä¢ Expanded reference section with imnodes examples<br>**Breaking insight**: imgui_demo.cpp patterns don't always apply to imnodes! |
| 2025-10-24 | 1.6 | ~~Dummy() + SameLine() approach~~ (WRONG for imnodes, fixed in v2.0) |
| 2025-10-24 | 1.5 | ~~Manual cursor positioning~~ (WRONG, fixed in v2.0) |
| 2025-10-24 | 1.4 | ~~GetContentRegionAvail()~~ (caused scrollbars, fixed in v2.0) |
| 2025-10-24 | 1.3 | **CRITICAL FIX**: Eliminated PIN_CIRCLE_OFFSET (was 8px). Added Section 8.2: Output Pin Circle Positioning. Pin circles now positioned at pinMax.x with zero offset for perfect node border alignment. |
| 2025-10-24 | 1.2 | Further reduced pin padding from 2px to 0px for maximum tightness. Updated all examples and checklist. |
| 2025-10-24 | 1.1 | Added Section 8: Pin Label Spacing (CRITICAL!). Fixed output pin text gap issue by reducing padding from 8px to 2px. Added SameLine spacing patterns from imgui_demo.cpp. |
| 2025-10-24 | 1.0 | Initial guide created. Added separator fix, color-coding patterns, tooltip system. |

---

## üìù 12. Contributing to This Guide

When you discover a new pattern or fix an issue:

1. Document it here with a clear example
2. Reference the source file and line numbers
3. Explain WHY this pattern is better
4. Add to the Pre-Flight Checklist if applicable
5. Update the version number and log

**This guide is a living document!** Update it after every successful node redesign.

---

**End of Guide** | Version 2.3.2 | 2025-10-24



================================================================================
FILE: imgui_demo.cpp
================================================================================


// dear imgui, v1.92.5 WIP
// (demo code)

// Help:
// - Read FAQ at http://dearimgui.com/faq
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Need help integrating Dear ImGui in your codebase?
//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started
//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.
// Read top of imgui.cpp and imgui.h for many details, documentation, comments, links.
// Get the latest version at https://github.com/ocornut/imgui

// How to easily locate code?
// - Use Tools->Item Picker to debug break in code by clicking any widgets: https://github.com/ocornut/imgui/wiki/Debug-Tools
// - Browse an online version the demo with code linked to hovered widgets: https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html
// - Find a visible string and search for it in the code!

//---------------------------------------------------
// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!
//---------------------------------------------------
// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:
// Think again! It is the most useful reference code that you and other coders will want to refer to and call.
// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!
// Also include Metrics! ItemPicker! DebugLog! and other debug features.
// Removing this file from your project is hindering access to documentation for everyone in your team,
// likely leading you to poorer usage of the library.
// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().
// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be
// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.
// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.
// Thank you,
// -Your beloved friend, imgui_demo.cpp (which you won't delete)

//--------------------------------------------
// ABOUT THE MEANING OF THE 'static' KEYWORD:
//--------------------------------------------
// In this demo code, we frequently use 'static' variables inside functions.
// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.
// Think of "static int n = 0;" as "global int n = 0;" !
// We do this IN THE DEMO because we want:
// - to gather code and data in the same place.
// - to make the demo source code faster to read, faster to change, smaller in size.
// - it is also a convenient way of storing simple UI related information as long as your function
//   doesn't need to be reentrant or used in multiple threads.
// This might be a pattern you will want to use in your code, but most of the data you would be working
// with in a complex codebase is likely going to be stored outside your functions.

//-----------------------------------------
// ABOUT THE CODING STYLE OF OUR DEMO CODE
//-----------------------------------------
// The Demo code in this file is designed to be easy to copy-and-paste into your application!
// Because of this:
// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.
// - We try to declare static variables in the local scope, as close as possible to the code using them.
// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.
// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided
//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional
//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.
//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.

// Navigating this file:
// - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
// - You can search/grep for all sections listed in the index to find the section.

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Helpers
// [SECTION] Demo Window / ShowDemoWindow()
// [SECTION] DemoWindowMenuBar()
// [SECTION] Helpers: ExampleTreeNode, ExampleMemberInfo (for use by Property Editor & Multi-Select demos)
// [SECTION] DemoWindowWidgetsBasic()
// [SECTION] DemoWindowWidgetsBullets()
// [SECTION] DemoWindowWidgetsCollapsingHeaders()
// [SECTION] DemoWindowWidgetsComboBoxes()
// [SECTION] DemoWindowWidgetsColorAndPickers()
// [SECTION] DemoWindowWidgetsDataTypes()
// [SECTION] DemoWindowWidgetsDisableBlocks()
// [SECTION] DemoWindowWidgetsDragAndDrop()
// [SECTION] DemoWindowWidgetsDragsAndSliders()
// [SECTION] DemoWindowWidgetsFonts()
// [SECTION] DemoWindowWidgetsImages()
// [SECTION] DemoWindowWidgetsListBoxes()
// [SECTION] DemoWindowWidgetsMultiComponents()
// [SECTION] DemoWindowWidgetsPlotting()
// [SECTION] DemoWindowWidgetsProgressBars()
// [SECTION] DemoWindowWidgetsQueryingStatuses()
// [SECTION] DemoWindowWidgetsSelectables()
// [SECTION] DemoWindowWidgetsSelectionAndMultiSelect()
// [SECTION] DemoWindowWidgetsTabs()
// [SECTION] DemoWindowWidgetsText()
// [SECTION] DemoWindowWidgetsTextFilter()
// [SECTION] DemoWindowWidgetsTextInput()
// [SECTION] DemoWindowWidgetsTooltips()
// [SECTION] DemoWindowWidgetsTreeNodes()
// [SECTION] DemoWindowWidgetsVerticalSliders()
// [SECTION] DemoWindowWidgets()
// [SECTION] DemoWindowLayout()
// [SECTION] DemoWindowPopups()
// [SECTION] DemoWindowTables()
// [SECTION] DemoWindowInputs()
// [SECTION] About Window / ShowAboutWindow()
// [SECTION] Style Editor / ShowStyleEditor()
// [SECTION] User Guide / ShowUserGuide()
// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()
// [SECTION] Example App: Debug Console / ShowExampleAppConsole()
// [SECTION] Example App: Debug Log / ShowExampleAppLog()
// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()
// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()
// [SECTION] Example App: Long Text / ShowExampleAppLongText()
// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()
// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()
// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()
// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()
// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()
// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()
// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()
// [SECTION] Example App: Assets Browser / ShowExampleAppAssetsBrowser()

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DISABLE

// System includes
#include <ctype.h>          // toupper
#include <limits.h>         // INT_MIN, INT_MAX
#include <math.h>           // sqrtf, powf, cosf, sinf, floorf, ceilf
#include <stdio.h>          // vsnprintf, sscanf, printf
#include <stdlib.h>         // NULL, malloc, free, atoi
#include <stdint.h>         // intptr_t
#if !defined(_MSC_VER) || _MSC_VER >= 1800
#include <inttypes.h>       // PRId64/PRIu64, not avail in some MinGW headers.
#endif
#ifdef __EMSCRIPTEN__
#include <emscripten/version.h>     // __EMSCRIPTEN_major__ etc.
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to an 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                     // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                           // yes, they are more terse.
#pragma clang diagnostic ignored "-Wdeprecated-declarations"        // warning: 'xx' is deprecated: The POSIX name for this..   // for strdup used in demo code (so user can copy & paste the code)
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning: cast to 'void *' from smaller integer type
#pragma clang diagnostic ignored "-Wformat"                         // warning: format specifies type 'int' but the argument has type 'unsigned int'
#pragma clang diagnostic ignored "-Wformat-security"                // warning: format string is not a string literal
#pragma clang diagnostic ignored "-Wexit-time-destructors"          // warning: declaration requires an exit-time destructor    // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wunused-macros"                  // warning: macro is not used                               // we define snprintf/vsnprintf on Windows so they are available, but not always used.
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                   // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wreserved-id-macro"              // warning: macro name is a reserved identifier
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"            // warning: 'xxx' is an unsafe pointer used for buffer access
#pragma clang diagnostic ignored "-Wswitch-default"                 // warning: 'switch' missing 'default' label
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wfloat-equal"                      // warning: comparing floating-point with '==' or '!=' is unsafe
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"              // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                           // warning: format '%p' expects argument of type 'int'/'void*', but argument X has type 'unsigned int'/'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wformat-security"                  // warning: format string is not a string literal (potentially insecure)
#pragma GCC diagnostic ignored "-Wdouble-promotion"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"                       // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wmisleading-indentation"           // [__GNUC__ >= 6] warning: this 'if' clause does not guard this statement      // GCC 6.0+ only. See #883 on GitHub.
#pragma GCC diagnostic ignored "-Wstrict-overflow"                  // warning: assuming signed overflow does not occur when simplifying division / ..when changing X +- C1 cmp C2 to X cmp C2 -+ C1
#pragma GCC diagnostic ignored "-Wcast-qual"                        // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

// Play it nice with Windows users (Update: May 2018, Notepad now supports Unix-style carriage returns!)
#ifdef _WIN32
#define IM_NEWLINE  "\r\n"
#else
#define IM_NEWLINE  "\n"
#endif

// Helpers
#if defined(_MSC_VER) && !defined(snprintf)
#define snprintf    _snprintf
#endif
#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf   _vsnprintf
#endif

// Format specifiers for 64-bit values (hasn't been decently standardized before VS2013)
#if !defined(PRId64) && defined(_MSC_VER)
#define PRId64 "I64d"
#define PRIu64 "I64u"
#elif !defined(PRId64)
#define PRId64 "lld"
#define PRIu64 "llu"
#endif

// Helpers macros
// We normally try to not use many helpers in imgui_demo.cpp in order to make code easier to copy and paste,
// but making an exception here as those are largely simplifying code...
// In other imgui sources we can use nicer internal functions from imgui_internal.h (ImMin/ImMax) but not in the demo.
#define IM_MIN(A, B)            (((A) < (B)) ? (A) : (B))
#define IM_MAX(A, B)            (((A) >= (B)) ? (A) : (B))
#define IM_CLAMP(V, MN, MX)     ((V) < (MN) ? (MN) : (V) > (MX) ? (MX) : (V))

// Enforce cdecl calling convention for functions called by the standard library,
// in case compilation settings changed the default to e.g. __vectorcall
#ifndef IMGUI_CDECL
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif
#endif

//-----------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-----------------------------------------------------------------------------

#if !defined(IMGUI_DISABLE_DEMO_WINDOWS)

// Forward Declarations
struct ImGuiDemoWindowData;
static void ShowExampleAppMainMenuBar();
static void ShowExampleAppAssetsBrowser(bool* p_open);
static void ShowExampleAppConsole(bool* p_open);
static void ShowExampleAppCustomRendering(bool* p_open);
static void ShowExampleAppDocuments(bool* p_open);
static void ShowExampleAppLog(bool* p_open);
static void ShowExampleAppLayout(bool* p_open);
static void ShowExampleAppPropertyEditor(bool* p_open, ImGuiDemoWindowData* demo_data);
static void ShowExampleAppSimpleOverlay(bool* p_open);
static void ShowExampleAppAutoResize(bool* p_open);
static void ShowExampleAppConstrainedResize(bool* p_open);
static void ShowExampleAppFullscreen(bool* p_open);
static void ShowExampleAppLongText(bool* p_open);
static void ShowExampleAppWindowTitles(bool* p_open);
static void ShowExampleMenuFile();

// We split the contents of the big ShowDemoWindow() function into smaller functions
// (because the link time of very large functions tends to grow non-linearly)
static void DemoWindowMenuBar(ImGuiDemoWindowData* demo_data);
static void DemoWindowWidgets(ImGuiDemoWindowData* demo_data);
static void DemoWindowLayout();
static void DemoWindowPopups();
static void DemoWindowTables();
static void DemoWindowColumns();
static void DemoWindowInputs();

// Helper tree functions used by Property Editor & Multi-Select demos
struct ExampleTreeNode;
static ExampleTreeNode* ExampleTree_CreateNode(const char* name, int uid, ExampleTreeNode* parent);
static void             ExampleTree_DestroyNode(ExampleTreeNode* node);

//-----------------------------------------------------------------------------
// [SECTION] Helpers
//-----------------------------------------------------------------------------

// Helper to display a little (?) mark which shows a tooltip when hovered.
// In your own code you may want to display an actual icon if you are using a merged icon fonts (see docs/FONTS.md)
static void HelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

// Helper to wire demo markers located in code to an interactive browser
typedef void (*ImGuiDemoMarkerCallback)(const char* file, int line, const char* section, void* user_data);
extern ImGuiDemoMarkerCallback      GImGuiDemoMarkerCallback;
extern void*                        GImGuiDemoMarkerCallbackUserData;
ImGuiDemoMarkerCallback             GImGuiDemoMarkerCallback = NULL;
void*                               GImGuiDemoMarkerCallbackUserData = NULL;
#define IMGUI_DEMO_MARKER(section)  do { if (GImGuiDemoMarkerCallback != NULL) GImGuiDemoMarkerCallback(__FILE__, __LINE__, section, GImGuiDemoMarkerCallbackUserData); } while (0)

//-----------------------------------------------------------------------------
// [SECTION] Demo Window / ShowDemoWindow()
//-----------------------------------------------------------------------------

// Data to be shared across different functions of the demo.
struct ImGuiDemoWindowData
{
    // Examples Apps (accessible from the "Examples" menu)
    bool ShowMainMenuBar = false;
    bool ShowAppAssetsBrowser = false;
    bool ShowAppConsole = false;
    bool ShowAppCustomRendering = false;
    bool ShowAppDocuments = false;
    bool ShowAppLog = false;
    bool ShowAppLayout = false;
    bool ShowAppPropertyEditor = false;
    bool ShowAppSimpleOverlay = false;
    bool ShowAppAutoResize = false;
    bool ShowAppConstrainedResize = false;
    bool ShowAppFullscreen = false;
    bool ShowAppLongText = false;
    bool ShowAppWindowTitles = false;

    // Dear ImGui Tools (accessible from the "Tools" menu)
    bool ShowMetrics = false;
    bool ShowDebugLog = false;
    bool ShowIDStackTool = false;
    bool ShowStyleEditor = false;
    bool ShowAbout = false;

    // Other data
    bool DisableSections = false;
    ExampleTreeNode* DemoTree = NULL;

    ~ImGuiDemoWindowData() { if (DemoTree) ExampleTree_DestroyNode(DemoTree); }
};

// Demonstrate most Dear ImGui features (this is big function!)
// You may execute this function to experiment with the UI and understand what it does.
// You may then search for keywords in the code when you are interested by a specific feature.
void ImGui::ShowDemoWindow(bool* p_open)
{
    // Exceptionally add an extra assert here for people confused about initial Dear ImGui setup
    // Most functions would normally just assert/crash if the context is missing.
    IM_ASSERT(ImGui::GetCurrentContext() != NULL && "Missing Dear ImGui context. Refer to examples app!");

    // Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.
    IMGUI_CHECKVERSION();

    // Stored data
    static ImGuiDemoWindowData demo_data;

    // Examples Apps (accessible from the "Examples" menu)
    if (demo_data.ShowMainMenuBar)          { ShowExampleAppMainMenuBar(); }
    if (demo_data.ShowAppDocuments)         { ShowExampleAppDocuments(&demo_data.ShowAppDocuments); }
    if (demo_data.ShowAppAssetsBrowser)     { ShowExampleAppAssetsBrowser(&demo_data.ShowAppAssetsBrowser); }
    if (demo_data.ShowAppConsole)           { ShowExampleAppConsole(&demo_data.ShowAppConsole); }
    if (demo_data.ShowAppCustomRendering)   { ShowExampleAppCustomRendering(&demo_data.ShowAppCustomRendering); }
    if (demo_data.ShowAppLog)               { ShowExampleAppLog(&demo_data.ShowAppLog); }
    if (demo_data.ShowAppLayout)            { ShowExampleAppLayout(&demo_data.ShowAppLayout); }
    if (demo_data.ShowAppPropertyEditor)    { ShowExampleAppPropertyEditor(&demo_data.ShowAppPropertyEditor, &demo_data); }
    if (demo_data.ShowAppSimpleOverlay)     { ShowExampleAppSimpleOverlay(&demo_data.ShowAppSimpleOverlay); }
    if (demo_data.ShowAppAutoResize)        { ShowExampleAppAutoResize(&demo_data.ShowAppAutoResize); }
    if (demo_data.ShowAppConstrainedResize) { ShowExampleAppConstrainedResize(&demo_data.ShowAppConstrainedResize); }
    if (demo_data.ShowAppFullscreen)        { ShowExampleAppFullscreen(&demo_data.ShowAppFullscreen); }
    if (demo_data.ShowAppLongText)          { ShowExampleAppLongText(&demo_data.ShowAppLongText); }
    if (demo_data.ShowAppWindowTitles)      { ShowExampleAppWindowTitles(&demo_data.ShowAppWindowTitles); }

    // Dear ImGui Tools (accessible from the "Tools" menu)
    if (demo_data.ShowMetrics)              { ImGui::ShowMetricsWindow(&demo_data.ShowMetrics); }
    if (demo_data.ShowDebugLog)             { ImGui::ShowDebugLogWindow(&demo_data.ShowDebugLog); }
    if (demo_data.ShowIDStackTool)          { ImGui::ShowIDStackToolWindow(&demo_data.ShowIDStackTool); }
    if (demo_data.ShowAbout)                { ImGui::ShowAboutWindow(&demo_data.ShowAbout); }
    if (demo_data.ShowStyleEditor)
    {
        ImGui::Begin("Dear ImGui Style Editor", &demo_data.ShowStyleEditor);
        ImGui::ShowStyleEditor();
        ImGui::End();
    }

    // Demonstrate the various window flags. Typically you would just use the default!
    static bool no_titlebar = false;
    static bool no_scrollbar = false;
    static bool no_menu = false;
    static bool no_move = false;
    static bool no_resize = false;
    static bool no_collapse = false;
    static bool no_close = false;
    static bool no_nav = false;
    static bool no_background = false;
    static bool no_bring_to_front = false;
    static bool unsaved_document = false;

    ImGuiWindowFlags window_flags = 0;
    if (no_titlebar)        window_flags |= ImGuiWindowFlags_NoTitleBar;
    if (no_scrollbar)       window_flags |= ImGuiWindowFlags_NoScrollbar;
    if (!no_menu)           window_flags |= ImGuiWindowFlags_MenuBar;
    if (no_move)            window_flags |= ImGuiWindowFlags_NoMove;
    if (no_resize)          window_flags |= ImGuiWindowFlags_NoResize;
    if (no_collapse)        window_flags |= ImGuiWindowFlags_NoCollapse;
    if (no_nav)             window_flags |= ImGuiWindowFlags_NoNav;
    if (no_background)      window_flags |= ImGuiWindowFlags_NoBackground;
    if (no_bring_to_front)  window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus;
    if (unsaved_document)   window_flags |= ImGuiWindowFlags_UnsavedDocument;
    if (no_close)           p_open = NULL; // Don't pass our bool* to Begin

    // We specify a default position/size in case there's no data in the .ini file.
    // We only do it to make the demo applications a little more welcoming, but typically this isn't required.
    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(ImVec2(main_viewport->WorkPos.x + 650, main_viewport->WorkPos.y + 20), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(550, 680), ImGuiCond_FirstUseEver);

    // Main body of the Demo window starts here.
    if (!ImGui::Begin("Dear ImGui Demo", p_open, window_flags))
    {
        // Early out if the window is collapsed, as an optimization.
        ImGui::End();
        return;
    }

    // Most framed widgets share a common width settings. Remaining width is used for the label.
    // The width of the frame may be changed with PushItemWidth() or SetNextItemWidth().
    // - Positive value for absolute size, negative value for right-alignment.
    // - The default value is about GetWindowWidth() * 0.65f.
    // - See 'Demo->Layout->Widgets Width' for details.
    // Here we change the frame width based on how much width we want to give to the label.
    const float label_width_base = ImGui::GetFontSize() * 12;               // Some amount of width for label, based on font size.
    const float label_width_max = ImGui::GetContentRegionAvail().x * 0.40f; // ...but always leave some room for framed widgets.
    const float label_width = IM_MIN(label_width_base, label_width_max);
    ImGui::PushItemWidth(-label_width);                                     // Right-align: framed items will leave 'label_width' available for the label.
    //ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x * 0.40f);       // e.g. Use 40% width for framed widgets, leaving 60% width for labels.
    //ImGui::PushItemWidth(-ImGui::GetContentRegionAvail().x * 0.40f);      // e.g. Use 40% width for labels, leaving 60% width for framed widgets.
    //ImGui::PushItemWidth(ImGui::GetFontSize() * -12);                     // e.g. Use XXX width for labels, leaving the rest for framed widgets.

    // Menu Bar
    DemoWindowMenuBar(&demo_data);

    ImGui::Text("dear imgui says hello! (%s) (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);
    ImGui::Spacing();

    IMGUI_DEMO_MARKER("Help");
    if (ImGui::CollapsingHeader("Help"))
    {
        ImGui::SeparatorText("ABOUT THIS DEMO:");
        ImGui::BulletText("Sections below are demonstrating many aspects of the library.");
        ImGui::BulletText("The \"Examples\" menu above leads to more demo contents.");
        ImGui::BulletText("The \"Tools\" menu above gives access to: About Box, Style Editor,\n"
                          "and Metrics/Debugger (general purpose Dear ImGui debugging tool).");

        ImGui::SeparatorText("PROGRAMMER GUIDE:");
        ImGui::BulletText("See the ShowDemoWindow() code in imgui_demo.cpp. <- you are here!");
        ImGui::BulletText("See comments in imgui.cpp.");
        ImGui::BulletText("See example applications in the examples/ folder.");
        ImGui::BulletText("Read the FAQ at ");
        ImGui::SameLine(0, 0);
        ImGui::TextLinkOpenURL("https://www.dearimgui.com/faq/");
        ImGui::BulletText("Set 'io.ConfigFlags |= NavEnableKeyboard' for keyboard controls.");
        ImGui::BulletText("Set 'io.ConfigFlags |= NavEnableGamepad' for gamepad controls.");

        ImGui::SeparatorText("USER GUIDE:");
        ImGui::ShowUserGuide();
    }

    IMGUI_DEMO_MARKER("Configuration");
    if (ImGui::CollapsingHeader("Configuration"))
    {
        ImGuiIO& io = ImGui::GetIO();

        if (ImGui::TreeNode("Configuration##2"))
        {
            ImGui::SeparatorText("General");
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableKeyboard",    &io.ConfigFlags, ImGuiConfigFlags_NavEnableKeyboard);
            ImGui::SameLine(); HelpMarker("Enable keyboard controls.");
            ImGui::CheckboxFlags("io.ConfigFlags: NavEnableGamepad",     &io.ConfigFlags, ImGuiConfigFlags_NavEnableGamepad);
            ImGui::SameLine(); HelpMarker("Enable gamepad controls. Require backend to set io.BackendFlags |= ImGuiBackendFlags_HasGamepad.\n\nRead instructions in imgui.cpp for details.");
            ImGui::CheckboxFlags("io.ConfigFlags: NoMouse",              &io.ConfigFlags, ImGuiConfigFlags_NoMouse);
            ImGui::SameLine(); HelpMarker("Instruct dear imgui to disable mouse inputs and interactions.");

            // The "NoMouse" option can get us stuck with a disabled mouse! Let's provide an alternative way to fix it:
            if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
            {
                if (fmodf((float)ImGui::GetTime(), 0.40f) < 0.20f)
                {
                    ImGui::SameLine();
                    ImGui::Text("<<PRESS SPACE TO DISABLE>>");
                }
                // Prevent both being checked
                if (ImGui::IsKeyPressed(ImGuiKey_Space) || (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard))
                    io.ConfigFlags &= ~ImGuiConfigFlags_NoMouse;
            }

            ImGui::CheckboxFlags("io.ConfigFlags: NoMouseCursorChange",  &io.ConfigFlags, ImGuiConfigFlags_NoMouseCursorChange);
            ImGui::SameLine(); HelpMarker("Instruct backend to not alter mouse cursor shape and visibility.");
            ImGui::CheckboxFlags("io.ConfigFlags: NoKeyboard", &io.ConfigFlags, ImGuiConfigFlags_NoKeyboard);
            ImGui::SameLine(); HelpMarker("Instruct dear imgui to disable keyboard inputs and interactions.");

            ImGui::Checkbox("io.ConfigInputTrickleEventQueue", &io.ConfigInputTrickleEventQueue);
            ImGui::SameLine(); HelpMarker("Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.");
            ImGui::Checkbox("io.MouseDrawCursor", &io.MouseDrawCursor);
            ImGui::SameLine(); HelpMarker("Instruct Dear ImGui to render a mouse cursor itself. Note that a mouse cursor rendered via your application GPU rendering path will feel more laggy than hardware cursor, but will be more in sync with your other visuals.\n\nSome desktop applications may use both kinds of cursors (e.g. enable software cursor only when resizing/dragging something).");

            ImGui::SeparatorText("Keyboard/Gamepad Navigation");
            ImGui::Checkbox("io.ConfigNavSwapGamepadButtons", &io.ConfigNavSwapGamepadButtons);
            ImGui::Checkbox("io.ConfigNavMoveSetMousePos", &io.ConfigNavMoveSetMousePos);
            ImGui::SameLine(); HelpMarker("Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult");
            ImGui::Checkbox("io.ConfigNavCaptureKeyboard", &io.ConfigNavCaptureKeyboard);
            ImGui::Checkbox("io.ConfigNavEscapeClearFocusItem", &io.ConfigNavEscapeClearFocusItem);
            ImGui::SameLine(); HelpMarker("Pressing Escape clears focused item.");
            ImGui::Checkbox("io.ConfigNavEscapeClearFocusWindow", &io.ConfigNavEscapeClearFocusWindow);
            ImGui::SameLine(); HelpMarker("Pressing Escape clears focused window.");
            ImGui::Checkbox("io.ConfigNavCursorVisibleAuto", &io.ConfigNavCursorVisibleAuto);
            ImGui::SameLine(); HelpMarker("Using directional navigation key makes the cursor visible. Mouse click hides the cursor.");
            ImGui::Checkbox("io.ConfigNavCursorVisibleAlways", &io.ConfigNavCursorVisibleAlways);
            ImGui::SameLine(); HelpMarker("Navigation cursor is always visible.");

            ImGui::SeparatorText("Windows");
            ImGui::Checkbox("io.ConfigWindowsResizeFromEdges", &io.ConfigWindowsResizeFromEdges);
            ImGui::SameLine(); HelpMarker("Enable resizing of windows from their edges and from the lower-left corner.\nThis requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback.");
            ImGui::Checkbox("io.ConfigWindowsMoveFromTitleBarOnly", &io.ConfigWindowsMoveFromTitleBarOnly);
            ImGui::Checkbox("io.ConfigWindowsCopyContentsWithCtrlC", &io.ConfigWindowsCopyContentsWithCtrlC); // [EXPERIMENTAL]
            ImGui::SameLine(); HelpMarker("*EXPERIMENTAL* CTRL+C copy the contents of focused window into the clipboard.\n\nExperimental because:\n- (1) has known issues with nested Begin/End pairs.\n- (2) text output quality varies.\n- (3) text output is in submission order rather than spatial order.");
            ImGui::Checkbox("io.ConfigScrollbarScrollByPage", &io.ConfigScrollbarScrollByPage);
            ImGui::SameLine(); HelpMarker("Enable scrolling page by page when clicking outside the scrollbar grab.\nWhen disabled, always scroll to clicked location.\nWhen enabled, Shift+Click scrolls to clicked location.");

            ImGui::SeparatorText("Widgets");
            ImGui::Checkbox("io.ConfigInputTextCursorBlink", &io.ConfigInputTextCursorBlink);
            ImGui::SameLine(); HelpMarker("Enable blinking cursor (optional as some users consider it to be distracting).");
            ImGui::Checkbox("io.ConfigInputTextEnterKeepActive", &io.ConfigInputTextEnterKeepActive);
            ImGui::SameLine(); HelpMarker("Pressing Enter will keep item active and select contents (single-line only).");
            ImGui::Checkbox("io.ConfigDragClickToInputText", &io.ConfigDragClickToInputText);
            ImGui::SameLine(); HelpMarker("Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving).");
            ImGui::Checkbox("io.ConfigMacOSXBehaviors", &io.ConfigMacOSXBehaviors);
            ImGui::SameLine(); HelpMarker("Swap Cmd<>Ctrl keys, enable various MacOS style behaviors.");
            ImGui::Text("Also see Style->Rendering for rendering options.");

            // Also read: https://github.com/ocornut/imgui/wiki/Error-Handling
            ImGui::SeparatorText("Error Handling");

            ImGui::Checkbox("io.ConfigErrorRecovery", &io.ConfigErrorRecovery);
            ImGui::SameLine(); HelpMarker(
                "Options to configure how we handle recoverable errors.\n"
                "- Error recovery is not perfect nor guaranteed! It is a feature to ease development.\n"
                "- You not are not supposed to rely on it in the course of a normal application run.\n"
                "- Possible usage: facilitate recovery from errors triggered from a scripting language or after specific exceptions handlers.\n"
                "- Always ensure that on programmers seat you have at minimum Asserts or Tooltips enabled when making direct imgui API call! "
                "Otherwise it would severely hinder your ability to catch and correct mistakes!");
            ImGui::Checkbox("io.ConfigErrorRecoveryEnableAssert", &io.ConfigErrorRecoveryEnableAssert);
            ImGui::Checkbox("io.ConfigErrorRecoveryEnableDebugLog", &io.ConfigErrorRecoveryEnableDebugLog);
            ImGui::Checkbox("io.ConfigErrorRecoveryEnableTooltip", &io.ConfigErrorRecoveryEnableTooltip);
            if (!io.ConfigErrorRecoveryEnableAssert && !io.ConfigErrorRecoveryEnableDebugLog && !io.ConfigErrorRecoveryEnableTooltip)
                io.ConfigErrorRecoveryEnableAssert = io.ConfigErrorRecoveryEnableDebugLog = io.ConfigErrorRecoveryEnableTooltip = true;

            // Also read: https://github.com/ocornut/imgui/wiki/Debug-Tools
            ImGui::SeparatorText("Debug");
            ImGui::Checkbox("io.ConfigDebugIsDebuggerPresent", &io.ConfigDebugIsDebuggerPresent);
            ImGui::SameLine(); HelpMarker("Enable various tools calling IM_DEBUG_BREAK().\n\nRequires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.");
            ImGui::Checkbox("io.ConfigDebugHighlightIdConflicts", &io.ConfigDebugHighlightIdConflicts);
            ImGui::SameLine(); HelpMarker("Highlight and show an error message when multiple items have conflicting identifiers.");
            ImGui::BeginDisabled();
            ImGui::Checkbox("io.ConfigDebugBeginReturnValueOnce", &io.ConfigDebugBeginReturnValueOnce);
            ImGui::EndDisabled();
            ImGui::SameLine(); HelpMarker("First calls to Begin()/BeginChild() will return false.\n\nTHIS OPTION IS DISABLED because it needs to be set at application boot-time to make sense. Showing the disabled option is a way to make this feature easier to discover.");
            ImGui::Checkbox("io.ConfigDebugBeginReturnValueLoop", &io.ConfigDebugBeginReturnValueLoop);
            ImGui::SameLine(); HelpMarker("Some calls to Begin()/BeginChild() will return false.\n\nWill cycle through window depths then repeat. Windows should be flickering while running.");
            ImGui::Checkbox("io.ConfigDebugIgnoreFocusLoss", &io.ConfigDebugIgnoreFocusLoss);
            ImGui::SameLine(); HelpMarker("Option to deactivate io.AddFocusEvent(false) handling. May facilitate interactions with a debugger when focus loss leads to clearing inputs data.");
            ImGui::Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings);
            ImGui::SameLine(); HelpMarker("Option to save .ini data with extra comments (particularly helpful for Docking, but makes saving slower).");

            ImGui::TreePop();
            ImGui::Spacing();
        }

        IMGUI_DEMO_MARKER("Configuration/Backend Flags");
        if (ImGui::TreeNode("Backend Flags"))
        {
            HelpMarker(
                "Those flags are set by the backends (imgui_impl_xxx files) to specify their capabilities.\n"
                "Here we expose them as read-only fields to avoid breaking interactions with your backend.");

            // FIXME: Maybe we need a BeginReadonly() equivalent to keep label bright?
            ImGui::BeginDisabled();
            ImGui::CheckboxFlags("io.BackendFlags: HasGamepad",           &io.BackendFlags, ImGuiBackendFlags_HasGamepad);
            ImGui::CheckboxFlags("io.BackendFlags: HasMouseCursors",      &io.BackendFlags, ImGuiBackendFlags_HasMouseCursors);
            ImGui::CheckboxFlags("io.BackendFlags: HasSetMousePos",       &io.BackendFlags, ImGuiBackendFlags_HasSetMousePos);
            ImGui::CheckboxFlags("io.BackendFlags: RendererHasVtxOffset", &io.BackendFlags, ImGuiBackendFlags_RendererHasVtxOffset);
            ImGui::CheckboxFlags("io.BackendFlags: RendererHasTextures",  &io.BackendFlags, ImGuiBackendFlags_RendererHasTextures);
            ImGui::EndDisabled();

            ImGui::TreePop();
            ImGui::Spacing();
        }

        IMGUI_DEMO_MARKER("Configuration/Style, Fonts");
        if (ImGui::TreeNode("Style, Fonts"))
        {
            ImGui::Checkbox("Style Editor", &demo_data.ShowStyleEditor);
            ImGui::SameLine();
            HelpMarker("The same contents can be accessed in 'Tools->Style Editor' or by calling the ShowStyleEditor() function.");
            ImGui::TreePop();
            ImGui::Spacing();
        }

        IMGUI_DEMO_MARKER("Configuration/Capture, Logging");
        if (ImGui::TreeNode("Capture/Logging"))
        {
            HelpMarker(
                "The logging API redirects all text output so you can easily capture the content of "
                "a window or a block. Tree nodes can be automatically expanded.\n"
                "Try opening any of the contents below in this window and then click one of the \"Log To\" button.");
            ImGui::LogButtons();

            HelpMarker("You can also call ImGui::LogText() to output directly to the log without a visual output.");
            if (ImGui::Button("Copy \"Hello, world!\" to clipboard"))
            {
                ImGui::LogToClipboard();
                ImGui::LogText("Hello, world!");
                ImGui::LogFinish();
            }
            ImGui::TreePop();
        }
    }

    IMGUI_DEMO_MARKER("Window options");
    if (ImGui::CollapsingHeader("Window options"))
    {
        if (ImGui::BeginTable("split", 3))
        {
            ImGui::TableNextColumn(); ImGui::Checkbox("No titlebar", &no_titlebar);
            ImGui::TableNextColumn(); ImGui::Checkbox("No scrollbar", &no_scrollbar);
            ImGui::TableNextColumn(); ImGui::Checkbox("No menu", &no_menu);
            ImGui::TableNextColumn(); ImGui::Checkbox("No move", &no_move);
            ImGui::TableNextColumn(); ImGui::Checkbox("No resize", &no_resize);
            ImGui::TableNextColumn(); ImGui::Checkbox("No collapse", &no_collapse);
            ImGui::TableNextColumn(); ImGui::Checkbox("No close", &no_close);
            ImGui::TableNextColumn(); ImGui::Checkbox("No nav", &no_nav);
            ImGui::TableNextColumn(); ImGui::Checkbox("No background", &no_background);
            ImGui::TableNextColumn(); ImGui::Checkbox("No bring to front", &no_bring_to_front);
            ImGui::TableNextColumn(); ImGui::Checkbox("Unsaved document", &unsaved_document);
            ImGui::EndTable();
        }
    }

    // All demo contents
    DemoWindowWidgets(&demo_data);
    DemoWindowLayout();
    DemoWindowPopups();
    DemoWindowTables();
    DemoWindowInputs();

    // End of ShowDemoWindow()
    ImGui::PopItemWidth();
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowMenuBar()
//-----------------------------------------------------------------------------

static void DemoWindowMenuBar(ImGuiDemoWindowData* demo_data)
{
    IMGUI_DEMO_MARKER("Menu");
    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("Menu"))
        {
            IMGUI_DEMO_MARKER("Menu/File");
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Examples"))
        {
            IMGUI_DEMO_MARKER("Menu/Examples");
            ImGui::MenuItem("Main menu bar", NULL, &demo_data->ShowMainMenuBar);

            ImGui::SeparatorText("Mini apps");
            ImGui::MenuItem("Assets Browser", NULL, &demo_data->ShowAppAssetsBrowser);
            ImGui::MenuItem("Console", NULL, &demo_data->ShowAppConsole);
            ImGui::MenuItem("Custom rendering", NULL, &demo_data->ShowAppCustomRendering);
            ImGui::MenuItem("Documents", NULL, &demo_data->ShowAppDocuments);
            ImGui::MenuItem("Log", NULL, &demo_data->ShowAppLog);
            ImGui::MenuItem("Property editor", NULL, &demo_data->ShowAppPropertyEditor);
            ImGui::MenuItem("Simple layout", NULL, &demo_data->ShowAppLayout);
            ImGui::MenuItem("Simple overlay", NULL, &demo_data->ShowAppSimpleOverlay);

            ImGui::SeparatorText("Concepts");
            ImGui::MenuItem("Auto-resizing window", NULL, &demo_data->ShowAppAutoResize);
            ImGui::MenuItem("Constrained-resizing window", NULL, &demo_data->ShowAppConstrainedResize);
            ImGui::MenuItem("Fullscreen window", NULL, &demo_data->ShowAppFullscreen);
            ImGui::MenuItem("Long text display", NULL, &demo_data->ShowAppLongText);
            ImGui::MenuItem("Manipulating window titles", NULL, &demo_data->ShowAppWindowTitles);

            ImGui::EndMenu();
        }
        //if (ImGui::MenuItem("MenuItem")) {} // You can also use MenuItem() inside a menu bar!
        if (ImGui::BeginMenu("Tools"))
        {
            IMGUI_DEMO_MARKER("Menu/Tools");
            ImGuiIO& io = ImGui::GetIO();
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
            const bool has_debug_tools = true;
#else
            const bool has_debug_tools = false;
#endif
            ImGui::MenuItem("Metrics/Debugger", NULL, &demo_data->ShowMetrics, has_debug_tools);
            if (ImGui::BeginMenu("Debug Options"))
            {
                ImGui::BeginDisabled(!has_debug_tools);
                ImGui::Checkbox("Highlight ID Conflicts", &io.ConfigDebugHighlightIdConflicts);
                ImGui::EndDisabled();
                ImGui::Checkbox("Assert on error recovery", &io.ConfigErrorRecoveryEnableAssert);
                ImGui::TextDisabled("(see Demo->Configuration for details & more)");
                ImGui::EndMenu();
            }
            ImGui::MenuItem("Debug Log", NULL, &demo_data->ShowDebugLog, has_debug_tools);
            ImGui::MenuItem("ID Stack Tool", NULL, &demo_data->ShowIDStackTool, has_debug_tools);
            bool is_debugger_present = io.ConfigDebugIsDebuggerPresent;
            if (ImGui::MenuItem("Item Picker", NULL, false, has_debug_tools))// && is_debugger_present))
                ImGui::DebugStartItemPicker();
            if (!is_debugger_present)
                ImGui::SetItemTooltip("Requires io.ConfigDebugIsDebuggerPresent=true to be set.\n\nWe otherwise disable some extra features to avoid casual users crashing the application.");
            ImGui::MenuItem("Style Editor", NULL, &demo_data->ShowStyleEditor);
            ImGui::MenuItem("About Dear ImGui", NULL, &demo_data->ShowAbout);

            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers: ExampleTreeNode, ExampleMemberInfo (for use by Property Editor & Multi-Select demos)
//-----------------------------------------------------------------------------

// Simple representation for a tree
// (this is designed to be simple to understand for our demos, not to be fancy or efficient etc.)
struct ExampleTreeNode
{
    // Tree structure
    char                        Name[28] = "";
    int                         UID = 0;
    ExampleTreeNode* Parent = NULL;
    ImVector<ExampleTreeNode*>  Childs;
    unsigned short              IndexInParent = 0;  // Maintaining this allows us to implement linear traversal more easily

    // Leaf Data
    bool                        HasData = false;    // All leaves have data
    bool                        DataMyBool = true;
    int                         DataMyInt = 128;
    ImVec2                      DataMyVec2 = ImVec2(0.0f, 3.141592f);
};

// Simple representation of struct metadata/serialization data.
// (this is a minimal version of what a typical advanced application may provide)
struct ExampleMemberInfo
{
    const char* Name;       // Member name
    ImGuiDataType   DataType;   // Member type
    int             DataCount;  // Member count (1 when scalar)
    int             Offset;     // Offset inside parent structure
};

// Metadata description of ExampleTreeNode struct.
static const ExampleMemberInfo ExampleTreeNodeMemberInfos[]
{
    { "MyName",     ImGuiDataType_String,  1, offsetof(ExampleTreeNode, Name) },
    { "MyBool",     ImGuiDataType_Bool,    1, offsetof(ExampleTreeNode, DataMyBool) },
    { "MyInt",      ImGuiDataType_S32,     1, offsetof(ExampleTreeNode, DataMyInt) },
    { "MyVec2",     ImGuiDataType_Float,   2, offsetof(ExampleTreeNode, DataMyVec2) },
};

static ExampleTreeNode* ExampleTree_CreateNode(const char* name, int uid, ExampleTreeNode* parent)
{
    ExampleTreeNode* node = IM_NEW(ExampleTreeNode);
    snprintf(node->Name, IM_ARRAYSIZE(node->Name), "%s", name);
    node->UID = uid;
    node->Parent = parent;
    node->IndexInParent = parent ? (unsigned short)parent->Childs.Size : 0;
    if (parent)
        parent->Childs.push_back(node);
    return node;
}

static void ExampleTree_DestroyNode(ExampleTreeNode* node)
{
    for (ExampleTreeNode* child_node : node->Childs)
        ExampleTree_DestroyNode(child_node);
    IM_DELETE(node);
}

// Create example tree data
// (this allocates _many_ more times than most other code in either Dear ImGui or others demo)
static ExampleTreeNode* ExampleTree_CreateDemoTree()
{
    static const char* root_names[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pear", "Pineapple", "Strawberry", "Watermelon" };
    const size_t NAME_MAX_LEN = sizeof(ExampleTreeNode::Name);
    char name_buf[NAME_MAX_LEN];
    int uid = 0;
    ExampleTreeNode* node_L0 = ExampleTree_CreateNode("<ROOT>", ++uid, NULL);
    const int root_items_multiplier = 2;
    for (int idx_L0 = 0; idx_L0 < IM_ARRAYSIZE(root_names) * root_items_multiplier; idx_L0++)
    {
        snprintf(name_buf, IM_ARRAYSIZE(name_buf), "%s %d", root_names[idx_L0 / root_items_multiplier], idx_L0 % root_items_multiplier);
        ExampleTreeNode* node_L1 = ExampleTree_CreateNode(name_buf, ++uid, node_L0);
        const int number_of_childs = (int)strlen(node_L1->Name);
        for (int idx_L1 = 0; idx_L1 < number_of_childs; idx_L1++)
        {
            snprintf(name_buf, IM_ARRAYSIZE(name_buf), "Child %d", idx_L1);
            ExampleTreeNode* node_L2 = ExampleTree_CreateNode(name_buf, ++uid, node_L1);
            node_L2->HasData = true;
            if (idx_L1 == 0)
            {
                snprintf(name_buf, IM_ARRAYSIZE(name_buf), "Sub-child %d", 0);
                ExampleTreeNode* node_L3 = ExampleTree_CreateNode(name_buf, ++uid, node_L2);
                node_L3->HasData = true;
            }
        }
    }
    return node_L0;
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsBasic()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsBasic()
{
    IMGUI_DEMO_MARKER("Widgets/Basic");
    if (ImGui::TreeNode("Basic"))
    {
        ImGui::SeparatorText("General");

        IMGUI_DEMO_MARKER("Widgets/Basic/Button");
        static int clicked = 0;
        if (ImGui::Button("Button"))
            clicked++;
        if (clicked & 1)
        {
            ImGui::SameLine();
            ImGui::Text("Thanks for clicking me!");
        }

        IMGUI_DEMO_MARKER("Widgets/Basic/Checkbox");
        static bool check = true;
        ImGui::Checkbox("checkbox", &check);

        IMGUI_DEMO_MARKER("Widgets/Basic/RadioButton");
        static int e = 0;
        ImGui::RadioButton("radio a", &e, 0); ImGui::SameLine();
        ImGui::RadioButton("radio b", &e, 1); ImGui::SameLine();
        ImGui::RadioButton("radio c", &e, 2);

        ImGui::AlignTextToFramePadding();
        ImGui::TextLinkOpenURL("Hyperlink", "https://github.com/ocornut/imgui/wiki/Error-Handling");

        // Color buttons, demonstrate using PushID() to add unique identifier in the ID stack, and changing style.
        IMGUI_DEMO_MARKER("Widgets/Basic/Buttons (Colored)");
        for (int i = 0; i < 7; i++)
        {
            if (i > 0)
                ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(i / 7.0f, 0.6f, 0.6f));
            ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(i / 7.0f, 0.7f, 0.7f));
            ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(i / 7.0f, 0.8f, 0.8f));
            ImGui::Button("Click");
            ImGui::PopStyleColor(3);
            ImGui::PopID();
        }

        // Use AlignTextToFramePadding() to align text baseline to the baseline of framed widgets elements
        // (otherwise a Text+SameLine+Button sequence will have the text a little too high by default!)
        // See 'Demo->Layout->Text Baseline Alignment' for details.
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Hold to repeat:");
        ImGui::SameLine();

        // Arrow buttons with Repeater
        IMGUI_DEMO_MARKER("Widgets/Basic/Buttons (Repeating)");
        static int counter = 0;
        float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
        ImGui::PushItemFlag(ImGuiItemFlags_ButtonRepeat, true);
        if (ImGui::ArrowButton("##left", ImGuiDir_Left)) { counter--; }
        ImGui::SameLine(0.0f, spacing);
        if (ImGui::ArrowButton("##right", ImGuiDir_Right)) { counter++; }
        ImGui::PopItemFlag();
        ImGui::SameLine();
        ImGui::Text("%d", counter);

        ImGui::Button("Tooltip");
        ImGui::SetItemTooltip("I am a tooltip");

        ImGui::LabelText("label", "Value");

        ImGui::SeparatorText("Inputs");

        {
            // To wire InputText() with std::string or any other custom string type,
            // see the "Text Input > Resize Callback" section of this demo, and the misc/cpp/imgui_stdlib.h file.
            IMGUI_DEMO_MARKER("Widgets/Basic/InputText");
            static char str0[128] = "Hello, world!";
            ImGui::InputText("input text", str0, IM_ARRAYSIZE(str0));
            ImGui::SameLine(); HelpMarker(
                "USER:\n"
                "Hold SHIFT or use mouse to select text.\n"
                "CTRL+Left/Right to word jump.\n"
                "CTRL+A or Double-Click to select all.\n"
                "CTRL+X,CTRL+C,CTRL+V for clipboard.\n"
                "CTRL+Z to undo, CTRL+Y/CTRL+SHIFT+Z to redo.\n"
                "ESCAPE to revert.\n\n"
                "PROGRAMMER:\n"
                "You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputText() "
                "to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example (this is not demonstrated "
                "in imgui_demo.cpp).");

            static char str1[128] = "";
            ImGui::InputTextWithHint("input text (w/ hint)", "enter text here", str1, IM_ARRAYSIZE(str1));

            IMGUI_DEMO_MARKER("Widgets/Basic/InputInt, InputFloat");
            static int i0 = 123;
            ImGui::InputInt("input int", &i0);

            static float f0 = 0.001f;
            ImGui::InputFloat("input float", &f0, 0.01f, 1.0f, "%.3f");

            static double d0 = 999999.00000001;
            ImGui::InputDouble("input double", &d0, 0.01f, 1.0f, "%.8f");

            static float f1 = 1.e10f;
            ImGui::InputFloat("input scientific", &f1, 0.0f, 0.0f, "%e");
            ImGui::SameLine(); HelpMarker(
                "You can input value using the scientific notation,\n"
                "  e.g. \"1e+8\" becomes \"100000000\".");

            static float vec4a[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
            ImGui::InputFloat3("input float3", vec4a);
        }

        ImGui::SeparatorText("Drags");

        {
            IMGUI_DEMO_MARKER("Widgets/Basic/DragInt, DragFloat");
            static int i1 = 50, i2 = 42, i3 = 128;
            ImGui::DragInt("drag int", &i1, 1);
            ImGui::SameLine(); HelpMarker(
                "Click and drag to edit value.\n"
                "Hold SHIFT/ALT for faster/slower edit.\n"
                "Double-click or CTRL+click to input value.");
            ImGui::DragInt("drag int 0..100", &i2, 1, 0, 100, "%d%%", ImGuiSliderFlags_AlwaysClamp);
            ImGui::DragInt("drag int wrap 100..200", &i3, 1, 100, 200, "%d", ImGuiSliderFlags_WrapAround);

            static float f1 = 1.00f, f2 = 0.0067f;
            ImGui::DragFloat("drag float", &f1, 0.005f);
            ImGui::DragFloat("drag small float", &f2, 0.0001f, 0.0f, 0.0f, "%.06f ns");
            //ImGui::DragFloat("drag wrap -1..1", &f3, 0.005f, -1.0f, 1.0f, NULL, ImGuiSliderFlags_WrapAround);
        }

        ImGui::SeparatorText("Sliders");

        {
            IMGUI_DEMO_MARKER("Widgets/Basic/SliderInt, SliderFloat");
            static int i1 = 0;
            ImGui::SliderInt("slider int", &i1, -1, 3);
            ImGui::SameLine(); HelpMarker("CTRL+click to input value.");

            static float f1 = 0.123f, f2 = 0.0f;
            ImGui::SliderFloat("slider float", &f1, 0.0f, 1.0f, "ratio = %.3f");
            ImGui::SliderFloat("slider float (log)", &f2, -10.0f, 10.0f, "%.4f", ImGuiSliderFlags_Logarithmic);

            IMGUI_DEMO_MARKER("Widgets/Basic/SliderAngle");
            static float angle = 0.0f;
            ImGui::SliderAngle("slider angle", &angle);

            // Using the format string to display a name instead of an integer.
            // Here we completely omit '%d' from the format string, so it'll only display a name.
            // This technique can also be used with DragInt().
            IMGUI_DEMO_MARKER("Widgets/Basic/Slider (enum)");
            enum Element { Element_Fire, Element_Earth, Element_Air, Element_Water, Element_COUNT };
            static int elem = Element_Fire;
            const char* elems_names[Element_COUNT] = { "Fire", "Earth", "Air", "Water" };
            const char* elem_name = (elem >= 0 && elem < Element_COUNT) ? elems_names[elem] : "Unknown";
            ImGui::SliderInt("slider enum", &elem, 0, Element_COUNT - 1, elem_name); // Use ImGuiSliderFlags_NoInput flag to disable CTRL+Click here.
            ImGui::SameLine(); HelpMarker("Using the format string parameter to display a name instead of the underlying integer.");
        }

        ImGui::SeparatorText("Selectors/Pickers");

        {
            IMGUI_DEMO_MARKER("Widgets/Basic/ColorEdit3, ColorEdit4");
            static float col1[3] = { 1.0f, 0.0f, 0.2f };
            static float col2[4] = { 0.4f, 0.7f, 0.0f, 0.5f };
            ImGui::ColorEdit3("color 1", col1);
            ImGui::SameLine(); HelpMarker(
                "Click on the color square to open a color picker.\n"
                "Click and hold to use drag and drop.\n"
                "Right-click on the color square to show options.\n"
                "CTRL+click on individual component to input value.\n");

            ImGui::ColorEdit4("color 2", col2);
        }

        {
            // Using the _simplified_ one-liner Combo() api here
            // See "Combo" section for examples of how to use the more flexible BeginCombo()/EndCombo() api.
            IMGUI_DEMO_MARKER("Widgets/Basic/Combo");
            const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIIIIII", "JJJJ", "KKKKKKK" };
            static int item_current = 0;
            ImGui::Combo("combo", &item_current, items, IM_ARRAYSIZE(items));
            ImGui::SameLine(); HelpMarker(
                "Using the simplified one-liner Combo API here.\n"
                "Refer to the \"Combo\" section below for an explanation of how to use the more flexible and general BeginCombo/EndCombo API.");
        }

        {
            // Using the _simplified_ one-liner ListBox() api here
            // See "List boxes" section for examples of how to use the more flexible BeginListBox()/EndListBox() api.
            IMGUI_DEMO_MARKER("Widgets/Basic/ListBox");
            const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi", "Mango", "Orange", "Pineapple", "Strawberry", "Watermelon" };
            static int item_current = 1;
            ImGui::ListBox("listbox", &item_current, items, IM_ARRAYSIZE(items), 4);
            ImGui::SameLine(); HelpMarker(
                "Using the simplified one-liner ListBox API here.\n"
                "Refer to the \"List boxes\" section below for an explanation of how to use the more flexible and general BeginListBox/EndListBox API.");
        }

        // Testing ImGuiOnceUponAFrame helper.
        //static ImGuiOnceUponAFrame once;
        //for (int i = 0; i < 5; i++)
        //    if (once)
        //        ImGui::Text("This will be displayed only once.");

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsBullets()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsBullets()
{
    IMGUI_DEMO_MARKER("Widgets/Bullets");
    if (ImGui::TreeNode("Bullets"))
    {
        ImGui::BulletText("Bullet point 1");
        ImGui::BulletText("Bullet point 2\nOn multiple lines");
        if (ImGui::TreeNode("Tree node"))
        {
            ImGui::BulletText("Another bullet point");
            ImGui::TreePop();
        }
        ImGui::Bullet(); ImGui::Text("Bullet point 3 (two calls)");
        ImGui::Bullet(); ImGui::SmallButton("Button");
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsCollapsingHeaders()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsCollapsingHeaders()
{
    IMGUI_DEMO_MARKER("Widgets/Collapsing Headers");
    if (ImGui::TreeNode("Collapsing Headers"))
    {
        static bool closable_group = true;
        ImGui::Checkbox("Show 2nd header", &closable_group);
        if (ImGui::CollapsingHeader("Header", ImGuiTreeNodeFlags_None))
        {
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
            for (int i = 0; i < 5; i++)
                ImGui::Text("Some content %d", i);
        }
        if (ImGui::CollapsingHeader("Header with a close button", &closable_group))
        {
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
            for (int i = 0; i < 5; i++)
                ImGui::Text("More content %d", i);
        }
        /*
        if (ImGui::CollapsingHeader("Header with a bullet", ImGuiTreeNodeFlags_Bullet))
            ImGui::Text("IsItemHovered: %d", ImGui::IsItemHovered());
        */
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsColorAndPickers()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsColorAndPickers()
{
    IMGUI_DEMO_MARKER("Widgets/Color");
    if (ImGui::TreeNode("Color/Picker Widgets"))
    {
        static ImVec4 color = ImVec4(114.0f / 255.0f, 144.0f / 255.0f, 154.0f / 255.0f, 200.0f / 255.0f);
        static ImGuiColorEditFlags base_flags = ImGuiColorEditFlags_None;

        ImGui::SeparatorText("Options");
        ImGui::CheckboxFlags("ImGuiColorEditFlags_NoAlpha", &base_flags, ImGuiColorEditFlags_NoAlpha);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_AlphaOpaque", &base_flags, ImGuiColorEditFlags_AlphaOpaque);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_AlphaNoBg", &base_flags, ImGuiColorEditFlags_AlphaNoBg);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_AlphaPreviewHalf", &base_flags, ImGuiColorEditFlags_AlphaPreviewHalf);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_NoDragDrop", &base_flags, ImGuiColorEditFlags_NoDragDrop);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_NoOptions", &base_flags, ImGuiColorEditFlags_NoOptions); ImGui::SameLine(); HelpMarker("Right-click on the individual color widget to show options.");
        ImGui::CheckboxFlags("ImGuiColorEditFlags_HDR", &base_flags, ImGuiColorEditFlags_HDR); ImGui::SameLine(); HelpMarker("Currently all this does is to lift the 0..1 limits on dragging widgets.");

        IMGUI_DEMO_MARKER("Widgets/Color/ColorEdit");
        ImGui::SeparatorText("Inline color editor");
        ImGui::Text("Color widget:");
        ImGui::SameLine(); HelpMarker(
            "Click on the color square to open a color picker.\n"
            "CTRL+click on individual component to input value.\n");
        ImGui::ColorEdit3("MyColor##1", (float*)&color, base_flags);

        IMGUI_DEMO_MARKER("Widgets/Color/ColorEdit (HSV, with Alpha)");
        ImGui::Text("Color widget HSV with Alpha:");
        ImGui::ColorEdit4("MyColor##2", (float*)&color, ImGuiColorEditFlags_DisplayHSV | base_flags);

        IMGUI_DEMO_MARKER("Widgets/Color/ColorEdit (float display)");
        ImGui::Text("Color widget with Float Display:");
        ImGui::ColorEdit4("MyColor##2f", (float*)&color, ImGuiColorEditFlags_Float | base_flags);

        IMGUI_DEMO_MARKER("Widgets/Color/ColorButton (with Picker)");
        ImGui::Text("Color button with Picker:");
        ImGui::SameLine(); HelpMarker(
            "With the ImGuiColorEditFlags_NoInputs flag you can hide all the slider/text inputs.\n"
            "With the ImGuiColorEditFlags_NoLabel flag you can pass a non-empty label which will only "
            "be used for the tooltip and picker popup.");
        ImGui::ColorEdit4("MyColor##3", (float*)&color, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel | base_flags);

        IMGUI_DEMO_MARKER("Widgets/Color/ColorButton (with custom Picker popup)");
        ImGui::Text("Color button with Custom Picker Popup:");

        // Generate a default palette. The palette will persist and can be edited.
        static bool saved_palette_init = true;
        static ImVec4 saved_palette[32] = {};
        if (saved_palette_init)
        {
            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)
            {
                ImGui::ColorConvertHSVtoRGB(n / 31.0f, 0.8f, 0.8f,
                    saved_palette[n].x, saved_palette[n].y, saved_palette[n].z);
                saved_palette[n].w = 1.0f; // Alpha
            }
            saved_palette_init = false;
        }

        static ImVec4 backup_color;
        bool open_popup = ImGui::ColorButton("MyColor##3b", color, base_flags);
        ImGui::SameLine(0, ImGui::GetStyle().ItemInnerSpacing.x);
        open_popup |= ImGui::Button("Palette");
        if (open_popup)
        {
            ImGui::OpenPopup("mypicker");
            backup_color = color;
        }
        if (ImGui::BeginPopup("mypicker"))
        {
            ImGui::Text("MY CUSTOM COLOR PICKER WITH AN AMAZING PALETTE!");
            ImGui::Separator();
            ImGui::ColorPicker4("##picker", (float*)&color, base_flags | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoSmallPreview);
            ImGui::SameLine();

            ImGui::BeginGroup(); // Lock X position
            ImGui::Text("Current");
            ImGui::ColorButton("##current", color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60, 40));
            ImGui::Text("Previous");
            if (ImGui::ColorButton("##previous", backup_color, ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_AlphaPreviewHalf, ImVec2(60, 40)))
                color = backup_color;
            ImGui::Separator();
            ImGui::Text("Palette");
            for (int n = 0; n < IM_ARRAYSIZE(saved_palette); n++)
            {
                ImGui::PushID(n);
                if ((n % 8) != 0)
                    ImGui::SameLine(0.0f, ImGui::GetStyle().ItemSpacing.y);

                ImGuiColorEditFlags palette_button_flags = ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoPicker | ImGuiColorEditFlags_NoTooltip;
                if (ImGui::ColorButton("##palette", saved_palette[n], palette_button_flags, ImVec2(20, 20)))
                    color = ImVec4(saved_palette[n].x, saved_palette[n].y, saved_palette[n].z, color.w); // Preserve alpha!

                // Allow user to drop colors into each palette entry. Note that ColorButton() is already a
                // drag source by default, unless specifying the ImGuiColorEditFlags_NoDragDrop flag.
                if (ImGui::BeginDragDropTarget())
                {
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 3);
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
                        memcpy((float*)&saved_palette[n], payload->Data, sizeof(float) * 4);
                    ImGui::EndDragDropTarget();
                }

                ImGui::PopID();
            }
            ImGui::EndGroup();
            ImGui::EndPopup();
        }

        IMGUI_DEMO_MARKER("Widgets/Color/ColorButton (simple)");
        ImGui::Text("Color button only:");
        static bool no_border = false;
        ImGui::Checkbox("ImGuiColorEditFlags_NoBorder", &no_border);
        ImGui::ColorButton("MyColor##3c", *(ImVec4*)&color, base_flags | (no_border ? ImGuiColorEditFlags_NoBorder : 0), ImVec2(80, 80));

        IMGUI_DEMO_MARKER("Widgets/Color/ColorPicker");
        ImGui::SeparatorText("Color picker");

        static bool ref_color = false;
        static ImVec4 ref_color_v(1.0f, 0.0f, 1.0f, 0.5f);
        static int picker_mode = 0;
        static int display_mode = 0;
        static ImGuiColorEditFlags color_picker_flags = ImGuiColorEditFlags_AlphaBar;

        ImGui::PushID("Color picker");
        ImGui::CheckboxFlags("ImGuiColorEditFlags_NoAlpha", &color_picker_flags, ImGuiColorEditFlags_NoAlpha);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_AlphaBar", &color_picker_flags, ImGuiColorEditFlags_AlphaBar);
        ImGui::CheckboxFlags("ImGuiColorEditFlags_NoSidePreview", &color_picker_flags, ImGuiColorEditFlags_NoSidePreview);
        if (color_picker_flags & ImGuiColorEditFlags_NoSidePreview)
        {
            ImGui::SameLine();
            ImGui::Checkbox("With Ref Color", &ref_color);
            if (ref_color)
            {
                ImGui::SameLine();
                ImGui::ColorEdit4("##RefColor", &ref_color_v.x, ImGuiColorEditFlags_NoInputs | base_flags);
            }
        }

        ImGui::Combo("Picker Mode", &picker_mode, "Auto/Current\0ImGuiColorEditFlags_PickerHueBar\0ImGuiColorEditFlags_PickerHueWheel\0");
        ImGui::SameLine(); HelpMarker("When not specified explicitly, user can right-click the picker to change mode.");

        ImGui::Combo("Display Mode", &display_mode, "Auto/Current\0ImGuiColorEditFlags_NoInputs\0ImGuiColorEditFlags_DisplayRGB\0ImGuiColorEditFlags_DisplayHSV\0ImGuiColorEditFlags_DisplayHex\0");
        ImGui::SameLine(); HelpMarker(
            "ColorEdit defaults to displaying RGB inputs if you don't specify a display mode, "
            "but the user can change it with a right-click on those inputs.\n\nColorPicker defaults to displaying RGB+HSV+Hex "
            "if you don't specify a display mode.\n\nYou can change the defaults using SetColorEditOptions().");

        ImGuiColorEditFlags flags = base_flags | color_picker_flags;
        if (picker_mode == 1)  flags |= ImGuiColorEditFlags_PickerHueBar;
        if (picker_mode == 2)  flags |= ImGuiColorEditFlags_PickerHueWheel;
        if (display_mode == 1) flags |= ImGuiColorEditFlags_NoInputs;       // Disable all RGB/HSV/Hex displays
        if (display_mode == 2) flags |= ImGuiColorEditFlags_DisplayRGB;     // Override display mode
        if (display_mode == 3) flags |= ImGuiColorEditFlags_DisplayHSV;
        if (display_mode == 4) flags |= ImGuiColorEditFlags_DisplayHex;
        ImGui::ColorPicker4("MyColor##4", (float*)&color, flags, ref_color ? &ref_color_v.x : NULL);

        ImGui::Text("Set defaults in code:");
        ImGui::SameLine(); HelpMarker(
            "SetColorEditOptions() is designed to allow you to set boot-time default.\n"
            "We don't have Push/Pop functions because you can force options on a per-widget basis if needed, "
            "and the user can change non-forced ones with the options menu.\nWe don't have a getter to avoid "
            "encouraging you to persistently save values that aren't forward-compatible.");
        if (ImGui::Button("Default: Uint8 + HSV + Hue Bar"))
            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_PickerHueBar);
        if (ImGui::Button("Default: Float + HDR + Hue Wheel"))
            ImGui::SetColorEditOptions(ImGuiColorEditFlags_Float | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_PickerHueWheel);

        // Always display a small version of both types of pickers
        // (that's in order to make it more visible in the demo to people who are skimming quickly through it)
        ImGui::Text("Both types:");
        float w = (ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.y) * 0.40f;
        ImGui::SetNextItemWidth(w);
        ImGui::ColorPicker3("##MyColor##5", (float*)&color, ImGuiColorEditFlags_PickerHueBar | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
        ImGui::SameLine();
        ImGui::SetNextItemWidth(w);
        ImGui::ColorPicker3("##MyColor##6", (float*)&color, ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_NoSidePreview | ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoAlpha);
        ImGui::PopID();

        // HSV encoded support (to avoid RGB<>HSV round trips and singularities when S==0 or V==0)
        static ImVec4 color_hsv(0.23f, 1.0f, 1.0f, 1.0f); // Stored as HSV!
        ImGui::Spacing();
        ImGui::Text("HSV encoded colors");
        ImGui::SameLine(); HelpMarker(
            "By default, colors are given to ColorEdit and ColorPicker in RGB, but ImGuiColorEditFlags_InputHSV "
            "allows you to store colors as HSV and pass them to ColorEdit and ColorPicker as HSV. This comes with the "
            "added benefit that you can manipulate hue values with the picker even when saturation or value are zero.");
        ImGui::Text("Color widget with InputHSV:");
        ImGui::ColorEdit4("HSV shown as RGB##1", (float*)&color_hsv, ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);
        ImGui::ColorEdit4("HSV shown as HSV##1", (float*)&color_hsv, ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_InputHSV | ImGuiColorEditFlags_Float);
        ImGui::DragFloat4("Raw HSV values", (float*)&color_hsv, 0.01f, 0.0f, 1.0f);

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsComboBoxes()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsComboBoxes()
{
    IMGUI_DEMO_MARKER("Widgets/Combo");
    if (ImGui::TreeNode("Combo"))
    {
        // Combo Boxes are also called "Dropdown" in other systems
        // Expose flags as checkbox for the demo
        static ImGuiComboFlags flags = 0;
        ImGui::CheckboxFlags("ImGuiComboFlags_PopupAlignLeft", &flags, ImGuiComboFlags_PopupAlignLeft);
        ImGui::SameLine(); HelpMarker("Only makes a difference if the popup is larger than the combo");
        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoArrowButton", &flags, ImGuiComboFlags_NoArrowButton))
            flags &= ~ImGuiComboFlags_NoPreview;     // Clear incompatible flags
        if (ImGui::CheckboxFlags("ImGuiComboFlags_NoPreview", &flags, ImGuiComboFlags_NoPreview))
            flags &= ~(ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_WidthFitPreview); // Clear incompatible flags
        if (ImGui::CheckboxFlags("ImGuiComboFlags_WidthFitPreview", &flags, ImGuiComboFlags_WidthFitPreview))
            flags &= ~ImGuiComboFlags_NoPreview;

        // Override default popup height
        if (ImGui::CheckboxFlags("ImGuiComboFlags_HeightSmall", &flags, ImGuiComboFlags_HeightSmall))
            flags &= ~(ImGuiComboFlags_HeightMask_ & ~ImGuiComboFlags_HeightSmall);
        if (ImGui::CheckboxFlags("ImGuiComboFlags_HeightRegular", &flags, ImGuiComboFlags_HeightRegular))
            flags &= ~(ImGuiComboFlags_HeightMask_ & ~ImGuiComboFlags_HeightRegular);
        if (ImGui::CheckboxFlags("ImGuiComboFlags_HeightLargest", &flags, ImGuiComboFlags_HeightLargest))
            flags &= ~(ImGuiComboFlags_HeightMask_ & ~ImGuiComboFlags_HeightLargest);

        // Using the generic BeginCombo() API, you have full control over how to display the combo contents.
        // (your selection data could be an index, a pointer to the object, an id for the object, a flag intrusively
        // stored in the object itself, etc.)
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };
        static int item_selected_idx = 0; // Here we store our selection data as an index.

        // Pass in the preview value visible before opening the combo (it could technically be different contents or not pulled from items[])
        const char* combo_preview_value = items[item_selected_idx];
        if (ImGui::BeginCombo("combo 1", combo_preview_value, flags))
        {
            for (int n = 0; n < IM_ARRAYSIZE(items); n++)
            {
                const bool is_selected = (item_selected_idx == n);
                if (ImGui::Selectable(items[n], is_selected))
                    item_selected_idx = n;

                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
                if (is_selected)
                    ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }

        // Show case embedding a filter using a simple trick: displaying the filter inside combo contents.
        // See https://github.com/ocornut/imgui/issues/718 for advanced/esoteric alternatives.
        if (ImGui::BeginCombo("combo 2 (w/ filter)", combo_preview_value, flags))
        {
            static ImGuiTextFilter filter;
            if (ImGui::IsWindowAppearing())
            {
                ImGui::SetKeyboardFocusHere();
                filter.Clear();
            }
            ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_F);
            filter.Draw("##Filter", -FLT_MIN);

            for (int n = 0; n < IM_ARRAYSIZE(items); n++)
            {
                const bool is_selected = (item_selected_idx == n);
                if (filter.PassFilter(items[n]))
                    if (ImGui::Selectable(items[n], is_selected))
                        item_selected_idx = n;
            }
            ImGui::EndCombo();
        }

        ImGui::Spacing();
        ImGui::SeparatorText("One-liner variants");
        HelpMarker("The Combo() function is not greatly useful apart from cases were you want to embed all options in a single strings.\nFlags above don't apply to this section.");

        // Simplified one-liner Combo() API, using values packed in a single constant string
        // This is a convenience for when the selection set is small and known at compile-time.
        static int item_current_2 = 0;
        ImGui::Combo("combo 3 (one-liner)", &item_current_2, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");

        // Simplified one-liner Combo() using an array of const char*
        // This is not very useful (may obsolete): prefer using BeginCombo()/EndCombo() for full control.
        static int item_current_3 = -1; // If the selection isn't within 0..count, Combo won't display a preview
        ImGui::Combo("combo 4 (array)", &item_current_3, items, IM_ARRAYSIZE(items));

        // Simplified one-liner Combo() using an accessor function
        static int item_current_4 = 0;
        ImGui::Combo("combo 5 (function)", &item_current_4, [](void* data, int n) { return ((const char**)data)[n]; }, items, IM_ARRAYSIZE(items));

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsDataTypes()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsDataTypes()
{
    IMGUI_DEMO_MARKER("Widgets/Data Types");
    if (ImGui::TreeNode("Data Types"))
    {
        // DragScalar/InputScalar/SliderScalar functions allow various data types
        // - signed/unsigned
        // - 8/16/32/64-bits
        // - integer/float/double
        // To avoid polluting the public API with all possible combinations, we use the ImGuiDataType enum
        // to pass the type, and passing all arguments by pointer.
        // This is the reason the test code below creates local variables to hold "zero" "one" etc. for each type.
        // In practice, if you frequently use a given type that is not covered by the normal API entry points,
        // you can wrap it yourself inside a 1 line function which can take typed argument as value instead of void*,
        // and then pass their address to the generic function. For example:
        //   bool MySliderU64(const char *label, u64* value, u64 min = 0, u64 max = 0, const char* format = "%lld")
        //   {
        //      return SliderScalar(label, ImGuiDataType_U64, value, &min, &max, format);
        //   }

        // Setup limits (as helper variables so we can take their address, as explained above)
        // Note: SliderScalar() functions have a maximum usable range of half the natural type maximum, hence the /2.
        #ifndef LLONG_MIN
        ImS64 LLONG_MIN = -9223372036854775807LL - 1;
        ImS64 LLONG_MAX = 9223372036854775807LL;
        ImU64 ULLONG_MAX = (2ULL * 9223372036854775807LL + 1);
        #endif
        const char    s8_zero  = 0,   s8_one  = 1,   s8_fifty  = 50, s8_min  = -128,        s8_max = 127;
        const ImU8    u8_zero  = 0,   u8_one  = 1,   u8_fifty  = 50, u8_min  = 0,           u8_max = 255;
        const short   s16_zero = 0,   s16_one = 1,   s16_fifty = 50, s16_min = -32768,      s16_max = 32767;
        const ImU16   u16_zero = 0,   u16_one = 1,   u16_fifty = 50, u16_min = 0,           u16_max = 65535;
        const ImS32   s32_zero = 0,   s32_one = 1,   s32_fifty = 50, s32_min = INT_MIN/2,   s32_max = INT_MAX/2,    s32_hi_a = INT_MAX/2 - 100,    s32_hi_b = INT_MAX/2;
        const ImU32   u32_zero = 0,   u32_one = 1,   u32_fifty = 50, u32_min = 0,           u32_max = UINT_MAX/2,   u32_hi_a = UINT_MAX/2 - 100,   u32_hi_b = UINT_MAX/2;
        const ImS64   s64_zero = 0,   s64_one = 1,   s64_fifty = 50, s64_min = LLONG_MIN/2, s64_max = LLONG_MAX/2,  s64_hi_a = LLONG_MAX/2 - 100,  s64_hi_b = LLONG_MAX/2;
        const ImU64   u64_zero = 0,   u64_one = 1,   u64_fifty = 50, u64_min = 0,           u64_max = ULLONG_MAX/2, u64_hi_a = ULLONG_MAX/2 - 100, u64_hi_b = ULLONG_MAX/2;
        const float   f32_zero = 0.f, f32_one = 1.f, f32_lo_a = -10000000000.0f, f32_hi_a = +10000000000.0f;
        const double  f64_zero = 0.,  f64_one = 1.,  f64_lo_a = -1000000000000000.0, f64_hi_a = +1000000000000000.0;

        // State
        static char   s8_v  = 127;
        static ImU8   u8_v  = 255;
        static short  s16_v = 32767;
        static ImU16  u16_v = 65535;
        static ImS32  s32_v = -1;
        static ImU32  u32_v = (ImU32)-1;
        static ImS64  s64_v = -1;
        static ImU64  u64_v = (ImU64)-1;
        static float  f32_v = 0.123f;
        static double f64_v = 90000.01234567890123456789;

        const float drag_speed = 0.2f;
        static bool drag_clamp = false;
        IMGUI_DEMO_MARKER("Widgets/Data Types/Drags");
        ImGui::SeparatorText("Drags");
        ImGui::Checkbox("Clamp integers to 0..50", &drag_clamp);
        ImGui::SameLine(); HelpMarker(
            "As with every widget in dear imgui, we never modify values unless there is a user interaction.\n"
            "You can override the clamping limits by using CTRL+Click to input a value.");
        ImGui::DragScalar("drag s8",        ImGuiDataType_S8,     &s8_v,  drag_speed, drag_clamp ? &s8_zero  : NULL, drag_clamp ? &s8_fifty  : NULL);
        ImGui::DragScalar("drag u8",        ImGuiDataType_U8,     &u8_v,  drag_speed, drag_clamp ? &u8_zero  : NULL, drag_clamp ? &u8_fifty  : NULL, "%u ms");
        ImGui::DragScalar("drag s16",       ImGuiDataType_S16,    &s16_v, drag_speed, drag_clamp ? &s16_zero : NULL, drag_clamp ? &s16_fifty : NULL);
        ImGui::DragScalar("drag u16",       ImGuiDataType_U16,    &u16_v, drag_speed, drag_clamp ? &u16_zero : NULL, drag_clamp ? &u16_fifty : NULL, "%u ms");
        ImGui::DragScalar("drag s32",       ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL);
        ImGui::DragScalar("drag s32 hex",   ImGuiDataType_S32,    &s32_v, drag_speed, drag_clamp ? &s32_zero : NULL, drag_clamp ? &s32_fifty : NULL, "0x%08X");
        ImGui::DragScalar("drag u32",       ImGuiDataType_U32,    &u32_v, drag_speed, drag_clamp ? &u32_zero : NULL, drag_clamp ? &u32_fifty : NULL, "%u ms");
        ImGui::DragScalar("drag s64",       ImGuiDataType_S64,    &s64_v, drag_speed, drag_clamp ? &s64_zero : NULL, drag_clamp ? &s64_fifty : NULL);
        ImGui::DragScalar("drag u64",       ImGuiDataType_U64,    &u64_v, drag_speed, drag_clamp ? &u64_zero : NULL, drag_clamp ? &u64_fifty : NULL);
        ImGui::DragScalar("drag float",     ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f");
        ImGui::DragScalar("drag float log", ImGuiDataType_Float,  &f32_v, 0.005f,  &f32_zero, &f32_one, "%f", ImGuiSliderFlags_Logarithmic);
        ImGui::DragScalar("drag double",    ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, NULL,     "%.10f grams");
        ImGui::DragScalar("drag double log",ImGuiDataType_Double, &f64_v, 0.0005f, &f64_zero, &f64_one, "0 < %.10f < 1", ImGuiSliderFlags_Logarithmic);

        IMGUI_DEMO_MARKER("Widgets/Data Types/Sliders");
        ImGui::SeparatorText("Sliders");
        ImGui::SliderScalar("slider s8 full",       ImGuiDataType_S8,     &s8_v,  &s8_min,   &s8_max,   "%d");
        ImGui::SliderScalar("slider u8 full",       ImGuiDataType_U8,     &u8_v,  &u8_min,   &u8_max,   "%u");
        ImGui::SliderScalar("slider s16 full",      ImGuiDataType_S16,    &s16_v, &s16_min,  &s16_max,  "%d");
        ImGui::SliderScalar("slider u16 full",      ImGuiDataType_U16,    &u16_v, &u16_min,  &u16_max,  "%u");
        ImGui::SliderScalar("slider s32 low",       ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty,"%d");
        ImGui::SliderScalar("slider s32 high",      ImGuiDataType_S32,    &s32_v, &s32_hi_a, &s32_hi_b, "%d");
        ImGui::SliderScalar("slider s32 full",      ImGuiDataType_S32,    &s32_v, &s32_min,  &s32_max,  "%d");
        ImGui::SliderScalar("slider s32 hex",       ImGuiDataType_S32,    &s32_v, &s32_zero, &s32_fifty, "0x%04X");
        ImGui::SliderScalar("slider u32 low",       ImGuiDataType_U32,    &u32_v, &u32_zero, &u32_fifty,"%u");
        ImGui::SliderScalar("slider u32 high",      ImGuiDataType_U32,    &u32_v, &u32_hi_a, &u32_hi_b, "%u");
        ImGui::SliderScalar("slider u32 full",      ImGuiDataType_U32,    &u32_v, &u32_min,  &u32_max,  "%u");
        ImGui::SliderScalar("slider s64 low",       ImGuiDataType_S64,    &s64_v, &s64_zero, &s64_fifty,"%" PRId64);
        ImGui::SliderScalar("slider s64 high",      ImGuiDataType_S64,    &s64_v, &s64_hi_a, &s64_hi_b, "%" PRId64);
        ImGui::SliderScalar("slider s64 full",      ImGuiDataType_S64,    &s64_v, &s64_min,  &s64_max,  "%" PRId64);
        ImGui::SliderScalar("slider u64 low",       ImGuiDataType_U64,    &u64_v, &u64_zero, &u64_fifty,"%" PRIu64 " ms");
        ImGui::SliderScalar("slider u64 high",      ImGuiDataType_U64,    &u64_v, &u64_hi_a, &u64_hi_b, "%" PRIu64 " ms");
        ImGui::SliderScalar("slider u64 full",      ImGuiDataType_U64,    &u64_v, &u64_min,  &u64_max,  "%" PRIu64 " ms");
        ImGui::SliderScalar("slider float low",     ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one);
        ImGui::SliderScalar("slider float low log", ImGuiDataType_Float,  &f32_v, &f32_zero, &f32_one,  "%.10f", ImGuiSliderFlags_Logarithmic);
        ImGui::SliderScalar("slider float high",    ImGuiDataType_Float,  &f32_v, &f32_lo_a, &f32_hi_a, "%e");
        ImGui::SliderScalar("slider double low",    ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f grams");
        ImGui::SliderScalar("slider double low log",ImGuiDataType_Double, &f64_v, &f64_zero, &f64_one,  "%.10f", ImGuiSliderFlags_Logarithmic);
        ImGui::SliderScalar("slider double high",   ImGuiDataType_Double, &f64_v, &f64_lo_a, &f64_hi_a, "%e grams");

        ImGui::SeparatorText("Sliders (reverse)");
        ImGui::SliderScalar("slider s8 reverse",    ImGuiDataType_S8,   &s8_v,  &s8_max,    &s8_min,   "%d");
        ImGui::SliderScalar("slider u8 reverse",    ImGuiDataType_U8,   &u8_v,  &u8_max,    &u8_min,   "%u");
        ImGui::SliderScalar("slider s32 reverse",   ImGuiDataType_S32,  &s32_v, &s32_fifty, &s32_zero, "%d");
        ImGui::SliderScalar("slider u32 reverse",   ImGuiDataType_U32,  &u32_v, &u32_fifty, &u32_zero, "%u");
        ImGui::SliderScalar("slider s64 reverse",   ImGuiDataType_S64,  &s64_v, &s64_fifty, &s64_zero, "%" PRId64);
        ImGui::SliderScalar("slider u64 reverse",   ImGuiDataType_U64,  &u64_v, &u64_fifty, &u64_zero, "%" PRIu64 " ms");

        IMGUI_DEMO_MARKER("Widgets/Data Types/Inputs");
        static bool inputs_step = true;
        static ImGuiInputTextFlags flags = ImGuiInputTextFlags_None;
        ImGui::SeparatorText("Inputs");
        ImGui::Checkbox("Show step buttons", &inputs_step);
        ImGui::CheckboxFlags("ImGuiInputTextFlags_ReadOnly", &flags, ImGuiInputTextFlags_ReadOnly);
        ImGui::CheckboxFlags("ImGuiInputTextFlags_ParseEmptyRefVal", &flags, ImGuiInputTextFlags_ParseEmptyRefVal);
        ImGui::CheckboxFlags("ImGuiInputTextFlags_DisplayEmptyRefVal", &flags, ImGuiInputTextFlags_DisplayEmptyRefVal);
        ImGui::InputScalar("input s8",      ImGuiDataType_S8,     &s8_v,  inputs_step ? &s8_one  : NULL, NULL, "%d", flags);
        ImGui::InputScalar("input u8",      ImGuiDataType_U8,     &u8_v,  inputs_step ? &u8_one  : NULL, NULL, "%u", flags);
        ImGui::InputScalar("input s16",     ImGuiDataType_S16,    &s16_v, inputs_step ? &s16_one : NULL, NULL, "%d", flags);
        ImGui::InputScalar("input u16",     ImGuiDataType_U16,    &u16_v, inputs_step ? &u16_one : NULL, NULL, "%u", flags);
        ImGui::InputScalar("input s32",     ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%d", flags);
        ImGui::InputScalar("input s32 hex", ImGuiDataType_S32,    &s32_v, inputs_step ? &s32_one : NULL, NULL, "%04X", flags);
        ImGui::InputScalar("input u32",     ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%u", flags);
        ImGui::InputScalar("input u32 hex", ImGuiDataType_U32,    &u32_v, inputs_step ? &u32_one : NULL, NULL, "%08X", flags);
        ImGui::InputScalar("input s64",     ImGuiDataType_S64,    &s64_v, inputs_step ? &s64_one : NULL, NULL, NULL, flags);
        ImGui::InputScalar("input u64",     ImGuiDataType_U64,    &u64_v, inputs_step ? &u64_one : NULL, NULL, NULL, flags);
        ImGui::InputScalar("input float",   ImGuiDataType_Float,  &f32_v, inputs_step ? &f32_one : NULL, NULL, NULL, flags);
        ImGui::InputScalar("input double",  ImGuiDataType_Double, &f64_v, inputs_step ? &f64_one : NULL, NULL, NULL, flags);

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsDisableBlocks()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsDisableBlocks(ImGuiDemoWindowData* demo_data)
{
    IMGUI_DEMO_MARKER("Widgets/Disable Blocks");
    if (ImGui::TreeNode("Disable Blocks"))
    {
        ImGui::Checkbox("Disable entire section above", &demo_data->DisableSections);
        ImGui::SameLine(); HelpMarker("Demonstrate using BeginDisabled()/EndDisabled() across other sections.");
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsDragAndDrop()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsDragAndDrop()
{
    IMGUI_DEMO_MARKER("Widgets/Drag and drop");
    if (ImGui::TreeNode("Drag and Drop"))
    {
        IMGUI_DEMO_MARKER("Widgets/Drag and drop/Standard widgets");
        if (ImGui::TreeNode("Drag and drop in standard widgets"))
        {
            // ColorEdit widgets automatically act as drag source and drag target.
            // They are using standardized payload strings IMGUI_PAYLOAD_TYPE_COLOR_3F and IMGUI_PAYLOAD_TYPE_COLOR_4F
            // to allow your own widgets to use colors in their drag and drop interaction.
            // Also see 'Demo->Widgets->Color/Picker Widgets->Palette' demo.
            HelpMarker("You can drag from the color squares.");
            static float col1[3] = { 1.0f, 0.0f, 0.2f };
            static float col2[4] = { 0.4f, 0.7f, 0.0f, 0.5f };
            ImGui::ColorEdit3("color 1", col1);
            ImGui::ColorEdit4("color 2", col2);
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Drag and drop/Copy-swap items");
        if (ImGui::TreeNode("Drag and drop to copy/swap items"))
        {
            enum Mode
            {
                Mode_Copy,
                Mode_Move,
                Mode_Swap
            };
            static int mode = 0;
            if (ImGui::RadioButton("Copy", mode == Mode_Copy)) { mode = Mode_Copy; } ImGui::SameLine();
            if (ImGui::RadioButton("Move", mode == Mode_Move)) { mode = Mode_Move; } ImGui::SameLine();
            if (ImGui::RadioButton("Swap", mode == Mode_Swap)) { mode = Mode_Swap; }
            static const char* names[9] =
            {
                "Bobby", "Beatrice", "Betty",
                "Brianna", "Barry", "Bernard",
                "Bibi", "Blaine", "Bryn"
            };
            for (int n = 0; n < IM_ARRAYSIZE(names); n++)
            {
                ImGui::PushID(n);
                if ((n % 3) != 0)
                    ImGui::SameLine();
                ImGui::Button(names[n], ImVec2(60, 60));

                // Our buttons are both drag sources and drag targets here!
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set payload to carry the index of our item (could be anything)
                    ImGui::SetDragDropPayload("DND_DEMO_CELL", &n, sizeof(int));

                    // Display preview (could be anything, e.g. when dragging an image we could decide to display
                    // the filename and a small preview of the image, etc.)
                    if (mode == Mode_Copy) { ImGui::Text("Copy %s", names[n]); }
                    if (mode == Mode_Move) { ImGui::Text("Move %s", names[n]); }
                    if (mode == Mode_Swap) { ImGui::Text("Swap %s", names[n]); }
                    ImGui::EndDragDropSource();
                }
                if (ImGui::BeginDragDropTarget())
                {
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_DEMO_CELL"))
                    {
                        IM_ASSERT(payload->DataSize == sizeof(int));
                        int payload_n = *(const int*)payload->Data;
                        if (mode == Mode_Copy)
                        {
                            names[n] = names[payload_n];
                        }
                        if (mode == Mode_Move)
                        {
                            names[n] = names[payload_n];
                            names[payload_n] = "";
                        }
                        if (mode == Mode_Swap)
                        {
                            const char* tmp = names[n];
                            names[n] = names[payload_n];
                            names[payload_n] = tmp;
                        }
                    }
                    ImGui::EndDragDropTarget();
                }
                ImGui::PopID();
            }
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Drag and Drop/Drag to reorder items (simple)");
        if (ImGui::TreeNode("Drag to reorder items (simple)"))
        {
            // FIXME: there is temporary (usually single-frame) ID Conflict during reordering as a same item may be submitting twice.
            // This code was always slightly faulty but in a way which was not easily noticeable.
            // Until we fix this, enable ImGuiItemFlags_AllowDuplicateId to disable detecting the issue.
            ImGui::PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true);

            // Simple reordering
            HelpMarker(
                "We don't use the drag and drop api at all here! "
                "Instead we query when the item is held but not hovered, and order items accordingly.");
            static const char* item_names[] = { "Item One", "Item Two", "Item Three", "Item Four", "Item Five" };
            for (int n = 0; n < IM_ARRAYSIZE(item_names); n++)
            {
                const char* item = item_names[n];
                ImGui::Selectable(item);

                if (ImGui::IsItemActive() && !ImGui::IsItemHovered())
                {
                    int n_next = n + (ImGui::GetMouseDragDelta(0).y < 0.f ? -1 : 1);
                    if (n_next >= 0 && n_next < IM_ARRAYSIZE(item_names))
                    {
                        item_names[n] = item_names[n_next];
                        item_names[n_next] = item;
                        ImGui::ResetMouseDragDelta();
                    }
                }
            }

            ImGui::PopItemFlag();
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Drag and Drop/Tooltip at target location");
        if (ImGui::TreeNode("Tooltip at target location"))
        {
            for (int n = 0; n < 2; n++)
            {
                // Drop targets
                ImGui::Button(n ? "drop here##1" : "drop here##0");
                if (ImGui::BeginDragDropTarget())
                {
                    ImGuiDragDropFlags drop_target_flags = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoPreviewTooltip;
                    if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, drop_target_flags))
                    {
                        IM_UNUSED(payload);
                        ImGui::SetMouseCursor(ImGuiMouseCursor_NotAllowed);
                        ImGui::SetTooltip("Cannot drop here!");
                    }
                    ImGui::EndDragDropTarget();
                }

                // Drop source
                static ImVec4 col4 = { 1.0f, 0.0f, 0.2f, 1.0f };
                if (n == 0)
                    ImGui::ColorButton("drag me", col4);

            }
            ImGui::TreePop();
        }

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsDragsAndSliders()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsDragsAndSliders()
{
    IMGUI_DEMO_MARKER("Widgets/Drag and Slider Flags");
    if (ImGui::TreeNode("Drag/Slider Flags"))
    {
        // Demonstrate using advanced flags for DragXXX and SliderXXX functions. Note that the flags are the same!
        static ImGuiSliderFlags flags = ImGuiSliderFlags_None;
        ImGui::CheckboxFlags("ImGuiSliderFlags_AlwaysClamp", &flags, ImGuiSliderFlags_AlwaysClamp);
        ImGui::CheckboxFlags("ImGuiSliderFlags_ClampOnInput", &flags, ImGuiSliderFlags_ClampOnInput);
        ImGui::SameLine(); HelpMarker("Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.");
        ImGui::CheckboxFlags("ImGuiSliderFlags_ClampZeroRange", &flags, ImGuiSliderFlags_ClampZeroRange);
        ImGui::SameLine(); HelpMarker("Clamp even if min==max==0.0f. Otherwise DragXXX functions don't clamp.");
        ImGui::CheckboxFlags("ImGuiSliderFlags_Logarithmic", &flags, ImGuiSliderFlags_Logarithmic);
        ImGui::SameLine(); HelpMarker("Enable logarithmic editing (more precision for small values).");
        ImGui::CheckboxFlags("ImGuiSliderFlags_NoRoundToFormat", &flags, ImGuiSliderFlags_NoRoundToFormat);
        ImGui::SameLine(); HelpMarker("Disable rounding underlying value to match precision of the format string (e.g. %.3f values are rounded to those 3 digits).");
        ImGui::CheckboxFlags("ImGuiSliderFlags_NoInput", &flags, ImGuiSliderFlags_NoInput);
        ImGui::SameLine(); HelpMarker("Disable CTRL+Click or Enter key allowing to input text directly into the widget.");
        ImGui::CheckboxFlags("ImGuiSliderFlags_NoSpeedTweaks", &flags, ImGuiSliderFlags_NoSpeedTweaks);
        ImGui::SameLine(); HelpMarker("Disable keyboard modifiers altering tweak speed. Useful if you want to alter tweak speed yourself based on your own logic.");
        ImGui::CheckboxFlags("ImGuiSliderFlags_WrapAround", &flags, ImGuiSliderFlags_WrapAround);
        ImGui::SameLine(); HelpMarker("Enable wrapping around from max to min and from min to max (only supported by DragXXX() functions)");

        // Drags
        static float drag_f = 0.5f;
        static int drag_i = 50;
        ImGui::Text("Underlying float value: %f", drag_f);
        ImGui::DragFloat("DragFloat (0 -> 1)", &drag_f, 0.005f, 0.0f, 1.0f, "%.3f", flags);
        ImGui::DragFloat("DragFloat (0 -> +inf)", &drag_f, 0.005f, 0.0f, FLT_MAX, "%.3f", flags);
        ImGui::DragFloat("DragFloat (-inf -> 1)", &drag_f, 0.005f, -FLT_MAX, 1.0f, "%.3f", flags);
        ImGui::DragFloat("DragFloat (-inf -> +inf)", &drag_f, 0.005f, -FLT_MAX, +FLT_MAX, "%.3f", flags);
        //ImGui::DragFloat("DragFloat (0 -> 0)", &drag_f, 0.005f, 0.0f, 0.0f, "%.3f", flags);           // To test ClampZeroRange
        //ImGui::DragFloat("DragFloat (100 -> 100)", &drag_f, 0.005f, 100.0f, 100.0f, "%.3f", flags);
        ImGui::DragInt("DragInt (0 -> 100)", &drag_i, 0.5f, 0, 100, "%d", flags);

        // Sliders
        static float slider_f = 0.5f;
        static int slider_i = 50;
        const ImGuiSliderFlags flags_for_sliders = flags & ~ImGuiSliderFlags_WrapAround;
        ImGui::Text("Underlying float value: %f", slider_f);
        ImGui::SliderFloat("SliderFloat (0 -> 1)", &slider_f, 0.0f, 1.0f, "%.3f", flags_for_sliders);
        ImGui::SliderInt("SliderInt (0 -> 100)", &slider_i, 0, 100, "%d", flags_for_sliders);

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsFonts()
//-----------------------------------------------------------------------------

// Forward declare ShowFontAtlas() which isn't worth putting in public API yet
namespace ImGui { IMGUI_API void ShowFontAtlas(ImFontAtlas* atlas); }

static void DemoWindowWidgetsFonts()
{
    IMGUI_DEMO_MARKER("Widgets/Fonts");
    if (ImGui::TreeNode("Fonts"))
    {
        ImFontAtlas* atlas = ImGui::GetIO().Fonts;
        ImGui::ShowFontAtlas(atlas);
        // FIXME-NEWATLAS: Provide a demo to add/create a procedural font?
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsImages()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsImages()
{
    IMGUI_DEMO_MARKER("Widgets/Images");
    if (ImGui::TreeNode("Images"))
    {
        ImGuiIO& io = ImGui::GetIO();
        ImGui::TextWrapped(
            "Below we are displaying the font texture (which is the only texture we have access to in this demo). "
            "Use the 'ImTextureID' type as storage to pass pointers or identifier to your own texture data. "
            "Hover the texture for a zoomed view!");

        // Below we are displaying the font texture because it is the only texture we have access to inside the demo!
        // Read description about ImTextureID/ImTextureRef and FAQ for details about texture identifiers.
        // If you use one of the default imgui_impl_XXXX.cpp rendering backend, they all have comments at the top
        // of their respective source file to specify what they are using as texture identifier, for example:
        // - The imgui_impl_dx11.cpp renderer expect a 'ID3D11ShaderResourceView*' pointer.
        // - The imgui_impl_opengl3.cpp renderer expect a GLuint OpenGL texture identifier, etc.
        // So with the DirectX11 backend, you call ImGui::Image() with a 'ID3D11ShaderResourceView*' cast to ImTextureID.
        // - If you decided that ImTextureID = MyEngineTexture*, then you can pass your MyEngineTexture* pointers
        //   to ImGui::Image(), and gather width/height through your own functions, etc.
        // - You can use ShowMetricsWindow() to inspect the draw data that are being passed to your renderer,
        //   it will help you debug issues if you are confused about it.
        // - Consider using the lower-level ImDrawList::AddImage() API, via ImGui::GetWindowDrawList()->AddImage().
        // - Read https://github.com/ocornut/imgui/blob/master/docs/FAQ.md
        // - Read https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples

        // Grab the current texture identifier used by the font atlas.
        ImTextureRef my_tex_id = io.Fonts->TexRef;

        // Regular user code should never have to care about TexData-> fields, but since we want to display the entire texture here, we pull Width/Height from it.
        float my_tex_w = (float)io.Fonts->TexData->Width;
        float my_tex_h = (float)io.Fonts->TexData->Height;

        {
            ImGui::Text("%.0fx%.0f", my_tex_w, my_tex_h);
            ImVec2 pos = ImGui::GetCursorScreenPos();
            ImVec2 uv_min = ImVec2(0.0f, 0.0f); // Top-left
            ImVec2 uv_max = ImVec2(1.0f, 1.0f); // Lower-right
            ImGui::PushStyleVar(ImGuiStyleVar_ImageBorderSize, IM_MAX(1.0f, ImGui::GetStyle().ImageBorderSize));
            ImGui::ImageWithBg(my_tex_id, ImVec2(my_tex_w, my_tex_h), uv_min, uv_max, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
            if (ImGui::BeginItemTooltip())
            {
                float region_sz = 32.0f;
                float region_x = io.MousePos.x - pos.x - region_sz * 0.5f;
                float region_y = io.MousePos.y - pos.y - region_sz * 0.5f;
                float zoom = 4.0f;
                if (region_x < 0.0f) { region_x = 0.0f; }
                else if (region_x > my_tex_w - region_sz) { region_x = my_tex_w - region_sz; }
                if (region_y < 0.0f) { region_y = 0.0f; }
                else if (region_y > my_tex_h - region_sz) { region_y = my_tex_h - region_sz; }
                ImGui::Text("Min: (%.2f, %.2f)", region_x, region_y);
                ImGui::Text("Max: (%.2f, %.2f)", region_x + region_sz, region_y + region_sz);
                ImVec2 uv0 = ImVec2((region_x) / my_tex_w, (region_y) / my_tex_h);
                ImVec2 uv1 = ImVec2((region_x + region_sz) / my_tex_w, (region_y + region_sz) / my_tex_h);
                ImGui::ImageWithBg(my_tex_id, ImVec2(region_sz * zoom, region_sz * zoom), uv0, uv1, ImVec4(0.0f, 0.0f, 0.0f, 1.0f));
                ImGui::EndTooltip();
            }
            ImGui::PopStyleVar();
        }

        IMGUI_DEMO_MARKER("Widgets/Images/Textured buttons");
        ImGui::TextWrapped("And now some textured buttons..");
        static int pressed_count = 0;
        for (int i = 0; i < 8; i++)
        {
            // UV coordinates are often (0.0f, 0.0f) and (1.0f, 1.0f) to display an entire textures.
            // Here are trying to display only a 32x32 pixels area of the texture, hence the UV computation.
            // Read about UV coordinates here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
            ImGui::PushID(i);
            if (i > 0)
                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(i - 1.0f, i - 1.0f));
            ImVec2 size = ImVec2(32.0f, 32.0f);                         // Size of the image we want to make visible
            ImVec2 uv0 = ImVec2(0.0f, 0.0f);                            // UV coordinates for lower-left
            ImVec2 uv1 = ImVec2(32.0f / my_tex_w, 32.0f / my_tex_h);    // UV coordinates for (32,32) in our texture
            ImVec4 bg_col = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);             // Black background
            ImVec4 tint_col = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);           // No tint
            if (ImGui::ImageButton("", my_tex_id, size, uv0, uv1, bg_col, tint_col))
                pressed_count += 1;
            if (i > 0)
                ImGui::PopStyleVar();
            ImGui::PopID();
            ImGui::SameLine();
        }
        ImGui::NewLine();
        ImGui::Text("Pressed %d times.", pressed_count);
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsListBoxes()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsListBoxes()
{
    IMGUI_DEMO_MARKER("Widgets/List Boxes");
    if (ImGui::TreeNode("List Boxes"))
    {
        // BeginListBox() is essentially a thin wrapper to using BeginChild()/EndChild()
        // using the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.
        // You may be tempted to simply use BeginChild() directly. However note that BeginChild() requires EndChild()
        // to always be called (inconsistent with BeginListBox()/EndListBox()).

        // Using the generic BeginListBox() API, you have full control over how to display the combo contents.
        // (your selection data could be an index, a pointer to the object, an id for the object, a flag intrusively
        // stored in the object itself, etc.)
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD", "EEEE", "FFFF", "GGGG", "HHHH", "IIII", "JJJJ", "KKKK", "LLLLLLL", "MMMM", "OOOOOOO" };
        static int item_selected_idx = 0; // Here we store our selected data as an index.

        static bool item_highlight = false;
        int item_highlighted_idx = -1; // Here we store our highlighted data as an index.
        ImGui::Checkbox("Highlight hovered item in second listbox", &item_highlight);

        if (ImGui::BeginListBox("listbox 1"))
        {
            for (int n = 0; n < IM_ARRAYSIZE(items); n++)
            {
                const bool is_selected = (item_selected_idx == n);
                if (ImGui::Selectable(items[n], is_selected))
                    item_selected_idx = n;

                if (item_highlight && ImGui::IsItemHovered())
                    item_highlighted_idx = n;

                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
                if (is_selected)
                    ImGui::SetItemDefaultFocus();
            }
            ImGui::EndListBox();
        }
        ImGui::SameLine(); HelpMarker("Here we are sharing selection state between both boxes.");

        // Custom size: use all width, 5 items tall
        ImGui::Text("Full-width:");
        if (ImGui::BeginListBox("##listbox 2", ImVec2(-FLT_MIN, 5 * ImGui::GetTextLineHeightWithSpacing())))
        {
            for (int n = 0; n < IM_ARRAYSIZE(items); n++)
            {
                bool is_selected = (item_selected_idx == n);
                ImGuiSelectableFlags flags = (item_highlighted_idx == n) ? ImGuiSelectableFlags_Highlight : 0;
                if (ImGui::Selectable(items[n], is_selected, flags))
                    item_selected_idx = n;

                // Set the initial focus when opening the combo (scrolling + keyboard navigation focus)
                if (is_selected)
                    ImGui::SetItemDefaultFocus();
            }
            ImGui::EndListBox();
        }

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsMultiComponents()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsMultiComponents()
{
    IMGUI_DEMO_MARKER("Widgets/Multi-component Widgets");
    if (ImGui::TreeNode("Multi-component Widgets"))
    {
        static float vec4f[4] = { 0.10f, 0.20f, 0.30f, 0.44f };
        static int vec4i[4] = { 1, 5, 100, 255 };

        ImGui::SeparatorText("2-wide");
        ImGui::InputFloat2("input float2", vec4f);
        ImGui::DragFloat2("drag float2", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat2("slider float2", vec4f, 0.0f, 1.0f);
        ImGui::InputInt2("input int2", vec4i);
        ImGui::DragInt2("drag int2", vec4i, 1, 0, 255);
        ImGui::SliderInt2("slider int2", vec4i, 0, 255);

        ImGui::SeparatorText("3-wide");
        ImGui::InputFloat3("input float3", vec4f);
        ImGui::DragFloat3("drag float3", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat3("slider float3", vec4f, 0.0f, 1.0f);
        ImGui::InputInt3("input int3", vec4i);
        ImGui::DragInt3("drag int3", vec4i, 1, 0, 255);
        ImGui::SliderInt3("slider int3", vec4i, 0, 255);

        ImGui::SeparatorText("4-wide");
        ImGui::InputFloat4("input float4", vec4f);
        ImGui::DragFloat4("drag float4", vec4f, 0.01f, 0.0f, 1.0f);
        ImGui::SliderFloat4("slider float4", vec4f, 0.0f, 1.0f);
        ImGui::InputInt4("input int4", vec4i);
        ImGui::DragInt4("drag int4", vec4i, 1, 0, 255);
        ImGui::SliderInt4("slider int4", vec4i, 0, 255);

        ImGui::SeparatorText("Ranges");
        static float begin = 10, end = 90;
        static int begin_i = 100, end_i = 1000;
        ImGui::DragFloatRange2("range float", &begin, &end, 0.25f, 0.0f, 100.0f, "Min: %.1f %%", "Max: %.1f %%", ImGuiSliderFlags_AlwaysClamp);
        ImGui::DragIntRange2("range int", &begin_i, &end_i, 5, 0, 1000, "Min: %d units", "Max: %d units");
        ImGui::DragIntRange2("range int (no bounds)", &begin_i, &end_i, 5, 0, 0, "Min: %d units", "Max: %d units");

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsPlotting()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsPlotting()
{
    // Plot/Graph widgets are not very good.
// Consider using a third-party library such as ImPlot: https://github.com/epezent/implot
// (see others https://github.com/ocornut/imgui/wiki/Useful-Extensions)
    IMGUI_DEMO_MARKER("Widgets/Plotting");
    if (ImGui::TreeNode("Plotting"))
    {
        ImGui::Text("Need better plotting and graphing? Consider using ImPlot:");
        ImGui::TextLinkOpenURL("https://github.com/epezent/implot");
        ImGui::Separator();

        static bool animate = true;
        ImGui::Checkbox("Animate", &animate);

        // Plot as lines and plot as histogram
        static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
        ImGui::PlotLines("Frame Times", arr, IM_ARRAYSIZE(arr));
        ImGui::PlotHistogram("Histogram", arr, IM_ARRAYSIZE(arr), 0, NULL, 0.0f, 1.0f, ImVec2(0, 80.0f));
        //ImGui::SameLine(); HelpMarker("Consider using ImPlot instead!");

        // Fill an array of contiguous float values to plot
        // Tip: If your float aren't contiguous but part of a structure, you can pass a pointer to your first float
        // and the sizeof() of your structure in the "stride" parameter.
        static float values[90] = {};
        static int values_offset = 0;
        static double refresh_time = 0.0;
        if (!animate || refresh_time == 0.0)
            refresh_time = ImGui::GetTime();
        while (refresh_time < ImGui::GetTime()) // Create data at fixed 60 Hz rate for the demo
        {
            static float phase = 0.0f;
            values[values_offset] = cosf(phase);
            values_offset = (values_offset + 1) % IM_ARRAYSIZE(values);
            phase += 0.10f * values_offset;
            refresh_time += 1.0f / 60.0f;
        }

        // Plots can display overlay texts
        // (in this example, we will display an average value)
        {
            float average = 0.0f;
            for (int n = 0; n < IM_ARRAYSIZE(values); n++)
                average += values[n];
            average /= (float)IM_ARRAYSIZE(values);
            char overlay[32];
            sprintf(overlay, "avg %f", average);
            ImGui::PlotLines("Lines", values, IM_ARRAYSIZE(values), values_offset, overlay, -1.0f, 1.0f, ImVec2(0, 80.0f));
        }

        // Use functions to generate output
        // FIXME: This is actually VERY awkward because current plot API only pass in indices.
        // We probably want an API passing floats and user provide sample rate/count.
        struct Funcs
        {
            static float Sin(void*, int i) { return sinf(i * 0.1f); }
            static float Saw(void*, int i) { return (i & 1) ? 1.0f : -1.0f; }
        };
        static int func_type = 0, display_count = 70;
        ImGui::SeparatorText("Functions");
        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
        ImGui::Combo("func", &func_type, "Sin\0Saw\0");
        ImGui::SameLine();
        ImGui::SliderInt("Sample count", &display_count, 1, 400);
        float (*func)(void*, int) = (func_type == 0) ? Funcs::Sin : Funcs::Saw;
        ImGui::PlotLines("Lines##2", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0, 80));
        ImGui::PlotHistogram("Histogram##2", func, NULL, display_count, 0, NULL, -1.0f, 1.0f, ImVec2(0, 80));

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsProgressBars()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsProgressBars()
{
    IMGUI_DEMO_MARKER("Widgets/Progress Bars");
    if (ImGui::TreeNode("Progress Bars"))
    {
        // Animate a simple progress bar
        static float progress = 0.0f, progress_dir = 1.0f;
        progress += progress_dir * 0.4f * ImGui::GetIO().DeltaTime;
        if (progress >= +1.1f) { progress = +1.1f; progress_dir *= -1.0f; }
        if (progress <= -0.1f) { progress = -0.1f; progress_dir *= -1.0f; }

        // Typically we would use ImVec2(-1.0f,0.0f) or ImVec2(-FLT_MIN,0.0f) to use all available width,
        // or ImVec2(width,0.0f) for a specified width. ImVec2(0.0f,0.0f) uses ItemWidth.
        ImGui::ProgressBar(progress, ImVec2(0.0f, 0.0f));
        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
        ImGui::Text("Progress Bar");

        float progress_saturated = IM_CLAMP(progress, 0.0f, 1.0f);
        char buf[32];
        sprintf(buf, "%d/%d", (int)(progress_saturated * 1753), 1753);
        ImGui::ProgressBar(progress, ImVec2(0.f, 0.f), buf);

        // Pass an animated negative value, e.g. -1.0f * (float)ImGui::GetTime() is the recommended value.
        // Adjust the factor if you want to adjust the animation speed.
        ImGui::ProgressBar(-1.0f * (float)ImGui::GetTime(), ImVec2(0.0f, 0.0f), "Searching..");
        ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
        ImGui::Text("Indeterminate");

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsQueryingStatuses()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsQueryingStatuses()
{
    IMGUI_DEMO_MARKER("Widgets/Querying Item Status (Edited,Active,Hovered etc.)");
    if (ImGui::TreeNode("Querying Item Status (Edited/Active/Hovered etc.)"))
    {
        // Select an item type
        const char* item_names[] =
        {
            "Text", "Button", "Button (w/ repeat)", "Checkbox", "SliderFloat", "InputText", "InputTextMultiline", "InputFloat",
            "InputFloat3", "ColorEdit4", "Selectable", "MenuItem", "TreeNode", "TreeNode (w/ double-click)", "Combo", "ListBox"
        };
        static int item_type = 4;
        static bool item_disabled = false;
        ImGui::Combo("Item Type", &item_type, item_names, IM_ARRAYSIZE(item_names), IM_ARRAYSIZE(item_names));
        ImGui::SameLine();
        HelpMarker("Testing how various types of items are interacting with the IsItemXXX functions. Note that the bool return value of most ImGui function is generally equivalent to calling ImGui::IsItemHovered().");
        ImGui::Checkbox("Item Disabled", &item_disabled);

        // Submit selected items so we can query their status in the code following it.
        bool ret = false;
        static bool b = false;
        static float col4f[4] = { 1.0f, 0.5, 0.0f, 1.0f };
        static char str[16] = {};
        if (item_disabled)
            ImGui::BeginDisabled(true);
        if (item_type == 0) { ImGui::Text("ITEM: Text"); }                                              // Testing text items with no identifier/interaction
        if (item_type == 1) { ret = ImGui::Button("ITEM: Button"); }                                    // Testing button
        if (item_type == 2) { ImGui::PushItemFlag(ImGuiItemFlags_ButtonRepeat, true); ret = ImGui::Button("ITEM: Button"); ImGui::PopItemFlag(); } // Testing button (with repeater)
        if (item_type == 3) { ret = ImGui::Checkbox("ITEM: Checkbox", &b); }                            // Testing checkbox
        if (item_type == 4) { ret = ImGui::SliderFloat("ITEM: SliderFloat", &col4f[0], 0.0f, 1.0f); }   // Testing basic item
        if (item_type == 5) { ret = ImGui::InputText("ITEM: InputText", &str[0], IM_ARRAYSIZE(str)); }  // Testing input text (which handles tabbing)
        if (item_type == 6) { ret = ImGui::InputTextMultiline("ITEM: InputTextMultiline", &str[0], IM_ARRAYSIZE(str)); } // Testing input text (which uses a child window)
        if (item_type == 7) { ret = ImGui::InputFloat("ITEM: InputFloat", col4f, 1.0f); }               // Testing +/- buttons on scalar input
        if (item_type == 8) { ret = ImGui::InputFloat3("ITEM: InputFloat3", col4f); }                   // Testing multi-component items (IsItemXXX flags are reported merged)
        if (item_type == 9) { ret = ImGui::ColorEdit4("ITEM: ColorEdit4", col4f); }                     // Testing multi-component items (IsItemXXX flags are reported merged)
        if (item_type == 10) { ret = ImGui::Selectable("ITEM: Selectable"); }                            // Testing selectable item
        if (item_type == 11) { ret = ImGui::MenuItem("ITEM: MenuItem"); }                                // Testing menu item (they use ImGuiButtonFlags_PressedOnRelease button policy)
        if (item_type == 12) { ret = ImGui::TreeNode("ITEM: TreeNode"); if (ret) ImGui::TreePop(); }     // Testing tree node
        if (item_type == 13) { ret = ImGui::TreeNodeEx("ITEM: TreeNode w/ ImGuiTreeNodeFlags_OpenOnDoubleClick", ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_NoTreePushOnOpen); } // Testing tree node with ImGuiButtonFlags_PressedOnDoubleClick button policy.
        if (item_type == 14) { const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi" }; static int current = 1; ret = ImGui::Combo("ITEM: Combo", &current, items, IM_ARRAYSIZE(items)); }
        if (item_type == 15) { const char* items[] = { "Apple", "Banana", "Cherry", "Kiwi" }; static int current = 1; ret = ImGui::ListBox("ITEM: ListBox", &current, items, IM_ARRAYSIZE(items), IM_ARRAYSIZE(items)); }

        bool hovered_delay_none = ImGui::IsItemHovered();
        bool hovered_delay_stationary = ImGui::IsItemHovered(ImGuiHoveredFlags_Stationary);
        bool hovered_delay_short = ImGui::IsItemHovered(ImGuiHoveredFlags_DelayShort);
        bool hovered_delay_normal = ImGui::IsItemHovered(ImGuiHoveredFlags_DelayNormal);
        bool hovered_delay_tooltip = ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip); // = Normal + Stationary

        // Display the values of IsItemHovered() and other common item state functions.
        // Note that the ImGuiHoveredFlags_XXX flags can be combined.
        // Because BulletText is an item itself and that would affect the output of IsItemXXX functions,
        // we query every state in a single call to avoid storing them and to simplify the code.
        ImGui::BulletText(
            "Return value = %d\n"
            "IsItemFocused() = %d\n"
            "IsItemHovered() = %d\n"
            "IsItemHovered(_AllowWhenBlockedByPopup) = %d\n"
            "IsItemHovered(_AllowWhenBlockedByActiveItem) = %d\n"
            "IsItemHovered(_AllowWhenOverlappedByItem) = %d\n"
            "IsItemHovered(_AllowWhenOverlappedByWindow) = %d\n"
            "IsItemHovered(_AllowWhenDisabled) = %d\n"
            "IsItemHovered(_RectOnly) = %d\n"
            "IsItemActive() = %d\n"
            "IsItemEdited() = %d\n"
            "IsItemActivated() = %d\n"
            "IsItemDeactivated() = %d\n"
            "IsItemDeactivatedAfterEdit() = %d\n"
            "IsItemVisible() = %d\n"
            "IsItemClicked() = %d\n"
            "IsItemToggledOpen() = %d\n"
            "GetItemRectMin() = (%.1f, %.1f)\n"
            "GetItemRectMax() = (%.1f, %.1f)\n"
            "GetItemRectSize() = (%.1f, %.1f)",
            ret,
            ImGui::IsItemFocused(),
            ImGui::IsItemHovered(),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlappedByItem),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenOverlappedByWindow),
            ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled),
            ImGui::IsItemHovered(ImGuiHoveredFlags_RectOnly),
            ImGui::IsItemActive(),
            ImGui::IsItemEdited(),
            ImGui::IsItemActivated(),
            ImGui::IsItemDeactivated(),
            ImGui::IsItemDeactivatedAfterEdit(),
            ImGui::IsItemVisible(),
            ImGui::IsItemClicked(),
            ImGui::IsItemToggledOpen(),
            ImGui::GetItemRectMin().x, ImGui::GetItemRectMin().y,
            ImGui::GetItemRectMax().x, ImGui::GetItemRectMax().y,
            ImGui::GetItemRectSize().x, ImGui::GetItemRectSize().y
        );
        ImGui::BulletText(
            "with Hovering Delay or Stationary test:\n"
            "IsItemHovered() = %d\n"
            "IsItemHovered(_Stationary) = %d\n"
            "IsItemHovered(_DelayShort) = %d\n"
            "IsItemHovered(_DelayNormal) = %d\n"
            "IsItemHovered(_Tooltip) = %d",
            hovered_delay_none, hovered_delay_stationary, hovered_delay_short, hovered_delay_normal, hovered_delay_tooltip);

        if (item_disabled)
            ImGui::EndDisabled();

        char buf[1] = "";
        ImGui::InputText("unused", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_ReadOnly);
        ImGui::SameLine();
        HelpMarker("This widget is only here to be able to tab-out of the widgets above and see e.g. Deactivated() status.");

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Widgets/Querying Window Status (Focused,Hovered etc.)");
    if (ImGui::TreeNode("Querying Window Status (Focused/Hovered etc.)"))
    {
        static bool embed_all_inside_a_child_window = false;
        ImGui::Checkbox("Embed everything inside a child window for testing _RootWindow flag.", &embed_all_inside_a_child_window);
        if (embed_all_inside_a_child_window)
            ImGui::BeginChild("outer_child", ImVec2(0, ImGui::GetFontSize() * 20.0f), ImGuiChildFlags_Borders);

        // Testing IsWindowFocused() function with its various flags.
        ImGui::BulletText(
            "IsWindowFocused() = %d\n"
            "IsWindowFocused(_ChildWindows) = %d\n"
            "IsWindowFocused(_ChildWindows|_NoPopupHierarchy) = %d\n"
            "IsWindowFocused(_ChildWindows|_RootWindow) = %d\n"
            "IsWindowFocused(_ChildWindows|_RootWindow|_NoPopupHierarchy) = %d\n"
            "IsWindowFocused(_RootWindow) = %d\n"
            "IsWindowFocused(_RootWindow|_NoPopupHierarchy) = %d\n"
            "IsWindowFocused(_AnyWindow) = %d\n",
            ImGui::IsWindowFocused(),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_NoPopupHierarchy),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_ChildWindows | ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_NoPopupHierarchy),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_NoPopupHierarchy),
            ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow));

        // Testing IsWindowHovered() function with its various flags.
        ImGui::BulletText(
            "IsWindowHovered() = %d\n"
            "IsWindowHovered(_AllowWhenBlockedByPopup) = %d\n"
            "IsWindowHovered(_AllowWhenBlockedByActiveItem) = %d\n"
            "IsWindowHovered(_ChildWindows) = %d\n"
            "IsWindowHovered(_ChildWindows|_NoPopupHierarchy) = %d\n"
            "IsWindowHovered(_ChildWindows|_RootWindow) = %d\n"
            "IsWindowHovered(_ChildWindows|_RootWindow|_NoPopupHierarchy) = %d\n"
            "IsWindowHovered(_RootWindow) = %d\n"
            "IsWindowHovered(_RootWindow|_NoPopupHierarchy) = %d\n"
            "IsWindowHovered(_ChildWindows|_AllowWhenBlockedByPopup) = %d\n"
            "IsWindowHovered(_AnyWindow) = %d\n"
            "IsWindowHovered(_Stationary) = %d\n",
            ImGui::IsWindowHovered(),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_NoPopupHierarchy),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_NoPopupHierarchy),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_NoPopupHierarchy),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_AllowWhenBlockedByPopup),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow),
            ImGui::IsWindowHovered(ImGuiHoveredFlags_Stationary));

        ImGui::BeginChild("child", ImVec2(0, 50), ImGuiChildFlags_Borders);
        ImGui::Text("This is another child window for testing the _ChildWindows flag.");
        ImGui::EndChild();
        if (embed_all_inside_a_child_window)
            ImGui::EndChild();

        // Calling IsItemHovered() after begin returns the hovered status of the title bar.
        // This is useful in particular if you want to create a context menu associated to the title bar of a window.
        static bool test_window = false;
        ImGui::Checkbox("Hovered/Active tests after Begin() for title bar testing", &test_window);
        if (test_window)
        {
            ImGui::Begin("Title bar Hovered/Active tests", &test_window);
            if (ImGui::BeginPopupContextItem()) // <-- This is using IsItemHovered()
            {
                if (ImGui::MenuItem("Close")) { test_window = false; }
                ImGui::EndPopup();
            }
            ImGui::Text(
                "IsItemHovered() after begin = %d (== is title bar hovered)\n"
                "IsItemActive() after begin = %d (== is window being clicked/moved)\n",
                ImGui::IsItemHovered(), ImGui::IsItemActive());
            ImGui::End();
        }

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsSelectables()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsSelectables()
{
    IMGUI_DEMO_MARKER("Widgets/Selectables");
    //ImGui::SetNextItemOpen(true, ImGuiCond_Once);
    if (ImGui::TreeNode("Selectables"))
    {
        // Selectable() has 2 overloads:
        // - The one taking "bool selected" as a read-only selection information.
        //   When Selectable() has been clicked it returns true and you can alter selection state accordingly.
        // - The one taking "bool* p_selected" as a read-write selection information (convenient in some cases)
        // The earlier is more flexible, as in real application your selection may be stored in many different ways
        // and not necessarily inside a bool value (e.g. in flags within objects, as an external list, etc).
        IMGUI_DEMO_MARKER("Widgets/Selectables/Basic");
        if (ImGui::TreeNode("Basic"))
        {
            static bool selection[5] = { false, true, false, false };
            ImGui::Selectable("1. I am selectable", &selection[0]);
            ImGui::Selectable("2. I am selectable", &selection[1]);
            ImGui::Selectable("3. I am selectable", &selection[2]);
            if (ImGui::Selectable("4. I am double clickable", selection[3], ImGuiSelectableFlags_AllowDoubleClick))
                if (ImGui::IsMouseDoubleClicked(0))
                    selection[3] = !selection[3];
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Selectables/Rendering more items on the same line");
        if (ImGui::TreeNode("Rendering more items on the same line"))
        {
            // (1) Using SetNextItemAllowOverlap()
            // (2) Using the Selectable() override that takes "bool* p_selected" parameter, the bool value is toggled automatically.
            static bool selected[3] = { false, false, false };
            ImGui::SetNextItemAllowOverlap(); ImGui::Selectable("main.c", &selected[0]); ImGui::SameLine(); ImGui::SmallButton("Link 1");
            ImGui::SetNextItemAllowOverlap(); ImGui::Selectable("Hello.cpp", &selected[1]); ImGui::SameLine(); ImGui::SmallButton("Link 2");
            ImGui::SetNextItemAllowOverlap(); ImGui::Selectable("Hello.h", &selected[2]); ImGui::SameLine(); ImGui::SmallButton("Link 3");
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Selectables/In Tables");
        if (ImGui::TreeNode("In Tables"))
        {
            static bool selected[10] = {};

            if (ImGui::BeginTable("split1", 3, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_Borders))
            {
                for (int i = 0; i < 10; i++)
                {
                    char label[32];
                    sprintf(label, "Item %d", i);
                    ImGui::TableNextColumn();
                    ImGui::Selectable(label, &selected[i]); // FIXME-TABLE: Selection overlap
                }
                ImGui::EndTable();
            }
            ImGui::Spacing();
            if (ImGui::BeginTable("split2", 3, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_Borders))
            {
                for (int i = 0; i < 10; i++)
                {
                    char label[32];
                    sprintf(label, "Item %d", i);
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn();
                    ImGui::Selectable(label, &selected[i], ImGuiSelectableFlags_SpanAllColumns);
                    ImGui::TableNextColumn();
                    ImGui::Text("Some other contents");
                    ImGui::TableNextColumn();
                    ImGui::Text("123456");
                }
                ImGui::EndTable();
            }
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Selectables/Grid");
        if (ImGui::TreeNode("Grid"))
        {
            static char selected[4][4] = { { 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 1 } };

            // Add in a bit of silly fun...
            const float time = (float)ImGui::GetTime();
            const bool winning_state = memchr(selected, 0, sizeof(selected)) == NULL; // If all cells are selected...
            if (winning_state)
                ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, ImVec2(0.5f + 0.5f * cosf(time * 2.0f), 0.5f + 0.5f * sinf(time * 3.0f)));

            for (int y = 0; y < 4; y++)
                for (int x = 0; x < 4; x++)
                {
                    if (x > 0)
                        ImGui::SameLine();
                    ImGui::PushID(y * 4 + x);
                    if (ImGui::Selectable("Sailor", selected[y][x] != 0, 0, ImVec2(50, 50)))
                    {
                        // Toggle clicked cell + toggle neighbors
                        selected[y][x] ^= 1;
                        if (x > 0) { selected[y][x - 1] ^= 1; }
                        if (x < 3) { selected[y][x + 1] ^= 1; }
                        if (y > 0) { selected[y - 1][x] ^= 1; }
                        if (y < 3) { selected[y + 1][x] ^= 1; }
                    }
                    ImGui::PopID();
                }

            if (winning_state)
                ImGui::PopStyleVar();
            ImGui::TreePop();
        }
        IMGUI_DEMO_MARKER("Widgets/Selectables/Alignment");
        if (ImGui::TreeNode("Alignment"))
        {
            HelpMarker(
                "By default, Selectables uses style.SelectableTextAlign but it can be overridden on a per-item "
                "basis using PushStyleVar(). You'll probably want to always keep your default situation to "
                "left-align otherwise it becomes difficult to layout multiple items on a same line");
            static bool selected[3 * 3] = { true, false, true, false, true, false, true, false, true };
            for (int y = 0; y < 3; y++)
            {
                for (int x = 0; x < 3; x++)
                {
                    ImVec2 alignment = ImVec2((float)x / 2.0f, (float)y / 2.0f);
                    char name[32];
                    sprintf(name, "(%.1f,%.1f)", alignment.x, alignment.y);
                    if (x > 0) ImGui::SameLine();
                    ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, alignment);
                    ImGui::Selectable(name, &selected[3 * y + x], ImGuiSelectableFlags_None, ImVec2(80, 80));
                    ImGui::PopStyleVar();
                }
            }
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsSelectionAndMultiSelect()
//-----------------------------------------------------------------------------
// Multi-selection demos
// Also read: https://github.com/ocornut/imgui/wiki/Multi-Select
//-----------------------------------------------------------------------------

static const char* ExampleNames[] =
{
    "Artichoke", "Arugula", "Asparagus", "Avocado", "Bamboo Shoots", "Bean Sprouts", "Beans", "Beet", "Belgian Endive", "Bell Pepper",
    "Bitter Gourd", "Bok Choy", "Broccoli", "Brussels Sprouts", "Burdock Root", "Cabbage", "Calabash", "Capers", "Carrot", "Cassava",
    "Cauliflower", "Celery", "Celery Root", "Celcuce", "Chayote", "Chinese Broccoli", "Corn", "Cucumber"
};

// Extra functions to add deletion support to ImGuiSelectionBasicStorage
struct ExampleSelectionWithDeletion : ImGuiSelectionBasicStorage
{
    // Find which item should be Focused after deletion.
    // Call _before_ item submission. Return an index in the before-deletion item list, your item loop should call SetKeyboardFocusHere() on it.
    // The subsequent ApplyDeletionPostLoop() code will use it to apply Selection.
    // - We cannot provide this logic in core Dear ImGui because we don't have access to selection data.
    // - We don't actually manipulate the ImVector<> here, only in ApplyDeletionPostLoop(), but using similar API for consistency and flexibility.
    // - Important: Deletion only works if the underlying ImGuiID for your items are stable: aka not depend on their index, but on e.g. item id/ptr.
    // FIXME-MULTISELECT: Doesn't take account of the possibility focus target will be moved during deletion. Need refocus or scroll offset.
    int ApplyDeletionPreLoop(ImGuiMultiSelectIO* ms_io, int items_count)
    {
        if (Size == 0)
            return -1;

        // If focused item is not selected...
        const int focused_idx = (int)ms_io->NavIdItem;  // Index of currently focused item
        if (ms_io->NavIdSelected == false)  // This is merely a shortcut, == Contains(adapter->IndexToStorage(items, focused_idx))
        {
            ms_io->RangeSrcReset = true;    // Request to recover RangeSrc from NavId next frame. Would be ok to reset even when NavIdSelected==true, but it would take an extra frame to recover RangeSrc when deleting a selected item.
            return focused_idx;             // Request to focus same item after deletion.
        }

        // If focused item is selected: land on first unselected item after focused item.
        for (int idx = focused_idx + 1; idx < items_count; idx++)
            if (!Contains(GetStorageIdFromIndex(idx)))
                return idx;

        // If focused item is selected: otherwise return last unselected item before focused item.
        for (int idx = IM_MIN(focused_idx, items_count) - 1; idx >= 0; idx--)
            if (!Contains(GetStorageIdFromIndex(idx)))
                return idx;

        return -1;
    }

    // Rewrite item list (delete items) + update selection.
    // - Call after EndMultiSelect()
    // - We cannot provide this logic in core Dear ImGui because we don't have access to your items, nor to selection data.
    template<typename ITEM_TYPE>
    void ApplyDeletionPostLoop(ImGuiMultiSelectIO* ms_io, ImVector<ITEM_TYPE>& items, int item_curr_idx_to_select)
    {
        // Rewrite item list (delete items) + convert old selection index (before deletion) to new selection index (after selection).
        // If NavId was not part of selection, we will stay on same item.
        ImVector<ITEM_TYPE> new_items;
        new_items.reserve(items.Size - Size);
        int item_next_idx_to_select = -1;
        for (int idx = 0; idx < items.Size; idx++)
        {
            if (!Contains(GetStorageIdFromIndex(idx)))
                new_items.push_back(items[idx]);
            if (item_curr_idx_to_select == idx)
                item_next_idx_to_select = new_items.Size - 1;
        }
        items.swap(new_items);

        // Update selection
        Clear();
        if (item_next_idx_to_select != -1 && ms_io->NavIdSelected)
            SetItemSelected(GetStorageIdFromIndex(item_next_idx_to_select), true);
    }
};

// Example: Implement dual list box storage and interface
struct ExampleDualListBox
{
    ImVector<ImGuiID>           Items[2];               // ID is index into ExampleName[]
    ImGuiSelectionBasicStorage  Selections[2];          // Store ExampleItemId into selection
    bool                        OptKeepSorted = true;

    void MoveAll(int src, int dst)
    {
        IM_ASSERT((src == 0 && dst == 1) || (src == 1 && dst == 0));
        for (ImGuiID item_id : Items[src])
            Items[dst].push_back(item_id);
        Items[src].clear();
        SortItems(dst);
        Selections[src].Swap(Selections[dst]);
        Selections[src].Clear();
    }
    void MoveSelected(int src, int dst)
    {
        for (int src_n = 0; src_n < Items[src].Size; src_n++)
        {
            ImGuiID item_id = Items[src][src_n];
            if (!Selections[src].Contains(item_id))
                continue;
            Items[src].erase(&Items[src][src_n]); // FIXME-OPT: Could be implemented more optimally (rebuild src items and swap)
            Items[dst].push_back(item_id);
            src_n--;
        }
        if (OptKeepSorted)
            SortItems(dst);
        Selections[src].Swap(Selections[dst]);
        Selections[src].Clear();
    }
    void ApplySelectionRequests(ImGuiMultiSelectIO* ms_io, int side)
    {
        // In this example we store item id in selection (instead of item index)
        Selections[side].UserData = Items[side].Data;
        Selections[side].AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { ImGuiID* items = (ImGuiID*)self->UserData; return items[idx]; };
        Selections[side].ApplyRequests(ms_io);
    }
    static int IMGUI_CDECL CompareItemsByValue(const void* lhs, const void* rhs)
    {
        const int* a = (const int*)lhs;
        const int* b = (const int*)rhs;
        return (*a - *b);
    }
    void SortItems(int n)
    {
        qsort(Items[n].Data, (size_t)Items[n].Size, sizeof(Items[n][0]), CompareItemsByValue);
    }
    void Show()
    {
        //if (ImGui::Checkbox("Sorted", &OptKeepSorted) && OptKeepSorted) { SortItems(0); SortItems(1); }
        if (ImGui::BeginTable("split", 3, ImGuiTableFlags_None))
        {
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthStretch);    // Left side
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed);      // Buttons
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthStretch);    // Right side
            ImGui::TableNextRow();

            int request_move_selected = -1;
            int request_move_all = -1;
            float child_height_0 = 0.0f;
            for (int side = 0; side < 2; side++)
            {
                // FIXME-MULTISELECT: Dual List Box: Add context menus
                // FIXME-NAV: Using ImGuiWindowFlags_NavFlattened exhibit many issues.
                ImVector<ImGuiID>& items = Items[side];
                ImGuiSelectionBasicStorage& selection = Selections[side];

                ImGui::TableSetColumnIndex((side == 0) ? 0 : 2);
                ImGui::Text("%s (%d)", (side == 0) ? "Available" : "Basket", items.Size);

                // Submit scrolling range to avoid glitches on moving/deletion
                const float items_height = ImGui::GetTextLineHeightWithSpacing();
                ImGui::SetNextWindowContentSize(ImVec2(0.0f, items.Size * items_height));

                bool child_visible;
                if (side == 0)
                {
                    // Left child is resizable
                    ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, ImGui::GetFrameHeightWithSpacing() * 4), ImVec2(FLT_MAX, FLT_MAX));
                    child_visible = ImGui::BeginChild("0", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY);
                    child_height_0 = ImGui::GetWindowSize().y;
                }
                else
                {
                    // Right child use same height as left one
                    child_visible = ImGui::BeginChild("1", ImVec2(-FLT_MIN, child_height_0), ImGuiChildFlags_FrameStyle);
                }
                if (child_visible)
                {
                    ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_None;
                    ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, items.Size);
                    ApplySelectionRequests(ms_io, side);

                    for (int item_n = 0; item_n < items.Size; item_n++)
                    {
                        ImGuiID item_id = items[item_n];
                        bool item_is_selected = selection.Contains(item_id);
                        ImGui::SetNextItemSelectionUserData(item_n);
                        ImGui::Selectable(ExampleNames[item_id], item_is_selected, ImGuiSelectableFlags_AllowDoubleClick);
                        if (ImGui::IsItemFocused())
                        {
                            // FIXME-MULTISELECT: Dual List Box: Transfer focus
                            if (ImGui::IsKeyPressed(ImGuiKey_Enter) || ImGui::IsKeyPressed(ImGuiKey_KeypadEnter))
                                request_move_selected = side;
                            if (ImGui::IsMouseDoubleClicked(0)) // FIXME-MULTISELECT: Double-click on multi-selection?
                                request_move_selected = side;
                        }
                    }

                    ms_io = ImGui::EndMultiSelect();
                    ApplySelectionRequests(ms_io, side);
                }
                ImGui::EndChild();
            }

            // Buttons columns
            ImGui::TableSetColumnIndex(1);
            ImGui::NewLine();
            //ImVec2 button_sz = { ImGui::CalcTextSize(">>").x + ImGui::GetStyle().FramePadding.x * 2.0f, ImGui::GetFrameHeight() + padding.y * 2.0f };
            ImVec2 button_sz = { ImGui::GetFrameHeight(), ImGui::GetFrameHeight() };

            // (Using BeginDisabled()/EndDisabled() works but feels distracting given how it is currently visualized)
            if (ImGui::Button(">>", button_sz))
                request_move_all = 0;
            if (ImGui::Button(">", button_sz))
                request_move_selected = 0;
            if (ImGui::Button("<", button_sz))
                request_move_selected = 1;
            if (ImGui::Button("<<", button_sz))
                request_move_all = 1;

            // Process requests
            if (request_move_all != -1)
                MoveAll(request_move_all, request_move_all ^ 1);
            if (request_move_selected != -1)
                MoveSelected(request_move_selected, request_move_selected ^ 1);

            // FIXME-MULTISELECT: Support action from outside
            /*
            if (OptKeepSorted == false)
            {
                ImGui::NewLine();
                if (ImGui::ArrowButton("MoveUp", ImGuiDir_Up)) {}
                if (ImGui::ArrowButton("MoveDown", ImGuiDir_Down)) {}
            }
            */

            ImGui::EndTable();
        }
    }
};

static void DemoWindowWidgetsSelectionAndMultiSelect(ImGuiDemoWindowData* demo_data)
{
    IMGUI_DEMO_MARKER("Widgets/Selection State & Multi-Select");
    if (ImGui::TreeNode("Selection State & Multi-Select"))
    {
        HelpMarker("Selections can be built using Selectable(), TreeNode() or other widgets. Selection state is owned by application code/data.");

        ImGui::BulletText("Wiki page:");
        ImGui::SameLine();
        ImGui::TextLinkOpenURL("imgui/wiki/Multi-Select", "https://github.com/ocornut/imgui/wiki/Multi-Select");

        // Without any fancy API: manage single-selection yourself.
        IMGUI_DEMO_MARKER("Widgets/Selection State/Single-Select");
        if (ImGui::TreeNode("Single-Select"))
        {
            static int selected = -1;
            for (int n = 0; n < 5; n++)
            {
                char buf[32];
                sprintf(buf, "Object %d", n);
                if (ImGui::Selectable(buf, selected == n))
                    selected = n;
            }
            ImGui::TreePop();
        }

        // Demonstrate implementation a most-basic form of multi-selection manually
        // This doesn't support the SHIFT modifier which requires BeginMultiSelect()!
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (manual/simplified, without BeginMultiSelect)");
        if (ImGui::TreeNode("Multi-Select (manual/simplified, without BeginMultiSelect)"))
        {
            HelpMarker("Hold CTRL and click to select multiple items.");
            static bool selection[5] = { false, false, false, false, false };
            for (int n = 0; n < 5; n++)
            {
                char buf[32];
                sprintf(buf, "Object %d", n);
                if (ImGui::Selectable(buf, selection[n]))
                {
                    if (!ImGui::GetIO().KeyCtrl) // Clear selection when CTRL is not held
                        memset(selection, 0, sizeof(selection));
                    selection[n] ^= 1; // Toggle current item
                }
            }
            ImGui::TreePop();
        }

        // Demonstrate handling proper multi-selection using the BeginMultiSelect/EndMultiSelect API.
        // SHIFT+Click w/ CTRL and other standard features are supported.
        // We use the ImGuiSelectionBasicStorage helper which you may freely reimplement.
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select");
        if (ImGui::TreeNode("Multi-Select"))
        {
            ImGui::Text("Supported features:");
            ImGui::BulletText("Keyboard navigation (arrows, page up/down, home/end, space).");
            ImGui::BulletText("Ctrl modifier to preserve and toggle selection.");
            ImGui::BulletText("Shift modifier for range selection.");
            ImGui::BulletText("CTRL+A to select all.");
            ImGui::BulletText("Escape to clear selection.");
            ImGui::BulletText("Click and drag to box-select.");
            ImGui::Text("Tip: Use 'Demo->Tools->Debug Log->Selection' to see selection requests as they happen.");

            // Use default selection.Adapter: Pass index to SetNextItemSelectionUserData(), store index in Selection
            const int ITEMS_COUNT = 50;
            static ImGuiSelectionBasicStorage selection;
            ImGui::Text("Selection: %d/%d", selection.Size, ITEMS_COUNT);

            // The BeginChild() has no purpose for selection logic, other that offering a scrolling region.
            if (ImGui::BeginChild("##Basket", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))
            {
                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, ITEMS_COUNT);
                selection.ApplyRequests(ms_io);

                for (int n = 0; n < ITEMS_COUNT; n++)
                {
                    char label[64];
                    sprintf(label, "Object %05d: %s", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);
                    bool item_is_selected = selection.Contains((ImGuiID)n);
                    ImGui::SetNextItemSelectionUserData(n);
                    ImGui::Selectable(label, item_is_selected);
                }

                ms_io = ImGui::EndMultiSelect();
                selection.ApplyRequests(ms_io);
            }
            ImGui::EndChild();
            ImGui::TreePop();
        }

        // Demonstrate using the clipper with BeginMultiSelect()/EndMultiSelect()
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (with clipper)");
        if (ImGui::TreeNode("Multi-Select (with clipper)"))
        {
            // Use default selection.Adapter: Pass index to SetNextItemSelectionUserData(), store index in Selection
            static ImGuiSelectionBasicStorage selection;

            ImGui::Text("Added features:");
            ImGui::BulletText("Using ImGuiListClipper.");

            const int ITEMS_COUNT = 10000;
            ImGui::Text("Selection: %d/%d", selection.Size, ITEMS_COUNT);
            if (ImGui::BeginChild("##Basket", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))
            {
                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, ITEMS_COUNT);
                selection.ApplyRequests(ms_io);

                ImGuiListClipper clipper;
                clipper.Begin(ITEMS_COUNT);
                if (ms_io->RangeSrcItem != -1)
                    clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem); // Ensure RangeSrc item is not clipped.
                while (clipper.Step())
                {
                    for (int n = clipper.DisplayStart; n < clipper.DisplayEnd; n++)
                    {
                        char label[64];
                        sprintf(label, "Object %05d: %s", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);
                        bool item_is_selected = selection.Contains((ImGuiID)n);
                        ImGui::SetNextItemSelectionUserData(n);
                        ImGui::Selectable(label, item_is_selected);
                    }
                }

                ms_io = ImGui::EndMultiSelect();
                selection.ApplyRequests(ms_io);
            }
            ImGui::EndChild();
            ImGui::TreePop();
        }

        // Demonstrate dynamic item list + deletion support using the BeginMultiSelect/EndMultiSelect API.
        // In order to support Deletion without any glitches you need to:
        // - (1) If items are submitted in their own scrolling area, submit contents size SetNextWindowContentSize() ahead of time to prevent one-frame readjustment of scrolling.
        // - (2) Items needs to have persistent ID Stack identifier = ID needs to not depends on their index. PushID(index) = KO. PushID(item_id) = OK. This is in order to focus items reliably after a selection.
        // - (3) BeginXXXX process
        // - (4) Focus process
        // - (5) EndXXXX process
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (with deletion)");
        if (ImGui::TreeNode("Multi-Select (with deletion)"))
        {
            // Storing items data separately from selection data.
            // (you may decide to store selection data inside your item (aka intrusive storage) if you don't need multiple views over same items)
            // Use a custom selection.Adapter: store item identifier in Selection (instead of index)
            static ImVector<ImGuiID> items;
            static ExampleSelectionWithDeletion selection;
            selection.UserData = (void*)&items;
            selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { ImVector<ImGuiID>* p_items = (ImVector<ImGuiID>*)self->UserData; return (*p_items)[idx]; }; // Index -> ID

            ImGui::Text("Added features:");
            ImGui::BulletText("Dynamic list with Delete key support.");
            ImGui::Text("Selection size: %d/%d", selection.Size, items.Size);

            // Initialize default list with 50 items + button to add/remove items.
            static ImGuiID items_next_id = 0;
            if (items_next_id == 0)
                for (ImGuiID n = 0; n < 50; n++)
                    items.push_back(items_next_id++);
            if (ImGui::SmallButton("Add 20 items"))     { for (int n = 0; n < 20; n++) { items.push_back(items_next_id++); } }
            ImGui::SameLine();
            if (ImGui::SmallButton("Remove 20 items"))  { for (int n = IM_MIN(20, items.Size); n > 0; n--) { selection.SetItemSelected(items.back(), false); items.pop_back(); } }

            // (1) Extra to support deletion: Submit scrolling range to avoid glitches on deletion
            const float items_height = ImGui::GetTextLineHeightWithSpacing();
            ImGui::SetNextWindowContentSize(ImVec2(0.0f, items.Size * items_height));

            if (ImGui::BeginChild("##Basket", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))
            {
                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, items.Size);
                selection.ApplyRequests(ms_io);

                const bool want_delete = ImGui::Shortcut(ImGuiKey_Delete, ImGuiInputFlags_Repeat) && (selection.Size > 0);
                const int item_curr_idx_to_focus = want_delete ? selection.ApplyDeletionPreLoop(ms_io, items.Size) : -1;

                for (int n = 0; n < items.Size; n++)
                {
                    const ImGuiID item_id = items[n];
                    char label[64];
                    sprintf(label, "Object %05u: %s", item_id, ExampleNames[item_id % IM_ARRAYSIZE(ExampleNames)]);

                    bool item_is_selected = selection.Contains(item_id);
                    ImGui::SetNextItemSelectionUserData(n);
                    ImGui::Selectable(label, item_is_selected);
                    if (item_curr_idx_to_focus == n)
                        ImGui::SetKeyboardFocusHere(-1);
                }

                // Apply multi-select requests
                ms_io = ImGui::EndMultiSelect();
                selection.ApplyRequests(ms_io);
                if (want_delete)
                    selection.ApplyDeletionPostLoop(ms_io, items, item_curr_idx_to_focus);
            }
            ImGui::EndChild();
            ImGui::TreePop();
        }

        // Implement a Dual List Box (#6648)
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (dual list box)");
        if (ImGui::TreeNode("Multi-Select (dual list box)"))
        {
            // Init default state
            static ExampleDualListBox dlb;
            if (dlb.Items[0].Size == 0 && dlb.Items[1].Size == 0)
                for (int item_id = 0; item_id < IM_ARRAYSIZE(ExampleNames); item_id++)
                    dlb.Items[0].push_back((ImGuiID)item_id);

            // Show
            dlb.Show();

            ImGui::TreePop();
        }

        // Demonstrate using the clipper with BeginMultiSelect()/EndMultiSelect()
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (in a table)");
        if (ImGui::TreeNode("Multi-Select (in a table)"))
        {
            static ImGuiSelectionBasicStorage selection;

            const int ITEMS_COUNT = 10000;
            ImGui::Text("Selection: %d/%d", selection.Size, ITEMS_COUNT);
            if (ImGui::BeginTable("##Basket", 2, ImGuiTableFlags_ScrollY | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter))
            {
                ImGui::TableSetupColumn("Object");
                ImGui::TableSetupColumn("Action");
                ImGui::TableSetupScrollFreeze(0, 1);
                ImGui::TableHeadersRow();

                ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, ITEMS_COUNT);
                selection.ApplyRequests(ms_io);

                ImGuiListClipper clipper;
                clipper.Begin(ITEMS_COUNT);
                if (ms_io->RangeSrcItem != -1)
                    clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem); // Ensure RangeSrc item is not clipped.
                while (clipper.Step())
                {
                    for (int n = clipper.DisplayStart; n < clipper.DisplayEnd; n++)
                    {
                        ImGui::TableNextRow();
                        ImGui::TableNextColumn();
                        char label[64];
                        sprintf(label, "Object %05d: %s", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);
                        bool item_is_selected = selection.Contains((ImGuiID)n);
                        ImGui::SetNextItemSelectionUserData(n);
                        ImGui::Selectable(label, item_is_selected, ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowOverlap);
                        ImGui::TableNextColumn();
                        ImGui::SmallButton("hello");
                    }
                }

                ms_io = ImGui::EndMultiSelect();
                selection.ApplyRequests(ms_io);
                ImGui::EndTable();
            }
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (checkboxes)");
        if (ImGui::TreeNode("Multi-Select (checkboxes)"))
        {
            ImGui::Text("In a list of checkboxes (not selectable):");
            ImGui::BulletText("Using _NoAutoSelect + _NoAutoClear flags.");
            ImGui::BulletText("Shift+Click to check multiple boxes.");
            ImGui::BulletText("Shift+Keyboard to copy current value to other boxes.");

            // If you have an array of checkboxes, you may want to use NoAutoSelect + NoAutoClear and the ImGuiSelectionExternalStorage helper.
            static bool items[20] = {};
            static ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_NoAutoSelect | ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_ClearOnEscape;
            ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoAutoSelect", &flags, ImGuiMultiSelectFlags_NoAutoSelect);
            ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoAutoClear", &flags, ImGuiMultiSelectFlags_NoAutoClear);
            ImGui::CheckboxFlags("ImGuiMultiSelectFlags_BoxSelect2d", &flags, ImGuiMultiSelectFlags_BoxSelect2d); // Cannot use ImGuiMultiSelectFlags_BoxSelect1d as checkboxes are varying width.

            if (ImGui::BeginChild("##Basket", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY))
            {
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, -1, IM_ARRAYSIZE(items));
                ImGuiSelectionExternalStorage storage_wrapper;
                storage_wrapper.UserData = (void*)items;
                storage_wrapper.AdapterSetItemSelected = [](ImGuiSelectionExternalStorage* self, int n, bool selected) { bool* array = (bool*)self->UserData; array[n] = selected; };
                storage_wrapper.ApplyRequests(ms_io);
                for (int n = 0; n < 20; n++)
                {
                    char label[32];
                    sprintf(label, "Item %d", n);
                    ImGui::SetNextItemSelectionUserData(n);
                    ImGui::Checkbox(label, &items[n]);
                }
                ms_io = ImGui::EndMultiSelect();
                storage_wrapper.ApplyRequests(ms_io);
            }
            ImGui::EndChild();

            ImGui::TreePop();
        }

        // Demonstrate individual selection scopes in same window
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (multiple scopes)");
        if (ImGui::TreeNode("Multi-Select (multiple scopes)"))
        {
            // Use default select: Pass index to SetNextItemSelectionUserData(), store index in Selection
            const int SCOPES_COUNT = 3;
            const int ITEMS_COUNT = 8; // Per scope
            static ImGuiSelectionBasicStorage selections_data[SCOPES_COUNT];

            // Use ImGuiMultiSelectFlags_ScopeRect to not affect other selections in same window.
            static ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ScopeRect | ImGuiMultiSelectFlags_ClearOnEscape;// | ImGuiMultiSelectFlags_ClearOnClickVoid;
            if (ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ScopeWindow", &flags, ImGuiMultiSelectFlags_ScopeWindow) && (flags & ImGuiMultiSelectFlags_ScopeWindow))
                flags &= ~ImGuiMultiSelectFlags_ScopeRect;
            if (ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ScopeRect", &flags, ImGuiMultiSelectFlags_ScopeRect) && (flags & ImGuiMultiSelectFlags_ScopeRect))
                flags &= ~ImGuiMultiSelectFlags_ScopeWindow;
            ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ClearOnClickVoid", &flags, ImGuiMultiSelectFlags_ClearOnClickVoid);
            ImGui::CheckboxFlags("ImGuiMultiSelectFlags_BoxSelect1d", &flags, ImGuiMultiSelectFlags_BoxSelect1d);

            for (int selection_scope_n = 0; selection_scope_n < SCOPES_COUNT; selection_scope_n++)
            {
                ImGui::PushID(selection_scope_n);
                ImGuiSelectionBasicStorage* selection = &selections_data[selection_scope_n];
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection->Size, ITEMS_COUNT);
                selection->ApplyRequests(ms_io);

                ImGui::SeparatorText("Selection scope");
                ImGui::Text("Selection size: %d/%d", selection->Size, ITEMS_COUNT);

                for (int n = 0; n < ITEMS_COUNT; n++)
                {
                    char label[64];
                    sprintf(label, "Object %05d: %s", n, ExampleNames[n % IM_ARRAYSIZE(ExampleNames)]);
                    bool item_is_selected = selection->Contains((ImGuiID)n);
                    ImGui::SetNextItemSelectionUserData(n);
                    ImGui::Selectable(label, item_is_selected);
                }

                // Apply multi-select requests
                ms_io = ImGui::EndMultiSelect();
                selection->ApplyRequests(ms_io);
                ImGui::PopID();
            }
            ImGui::TreePop();
        }

        // See ShowExampleAppAssetsBrowser()
        if (ImGui::TreeNode("Multi-Select (tiled assets browser)"))
        {
            ImGui::Checkbox("Assets Browser", &demo_data->ShowAppAssetsBrowser);
            ImGui::Text("(also access from 'Examples->Assets Browser' in menu)");
            ImGui::TreePop();
        }

        // Demonstrate supporting multiple-selection in a tree.
        // - We don't use linear indices for selection user data, but our ExampleTreeNode* pointer directly!
        //   This showcase how SetNextItemSelectionUserData() never assume indices!
        // - The difficulty here is to "interpolate" from RangeSrcItem to RangeDstItem in the SetAll/SetRange request.
        //   We want this interpolation to match what the user sees: in visible order, skipping closed nodes.
        //   This is implemented by our TreeGetNextNodeInVisibleOrder() user-space helper.
        // - Important: In a real codebase aiming to implement full-featured selectable tree with custom filtering, you
        //   are more likely to build an array mapping sequential indices to visible tree nodes, since your
        //   filtering/search + clipping process will benefit from it. Having this will make this interpolation much easier.
        // - Consider this a prototype: we are working toward simplifying some of it.
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (trees)");
        if (ImGui::TreeNode("Multi-Select (trees)"))
        {
            HelpMarker(
                "This is rather advanced and experimental. If you are getting started with multi-select, "
                "please don't start by looking at how to use it for a tree!\n\n"
                "Future versions will try to simplify and formalize some of this.");

            struct ExampleTreeFuncs
            {
                static void DrawNode(ExampleTreeNode* node, ImGuiSelectionBasicStorage* selection)
                {
                    ImGuiTreeNodeFlags tree_node_flags = ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;
                    tree_node_flags |= ImGuiTreeNodeFlags_NavLeftJumpsToParent; // Enable pressing left to jump to parent
                    if (node->Childs.Size == 0)
                        tree_node_flags |= ImGuiTreeNodeFlags_Bullet | ImGuiTreeNodeFlags_Leaf;
                    if (selection->Contains((ImGuiID)node->UID))
                        tree_node_flags |= ImGuiTreeNodeFlags_Selected;

                    // Using SetNextItemStorageID() to specify storage id, so we can easily peek into
                    // the storage holding open/close stage, using our TreeNodeGetOpen/TreeNodeSetOpen() functions.
                    ImGui::SetNextItemSelectionUserData((ImGuiSelectionUserData)(intptr_t)node);
                    ImGui::SetNextItemStorageID((ImGuiID)node->UID);
                    if (ImGui::TreeNodeEx(node->Name, tree_node_flags))
                    {
                        for (ExampleTreeNode* child : node->Childs)
                            DrawNode(child, selection);
                        ImGui::TreePop();
                    }
                    else if (ImGui::IsItemToggledOpen())
                    {
                        TreeCloseAndUnselectChildNodes(node, selection);
                    }
                }

                static bool TreeNodeGetOpen(ExampleTreeNode* node)
                {
                    return ImGui::GetStateStorage()->GetBool((ImGuiID)node->UID);
                }

                static void TreeNodeSetOpen(ExampleTreeNode* node, bool open)
                {
                    ImGui::GetStateStorage()->SetBool((ImGuiID)node->UID, open);
                }

                // When closing a node: 1) close and unselect all child nodes, 2) select parent if any child was selected.
                // FIXME: This is currently handled by user logic but I'm hoping to eventually provide tree node
                // features to do this automatically, e.g. a ImGuiTreeNodeFlags_AutoCloseChildNodes etc.
                static int TreeCloseAndUnselectChildNodes(ExampleTreeNode* node, ImGuiSelectionBasicStorage* selection, int depth = 0)
                {
                    // Recursive close (the test for depth == 0 is because we call this on a node that was just closed!)
                    int unselected_count = selection->Contains((ImGuiID)node->UID) ? 1 : 0;
                    if (depth == 0 || TreeNodeGetOpen(node))
                    {
                        for (ExampleTreeNode* child : node->Childs)
                            unselected_count += TreeCloseAndUnselectChildNodes(child, selection, depth + 1);
                        TreeNodeSetOpen(node, false);
                    }

                    // Select root node if any of its child was selected, otherwise unselect
                    selection->SetItemSelected((ImGuiID)node->UID, (depth == 0 && unselected_count > 0));
                    return unselected_count;
                }

                // Apply multi-selection requests
                static void ApplySelectionRequests(ImGuiMultiSelectIO* ms_io, ExampleTreeNode* tree, ImGuiSelectionBasicStorage* selection)
                {
                    for (ImGuiSelectionRequest& req : ms_io->Requests)
                    {
                        if (req.Type == ImGuiSelectionRequestType_SetAll)
                        {
                            if (req.Selected)
                                TreeSetAllInOpenNodes(tree, selection, req.Selected);
                            else
                                selection->Clear();
                        }
                        else if (req.Type == ImGuiSelectionRequestType_SetRange)
                        {
                            ExampleTreeNode* first_node = (ExampleTreeNode*)(intptr_t)req.RangeFirstItem;
                            ExampleTreeNode* last_node = (ExampleTreeNode*)(intptr_t)req.RangeLastItem;
                            for (ExampleTreeNode* node = first_node; node != NULL; node = TreeGetNextNodeInVisibleOrder(node, last_node))
                                selection->SetItemSelected((ImGuiID)node->UID, req.Selected);
                        }
                    }
                }

                static void TreeSetAllInOpenNodes(ExampleTreeNode* node, ImGuiSelectionBasicStorage* selection, bool selected)
                {
                    if (node->Parent != NULL) // Root node isn't visible nor selectable in our scheme
                        selection->SetItemSelected((ImGuiID)node->UID, selected);
                    if (node->Parent == NULL || TreeNodeGetOpen(node))
                        for (ExampleTreeNode* child : node->Childs)
                            TreeSetAllInOpenNodes(child, selection, selected);
                }

                // Interpolate in *user-visible order* AND only *over opened nodes*.
                // If you have a sequential mapping tables (e.g. generated after a filter/search pass) this would be simpler.
                // Here the tricks are that:
                // - we store/maintain ExampleTreeNode::IndexInParent which allows implementing a linear iterator easily, without searches, without recursion.
                //   this could be replaced by a search in parent, aka 'int index_in_parent = curr_node->Parent->Childs.find_index(curr_node)'
                //   which would only be called when crossing from child to a parent, aka not too much.
                // - we call SetNextItemStorageID() before our TreeNode() calls with an ID which doesn't relate to UI stack,
                //   making it easier to call TreeNodeGetOpen()/TreeNodeSetOpen() from any location.
                static ExampleTreeNode* TreeGetNextNodeInVisibleOrder(ExampleTreeNode* curr_node, ExampleTreeNode* last_node)
                {
                    // Reached last node
                    if (curr_node == last_node)
                        return NULL;

                    // Recurse into childs. Query storage to tell if the node is open.
                    if (curr_node->Childs.Size > 0 && TreeNodeGetOpen(curr_node))
                        return curr_node->Childs[0];

                    // Next sibling, then into our own parent
                    while (curr_node->Parent != NULL)
                    {
                        if (curr_node->IndexInParent + 1 < curr_node->Parent->Childs.Size)
                            return curr_node->Parent->Childs[curr_node->IndexInParent + 1];
                        curr_node = curr_node->Parent;
                    }
                    return NULL;
                }

            }; // ExampleTreeFuncs

            static ImGuiSelectionBasicStorage selection;
            if (demo_data->DemoTree == NULL)
                demo_data->DemoTree = ExampleTree_CreateDemoTree(); // Create tree once
            ImGui::Text("Selection size: %d", selection.Size);

            if (ImGui::BeginChild("##Tree", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))
            {
                ExampleTreeNode* tree = demo_data->DemoTree;
                ImGuiMultiSelectFlags ms_flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect2d;
                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(ms_flags, selection.Size, -1);
                ExampleTreeFuncs::ApplySelectionRequests(ms_io, tree, &selection);
                for (ExampleTreeNode* node : tree->Childs)
                    ExampleTreeFuncs::DrawNode(node, &selection);
                ms_io = ImGui::EndMultiSelect();
                ExampleTreeFuncs::ApplySelectionRequests(ms_io, tree, &selection);
            }
            ImGui::EndChild();

            ImGui::TreePop();
        }

        // Advanced demonstration of BeginMultiSelect()
        // - Showcase clipping.
        // - Showcase deletion.
        // - Showcase basic drag and drop.
        // - Showcase TreeNode variant (note that tree node don't expand in the demo: supporting expanding tree nodes + clipping a separate thing).
        // - Showcase using inside a table.
        IMGUI_DEMO_MARKER("Widgets/Selection State/Multi-Select (advanced)");
        //ImGui::SetNextItemOpen(true, ImGuiCond_Once);
        if (ImGui::TreeNode("Multi-Select (advanced)"))
        {
            // Options
            enum WidgetType { WidgetType_Selectable, WidgetType_TreeNode };
            static bool use_clipper = true;
            static bool use_deletion = true;
            static bool use_drag_drop = true;
            static bool show_in_table = false;
            static bool show_color_button = true;
            static ImGuiMultiSelectFlags flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_BoxSelect1d;
            static WidgetType widget_type = WidgetType_Selectable;

            if (ImGui::TreeNode("Options"))
            {
                if (ImGui::RadioButton("Selectables", widget_type == WidgetType_Selectable)) { widget_type = WidgetType_Selectable; }
                ImGui::SameLine();
                if (ImGui::RadioButton("Tree nodes", widget_type == WidgetType_TreeNode)) { widget_type = WidgetType_TreeNode; }
                ImGui::SameLine();
                HelpMarker("TreeNode() is technically supported but... using this correctly is more complicated (you need some sort of linear/random access to your tree, which is suited to advanced trees setups already implementing filters and clipper. We will work toward simplifying and demoing this.\n\nFor now the tree demo is actually a little bit meaningless because it is an empty tree with only root nodes.");
                ImGui::Checkbox("Enable clipper", &use_clipper);
                ImGui::Checkbox("Enable deletion", &use_deletion);
                ImGui::Checkbox("Enable drag & drop", &use_drag_drop);
                ImGui::Checkbox("Show in a table", &show_in_table);
                ImGui::Checkbox("Show color button", &show_color_button);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_SingleSelect", &flags, ImGuiMultiSelectFlags_SingleSelect);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoSelectAll", &flags, ImGuiMultiSelectFlags_NoSelectAll);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoRangeSelect", &flags, ImGuiMultiSelectFlags_NoRangeSelect);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoAutoSelect", &flags, ImGuiMultiSelectFlags_NoAutoSelect);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoAutoClear", &flags, ImGuiMultiSelectFlags_NoAutoClear);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoAutoClearOnReselect", &flags, ImGuiMultiSelectFlags_NoAutoClearOnReselect);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_NoSelectOnRightClick", &flags, ImGuiMultiSelectFlags_NoSelectOnRightClick);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_BoxSelect1d", &flags, ImGuiMultiSelectFlags_BoxSelect1d);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_BoxSelect2d", &flags, ImGuiMultiSelectFlags_BoxSelect2d);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_BoxSelectNoScroll", &flags, ImGuiMultiSelectFlags_BoxSelectNoScroll);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ClearOnEscape", &flags, ImGuiMultiSelectFlags_ClearOnEscape);
                ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ClearOnClickVoid", &flags, ImGuiMultiSelectFlags_ClearOnClickVoid);
                if (ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ScopeWindow", &flags, ImGuiMultiSelectFlags_ScopeWindow) && (flags & ImGuiMultiSelectFlags_ScopeWindow))
                    flags &= ~ImGuiMultiSelectFlags_ScopeRect;
                if (ImGui::CheckboxFlags("ImGuiMultiSelectFlags_ScopeRect", &flags, ImGuiMultiSelectFlags_ScopeRect) && (flags & ImGuiMultiSelectFlags_ScopeRect))
                    flags &= ~ImGuiMultiSelectFlags_ScopeWindow;
                if (ImGui::CheckboxFlags("ImGuiMultiSelectFlags_SelectOnClick", &flags, ImGuiMultiSelectFlags_SelectOnClick) && (flags & ImGuiMultiSelectFlags_SelectOnClick))
                    flags &= ~ImGuiMultiSelectFlags_SelectOnClickRelease;
                if (ImGui::CheckboxFlags("ImGuiMultiSelectFlags_SelectOnClickRelease", &flags, ImGuiMultiSelectFlags_SelectOnClickRelease) && (flags & ImGuiMultiSelectFlags_SelectOnClickRelease))
                    flags &= ~ImGuiMultiSelectFlags_SelectOnClick;
                ImGui::SameLine(); HelpMarker("Allow dragging an unselected item without altering selection.");
                ImGui::TreePop();
            }

            // Initialize default list with 1000 items.
            // Use default selection.Adapter: Pass index to SetNextItemSelectionUserData(), store index in Selection
            static ImVector<int> items;
            static int items_next_id = 0;
            if (items_next_id == 0) { for (int n = 0; n < 1000; n++) { items.push_back(items_next_id++); } }
            static ExampleSelectionWithDeletion selection;
            static bool request_deletion_from_menu = false; // Queue deletion triggered from context menu

            ImGui::Text("Selection size: %d/%d", selection.Size, items.Size);

            const float items_height = (widget_type == WidgetType_TreeNode) ? ImGui::GetTextLineHeight() : ImGui::GetTextLineHeightWithSpacing();
            ImGui::SetNextWindowContentSize(ImVec2(0.0f, items.Size * items_height));
            if (ImGui::BeginChild("##Basket", ImVec2(-FLT_MIN, ImGui::GetFontSize() * 20), ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY))
            {
                ImVec2 color_button_sz(ImGui::GetFontSize(), ImGui::GetFontSize());
                if (widget_type == WidgetType_TreeNode)
                    ImGui::PushStyleVarY(ImGuiStyleVar_ItemSpacing, 0.0f);

                ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(flags, selection.Size, items.Size);
                selection.ApplyRequests(ms_io);

                const bool want_delete = (ImGui::Shortcut(ImGuiKey_Delete, ImGuiInputFlags_Repeat) && (selection.Size > 0)) || request_deletion_from_menu;
                const int item_curr_idx_to_focus = want_delete ? selection.ApplyDeletionPreLoop(ms_io, items.Size) : -1;
                request_deletion_from_menu = false;

                if (show_in_table)
                {
                    if (widget_type == WidgetType_TreeNode)
                        ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, ImVec2(0.0f, 0.0f));
                    ImGui::BeginTable("##Split", 2, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_NoPadOuterX);
                    ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthStretch, 0.70f);
                    ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthStretch, 0.30f);
                    //ImGui::PushStyleVarY(ImGuiStyleVar_ItemSpacing, 0.0f);
                }

                ImGuiListClipper clipper;
                if (use_clipper)
                {
                    clipper.Begin(items.Size);
                    if (item_curr_idx_to_focus != -1)
                        clipper.IncludeItemByIndex(item_curr_idx_to_focus); // Ensure focused item is not clipped.
                    if (ms_io->RangeSrcItem != -1)
                        clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem); // Ensure RangeSrc item is not clipped.
                }

                while (!use_clipper || clipper.Step())
                {
                    const int item_begin = use_clipper ? clipper.DisplayStart : 0;
                    const int item_end = use_clipper ? clipper.DisplayEnd : items.Size;
                    for (int n = item_begin; n < item_end; n++)
                    {
                        if (show_in_table)
                            ImGui::TableNextColumn();

                        const int item_id = items[n];
                        const char* item_category = ExampleNames[item_id % IM_ARRAYSIZE(ExampleNames)];
                        char label[64];
                        sprintf(label, "Object %05d: %s", item_id, item_category);

                        // IMPORTANT: for deletion refocus to work we need object ID to be stable,
                        // aka not depend on their index in the list. Here we use our persistent item_id
                        // instead of index to build a unique ID that will persist.
                        // (If we used PushID(index) instead, focus wouldn't be restored correctly after deletion).
                        ImGui::PushID(item_id);

                        // Emit a color button, to test that Shift+LeftArrow landing on an item that is not part
                        // of the selection scope doesn't erroneously alter our selection.
                        if (show_color_button)
                        {
                            ImU32 dummy_col = (ImU32)((unsigned int)n * 0xC250B74B) | IM_COL32_A_MASK;
                            ImGui::ColorButton("##", ImColor(dummy_col), ImGuiColorEditFlags_NoTooltip, color_button_sz);
                            ImGui::SameLine();
                        }

                        // Submit item
                        bool item_is_selected = selection.Contains((ImGuiID)n);
                        bool item_is_open = false;
                        ImGui::SetNextItemSelectionUserData(n);
                        if (widget_type == WidgetType_Selectable)
                        {
                            ImGui::Selectable(label, item_is_selected, ImGuiSelectableFlags_None);
                        }
                        else if (widget_type == WidgetType_TreeNode)
                        {
                            ImGuiTreeNodeFlags tree_node_flags = ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;
                            if (item_is_selected)
                                tree_node_flags |= ImGuiTreeNodeFlags_Selected;
                            item_is_open = ImGui::TreeNodeEx(label, tree_node_flags);
                        }

                        // Focus (for after deletion)
                        if (item_curr_idx_to_focus == n)
                            ImGui::SetKeyboardFocusHere(-1);

                        // Drag and Drop
                        if (use_drag_drop && ImGui::BeginDragDropSource())
                        {
                            // Create payload with full selection OR single unselected item.
                            // (the later is only possible when using ImGuiMultiSelectFlags_SelectOnClickRelease)
                            if (ImGui::GetDragDropPayload() == NULL)
                            {
                                ImVector<int> payload_items;
                                void* it = NULL;
                                ImGuiID id = 0;
                                if (!item_is_selected)
                                    payload_items.push_back(item_id);
                                else
                                    while (selection.GetNextSelectedItem(&it, &id))
                                        payload_items.push_back((int)id);
                                ImGui::SetDragDropPayload("MULTISELECT_DEMO_ITEMS", payload_items.Data, (size_t)payload_items.size_in_bytes());
                            }

                            // Display payload content in tooltip
                            const ImGuiPayload* payload = ImGui::GetDragDropPayload();
                            const int* payload_items = (int*)payload->Data;
                            const int payload_count = (int)payload->DataSize / (int)sizeof(int);
                            if (payload_count == 1)
                                ImGui::Text("Object %05d: %s", payload_items[0], ExampleNames[payload_items[0] % IM_ARRAYSIZE(ExampleNames)]);
                            else
                                ImGui::Text("Dragging %d objects", payload_count);

                            ImGui::EndDragDropSource();
                        }

                        if (widget_type == WidgetType_TreeNode && item_is_open)
                            ImGui::TreePop();

                        // Right-click: context menu
                        if (ImGui::BeginPopupContextItem())
                        {
                            ImGui::BeginDisabled(!use_deletion || selection.Size == 0);
                            sprintf(label, "Delete %d item(s)###DeleteSelected", selection.Size);
                            if (ImGui::Selectable(label))
                                request_deletion_from_menu = true;
                            ImGui::EndDisabled();
                            ImGui::Selectable("Close");
                            ImGui::EndPopup();
                        }

                        // Demo content within a table
                        if (show_in_table)
                        {
                            ImGui::TableNextColumn();
                            ImGui::SetNextItemWidth(-FLT_MIN);
                            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
                            ImGui::InputText("###NoLabel", (char*)(void*)item_category, strlen(item_category), ImGuiInputTextFlags_ReadOnly);
                            ImGui::PopStyleVar();
                        }

                        ImGui::PopID();
                    }
                    if (!use_clipper)
                        break;
                }

                if (show_in_table)
                {
                    ImGui::EndTable();
                    if (widget_type == WidgetType_TreeNode)
                        ImGui::PopStyleVar();
                }

                // Apply multi-select requests
                ms_io = ImGui::EndMultiSelect();
                selection.ApplyRequests(ms_io);
                if (want_delete)
                    selection.ApplyDeletionPostLoop(ms_io, items, item_curr_idx_to_focus);

                if (widget_type == WidgetType_TreeNode)
                    ImGui::PopStyleVar();
            }
            ImGui::EndChild();
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsTabs()
//-----------------------------------------------------------------------------

static void EditTabBarFittingPolicyFlags(ImGuiTabBarFlags* p_flags)
{
    if ((*p_flags & ImGuiTabBarFlags_FittingPolicyMask_) == 0)
        *p_flags |= ImGuiTabBarFlags_FittingPolicyDefault_;
    if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyMixed", p_flags, ImGuiTabBarFlags_FittingPolicyMixed))
        *p_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyMixed);
    if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyShrink", p_flags, ImGuiTabBarFlags_FittingPolicyShrink))
        *p_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyShrink);
    if (ImGui::CheckboxFlags("ImGuiTabBarFlags_FittingPolicyScroll", p_flags, ImGuiTabBarFlags_FittingPolicyScroll))
        *p_flags &= ~(ImGuiTabBarFlags_FittingPolicyMask_ ^ ImGuiTabBarFlags_FittingPolicyScroll);
}

static void DemoWindowWidgetsTabs()
{
    IMGUI_DEMO_MARKER("Widgets/Tabs");
    if (ImGui::TreeNode("Tabs"))
    {
        IMGUI_DEMO_MARKER("Widgets/Tabs/Basic");
        if (ImGui::TreeNode("Basic"))
        {
            ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                if (ImGui::BeginTabItem("Avocado"))
                {
                    ImGui::Text("This is the Avocado tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Broccoli"))
                {
                    ImGui::Text("This is the Broccoli tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Cucumber"))
                {
                    ImGui::Text("This is the Cucumber tab!\nblah blah blah blah blah");
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Tabs/Advanced & Close Button");
        if (ImGui::TreeNode("Advanced & Close Button"))
        {
            // Expose a couple of the available flags. In most cases you may just call BeginTabBar() with no flags (0).
            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_Reorderable;
            ImGui::CheckboxFlags("ImGuiTabBarFlags_Reorderable", &tab_bar_flags, ImGuiTabBarFlags_Reorderable);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_AutoSelectNewTabs", &tab_bar_flags, ImGuiTabBarFlags_AutoSelectNewTabs);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_TabListPopupButton", &tab_bar_flags, ImGuiTabBarFlags_TabListPopupButton);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_NoCloseWithMiddleMouseButton", &tab_bar_flags, ImGuiTabBarFlags_NoCloseWithMiddleMouseButton);
            ImGui::CheckboxFlags("ImGuiTabBarFlags_DrawSelectedOverline", &tab_bar_flags, ImGuiTabBarFlags_DrawSelectedOverline);
            EditTabBarFittingPolicyFlags(&tab_bar_flags);

            // Tab Bar
            ImGui::AlignTextToFramePadding();
            ImGui::Text("Opened:");
            const char* names[4] = { "Artichoke", "Beetroot", "Celery", "Daikon" };
            static bool opened[4] = { true, true, true, true }; // Persistent user state
            for (int n = 0; n < IM_ARRAYSIZE(opened); n++)
            {
                ImGui::SameLine();
                ImGui::Checkbox(names[n], &opened[n]);
            }

            // Passing a bool* to BeginTabItem() is similar to passing one to Begin():
            // the underlying bool will be set to false when the tab is closed.
            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                for (int n = 0; n < IM_ARRAYSIZE(opened); n++)
                    if (opened[n] && ImGui::BeginTabItem(names[n], &opened[n], ImGuiTabItemFlags_None))
                    {
                        ImGui::Text("This is the %s tab!", names[n]);
                        if (n & 1)
                            ImGui::Text("I am an odd tab.");
                        ImGui::EndTabItem();
                    }
                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Tabs/TabItemButton & Leading-Trailing flags");
        if (ImGui::TreeNode("TabItemButton & Leading/Trailing flags"))
        {
            static ImVector<int> active_tabs;
            static int next_tab_id = 0;
            if (next_tab_id == 0) // Initialize with some default tabs
                for (int i = 0; i < 3; i++)
                    active_tabs.push_back(next_tab_id++);

            // TabItemButton() and Leading/Trailing flags are distinct features which we will demo together.
            // (It is possible to submit regular tabs with Leading/Trailing flags, or TabItemButton tabs without Leading/Trailing flags...
            // but they tend to make more sense together)
            static bool show_leading_button = true;
            static bool show_trailing_button = true;
            ImGui::Checkbox("Show Leading TabItemButton()", &show_leading_button);
            ImGui::Checkbox("Show Trailing TabItemButton()", &show_trailing_button);

            // Expose some other flags which are useful to showcase how they interact with Leading/Trailing tabs
            static ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_AutoSelectNewTabs | ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_FittingPolicyShrink;
            EditTabBarFittingPolicyFlags(&tab_bar_flags);

            if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
            {
                // Demo a Leading TabItemButton(): click the "?" button to open a menu
                if (show_leading_button)
                    if (ImGui::TabItemButton("?", ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_NoTooltip))
                        ImGui::OpenPopup("MyHelpMenu");
                if (ImGui::BeginPopup("MyHelpMenu"))
                {
                    ImGui::Selectable("Hello!");
                    ImGui::EndPopup();
                }

                // Demo Trailing Tabs: click the "+" button to add a new tab.
                // (In your app you may want to use a font icon instead of the "+")
                // We submit it before the regular tabs, but thanks to the ImGuiTabItemFlags_Trailing flag it will always appear at the end.
                if (show_trailing_button)
                    if (ImGui::TabItemButton("+", ImGuiTabItemFlags_Trailing | ImGuiTabItemFlags_NoTooltip))
                        active_tabs.push_back(next_tab_id++); // Add new tab

                // Submit our regular tabs
                for (int n = 0; n < active_tabs.Size; )
                {
                    bool open = true;
                    char name[16];
                    snprintf(name, IM_ARRAYSIZE(name), "%04d", active_tabs[n]);
                    if (ImGui::BeginTabItem(name, &open, ImGuiTabItemFlags_None))
                    {
                        ImGui::Text("This is the %s tab!", name);
                        ImGui::EndTabItem();
                    }

                    if (!open)
                        active_tabs.erase(active_tabs.Data + n);
                    else
                        n++;
                }

                ImGui::EndTabBar();
            }
            ImGui::Separator();
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsText()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsText()
{
    IMGUI_DEMO_MARKER("Widgets/Text");
    if (ImGui::TreeNode("Text"))
    {
        IMGUI_DEMO_MARKER("Widgets/Text/Colored Text");
        if (ImGui::TreeNode("Colorful Text"))
        {
            // Using shortcut. You can use PushStyleColor()/PopStyleColor() for more flexibility.
            ImGui::TextColored(ImVec4(1.0f, 0.0f, 1.0f, 1.0f), "Pink");
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Yellow");
            ImGui::TextDisabled("Disabled");
            ImGui::SameLine(); HelpMarker("The TextDisabled color is stored in ImGuiStyle.");
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text/Font Size");
        if (ImGui::TreeNode("Font Size"))
        {
            ImGuiStyle& style = ImGui::GetStyle();
            const float global_scale = style.FontScaleMain * style.FontScaleDpi;
            ImGui::Text("style.FontScaleMain = %0.2f", style.FontScaleMain);
            ImGui::Text("style.FontScaleDpi = %0.2f", style.FontScaleDpi);
            ImGui::Text("global_scale = ~%0.2f", global_scale); // This is not technically accurate as internal scales may apply, but conceptually let's pretend it is.
            ImGui::Text("FontSize = %0.2f", ImGui::GetFontSize());

            ImGui::SeparatorText("");
            static float custom_size = 16.0f;
            ImGui::SliderFloat("custom_size", &custom_size, 10.0f, 100.0f, "%.0f");
            ImGui::Text("ImGui::PushFont(nullptr, custom_size);");
            ImGui::PushFont(NULL, custom_size);
            ImGui::Text("FontSize = %.2f (== %.2f * global_scale)", ImGui::GetFontSize(), custom_size);
            ImGui::PopFont();

            ImGui::SeparatorText("");
            static float custom_scale = 1.0f;
            ImGui::SliderFloat("custom_scale", &custom_scale, 0.5f, 4.0f, "%.2f");
            ImGui::Text("ImGui::PushFont(nullptr, style.FontSizeBase * custom_scale);");
            ImGui::PushFont(NULL, style.FontSizeBase * custom_scale);
            ImGui::Text("FontSize = %.2f (== style.FontSizeBase * %.2f * global_scale)", ImGui::GetFontSize(), custom_scale);
            ImGui::PopFont();

            ImGui::SeparatorText("");
            for (float scaling = 0.5f; scaling <= 4.0f; scaling += 0.5f)
            {
                ImGui::PushFont(NULL, style.FontSizeBase * scaling);
                ImGui::Text("FontSize = %.2f (== style.FontSizeBase * %.2f * global_scale)", ImGui::GetFontSize(), scaling);
                ImGui::PopFont();
            }

            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text/Word Wrapping");
        if (ImGui::TreeNode("Word Wrapping"))
        {
            // Using shortcut. You can use PushTextWrapPos()/PopTextWrapPos() for more flexibility.
            ImGui::TextWrapped(
                "This text should automatically wrap on the edge of the window. The current implementation "
                "for text wrapping follows simple rules suitable for English and possibly other languages.");
            ImGui::Spacing();

            static float wrap_width = 200.0f;
            ImGui::SliderFloat("Wrap width", &wrap_width, -20, 600, "%.0f");

            ImDrawList* draw_list = ImGui::GetWindowDrawList();
            for (int n = 0; n < 2; n++)
            {
                ImGui::Text("Test paragraph %d:", n);
                ImVec2 pos = ImGui::GetCursorScreenPos();
                ImVec2 marker_min = ImVec2(pos.x + wrap_width, pos.y);
                ImVec2 marker_max = ImVec2(pos.x + wrap_width + 10, pos.y + ImGui::GetTextLineHeight());
                ImGui::PushTextWrapPos(ImGui::GetCursorPos().x + wrap_width);
                if (n == 0)
                    ImGui::Text("The lazy dog is a good dog. This paragraph should fit within %.0f pixels. Testing a 1 character word. The quick brown fox jumps over the lazy dog.", wrap_width);
                else
                    ImGui::Text("aaaaaaaa bbbbbbbb, c cccccccc,dddddddd. d eeeeeeee   ffffffff. gggggggg!hhhhhhhh");

                // Draw actual text bounding box, following by marker of our expected limit (should not overlap!)
                draw_list->AddRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), IM_COL32(255, 255, 0, 255));
                draw_list->AddRectFilled(marker_min, marker_max, IM_COL32(255, 0, 255, 255));
                ImGui::PopTextWrapPos();
            }

            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text/UTF-8 Text");
        if (ImGui::TreeNode("UTF-8 Text"))
        {
            // UTF-8 test with Japanese characters
            // (Needs a suitable font? Try "Google Noto" or "Arial Unicode". See docs/FONTS.md for details.)
            // - From C++11 you can use the u8"my text" syntax to encode literal strings as UTF-8
            // - For earlier compiler, you may be able to encode your sources as UTF-8 (e.g. in Visual Studio, you
            //   can save your source files as 'UTF-8 without signature').
            // - FOR THIS DEMO FILE ONLY, BECAUSE WE WANT TO SUPPORT OLD COMPILERS, WE ARE *NOT* INCLUDING RAW UTF-8
            //   CHARACTERS IN THIS SOURCE FILE. Instead we are encoding a few strings with hexadecimal constants.
            //   Don't do this in your application! Please use u8"text in any language" in your application!
            // Note that characters values are preserved even by InputText() if the font cannot be displayed,
            // so you can safely copy & paste garbled characters into another application.
            ImGui::TextWrapped(
                "CJK text will only appear if the font was loaded with the appropriate CJK character ranges. "
                "Call io.Fonts->AddFontFromFileTTF() manually to load extra character ranges. "
                "Read docs/FONTS.md for details.");
            ImGui::Text("Hiragana: \xe3\x81\x8b\xe3\x81\x8d\xe3\x81\x8f\xe3\x81\x91\xe3\x81\x93 (kakikukeko)");
            ImGui::Text("Kanjis: \xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e (nihongo)");
            static char buf[32] = "\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e";
            //static char buf[32] = u8"NIHONGO"; // <- this is how you would write it with C++11, using real kanjis
            ImGui::InputText("UTF-8 input", buf, IM_ARRAYSIZE(buf));
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsTextFilter()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsTextFilter()
{
    IMGUI_DEMO_MARKER("Widgets/Text Filter");
    if (ImGui::TreeNode("Text Filter"))
    {
        // Helper class to easy setup a text filter.
        // You may want to implement a more feature-full filtering scheme in your own application.
        HelpMarker("Not a widget per-se, but ImGuiTextFilter is a helper to perform simple filtering on text strings.");
        static ImGuiTextFilter filter;
        ImGui::Text("Filter usage:\n"
            "  \"\"         display all lines\n"
            "  \"xxx\"      display lines containing \"xxx\"\n"
            "  \"xxx,yyy\"  display lines containing \"xxx\" or \"yyy\"\n"
            "  \"-xxx\"     hide lines containing \"xxx\"");
        filter.Draw();
        const char* lines[] = { "aaa1.c", "bbb1.c", "ccc1.c", "aaa2.cpp", "bbb2.cpp", "ccc2.cpp", "abc.h", "hello, world" };
        for (int i = 0; i < IM_ARRAYSIZE(lines); i++)
            if (filter.PassFilter(lines[i]))
                ImGui::BulletText("%s", lines[i]);
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsTextInput()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsTextInput()
{
    // To wire InputText() with std::string or any other custom string type,
    // see the "Text Input > Resize Callback" section of this demo, and the misc/cpp/imgui_stdlib.h file.
    IMGUI_DEMO_MARKER("Widgets/Text Input");
    if (ImGui::TreeNode("Text Input"))
    {
        IMGUI_DEMO_MARKER("Widgets/Text Input/Multi-line Text Input");
        if (ImGui::TreeNode("Multi-line Text Input"))
        {
            // Note: we are using a fixed-sized buffer for simplicity here. See ImGuiInputTextFlags_CallbackResize
            // and the code in misc/cpp/imgui_stdlib.h for how to setup InputText() for dynamically resizing strings.
            static char text[1024 * 16] =
                "/*\n"
                " The Pentium F00F bug, shorthand for F0 0F C7 C8,\n"
                " the hexadecimal encoding of one offending instruction,\n"
                " more formally, the invalid operand with locked CMPXCHG8B\n"
                " instruction bug, is a design flaw in the majority of\n"
                " Intel Pentium, Pentium MMX, and Pentium OverDrive\n"
                " processors (all in the P5 microarchitecture).\n"
                "*/\n\n"
                "label:\n"
                "\tlock cmpxchg8b eax\n";

            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_AllowTabInput;
            HelpMarker("You can use the ImGuiInputTextFlags_CallbackResize facility if you need to wire InputTextMultiline() to a dynamic string type. See misc/cpp/imgui_stdlib.h for an example. (This is not demonstrated in imgui_demo.cpp because we don't want to include <string> in here)");
            ImGui::CheckboxFlags("ImGuiInputTextFlags_ReadOnly", &flags, ImGuiInputTextFlags_ReadOnly);
            ImGui::CheckboxFlags("ImGuiInputTextFlags_WordWrap", &flags, ImGuiInputTextFlags_WordWrap);
            ImGui::SameLine(); HelpMarker("Feature is currently in Beta. Please read comments in imgui.h");
            ImGui::CheckboxFlags("ImGuiInputTextFlags_AllowTabInput", &flags, ImGuiInputTextFlags_AllowTabInput);
            ImGui::SameLine(); HelpMarker("When _AllowTabInput is set, passing through the widget with Tabbing doesn't automatically activate it, in order to also cycling through subsequent widgets.");
            ImGui::CheckboxFlags("ImGuiInputTextFlags_CtrlEnterForNewLine", &flags, ImGuiInputTextFlags_CtrlEnterForNewLine);
            ImGui::InputTextMultiline("##source", text, IM_ARRAYSIZE(text), ImVec2(-FLT_MIN, ImGui::GetTextLineHeight() * 16), flags);
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text Input/Filtered Text Input");
        if (ImGui::TreeNode("Filtered Text Input"))
        {
            struct TextFilters
            {
                // Modify character input by altering 'data->Eventchar' (ImGuiInputTextFlags_CallbackCharFilter callback)
                static int FilterCasingSwap(ImGuiInputTextCallbackData* data)
                {
                    if (data->EventChar >= 'a' && data->EventChar <= 'z') { data->EventChar -= 'a' - 'A'; } // Lowercase becomes uppercase
                    else if (data->EventChar >= 'A' && data->EventChar <= 'Z') { data->EventChar += 'a' - 'A'; } // Uppercase becomes lowercase
                    return 0;
                }

                // Return 0 (pass) if the character is 'i' or 'm' or 'g' or 'u' or 'i', otherwise return 1 (filter out)
                static int FilterImGuiLetters(ImGuiInputTextCallbackData* data)
                {
                    if (data->EventChar < 256 && strchr("imgui", (char)data->EventChar))
                        return 0;
                    return 1;
                }
            };

            static char buf1[32] = ""; ImGui::InputText("default", buf1, IM_ARRAYSIZE(buf1));
            static char buf2[32] = ""; ImGui::InputText("decimal", buf2, IM_ARRAYSIZE(buf2), ImGuiInputTextFlags_CharsDecimal);
            static char buf3[32] = ""; ImGui::InputText("hexadecimal", buf3, IM_ARRAYSIZE(buf3), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase);
            static char buf4[32] = ""; ImGui::InputText("uppercase", buf4, IM_ARRAYSIZE(buf4), ImGuiInputTextFlags_CharsUppercase);
            static char buf5[32] = ""; ImGui::InputText("no blank", buf5, IM_ARRAYSIZE(buf5), ImGuiInputTextFlags_CharsNoBlank);
            static char buf6[32] = ""; ImGui::InputText("casing swap", buf6, IM_ARRAYSIZE(buf6), ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterCasingSwap); // Use CharFilter callback to replace characters.
            static char buf7[32] = ""; ImGui::InputText("\"imgui\"", buf7, IM_ARRAYSIZE(buf7), ImGuiInputTextFlags_CallbackCharFilter, TextFilters::FilterImGuiLetters); // Use CharFilter callback to disable some characters.
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text Input/Password input");
        if (ImGui::TreeNode("Password Input"))
        {
            static char password[64] = "password123";
            ImGui::InputText("password", password, IM_ARRAYSIZE(password), ImGuiInputTextFlags_Password);
            ImGui::SameLine(); HelpMarker("Display all characters as '*'.\nDisable clipboard cut and copy.\nDisable logging.\n");
            ImGui::InputTextWithHint("password (w/ hint)", "<password>", password, IM_ARRAYSIZE(password), ImGuiInputTextFlags_Password);
            ImGui::InputText("password (clear)", password, IM_ARRAYSIZE(password));
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text Input/Completion, History, Edit Callbacks");
        if (ImGui::TreeNode("Completion, History, Edit Callbacks"))
        {
            struct Funcs
            {
                static int MyCallback(ImGuiInputTextCallbackData* data)
                {
                    if (data->EventFlag == ImGuiInputTextFlags_CallbackCompletion)
                    {
                        data->InsertChars(data->CursorPos, "..");
                    }
                    else if (data->EventFlag == ImGuiInputTextFlags_CallbackHistory)
                    {
                        if (data->EventKey == ImGuiKey_UpArrow)
                        {
                            data->DeleteChars(0, data->BufTextLen);
                            data->InsertChars(0, "Pressed Up!");
                            data->SelectAll();
                        }
                        else if (data->EventKey == ImGuiKey_DownArrow)
                        {
                            data->DeleteChars(0, data->BufTextLen);
                            data->InsertChars(0, "Pressed Down!");
                            data->SelectAll();
                        }
                    }
                    else if (data->EventFlag == ImGuiInputTextFlags_CallbackEdit)
                    {
                        // Toggle casing of first character
                        char c = data->Buf[0];
                        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) data->Buf[0] ^= 32;
                        data->BufDirty = true;

                        // Increment a counter
                        int* p_int = (int*)data->UserData;
                        *p_int = *p_int + 1;
                    }
                    return 0;
                }
            };
            static char buf1[64];
            ImGui::InputText("Completion", buf1, IM_ARRAYSIZE(buf1), ImGuiInputTextFlags_CallbackCompletion, Funcs::MyCallback);
            ImGui::SameLine(); HelpMarker(
                "Here we append \"..\" each time Tab is pressed. "
                "See 'Examples>Console' for a more meaningful demonstration of using this callback.");

            static char buf2[64];
            ImGui::InputText("History", buf2, IM_ARRAYSIZE(buf2), ImGuiInputTextFlags_CallbackHistory, Funcs::MyCallback);
            ImGui::SameLine(); HelpMarker(
                "Here we replace and select text each time Up/Down are pressed. "
                "See 'Examples>Console' for a more meaningful demonstration of using this callback.");

            static char buf3[64];
            static int edit_count = 0;
            ImGui::InputText("Edit", buf3, IM_ARRAYSIZE(buf3), ImGuiInputTextFlags_CallbackEdit, Funcs::MyCallback, (void*)&edit_count);
            ImGui::SameLine(); HelpMarker(
                "Here we toggle the casing of the first character on every edit + count edits.");
            ImGui::SameLine(); ImGui::Text("(%d)", edit_count);

            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text Input/Resize Callback");
        if (ImGui::TreeNode("Resize Callback"))
        {
            // To wire InputText() with std::string or any other custom string type,
            // you can use the ImGuiInputTextFlags_CallbackResize flag + create a custom ImGui::InputText() wrapper
            // using your preferred type. See misc/cpp/imgui_stdlib.h for an implementation of this using std::string.
            HelpMarker(
                "Using ImGuiInputTextFlags_CallbackResize to wire your custom string type to InputText().\n\n"
                "See misc/cpp/imgui_stdlib.h for an implementation of this for std::string.");
            struct Funcs
            {
                static int MyResizeCallback(ImGuiInputTextCallbackData* data)
                {
                    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
                    {
                        ImVector<char>* my_str = (ImVector<char>*)data->UserData;
                        IM_ASSERT(my_str->begin() == data->Buf);
                        my_str->resize(data->BufSize); // NB: On resizing calls, generally data->BufSize == data->BufTextLen + 1
                        data->Buf = my_str->begin();
                    }
                    return 0;
                }

                // Note: Because ImGui:: is a namespace you would typically add your own function into the namespace.
                // For example, you code may declare a function 'ImGui::InputText(const char* label, MyString* my_str)'
                static bool MyInputTextMultiline(const char* label, ImVector<char>* my_str, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0)
                {
                    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);
                    return ImGui::InputTextMultiline(label, my_str->begin(), (size_t)my_str->size(), size, flags | ImGuiInputTextFlags_CallbackResize, Funcs::MyResizeCallback, (void*)my_str);
                }
            };

            // For this demo we are using ImVector as a string container.
            // Note that because we need to store a terminating zero character, our size/capacity are 1 more
            // than usually reported by a typical string class.
            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_None;
            ImGui::CheckboxFlags("ImGuiInputTextFlags_WordWrap", &flags, ImGuiInputTextFlags_WordWrap);

            static ImVector<char> my_str;
            if (my_str.empty())
                my_str.push_back(0);
            Funcs::MyInputTextMultiline("##MyStr", &my_str, ImVec2(-FLT_MIN, ImGui::GetTextLineHeight() * 16), flags);
            ImGui::Text("Data: %p\nSize: %d\nCapacity: %d", (void*)my_str.begin(), my_str.size(), my_str.capacity());
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text Input/Eliding, Alignment");
        if (ImGui::TreeNode("Eliding, Alignment"))
        {
            static char buf1[128] = "/path/to/some/folder/with/long/filename.cpp";
            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_ElideLeft;
            ImGui::CheckboxFlags("ImGuiInputTextFlags_ElideLeft", &flags, ImGuiInputTextFlags_ElideLeft);
            ImGui::InputText("Path", buf1, IM_ARRAYSIZE(buf1), flags);
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Text Input/Miscellaneous");
        if (ImGui::TreeNode("Miscellaneous"))
        {
            static char buf1[16];
            static ImGuiInputTextFlags flags = ImGuiInputTextFlags_EscapeClearsAll;
            ImGui::CheckboxFlags("ImGuiInputTextFlags_EscapeClearsAll", &flags, ImGuiInputTextFlags_EscapeClearsAll);
            ImGui::CheckboxFlags("ImGuiInputTextFlags_ReadOnly", &flags, ImGuiInputTextFlags_ReadOnly);
            ImGui::CheckboxFlags("ImGuiInputTextFlags_NoUndoRedo", &flags, ImGuiInputTextFlags_NoUndoRedo);
            ImGui::InputText("Hello", buf1, IM_ARRAYSIZE(buf1), flags);
            ImGui::TreePop();
        }

        ImGui::TreePop();
    }

}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsTooltips()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsTooltips()
{
    IMGUI_DEMO_MARKER("Widgets/Tooltips");
    if (ImGui::TreeNode("Tooltips"))
    {
        // Tooltips are windows following the mouse. They do not take focus away.
        ImGui::SeparatorText("General");

        // Typical use cases:
        // - Short-form (text only):      SetItemTooltip("Hello");
        // - Short-form (any contents):   if (BeginItemTooltip()) { Text("Hello"); EndTooltip(); }

        // - Full-form (text only):       if (IsItemHovered(...)) { SetTooltip("Hello"); }
        // - Full-form (any contents):    if (IsItemHovered(...) && BeginTooltip()) { Text("Hello"); EndTooltip(); }

        HelpMarker(
            "Tooltip are typically created by using a IsItemHovered() + SetTooltip() sequence.\n\n"
            "We provide a helper SetItemTooltip() function to perform the two with standards flags.");

        ImVec2 sz = ImVec2(-FLT_MIN, 0.0f);

        ImGui::Button("Basic", sz);
        ImGui::SetItemTooltip("I am a tooltip");

        ImGui::Button("Fancy", sz);
        if (ImGui::BeginItemTooltip())
        {
            ImGui::Text("I am a fancy tooltip");
            static float arr[] = { 0.6f, 0.1f, 1.0f, 0.5f, 0.92f, 0.1f, 0.2f };
            ImGui::PlotLines("Curve", arr, IM_ARRAYSIZE(arr));
            ImGui::Text("Sin(time) = %f", sinf((float)ImGui::GetTime()));
            ImGui::EndTooltip();
        }

        ImGui::SeparatorText("Always On");

        // Showcase NOT relying on a IsItemHovered() to emit a tooltip.
        // Here the tooltip is always emitted when 'always_on == true'.
        static int always_on = 0;
        ImGui::RadioButton("Off", &always_on, 0);
        ImGui::SameLine();
        ImGui::RadioButton("Always On (Simple)", &always_on, 1);
        ImGui::SameLine();
        ImGui::RadioButton("Always On (Advanced)", &always_on, 2);
        if (always_on == 1)
            ImGui::SetTooltip("I am following you around.");
        else if (always_on == 2 && ImGui::BeginTooltip())
        {
            ImGui::ProgressBar(sinf((float)ImGui::GetTime()) * 0.5f + 0.5f, ImVec2(ImGui::GetFontSize() * 25, 0.0f));
            ImGui::EndTooltip();
        }

        ImGui::SeparatorText("Custom");

        HelpMarker(
            "Passing ImGuiHoveredFlags_ForTooltip to IsItemHovered() is the preferred way to standardize "
            "tooltip activation details across your application. You may however decide to use custom "
            "flags for a specific tooltip instance.");

        // The following examples are passed for documentation purpose but may not be useful to most users.
        // Passing ImGuiHoveredFlags_ForTooltip to IsItemHovered() will pull ImGuiHoveredFlags flags values from
        // 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' depending on whether mouse or keyboard/gamepad is being used.
        // With default settings, ImGuiHoveredFlags_ForTooltip is equivalent to ImGuiHoveredFlags_DelayShort + ImGuiHoveredFlags_Stationary.
        ImGui::Button("Manual", sz);
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip))
            ImGui::SetTooltip("I am a manually emitted tooltip.");

        ImGui::Button("DelayNone", sz);
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayNone))
            ImGui::SetTooltip("I am a tooltip with no delay.");

        ImGui::Button("DelayShort", sz);
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_NoSharedDelay))
            ImGui::SetTooltip("I am a tooltip with a short delay (%0.2f sec).", ImGui::GetStyle().HoverDelayShort);

        ImGui::Button("DelayLong", sz);
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_NoSharedDelay))
            ImGui::SetTooltip("I am a tooltip with a long delay (%0.2f sec).", ImGui::GetStyle().HoverDelayNormal);

        ImGui::Button("Stationary", sz);
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_Stationary))
            ImGui::SetTooltip("I am a tooltip requiring mouse to be stationary before activating.");

        // Using ImGuiHoveredFlags_ForTooltip will pull flags from 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav',
        // which default value include the ImGuiHoveredFlags_AllowWhenDisabled flag.
        ImGui::BeginDisabled();
        ImGui::Button("Disabled item", sz);
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_ForTooltip))
            ImGui::SetTooltip("I am a a tooltip for a disabled item.");
        ImGui::EndDisabled();

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsTreeNodes()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsTreeNodes()
{
    IMGUI_DEMO_MARKER("Widgets/Tree Nodes");
    if (ImGui::TreeNode("Tree Nodes"))
    {
        // See see "Examples -> Property Editor" (ShowExampleAppPropertyEditor() function) for a fancier, data-driven tree.
        IMGUI_DEMO_MARKER("Widgets/Tree Nodes/Basic trees");
        if (ImGui::TreeNode("Basic trees"))
        {
            for (int i = 0; i < 5; i++)
            {
                // Use SetNextItemOpen() so set the default state of a node to be open. We could
                // also use TreeNodeEx() with the ImGuiTreeNodeFlags_DefaultOpen flag to achieve the same thing!
                if (i == 0)
                    ImGui::SetNextItemOpen(true, ImGuiCond_Once);

                // Here we use PushID() to generate a unique base ID, and then the "" used as TreeNode id won't conflict.
                // An alternative to using 'PushID() + TreeNode("", ...)' to generate a unique ID is to use 'TreeNode((void*)(intptr_t)i, ...)',
                // aka generate a dummy pointer-sized value to be hashed. The demo below uses that technique. Both are fine.
                ImGui::PushID(i);
                if (ImGui::TreeNode("", "Child %d", i))
                {
                    ImGui::Text("blah blah");
                    ImGui::SameLine();
                    if (ImGui::SmallButton("button")) {}
                    ImGui::TreePop();
                }
                ImGui::PopID();
            }
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Tree Nodes/Hierarchy lines");
        if (ImGui::TreeNode("Hierarchy lines"))
        {
            static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_DrawLinesFull | ImGuiTreeNodeFlags_DefaultOpen;
            HelpMarker("Default option for DrawLinesXXX is stored in style.TreeLinesFlags");
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_DrawLinesNone", &base_flags, ImGuiTreeNodeFlags_DrawLinesNone);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_DrawLinesFull", &base_flags, ImGuiTreeNodeFlags_DrawLinesFull);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_DrawLinesToNodes", &base_flags, ImGuiTreeNodeFlags_DrawLinesToNodes);

            if (ImGui::TreeNodeEx("Parent", base_flags))
            {
                if (ImGui::TreeNodeEx("Child 1", base_flags))
                {
                    ImGui::Button("Button for Child 1");
                    ImGui::TreePop();
                }
                if (ImGui::TreeNodeEx("Child 2", base_flags))
                {
                    ImGui::Button("Button for Child 2");
                    ImGui::TreePop();
                }
                ImGui::Text("Remaining contents");
                ImGui::Text("Remaining contents");
                ImGui::TreePop();
            }

            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Widgets/Tree Nodes/Advanced, with Selectable nodes");
        if (ImGui::TreeNode("Advanced, with Selectable nodes"))
        {
            HelpMarker(
                "This is a more typical looking tree with selectable nodes.\n"
                "Click to select, CTRL+Click to toggle, click on arrows or double-click to open.");
            static ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_SpanAvailWidth;
            static bool align_label_with_current_x_position = false;
            static bool test_drag_and_drop = false;
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_OpenOnArrow", &base_flags, ImGuiTreeNodeFlags_OpenOnArrow);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_OpenOnDoubleClick", &base_flags, ImGuiTreeNodeFlags_OpenOnDoubleClick);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanAvailWidth", &base_flags, ImGuiTreeNodeFlags_SpanAvailWidth); ImGui::SameLine(); HelpMarker("Extend hit area to all available width instead of allowing more items to be laid out after the node.");
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanFullWidth", &base_flags, ImGuiTreeNodeFlags_SpanFullWidth);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanLabelWidth", &base_flags, ImGuiTreeNodeFlags_SpanLabelWidth); ImGui::SameLine(); HelpMarker("Reduce hit area to the text label and a bit of margin.");
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanAllColumns", &base_flags, ImGuiTreeNodeFlags_SpanAllColumns); ImGui::SameLine(); HelpMarker("For use in Tables only.");
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_AllowOverlap", &base_flags, ImGuiTreeNodeFlags_AllowOverlap);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_Framed", &base_flags, ImGuiTreeNodeFlags_Framed); ImGui::SameLine(); HelpMarker("Draw frame with background (e.g. for CollapsingHeader)");
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_NavLeftJumpsToParent", &base_flags, ImGuiTreeNodeFlags_NavLeftJumpsToParent);

            HelpMarker("Default option for DrawLinesXXX is stored in style.TreeLinesFlags");
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_DrawLinesNone", &base_flags, ImGuiTreeNodeFlags_DrawLinesNone);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_DrawLinesFull", &base_flags, ImGuiTreeNodeFlags_DrawLinesFull);
            ImGui::CheckboxFlags("ImGuiTreeNodeFlags_DrawLinesToNodes", &base_flags, ImGuiTreeNodeFlags_DrawLinesToNodes);

            ImGui::Checkbox("Align label with current X position", &align_label_with_current_x_position);
            ImGui::Checkbox("Test tree node as drag source", &test_drag_and_drop);
            ImGui::Text("Hello!");
            if (align_label_with_current_x_position)
                ImGui::Unindent(ImGui::GetTreeNodeToLabelSpacing());

            // 'selection_mask' is dumb representation of what may be user-side selection state.
            //  You may retain selection state inside or outside your objects in whatever format you see fit.
            // 'node_clicked' is temporary storage of what node we have clicked to process selection at the end
            /// of the loop. May be a pointer to your own node type, etc.
            static int selection_mask = (1 << 2);
            int node_clicked = -1;
            for (int i = 0; i < 6; i++)
            {
                // Disable the default "open on single-click behavior" + set Selected flag according to our selection.
                // To alter selection we use IsItemClicked() && !IsItemToggledOpen(), so clicking on an arrow doesn't alter selection.
                ImGuiTreeNodeFlags node_flags = base_flags;
                const bool is_selected = (selection_mask & (1 << i)) != 0;
                if (is_selected)
                    node_flags |= ImGuiTreeNodeFlags_Selected;
                if (i < 3)
                {
                    // Items 0..2 are Tree Node
                    bool node_open = ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Node %d", i);
                    if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen())
                        node_clicked = i;
                    if (test_drag_and_drop && ImGui::BeginDragDropSource())
                    {
                        ImGui::SetDragDropPayload("_TREENODE", NULL, 0);
                        ImGui::Text("This is a drag and drop source");
                        ImGui::EndDragDropSource();
                    }
                    if (i == 2 && (base_flags & ImGuiTreeNodeFlags_SpanLabelWidth))
                    {
                        // Item 2 has an additional inline button to help demonstrate SpanLabelWidth.
                        ImGui::SameLine();
                        if (ImGui::SmallButton("button")) {}
                    }
                    if (node_open)
                    {
                        ImGui::BulletText("Blah blah\nBlah Blah");
                        ImGui::SameLine();
                        ImGui::SmallButton("Button");
                        ImGui::TreePop();
                    }
                }
                else
                {
                    // Items 3..5 are Tree Leaves
                    // The only reason we use TreeNode at all is to allow selection of the leaf. Otherwise we can
                    // use BulletText() or advance the cursor by GetTreeNodeToLabelSpacing() and call Text().
                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen; // ImGuiTreeNodeFlags_Bullet
                    ImGui::TreeNodeEx((void*)(intptr_t)i, node_flags, "Selectable Leaf %d", i);
                    if (ImGui::IsItemClicked() && !ImGui::IsItemToggledOpen())
                        node_clicked = i;
                    if (test_drag_and_drop && ImGui::BeginDragDropSource())
                    {
                        ImGui::SetDragDropPayload("_TREENODE", NULL, 0);
                        ImGui::Text("This is a drag and drop source");
                        ImGui::EndDragDropSource();
                    }
                }
            }
            if (node_clicked != -1)
            {
                // Update selection state
                // (process outside of tree loop to avoid visual inconsistencies during the clicking frame)
                if (ImGui::GetIO().KeyCtrl)
                    selection_mask ^= (1 << node_clicked);          // CTRL+click to toggle
                else //if (!(selection_mask & (1 << node_clicked))) // Depending on selection behavior you want, may want to preserve selection when clicking on item that is part of the selection
                    selection_mask = (1 << node_clicked);           // Click to single-select
            }
            if (align_label_with_current_x_position)
                ImGui::Indent(ImGui::GetTreeNodeToLabelSpacing());
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgetsVerticalSliders()
//-----------------------------------------------------------------------------

static void DemoWindowWidgetsVerticalSliders()
{
    IMGUI_DEMO_MARKER("Widgets/Vertical Sliders");
    if (ImGui::TreeNode("Vertical Sliders"))
    {
        const float spacing = 4;
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

        static int int_value = 0;
        ImGui::VSliderInt("##int", ImVec2(18, 160), &int_value, 0, 5);
        ImGui::SameLine();

        static float values[7] = { 0.0f, 0.60f, 0.35f, 0.9f, 0.70f, 0.20f, 0.0f };
        ImGui::PushID("set1");
        for (int i = 0; i < 7; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(i / 7.0f, 0.5f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(i / 7.0f, 0.6f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(i / 7.0f, 0.7f, 0.5f));
            ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(i / 7.0f, 0.9f, 0.9f));
            ImGui::VSliderFloat("##v", ImVec2(18, 160), &values[i], 0.0f, 1.0f, "");
            if (ImGui::IsItemActive() || ImGui::IsItemHovered())
                ImGui::SetTooltip("%.3f", values[i]);
            ImGui::PopStyleColor(4);
            ImGui::PopID();
        }
        ImGui::PopID();

        ImGui::SameLine();
        ImGui::PushID("set2");
        static float values2[4] = { 0.20f, 0.80f, 0.40f, 0.25f };
        const int rows = 3;
        const ImVec2 small_slider_size(18, (float)(int)((160.0f - (rows - 1) * spacing) / rows));
        for (int nx = 0; nx < 4; nx++)
        {
            if (nx > 0) ImGui::SameLine();
            ImGui::BeginGroup();
            for (int ny = 0; ny < rows; ny++)
            {
                ImGui::PushID(nx * rows + ny);
                ImGui::VSliderFloat("##v", small_slider_size, &values2[nx], 0.0f, 1.0f, "");
                if (ImGui::IsItemActive() || ImGui::IsItemHovered())
                    ImGui::SetTooltip("%.3f", values2[nx]);
                ImGui::PopID();
            }
            ImGui::EndGroup();
        }
        ImGui::PopID();

        ImGui::SameLine();
        ImGui::PushID("set3");
        for (int i = 0; i < 4; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::PushStyleVar(ImGuiStyleVar_GrabMinSize, 40);
            ImGui::VSliderFloat("##v", ImVec2(40, 160), &values[i], 0.0f, 1.0f, "%.2f\nsec");
            ImGui::PopStyleVar();
            ImGui::PopID();
        }
        ImGui::PopID();
        ImGui::PopStyleVar();
        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowWidgets()
//-----------------------------------------------------------------------------

static void DemoWindowWidgets(ImGuiDemoWindowData* demo_data)
{
    IMGUI_DEMO_MARKER("Widgets");
    //ImGui::SetNextItemOpen(true, ImGuiCond_Once);
    if (!ImGui::CollapsingHeader("Widgets"))
        return;

    const bool disable_all = demo_data->DisableSections; // The Checkbox for that is inside the "Disabled" section at the bottom
    if (disable_all)
        ImGui::BeginDisabled();

    DemoWindowWidgetsBasic();
    DemoWindowWidgetsBullets();
    DemoWindowWidgetsCollapsingHeaders();
    DemoWindowWidgetsComboBoxes();
    DemoWindowWidgetsColorAndPickers();
    DemoWindowWidgetsDataTypes();

    if (disable_all)
        ImGui::EndDisabled();
    DemoWindowWidgetsDisableBlocks(demo_data);
    if (disable_all)
        ImGui::BeginDisabled();

    DemoWindowWidgetsDragAndDrop();
    DemoWindowWidgetsDragsAndSliders();
    DemoWindowWidgetsFonts();
    DemoWindowWidgetsImages();
    DemoWindowWidgetsListBoxes();
    DemoWindowWidgetsMultiComponents();
    DemoWindowWidgetsPlotting();
    DemoWindowWidgetsProgressBars();
    DemoWindowWidgetsQueryingStatuses();
    DemoWindowWidgetsSelectables();
    DemoWindowWidgetsSelectionAndMultiSelect(demo_data);
    DemoWindowWidgetsTabs();
    DemoWindowWidgetsText();
    DemoWindowWidgetsTextFilter();
    DemoWindowWidgetsTextInput();
    DemoWindowWidgetsTooltips();
    DemoWindowWidgetsTreeNodes();
    DemoWindowWidgetsVerticalSliders();

    if (disable_all)
        ImGui::EndDisabled();
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowLayout()
//-----------------------------------------------------------------------------

static void DemoWindowLayout()
{
    IMGUI_DEMO_MARKER("Layout");
    if (!ImGui::CollapsingHeader("Layout & Scrolling"))
        return;

    IMGUI_DEMO_MARKER("Layout/Child windows");
    if (ImGui::TreeNode("Child windows"))
    {
        ImGui::SeparatorText("Child windows");

        HelpMarker("Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window.");
        static bool disable_mouse_wheel = false;
        static bool disable_menu = false;
        ImGui::Checkbox("Disable Mouse Wheel", &disable_mouse_wheel);
        ImGui::Checkbox("Disable Menu", &disable_menu);

        // Child 1: no border, enable horizontal scrollbar
        {
            ImGuiWindowFlags window_flags = ImGuiWindowFlags_HorizontalScrollbar;
            if (disable_mouse_wheel)
                window_flags |= ImGuiWindowFlags_NoScrollWithMouse;
            ImGui::BeginChild("ChildL", ImVec2(ImGui::GetContentRegionAvail().x * 0.5f, 260), ImGuiChildFlags_None, window_flags);
            for (int i = 0; i < 100; i++)
                ImGui::Text("%04d: scrollable region", i);
            ImGui::EndChild();
        }

        ImGui::SameLine();

        // Child 2: rounded border
        {
            ImGuiWindowFlags window_flags = ImGuiWindowFlags_None;
            if (disable_mouse_wheel)
                window_flags |= ImGuiWindowFlags_NoScrollWithMouse;
            if (!disable_menu)
                window_flags |= ImGuiWindowFlags_MenuBar;
            ImGui::PushStyleVar(ImGuiStyleVar_ChildRounding, 5.0f);
            ImGui::BeginChild("ChildR", ImVec2(0, 260), ImGuiChildFlags_Borders, window_flags);
            if (!disable_menu && ImGui::BeginMenuBar())
            {
                if (ImGui::BeginMenu("Menu"))
                {
                    ShowExampleMenuFile();
                    ImGui::EndMenu();
                }
                ImGui::EndMenuBar();
            }
            if (ImGui::BeginTable("split", 2, ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings))
            {
                for (int i = 0; i < 100; i++)
                {
                    char buf[32];
                    sprintf(buf, "%03d", i);
                    ImGui::TableNextColumn();
                    ImGui::Button(buf, ImVec2(-FLT_MIN, 0.0f));
                }
                ImGui::EndTable();
            }
            ImGui::EndChild();
            ImGui::PopStyleVar();
        }

        // Child 3: manual-resize
        ImGui::SeparatorText("Manual-resize");
        {
            HelpMarker("Drag bottom border to resize. Double-click bottom border to auto-fit to vertical contents.");
            //if (ImGui::Button("Set Height to 200"))
            //    ImGui::SetNextWindowSize(ImVec2(-FLT_MIN, 200.0f));

            ImGui::PushStyleColor(ImGuiCol_ChildBg, ImGui::GetStyleColorVec4(ImGuiCol_FrameBg));
            if (ImGui::BeginChild("ResizableChild", ImVec2(-FLT_MIN, ImGui::GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeY))
                for (int n = 0; n < 10; n++)
                    ImGui::Text("Line %04d", n);
            ImGui::PopStyleColor();
            ImGui::EndChild();
        }

        // Child 4: auto-resizing height with a limit
        ImGui::SeparatorText("Auto-resize with constraints");
        {
            static int draw_lines = 3;
            static int max_height_in_lines = 10;
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
            ImGui::DragInt("Lines Count", &draw_lines, 0.2f);
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
            ImGui::DragInt("Max Height (in Lines)", &max_height_in_lines, 0.2f);

            ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, ImGui::GetTextLineHeightWithSpacing() * 1), ImVec2(FLT_MAX, ImGui::GetTextLineHeightWithSpacing() * max_height_in_lines));
            if (ImGui::BeginChild("ConstrainedChild", ImVec2(-FLT_MIN, 0.0f), ImGuiChildFlags_Borders | ImGuiChildFlags_AutoResizeY))
                for (int n = 0; n < draw_lines; n++)
                    ImGui::Text("Line %04d", n);
            ImGui::EndChild();
        }

        ImGui::SeparatorText("Misc/Advanced");

        // Demonstrate a few extra things
        // - Changing ImGuiCol_ChildBg (which is transparent black in default styles)
        // - Using SetCursorPos() to position child window (the child window is an item from the POV of parent window)
        //   You can also call SetNextWindowPos() to position the child window. The parent window will effectively
        //   layout from this position.
        // - Using ImGui::GetItemRectMin/Max() to query the "item" state (because the child window is an item from
        //   the POV of the parent window). See 'Demo->Querying Status (Edited/Active/Hovered etc.)' for details.
        {
            static int offset_x = 0;
            static bool override_bg_color = true;
            static ImGuiChildFlags child_flags = ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeX | ImGuiChildFlags_ResizeY;
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
            ImGui::DragInt("Offset X", &offset_x, 1.0f, -1000, 1000);
            ImGui::Checkbox("Override ChildBg color", &override_bg_color);
            ImGui::CheckboxFlags("ImGuiChildFlags_Borders", &child_flags, ImGuiChildFlags_Borders);
            ImGui::CheckboxFlags("ImGuiChildFlags_AlwaysUseWindowPadding", &child_flags, ImGuiChildFlags_AlwaysUseWindowPadding);
            ImGui::CheckboxFlags("ImGuiChildFlags_ResizeX", &child_flags, ImGuiChildFlags_ResizeX);
            ImGui::CheckboxFlags("ImGuiChildFlags_ResizeY", &child_flags, ImGuiChildFlags_ResizeY);
            ImGui::CheckboxFlags("ImGuiChildFlags_FrameStyle", &child_flags, ImGuiChildFlags_FrameStyle);
            ImGui::SameLine(); HelpMarker("Style the child window like a framed item: use FrameBg, FrameRounding, FrameBorderSize, FramePadding instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.");
            if (child_flags & ImGuiChildFlags_FrameStyle)
                override_bg_color = false;

            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (float)offset_x);
            if (override_bg_color)
                ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(255, 0, 0, 100));
            ImGui::BeginChild("Red", ImVec2(200, 100), child_flags, ImGuiWindowFlags_None);
            if (override_bg_color)
                ImGui::PopStyleColor();

            for (int n = 0; n < 50; n++)
                ImGui::Text("Some test %d", n);
            ImGui::EndChild();
            bool child_is_hovered = ImGui::IsItemHovered();
            ImVec2 child_rect_min = ImGui::GetItemRectMin();
            ImVec2 child_rect_max = ImGui::GetItemRectMax();
            ImGui::Text("Hovered: %d", child_is_hovered);
            ImGui::Text("Rect of child window is: (%.0f,%.0f) (%.0f,%.0f)", child_rect_min.x, child_rect_min.y, child_rect_max.x, child_rect_max.y);
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Widgets Width");
    if (ImGui::TreeNode("Widgets Width"))
    {
        static float f = 0.0f;
        static bool show_indented_items = true;
        ImGui::Checkbox("Show indented items", &show_indented_items);

        // Use SetNextItemWidth() to set the width of a single upcoming item.
        // Use PushItemWidth()/PopItemWidth() to set the width of a group of items.
        // In real code use you'll probably want to choose width values that are proportional to your font size
        // e.g. Using '20.0f * GetFontSize()' as width instead of '200.0f', etc.

        ImGui::Text("SetNextItemWidth/PushItemWidth(100)");
        ImGui::SameLine(); HelpMarker("Fixed width.");
        ImGui::PushItemWidth(100);
        ImGui::DragFloat("float##1b", &f);
        if (show_indented_items)
        {
            ImGui::Indent();
            ImGui::DragFloat("float (indented)##1b", &f);
            ImGui::Unindent();
        }
        ImGui::PopItemWidth();

        ImGui::Text("SetNextItemWidth/PushItemWidth(-100)");
        ImGui::SameLine(); HelpMarker("Align to right edge minus 100");
        ImGui::PushItemWidth(-100);
        ImGui::DragFloat("float##2a", &f);
        if (show_indented_items)
        {
            ImGui::Indent();
            ImGui::DragFloat("float (indented)##2b", &f);
            ImGui::Unindent();
        }
        ImGui::PopItemWidth();

        ImGui::Text("SetNextItemWidth/PushItemWidth(GetContentRegionAvail().x * 0.5f)");
        ImGui::SameLine(); HelpMarker("Half of available width.\n(~ right-cursor_pos)\n(works within a column set)");
        ImGui::PushItemWidth(ImGui::GetContentRegionAvail().x * 0.5f);
        ImGui::DragFloat("float##3a", &f);
        if (show_indented_items)
        {
            ImGui::Indent();
            ImGui::DragFloat("float (indented)##3b", &f);
            ImGui::Unindent();
        }
        ImGui::PopItemWidth();

        ImGui::Text("SetNextItemWidth/PushItemWidth(-GetContentRegionAvail().x * 0.5f)");
        ImGui::SameLine(); HelpMarker("Align to right edge minus half");
        ImGui::PushItemWidth(-ImGui::GetContentRegionAvail().x * 0.5f);
        ImGui::DragFloat("float##4a", &f);
        if (show_indented_items)
        {
            ImGui::Indent();
            ImGui::DragFloat("float (indented)##4b", &f);
            ImGui::Unindent();
        }
        ImGui::PopItemWidth();

        ImGui::Text("SetNextItemWidth/PushItemWidth(-Min(GetContentRegionAvail().x * 0.40f, GetFontSize() * 12))");
        ImGui::PushItemWidth(-IM_MIN(ImGui::GetFontSize() * 12, ImGui::GetContentRegionAvail().x * 0.40f));
        ImGui::DragFloat("float##5a", &f);
        if (show_indented_items)
        {
            ImGui::Indent();
            ImGui::DragFloat("float (indented)##5b", &f);
            ImGui::Unindent();
        }
        ImGui::PopItemWidth();

        // Demonstrate using PushItemWidth to surround three items.
        // Calling SetNextItemWidth() before each of them would have the same effect.
        ImGui::Text("SetNextItemWidth/PushItemWidth(-FLT_MIN)");
        ImGui::SameLine(); HelpMarker("Align to right edge");
        ImGui::PushItemWidth(-FLT_MIN);
        ImGui::DragFloat("##float6a", &f);
        if (show_indented_items)
        {
            ImGui::Indent();
            ImGui::DragFloat("float (indented)##6b", &f);
            ImGui::Unindent();
        }
        ImGui::PopItemWidth();

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Basic Horizontal Layout");
    if (ImGui::TreeNode("Basic Horizontal Layout"))
    {
        ImGui::TextWrapped("(Use ImGui::SameLine() to keep adding items to the right of the preceding item)");

        // Text
        IMGUI_DEMO_MARKER("Layout/Basic Horizontal Layout/SameLine");
        ImGui::Text("Two items: Hello"); ImGui::SameLine();
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Sailor");

        // Adjust spacing
        ImGui::Text("More spacing: Hello"); ImGui::SameLine(0, 20);
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Sailor");

        // Button
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Normal buttons"); ImGui::SameLine();
        ImGui::Button("Banana"); ImGui::SameLine();
        ImGui::Button("Apple"); ImGui::SameLine();
        ImGui::Button("Corniflower");

        // Button
        ImGui::Text("Small buttons"); ImGui::SameLine();
        ImGui::SmallButton("Like this one"); ImGui::SameLine();
        ImGui::Text("can fit within a text block.");

        // Aligned to arbitrary position. Easy/cheap column.
        IMGUI_DEMO_MARKER("Layout/Basic Horizontal Layout/SameLine (with offset)");
        ImGui::Text("Aligned");
        ImGui::SameLine(150); ImGui::Text("x=150");
        ImGui::SameLine(300); ImGui::Text("x=300");
        ImGui::Text("Aligned");
        ImGui::SameLine(150); ImGui::SmallButton("x=150");
        ImGui::SameLine(300); ImGui::SmallButton("x=300");

        // Checkbox
        IMGUI_DEMO_MARKER("Layout/Basic Horizontal Layout/SameLine (more)");
        static bool c1 = false, c2 = false, c3 = false, c4 = false;
        ImGui::Checkbox("My", &c1); ImGui::SameLine();
        ImGui::Checkbox("Tailor", &c2); ImGui::SameLine();
        ImGui::Checkbox("Is", &c3); ImGui::SameLine();
        ImGui::Checkbox("Rich", &c4);

        // Various
        static float f0 = 1.0f, f1 = 2.0f, f2 = 3.0f;
        ImGui::PushItemWidth(80);
        const char* items[] = { "AAAA", "BBBB", "CCCC", "DDDD" };
        static int item = -1;
        ImGui::Combo("Combo", &item, items, IM_ARRAYSIZE(items)); ImGui::SameLine();
        ImGui::SliderFloat("X", &f0, 0.0f, 5.0f); ImGui::SameLine();
        ImGui::SliderFloat("Y", &f1, 0.0f, 5.0f); ImGui::SameLine();
        ImGui::SliderFloat("Z", &f2, 0.0f, 5.0f);
        ImGui::PopItemWidth();

        ImGui::PushItemWidth(80);
        ImGui::Text("Lists:");
        static int selection[4] = { 0, 1, 2, 3 };
        for (int i = 0; i < 4; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::PushID(i);
            ImGui::ListBox("", &selection[i], items, IM_ARRAYSIZE(items));
            ImGui::PopID();
            //ImGui::SetItemTooltip("ListBox %d hovered", i);
        }
        ImGui::PopItemWidth();

        // Dummy
        IMGUI_DEMO_MARKER("Layout/Basic Horizontal Layout/Dummy");
        ImVec2 button_sz(40, 40);
        ImGui::Button("A", button_sz); ImGui::SameLine();
        ImGui::Dummy(button_sz); ImGui::SameLine();
        ImGui::Button("B", button_sz);

        // Manually wrapping
        // (we should eventually provide this as an automatic layout feature, but for now you can do it manually)
        IMGUI_DEMO_MARKER("Layout/Basic Horizontal Layout/Manual wrapping");
        ImGui::Text("Manual wrapping:");
        ImGuiStyle& style = ImGui::GetStyle();
        int buttons_count = 20;
        float window_visible_x2 = ImGui::GetCursorScreenPos().x + ImGui::GetContentRegionAvail().x;
        for (int n = 0; n < buttons_count; n++)
        {
            ImGui::PushID(n);
            ImGui::Button("Box", button_sz);
            float last_button_x2 = ImGui::GetItemRectMax().x;
            float next_button_x2 = last_button_x2 + style.ItemSpacing.x + button_sz.x; // Expected position if next button was on same line
            if (n + 1 < buttons_count && next_button_x2 < window_visible_x2)
                ImGui::SameLine();
            ImGui::PopID();
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Groups");
    if (ImGui::TreeNode("Groups"))
    {
        HelpMarker(
            "BeginGroup() basically locks the horizontal position for new line. "
            "EndGroup() bundles the whole group so that you can use \"item\" functions such as "
            "IsItemHovered()/IsItemActive() or SameLine() etc. on the whole group.");
        ImGui::BeginGroup();
        {
            ImGui::BeginGroup();
            ImGui::Button("AAA");
            ImGui::SameLine();
            ImGui::Button("BBB");
            ImGui::SameLine();
            ImGui::BeginGroup();
            ImGui::Button("CCC");
            ImGui::Button("DDD");
            ImGui::EndGroup();
            ImGui::SameLine();
            ImGui::Button("EEE");
            ImGui::EndGroup();
            ImGui::SetItemTooltip("First group hovered");
        }
        // Capture the group size and create widgets using the same size
        ImVec2 size = ImGui::GetItemRectSize();
        const float values[5] = { 0.5f, 0.20f, 0.80f, 0.60f, 0.25f };
        ImGui::PlotHistogram("##values", values, IM_ARRAYSIZE(values), 0, NULL, 0.0f, 1.0f, size);

        ImGui::Button("ACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x) * 0.5f, size.y));
        ImGui::SameLine();
        ImGui::Button("REACTION", ImVec2((size.x - ImGui::GetStyle().ItemSpacing.x) * 0.5f, size.y));
        ImGui::EndGroup();
        ImGui::SameLine();

        ImGui::Button("LEVERAGE\nBUZZWORD", size);
        ImGui::SameLine();

        if (ImGui::BeginListBox("List", size))
        {
            ImGui::Selectable("Selected", true);
            ImGui::Selectable("Not Selected", false);
            ImGui::EndListBox();
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Text Baseline Alignment");
    if (ImGui::TreeNode("Text Baseline Alignment"))
    {
        {
            ImGui::BulletText("Text baseline:");
            ImGui::SameLine(); HelpMarker(
                "This is testing the vertical alignment that gets applied on text to keep it aligned with widgets. "
                "Lines only composed of text or \"small\" widgets use less vertical space than lines with framed widgets.");
            ImGui::Indent();

            ImGui::Text("KO Blahblah"); ImGui::SameLine();
            ImGui::Button("Some framed item"); ImGui::SameLine();
            HelpMarker("Baseline of button will look misaligned with text..");

            // If your line starts with text, call AlignTextToFramePadding() to align text to upcoming widgets.
            // (because we don't know what's coming after the Text() statement, we need to move the text baseline
            // down by FramePadding.y ahead of time)
            ImGui::AlignTextToFramePadding();
            ImGui::Text("OK Blahblah"); ImGui::SameLine();
            ImGui::Button("Some framed item##2"); ImGui::SameLine();
            HelpMarker("We call AlignTextToFramePadding() to vertically align the text baseline by +FramePadding.y");

            // SmallButton() uses the same vertical padding as Text
            ImGui::Button("TEST##1"); ImGui::SameLine();
            ImGui::Text("TEST"); ImGui::SameLine();
            ImGui::SmallButton("TEST##2");

            // If your line starts with text, call AlignTextToFramePadding() to align text to upcoming widgets.
            ImGui::AlignTextToFramePadding();
            ImGui::Text("Text aligned to framed item"); ImGui::SameLine();
            ImGui::Button("Item##1"); ImGui::SameLine();
            ImGui::Text("Item"); ImGui::SameLine();
            ImGui::SmallButton("Item##2"); ImGui::SameLine();
            ImGui::Button("Item##3");

            ImGui::Unindent();
        }

        ImGui::Spacing();

        {
            ImGui::BulletText("Multi-line text:");
            ImGui::Indent();
            ImGui::Text("One\nTwo\nThree"); ImGui::SameLine();
            ImGui::Text("Hello\nWorld"); ImGui::SameLine();
            ImGui::Text("Banana");

            ImGui::Text("Banana"); ImGui::SameLine();
            ImGui::Text("Hello\nWorld"); ImGui::SameLine();
            ImGui::Text("One\nTwo\nThree");

            ImGui::Button("HOP##1"); ImGui::SameLine();
            ImGui::Text("Banana"); ImGui::SameLine();
            ImGui::Text("Hello\nWorld"); ImGui::SameLine();
            ImGui::Text("Banana");

            ImGui::Button("HOP##2"); ImGui::SameLine();
            ImGui::Text("Hello\nWorld"); ImGui::SameLine();
            ImGui::Text("Banana");
            ImGui::Unindent();
        }

        ImGui::Spacing();

        {
            ImGui::BulletText("Misc items:");
            ImGui::Indent();

            // SmallButton() sets FramePadding to zero. Text baseline is aligned to match baseline of previous Button.
            ImGui::Button("80x80", ImVec2(80, 80));
            ImGui::SameLine();
            ImGui::Button("50x50", ImVec2(50, 50));
            ImGui::SameLine();
            ImGui::Button("Button()");
            ImGui::SameLine();
            ImGui::SmallButton("SmallButton()");

            // Tree
            // (here the node appears after a button and has odd intent, so we use ImGuiTreeNodeFlags_DrawLinesNone to disable hierarchy outline)
            const float spacing = ImGui::GetStyle().ItemInnerSpacing.x;
            ImGui::Button("Button##1");
            ImGui::SameLine(0.0f, spacing);
            if (ImGui::TreeNodeEx("Node##1", ImGuiTreeNodeFlags_DrawLinesNone))
            {
                // Placeholder tree data
                for (int i = 0; i < 6; i++)
                    ImGui::BulletText("Item %d..", i);
                ImGui::TreePop();
            }

            // Vertically align text node a bit lower so it'll be vertically centered with upcoming widget.
            // Otherwise you can use SmallButton() (smaller fit).
            ImGui::AlignTextToFramePadding();

            // Common mistake to avoid: if we want to SameLine after TreeNode we need to do it before we add
            // other contents below the node.
            bool node_open = ImGui::TreeNode("Node##2");
            ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##2");
            if (node_open)
            {
                // Placeholder tree data
                for (int i = 0; i < 6; i++)
                    ImGui::BulletText("Item %d..", i);
                ImGui::TreePop();
            }

            // Bullet
            ImGui::Button("Button##3");
            ImGui::SameLine(0.0f, spacing);
            ImGui::BulletText("Bullet text");

            ImGui::AlignTextToFramePadding();
            ImGui::BulletText("Node");
            ImGui::SameLine(0.0f, spacing); ImGui::Button("Button##4");
            ImGui::Unindent();
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Scrolling");
    if (ImGui::TreeNode("Scrolling"))
    {
        // Vertical scroll functions
        IMGUI_DEMO_MARKER("Layout/Scrolling/Vertical");
        HelpMarker("Use SetScrollHereY() or SetScrollFromPosY() to scroll to a given vertical position.");

        static int track_item = 50;
        static bool enable_track = true;
        static bool enable_extra_decorations = false;
        static float scroll_to_off_px = 0.0f;
        static float scroll_to_pos_px = 200.0f;

        ImGui::Checkbox("Decoration", &enable_extra_decorations);

        ImGui::PushItemWidth(ImGui::GetFontSize() * 10);
        enable_track |= ImGui::DragInt("##item", &track_item, 0.25f, 0, 99, "Item = %d");
        ImGui::SameLine();
        ImGui::Checkbox("Track", &enable_track);

        bool scroll_to_off = ImGui::DragFloat("##off", &scroll_to_off_px, 1.00f, 0, FLT_MAX, "+%.0f px");
        ImGui::SameLine();
        scroll_to_off |= ImGui::Button("Scroll Offset");

        bool scroll_to_pos = ImGui::DragFloat("##pos", &scroll_to_pos_px, 1.00f, -10, FLT_MAX, "X/Y = %.0f px");
        ImGui::SameLine();
        scroll_to_pos |= ImGui::Button("Scroll To Pos");
        ImGui::PopItemWidth();

        if (scroll_to_off || scroll_to_pos)
            enable_track = false;

        ImGuiStyle& style = ImGui::GetStyle();
        float child_w = (ImGui::GetContentRegionAvail().x - 4 * style.ItemSpacing.x) / 5;
        if (child_w < 1.0f)
            child_w = 1.0f;
        ImGui::PushID("##VerticalScrolling");
        for (int i = 0; i < 5; i++)
        {
            if (i > 0) ImGui::SameLine();
            ImGui::BeginGroup();
            const char* names[] = { "Top", "25%", "Center", "75%", "Bottom" };
            ImGui::TextUnformatted(names[i]);

            const ImGuiWindowFlags child_flags = enable_extra_decorations ? ImGuiWindowFlags_MenuBar : 0;
            const ImGuiID child_id = ImGui::GetID((void*)(intptr_t)i);
            const bool child_is_visible = ImGui::BeginChild(child_id, ImVec2(child_w, 200.0f), ImGuiChildFlags_Borders, child_flags);
            if (ImGui::BeginMenuBar())
            {
                ImGui::TextUnformatted("abc");
                ImGui::EndMenuBar();
            }
            if (scroll_to_off)
                ImGui::SetScrollY(scroll_to_off_px);
            if (scroll_to_pos)
                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + scroll_to_pos_px, i * 0.25f);
            if (child_is_visible) // Avoid calling SetScrollHereY when running with culled items
            {
                for (int item = 0; item < 100; item++)
                {
                    if (enable_track && item == track_item)
                    {
                        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Item %d", item);
                        ImGui::SetScrollHereY(i * 0.25f); // 0.0f:top, 0.5f:center, 1.0f:bottom
                    }
                    else
                    {
                        ImGui::Text("Item %d", item);
                    }
                }
            }
            float scroll_y = ImGui::GetScrollY();
            float scroll_max_y = ImGui::GetScrollMaxY();
            ImGui::EndChild();
            ImGui::Text("%.0f/%.0f", scroll_y, scroll_max_y);
            ImGui::EndGroup();
        }
        ImGui::PopID();

        // Horizontal scroll functions
        IMGUI_DEMO_MARKER("Layout/Scrolling/Horizontal");
        ImGui::Spacing();
        HelpMarker(
            "Use SetScrollHereX() or SetScrollFromPosX() to scroll to a given horizontal position.\n\n"
            "Because the clipping rectangle of most window hides half worth of WindowPadding on the "
            "left/right, using SetScrollFromPosX(+1) will usually result in clipped text whereas the "
            "equivalent SetScrollFromPosY(+1) wouldn't.");
        ImGui::PushID("##HorizontalScrolling");
        for (int i = 0; i < 5; i++)
        {
            float child_height = ImGui::GetTextLineHeight() + style.ScrollbarSize + style.WindowPadding.y * 2.0f;
            ImGuiWindowFlags child_flags = ImGuiWindowFlags_HorizontalScrollbar | (enable_extra_decorations ? ImGuiWindowFlags_AlwaysVerticalScrollbar : 0);
            ImGuiID child_id = ImGui::GetID((void*)(intptr_t)i);
            bool child_is_visible = ImGui::BeginChild(child_id, ImVec2(-100, child_height), ImGuiChildFlags_Borders, child_flags);
            if (scroll_to_off)
                ImGui::SetScrollX(scroll_to_off_px);
            if (scroll_to_pos)
                ImGui::SetScrollFromPosX(ImGui::GetCursorStartPos().x + scroll_to_pos_px, i * 0.25f);
            if (child_is_visible) // Avoid calling SetScrollHereY when running with culled items
            {
                for (int item = 0; item < 100; item++)
                {
                    if (item > 0)
                        ImGui::SameLine();
                    if (enable_track && item == track_item)
                    {
                        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Item %d", item);
                        ImGui::SetScrollHereX(i * 0.25f); // 0.0f:left, 0.5f:center, 1.0f:right
                    }
                    else
                    {
                        ImGui::Text("Item %d", item);
                    }
                }
            }
            float scroll_x = ImGui::GetScrollX();
            float scroll_max_x = ImGui::GetScrollMaxX();
            ImGui::EndChild();
            ImGui::SameLine();
            const char* names[] = { "Left", "25%", "Center", "75%", "Right" };
            ImGui::Text("%s\n%.0f/%.0f", names[i], scroll_x, scroll_max_x);
            ImGui::Spacing();
        }
        ImGui::PopID();

        // Miscellaneous Horizontal Scrolling Demo
        IMGUI_DEMO_MARKER("Layout/Scrolling/Horizontal (more)");
        HelpMarker(
            "Horizontal scrolling for a window is enabled via the ImGuiWindowFlags_HorizontalScrollbar flag.\n\n"
            "You may want to also explicitly specify content width by using SetNextWindowContentWidth() before Begin().");
        static int lines = 7;
        ImGui::SliderInt("Lines", &lines, 1, 15);
        ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 3.0f);
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.0f, 1.0f));
        ImVec2 scrolling_child_size = ImVec2(0, ImGui::GetFrameHeightWithSpacing() * 7 + 30);
        ImGui::BeginChild("scrolling", scrolling_child_size, ImGuiChildFlags_Borders, ImGuiWindowFlags_HorizontalScrollbar);
        for (int line = 0; line < lines; line++)
        {
            // Display random stuff. For the sake of this trivial demo we are using basic Button() + SameLine()
            // If you want to create your own time line for a real application you may be better off manipulating
            // the cursor position yourself, aka using SetCursorPos/SetCursorScreenPos to position the widgets
            // yourself. You may also want to use the lower-level ImDrawList API.
            int num_buttons = 10 + ((line & 1) ? line * 9 : line * 3);
            for (int n = 0; n < num_buttons; n++)
            {
                if (n > 0) ImGui::SameLine();
                ImGui::PushID(n + line * 1000);
                char num_buf[16];
                sprintf(num_buf, "%d", n);
                const char* label = (!(n % 15)) ? "FizzBuzz" : (!(n % 3)) ? "Fizz" : (!(n % 5)) ? "Buzz" : num_buf;
                float hue = n * 0.05f;
                ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));
                ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(hue, 0.8f, 0.8f));
                ImGui::Button(label, ImVec2(40.0f + sinf((float)(line + n)) * 20.0f, 0.0f));
                ImGui::PopStyleColor(3);
                ImGui::PopID();
            }
        }
        float scroll_x = ImGui::GetScrollX();
        float scroll_max_x = ImGui::GetScrollMaxX();
        ImGui::EndChild();
        ImGui::PopStyleVar(2);
        float scroll_x_delta = 0.0f;
        ImGui::SmallButton("<<");
        if (ImGui::IsItemActive())
            scroll_x_delta = -ImGui::GetIO().DeltaTime * 1000.0f;
        ImGui::SameLine();
        ImGui::Text("Scroll from code"); ImGui::SameLine();
        ImGui::SmallButton(">>");
        if (ImGui::IsItemActive())
            scroll_x_delta = +ImGui::GetIO().DeltaTime * 1000.0f;
        ImGui::SameLine();
        ImGui::Text("%.0f/%.0f", scroll_x, scroll_max_x);
        if (scroll_x_delta != 0.0f)
        {
            // Demonstrate a trick: you can use Begin to set yourself in the context of another window
            // (here we are already out of your child window)
            ImGui::BeginChild("scrolling");
            ImGui::SetScrollX(ImGui::GetScrollX() + scroll_x_delta);
            ImGui::EndChild();
        }
        ImGui::Spacing();

        static bool show_horizontal_contents_size_demo_window = false;
        ImGui::Checkbox("Show Horizontal contents size demo window", &show_horizontal_contents_size_demo_window);

        if (show_horizontal_contents_size_demo_window)
        {
            static bool show_h_scrollbar = true;
            static bool show_button = true;
            static bool show_tree_nodes = true;
            static bool show_text_wrapped = false;
            static bool show_columns = true;
            static bool show_tab_bar = true;
            static bool show_child = false;
            static bool explicit_content_size = false;
            static float contents_size_x = 300.0f;
            if (explicit_content_size)
                ImGui::SetNextWindowContentSize(ImVec2(contents_size_x, 0.0f));
            ImGui::Begin("Horizontal contents size demo window", &show_horizontal_contents_size_demo_window, show_h_scrollbar ? ImGuiWindowFlags_HorizontalScrollbar : 0);
            IMGUI_DEMO_MARKER("Layout/Scrolling/Horizontal contents size demo window");
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(2, 0));
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 0));
            HelpMarker(
                "Test how different widgets react and impact the work rectangle growing when horizontal scrolling is enabled.\n\n"
                "Use 'Metrics->Tools->Show windows rectangles' to visualize rectangles.");
            ImGui::Checkbox("H-scrollbar", &show_h_scrollbar);
            ImGui::Checkbox("Button", &show_button);            // Will grow contents size (unless explicitly overwritten)
            ImGui::Checkbox("Tree nodes", &show_tree_nodes);    // Will grow contents size and display highlight over full width
            ImGui::Checkbox("Text wrapped", &show_text_wrapped);// Will grow and use contents size
            ImGui::Checkbox("Columns", &show_columns);          // Will use contents size
            ImGui::Checkbox("Tab bar", &show_tab_bar);          // Will use contents size
            ImGui::Checkbox("Child", &show_child);              // Will grow and use contents size
            ImGui::Checkbox("Explicit content size", &explicit_content_size);
            ImGui::Text("Scroll %.1f/%.1f %.1f/%.1f", ImGui::GetScrollX(), ImGui::GetScrollMaxX(), ImGui::GetScrollY(), ImGui::GetScrollMaxY());
            if (explicit_content_size)
            {
                ImGui::SameLine();
                ImGui::SetNextItemWidth(100);
                ImGui::DragFloat("##csx", &contents_size_x);
                ImVec2 p = ImGui::GetCursorScreenPos();
                ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x + 10, p.y + 10), IM_COL32_WHITE);
                ImGui::GetWindowDrawList()->AddRectFilled(ImVec2(p.x + contents_size_x - 10, p.y), ImVec2(p.x + contents_size_x, p.y + 10), IM_COL32_WHITE);
                ImGui::Dummy(ImVec2(0, 10));
            }
            ImGui::PopStyleVar(2);
            ImGui::Separator();
            if (show_button)
            {
                ImGui::Button("this is a 300-wide button", ImVec2(300, 0));
            }
            if (show_tree_nodes)
            {
                bool open = true;
                if (ImGui::TreeNode("this is a tree node"))
                {
                    if (ImGui::TreeNode("another one of those tree node..."))
                    {
                        ImGui::Text("Some tree contents");
                        ImGui::TreePop();
                    }
                    ImGui::TreePop();
                }
                ImGui::CollapsingHeader("CollapsingHeader", &open);
            }
            if (show_text_wrapped)
            {
                ImGui::TextWrapped("This text should automatically wrap on the edge of the work rectangle.");
            }
            if (show_columns)
            {
                ImGui::Text("Tables:");
                if (ImGui::BeginTable("table", 4, ImGuiTableFlags_Borders))
                {
                    for (int n = 0; n < 4; n++)
                    {
                        ImGui::TableNextColumn();
                        ImGui::Text("Width %.2f", ImGui::GetContentRegionAvail().x);
                    }
                    ImGui::EndTable();
                }
                ImGui::Text("Columns:");
                ImGui::Columns(4);
                for (int n = 0; n < 4; n++)
                {
                    ImGui::Text("Width %.2f", ImGui::GetColumnWidth());
                    ImGui::NextColumn();
                }
                ImGui::Columns(1);
            }
            if (show_tab_bar && ImGui::BeginTabBar("Hello"))
            {
                if (ImGui::BeginTabItem("OneOneOne")) { ImGui::EndTabItem(); }
                if (ImGui::BeginTabItem("TwoTwoTwo")) { ImGui::EndTabItem(); }
                if (ImGui::BeginTabItem("ThreeThreeThree")) { ImGui::EndTabItem(); }
                if (ImGui::BeginTabItem("FourFourFour")) { ImGui::EndTabItem(); }
                ImGui::EndTabBar();
            }
            if (show_child)
            {
                ImGui::BeginChild("child", ImVec2(0, 0), ImGuiChildFlags_Borders);
                ImGui::EndChild();
            }
            ImGui::End();
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Text Clipping");
    if (ImGui::TreeNode("Text Clipping"))
    {
        static ImVec2 size(100.0f, 100.0f);
        static ImVec2 offset(30.0f, 30.0f);
        ImGui::DragFloat2("size", (float*)&size, 0.5f, 1.0f, 200.0f, "%.0f");
        ImGui::TextWrapped("(Click and drag to scroll)");

        HelpMarker(
            "(Left) Using ImGui::PushClipRect():\n"
            "Will alter ImGui hit-testing logic + ImDrawList rendering.\n"
            "(use this if you want your clipping rectangle to affect interactions)\n\n"
            "(Center) Using ImDrawList::PushClipRect():\n"
            "Will alter ImDrawList rendering only.\n"
            "(use this as a shortcut if you are only using ImDrawList calls)\n\n"
            "(Right) Using ImDrawList::AddText() with a fine ClipRect:\n"
            "Will alter only this specific ImDrawList::AddText() rendering.\n"
            "This is often used internally to avoid altering the clipping rectangle and minimize draw calls.");

        for (int n = 0; n < 3; n++)
        {
            if (n > 0)
                ImGui::SameLine();

            ImGui::PushID(n);
            ImGui::InvisibleButton("##canvas", size);
            if (ImGui::IsItemActive() && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
            {
                offset.x += ImGui::GetIO().MouseDelta.x;
                offset.y += ImGui::GetIO().MouseDelta.y;
            }
            ImGui::PopID();
            if (!ImGui::IsItemVisible()) // Skip rendering as ImDrawList elements are not clipped.
                continue;

            const ImVec2 p0 = ImGui::GetItemRectMin();
            const ImVec2 p1 = ImGui::GetItemRectMax();
            const char* text_str = "Line 1 hello\nLine 2 clip me!";
            const ImVec2 text_pos = ImVec2(p0.x + offset.x, p0.y + offset.y);
            ImDrawList* draw_list = ImGui::GetWindowDrawList();
            switch (n)
            {
            case 0:
                ImGui::PushClipRect(p0, p1, true);
                draw_list->AddRectFilled(p0, p1, IM_COL32(90, 90, 120, 255));
                draw_list->AddText(text_pos, IM_COL32_WHITE, text_str);
                ImGui::PopClipRect();
                break;
            case 1:
                draw_list->PushClipRect(p0, p1, true);
                draw_list->AddRectFilled(p0, p1, IM_COL32(90, 90, 120, 255));
                draw_list->AddText(text_pos, IM_COL32_WHITE, text_str);
                draw_list->PopClipRect();
                break;
            case 2:
                ImVec4 clip_rect(p0.x, p0.y, p1.x, p1.y); // AddText() takes a ImVec4* here so let's convert.
                draw_list->AddRectFilled(p0, p1, IM_COL32(90, 90, 120, 255));
                draw_list->AddText(ImGui::GetFont(), ImGui::GetFontSize(), text_pos, IM_COL32_WHITE, text_str, NULL, 0.0f, &clip_rect);
                break;
            }
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Layout/Overlap Mode");
    if (ImGui::TreeNode("Overlap Mode"))
    {
        static bool enable_allow_overlap = true;

        HelpMarker(
            "Hit-testing is by default performed in item submission order, which generally is perceived as 'back-to-front'.\n\n"
            "By using SetNextItemAllowOverlap() you can notify that an item may be overlapped by another. "
            "Doing so alters the hovering logic: items using AllowOverlap mode requires an extra frame to accept hovered state.");
        ImGui::Checkbox("Enable AllowOverlap", &enable_allow_overlap);

        ImVec2 button1_pos = ImGui::GetCursorScreenPos();
        ImVec2 button2_pos = ImVec2(button1_pos.x + 50.0f, button1_pos.y + 50.0f);
        if (enable_allow_overlap)
            ImGui::SetNextItemAllowOverlap();
        ImGui::Button("Button 1", ImVec2(80, 80));
        ImGui::SetCursorScreenPos(button2_pos);
        ImGui::Button("Button 2", ImVec2(80, 80));

        // This is typically used with width-spanning items.
        // (note that Selectable() has a dedicated flag ImGuiSelectableFlags_AllowOverlap, which is a shortcut
        // for using SetNextItemAllowOverlap(). For demo purpose we use SetNextItemAllowOverlap() here.)
        if (enable_allow_overlap)
            ImGui::SetNextItemAllowOverlap();
        ImGui::Selectable("Some Selectable", false);
        ImGui::SameLine();
        ImGui::SmallButton("++");

        ImGui::TreePop();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowPopups()
//-----------------------------------------------------------------------------

static void DemoWindowPopups()
{
    IMGUI_DEMO_MARKER("Popups");
    if (!ImGui::CollapsingHeader("Popups & Modal windows"))
        return;

    // The properties of popups windows are:
    // - They block normal mouse hovering detection outside them. (*)
    // - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
    // - Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as
    //   we are used to with regular Begin() calls. User can manipulate the visibility state by calling OpenPopup().
    // (*) One can use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) to bypass it and detect hovering even
    //     when normally blocked by a popup.
    // Those three properties are connected. The library needs to hold their visibility state BECAUSE it can close
    // popups at any time.

    // Typical use for regular windows:
    //   bool my_tool_is_active = false; if (ImGui::Button("Open")) my_tool_is_active = true; [...] if (my_tool_is_active) Begin("My Tool", &my_tool_is_active) { [...] } End();
    // Typical use for popups:
    //   if (ImGui::Button("Open")) ImGui::OpenPopup("MyPopup"); if (ImGui::BeginPopup("MyPopup")) { [...] EndPopup(); }

    // With popups we have to go through a library call (here OpenPopup) to manipulate the visibility state.
    // This may be a bit confusing at first but it should quickly make sense. Follow on the examples below.

    IMGUI_DEMO_MARKER("Popups/Popups");
    if (ImGui::TreeNode("Popups"))
    {
        ImGui::TextWrapped(
            "When a popup is active, it inhibits interacting with windows that are behind the popup. "
            "Clicking outside the popup closes it.");

        static int selected_fish = -1;
        const char* names[] = { "Bream", "Haddock", "Mackerel", "Pollock", "Tilefish" };
        static bool toggles[] = { true, false, false, false, false };

        // Simple selection popup (if you want to show the current selection inside the Button itself,
        // you may want to build a string using the "###" operator to preserve a constant ID with a variable label)
        if (ImGui::Button("Select.."))
            ImGui::OpenPopup("my_select_popup");
        ImGui::SameLine();
        ImGui::TextUnformatted(selected_fish == -1 ? "<None>" : names[selected_fish]);
        if (ImGui::BeginPopup("my_select_popup"))
        {
            ImGui::SeparatorText("Aquarium");
            for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                if (ImGui::Selectable(names[i]))
                    selected_fish = i;
            ImGui::EndPopup();
        }

        // Showing a menu with toggles
        if (ImGui::Button("Toggle.."))
            ImGui::OpenPopup("my_toggle_popup");
        if (ImGui::BeginPopup("my_toggle_popup"))
        {
            for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                ImGui::MenuItem(names[i], "", &toggles[i]);
            if (ImGui::BeginMenu("Sub-menu"))
            {
                ImGui::MenuItem("Click me");
                ImGui::EndMenu();
            }

            ImGui::Separator();
            ImGui::Text("Tooltip here");
            ImGui::SetItemTooltip("I am a tooltip over a popup");

            if (ImGui::Button("Stacked Popup"))
                ImGui::OpenPopup("another popup");
            if (ImGui::BeginPopup("another popup"))
            {
                for (int i = 0; i < IM_ARRAYSIZE(names); i++)
                    ImGui::MenuItem(names[i], "", &toggles[i]);
                if (ImGui::BeginMenu("Sub-menu"))
                {
                    ImGui::MenuItem("Click me");
                    if (ImGui::Button("Stacked Popup"))
                        ImGui::OpenPopup("another popup");
                    if (ImGui::BeginPopup("another popup"))
                    {
                        ImGui::Text("I am the last one here.");
                        ImGui::EndPopup();
                    }
                    ImGui::EndMenu();
                }
                ImGui::EndPopup();
            }
            ImGui::EndPopup();
        }

        // Call the more complete ShowExampleMenuFile which we use in various places of this demo
        if (ImGui::Button("With a menu.."))
            ImGui::OpenPopup("my_file_popup");
        if (ImGui::BeginPopup("my_file_popup", ImGuiWindowFlags_MenuBar))
        {
            if (ImGui::BeginMenuBar())
            {
                if (ImGui::BeginMenu("File"))
                {
                    ShowExampleMenuFile();
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Edit"))
                {
                    ImGui::MenuItem("Dummy");
                    ImGui::EndMenu();
                }
                ImGui::EndMenuBar();
            }
            ImGui::Text("Hello from popup!");
            ImGui::Button("This is a dummy button..");
            ImGui::EndPopup();
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Popups/Context menus");
    if (ImGui::TreeNode("Context menus"))
    {
        HelpMarker("\"Context\" functions are simple helpers to associate a Popup to a given Item or Window identifier.");

        // BeginPopupContextItem() is a helper to provide common/simple popup behavior of essentially doing:
        //     if (id == 0)
        //         id = GetItemID(); // Use last item id
        //     if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
        //         OpenPopup(id);
        //     return BeginPopup(id);
        // For advanced uses you may want to replicate and customize this code.
        // See more details in BeginPopupContextItem().

        // Example 1
        // When used after an item that has an ID (e.g. Button), we can skip providing an ID to BeginPopupContextItem(),
        // and BeginPopupContextItem() will use the last item ID as the popup ID.
        {
            const char* names[5] = { "Label1", "Label2", "Label3", "Label4", "Label5" };
            static int selected = -1;
            for (int n = 0; n < 5; n++)
            {
                if (ImGui::Selectable(names[n], selected == n))
                    selected = n;
                if (ImGui::BeginPopupContextItem()) // <-- use last item id as popup id
                {
                    selected = n;
                    ImGui::Text("This a popup for \"%s\"!", names[n]);
                    if (ImGui::Button("Close"))
                        ImGui::CloseCurrentPopup();
                    ImGui::EndPopup();
                }
                ImGui::SetItemTooltip("Right-click to open popup");
            }
        }

        // Example 2
        // Popup on a Text() element which doesn't have an identifier: we need to provide an identifier to BeginPopupContextItem().
        // Using an explicit identifier is also convenient if you want to activate the popups from different locations.
        {
            HelpMarker("Text() elements don't have stable identifiers so we need to provide one.");
            static float value = 0.5f;
            ImGui::Text("Value = %.3f <-- (1) right-click this text", value);
            if (ImGui::BeginPopupContextItem("my popup"))
            {
                if (ImGui::Selectable("Set to zero")) value = 0.0f;
                if (ImGui::Selectable("Set to PI")) value = 3.1415f;
                ImGui::SetNextItemWidth(-FLT_MIN);
                ImGui::DragFloat("##Value", &value, 0.1f, 0.0f, 0.0f);
                ImGui::EndPopup();
            }

            // We can also use OpenPopupOnItemClick() to toggle the visibility of a given popup.
            // Here we make it that right-clicking this other text element opens the same popup as above.
            // The popup itself will be submitted by the code above.
            ImGui::Text("(2) Or right-click this text");
            ImGui::OpenPopupOnItemClick("my popup", ImGuiPopupFlags_MouseButtonRight);

            // Back to square one: manually open the same popup.
            if (ImGui::Button("(3) Or click this button"))
                ImGui::OpenPopup("my popup");
        }

        // Example 3
        // When using BeginPopupContextItem() with an implicit identifier (NULL == use last item ID),
        // we need to make sure your item identifier is stable.
        // In this example we showcase altering the item label while preserving its identifier, using the ### operator (see FAQ).
        {
            HelpMarker("Showcase using a popup ID linked to item ID, with the item having a changing label + stable ID using the ### operator.");
            static char name[32] = "Label1";
            char buf[64];
            sprintf(buf, "Button: %s###Button", name); // ### operator override ID ignoring the preceding label
            ImGui::Button(buf);
            if (ImGui::BeginPopupContextItem())
            {
                ImGui::Text("Edit name:");
                ImGui::InputText("##edit", name, IM_ARRAYSIZE(name));
                if (ImGui::Button("Close"))
                    ImGui::CloseCurrentPopup();
                ImGui::EndPopup();
            }
            ImGui::SameLine(); ImGui::Text("(<-- right-click here)");
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Popups/Modals");
    if (ImGui::TreeNode("Modals"))
    {
        ImGui::TextWrapped("Modal windows are like popups but the user cannot close them by clicking outside.");

        if (ImGui::Button("Delete.."))
            ImGui::OpenPopup("Delete?");

        // Always center this window when appearing
        ImVec2 center = ImGui::GetMainViewport()->GetCenter();
        ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

        if (ImGui::BeginPopupModal("Delete?", NULL, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::Text("All those beautiful files will be deleted.\nThis operation cannot be undone!");
            ImGui::Separator();

            //static int unused_i = 0;
            //ImGui::Combo("Combo", &unused_i, "Delete\0Delete harder\0");

            static bool dont_ask_me_next_time = false;
            ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
            ImGui::Checkbox("Don't ask me next time", &dont_ask_me_next_time);
            ImGui::PopStyleVar();

            if (ImGui::Button("OK", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
            ImGui::SetItemDefaultFocus();
            ImGui::SameLine();
            if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
            ImGui::EndPopup();
        }

        if (ImGui::Button("Stacked modals.."))
            ImGui::OpenPopup("Stacked 1");
        if (ImGui::BeginPopupModal("Stacked 1", NULL, ImGuiWindowFlags_MenuBar))
        {
            if (ImGui::BeginMenuBar())
            {
                if (ImGui::BeginMenu("File"))
                {
                    if (ImGui::MenuItem("Some menu item")) {}
                    ImGui::EndMenu();
                }
                ImGui::EndMenuBar();
            }
            ImGui::Text("Hello from Stacked The First\nUsing style.Colors[ImGuiCol_ModalWindowDimBg] behind it.");

            // Testing behavior of widgets stacking their own regular popups over the modal.
            static int item = 1;
            static float color[4] = { 0.4f, 0.7f, 0.0f, 0.5f };
            ImGui::Combo("Combo", &item, "aaaa\0bbbb\0cccc\0dddd\0eeee\0\0");
            ImGui::ColorEdit4("Color", color);

            if (ImGui::Button("Add another modal.."))
                ImGui::OpenPopup("Stacked 2");

            // Also demonstrate passing a bool* to BeginPopupModal(), this will create a regular close button which
            // will close the popup. Note that the visibility state of popups is owned by imgui, so the input value
            // of the bool actually doesn't matter here.
            bool unused_open = true;
            if (ImGui::BeginPopupModal("Stacked 2", &unused_open))
            {
                ImGui::Text("Hello from Stacked The Second!");
                ImGui::ColorEdit4("Color", color); // Allow opening another nested popup
                if (ImGui::Button("Close"))
                    ImGui::CloseCurrentPopup();
                ImGui::EndPopup();
            }

            if (ImGui::Button("Close"))
                ImGui::CloseCurrentPopup();
            ImGui::EndPopup();
        }

        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Popups/Menus inside a regular window");
    if (ImGui::TreeNode("Menus inside a regular window"))
    {
        ImGui::TextWrapped("Below we are testing adding menu items to a regular window. It's rather unusual but should work!");
        ImGui::Separator();

        ImGui::MenuItem("Menu item", "CTRL+M");
        if (ImGui::BeginMenu("Menu inside a regular window"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        ImGui::Separator();
        ImGui::TreePop();
    }
}

// Dummy data structure that we use for the Table demo.
// (pre-C++11 doesn't allow us to instantiate ImVector<MyItem> template if this structure is defined inside the demo function)
namespace
{
// We are passing our own identifier to TableSetupColumn() to facilitate identifying columns in the sorting code.
// This identifier will be passed down into ImGuiTableSortSpec::ColumnUserID.
// But it is possible to omit the user id parameter of TableSetupColumn() and just use the column index instead! (ImGuiTableSortSpec::ColumnIndex)
// If you don't use sorting, you will generally never care about giving column an ID!
enum MyItemColumnID
{
    MyItemColumnID_ID,
    MyItemColumnID_Name,
    MyItemColumnID_Action,
    MyItemColumnID_Quantity,
    MyItemColumnID_Description
};

struct MyItem
{
    int         ID;
    const char* Name;
    int         Quantity;

    // We have a problem which is affecting _only this demo_ and should not affect your code:
    // As we don't rely on std:: or other third-party library to compile dear imgui, we only have reliable access to qsort(),
    // however qsort doesn't allow passing user data to comparing function.
    // As a workaround, we are storing the sort specs in a static/global for the comparing function to access.
    // In your own use case you would probably pass the sort specs to your sorting/comparing functions directly and not use a global.
    // We could technically call ImGui::TableGetSortSpecs() in CompareWithSortSpecs(), but considering that this function is called
    // very often by the sorting algorithm it would be a little wasteful.
    static const ImGuiTableSortSpecs* s_current_sort_specs;

    static void SortWithSortSpecs(ImGuiTableSortSpecs* sort_specs, MyItem* items, int items_count)
    {
        s_current_sort_specs = sort_specs; // Store in variable accessible by the sort function.
        if (items_count > 1)
            qsort(items, (size_t)items_count, sizeof(items[0]), MyItem::CompareWithSortSpecs);
        s_current_sort_specs = NULL;
    }

    // Compare function to be used by qsort()
    static int IMGUI_CDECL CompareWithSortSpecs(const void* lhs, const void* rhs)
    {
        const MyItem* a = (const MyItem*)lhs;
        const MyItem* b = (const MyItem*)rhs;
        for (int n = 0; n < s_current_sort_specs->SpecsCount; n++)
        {
            // Here we identify columns using the ColumnUserID value that we ourselves passed to TableSetupColumn()
            // We could also choose to identify columns based on their index (sort_spec->ColumnIndex), which is simpler!
            const ImGuiTableColumnSortSpecs* sort_spec = &s_current_sort_specs->Specs[n];
            int delta = 0;
            switch (sort_spec->ColumnUserID)
            {
            case MyItemColumnID_ID:             delta = (a->ID - b->ID);                break;
            case MyItemColumnID_Name:           delta = (strcmp(a->Name, b->Name));     break;
            case MyItemColumnID_Quantity:       delta = (a->Quantity - b->Quantity);    break;
            case MyItemColumnID_Description:    delta = (strcmp(a->Name, b->Name));     break;
            default: IM_ASSERT(0); break;
            }
            if (delta > 0)
                return (sort_spec->SortDirection == ImGuiSortDirection_Ascending) ? +1 : -1;
            if (delta < 0)
                return (sort_spec->SortDirection == ImGuiSortDirection_Ascending) ? -1 : +1;
        }

        // qsort() is instable so always return a way to differentiate items.
        // Your own compare function may want to avoid fallback on implicit sort specs.
        // e.g. a Name compare if it wasn't already part of the sort specs.
        return (a->ID - b->ID);
    }
};
const ImGuiTableSortSpecs* MyItem::s_current_sort_specs = NULL;
}

// Make the UI compact because there are so many fields
static void PushStyleCompact()
{
    ImGuiStyle& style = ImGui::GetStyle();
    ImGui::PushStyleVarY(ImGuiStyleVar_FramePadding, (float)(int)(style.FramePadding.y * 0.60f));
    ImGui::PushStyleVarY(ImGuiStyleVar_ItemSpacing, (float)(int)(style.ItemSpacing.y * 0.60f));
}

static void PopStyleCompact()
{
    ImGui::PopStyleVar(2);
}

// Show a combo box with a choice of sizing policies
static void EditTableSizingFlags(ImGuiTableFlags* p_flags)
{
    struct EnumDesc { ImGuiTableFlags Value; const char* Name; const char* Tooltip; };
    static const EnumDesc policies[] =
    {
        { ImGuiTableFlags_None,               "Default",                            "Use default sizing policy:\n- ImGuiTableFlags_SizingFixedFit if ScrollX is on or if host window has ImGuiWindowFlags_AlwaysAutoResize.\n- ImGuiTableFlags_SizingStretchSame otherwise." },
        { ImGuiTableFlags_SizingFixedFit,     "ImGuiTableFlags_SizingFixedFit",     "Columns default to _WidthFixed (if resizable) or _WidthAuto (if not resizable), matching contents width." },
        { ImGuiTableFlags_SizingFixedSame,    "ImGuiTableFlags_SizingFixedSame",    "Columns are all the same width, matching the maximum contents width.\nImplicitly disable ImGuiTableFlags_Resizable and enable ImGuiTableFlags_NoKeepColumnsVisible." },
        { ImGuiTableFlags_SizingStretchProp,  "ImGuiTableFlags_SizingStretchProp",  "Columns default to _WidthStretch with weights proportional to their widths." },
        { ImGuiTableFlags_SizingStretchSame,  "ImGuiTableFlags_SizingStretchSame",  "Columns default to _WidthStretch with same weights." }
    };
    int idx;
    for (idx = 0; idx < IM_ARRAYSIZE(policies); idx++)
        if (policies[idx].Value == (*p_flags & ImGuiTableFlags_SizingMask_))
            break;
    const char* preview_text = (idx < IM_ARRAYSIZE(policies)) ? policies[idx].Name + (idx > 0 ? strlen("ImGuiTableFlags") : 0) : "";
    if (ImGui::BeginCombo("Sizing Policy", preview_text))
    {
        for (int n = 0; n < IM_ARRAYSIZE(policies); n++)
            if (ImGui::Selectable(policies[n].Name, idx == n))
                *p_flags = (*p_flags & ~ImGuiTableFlags_SizingMask_) | policies[n].Value;
        ImGui::EndCombo();
    }
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 50.0f);
        for (int m = 0; m < IM_ARRAYSIZE(policies); m++)
        {
            ImGui::Separator();
            ImGui::Text("%s:", policies[m].Name);
            ImGui::Separator();
            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetStyle().IndentSpacing * 0.5f);
            ImGui::TextUnformatted(policies[m].Tooltip);
        }
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

static void EditTableColumnsFlags(ImGuiTableColumnFlags* p_flags)
{
    ImGui::CheckboxFlags("_Disabled", p_flags, ImGuiTableColumnFlags_Disabled); ImGui::SameLine(); HelpMarker("Master disable flag (also hide from context menu)");
    ImGui::CheckboxFlags("_DefaultHide", p_flags, ImGuiTableColumnFlags_DefaultHide);
    ImGui::CheckboxFlags("_DefaultSort", p_flags, ImGuiTableColumnFlags_DefaultSort);
    if (ImGui::CheckboxFlags("_WidthStretch", p_flags, ImGuiTableColumnFlags_WidthStretch))
        *p_flags &= ~(ImGuiTableColumnFlags_WidthMask_ ^ ImGuiTableColumnFlags_WidthStretch);
    if (ImGui::CheckboxFlags("_WidthFixed", p_flags, ImGuiTableColumnFlags_WidthFixed))
        *p_flags &= ~(ImGuiTableColumnFlags_WidthMask_ ^ ImGuiTableColumnFlags_WidthFixed);
    ImGui::CheckboxFlags("_NoResize", p_flags, ImGuiTableColumnFlags_NoResize);
    ImGui::CheckboxFlags("_NoReorder", p_flags, ImGuiTableColumnFlags_NoReorder);
    ImGui::CheckboxFlags("_NoHide", p_flags, ImGuiTableColumnFlags_NoHide);
    ImGui::CheckboxFlags("_NoClip", p_flags, ImGuiTableColumnFlags_NoClip);
    ImGui::CheckboxFlags("_NoSort", p_flags, ImGuiTableColumnFlags_NoSort);
    ImGui::CheckboxFlags("_NoSortAscending", p_flags, ImGuiTableColumnFlags_NoSortAscending);
    ImGui::CheckboxFlags("_NoSortDescending", p_flags, ImGuiTableColumnFlags_NoSortDescending);
    ImGui::CheckboxFlags("_NoHeaderLabel", p_flags, ImGuiTableColumnFlags_NoHeaderLabel);
    ImGui::CheckboxFlags("_NoHeaderWidth", p_flags, ImGuiTableColumnFlags_NoHeaderWidth);
    ImGui::CheckboxFlags("_PreferSortAscending", p_flags, ImGuiTableColumnFlags_PreferSortAscending);
    ImGui::CheckboxFlags("_PreferSortDescending", p_flags, ImGuiTableColumnFlags_PreferSortDescending);
    ImGui::CheckboxFlags("_IndentEnable", p_flags, ImGuiTableColumnFlags_IndentEnable); ImGui::SameLine(); HelpMarker("Default for column 0");
    ImGui::CheckboxFlags("_IndentDisable", p_flags, ImGuiTableColumnFlags_IndentDisable); ImGui::SameLine(); HelpMarker("Default for column >0");
    ImGui::CheckboxFlags("_AngledHeader", p_flags, ImGuiTableColumnFlags_AngledHeader);
}

static void ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags)
{
    ImGui::CheckboxFlags("_IsEnabled", &flags, ImGuiTableColumnFlags_IsEnabled);
    ImGui::CheckboxFlags("_IsVisible", &flags, ImGuiTableColumnFlags_IsVisible);
    ImGui::CheckboxFlags("_IsSorted", &flags, ImGuiTableColumnFlags_IsSorted);
    ImGui::CheckboxFlags("_IsHovered", &flags, ImGuiTableColumnFlags_IsHovered);
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowTables()
//-----------------------------------------------------------------------------

static void DemoWindowTables()
{
    //ImGui::SetNextItemOpen(true, ImGuiCond_Once);
    IMGUI_DEMO_MARKER("Tables");
    if (!ImGui::CollapsingHeader("Tables & Columns"))
        return;

    // Using those as a base value to create width/height that are factor of the size of our font
    const float TEXT_BASE_WIDTH = ImGui::CalcTextSize("A").x;
    const float TEXT_BASE_HEIGHT = ImGui::GetTextLineHeightWithSpacing();

    ImGui::PushID("Tables");

    int open_action = -1;
    if (ImGui::Button("Expand all"))
        open_action = 1;
    ImGui::SameLine();
    if (ImGui::Button("Collapse all"))
        open_action = 0;
    ImGui::SameLine();

    // Options
    static bool disable_indent = false;
    ImGui::Checkbox("Disable tree indentation", &disable_indent);
    ImGui::SameLine();
    HelpMarker("Disable the indenting of tree nodes so demo tables can use the full window width.");
    ImGui::Separator();
    if (disable_indent)
        ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 0.0f);

    // About Styling of tables
    // Most settings are configured on a per-table basis via the flags passed to BeginTable() and TableSetupColumns APIs.
    // There are however a few settings that a shared and part of the ImGuiStyle structure:
    //   style.CellPadding                          // Padding within each cell
    //   style.Colors[ImGuiCol_TableHeaderBg]       // Table header background
    //   style.Colors[ImGuiCol_TableBorderStrong]   // Table outer and header borders
    //   style.Colors[ImGuiCol_TableBorderLight]    // Table inner borders
    //   style.Colors[ImGuiCol_TableRowBg]          // Table row background when ImGuiTableFlags_RowBg is enabled (even rows)
    //   style.Colors[ImGuiCol_TableRowBgAlt]       // Table row background when ImGuiTableFlags_RowBg is enabled (odds rows)

    // Demos
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Basic");
    if (ImGui::TreeNode("Basic"))
    {
        // Here we will showcase three different ways to output a table.
        // They are very simple variations of a same thing!

        // [Method 1] Using TableNextRow() to create a new row, and TableSetColumnIndex() to select the column.
        // In many situations, this is the most flexible and easy to use pattern.
        HelpMarker("Using TableNextRow() + calling TableSetColumnIndex() _before_ each cell, in a loop.");
        if (ImGui::BeginTable("table1", 3))
        {
            for (int row = 0; row < 4; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Row %d Column %d", row, column);
                }
            }
            ImGui::EndTable();
        }

        // [Method 2] Using TableNextColumn() called multiple times, instead of using a for loop + TableSetColumnIndex().
        // This is generally more convenient when you have code manually submitting the contents of each column.
        HelpMarker("Using TableNextRow() + calling TableNextColumn() _before_ each cell, manually.");
        if (ImGui::BeginTable("table2", 3))
        {
            for (int row = 0; row < 4; row++)
            {
                ImGui::TableNextRow();
                ImGui::TableNextColumn();
                ImGui::Text("Row %d", row);
                ImGui::TableNextColumn();
                ImGui::Text("Some contents");
                ImGui::TableNextColumn();
                ImGui::Text("123.456");
            }
            ImGui::EndTable();
        }

        // [Method 3] We call TableNextColumn() _before_ each cell. We never call TableNextRow(),
        // as TableNextColumn() will automatically wrap around and create new rows as needed.
        // This is generally more convenient when your cells all contains the same type of data.
        HelpMarker(
            "Only using TableNextColumn(), which tends to be convenient for tables where every cell contains "
            "the same type of contents.\n This is also more similar to the old NextColumn() function of the "
            "Columns API, and provided to facilitate the Columns->Tables API transition.");
        if (ImGui::BeginTable("table3", 3))
        {
            for (int item = 0; item < 14; item++)
            {
                ImGui::TableNextColumn();
                ImGui::Text("Item %d", item);
            }
            ImGui::EndTable();
        }

        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Borders, background");
    if (ImGui::TreeNode("Borders, background"))
    {
        // Expose a few Borders related flags interactively
        enum ContentsType { CT_Text, CT_FillButton };
        static ImGuiTableFlags flags = ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg;
        static bool display_headers = false;
        static int contents_type = CT_Text;

        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_RowBg", &flags, ImGuiTableFlags_RowBg);
        ImGui::CheckboxFlags("ImGuiTableFlags_Borders", &flags, ImGuiTableFlags_Borders);
        ImGui::SameLine(); HelpMarker("ImGuiTableFlags_Borders\n = ImGuiTableFlags_BordersInnerV\n | ImGuiTableFlags_BordersOuterV\n | ImGuiTableFlags_BordersInnerH\n | ImGuiTableFlags_BordersOuterH");
        ImGui::Indent();

        ImGui::CheckboxFlags("ImGuiTableFlags_BordersH", &flags, ImGuiTableFlags_BordersH);
        ImGui::Indent();
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuterH", &flags, ImGuiTableFlags_BordersOuterH);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersInnerH", &flags, ImGuiTableFlags_BordersInnerH);
        ImGui::Unindent();

        ImGui::CheckboxFlags("ImGuiTableFlags_BordersV", &flags, ImGuiTableFlags_BordersV);
        ImGui::Indent();
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuterV", &flags, ImGuiTableFlags_BordersOuterV);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersInnerV", &flags, ImGuiTableFlags_BordersInnerV);
        ImGui::Unindent();

        ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuter", &flags, ImGuiTableFlags_BordersOuter);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersInner", &flags, ImGuiTableFlags_BordersInner);
        ImGui::Unindent();

        ImGui::AlignTextToFramePadding(); ImGui::Text("Cell contents:");
        ImGui::SameLine(); ImGui::RadioButton("Text", &contents_type, CT_Text);
        ImGui::SameLine(); ImGui::RadioButton("FillButton", &contents_type, CT_FillButton);
        ImGui::Checkbox("Display headers", &display_headers);
        ImGui::CheckboxFlags("ImGuiTableFlags_NoBordersInBody", &flags, ImGuiTableFlags_NoBordersInBody); ImGui::SameLine(); HelpMarker("Disable vertical borders in columns Body (borders will always appear in Headers)");
        PopStyleCompact();

        if (ImGui::BeginTable("table1", 3, flags))
        {
            // Display headers so we can inspect their interaction with borders
            // (Headers are not the main purpose of this section of the demo, so we are not elaborating on them now. See other sections for details)
            if (display_headers)
            {
                ImGui::TableSetupColumn("One");
                ImGui::TableSetupColumn("Two");
                ImGui::TableSetupColumn("Three");
                ImGui::TableHeadersRow();
            }

            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    char buf[32];
                    sprintf(buf, "Hello %d,%d", column, row);
                    if (contents_type == CT_Text)
                        ImGui::TextUnformatted(buf);
                    else if (contents_type == CT_FillButton)
                        ImGui::Button(buf, ImVec2(-FLT_MIN, 0.0f));
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Resizable, stretch");
    if (ImGui::TreeNode("Resizable, stretch"))
    {
        // By default, if we don't enable ScrollX the sizing policy for each column is "Stretch"
        // All columns maintain a sizing weight, and they will occupy all available width.
        static ImGuiTableFlags flags = ImGuiTableFlags_SizingStretchSame | ImGuiTableFlags_Resizable | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_ContextMenuInBody;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersV", &flags, ImGuiTableFlags_BordersV);
        ImGui::SameLine(); HelpMarker(
            "Using the _Resizable flag automatically enables the _BordersInnerV flag as well, "
            "this is why the resize borders are still showing when unchecking this.");
        PopStyleCompact();

        if (ImGui::BeginTable("table1", 3, flags))
        {
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Hello %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Resizable, fixed");
    if (ImGui::TreeNode("Resizable, fixed"))
    {
        // Here we use ImGuiTableFlags_SizingFixedFit (even though _ScrollX is not set)
        // So columns will adopt the "Fixed" policy and will maintain a fixed width regardless of the whole available width (unless table is small)
        // If there is not enough available width to fit all columns, they will however be resized down.
        // FIXME-TABLE: Providing a stretch-on-init would make sense especially for tables which don't have saved settings
        HelpMarker(
            "Using _Resizable + _SizingFixedFit flags.\n"
            "Fixed-width columns generally makes more sense if you want to use horizontal scrolling.\n\n"
            "Double-click a column border to auto-fit the column to its contents.");
        PushStyleCompact();
        static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Resizable | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_ContextMenuInBody;
        ImGui::CheckboxFlags("ImGuiTableFlags_NoHostExtendX", &flags, ImGuiTableFlags_NoHostExtendX);
        PopStyleCompact();

        if (ImGui::BeginTable("table1", 3, flags))
        {
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Hello %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Resizable, mixed");
    if (ImGui::TreeNode("Resizable, mixed"))
    {
        HelpMarker(
            "Using TableSetupColumn() to alter resizing policy on a per-column basis.\n\n"
            "When combining Fixed and Stretch columns, generally you only want one, maybe two trailing columns to use _WidthStretch.");
        static ImGuiTableFlags flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;

        if (ImGui::BeginTable("table1", 3, flags))
        {
            ImGui::TableSetupColumn("AAA", ImGuiTableColumnFlags_WidthFixed);
            ImGui::TableSetupColumn("BBB", ImGuiTableColumnFlags_WidthFixed);
            ImGui::TableSetupColumn("CCC", ImGuiTableColumnFlags_WidthStretch);
            ImGui::TableHeadersRow();
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("%s %d,%d", (column == 2) ? "Stretch" : "Fixed", column, row);
                }
            }
            ImGui::EndTable();
        }
        if (ImGui::BeginTable("table2", 6, flags))
        {
            ImGui::TableSetupColumn("AAA", ImGuiTableColumnFlags_WidthFixed);
            ImGui::TableSetupColumn("BBB", ImGuiTableColumnFlags_WidthFixed);
            ImGui::TableSetupColumn("CCC", ImGuiTableColumnFlags_WidthFixed | ImGuiTableColumnFlags_DefaultHide);
            ImGui::TableSetupColumn("DDD", ImGuiTableColumnFlags_WidthStretch);
            ImGui::TableSetupColumn("EEE", ImGuiTableColumnFlags_WidthStretch);
            ImGui::TableSetupColumn("FFF", ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_DefaultHide);
            ImGui::TableHeadersRow();
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 6; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("%s %d,%d", (column >= 3) ? "Stretch" : "Fixed", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Reorderable, hideable, with headers");
    if (ImGui::TreeNode("Reorderable, hideable, with headers"))
    {
        HelpMarker(
            "Click and drag column headers to reorder columns.\n\n"
            "Right-click on a header to open a context menu.");
        static ImGuiTableFlags flags = ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_Reorderable", &flags, ImGuiTableFlags_Reorderable);
        ImGui::CheckboxFlags("ImGuiTableFlags_Hideable", &flags, ImGuiTableFlags_Hideable);
        ImGui::CheckboxFlags("ImGuiTableFlags_NoBordersInBody", &flags, ImGuiTableFlags_NoBordersInBody);
        ImGui::CheckboxFlags("ImGuiTableFlags_NoBordersInBodyUntilResize", &flags, ImGuiTableFlags_NoBordersInBodyUntilResize); ImGui::SameLine(); HelpMarker("Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers)");
        ImGui::CheckboxFlags("ImGuiTableFlags_HighlightHoveredColumn", &flags, ImGuiTableFlags_HighlightHoveredColumn);
        PopStyleCompact();

        if (ImGui::BeginTable("table1", 3, flags))
        {
            // Submit columns name with TableSetupColumn() and call TableHeadersRow() to create a row with a header in each column.
            // (Later we will show how TableSetupColumn() has other uses, optional flags, sizing weight etc.)
            ImGui::TableSetupColumn("One");
            ImGui::TableSetupColumn("Two");
            ImGui::TableSetupColumn("Three");
            ImGui::TableHeadersRow();
            for (int row = 0; row < 6; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Hello %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }

        // Use outer_size.x == 0.0f instead of default to make the table as tight as possible
        // (only valid when no scrolling and no stretch column)
        if (ImGui::BeginTable("table2", 3, flags | ImGuiTableFlags_SizingFixedFit, ImVec2(0.0f, 0.0f)))
        {
            ImGui::TableSetupColumn("One");
            ImGui::TableSetupColumn("Two");
            ImGui::TableSetupColumn("Three");
            ImGui::TableHeadersRow();
            for (int row = 0; row < 6; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Fixed %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Padding");
    if (ImGui::TreeNode("Padding"))
    {
        // First example: showcase use of padding flags and effect of BorderOuterV/BorderInnerV on X padding.
        // We don't expose BorderOuterH/BorderInnerH here because they have no effect on X padding.
        HelpMarker(
            "We often want outer padding activated when any using features which makes the edges of a column visible:\n"
            "e.g.:\n"
            "- BorderOuterV\n"
            "- any form of row selection\n"
            "Because of this, activating BorderOuterV sets the default to PadOuterX. "
            "Using PadOuterX or NoPadOuterX you can override the default.\n\n"
            "Actual padding values are using style.CellPadding.\n\n"
            "In this demo we don't show horizontal borders to emphasize how they don't affect default horizontal padding.");

        static ImGuiTableFlags flags1 = ImGuiTableFlags_BordersV;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_PadOuterX", &flags1, ImGuiTableFlags_PadOuterX);
        ImGui::SameLine(); HelpMarker("Enable outer-most padding (default if ImGuiTableFlags_BordersOuterV is set)");
        ImGui::CheckboxFlags("ImGuiTableFlags_NoPadOuterX", &flags1, ImGuiTableFlags_NoPadOuterX);
        ImGui::SameLine(); HelpMarker("Disable outer-most padding (default if ImGuiTableFlags_BordersOuterV is not set)");
        ImGui::CheckboxFlags("ImGuiTableFlags_NoPadInnerX", &flags1, ImGuiTableFlags_NoPadInnerX);
        ImGui::SameLine(); HelpMarker("Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off)");
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuterV", &flags1, ImGuiTableFlags_BordersOuterV);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersInnerV", &flags1, ImGuiTableFlags_BordersInnerV);
        static bool show_headers = false;
        ImGui::Checkbox("show_headers", &show_headers);
        PopStyleCompact();

        if (ImGui::BeginTable("table_padding", 3, flags1))
        {
            if (show_headers)
            {
                ImGui::TableSetupColumn("One");
                ImGui::TableSetupColumn("Two");
                ImGui::TableSetupColumn("Three");
                ImGui::TableHeadersRow();
            }

            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    if (row == 0)
                    {
                        ImGui::Text("Avail %.2f", ImGui::GetContentRegionAvail().x);
                    }
                    else
                    {
                        char buf[32];
                        sprintf(buf, "Hello %d,%d", column, row);
                        ImGui::Button(buf, ImVec2(-FLT_MIN, 0.0f));
                    }
                    //if (ImGui::TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered)
                    //    ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, IM_COL32(0, 100, 0, 255));
                }
            }
            ImGui::EndTable();
        }

        // Second example: set style.CellPadding to (0.0) or a custom value.
        // FIXME-TABLE: Vertical border effectively not displayed the same way as horizontal one...
        HelpMarker("Setting style.CellPadding to (0,0) or a custom value.");
        static ImGuiTableFlags flags2 = ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg;
        static ImVec2 cell_padding(0.0f, 0.0f);
        static bool show_widget_frame_bg = true;

        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Borders", &flags2, ImGuiTableFlags_Borders);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersH", &flags2, ImGuiTableFlags_BordersH);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersV", &flags2, ImGuiTableFlags_BordersV);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersInner", &flags2, ImGuiTableFlags_BordersInner);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuter", &flags2, ImGuiTableFlags_BordersOuter);
        ImGui::CheckboxFlags("ImGuiTableFlags_RowBg", &flags2, ImGuiTableFlags_RowBg);
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags2, ImGuiTableFlags_Resizable);
        ImGui::Checkbox("show_widget_frame_bg", &show_widget_frame_bg);
        ImGui::SliderFloat2("CellPadding", &cell_padding.x, 0.0f, 10.0f, "%.0f");
        PopStyleCompact();

        ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, cell_padding);
        if (ImGui::BeginTable("table_padding_2", 3, flags2))
        {
            static char text_bufs[3 * 5][16]; // Mini text storage for 3x5 cells
            static bool init = true;
            if (!show_widget_frame_bg)
                ImGui::PushStyleColor(ImGuiCol_FrameBg, 0);
            for (int cell = 0; cell < 3 * 5; cell++)
            {
                ImGui::TableNextColumn();
                if (init)
                    strcpy(text_bufs[cell], "edit me");
                ImGui::SetNextItemWidth(-FLT_MIN);
                ImGui::PushID(cell);
                ImGui::InputText("##cell", text_bufs[cell], IM_ARRAYSIZE(text_bufs[cell]));
                ImGui::PopID();
            }
            if (!show_widget_frame_bg)
                ImGui::PopStyleColor();
            init = false;
            ImGui::EndTable();
        }
        ImGui::PopStyleVar();

        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Explicit widths");
    if (ImGui::TreeNode("Sizing policies"))
    {
        static ImGuiTableFlags flags1 = ImGuiTableFlags_BordersV | ImGuiTableFlags_BordersOuterH | ImGuiTableFlags_RowBg | ImGuiTableFlags_ContextMenuInBody;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags1, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_NoHostExtendX", &flags1, ImGuiTableFlags_NoHostExtendX);
        PopStyleCompact();

        static ImGuiTableFlags sizing_policy_flags[4] = { ImGuiTableFlags_SizingFixedFit, ImGuiTableFlags_SizingFixedSame, ImGuiTableFlags_SizingStretchProp, ImGuiTableFlags_SizingStretchSame };
        for (int table_n = 0; table_n < 4; table_n++)
        {
            ImGui::PushID(table_n);
            ImGui::SetNextItemWidth(TEXT_BASE_WIDTH * 30);
            EditTableSizingFlags(&sizing_policy_flags[table_n]);

            // To make it easier to understand the different sizing policy,
            // For each policy: we display one table where the columns have equal contents width,
            // and one where the columns have different contents width.
            if (ImGui::BeginTable("table1", 3, sizing_policy_flags[table_n] | flags1))
            {
                for (int row = 0; row < 3; row++)
                {
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn(); ImGui::Text("Oh dear");
                    ImGui::TableNextColumn(); ImGui::Text("Oh dear");
                    ImGui::TableNextColumn(); ImGui::Text("Oh dear");
                }
                ImGui::EndTable();
            }
            if (ImGui::BeginTable("table2", 3, sizing_policy_flags[table_n] | flags1))
            {
                for (int row = 0; row < 3; row++)
                {
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn(); ImGui::Text("AAAA");
                    ImGui::TableNextColumn(); ImGui::Text("BBBBBBBB");
                    ImGui::TableNextColumn(); ImGui::Text("CCCCCCCCCCCC");
                }
                ImGui::EndTable();
            }
            ImGui::PopID();
        }

        ImGui::Spacing();
        ImGui::TextUnformatted("Advanced");
        ImGui::SameLine();
        HelpMarker(
            "This section allows you to interact and see the effect of various sizing policies "
            "depending on whether Scroll is enabled and the contents of your columns.");

        enum ContentsType { CT_ShowWidth, CT_ShortText, CT_LongText, CT_Button, CT_FillButton, CT_InputText };
        static ImGuiTableFlags flags = ImGuiTableFlags_ScrollY | ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable;
        static int contents_type = CT_ShowWidth;
        static int column_count = 3;

        PushStyleCompact();
        ImGui::PushID("Advanced");
        ImGui::PushItemWidth(TEXT_BASE_WIDTH * 30);
        EditTableSizingFlags(&flags);
        ImGui::Combo("Contents", &contents_type, "Show width\0Short Text\0Long Text\0Button\0Fill Button\0InputText\0");
        if (contents_type == CT_FillButton)
        {
            ImGui::SameLine();
            HelpMarker(
                "Be mindful that using right-alignment (e.g. size.x = -FLT_MIN) creates a feedback loop "
                "where contents width can feed into auto-column width can feed into contents width.");
        }
        ImGui::DragInt("Columns", &column_count, 0.1f, 1, 64, "%d", ImGuiSliderFlags_AlwaysClamp);
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_PreciseWidths", &flags, ImGuiTableFlags_PreciseWidths);
        ImGui::SameLine(); HelpMarker("Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.");
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollX", &flags, ImGuiTableFlags_ScrollX);
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollY", &flags, ImGuiTableFlags_ScrollY);
        ImGui::CheckboxFlags("ImGuiTableFlags_NoClip", &flags, ImGuiTableFlags_NoClip);
        ImGui::PopItemWidth();
        ImGui::PopID();
        PopStyleCompact();

        if (ImGui::BeginTable("table2", column_count, flags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 7)))
        {
            for (int cell = 0; cell < 10 * column_count; cell++)
            {
                ImGui::TableNextColumn();
                int column = ImGui::TableGetColumnIndex();
                int row = ImGui::TableGetRowIndex();

                ImGui::PushID(cell);
                char label[32];
                static char text_buf[32] = "";
                sprintf(label, "Hello %d,%d", column, row);
                switch (contents_type)
                {
                case CT_ShortText:  ImGui::TextUnformatted(label); break;
                case CT_LongText:   ImGui::Text("Some %s text %d,%d\nOver two lines..", column == 0 ? "long" : "longeeer", column, row); break;
                case CT_ShowWidth:  ImGui::Text("W: %.1f", ImGui::GetContentRegionAvail().x); break;
                case CT_Button:     ImGui::Button(label); break;
                case CT_FillButton: ImGui::Button(label, ImVec2(-FLT_MIN, 0.0f)); break;
                case CT_InputText:  ImGui::SetNextItemWidth(-FLT_MIN); ImGui::InputText("##", text_buf, IM_ARRAYSIZE(text_buf)); break;
                }
                ImGui::PopID();
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Vertical scrolling, with clipping");
    if (ImGui::TreeNode("Vertical scrolling, with clipping"))
    {
        HelpMarker(
            "Here we activate ScrollY, which will create a child window container to allow hosting scrollable contents.\n\n"
            "We also demonstrate using ImGuiListClipper to virtualize the submission of many items.");
        static ImGuiTableFlags flags = ImGuiTableFlags_ScrollY | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;

        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollY", &flags, ImGuiTableFlags_ScrollY);
        PopStyleCompact();

        // When using ScrollX or ScrollY we need to specify a size for our table container!
        // Otherwise by default the table will fit all available space, like a BeginChild() call.
        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 8);
        if (ImGui::BeginTable("table_scrolly", 3, flags, outer_size))
        {
            ImGui::TableSetupScrollFreeze(0, 1); // Make top row always visible
            ImGui::TableSetupColumn("One", ImGuiTableColumnFlags_None);
            ImGui::TableSetupColumn("Two", ImGuiTableColumnFlags_None);
            ImGui::TableSetupColumn("Three", ImGuiTableColumnFlags_None);
            ImGui::TableHeadersRow();

            // Demonstrate using clipper for large vertical lists
            ImGuiListClipper clipper;
            clipper.Begin(1000);
            while (clipper.Step())
            {
                for (int row = clipper.DisplayStart; row < clipper.DisplayEnd; row++)
                {
                    ImGui::TableNextRow();
                    for (int column = 0; column < 3; column++)
                    {
                        ImGui::TableSetColumnIndex(column);
                        ImGui::Text("Hello %d,%d", column, row);
                    }
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Horizontal scrolling");
    if (ImGui::TreeNode("Horizontal scrolling"))
    {
        HelpMarker(
            "When ScrollX is enabled, the default sizing policy becomes ImGuiTableFlags_SizingFixedFit, "
            "as automatically stretching columns doesn't make much sense with horizontal scrolling.\n\n"
            "Also note that as of the current version, you will almost always want to enable ScrollY along with ScrollX, "
            "because the container window won't automatically extend vertically to fix contents "
            "(this may be improved in future versions).");
        static ImGuiTableFlags flags = ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable;
        static int freeze_cols = 1;
        static int freeze_rows = 1;

        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollX", &flags, ImGuiTableFlags_ScrollX);
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollY", &flags, ImGuiTableFlags_ScrollY);
        ImGui::SetNextItemWidth(ImGui::GetFrameHeight());
        ImGui::DragInt("freeze_cols", &freeze_cols, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);
        ImGui::SetNextItemWidth(ImGui::GetFrameHeight());
        ImGui::DragInt("freeze_rows", &freeze_rows, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);
        PopStyleCompact();

        // When using ScrollX or ScrollY we need to specify a size for our table container!
        // Otherwise by default the table will fit all available space, like a BeginChild() call.
        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 8);
        if (ImGui::BeginTable("table_scrollx", 7, flags, outer_size))
        {
            ImGui::TableSetupScrollFreeze(freeze_cols, freeze_rows);
            ImGui::TableSetupColumn("Line #", ImGuiTableColumnFlags_NoHide); // Make the first column not hideable to match our use of TableSetupScrollFreeze()
            ImGui::TableSetupColumn("One");
            ImGui::TableSetupColumn("Two");
            ImGui::TableSetupColumn("Three");
            ImGui::TableSetupColumn("Four");
            ImGui::TableSetupColumn("Five");
            ImGui::TableSetupColumn("Six");
            ImGui::TableHeadersRow();
            for (int row = 0; row < 20; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 7; column++)
                {
                    // Both TableNextColumn() and TableSetColumnIndex() return true when a column is visible or performing width measurement.
                    // Because here we know that:
                    // - A) all our columns are contributing the same to row height
                    // - B) column 0 is always visible,
                    // We only always submit this one column and can skip others.
                    // More advanced per-column clipping behaviors may benefit from polling the status flags via TableGetColumnFlags().
                    if (!ImGui::TableSetColumnIndex(column) && column > 0)
                        continue;
                    if (column == 0)
                        ImGui::Text("Line %d", row);
                    else
                        ImGui::Text("Hello world %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }

        ImGui::Spacing();
        ImGui::TextUnformatted("Stretch + ScrollX");
        ImGui::SameLine();
        HelpMarker(
            "Showcase using Stretch columns + ScrollX together: "
            "this is rather unusual and only makes sense when specifying an 'inner_width' for the table!\n"
            "Without an explicit value, inner_width is == outer_size.x and therefore using Stretch columns "
            "along with ScrollX doesn't make sense.");
        static ImGuiTableFlags flags2 = ImGuiTableFlags_SizingStretchSame | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_RowBg | ImGuiTableFlags_ContextMenuInBody;
        static float inner_width = 1000.0f;
        PushStyleCompact();
        ImGui::PushID("flags3");
        ImGui::PushItemWidth(TEXT_BASE_WIDTH * 30);
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollX", &flags2, ImGuiTableFlags_ScrollX);
        ImGui::DragFloat("inner_width", &inner_width, 1.0f, 0.0f, FLT_MAX, "%.1f");
        ImGui::PopItemWidth();
        ImGui::PopID();
        PopStyleCompact();
        if (ImGui::BeginTable("table2", 7, flags2, outer_size, inner_width))
        {
            for (int cell = 0; cell < 20 * 7; cell++)
            {
                ImGui::TableNextColumn();
                ImGui::Text("Hello world %d,%d", ImGui::TableGetColumnIndex(), ImGui::TableGetRowIndex());
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Columns flags");
    if (ImGui::TreeNode("Columns flags"))
    {
        // Create a first table just to show all the options/flags we want to make visible in our example!
        const int column_count = 3;
        const char* column_names[column_count] = { "One", "Two", "Three" };
        static ImGuiTableColumnFlags column_flags[column_count] = { ImGuiTableColumnFlags_DefaultSort, ImGuiTableColumnFlags_None, ImGuiTableColumnFlags_DefaultHide };
        static ImGuiTableColumnFlags column_flags_out[column_count] = { 0, 0, 0 }; // Output from TableGetColumnFlags()

        if (ImGui::BeginTable("table_columns_flags_checkboxes", column_count, ImGuiTableFlags_None))
        {
            PushStyleCompact();
            for (int column = 0; column < column_count; column++)
            {
                ImGui::TableNextColumn();
                ImGui::PushID(column);
                ImGui::AlignTextToFramePadding(); // FIXME-TABLE: Workaround for wrong text baseline propagation across columns
                ImGui::Text("'%s'", column_names[column]);
                ImGui::Spacing();
                ImGui::Text("Input flags:");
                EditTableColumnsFlags(&column_flags[column]);
                ImGui::Spacing();
                ImGui::Text("Output flags:");
                ImGui::BeginDisabled();
                ShowTableColumnsStatusFlags(column_flags_out[column]);
                ImGui::EndDisabled();
                ImGui::PopID();
            }
            PopStyleCompact();
            ImGui::EndTable();
        }

        // Create the real table we care about for the example!
        // We use a scrolling table to be able to showcase the difference between the _IsEnabled and _IsVisible flags above,
        // otherwise in a non-scrolling table columns are always visible (unless using ImGuiTableFlags_NoKeepColumnsVisible
        // + resizing the parent window down).
        const ImGuiTableFlags flags
            = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY
            | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV
            | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Sortable;
        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 9);
        if (ImGui::BeginTable("table_columns_flags", column_count, flags, outer_size))
        {
            bool has_angled_header = false;
            for (int column = 0; column < column_count; column++)
            {
                has_angled_header |= (column_flags[column] & ImGuiTableColumnFlags_AngledHeader) != 0;
                ImGui::TableSetupColumn(column_names[column], column_flags[column]);
            }
            if (has_angled_header)
                ImGui::TableAngledHeadersRow();
            ImGui::TableHeadersRow();
            for (int column = 0; column < column_count; column++)
                column_flags_out[column] = ImGui::TableGetColumnFlags(column);
            float indent_step = (float)((int)TEXT_BASE_WIDTH / 2);
            for (int row = 0; row < 8; row++)
            {
                // Add some indentation to demonstrate usage of per-column IndentEnable/IndentDisable flags.
                ImGui::Indent(indent_step);
                ImGui::TableNextRow();
                for (int column = 0; column < column_count; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("%s %s", (column == 0) ? "Indented" : "Hello", ImGui::TableGetColumnName(column));
                }
            }
            ImGui::Unindent(indent_step * 8.0f);

            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Columns widths");
    if (ImGui::TreeNode("Columns widths"))
    {
        HelpMarker("Using TableSetupColumn() to setup default width.");

        static ImGuiTableFlags flags1 = ImGuiTableFlags_Borders | ImGuiTableFlags_NoBordersInBodyUntilResize;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags1, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_NoBordersInBodyUntilResize", &flags1, ImGuiTableFlags_NoBordersInBodyUntilResize);
        PopStyleCompact();
        if (ImGui::BeginTable("table1", 3, flags1))
        {
            // We could also set ImGuiTableFlags_SizingFixedFit on the table and all columns will default to ImGuiTableColumnFlags_WidthFixed.
            ImGui::TableSetupColumn("one", ImGuiTableColumnFlags_WidthFixed, 100.0f); // Default to 100.0f
            ImGui::TableSetupColumn("two", ImGuiTableColumnFlags_WidthFixed, 200.0f); // Default to 200.0f
            ImGui::TableSetupColumn("three", ImGuiTableColumnFlags_WidthFixed);       // Default to auto
            ImGui::TableHeadersRow();
            for (int row = 0; row < 4; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    if (row == 0)
                        ImGui::Text("(w: %5.1f)", ImGui::GetContentRegionAvail().x);
                    else
                        ImGui::Text("Hello %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }

        HelpMarker(
            "Using TableSetupColumn() to setup explicit width.\n\nUnless _NoKeepColumnsVisible is set, "
            "fixed columns with set width may still be shrunk down if there's not enough space in the host.");

        static ImGuiTableFlags flags2 = ImGuiTableFlags_None;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_NoKeepColumnsVisible", &flags2, ImGuiTableFlags_NoKeepColumnsVisible);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersInnerV", &flags2, ImGuiTableFlags_BordersInnerV);
        ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuterV", &flags2, ImGuiTableFlags_BordersOuterV);
        PopStyleCompact();
        if (ImGui::BeginTable("table2", 4, flags2))
        {
            // We could also set ImGuiTableFlags_SizingFixedFit on the table and then all columns
            // will default to ImGuiTableColumnFlags_WidthFixed.
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed, 100.0f);
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 15.0f);
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 30.0f);
            ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 15.0f);
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 4; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    if (row == 0)
                        ImGui::Text("(w: %5.1f)", ImGui::GetContentRegionAvail().x);
                    else
                        ImGui::Text("Hello %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Nested tables");
    if (ImGui::TreeNode("Nested tables"))
    {
        HelpMarker("This demonstrates embedding a table into another table cell.");

        if (ImGui::BeginTable("table_nested1", 2, ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
        {
            ImGui::TableSetupColumn("A0");
            ImGui::TableSetupColumn("A1");
            ImGui::TableHeadersRow();

            ImGui::TableNextColumn();
            ImGui::Text("A0 Row 0");
            {
                float rows_height = TEXT_BASE_HEIGHT * 2;
                if (ImGui::BeginTable("table_nested2", 2, ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
                {
                    ImGui::TableSetupColumn("B0");
                    ImGui::TableSetupColumn("B1");
                    ImGui::TableHeadersRow();

                    ImGui::TableNextRow(ImGuiTableRowFlags_None, rows_height);
                    ImGui::TableNextColumn();
                    ImGui::Text("B0 Row 0");
                    ImGui::TableNextColumn();
                    ImGui::Text("B1 Row 0");
                    ImGui::TableNextRow(ImGuiTableRowFlags_None, rows_height);
                    ImGui::TableNextColumn();
                    ImGui::Text("B0 Row 1");
                    ImGui::TableNextColumn();
                    ImGui::Text("B1 Row 1");

                    ImGui::EndTable();
                }
            }
            ImGui::TableNextColumn(); ImGui::Text("A1 Row 0");
            ImGui::TableNextColumn(); ImGui::Text("A0 Row 1");
            ImGui::TableNextColumn(); ImGui::Text("A1 Row 1");
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Row height");
    if (ImGui::TreeNode("Row height"))
    {
        HelpMarker(
            "You can pass a 'min_row_height' to TableNextRow().\n\nRows are padded with 'style.CellPadding.y' on top and bottom, "
            "so effectively the minimum row height will always be >= 'style.CellPadding.y * 2.0f'.\n\n"
            "We cannot honor a _maximum_ row height as that would require a unique clipping rectangle per row.");
        if (ImGui::BeginTable("table_row_height", 1, ImGuiTableFlags_Borders))
        {
            for (int row = 0; row < 8; row++)
            {
                float min_row_height = (float)(int)(TEXT_BASE_HEIGHT * 0.30f * row);
                ImGui::TableNextRow(ImGuiTableRowFlags_None, min_row_height);
                ImGui::TableNextColumn();
                ImGui::Text("min_row_height = %.2f", min_row_height);
            }
            ImGui::EndTable();
        }

        HelpMarker(
            "Showcase using SameLine(0,0) to share Current Line Height between cells.\n\n"
            "Please note that Tables Row Height is not the same thing as Current Line Height, "
            "as a table cell may contains multiple lines.");
        if (ImGui::BeginTable("table_share_lineheight", 2, ImGuiTableFlags_Borders))
        {
            ImGui::TableNextRow();
            ImGui::TableNextColumn();
            ImGui::ColorButton("##1", ImVec4(0.13f, 0.26f, 0.40f, 1.0f), ImGuiColorEditFlags_None, ImVec2(40, 40));
            ImGui::TableNextColumn();
            ImGui::Text("Line 1");
            ImGui::Text("Line 2");

            ImGui::TableNextRow();
            ImGui::TableNextColumn();
            ImGui::ColorButton("##2", ImVec4(0.13f, 0.26f, 0.40f, 1.0f), ImGuiColorEditFlags_None, ImVec2(40, 40));
            ImGui::TableNextColumn();
            ImGui::SameLine(0.0f, 0.0f); // Reuse line height from previous column
            ImGui::Text("Line 1, with SameLine(0,0)");
            ImGui::Text("Line 2");

            ImGui::EndTable();
        }

        HelpMarker("Showcase altering CellPadding.y between rows. Note that CellPadding.x is locked for the entire table.");
        if (ImGui::BeginTable("table_changing_cellpadding_y", 1, ImGuiTableFlags_Borders))
        {
            ImGuiStyle& style = ImGui::GetStyle();
            for (int row = 0; row < 8; row++)
            {
                if ((row % 3) == 2)
                    ImGui::PushStyleVarY(ImGuiStyleVar_CellPadding, 20.0f);
                ImGui::TableNextRow(ImGuiTableRowFlags_None);
                ImGui::TableNextColumn();
                ImGui::Text("CellPadding.y = %.2f", style.CellPadding.y);
                if ((row % 3) == 2)
                    ImGui::PopStyleVar();
            }
            ImGui::EndTable();
        }

        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Outer size");
    if (ImGui::TreeNode("Outer size"))
    {
        // Showcasing use of ImGuiTableFlags_NoHostExtendX and ImGuiTableFlags_NoHostExtendY
        // Important to that note how the two flags have slightly different behaviors!
        ImGui::Text("Using NoHostExtendX and NoHostExtendY:");
        PushStyleCompact();
        static ImGuiTableFlags flags = ImGuiTableFlags_Borders | ImGuiTableFlags_Resizable | ImGuiTableFlags_ContextMenuInBody | ImGuiTableFlags_RowBg | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_NoHostExtendX;
        ImGui::CheckboxFlags("ImGuiTableFlags_NoHostExtendX", &flags, ImGuiTableFlags_NoHostExtendX);
        ImGui::SameLine(); HelpMarker("Make outer width auto-fit to columns, overriding outer_size.x value.\n\nOnly available when ScrollX/ScrollY are disabled and Stretch columns are not used.");
        ImGui::CheckboxFlags("ImGuiTableFlags_NoHostExtendY", &flags, ImGuiTableFlags_NoHostExtendY);
        ImGui::SameLine(); HelpMarker("Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit).\n\nOnly available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.");
        PopStyleCompact();

        ImVec2 outer_size = ImVec2(0.0f, TEXT_BASE_HEIGHT * 5.5f);
        if (ImGui::BeginTable("table1", 3, flags, outer_size))
        {
            for (int row = 0; row < 10; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableNextColumn();
                    ImGui::Text("Cell %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::SameLine();
        ImGui::Text("Hello!");

        ImGui::Spacing();

        ImGui::Text("Using explicit size:");
        if (ImGui::BeginTable("table2", 3, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg, ImVec2(TEXT_BASE_WIDTH * 30, 0.0f)))
        {
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableNextColumn();
                    ImGui::Text("Cell %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }
        ImGui::SameLine();
        if (ImGui::BeginTable("table3", 3, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg, ImVec2(TEXT_BASE_WIDTH * 30, 0.0f)))
        {
            for (int row = 0; row < 3; row++)
            {
                ImGui::TableNextRow(0, TEXT_BASE_HEIGHT * 1.5f);
                for (int column = 0; column < 3; column++)
                {
                    ImGui::TableNextColumn();
                    ImGui::Text("Cell %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }

        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Background color");
    if (ImGui::TreeNode("Background color"))
    {
        static ImGuiTableFlags flags = ImGuiTableFlags_RowBg;
        static int row_bg_type = 1;
        static int row_bg_target = 1;
        static int cell_bg_type = 1;

        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_Borders", &flags, ImGuiTableFlags_Borders);
        ImGui::CheckboxFlags("ImGuiTableFlags_RowBg", &flags, ImGuiTableFlags_RowBg);
        ImGui::SameLine(); HelpMarker("ImGuiTableFlags_RowBg automatically sets RowBg0 to alternative colors pulled from the Style.");
        ImGui::Combo("row bg type", (int*)&row_bg_type, "None\0Red\0Gradient\0");
        ImGui::Combo("row bg target", (int*)&row_bg_target, "RowBg0\0RowBg1\0"); ImGui::SameLine(); HelpMarker("Target RowBg0 to override the alternating odd/even colors,\nTarget RowBg1 to blend with them.");
        ImGui::Combo("cell bg type", (int*)&cell_bg_type, "None\0Blue\0"); ImGui::SameLine(); HelpMarker("We are colorizing cells to B1->C2 here.");
        IM_ASSERT(row_bg_type >= 0 && row_bg_type <= 2);
        IM_ASSERT(row_bg_target >= 0 && row_bg_target <= 1);
        IM_ASSERT(cell_bg_type >= 0 && cell_bg_type <= 1);
        PopStyleCompact();

        if (ImGui::BeginTable("table1", 5, flags))
        {
            for (int row = 0; row < 6; row++)
            {
                ImGui::TableNextRow();

                // Demonstrate setting a row background color with 'ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBgX, ...)'
                // We use a transparent color so we can see the one behind in case our target is RowBg1 and RowBg0 was already targeted by the ImGuiTableFlags_RowBg flag.
                if (row_bg_type != 0)
                {
                    ImU32 row_bg_color = ImGui::GetColorU32(row_bg_type == 1 ? ImVec4(0.7f, 0.3f, 0.3f, 0.65f) : ImVec4(0.2f + row * 0.1f, 0.2f, 0.2f, 0.65f)); // Flat or Gradient?
                    ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0 + row_bg_target, row_bg_color);
                }

                // Fill cells
                for (int column = 0; column < 5; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("%c%c", 'A' + row, '0' + column);

                    // Change background of Cells B1->C2
                    // Demonstrate setting a cell background color with 'ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, ...)'
                    // (the CellBg color will be blended over the RowBg and ColumnBg colors)
                    // We can also pass a column number as a third parameter to TableSetBgColor() and do this outside the column loop.
                    if (row >= 1 && row <= 2 && column >= 1 && column <= 2 && cell_bg_type == 1)
                    {
                        ImU32 cell_bg_color = ImGui::GetColorU32(ImVec4(0.3f, 0.3f, 0.7f, 0.65f));
                        ImGui::TableSetBgColor(ImGuiTableBgTarget_CellBg, cell_bg_color);
                    }
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Tree view");
    if (ImGui::TreeNode("Tree view"))
    {
        static ImGuiTableFlags table_flags = ImGuiTableFlags_BordersV | ImGuiTableFlags_BordersOuterH | ImGuiTableFlags_Resizable | ImGuiTableFlags_RowBg | ImGuiTableFlags_NoBordersInBody;

        static ImGuiTreeNodeFlags tree_node_flags_base = ImGuiTreeNodeFlags_SpanAllColumns | ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_DrawLinesFull;
        ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanFullWidth",  &tree_node_flags_base, ImGuiTreeNodeFlags_SpanFullWidth);
        ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanLabelWidth",  &tree_node_flags_base, ImGuiTreeNodeFlags_SpanLabelWidth);
        ImGui::CheckboxFlags("ImGuiTreeNodeFlags_SpanAllColumns", &tree_node_flags_base, ImGuiTreeNodeFlags_SpanAllColumns);
        ImGui::CheckboxFlags("ImGuiTreeNodeFlags_LabelSpanAllColumns", &tree_node_flags_base, ImGuiTreeNodeFlags_LabelSpanAllColumns);
        ImGui::SameLine(); HelpMarker("Useful if you know that you aren't displaying contents in other columns");

        HelpMarker("See \"Columns flags\" section to configure how indentation is applied to individual columns.");
        if (ImGui::BeginTable("3ways", 3, table_flags))
        {
            // The first column will use the default _WidthStretch when ScrollX is Off and _WidthFixed when ScrollX is On
            ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_NoHide);
            ImGui::TableSetupColumn("Size", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 12.0f);
            ImGui::TableSetupColumn("Type", ImGuiTableColumnFlags_WidthFixed, TEXT_BASE_WIDTH * 18.0f);
            ImGui::TableHeadersRow();

            // Simple storage to output a dummy file-system.
            struct MyTreeNode
            {
                const char*     Name;
                const char*     Type;
                int             Size;
                int             ChildIdx;
                int             ChildCount;
                static void DisplayNode(const MyTreeNode* node, const MyTreeNode* all_nodes)
                {
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn();
                    const bool is_folder = (node->ChildCount > 0);

                    ImGuiTreeNodeFlags node_flags = tree_node_flags_base;
                    if (node != &all_nodes[0])
                        node_flags &= ~ImGuiTreeNodeFlags_LabelSpanAllColumns; // Only demonstrate this on the root node.

                    if (is_folder)
                    {
                        bool open = ImGui::TreeNodeEx(node->Name, node_flags);
                        if ((node_flags & ImGuiTreeNodeFlags_LabelSpanAllColumns) == 0)
                        {
                            ImGui::TableNextColumn();
                            ImGui::TextDisabled("--");
                            ImGui::TableNextColumn();
                            ImGui::TextUnformatted(node->Type);
                        }
                        if (open)
                        {
                            for (int child_n = 0; child_n < node->ChildCount; child_n++)
                                DisplayNode(&all_nodes[node->ChildIdx + child_n], all_nodes);
                            ImGui::TreePop();
                        }
                    }
                    else
                    {
                        ImGui::TreeNodeEx(node->Name, node_flags | ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_Bullet | ImGuiTreeNodeFlags_NoTreePushOnOpen);
                        ImGui::TableNextColumn();
                        ImGui::Text("%d", node->Size);
                        ImGui::TableNextColumn();
                        ImGui::TextUnformatted(node->Type);
                    }
                }
            };
            static const MyTreeNode nodes[] =
            {
                { "Root with Long Name",          "Folder",       -1,       1, 3    }, // 0
                { "Music",                        "Folder",       -1,       4, 2    }, // 1
                { "Textures",                     "Folder",       -1,       6, 3    }, // 2
                { "desktop.ini",                  "System file",  1024,    -1,-1    }, // 3
                { "File1_a.wav",                  "Audio file",   123000,  -1,-1    }, // 4
                { "File1_b.wav",                  "Audio file",   456000,  -1,-1    }, // 5
                { "Image001.png",                 "Image file",   203128,  -1,-1    }, // 6
                { "Copy of Image001.png",         "Image file",   203256,  -1,-1    }, // 7
                { "Copy of Image001 (Final2).png","Image file",   203512,  -1,-1    }, // 8
            };

            MyTreeNode::DisplayNode(&nodes[0], nodes);

            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Item width");
    if (ImGui::TreeNode("Item width"))
    {
        HelpMarker(
            "Showcase using PushItemWidth() and how it is preserved on a per-column basis.\n\n"
            "Note that on auto-resizing non-resizable fixed columns, querying the content width for "
            "e.g. right-alignment doesn't make sense.");
        if (ImGui::BeginTable("table_item_width", 3, ImGuiTableFlags_Borders))
        {
            ImGui::TableSetupColumn("small");
            ImGui::TableSetupColumn("half");
            ImGui::TableSetupColumn("right-align");
            ImGui::TableHeadersRow();

            for (int row = 0; row < 3; row++)
            {
                ImGui::TableNextRow();
                if (row == 0)
                {
                    // Setup ItemWidth once (instead of setting up every time, which is also possible but less efficient)
                    ImGui::TableSetColumnIndex(0);
                    ImGui::PushItemWidth(TEXT_BASE_WIDTH * 3.0f); // Small
                    ImGui::TableSetColumnIndex(1);
                    ImGui::PushItemWidth(-ImGui::GetContentRegionAvail().x * 0.5f);
                    ImGui::TableSetColumnIndex(2);
                    ImGui::PushItemWidth(-FLT_MIN); // Right-aligned
                }

                // Draw our contents
                static float dummy_f = 0.0f;
                ImGui::PushID(row);
                ImGui::TableSetColumnIndex(0);
                ImGui::SliderFloat("float0", &dummy_f, 0.0f, 1.0f);
                ImGui::TableSetColumnIndex(1);
                ImGui::SliderFloat("float1", &dummy_f, 0.0f, 1.0f);
                ImGui::TableSetColumnIndex(2);
                ImGui::SliderFloat("##float2", &dummy_f, 0.0f, 1.0f); // No visible label since right-aligned
                ImGui::PopID();
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    // Demonstrate using TableHeader() calls instead of TableHeadersRow()
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Custom headers");
    if (ImGui::TreeNode("Custom headers"))
    {
        const int COLUMNS_COUNT = 3;
        if (ImGui::BeginTable("table_custom_headers", COLUMNS_COUNT, ImGuiTableFlags_Borders | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
        {
            ImGui::TableSetupColumn("Apricot");
            ImGui::TableSetupColumn("Banana");
            ImGui::TableSetupColumn("Cherry");

            // Dummy entire-column selection storage
            // FIXME: It would be nice to actually demonstrate full-featured selection using those checkbox.
            static bool column_selected[3] = {};

            // Instead of calling TableHeadersRow() we'll submit custom headers ourselves.
            // (A different approach is also possible:
            //    - Specify ImGuiTableColumnFlags_NoHeaderLabel in some TableSetupColumn() call.
            //    - Call TableHeadersRow() normally. This will submit TableHeader() with no name.
            //    - Then call TableSetColumnIndex() to position yourself in the column and submit your stuff e.g. Checkbox().)
            ImGui::TableNextRow(ImGuiTableRowFlags_Headers);
            for (int column = 0; column < COLUMNS_COUNT; column++)
            {
                ImGui::TableSetColumnIndex(column);
                const char* column_name = ImGui::TableGetColumnName(column); // Retrieve name passed to TableSetupColumn()
                ImGui::PushID(column);
                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
                ImGui::Checkbox("##checkall", &column_selected[column]);
                ImGui::PopStyleVar();
                ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
                ImGui::TableHeader(column_name);
                ImGui::PopID();
            }

            // Submit table contents
            for (int row = 0; row < 5; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < 3; column++)
                {
                    char buf[32];
                    sprintf(buf, "Cell %d,%d", column, row);
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Selectable(buf, column_selected[column]);
                }
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    // Demonstrate using ImGuiTableColumnFlags_AngledHeader flag to create angled headers
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Angled headers");
    if (ImGui::TreeNode("Angled headers"))
    {
        const char* column_names[] = { "Track", "cabasa", "ride", "smash", "tom-hi", "tom-mid", "tom-low", "hihat-o", "hihat-c", "snare-s", "snare-c", "clap", "rim", "kick" };
        const int columns_count = IM_ARRAYSIZE(column_names);
        const int rows_count = 12;

        static ImGuiTableFlags table_flags = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_Hideable | ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_HighlightHoveredColumn;
        static ImGuiTableColumnFlags column_flags = ImGuiTableColumnFlags_AngledHeader | ImGuiTableColumnFlags_WidthFixed;
        static bool bools[columns_count * rows_count] = {}; // Dummy storage selection storage
        static int frozen_cols = 1;
        static int frozen_rows = 2;
        ImGui::CheckboxFlags("_ScrollX", &table_flags, ImGuiTableFlags_ScrollX);
        ImGui::CheckboxFlags("_ScrollY", &table_flags, ImGuiTableFlags_ScrollY);
        ImGui::CheckboxFlags("_Resizable", &table_flags, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("_Sortable", &table_flags, ImGuiTableFlags_Sortable);
        ImGui::CheckboxFlags("_NoBordersInBody", &table_flags, ImGuiTableFlags_NoBordersInBody);
        ImGui::CheckboxFlags("_HighlightHoveredColumn", &table_flags, ImGuiTableFlags_HighlightHoveredColumn);
        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
        ImGui::SliderInt("Frozen columns", &frozen_cols, 0, 2);
        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
        ImGui::SliderInt("Frozen rows", &frozen_rows, 0, 2);
        ImGui::CheckboxFlags("Disable header contributing to column width", &column_flags, ImGuiTableColumnFlags_NoHeaderWidth);

        if (ImGui::TreeNode("Style settings"))
        {
            ImGui::SameLine();
            HelpMarker("Giving access to some ImGuiStyle value in this demo for convenience.");
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
            ImGui::SliderAngle("style.TableAngledHeadersAngle", &ImGui::GetStyle().TableAngledHeadersAngle, -50.0f, +50.0f);
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
            ImGui::SliderFloat2("style.TableAngledHeadersTextAlign", (float*)&ImGui::GetStyle().TableAngledHeadersTextAlign, 0.0f, 1.0f, "%.2f");
            ImGui::TreePop();
        }

        if (ImGui::BeginTable("table_angled_headers", columns_count, table_flags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 12)))
        {
            ImGui::TableSetupColumn(column_names[0], ImGuiTableColumnFlags_NoHide | ImGuiTableColumnFlags_NoReorder);
            for (int n = 1; n < columns_count; n++)
                ImGui::TableSetupColumn(column_names[n], column_flags);
            ImGui::TableSetupScrollFreeze(frozen_cols, frozen_rows);

            ImGui::TableAngledHeadersRow(); // Draw angled headers for all columns with the ImGuiTableColumnFlags_AngledHeader flag.
            ImGui::TableHeadersRow();       // Draw remaining headers and allow access to context-menu and other functions.
            for (int row = 0; row < rows_count; row++)
            {
                ImGui::PushID(row);
                ImGui::TableNextRow();
                ImGui::TableSetColumnIndex(0);
                ImGui::AlignTextToFramePadding();
                ImGui::Text("Track %d", row);
                for (int column = 1; column < columns_count; column++)
                    if (ImGui::TableSetColumnIndex(column))
                    {
                        ImGui::PushID(column);
                        ImGui::Checkbox("", &bools[row * columns_count + column]);
                        ImGui::PopID();
                    }
                ImGui::PopID();
            }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    // Demonstrate creating custom context menus inside columns,
    // while playing it nice with context menus provided by TableHeadersRow()/TableHeader()
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Context menus");
    if (ImGui::TreeNode("Context menus"))
    {
        HelpMarker(
            "By default, right-clicking over a TableHeadersRow()/TableHeader() line will open the default context-menu.\n"
            "Using ImGuiTableFlags_ContextMenuInBody we also allow right-clicking over columns body.");
        static ImGuiTableFlags flags1 = ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Borders | ImGuiTableFlags_ContextMenuInBody;

        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_ContextMenuInBody", &flags1, ImGuiTableFlags_ContextMenuInBody);
        PopStyleCompact();

        // Context Menus: first example
        // [1.1] Right-click on the TableHeadersRow() line to open the default table context menu.
        // [1.2] Right-click in columns also open the default table context menu (if ImGuiTableFlags_ContextMenuInBody is set)
        const int COLUMNS_COUNT = 3;
        if (ImGui::BeginTable("table_context_menu", COLUMNS_COUNT, flags1))
        {
            ImGui::TableSetupColumn("One");
            ImGui::TableSetupColumn("Two");
            ImGui::TableSetupColumn("Three");

            // [1.1]] Right-click on the TableHeadersRow() line to open the default table context menu.
            ImGui::TableHeadersRow();

            // Submit dummy contents
            for (int row = 0; row < 4; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < COLUMNS_COUNT; column++)
                {
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Cell %d,%d", column, row);
                }
            }
            ImGui::EndTable();
        }

        // Context Menus: second example
        // [2.1] Right-click on the TableHeadersRow() line to open the default table context menu.
        // [2.2] Right-click on the ".." to open a custom popup
        // [2.3] Right-click in columns to open another custom popup
        HelpMarker(
            "Demonstrate mixing table context menu (over header), item context button (over button) "
            "and custom per-colunm context menu (over column body).");
        ImGuiTableFlags flags2 = ImGuiTableFlags_Resizable | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Borders;
        if (ImGui::BeginTable("table_context_menu_2", COLUMNS_COUNT, flags2))
        {
            ImGui::TableSetupColumn("One");
            ImGui::TableSetupColumn("Two");
            ImGui::TableSetupColumn("Three");

            // [2.1] Right-click on the TableHeadersRow() line to open the default table context menu.
            ImGui::TableHeadersRow();
            for (int row = 0; row < 4; row++)
            {
                ImGui::TableNextRow();
                for (int column = 0; column < COLUMNS_COUNT; column++)
                {
                    // Submit dummy contents
                    ImGui::TableSetColumnIndex(column);
                    ImGui::Text("Cell %d,%d", column, row);
                    ImGui::SameLine();

                    // [2.2] Right-click on the ".." to open a custom popup
                    ImGui::PushID(row * COLUMNS_COUNT + column);
                    ImGui::SmallButton("..");
                    if (ImGui::BeginPopupContextItem())
                    {
                        ImGui::Text("This is the popup for Button(\"..\") in Cell %d,%d", column, row);
                        if (ImGui::Button("Close"))
                            ImGui::CloseCurrentPopup();
                        ImGui::EndPopup();
                    }
                    ImGui::PopID();
                }
            }

            // [2.3] Right-click anywhere in columns to open another custom popup
            // (instead of testing for !IsAnyItemHovered() we could also call OpenPopup() with ImGuiPopupFlags_NoOpenOverExistingPopup
            // to manage popup priority as the popups triggers, here "are we hovering a column" are overlapping)
            int hovered_column = -1;
            for (int column = 0; column < COLUMNS_COUNT + 1; column++)
            {
                ImGui::PushID(column);
                if (ImGui::TableGetColumnFlags(column) & ImGuiTableColumnFlags_IsHovered)
                    hovered_column = column;
                if (hovered_column == column && !ImGui::IsAnyItemHovered() && ImGui::IsMouseReleased(1))
                    ImGui::OpenPopup("MyPopup");
                if (ImGui::BeginPopup("MyPopup"))
                {
                    if (column == COLUMNS_COUNT)
                        ImGui::Text("This is a custom popup for unused space after the last column.");
                    else
                        ImGui::Text("This is a custom popup for Column %d", column);
                    if (ImGui::Button("Close"))
                        ImGui::CloseCurrentPopup();
                    ImGui::EndPopup();
                }
                ImGui::PopID();
            }

            ImGui::EndTable();
            ImGui::Text("Hovered column: %d", hovered_column);
        }
        ImGui::TreePop();
    }

    // Demonstrate creating multiple tables with the same ID
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Synced instances");
    if (ImGui::TreeNode("Synced instances"))
    {
        HelpMarker("Multiple tables with the same identifier will share their settings, width, visibility, order etc.");

        static ImGuiTableFlags flags = ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Borders | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_NoSavedSettings;
        ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags, ImGuiTableFlags_Resizable);
        ImGui::CheckboxFlags("ImGuiTableFlags_ScrollY", &flags, ImGuiTableFlags_ScrollY);
        ImGui::CheckboxFlags("ImGuiTableFlags_SizingFixedFit", &flags, ImGuiTableFlags_SizingFixedFit);
        ImGui::CheckboxFlags("ImGuiTableFlags_HighlightHoveredColumn", &flags, ImGuiTableFlags_HighlightHoveredColumn);
        for (int n = 0; n < 3; n++)
        {
            char buf[32];
            sprintf(buf, "Synced Table %d", n);
            bool open = ImGui::CollapsingHeader(buf, ImGuiTreeNodeFlags_DefaultOpen);
            if (open && ImGui::BeginTable("Table", 3, flags, ImVec2(0.0f, ImGui::GetTextLineHeightWithSpacing() * 5)))
            {
                ImGui::TableSetupColumn("One");
                ImGui::TableSetupColumn("Two");
                ImGui::TableSetupColumn("Three");
                ImGui::TableHeadersRow();
                const int cell_count = (n == 1) ? 27 : 9; // Make second table have a scrollbar to verify that additional decoration is not affecting column positions.
                for (int cell = 0; cell < cell_count; cell++)
                {
                    ImGui::TableNextColumn();
                    ImGui::Text("this cell %d", cell);
                }
                ImGui::EndTable();
            }
        }
        ImGui::TreePop();
    }

    // Demonstrate using Sorting facilities
    // This is a simplified version of the "Advanced" example, where we mostly focus on the code necessary to handle sorting.
    // Note that the "Advanced" example also showcase manually triggering a sort (e.g. if item quantities have been modified)
    static const char* template_items_names[] =
    {
        "Banana", "Apple", "Cherry", "Watermelon", "Grapefruit", "Strawberry", "Mango",
        "Kiwi", "Orange", "Pineapple", "Blueberry", "Plum", "Coconut", "Pear", "Apricot"
    };
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Sorting");
    if (ImGui::TreeNode("Sorting"))
    {
        // Create item list
        static ImVector<MyItem> items;
        if (items.Size == 0)
        {
            items.resize(50, MyItem());
            for (int n = 0; n < items.Size; n++)
            {
                const int template_n = n % IM_ARRAYSIZE(template_items_names);
                MyItem& item = items[n];
                item.ID = n;
                item.Name = template_items_names[template_n];
                item.Quantity = (n * n - n) % 20; // Assign default quantities
            }
        }

        // Options
        static ImGuiTableFlags flags =
            ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Sortable | ImGuiTableFlags_SortMulti
            | ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_NoBordersInBody
            | ImGuiTableFlags_ScrollY;
        PushStyleCompact();
        ImGui::CheckboxFlags("ImGuiTableFlags_SortMulti", &flags, ImGuiTableFlags_SortMulti);
        ImGui::SameLine(); HelpMarker("When sorting is enabled: hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).");
        ImGui::CheckboxFlags("ImGuiTableFlags_SortTristate", &flags, ImGuiTableFlags_SortTristate);
        ImGui::SameLine(); HelpMarker("When sorting is enabled: allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).");
        PopStyleCompact();

        if (ImGui::BeginTable("table_sorting", 4, flags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 15), 0.0f))
        {
            // Declare columns
            // We use the "user_id" parameter of TableSetupColumn() to specify a user id that will be stored in the sort specifications.
            // This is so our sort function can identify a column given our own identifier. We could also identify them based on their index!
            // Demonstrate using a mixture of flags among available sort-related flags:
            // - ImGuiTableColumnFlags_DefaultSort
            // - ImGuiTableColumnFlags_NoSort / ImGuiTableColumnFlags_NoSortAscending / ImGuiTableColumnFlags_NoSortDescending
            // - ImGuiTableColumnFlags_PreferSortAscending / ImGuiTableColumnFlags_PreferSortDescending
            ImGui::TableSetupColumn("ID",       ImGuiTableColumnFlags_DefaultSort          | ImGuiTableColumnFlags_WidthFixed,   0.0f, MyItemColumnID_ID);
            ImGui::TableSetupColumn("Name",                                                  ImGuiTableColumnFlags_WidthFixed,   0.0f, MyItemColumnID_Name);
            ImGui::TableSetupColumn("Action",   ImGuiTableColumnFlags_NoSort               | ImGuiTableColumnFlags_WidthFixed,   0.0f, MyItemColumnID_Action);
            ImGui::TableSetupColumn("Quantity", ImGuiTableColumnFlags_PreferSortDescending | ImGuiTableColumnFlags_WidthStretch, 0.0f, MyItemColumnID_Quantity);
            ImGui::TableSetupScrollFreeze(0, 1); // Make row always visible
            ImGui::TableHeadersRow();

            // Sort our data if sort specs have been changed!
            if (ImGuiTableSortSpecs* sort_specs = ImGui::TableGetSortSpecs())
                if (sort_specs->SpecsDirty)
                {
                    MyItem::SortWithSortSpecs(sort_specs, items.Data, items.Size);
                    sort_specs->SpecsDirty = false;
                }

            // Demonstrate using clipper for large vertical lists
            ImGuiListClipper clipper;
            clipper.Begin(items.Size);
            while (clipper.Step())
                for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++)
                {
                    // Display a data item
                    MyItem* item = &items[row_n];
                    ImGui::PushID(item->ID);
                    ImGui::TableNextRow();
                    ImGui::TableNextColumn();
                    ImGui::Text("%04d", item->ID);
                    ImGui::TableNextColumn();
                    ImGui::TextUnformatted(item->Name);
                    ImGui::TableNextColumn();
                    ImGui::SmallButton("None");
                    ImGui::TableNextColumn();
                    ImGui::Text("%d", item->Quantity);
                    ImGui::PopID();
                }
            ImGui::EndTable();
        }
        ImGui::TreePop();
    }

    // In this example we'll expose most table flags and settings.
    // For specific flags and settings refer to the corresponding section for more detailed explanation.
    // This section is mostly useful to experiment with combining certain flags or settings with each others.
    //ImGui::SetNextItemOpen(true, ImGuiCond_Once); // [DEBUG]
    if (open_action != -1)
        ImGui::SetNextItemOpen(open_action != 0);
    IMGUI_DEMO_MARKER("Tables/Advanced");
    if (ImGui::TreeNode("Advanced"))
    {
        static ImGuiTableFlags flags =
            ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable
            | ImGuiTableFlags_Sortable | ImGuiTableFlags_SortMulti
            | ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_NoBordersInBody
            | ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY
            | ImGuiTableFlags_SizingFixedFit;
        static ImGuiTableColumnFlags columns_base_flags = ImGuiTableColumnFlags_None;

        enum ContentsType { CT_Text, CT_Button, CT_SmallButton, CT_FillButton, CT_Selectable, CT_SelectableSpanRow };
        static int contents_type = CT_SelectableSpanRow;
        const char* contents_type_names[] = { "Text", "Button", "SmallButton", "FillButton", "Selectable", "Selectable (span row)" };
        static int freeze_cols = 1;
        static int freeze_rows = 1;
        static int items_count = IM_ARRAYSIZE(template_items_names) * 2;
        static ImVec2 outer_size_value = ImVec2(0.0f, TEXT_BASE_HEIGHT * 12);
        static float row_min_height = 0.0f; // Auto
        static float inner_width_with_scroll = 0.0f; // Auto-extend
        static bool outer_size_enabled = true;
        static bool show_headers = true;
        static bool show_wrapped_text = false;
        //static ImGuiTextFilter filter;
        //ImGui::SetNextItemOpen(true, ImGuiCond_Once); // FIXME-TABLE: Enabling this results in initial clipped first pass on table which tend to affect column sizing
        if (ImGui::TreeNode("Options"))
        {
            // Make the UI compact because there are so many fields
            PushStyleCompact();
            ImGui::PushItemWidth(TEXT_BASE_WIDTH * 28.0f);

            if (ImGui::TreeNodeEx("Features:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::CheckboxFlags("ImGuiTableFlags_Resizable", &flags, ImGuiTableFlags_Resizable);
                ImGui::CheckboxFlags("ImGuiTableFlags_Reorderable", &flags, ImGuiTableFlags_Reorderable);
                ImGui::CheckboxFlags("ImGuiTableFlags_Hideable", &flags, ImGuiTableFlags_Hideable);
                ImGui::CheckboxFlags("ImGuiTableFlags_Sortable", &flags, ImGuiTableFlags_Sortable);
                ImGui::CheckboxFlags("ImGuiTableFlags_NoSavedSettings", &flags, ImGuiTableFlags_NoSavedSettings);
                ImGui::CheckboxFlags("ImGuiTableFlags_ContextMenuInBody", &flags, ImGuiTableFlags_ContextMenuInBody);
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Decorations:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::CheckboxFlags("ImGuiTableFlags_RowBg", &flags, ImGuiTableFlags_RowBg);
                ImGui::CheckboxFlags("ImGuiTableFlags_BordersV", &flags, ImGuiTableFlags_BordersV);
                ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuterV", &flags, ImGuiTableFlags_BordersOuterV);
                ImGui::CheckboxFlags("ImGuiTableFlags_BordersInnerV", &flags, ImGuiTableFlags_BordersInnerV);
                ImGui::CheckboxFlags("ImGuiTableFlags_BordersH", &flags, ImGuiTableFlags_BordersH);
                ImGui::CheckboxFlags("ImGuiTableFlags_BordersOuterH", &flags, ImGuiTableFlags_BordersOuterH);
                ImGui::CheckboxFlags("ImGuiTableFlags_BordersInnerH", &flags, ImGuiTableFlags_BordersInnerH);
                ImGui::CheckboxFlags("ImGuiTableFlags_NoBordersInBody", &flags, ImGuiTableFlags_NoBordersInBody); ImGui::SameLine(); HelpMarker("Disable vertical borders in columns Body (borders will always appear in Headers)");
                ImGui::CheckboxFlags("ImGuiTableFlags_NoBordersInBodyUntilResize", &flags, ImGuiTableFlags_NoBordersInBodyUntilResize); ImGui::SameLine(); HelpMarker("Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers)");
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Sizing:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                EditTableSizingFlags(&flags);
                ImGui::SameLine(); HelpMarker("In the Advanced demo we override the policy of each column so those table-wide settings have less effect that typical.");
                ImGui::CheckboxFlags("ImGuiTableFlags_NoHostExtendX", &flags, ImGuiTableFlags_NoHostExtendX);
                ImGui::SameLine(); HelpMarker("Make outer width auto-fit to columns, overriding outer_size.x value.\n\nOnly available when ScrollX/ScrollY are disabled and Stretch columns are not used.");
                ImGui::CheckboxFlags("ImGuiTableFlags_NoHostExtendY", &flags, ImGuiTableFlags_NoHostExtendY);
                ImGui::SameLine(); HelpMarker("Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit).\n\nOnly available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.");
                ImGui::CheckboxFlags("ImGuiTableFlags_NoKeepColumnsVisible", &flags, ImGuiTableFlags_NoKeepColumnsVisible);
                ImGui::SameLine(); HelpMarker("Only available if ScrollX is disabled.");
                ImGui::CheckboxFlags("ImGuiTableFlags_PreciseWidths", &flags, ImGuiTableFlags_PreciseWidths);
                ImGui::SameLine(); HelpMarker("Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.");
                ImGui::CheckboxFlags("ImGuiTableFlags_NoClip", &flags, ImGuiTableFlags_NoClip);
                ImGui::SameLine(); HelpMarker("Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with ScrollFreeze options.");
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Padding:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::CheckboxFlags("ImGuiTableFlags_PadOuterX", &flags, ImGuiTableFlags_PadOuterX);
                ImGui::CheckboxFlags("ImGuiTableFlags_NoPadOuterX", &flags, ImGuiTableFlags_NoPadOuterX);
                ImGui::CheckboxFlags("ImGuiTableFlags_NoPadInnerX", &flags, ImGuiTableFlags_NoPadInnerX);
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Scrolling:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::CheckboxFlags("ImGuiTableFlags_ScrollX", &flags, ImGuiTableFlags_ScrollX);
                ImGui::SameLine();
                ImGui::SetNextItemWidth(ImGui::GetFrameHeight());
                ImGui::DragInt("freeze_cols", &freeze_cols, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);
                ImGui::CheckboxFlags("ImGuiTableFlags_ScrollY", &flags, ImGuiTableFlags_ScrollY);
                ImGui::SameLine();
                ImGui::SetNextItemWidth(ImGui::GetFrameHeight());
                ImGui::DragInt("freeze_rows", &freeze_rows, 0.2f, 0, 9, NULL, ImGuiSliderFlags_NoInput);
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Sorting:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::CheckboxFlags("ImGuiTableFlags_SortMulti", &flags, ImGuiTableFlags_SortMulti);
                ImGui::SameLine(); HelpMarker("When sorting is enabled: hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).");
                ImGui::CheckboxFlags("ImGuiTableFlags_SortTristate", &flags, ImGuiTableFlags_SortTristate);
                ImGui::SameLine(); HelpMarker("When sorting is enabled: allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).");
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Headers:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::Checkbox("show_headers", &show_headers);
                ImGui::CheckboxFlags("ImGuiTableFlags_HighlightHoveredColumn", &flags, ImGuiTableFlags_HighlightHoveredColumn);
                ImGui::CheckboxFlags("ImGuiTableColumnFlags_AngledHeader", &columns_base_flags, ImGuiTableColumnFlags_AngledHeader);
                ImGui::SameLine(); HelpMarker("Enable AngledHeader on all columns. Best enabled on selected narrow columns (see \"Angled headers\" section of the demo).");
                ImGui::TreePop();
            }

            if (ImGui::TreeNodeEx("Other:", ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::Checkbox("show_wrapped_text", &show_wrapped_text);

                ImGui::DragFloat2("##OuterSize", &outer_size_value.x);
                ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
                ImGui::Checkbox("outer_size", &outer_size_enabled);
                ImGui::SameLine();
                HelpMarker("If scrolling is disabled (ScrollX and ScrollY not set):\n"
                    "- The table is output directly in the parent window.\n"
                    "- OuterSize.x < 0.0f will right-align the table.\n"
                    "- OuterSize.x = 0.0f will narrow fit the table unless there are any Stretch columns.\n"
                    "- OuterSize.y then becomes the minimum size for the table, which will extend vertically if there are more rows (unless NoHostExtendY is set).");

                // From a user point of view we will tend to use 'inner_width' differently depending on whether our table is embedding scrolling.
                // To facilitate toying with this demo we will actually pass 0.0f to the BeginTable() when ScrollX is disabled.
                ImGui::DragFloat("inner_width (when ScrollX active)", &inner_width_with_scroll, 1.0f, 0.0f, FLT_MAX);

                ImGui::DragFloat("row_min_height", &row_min_height, 1.0f, 0.0f, FLT_MAX);
                ImGui::SameLine(); HelpMarker("Specify height of the Selectable item.");

                ImGui::DragInt("items_count", &items_count, 0.1f, 0, 9999);
                ImGui::Combo("items_type (first column)", &contents_type, contents_type_names, IM_ARRAYSIZE(contents_type_names));
                //filter.Draw("filter");
                ImGui::TreePop();
            }

            ImGui::PopItemWidth();
            PopStyleCompact();
            ImGui::Spacing();
            ImGui::TreePop();
        }

        // Update item list if we changed the number of items
        static ImVector<MyItem> items;
        static ImVector<int> selection;
        static bool items_need_sort = false;
        if (items.Size != items_count)
        {
            items.resize(items_count, MyItem());
            for (int n = 0; n < items_count; n++)
            {
                const int template_n = n % IM_ARRAYSIZE(template_items_names);
                MyItem& item = items[n];
                item.ID = n;
                item.Name = template_items_names[template_n];
                item.Quantity = (template_n == 3) ? 10 : (template_n == 4) ? 20 : 0; // Assign default quantities
            }
        }

        const ImDrawList* parent_draw_list = ImGui::GetWindowDrawList();
        const int parent_draw_list_draw_cmd_count = parent_draw_list->CmdBuffer.Size;
        ImVec2 table_scroll_cur, table_scroll_max; // For debug display
        const ImDrawList* table_draw_list = NULL;  // "

        // Submit table
        const float inner_width_to_use = (flags & ImGuiTableFlags_ScrollX) ? inner_width_with_scroll : 0.0f;
        if (ImGui::BeginTable("table_advanced", 6, flags, outer_size_enabled ? outer_size_value : ImVec2(0, 0), inner_width_to_use))
        {
            // Declare columns
            // We use the "user_id" parameter of TableSetupColumn() to specify a user id that will be stored in the sort specifications.
            // This is so our sort function can identify a column given our own identifier. We could also identify them based on their index!
            ImGui::TableSetupColumn("ID",           columns_base_flags | ImGuiTableColumnFlags_DefaultSort | ImGuiTableColumnFlags_WidthFixed | ImGuiTableColumnFlags_NoHide, 0.0f, MyItemColumnID_ID);
            ImGui::TableSetupColumn("Name",         columns_base_flags | ImGuiTableColumnFlags_WidthFixed, 0.0f, MyItemColumnID_Name);
            ImGui::TableSetupColumn("Action",       columns_base_flags | ImGuiTableColumnFlags_NoSort | ImGuiTableColumnFlags_WidthFixed, 0.0f, MyItemColumnID_Action);
            ImGui::TableSetupColumn("Quantity",     columns_base_flags | ImGuiTableColumnFlags_PreferSortDescending, 0.0f, MyItemColumnID_Quantity);
            ImGui::TableSetupColumn("Description",  columns_base_flags | ((flags & ImGuiTableFlags_NoHostExtendX) ? 0 : ImGuiTableColumnFlags_WidthStretch), 0.0f, MyItemColumnID_Description);
            ImGui::TableSetupColumn("Hidden",       columns_base_flags |  ImGuiTableColumnFlags_DefaultHide | ImGuiTableColumnFlags_NoSort);
            ImGui::TableSetupScrollFreeze(freeze_cols, freeze_rows);

            // Sort our data if sort specs have been changed!
            ImGuiTableSortSpecs* sort_specs = ImGui::TableGetSortSpecs();
            if (sort_specs && sort_specs->SpecsDirty)
                items_need_sort = true;
            if (sort_specs && items_need_sort && items.Size > 1)
            {
                MyItem::SortWithSortSpecs(sort_specs, items.Data, items.Size);
                sort_specs->SpecsDirty = false;
            }
            items_need_sort = false;

            // Take note of whether we are currently sorting based on the Quantity field,
            // we will use this to trigger sorting when we know the data of this column has been modified.
            const bool sorts_specs_using_quantity = (ImGui::TableGetColumnFlags(3) & ImGuiTableColumnFlags_IsSorted) != 0;

            // Show headers
            if (show_headers && (columns_base_flags & ImGuiTableColumnFlags_AngledHeader) != 0)
                ImGui::TableAngledHeadersRow();
            if (show_headers)
                ImGui::TableHeadersRow();

            // Show data
            // FIXME-TABLE FIXME-NAV: How we can get decent up/down even though we have the buttons here?
#if 1
            // Demonstrate using clipper for large vertical lists
            ImGuiListClipper clipper;
            clipper.Begin(items.Size);
            while (clipper.Step())
            {
                for (int row_n = clipper.DisplayStart; row_n < clipper.DisplayEnd; row_n++)
#else
            // Without clipper
            {
                for (int row_n = 0; row_n < items.Size; row_n++)
#endif
                {
                    MyItem* item = &items[row_n];
                    //if (!filter.PassFilter(item->Name))
                    //    continue;

                    const bool item_is_selected = selection.contains(item->ID);
                    ImGui::PushID(item->ID);
                    ImGui::TableNextRow(ImGuiTableRowFlags_None, row_min_height);

                    // For the demo purpose we can select among different type of items submitted in the first column
                    ImGui::TableSetColumnIndex(0);
                    char label[32];
                    sprintf(label, "%04d", item->ID);
                    if (contents_type == CT_Text)
                        ImGui::TextUnformatted(label);
                    else if (contents_type == CT_Button)
                        ImGui::Button(label);
                    else if (contents_type == CT_SmallButton)
                        ImGui::SmallButton(label);
                    else if (contents_type == CT_FillButton)
                        ImGui::Button(label, ImVec2(-FLT_MIN, 0.0f));
                    else if (contents_type == CT_Selectable || contents_type == CT_SelectableSpanRow)
                    {
                        ImGuiSelectableFlags selectable_flags = (contents_type == CT_SelectableSpanRow) ? ImGuiSelectableFlags_SpanAllColumns | ImGuiSelectableFlags_AllowOverlap : ImGuiSelectableFlags_None;
                        if (ImGui::Selectable(label, item_is_selected, selectable_flags, ImVec2(0, row_min_height)))
                        {
                            if (ImGui::GetIO().KeyCtrl)
                            {
                                if (item_is_selected)
                                    selection.find_erase_unsorted(item->ID);
                                else
                                    selection.push_back(item->ID);
                            }
                            else
                            {
                                selection.clear();
                                selection.push_back(item->ID);
                            }
                        }
                    }

                    if (ImGui::TableSetColumnIndex(1))
                        ImGui::TextUnformatted(item->Name);

                    // Here we demonstrate marking our data set as needing to be sorted again if we modified a quantity,
                    // and we are currently sorting on the column showing the Quantity.
                    // To avoid triggering a sort while holding the button, we only trigger it when the button has been released.
                    // You will probably need some extra logic if you want to automatically sort when a specific entry changes.
                    if (ImGui::TableSetColumnIndex(2))
                    {
                        if (ImGui::SmallButton("Chop")) { item->Quantity += 1; }
                        if (sorts_specs_using_quantity && ImGui::IsItemDeactivated()) { items_need_sort = true; }
                        ImGui::SameLine();
                        if (ImGui::SmallButton("Eat")) { item->Quantity -= 1; }
                        if (sorts_specs_using_quantity && ImGui::IsItemDeactivated()) { items_need_sort = true; }
                    }

                    if (ImGui::TableSetColumnIndex(3))
                        ImGui::Text("%d", item->Quantity);

                    ImGui::TableSetColumnIndex(4);
                    if (show_wrapped_text)
                        ImGui::TextWrapped("Lorem ipsum dolor sit amet");
                    else
                        ImGui::Text("Lorem ipsum dolor sit amet");

                    if (ImGui::TableSetColumnIndex(5))
                        ImGui::Text("1234");

                    ImGui::PopID();
                }
            }

            // Store some info to display debug details below
            table_scroll_cur = ImVec2(ImGui::GetScrollX(), ImGui::GetScrollY());
            table_scroll_max = ImVec2(ImGui::GetScrollMaxX(), ImGui::GetScrollMaxY());
            table_draw_list = ImGui::GetWindowDrawList();
            ImGui::EndTable();
        }
        static bool show_debug_details = false;
        ImGui::Checkbox("Debug details", &show_debug_details);
        if (show_debug_details && table_draw_list)
        {
            ImGui::SameLine(0.0f, 0.0f);
            const int table_draw_list_draw_cmd_count = table_draw_list->CmdBuffer.Size;
            if (table_draw_list == parent_draw_list)
                ImGui::Text(": DrawCmd: +%d (in same window)",
                    table_draw_list_draw_cmd_count - parent_draw_list_draw_cmd_count);
            else
                ImGui::Text(": DrawCmd: +%d (in child window), Scroll: (%.f/%.f) (%.f/%.f)",
                    table_draw_list_draw_cmd_count - 1, table_scroll_cur.x, table_scroll_max.x, table_scroll_cur.y, table_scroll_max.y);
        }
        ImGui::TreePop();
    }

    ImGui::PopID();

    DemoWindowColumns();

    if (disable_indent)
        ImGui::PopStyleVar();
}

// Demonstrate old/legacy Columns API!
// [2020: Columns are under-featured and not maintained. Prefer using the more flexible and powerful BeginTable() API!]
static void DemoWindowColumns()
{
    IMGUI_DEMO_MARKER("Columns (legacy API)");
    bool open = ImGui::TreeNode("Legacy Columns API");
    ImGui::SameLine();
    HelpMarker("Columns() is an old API! Prefer using the more flexible and powerful BeginTable() API!");
    if (!open)
        return;

    // Basic columns
    IMGUI_DEMO_MARKER("Columns (legacy API)/Basic");
    if (ImGui::TreeNode("Basic"))
    {
        ImGui::Text("Without border:");
        ImGui::Columns(3, "mycolumns3", false);  // 3-ways, no border
        ImGui::Separator();
        for (int n = 0; n < 14; n++)
        {
            char label[32];
            sprintf(label, "Item %d", n);
            if (ImGui::Selectable(label)) {}
            //if (ImGui::Button(label, ImVec2(-FLT_MIN,0.0f))) {}
            ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::Separator();

        ImGui::Text("With border:");
        ImGui::Columns(4, "mycolumns"); // 4-ways, with border
        ImGui::Separator();
        ImGui::Text("ID"); ImGui::NextColumn();
        ImGui::Text("Name"); ImGui::NextColumn();
        ImGui::Text("Path"); ImGui::NextColumn();
        ImGui::Text("Hovered"); ImGui::NextColumn();
        ImGui::Separator();
        const char* names[3] = { "One", "Two", "Three" };
        const char* paths[3] = { "/path/one", "/path/two", "/path/three" };
        static int selected = -1;
        for (int i = 0; i < 3; i++)
        {
            char label[32];
            sprintf(label, "%04d", i);
            if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SpanAllColumns))
                selected = i;
            bool hovered = ImGui::IsItemHovered();
            ImGui::NextColumn();
            ImGui::Text(names[i]); ImGui::NextColumn();
            ImGui::Text(paths[i]); ImGui::NextColumn();
            ImGui::Text("%d", hovered); ImGui::NextColumn();
        }
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Columns (legacy API)/Borders");
    if (ImGui::TreeNode("Borders"))
    {
        // NB: Future columns API should allow automatic horizontal borders.
        static bool h_borders = true;
        static bool v_borders = true;
        static int columns_count = 4;
        const int lines_count = 3;
        ImGui::SetNextItemWidth(ImGui::GetFontSize() * 8);
        ImGui::DragInt("##columns_count", &columns_count, 0.1f, 2, 10, "%d columns");
        if (columns_count < 2)
            columns_count = 2;
        ImGui::SameLine();
        ImGui::Checkbox("horizontal", &h_borders);
        ImGui::SameLine();
        ImGui::Checkbox("vertical", &v_borders);
        ImGui::Columns(columns_count, NULL, v_borders);
        for (int i = 0; i < columns_count * lines_count; i++)
        {
            if (h_borders && ImGui::GetColumnIndex() == 0)
                ImGui::Separator();
            ImGui::PushID(i);
            ImGui::Text("%c%c%c", 'a' + i, 'a' + i, 'a' + i);
            ImGui::Text("Width %.2f", ImGui::GetColumnWidth());
            ImGui::Text("Avail %.2f", ImGui::GetContentRegionAvail().x);
            ImGui::Text("Offset %.2f", ImGui::GetColumnOffset());
            ImGui::Text("Long text that is likely to clip");
            ImGui::Button("Button", ImVec2(-FLT_MIN, 0.0f));
            ImGui::PopID();
            ImGui::NextColumn();
        }
        ImGui::Columns(1);
        if (h_borders)
            ImGui::Separator();
        ImGui::TreePop();
    }

    // Create multiple items in a same cell before switching to next column
    IMGUI_DEMO_MARKER("Columns (legacy API)/Mixed items");
    if (ImGui::TreeNode("Mixed items"))
    {
        ImGui::Columns(3, "mixed");
        ImGui::Separator();

        ImGui::Text("Hello");
        ImGui::Button("Banana");
        ImGui::NextColumn();

        ImGui::Text("ImGui");
        ImGui::Button("Apple");
        static float foo = 1.0f;
        ImGui::InputFloat("red", &foo, 0.05f, 0, "%.3f");
        ImGui::Text("An extra line here.");
        ImGui::NextColumn();

        ImGui::Text("Sailor");
        ImGui::Button("Corniflower");
        static float bar = 1.0f;
        ImGui::InputFloat("blue", &bar, 0.05f, 0, "%.3f");
        ImGui::NextColumn();

        if (ImGui::CollapsingHeader("Category A")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        if (ImGui::CollapsingHeader("Category B")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        if (ImGui::CollapsingHeader("Category C")) { ImGui::Text("Blah blah blah"); } ImGui::NextColumn();
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    // Word wrapping
    IMGUI_DEMO_MARKER("Columns (legacy API)/Word-wrapping");
    if (ImGui::TreeNode("Word-wrapping"))
    {
        ImGui::Columns(2, "word-wrapping");
        ImGui::Separator();
        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");
        ImGui::TextWrapped("Hello Left");
        ImGui::NextColumn();
        ImGui::TextWrapped("The quick brown fox jumps over the lazy dog.");
        ImGui::TextWrapped("Hello Right");
        ImGui::Columns(1);
        ImGui::Separator();
        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Columns (legacy API)/Horizontal Scrolling");
    if (ImGui::TreeNode("Horizontal Scrolling"))
    {
        ImGui::SetNextWindowContentSize(ImVec2(1500.0f, 0.0f));
        ImVec2 child_size = ImVec2(0, ImGui::GetFontSize() * 20.0f);
        ImGui::BeginChild("##ScrollingRegion", child_size, ImGuiChildFlags_None, ImGuiWindowFlags_HorizontalScrollbar);
        ImGui::Columns(10);

        // Also demonstrate using clipper for large vertical lists
        int ITEMS_COUNT = 2000;
        ImGuiListClipper clipper;
        clipper.Begin(ITEMS_COUNT);
        while (clipper.Step())
        {
            for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
                for (int j = 0; j < 10; j++)
                {
                    ImGui::Text("Line %d Column %d...", i, j);
                    ImGui::NextColumn();
                }
        }
        ImGui::Columns(1);
        ImGui::EndChild();
        ImGui::TreePop();
    }

    IMGUI_DEMO_MARKER("Columns (legacy API)/Tree");
    if (ImGui::TreeNode("Tree"))
    {
        ImGui::Columns(2, "tree", true);
        for (int x = 0; x < 3; x++)
        {
            bool open1 = ImGui::TreeNode((void*)(intptr_t)x, "Node%d", x);
            ImGui::NextColumn();
            ImGui::Text("Node contents");
            ImGui::NextColumn();
            if (open1)
            {
                for (int y = 0; y < 3; y++)
                {
                    bool open2 = ImGui::TreeNode((void*)(intptr_t)y, "Node%d.%d", x, y);
                    ImGui::NextColumn();
                    ImGui::Text("Node contents");
                    if (open2)
                    {
                        ImGui::Text("Even more contents");
                        if (ImGui::TreeNode("Tree in column"))
                        {
                            ImGui::Text("The quick brown fox jumps over the lazy dog");
                            ImGui::TreePop();
                        }
                    }
                    ImGui::NextColumn();
                    if (open2)
                        ImGui::TreePop();
                }
                ImGui::TreePop();
            }
        }
        ImGui::Columns(1);
        ImGui::TreePop();
    }

    ImGui::TreePop();
}

//-----------------------------------------------------------------------------
// [SECTION] DemoWindowInputs()
//-----------------------------------------------------------------------------

static void DemoWindowInputs()
{
    IMGUI_DEMO_MARKER("Inputs & Focus");
    if (ImGui::CollapsingHeader("Inputs & Focus"))
    {
        ImGuiIO& io = ImGui::GetIO();

        // Display inputs submitted to ImGuiIO
        IMGUI_DEMO_MARKER("Inputs & Focus/Inputs");
        ImGui::SetNextItemOpen(true, ImGuiCond_Once);
        bool inputs_opened = ImGui::TreeNode("Inputs");
        ImGui::SameLine();
        HelpMarker(
            "This is a simplified view. See more detailed input state:\n"
            "- in 'Tools->Metrics/Debugger->Inputs'.\n"
            "- in 'Tools->Debug Log->IO'.");
        if (inputs_opened)
        {
            if (ImGui::IsMousePosValid())
                ImGui::Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
            else
                ImGui::Text("Mouse pos: <INVALID>");
            ImGui::Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
            ImGui::Text("Mouse down:");
            for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (ImGui::IsMouseDown(i)) { ImGui::SameLine(); ImGui::Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]); }
            ImGui::Text("Mouse wheel: %.1f", io.MouseWheel);
            ImGui::Text("Mouse clicked count:");
            for (int i = 0; i < IM_ARRAYSIZE(io.MouseDown); i++) if (io.MouseClickedCount[i] > 0) { ImGui::SameLine(); ImGui::Text("b%d: %d", i, io.MouseClickedCount[i]); }

            // We iterate both legacy native range and named ImGuiKey ranges. This is a little unusual/odd but this allows
            // displaying the data for old/new backends.
            // User code should never have to go through such hoops!
            // You can generally iterate between ImGuiKey_NamedKey_BEGIN and ImGuiKey_NamedKey_END.
            struct funcs { static bool IsLegacyNativeDupe(ImGuiKey) { return false; } };
            ImGuiKey start_key = ImGuiKey_NamedKey_BEGIN;
            ImGui::Text("Keys down:");         for (ImGuiKey key = start_key; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1)) { if (funcs::IsLegacyNativeDupe(key) || !ImGui::IsKeyDown(key)) continue; ImGui::SameLine(); ImGui::Text((key < ImGuiKey_NamedKey_BEGIN) ? "\"%s\"" : "\"%s\" %d", ImGui::GetKeyName(key), key); }
            ImGui::Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");
            ImGui::Text("Chars queue:");       for (int i = 0; i < io.InputQueueCharacters.Size; i++) { ImWchar c = io.InputQueueCharacters[i]; ImGui::SameLine();  ImGui::Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? (char)c : '?', c); } // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.

            ImGui::TreePop();
        }

        // Display ImGuiIO output flags
        IMGUI_DEMO_MARKER("Inputs & Focus/Outputs");
        ImGui::SetNextItemOpen(true, ImGuiCond_Once);
        bool outputs_opened = ImGui::TreeNode("Outputs");
        ImGui::SameLine();
        HelpMarker(
            "The value of io.WantCaptureMouse and io.WantCaptureKeyboard are normally set by Dear ImGui "
            "to instruct your application of how to route inputs. Typically, when a value is true, it means "
            "Dear ImGui wants the corresponding inputs and we expect the underlying application to ignore them.\n\n"
            "The most typical case is: when hovering a window, Dear ImGui set io.WantCaptureMouse to true, "
            "and underlying application should ignore mouse inputs (in practice there are many and more subtle "
            "rules leading to how those flags are set).");
        if (outputs_opened)
        {
            ImGui::Text("io.WantCaptureMouse: %d", io.WantCaptureMouse);
            ImGui::Text("io.WantCaptureMouseUnlessPopupClose: %d", io.WantCaptureMouseUnlessPopupClose);
            ImGui::Text("io.WantCaptureKeyboard: %d", io.WantCaptureKeyboard);
            ImGui::Text("io.WantTextInput: %d", io.WantTextInput);
            ImGui::Text("io.WantSetMousePos: %d", io.WantSetMousePos);
            ImGui::Text("io.NavActive: %d, io.NavVisible: %d", io.NavActive, io.NavVisible);

            IMGUI_DEMO_MARKER("Inputs & Focus/Outputs/WantCapture override");
            if (ImGui::TreeNode("WantCapture override"))
            {
                HelpMarker(
                    "Hovering the colored canvas will override io.WantCaptureXXX fields.\n"
                    "Notice how normally (when set to none), the value of io.WantCaptureKeyboard would be false when hovering "
                    "and true when clicking.");
                static int capture_override_mouse = -1;
                static int capture_override_keyboard = -1;
                const char* capture_override_desc[] = { "None", "Set to false", "Set to true" };
                ImGui::SetNextItemWidth(ImGui::GetFontSize() * 15);
                ImGui::SliderInt("SetNextFrameWantCaptureMouse() on hover", &capture_override_mouse, -1, +1, capture_override_desc[capture_override_mouse + 1], ImGuiSliderFlags_AlwaysClamp);
                ImGui::SetNextItemWidth(ImGui::GetFontSize() * 15);
                ImGui::SliderInt("SetNextFrameWantCaptureKeyboard() on hover", &capture_override_keyboard, -1, +1, capture_override_desc[capture_override_keyboard + 1], ImGuiSliderFlags_AlwaysClamp);

                ImGui::ColorButton("##panel", ImVec4(0.7f, 0.1f, 0.7f, 1.0f), ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoDragDrop, ImVec2(128.0f, 96.0f)); // Dummy item
                if (ImGui::IsItemHovered() && capture_override_mouse != -1)
                    ImGui::SetNextFrameWantCaptureMouse(capture_override_mouse == 1);
                if (ImGui::IsItemHovered() && capture_override_keyboard != -1)
                    ImGui::SetNextFrameWantCaptureKeyboard(capture_override_keyboard == 1);

                ImGui::TreePop();
            }
            ImGui::TreePop();
        }

        // Demonstrate using Shortcut() and Routing Policies.
        // The general flow is:
        // - Code interested in a chord (e.g. "Ctrl+A") declares their intent.
        // - Multiple locations may be interested in same chord! Routing helps find a winner.
        // - Every frame, we resolve all claims and assign one owner if the modifiers are matching.
        // - The lower-level function is 'bool SetShortcutRouting()', returns true when caller got the route.
        // - Most of the times, SetShortcutRouting() is not called directly. User mostly calls Shortcut() with routing flags.
        // - If you call Shortcut() WITHOUT any routing option, it uses ImGuiInputFlags_RouteFocused.
        // TL;DR: Most uses will simply be:
        // - Shortcut(ImGuiMod_Ctrl | ImGuiKey_A); // Use ImGuiInputFlags_RouteFocused policy.
        IMGUI_DEMO_MARKER("Inputs & Focus/Shortcuts");
        if (ImGui::TreeNode("Shortcuts"))
        {
            static ImGuiInputFlags route_options = ImGuiInputFlags_Repeat;
            static ImGuiInputFlags route_type = ImGuiInputFlags_RouteFocused;
            ImGui::CheckboxFlags("ImGuiInputFlags_Repeat", &route_options, ImGuiInputFlags_Repeat);
            ImGui::RadioButton("ImGuiInputFlags_RouteActive", &route_type, ImGuiInputFlags_RouteActive);
            ImGui::RadioButton("ImGuiInputFlags_RouteFocused (default)", &route_type, ImGuiInputFlags_RouteFocused);
            ImGui::RadioButton("ImGuiInputFlags_RouteGlobal", &route_type, ImGuiInputFlags_RouteGlobal);
            ImGui::Indent();
            ImGui::BeginDisabled(route_type != ImGuiInputFlags_RouteGlobal);
            ImGui::CheckboxFlags("ImGuiInputFlags_RouteOverFocused", &route_options, ImGuiInputFlags_RouteOverFocused);
            ImGui::CheckboxFlags("ImGuiInputFlags_RouteOverActive", &route_options, ImGuiInputFlags_RouteOverActive);
            ImGui::CheckboxFlags("ImGuiInputFlags_RouteUnlessBgFocused", &route_options, ImGuiInputFlags_RouteUnlessBgFocused);
            ImGui::EndDisabled();
            ImGui::Unindent();
            ImGui::RadioButton("ImGuiInputFlags_RouteAlways", &route_type, ImGuiInputFlags_RouteAlways);
            ImGuiInputFlags flags = route_type | route_options; // Merged flags
            if (route_type != ImGuiInputFlags_RouteGlobal)
                flags &= ~(ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused);

            ImGui::SeparatorText("Using SetNextItemShortcut()");
            ImGui::Text("Ctrl+S");
            ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_S, flags | ImGuiInputFlags_Tooltip);
            ImGui::Button("Save");
            ImGui::Text("Alt+F");
            ImGui::SetNextItemShortcut(ImGuiMod_Alt | ImGuiKey_F, flags | ImGuiInputFlags_Tooltip);
            static float f = 0.5f;
            ImGui::SliderFloat("Factor", &f, 0.0f, 1.0f);

            ImGui::SeparatorText("Using Shortcut()");
            const float line_height = ImGui::GetTextLineHeightWithSpacing();
            const ImGuiKeyChord key_chord = ImGuiMod_Ctrl | ImGuiKey_A;

            ImGui::Text("Ctrl+A");
            ImGui::Text("IsWindowFocused: %d, Shortcut: %s", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? "PRESSED" : "...");

            ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(1.0f, 0.0f, 1.0f, 0.1f));

            ImGui::BeginChild("WindowA", ImVec2(-FLT_MIN, line_height * 14), true);
            ImGui::Text("Press CTRL+A and see who receives it!");
            ImGui::Separator();

            // 1: Window polling for CTRL+A
            ImGui::Text("(in WindowA)");
            ImGui::Text("IsWindowFocused: %d, Shortcut: %s", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? "PRESSED" : "...");

            // 2: InputText also polling for CTRL+A: it always uses _RouteFocused internally (gets priority when active)
            // (Commented because the owner-aware version of Shortcut() is still in imgui_internal.h)
            //char str[16] = "Press CTRL+A";
            //ImGui::Spacing();
            //ImGui::InputText("InputTextB", str, IM_ARRAYSIZE(str), ImGuiInputTextFlags_ReadOnly);
            //ImGuiID item_id = ImGui::GetItemID();
            //ImGui::SameLine(); HelpMarker("Internal widgets always use _RouteFocused");
            //ImGui::Text("IsWindowFocused: %d, Shortcut: %s", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags, item_id) ? "PRESSED" : "...");

            // 3: Dummy child is not claiming the route: focusing them shouldn't steal route away from WindowA
            ImGui::BeginChild("ChildD", ImVec2(-FLT_MIN, line_height * 4), true);
            ImGui::Text("(in ChildD: not using same Shortcut)");
            ImGui::Text("IsWindowFocused: %d", ImGui::IsWindowFocused());
            ImGui::EndChild();

            // 4: Child window polling for CTRL+A. It is deeper than WindowA and gets priority when focused.
            ImGui::BeginChild("ChildE", ImVec2(-FLT_MIN, line_height * 4), true);
            ImGui::Text("(in ChildE: using same Shortcut)");
            ImGui::Text("IsWindowFocused: %d, Shortcut: %s", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? "PRESSED" : "...");
            ImGui::EndChild();

            // 5: In a popup
            if (ImGui::Button("Open Popup"))
                ImGui::OpenPopup("PopupF");
            if (ImGui::BeginPopup("PopupF"))
            {
                ImGui::Text("(in PopupF)");
                ImGui::Text("IsWindowFocused: %d, Shortcut: %s", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags) ? "PRESSED" : "...");
                // (Commented because the owner-aware version of Shortcut() is still in imgui_internal.h)
                //ImGui::InputText("InputTextG", str, IM_ARRAYSIZE(str), ImGuiInputTextFlags_ReadOnly);
                //ImGui::Text("IsWindowFocused: %d, Shortcut: %s", ImGui::IsWindowFocused(), ImGui::Shortcut(key_chord, flags, ImGui::GetItemID()) ? "PRESSED" : "...");
                ImGui::EndPopup();
            }
            ImGui::EndChild();
            ImGui::PopStyleColor();

            ImGui::TreePop();
        }

        // Display mouse cursors
        IMGUI_DEMO_MARKER("Inputs & Focus/Mouse Cursors");
        if (ImGui::TreeNode("Mouse Cursors"))
        {
            const char* mouse_cursors_names[] = { "Arrow", "TextInput", "ResizeAll", "ResizeNS", "ResizeEW", "ResizeNESW", "ResizeNWSE", "Hand", "Wait", "Progress", "NotAllowed" };
            IM_ASSERT(IM_ARRAYSIZE(mouse_cursors_names) == ImGuiMouseCursor_COUNT);

            ImGuiMouseCursor current = ImGui::GetMouseCursor();
            const char* cursor_name = (current >= ImGuiMouseCursor_Arrow) && (current < ImGuiMouseCursor_COUNT) ? mouse_cursors_names[current] : "N/A";
            ImGui::Text("Current mouse cursor = %d: %s", current, cursor_name);
            ImGui::BeginDisabled(true);
            ImGui::CheckboxFlags("io.BackendFlags: HasMouseCursors", &io.BackendFlags, ImGuiBackendFlags_HasMouseCursors);
            ImGui::EndDisabled();

            ImGui::Text("Hover to see mouse cursors:");
            ImGui::SameLine(); HelpMarker(
                "Your application can render a different mouse cursor based on what ImGui::GetMouseCursor() returns. "
                "If software cursor rendering (io.MouseDrawCursor) is set ImGui will draw the right cursor for you, "
                "otherwise your backend needs to handle it.");
            for (int i = 0; i < ImGuiMouseCursor_COUNT; i++)
            {
                char label[32];
                sprintf(label, "Mouse cursor %d: %s", i, mouse_cursors_names[i]);
                ImGui::Bullet(); ImGui::Selectable(label, false);
                if (ImGui::IsItemHovered())
                    ImGui::SetMouseCursor(i);
            }
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Inputs & Focus/Tabbing");
        if (ImGui::TreeNode("Tabbing"))
        {
            ImGui::Text("Use TAB/SHIFT+TAB to cycle through keyboard editable fields.");
            static char buf[32] = "hello";
            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));
            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));
            ImGui::InputText("3", buf, IM_ARRAYSIZE(buf));
            ImGui::PushItemFlag(ImGuiItemFlags_NoTabStop, true);
            ImGui::InputText("4 (tab skip)", buf, IM_ARRAYSIZE(buf));
            ImGui::SameLine(); HelpMarker("Item won't be cycled through when using TAB or Shift+Tab.");
            ImGui::PopItemFlag();
            ImGui::InputText("5", buf, IM_ARRAYSIZE(buf));
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Inputs & Focus/Focus from code");
        if (ImGui::TreeNode("Focus from code"))
        {
            bool focus_1 = ImGui::Button("Focus on 1"); ImGui::SameLine();
            bool focus_2 = ImGui::Button("Focus on 2"); ImGui::SameLine();
            bool focus_3 = ImGui::Button("Focus on 3");
            int has_focus = 0;
            static char buf[128] = "click on a button to set focus";

            if (focus_1) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("1", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 1;

            if (focus_2) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("2", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 2;

            ImGui::PushItemFlag(ImGuiItemFlags_NoTabStop, true);
            if (focus_3) ImGui::SetKeyboardFocusHere();
            ImGui::InputText("3 (tab skip)", buf, IM_ARRAYSIZE(buf));
            if (ImGui::IsItemActive()) has_focus = 3;
            ImGui::SameLine(); HelpMarker("Item won't be cycled through when using TAB or Shift+Tab.");
            ImGui::PopItemFlag();

            if (has_focus)
                ImGui::Text("Item with focus: %d", has_focus);
            else
                ImGui::Text("Item with focus: <none>");

            // Use >= 0 parameter to SetKeyboardFocusHere() to focus an upcoming item
            static float f3[3] = { 0.0f, 0.0f, 0.0f };
            int focus_ahead = -1;
            if (ImGui::Button("Focus on X")) { focus_ahead = 0; } ImGui::SameLine();
            if (ImGui::Button("Focus on Y")) { focus_ahead = 1; } ImGui::SameLine();
            if (ImGui::Button("Focus on Z")) { focus_ahead = 2; }
            if (focus_ahead != -1) ImGui::SetKeyboardFocusHere(focus_ahead);
            ImGui::SliderFloat3("Float3", &f3[0], 0.0f, 1.0f);

            ImGui::TextWrapped("NB: Cursor & selection are preserved when refocusing last used item in code.");
            ImGui::TreePop();
        }

        IMGUI_DEMO_MARKER("Inputs & Focus/Dragging");
        if (ImGui::TreeNode("Dragging"))
        {
            ImGui::TextWrapped("You can use ImGui::GetMouseDragDelta(0) to query for the dragged amount on any widget.");
            for (int button = 0; button < 3; button++)
            {
                ImGui::Text("IsMouseDragging(%d):", button);
                ImGui::Text("  w/ default threshold: %d,", ImGui::IsMouseDragging(button));
                ImGui::Text("  w/ zero threshold: %d,", ImGui::IsMouseDragging(button, 0.0f));
                ImGui::Text("  w/ large threshold: %d,", ImGui::IsMouseDragging(button, 20.0f));
            }

            ImGui::Button("Drag Me");
            if (ImGui::IsItemActive())
                ImGui::GetForegroundDrawList()->AddLine(io.MouseClickedPos[0], io.MousePos, ImGui::GetColorU32(ImGuiCol_Button), 4.0f); // Draw a line between the button and the mouse cursor

            // Drag operations gets "unlocked" when the mouse has moved past a certain threshold
            // (the default threshold is stored in io.MouseDragThreshold). You can request a lower or higher
            // threshold using the second parameter of IsMouseDragging() and GetMouseDragDelta().
            ImVec2 value_raw = ImGui::GetMouseDragDelta(0, 0.0f);
            ImVec2 value_with_lock_threshold = ImGui::GetMouseDragDelta(0);
            ImVec2 mouse_delta = io.MouseDelta;
            ImGui::Text("GetMouseDragDelta(0):");
            ImGui::Text("  w/ default threshold: (%.1f, %.1f)", value_with_lock_threshold.x, value_with_lock_threshold.y);
            ImGui::Text("  w/ zero threshold: (%.1f, %.1f)", value_raw.x, value_raw.y);
            ImGui::Text("io.MouseDelta: (%.1f, %.1f)", mouse_delta.x, mouse_delta.y);
            ImGui::TreePop();
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] About Window / ShowAboutWindow()
// Access from Dear ImGui Demo -> Tools -> About
//-----------------------------------------------------------------------------

void ImGui::ShowAboutWindow(bool* p_open)
{
    if (!ImGui::Begin("About Dear ImGui", p_open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }
    IMGUI_DEMO_MARKER("Tools/About Dear ImGui");
    ImGui::Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);

    ImGui::TextLinkOpenURL("Homepage", "https://github.com/ocornut/imgui");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("FAQ", "https://github.com/ocornut/imgui/blob/master/docs/FAQ.md");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Wiki", "https://github.com/ocornut/imgui/wiki");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Extensions", "https://github.com/ocornut/imgui/wiki/Useful-Extensions");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Releases", "https://github.com/ocornut/imgui/releases");
    ImGui::SameLine();
    ImGui::TextLinkOpenURL("Funding", "https://github.com/ocornut/imgui/wiki/Funding");

    ImGui::Separator();
    ImGui::Text("(c) 2014-2025 Omar Cornut");
    ImGui::Text("Developed by Omar Cornut and all Dear ImGui contributors.");
    ImGui::Text("Dear ImGui is licensed under the MIT License, see LICENSE for more information.");
    ImGui::Text("If your company uses this, please consider funding the project.");

    static bool show_config_info = false;
    ImGui::Checkbox("Config/Build Information", &show_config_info);
    if (show_config_info)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImGuiStyle& style = ImGui::GetStyle();

        bool copy_to_clipboard = ImGui::Button("Copy to clipboard");
        ImVec2 child_size = ImVec2(0, ImGui::GetTextLineHeightWithSpacing() * 18);
        ImGui::BeginChild(ImGui::GetID("cfg_infos"), child_size, ImGuiChildFlags_FrameStyle);
        if (copy_to_clipboard)
        {
            ImGui::LogToClipboard();
            ImGui::LogText("```cpp\n"); // Back quotes will make text appears without formatting when pasting on GitHub
        }

        ImGui::Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);
        ImGui::Separator();
        ImGui::Text("sizeof(size_t): %d, sizeof(ImDrawIdx): %d, sizeof(ImDrawVert): %d", (int)sizeof(size_t), (int)sizeof(ImDrawIdx), (int)sizeof(ImDrawVert));
        ImGui::Text("define: __cplusplus=%d", (int)__cplusplus);
#ifdef IMGUI_ENABLE_TEST_ENGINE
        ImGui::Text("define: IMGUI_ENABLE_TEST_ENGINE");
#endif
#ifdef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_OBSOLETE_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_WIN32_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_WIN32_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_FILE_FUNCTIONS
        ImGui::Text("define: IMGUI_DISABLE_FILE_FUNCTIONS");
#endif
#ifdef IMGUI_DISABLE_DEFAULT_ALLOCATORS
        ImGui::Text("define: IMGUI_DISABLE_DEFAULT_ALLOCATORS");
#endif
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
        ImGui::Text("define: IMGUI_USE_BGRA_PACKED_COLOR");
#endif
#ifdef _WIN32
        ImGui::Text("define: _WIN32");
#endif
#ifdef _WIN64
        ImGui::Text("define: _WIN64");
#endif
#ifdef __linux__
        ImGui::Text("define: __linux__");
#endif
#ifdef __APPLE__
        ImGui::Text("define: __APPLE__");
#endif
#ifdef _MSC_VER
        ImGui::Text("define: _MSC_VER=%d", _MSC_VER);
#endif
#ifdef _MSVC_LANG
        ImGui::Text("define: _MSVC_LANG=%d", (int)_MSVC_LANG);
#endif
#ifdef __MINGW32__
        ImGui::Text("define: __MINGW32__");
#endif
#ifdef __MINGW64__
        ImGui::Text("define: __MINGW64__");
#endif
#ifdef __GNUC__
        ImGui::Text("define: __GNUC__=%d", (int)__GNUC__);
#endif
#ifdef __clang_version__
        ImGui::Text("define: __clang_version__=%s", __clang_version__);
#endif
#ifdef __EMSCRIPTEN__
        ImGui::Text("define: __EMSCRIPTEN__");
        ImGui::Text("Emscripten: %d.%d.%d", __EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__);
#endif
        ImGui::Separator();
        ImGui::Text("io.BackendPlatformName: %s", io.BackendPlatformName ? io.BackendPlatformName : "NULL");
        ImGui::Text("io.BackendRendererName: %s", io.BackendRendererName ? io.BackendRendererName : "NULL");
        ImGui::Text("io.ConfigFlags: 0x%08X", io.ConfigFlags);
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)        ImGui::Text(" NavEnableKeyboard");
        if (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad)         ImGui::Text(" NavEnableGamepad");
        if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)                  ImGui::Text(" NoMouse");
        if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)      ImGui::Text(" NoMouseCursorChange");
        if (io.ConfigFlags & ImGuiConfigFlags_NoKeyboard)               ImGui::Text(" NoKeyboard");
        if (io.MouseDrawCursor)                                         ImGui::Text("io.MouseDrawCursor");
        if (io.ConfigMacOSXBehaviors)                                   ImGui::Text("io.ConfigMacOSXBehaviors");
        if (io.ConfigNavMoveSetMousePos)                                ImGui::Text("io.ConfigNavMoveSetMousePos");
        if (io.ConfigNavCaptureKeyboard)                                ImGui::Text("io.ConfigNavCaptureKeyboard");
        if (io.ConfigInputTextCursorBlink)                              ImGui::Text("io.ConfigInputTextCursorBlink");
        if (io.ConfigWindowsResizeFromEdges)                            ImGui::Text("io.ConfigWindowsResizeFromEdges");
        if (io.ConfigWindowsMoveFromTitleBarOnly)                       ImGui::Text("io.ConfigWindowsMoveFromTitleBarOnly");
        if (io.ConfigMemoryCompactTimer >= 0.0f)                        ImGui::Text("io.ConfigMemoryCompactTimer = %.1f", io.ConfigMemoryCompactTimer);
        ImGui::Text("io.BackendFlags: 0x%08X", io.BackendFlags);
        if (io.BackendFlags & ImGuiBackendFlags_HasGamepad)             ImGui::Text(" HasGamepad");
        if (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)        ImGui::Text(" HasMouseCursors");
        if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos)         ImGui::Text(" HasSetMousePos");
        if (io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)   ImGui::Text(" RendererHasVtxOffset");
        if (io.BackendFlags & ImGuiBackendFlags_RendererHasTextures)    ImGui::Text(" RendererHasTextures");
        ImGui::Separator();
        ImGui::Text("io.Fonts: %d fonts, Flags: 0x%08X, TexSize: %d,%d", io.Fonts->Fonts.Size, io.Fonts->Flags, io.Fonts->TexData->Width, io.Fonts->TexData->Height);
        ImGui::Text("io.Fonts->FontLoaderName: %s", io.Fonts->FontLoaderName ? io.Fonts->FontLoaderName : "NULL");
        ImGui::Text("io.DisplaySize: %.2f,%.2f", io.DisplaySize.x, io.DisplaySize.y);
        ImGui::Text("io.DisplayFramebufferScale: %.2f,%.2f", io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
        ImGui::Separator();
        ImGui::Text("style.WindowPadding: %.2f,%.2f", style.WindowPadding.x, style.WindowPadding.y);
        ImGui::Text("style.WindowBorderSize: %.2f", style.WindowBorderSize);
        ImGui::Text("style.FramePadding: %.2f,%.2f", style.FramePadding.x, style.FramePadding.y);
        ImGui::Text("style.FrameRounding: %.2f", style.FrameRounding);
        ImGui::Text("style.FrameBorderSize: %.2f", style.FrameBorderSize);
        ImGui::Text("style.ItemSpacing: %.2f,%.2f", style.ItemSpacing.x, style.ItemSpacing.y);
        ImGui::Text("style.ItemInnerSpacing: %.2f,%.2f", style.ItemInnerSpacing.x, style.ItemInnerSpacing.y);

        if (copy_to_clipboard)
        {
            ImGui::LogText("\n```\n");
            ImGui::LogFinish();
        }
        ImGui::EndChild();
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Style Editor / ShowStyleEditor()
//-----------------------------------------------------------------------------
// - ShowStyleSelector()
// - ShowStyleEditor()
//-----------------------------------------------------------------------------

// Demo helper function to select among default colors. See ShowStyleEditor() for more advanced options.
bool ImGui::ShowStyleSelector(const char* label)
{
    // FIXME: This is a bit tricky to get right as style are functions, they don't register a name nor the fact that one is active.
    // So we keep track of last active one among our limited selection.
    static int style_idx = -1;
    const char* style_names[] = { "Dark", "Light", "Classic" };
    bool ret = false;
    if (ImGui::BeginCombo(label, (style_idx >= 0 && style_idx < IM_ARRAYSIZE(style_names)) ? style_names[style_idx] : ""))
    {
        for (int n = 0; n < IM_ARRAYSIZE(style_names); n++)
        {
            if (ImGui::Selectable(style_names[n], style_idx == n, ImGuiSelectableFlags_SelectOnNav))
            {
                style_idx = n;
                ret = true;
                switch (style_idx)
                {
                case 0: ImGui::StyleColorsDark(); break;
                case 1: ImGui::StyleColorsLight(); break;
                case 2: ImGui::StyleColorsClassic(); break;
                }
            }
            else if (style_idx == n)
                ImGui::SetItemDefaultFocus();
        }
        ImGui::EndCombo();
    }
    return ret;
}

static const char* GetTreeLinesFlagsName(ImGuiTreeNodeFlags flags)
{
    if (flags == ImGuiTreeNodeFlags_DrawLinesNone) return "DrawLinesNone";
    if (flags == ImGuiTreeNodeFlags_DrawLinesFull) return "DrawLinesFull";
    if (flags == ImGuiTreeNodeFlags_DrawLinesToNodes) return "DrawLinesToNodes";
    return "";
}

// We omit the ImGui:: prefix in this function, as we don't expect user to be copy and pasting this code.
void ImGui::ShowStyleEditor(ImGuiStyle* ref)
{
    IMGUI_DEMO_MARKER("Tools/Style Editor");
    // You can pass in a reference ImGuiStyle structure to compare to, revert to and save to
    // (without a reference style pointer, we will use one compared locally as a reference)
    ImGuiStyle& style = GetStyle();
    static ImGuiStyle ref_saved_style;

    // Default to using internal storage as reference
    static bool init = true;
    if (init && ref == NULL)
        ref_saved_style = style;
    init = false;
    if (ref == NULL)
        ref = &ref_saved_style;

    PushItemWidth(GetWindowWidth() * 0.50f);

    {
        // General
        SeparatorText("General");
        if ((GetIO().BackendFlags & ImGuiBackendFlags_RendererHasTextures) == 0)
        {
            BulletText("Warning: Font scaling will NOT be smooth, because\nImGuiBackendFlags_RendererHasTextures is not set!");
            BulletText("For instructions, see:");
            SameLine();
            TextLinkOpenURL("docs/BACKENDS.md", "https://github.com/ocornut/imgui/blob/master/docs/BACKENDS.md");
        }

        if (ShowStyleSelector("Colors##Selector"))
            ref_saved_style = style;
        ShowFontSelector("Fonts##Selector");
        if (DragFloat("FontSizeBase", &style.FontSizeBase, 0.20f, 5.0f, 100.0f, "%.0f"))
            style._NextFrameFontSizeBase = style.FontSizeBase; // FIXME: Temporary hack until we finish remaining work.
        SameLine(0.0f, 0.0f); Text(" (out %.2f)", GetFontSize());
        DragFloat("FontScaleMain", &style.FontScaleMain, 0.02f, 0.5f, 4.0f);
        //BeginDisabled(GetIO().ConfigDpiScaleFonts);
        DragFloat("FontScaleDpi", &style.FontScaleDpi, 0.02f, 0.5f, 4.0f);
        //SetItemTooltip("When io.ConfigDpiScaleFonts is set, this value is automatically overwritten.");
        //EndDisabled();

        // Simplified Settings (expose floating-pointer border sizes as boolean representing 0.0f or 1.0f)
        if (SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f"))
            style.GrabRounding = style.FrameRounding; // Make GrabRounding always the same value as FrameRounding
        { bool border = (style.WindowBorderSize > 0.0f); if (Checkbox("WindowBorder", &border)) { style.WindowBorderSize = border ? 1.0f : 0.0f; } }
        SameLine();
        { bool border = (style.FrameBorderSize > 0.0f);  if (Checkbox("FrameBorder", &border)) { style.FrameBorderSize = border ? 1.0f : 0.0f; } }
        SameLine();
        { bool border = (style.PopupBorderSize > 0.0f);  if (Checkbox("PopupBorder", &border)) { style.PopupBorderSize = border ? 1.0f : 0.0f; } }
    }

    // Save/Revert button
    if (Button("Save Ref"))
        *ref = ref_saved_style = style;
    SameLine();
    if (Button("Revert Ref"))
        style = *ref;
    SameLine();
    HelpMarker(
        "Save/Revert in local non-persistent storage. Default Colors definition are not affected. "
        "Use \"Export\" below to save them somewhere.");

    SeparatorText("Details");
    if (BeginTabBar("##tabs", ImGuiTabBarFlags_None))
    {
        if (BeginTabItem("Sizes"))
        {
            SeparatorText("Main");
            SliderFloat2("WindowPadding", (float*)&style.WindowPadding, 0.0f, 20.0f, "%.0f");
            SliderFloat2("FramePadding", (float*)&style.FramePadding, 0.0f, 20.0f, "%.0f");
            SliderFloat2("ItemSpacing", (float*)&style.ItemSpacing, 0.0f, 20.0f, "%.0f");
            SliderFloat2("ItemInnerSpacing", (float*)&style.ItemInnerSpacing, 0.0f, 20.0f, "%.0f");
            SliderFloat2("TouchExtraPadding", (float*)&style.TouchExtraPadding, 0.0f, 10.0f, "%.0f");
            SliderFloat("IndentSpacing", &style.IndentSpacing, 0.0f, 30.0f, "%.0f");
            SliderFloat("GrabMinSize", &style.GrabMinSize, 1.0f, 20.0f, "%.0f");

            SeparatorText("Borders");
            SliderFloat("WindowBorderSize", &style.WindowBorderSize, 0.0f, 1.0f, "%.0f");
            SliderFloat("ChildBorderSize", &style.ChildBorderSize, 0.0f, 1.0f, "%.0f");
            SliderFloat("PopupBorderSize", &style.PopupBorderSize, 0.0f, 1.0f, "%.0f");
            SliderFloat("FrameBorderSize", &style.FrameBorderSize, 0.0f, 1.0f, "%.0f");

            SeparatorText("Rounding");
            SliderFloat("WindowRounding", &style.WindowRounding, 0.0f, 12.0f, "%.0f");
            SliderFloat("ChildRounding", &style.ChildRounding, 0.0f, 12.0f, "%.0f");
            SliderFloat("FrameRounding", &style.FrameRounding, 0.0f, 12.0f, "%.0f");
            SliderFloat("PopupRounding", &style.PopupRounding, 0.0f, 12.0f, "%.0f");
            SliderFloat("GrabRounding", &style.GrabRounding, 0.0f, 12.0f, "%.0f");

            SeparatorText("Scrollbar");
            SliderFloat("ScrollbarSize", &style.ScrollbarSize, 1.0f, 20.0f, "%.0f");
            SliderFloat("ScrollbarRounding", &style.ScrollbarRounding, 0.0f, 12.0f, "%.0f");
            SliderFloat("ScrollbarPadding", &style.ScrollbarPadding, 0.0f, 10.0f, "%.0f");

            SeparatorText("Tabs");
            SliderFloat("TabBorderSize", &style.TabBorderSize, 0.0f, 1.0f, "%.0f");
            SliderFloat("TabBarBorderSize", &style.TabBarBorderSize, 0.0f, 2.0f, "%.0f");
            SliderFloat("TabBarOverlineSize", &style.TabBarOverlineSize, 0.0f, 3.0f, "%.0f");
            SameLine(); HelpMarker("Overline is only drawn over the selected tab when ImGuiTabBarFlags_DrawSelectedOverline is set.");
            DragFloat("TabMinWidthBase", &style.TabMinWidthBase, 0.5f, 1.0f, 500.0f, "%.0f");
            DragFloat("TabMinWidthShrink", &style.TabMinWidthShrink, 0.5f, 1.0f, 500.0f, "%0.f");
            DragFloat("TabCloseButtonMinWidthSelected", &style.TabCloseButtonMinWidthSelected, 0.5f, -1.0f, 100.0f, (style.TabCloseButtonMinWidthSelected < 0.0f) ? "%.0f (Always)" : "%.0f");
            DragFloat("TabCloseButtonMinWidthUnselected", &style.TabCloseButtonMinWidthUnselected, 0.5f, -1.0f, 100.0f, (style.TabCloseButtonMinWidthUnselected < 0.0f) ? "%.0f (Always)" : "%.0f");
            SliderFloat("TabRounding", &style.TabRounding, 0.0f, 12.0f, "%.0f");

            SeparatorText("Tables");
            SliderFloat2("CellPadding", (float*)&style.CellPadding, 0.0f, 20.0f, "%.0f");
            SliderAngle("TableAngledHeadersAngle", &style.TableAngledHeadersAngle, -50.0f, +50.0f);
            SliderFloat2("TableAngledHeadersTextAlign", (float*)&style.TableAngledHeadersTextAlign, 0.0f, 1.0f, "%.2f");

            SeparatorText("Trees");
            bool combo_open = BeginCombo("TreeLinesFlags", GetTreeLinesFlagsName(style.TreeLinesFlags));
            SameLine();
            HelpMarker("[Experimental] Tree lines may not work in all situations (e.g. using a clipper) and may incurs slight traversal overhead.\n\nImGuiTreeNodeFlags_DrawLinesFull is faster than ImGuiTreeNodeFlags_DrawLinesToNode.");
            if (combo_open)
            {
                const ImGuiTreeNodeFlags options[] = { ImGuiTreeNodeFlags_DrawLinesNone, ImGuiTreeNodeFlags_DrawLinesFull, ImGuiTreeNodeFlags_DrawLinesToNodes };
                for (ImGuiTreeNodeFlags option : options)
                    if (Selectable(GetTreeLinesFlagsName(option), style.TreeLinesFlags == option))
                        style.TreeLinesFlags = option;
                EndCombo();
            }
            SliderFloat("TreeLinesSize", &style.TreeLinesSize, 0.0f, 2.0f, "%.0f");
            SliderFloat("TreeLinesRounding", &style.TreeLinesRounding, 0.0f, 12.0f, "%.0f");

            SeparatorText("Windows");
            SliderFloat2("WindowTitleAlign", (float*)&style.WindowTitleAlign, 0.0f, 1.0f, "%.2f");
            SliderFloat("WindowBorderHoverPadding", &style.WindowBorderHoverPadding, 1.0f, 20.0f, "%.0f");
            int window_menu_button_position = style.WindowMenuButtonPosition + 1;
            if (Combo("WindowMenuButtonPosition", (int*)&window_menu_button_position, "None\0Left\0Right\0"))
                style.WindowMenuButtonPosition = (ImGuiDir)(window_menu_button_position - 1);

            SeparatorText("Widgets");
            Combo("ColorButtonPosition", (int*)&style.ColorButtonPosition, "Left\0Right\0");
            SliderFloat2("ButtonTextAlign", (float*)&style.ButtonTextAlign, 0.0f, 1.0f, "%.2f");
            SameLine(); HelpMarker("Alignment applies when a button is larger than its text content.");
            SliderFloat2("SelectableTextAlign", (float*)&style.SelectableTextAlign, 0.0f, 1.0f, "%.2f");
            SameLine(); HelpMarker("Alignment applies when a selectable is larger than its text content.");
            SliderFloat("SeparatorTextBorderSize", &style.SeparatorTextBorderSize, 0.0f, 10.0f, "%.0f");
            SliderFloat2("SeparatorTextAlign", (float*)&style.SeparatorTextAlign, 0.0f, 1.0f, "%.2f");
            SliderFloat2("SeparatorTextPadding", (float*)&style.SeparatorTextPadding, 0.0f, 40.0f, "%.0f");
            SliderFloat("LogSliderDeadzone", &style.LogSliderDeadzone, 0.0f, 12.0f, "%.0f");
            SliderFloat("ImageBorderSize", &style.ImageBorderSize, 0.0f, 1.0f, "%.0f");

            SeparatorText("Tooltips");
            for (int n = 0; n < 2; n++)
                if (TreeNodeEx(n == 0 ? "HoverFlagsForTooltipMouse" : "HoverFlagsForTooltipNav"))
                {
                    ImGuiHoveredFlags* p = (n == 0) ? &style.HoverFlagsForTooltipMouse : &style.HoverFlagsForTooltipNav;
                    CheckboxFlags("ImGuiHoveredFlags_DelayNone", p, ImGuiHoveredFlags_DelayNone);
                    CheckboxFlags("ImGuiHoveredFlags_DelayShort", p, ImGuiHoveredFlags_DelayShort);
                    CheckboxFlags("ImGuiHoveredFlags_DelayNormal", p, ImGuiHoveredFlags_DelayNormal);
                    CheckboxFlags("ImGuiHoveredFlags_Stationary", p, ImGuiHoveredFlags_Stationary);
                    CheckboxFlags("ImGuiHoveredFlags_NoSharedDelay", p, ImGuiHoveredFlags_NoSharedDelay);
                    TreePop();
                }

            SeparatorText("Misc");
            SliderFloat2("DisplayWindowPadding", (float*)&style.DisplayWindowPadding, 0.0f, 30.0f, "%.0f"); SameLine(); HelpMarker("Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.");
            SliderFloat2("DisplaySafeAreaPadding", (float*)&style.DisplaySafeAreaPadding, 0.0f, 30.0f, "%.0f"); SameLine(); HelpMarker("Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).");

            EndTabItem();
        }

        if (BeginTabItem("Colors"))
        {
            static int output_dest = 0;
            static bool output_only_modified = true;
            if (Button("Export"))
            {
                if (output_dest == 0)
                    LogToClipboard();
                else
                    LogToTTY();
                LogText("ImVec4* colors = GetStyle().Colors;" IM_NEWLINE);
                for (int i = 0; i < ImGuiCol_COUNT; i++)
                {
                    const ImVec4& col = style.Colors[i];
                    const char* name = GetStyleColorName(i);
                    if (!output_only_modified || memcmp(&col, &ref->Colors[i], sizeof(ImVec4)) != 0)
                        LogText("colors[ImGuiCol_%s]%*s= ImVec4(%.2ff, %.2ff, %.2ff, %.2ff);" IM_NEWLINE,
                            name, 23 - (int)strlen(name), "", col.x, col.y, col.z, col.w);
                }
                LogFinish();
            }
            SameLine(); SetNextItemWidth(120); Combo("##output_type", &output_dest, "To Clipboard\0To TTY\0");
            SameLine(); Checkbox("Only Modified Colors", &output_only_modified);

            static ImGuiTextFilter filter;
            filter.Draw("Filter colors", GetFontSize() * 16);

            static ImGuiColorEditFlags alpha_flags = 0;
            if (RadioButton("Opaque", alpha_flags == ImGuiColorEditFlags_AlphaOpaque))       { alpha_flags = ImGuiColorEditFlags_AlphaOpaque; } SameLine();
            if (RadioButton("Alpha",  alpha_flags == ImGuiColorEditFlags_None))              { alpha_flags = ImGuiColorEditFlags_None; } SameLine();
            if (RadioButton("Both",   alpha_flags == ImGuiColorEditFlags_AlphaPreviewHalf))  { alpha_flags = ImGuiColorEditFlags_AlphaPreviewHalf; } SameLine();
            HelpMarker(
                "In the color list:\n"
                "Left-click on color square to open color picker,\n"
                "Right-click to open edit options menu.");

            SetNextWindowSizeConstraints(ImVec2(0.0f, GetTextLineHeightWithSpacing() * 10), ImVec2(FLT_MAX, FLT_MAX));
            BeginChild("##colors", ImVec2(0, 0), ImGuiChildFlags_Borders | ImGuiChildFlags_NavFlattened, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);
            PushItemWidth(GetFontSize() * -12);
            for (int i = 0; i < ImGuiCol_COUNT; i++)
            {
                const char* name = GetStyleColorName(i);
                if (!filter.PassFilter(name))
                    continue;
                PushID(i);
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
                if (Button("?"))
                    DebugFlashStyleColor((ImGuiCol)i);
                SetItemTooltip("Flash given color to identify places where it is used.");
                SameLine();
#endif
                ColorEdit4("##color", (float*)&style.Colors[i], ImGuiColorEditFlags_AlphaBar | alpha_flags);
                if (memcmp(&style.Colors[i], &ref->Colors[i], sizeof(ImVec4)) != 0)
                {
                    // Tips: in a real user application, you may want to merge and use an icon font into the main font,
                    // so instead of "Save"/"Revert" you'd use icons!
                    // Read the FAQ and docs/FONTS.md about using icon fonts. It's really easy and super convenient!
                    SameLine(0.0f, style.ItemInnerSpacing.x); if (Button("Save")) { ref->Colors[i] = style.Colors[i]; }
                    SameLine(0.0f, style.ItemInnerSpacing.x); if (Button("Revert")) { style.Colors[i] = ref->Colors[i]; }
                }
                SameLine(0.0f, style.ItemInnerSpacing.x);
                TextUnformatted(name);
                PopID();
            }
            PopItemWidth();
            EndChild();

            EndTabItem();
        }

        if (BeginTabItem("Fonts"))
        {
            ImGuiIO& io = GetIO();
            ImFontAtlas* atlas = io.Fonts;
            ShowFontAtlas(atlas);

            // Post-baking font scaling. Note that this is NOT the nice way of scaling fonts, read below.
            // (we enforce hard clamping manually as by default DragFloat/SliderFloat allows CTRL+Click text to get out of bounds).
            /*
            SeparatorText("Legacy Scaling");
            const float MIN_SCALE = 0.3f;
            const float MAX_SCALE = 2.0f;
            HelpMarker(
                "Those are old settings provided for convenience.\n"
                "However, the _correct_ way of scaling your UI is currently to reload your font at the designed size, "
                "rebuild the font atlas, and call style.ScaleAllSizes() on a reference ImGuiStyle structure.\n"
                "Using those settings here will give you poor quality results.");
            PushItemWidth(GetFontSize() * 8);
            DragFloat("global scale", &io.FontGlobalScale, 0.005f, MIN_SCALE, MAX_SCALE, "%.2f", ImGuiSliderFlags_AlwaysClamp); // Scale everything
            //static float window_scale = 1.0f;
            //if (DragFloat("window scale", &window_scale, 0.005f, MIN_SCALE, MAX_SCALE, "%.2f", ImGuiSliderFlags_AlwaysClamp)) // Scale only this window
            //    SetWindowFontScale(window_scale);
            PopItemWidth();
            */

            EndTabItem();
        }

        if (BeginTabItem("Rendering"))
        {
            Checkbox("Anti-aliased lines", &style.AntiAliasedLines);
            SameLine();
            HelpMarker("When disabling anti-aliasing lines, you'll probably want to disable borders in your style as well.");

            Checkbox("Anti-aliased lines use texture", &style.AntiAliasedLinesUseTex);
            SameLine();
            HelpMarker("Faster lines using texture data. Require backend to render with bilinear filtering (not point/nearest filtering).");

            Checkbox("Anti-aliased fill", &style.AntiAliasedFill);
            PushItemWidth(GetFontSize() * 8);
            DragFloat("Curve Tessellation Tolerance", &style.CurveTessellationTol, 0.02f, 0.10f, 10.0f, "%.2f");
            if (style.CurveTessellationTol < 0.10f) style.CurveTessellationTol = 0.10f;

            // When editing the "Circle Segment Max Error" value, draw a preview of its effect on auto-tessellated circles.
            DragFloat("Circle Tessellation Max Error", &style.CircleTessellationMaxError , 0.005f, 0.10f, 5.0f, "%.2f", ImGuiSliderFlags_AlwaysClamp);
            const bool show_samples = IsItemActive();
            if (show_samples)
                SetNextWindowPos(GetCursorScreenPos());
            if (show_samples && BeginTooltip())
            {
                TextUnformatted("(R = radius, N = approx number of segments)");
                Spacing();
                ImDrawList* draw_list = GetWindowDrawList();
                const float min_widget_width = CalcTextSize("R: MMM\nN: MMM").x;
                for (int n = 0; n < 8; n++)
                {
                    const float RAD_MIN = 5.0f;
                    const float RAD_MAX = 70.0f;
                    const float rad = RAD_MIN + (RAD_MAX - RAD_MIN) * (float)n / (8.0f - 1.0f);

                    BeginGroup();

                    // N is not always exact here due to how PathArcTo() function work internally
                    Text("R: %.f\nN: %d", rad, draw_list->_CalcCircleAutoSegmentCount(rad));

                    const float canvas_width = IM_MAX(min_widget_width, rad * 2.0f);
                    const float offset_x     = floorf(canvas_width * 0.5f);
                    const float offset_y     = floorf(RAD_MAX);

                    const ImVec2 p1 = GetCursorScreenPos();
                    draw_list->AddCircle(ImVec2(p1.x + offset_x, p1.y + offset_y), rad, GetColorU32(ImGuiCol_Text));
                    Dummy(ImVec2(canvas_width, RAD_MAX * 2));

                    /*
                    const ImVec2 p2 = GetCursorScreenPos();
                    draw_list->AddCircleFilled(ImVec2(p2.x + offset_x, p2.y + offset_y), rad, GetColorU32(ImGuiCol_Text));
                    Dummy(ImVec2(canvas_width, RAD_MAX * 2));
                    */

                    EndGroup();
                    SameLine();
                }
                EndTooltip();
            }
            SameLine();
            HelpMarker("When drawing circle primitives with \"num_segments == 0\" tessellation will be calculated automatically.");

            DragFloat("Global Alpha", &style.Alpha, 0.005f, 0.20f, 1.0f, "%.2f"); // Not exposing zero here so user doesn't "lose" the UI (zero alpha clips all widgets). But application code could have a toggle to switch between zero and non-zero.
            DragFloat("Disabled Alpha", &style.DisabledAlpha, 0.005f, 0.0f, 1.0f, "%.2f"); SameLine(); HelpMarker("Additional alpha multiplier for disabled items (multiply over current value of Alpha).");
            PopItemWidth();

            EndTabItem();
        }

        EndTabBar();
    }
    PopItemWidth();
}

//-----------------------------------------------------------------------------
// [SECTION] User Guide / ShowUserGuide()
//-----------------------------------------------------------------------------

// We omit the ImGui:: prefix in this function, as we don't expect user to be copy and pasting this code.
void ImGui::ShowUserGuide()
{
    ImGuiIO& io = GetIO();
    BulletText("Double-click on title bar to collapse window.");
    BulletText(
        "Click and drag on lower corner to resize window\n"
        "(double-click to auto fit window to its contents).");
    BulletText("CTRL+Click on a slider or drag box to input value as text.");
    BulletText("TAB/SHIFT+TAB to cycle through keyboard editable fields.");
    BulletText("CTRL+Tab to select a window.");
    if (io.FontAllowUserScaling)
        BulletText("CTRL+Mouse Wheel to zoom window contents.");
    BulletText("While inputting text:\n");
    Indent();
    BulletText("CTRL+Left/Right to word jump.");
    BulletText("CTRL+A or double-click to select all.");
    BulletText("CTRL+X/C/V to use clipboard cut/copy/paste.");
    BulletText("CTRL+Z to undo, CTRL+Y/CTRL+SHIFT+Z to redo.");
    BulletText("ESCAPE to revert.");
    Unindent();
    BulletText("With keyboard navigation enabled:");
    Indent();
    BulletText("Arrow keys to navigate.");
    BulletText("Space to activate a widget.");
    BulletText("Return to input text into a widget.");
    BulletText("Escape to deactivate a widget, close popup, exit child window.");
    BulletText("Alt to jump to the menu layer of a window.");
    Unindent();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()
//-----------------------------------------------------------------------------
// - ShowExampleAppMainMenuBar()
// - ShowExampleMenuFile()
//-----------------------------------------------------------------------------

// Demonstrate creating a "main" fullscreen menu bar and populating it.
// Note the difference between BeginMainMenuBar() and BeginMenuBar():
// - BeginMenuBar() = menu-bar inside current window (which needs the ImGuiWindowFlags_MenuBar flag!)
// - BeginMainMenuBar() = helper to create menu-bar-sized window at the top of the main viewport + call BeginMenuBar() into it.
static void ShowExampleAppMainMenuBar()
{
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            ShowExampleMenuFile();
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Undo", "CTRL+Z")) {}
            if (ImGui::MenuItem("Redo", "CTRL+Y", false, false)) {} // Disabled item
            ImGui::Separator();
            if (ImGui::MenuItem("Cut", "CTRL+X")) {}
            if (ImGui::MenuItem("Copy", "CTRL+C")) {}
            if (ImGui::MenuItem("Paste", "CTRL+V")) {}
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }
}

// Note that shortcuts are currently provided for display only
// (future version will add explicit flags to BeginMenu() to request processing shortcuts)
static void ShowExampleMenuFile()
{
    IMGUI_DEMO_MARKER("Examples/Menu");
    ImGui::MenuItem("(demo menu)", NULL, false, false);
    if (ImGui::MenuItem("New")) {}
    if (ImGui::MenuItem("Open", "Ctrl+O")) {}
    if (ImGui::BeginMenu("Open Recent"))
    {
        ImGui::MenuItem("fish_hat.c");
        ImGui::MenuItem("fish_hat.inl");
        ImGui::MenuItem("fish_hat.h");
        if (ImGui::BeginMenu("More.."))
        {
            ImGui::MenuItem("Hello");
            ImGui::MenuItem("Sailor");
            if (ImGui::BeginMenu("Recurse.."))
            {
                ShowExampleMenuFile();
                ImGui::EndMenu();
            }
            ImGui::EndMenu();
        }
        ImGui::EndMenu();
    }
    if (ImGui::MenuItem("Save", "Ctrl+S")) {}
    if (ImGui::MenuItem("Save As..")) {}

    ImGui::Separator();
    IMGUI_DEMO_MARKER("Examples/Menu/Options");
    if (ImGui::BeginMenu("Options"))
    {
        static bool enabled = true;
        ImGui::MenuItem("Enabled", "", &enabled);
        ImGui::BeginChild("child", ImVec2(0, 60), ImGuiChildFlags_Borders);
        for (int i = 0; i < 10; i++)
            ImGui::Text("Scrolling Text %d", i);
        ImGui::EndChild();
        static float f = 0.5f;
        static int n = 0;
        ImGui::SliderFloat("Value", &f, 0.0f, 1.0f);
        ImGui::InputFloat("Input", &f, 0.1f);
        ImGui::Combo("Combo", &n, "Yes\0No\0Maybe\0\0");
        ImGui::EndMenu();
    }

    IMGUI_DEMO_MARKER("Examples/Menu/Colors");
    if (ImGui::BeginMenu("Colors"))
    {
        float sz = ImGui::GetTextLineHeight();
        for (int i = 0; i < ImGuiCol_COUNT; i++)
        {
            const char* name = ImGui::GetStyleColorName((ImGuiCol)i);
            ImVec2 p = ImGui::GetCursorScreenPos();
            ImGui::GetWindowDrawList()->AddRectFilled(p, ImVec2(p.x + sz, p.y + sz), ImGui::GetColorU32((ImGuiCol)i));
            ImGui::Dummy(ImVec2(sz, sz));
            ImGui::SameLine();
            ImGui::MenuItem(name);
        }
        ImGui::EndMenu();
    }

    // Here we demonstrate appending again to the "Options" menu (which we already created above)
    // Of course in this demo it is a little bit silly that this function calls BeginMenu("Options") twice.
    // In a real code-base using it would make senses to use this feature from very different code locations.
    if (ImGui::BeginMenu("Options")) // <-- Append!
    {
        IMGUI_DEMO_MARKER("Examples/Menu/Append to an existing menu");
        static bool b = true;
        ImGui::Checkbox("SomeOption", &b);
        ImGui::EndMenu();
    }

    if (ImGui::BeginMenu("Disabled", false)) // Disabled
    {
        IM_ASSERT(0);
    }
    if (ImGui::MenuItem("Checked", NULL, true)) {}
    ImGui::Separator();
    if (ImGui::MenuItem("Quit", "Alt+F4")) {}
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Debug Console / ShowExampleAppConsole()
//-----------------------------------------------------------------------------

// Demonstrate creating a simple console window, with scrolling, filtering, completion and history.
// For the console example, we are using a more C++ like approach of declaring a class to hold both data and functions.
struct ExampleAppConsole
{
    char                  InputBuf[256];
    ImVector<char*>       Items;
    ImVector<const char*> Commands;
    ImVector<char*>       History;
    int                   HistoryPos;    // -1: new line, 0..History.Size-1 browsing history.
    ImGuiTextFilter       Filter;
    bool                  AutoScroll;
    bool                  ScrollToBottom;

    ExampleAppConsole()
    {
        IMGUI_DEMO_MARKER("Examples/Console");
        ClearLog();
        memset(InputBuf, 0, sizeof(InputBuf));
        HistoryPos = -1;

        // "CLASSIFY" is here to provide the test case where "C"+[tab] completes to "CL" and display multiple matches.
        Commands.push_back("HELP");
        Commands.push_back("HISTORY");
        Commands.push_back("CLEAR");
        Commands.push_back("CLASSIFY");
        AutoScroll = true;
        ScrollToBottom = false;
        AddLog("Welcome to Dear ImGui!");
    }
    ~ExampleAppConsole()
    {
        ClearLog();
        for (int i = 0; i < History.Size; i++)
            ImGui::MemFree(History[i]);
    }

    // Portable helpers
    static int   Stricmp(const char* s1, const char* s2)         { int d; while ((d = toupper(*s2) - toupper(*s1)) == 0 && *s1) { s1++; s2++; } return d; }
    static int   Strnicmp(const char* s1, const char* s2, int n) { int d = 0; while (n > 0 && (d = toupper(*s2) - toupper(*s1)) == 0 && *s1) { s1++; s2++; n--; } return d; }
    static char* Strdup(const char* s)                           { IM_ASSERT(s); size_t len = strlen(s) + 1; void* buf = ImGui::MemAlloc(len); IM_ASSERT(buf); return (char*)memcpy(buf, (const void*)s, len); }
    static void  Strtrim(char* s)                                { char* str_end = s + strlen(s); while (str_end > s && str_end[-1] == ' ') str_end--; *str_end = 0; }

    void    ClearLog()
    {
        for (int i = 0; i < Items.Size; i++)
            ImGui::MemFree(Items[i]);
        Items.clear();
    }

    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)
    {
        // FIXME-OPT
        char buf[1024];
        va_list args;
        va_start(args, fmt);
        vsnprintf(buf, IM_ARRAYSIZE(buf), fmt, args);
        buf[IM_ARRAYSIZE(buf)-1] = 0;
        va_end(args);
        Items.push_back(Strdup(buf));
    }

    void    Draw(const char* title, bool* p_open)
    {
        ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
        if (!ImGui::Begin(title, p_open))
        {
            ImGui::End();
            return;
        }

        // As a specific feature guaranteed by the library, after calling Begin() the last Item represent the title bar.
        // So e.g. IsItemHovered() will return true when hovering the title bar.
        // Here we create a context menu only available from the title bar.
        if (ImGui::BeginPopupContextItem())
        {
            if (ImGui::MenuItem("Close Console"))
                *p_open = false;
            ImGui::EndPopup();
        }

        ImGui::TextWrapped(
            "This example implements a console with basic coloring, completion (TAB key) and history (Up/Down keys). A more elaborate "
            "implementation may want to store entries along with extra data such as timestamp, emitter, etc.");
        ImGui::TextWrapped("Enter 'HELP' for help.");

        // TODO: display items starting from the bottom

        if (ImGui::SmallButton("Add Debug Text"))  { AddLog("%d some text", Items.Size); AddLog("some more text"); AddLog("display very important message here!"); }
        ImGui::SameLine();
        if (ImGui::SmallButton("Add Debug Error")) { AddLog("[error] something went wrong"); }
        ImGui::SameLine();
        if (ImGui::SmallButton("Clear"))           { ClearLog(); }
        ImGui::SameLine();
        bool copy_to_clipboard = ImGui::SmallButton("Copy");
        //static float t = 0.0f; if (ImGui::GetTime() - t > 0.02f) { t = ImGui::GetTime(); AddLog("Spam %f", t); }

        ImGui::Separator();

        // Options menu
        if (ImGui::BeginPopup("Options"))
        {
            ImGui::Checkbox("Auto-scroll", &AutoScroll);
            ImGui::EndPopup();
        }

        // Options, Filter
        ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_O, ImGuiInputFlags_Tooltip);
        if (ImGui::Button("Options"))
            ImGui::OpenPopup("Options");
        ImGui::SameLine();
        Filter.Draw("Filter (\"incl,-excl\") (\"error\")", 180);
        ImGui::Separator();

        // Reserve enough left-over height for 1 separator + 1 input text
        const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing();
        if (ImGui::BeginChild("ScrollingRegion", ImVec2(0, -footer_height_to_reserve), ImGuiChildFlags_NavFlattened, ImGuiWindowFlags_HorizontalScrollbar))
        {
            if (ImGui::BeginPopupContextWindow())
            {
                if (ImGui::Selectable("Clear")) ClearLog();
                ImGui::EndPopup();
            }

            // Display every line as a separate entry so we can change their color or add custom widgets.
            // If you only want raw text you can use ImGui::TextUnformatted(log.begin(), log.end());
            // NB- if you have thousands of entries this approach may be too inefficient and may require user-side clipping
            // to only process visible items. The clipper will automatically measure the height of your first item and then
            // "seek" to display only items in the visible area.
            // To use the clipper we can replace your standard loop:
            //      for (int i = 0; i < Items.Size; i++)
            //   With:
            //      ImGuiListClipper clipper;
            //      clipper.Begin(Items.Size);
            //      while (clipper.Step())
            //         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
            // - That your items are evenly spaced (same height)
            // - That you have cheap random access to your elements (you can access them given their index,
            //   without processing all the ones before)
            // You cannot this code as-is if a filter is active because it breaks the 'cheap random-access' property.
            // We would need random-access on the post-filtered list.
            // A typical application wanting coarse clipping and filtering may want to pre-compute an array of indices
            // or offsets of items that passed the filtering test, recomputing this array when user changes the filter,
            // and appending newly elements as they are inserted. This is left as a task to the user until we can manage
            // to improve this example code!
            // If your items are of variable height:
            // - Split them into same height items would be simpler and facilitate random-seeking into your list.
            // - Consider using manual call to IsRectVisible() and skipping extraneous decoration from your items.
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 1)); // Tighten spacing
            if (copy_to_clipboard)
                ImGui::LogToClipboard();
            for (const char* item : Items)
            {
                if (!Filter.PassFilter(item))
                    continue;

                // Normally you would store more information in your item than just a string.
                // (e.g. make Items[] an array of structure, store color/type etc.)
                ImVec4 color;
                bool has_color = false;
                if (strstr(item, "[error]")) { color = ImVec4(1.0f, 0.4f, 0.4f, 1.0f); has_color = true; }
                else if (strncmp(item, "# ", 2) == 0) { color = ImVec4(1.0f, 0.8f, 0.6f, 1.0f); has_color = true; }
                if (has_color)
                    ImGui::PushStyleColor(ImGuiCol_Text, color);
                ImGui::TextUnformatted(item);
                if (has_color)
                    ImGui::PopStyleColor();
            }
            if (copy_to_clipboard)
                ImGui::LogFinish();

            // Keep up at the bottom of the scroll region if we were already at the bottom at the beginning of the frame.
            // Using a scrollbar or mouse-wheel will take away from the bottom edge.
            if (ScrollToBottom || (AutoScroll && ImGui::GetScrollY() >= ImGui::GetScrollMaxY()))
                ImGui::SetScrollHereY(1.0f);
            ScrollToBottom = false;

            ImGui::PopStyleVar();
        }
        ImGui::EndChild();
        ImGui::Separator();

        // Command-line
        bool reclaim_focus = false;
        ImGuiInputTextFlags input_text_flags = ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_EscapeClearsAll | ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory;
        if (ImGui::InputText("Input", InputBuf, IM_ARRAYSIZE(InputBuf), input_text_flags, &TextEditCallbackStub, (void*)this))
        {
            char* s = InputBuf;
            Strtrim(s);
            if (s[0])
                ExecCommand(s);
            strcpy(s, "");
            reclaim_focus = true;
        }

        // Auto-focus on window apparition
        ImGui::SetItemDefaultFocus();
        if (reclaim_focus)
            ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget

        ImGui::End();
    }

    void    ExecCommand(const char* command_line)
    {
        AddLog("# %s\n", command_line);

        // Insert into history. First find match and delete it so it can be pushed to the back.
        // This isn't trying to be smart or optimal.
        HistoryPos = -1;
        for (int i = History.Size - 1; i >= 0; i--)
            if (Stricmp(History[i], command_line) == 0)
            {
                ImGui::MemFree(History[i]);
                History.erase(History.begin() + i);
                break;
            }
        History.push_back(Strdup(command_line));

        // Process command
        if (Stricmp(command_line, "CLEAR") == 0)
        {
            ClearLog();
        }
        else if (Stricmp(command_line, "HELP") == 0)
        {
            AddLog("Commands:");
            for (int i = 0; i < Commands.Size; i++)
                AddLog("- %s", Commands[i]);
        }
        else if (Stricmp(command_line, "HISTORY") == 0)
        {
            int first = History.Size - 10;
            for (int i = first > 0 ? first : 0; i < History.Size; i++)
                AddLog("%3d: %s\n", i, History[i]);
        }
        else
        {
            AddLog("Unknown command: '%s'\n", command_line);
        }

        // On command input, we scroll to bottom even if AutoScroll==false
        ScrollToBottom = true;
    }

    // In C++11 you'd be better off using lambdas for this sort of forwarding callbacks
    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data)
    {
        ExampleAppConsole* console = (ExampleAppConsole*)data->UserData;
        return console->TextEditCallback(data);
    }

    int     TextEditCallback(ImGuiInputTextCallbackData* data)
    {
        //AddLog("cursor: %d, selection: %d-%d", data->CursorPos, data->SelectionStart, data->SelectionEnd);
        switch (data->EventFlag)
        {
        case ImGuiInputTextFlags_CallbackCompletion:
            {
                // Example of TEXT COMPLETION

                // Locate beginning of current word
                const char* word_end = data->Buf + data->CursorPos;
                const char* word_start = word_end;
                while (word_start > data->Buf)
                {
                    const char c = word_start[-1];
                    if (c == ' ' || c == '\t' || c == ',' || c == ';')
                        break;
                    word_start--;
                }

                // Build a list of candidates
                ImVector<const char*> candidates;
                for (int i = 0; i < Commands.Size; i++)
                    if (Strnicmp(Commands[i], word_start, (int)(word_end - word_start)) == 0)
                        candidates.push_back(Commands[i]);

                if (candidates.Size == 0)
                {
                    // No match
                    AddLog("No match for \"%.*s\"!\n", (int)(word_end - word_start), word_start);
                }
                else if (candidates.Size == 1)
                {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing.
                    data->DeleteChars((int)(word_start - data->Buf), (int)(word_end - word_start));
                    data->InsertChars(data->CursorPos, candidates[0]);
                    data->InsertChars(data->CursorPos, " ");
                }
                else
                {
                    // Multiple matches. Complete as much as we can..
                    // So inputting "C"+Tab will complete to "CL" then display "CLEAR" and "CLASSIFY" as matches.
                    int match_len = (int)(word_end - word_start);
                    for (;;)
                    {
                        int c = 0;
                        bool all_candidates_matches = true;
                        for (int i = 0; i < candidates.Size && all_candidates_matches; i++)
                            if (i == 0)
                                c = toupper(candidates[i][match_len]);
                            else if (c == 0 || c != toupper(candidates[i][match_len]))
                                all_candidates_matches = false;
                        if (!all_candidates_matches)
                            break;
                        match_len++;
                    }

                    if (match_len > 0)
                    {
                        data->DeleteChars((int)(word_start - data->Buf), (int)(word_end - word_start));
                        data->InsertChars(data->CursorPos, candidates[0], candidates[0] + match_len);
                    }

                    // List matches
                    AddLog("Possible matches:\n");
                    for (int i = 0; i < candidates.Size; i++)
                        AddLog("- %s\n", candidates[i]);
                }

                break;
            }
        case ImGuiInputTextFlags_CallbackHistory:
            {
                // Example of HISTORY
                const int prev_history_pos = HistoryPos;
                if (data->EventKey == ImGuiKey_UpArrow)
                {
                    if (HistoryPos == -1)
                        HistoryPos = History.Size - 1;
                    else if (HistoryPos > 0)
                        HistoryPos--;
                }
                else if (data->EventKey == ImGuiKey_DownArrow)
                {
                    if (HistoryPos != -1)
                        if (++HistoryPos >= History.Size)
                            HistoryPos = -1;
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if (prev_history_pos != HistoryPos)
                {
                    const char* history_str = (HistoryPos >= 0) ? History[HistoryPos] : "";
                    data->DeleteChars(0, data->BufTextLen);
                    data->InsertChars(0, history_str);
                }
            }
        }
        return 0;
    }
};

static void ShowExampleAppConsole(bool* p_open)
{
    static ExampleAppConsole console;
    console.Draw("Example: Console", p_open);
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Debug Log / ShowExampleAppLog()
//-----------------------------------------------------------------------------

// Usage:
//  static ExampleAppLog my_log;
//  my_log.AddLog("Hello %d world\n", 123);
//  my_log.Draw("title");
struct ExampleAppLog
{
    ImGuiTextBuffer     Buf;
    ImGuiTextFilter     Filter;
    ImVector<int>       LineOffsets; // Index to lines offset. We maintain this with AddLog() calls.
    bool                AutoScroll;  // Keep scrolling if already at the bottom.

    ExampleAppLog()
    {
        AutoScroll = true;
        Clear();
    }

    void    Clear()
    {
        Buf.clear();
        LineOffsets.clear();
        LineOffsets.push_back(0);
    }

    void    AddLog(const char* fmt, ...) IM_FMTARGS(2)
    {
        int old_size = Buf.size();
        va_list args;
        va_start(args, fmt);
        Buf.appendfv(fmt, args);
        va_end(args);
        for (int new_size = Buf.size(); old_size < new_size; old_size++)
            if (Buf[old_size] == '\n')
                LineOffsets.push_back(old_size + 1);
    }

    void    Draw(const char* title, bool* p_open = NULL)
    {
        if (!ImGui::Begin(title, p_open))
        {
            ImGui::End();
            return;
        }

        // Options menu
        if (ImGui::BeginPopup("Options"))
        {
            ImGui::Checkbox("Auto-scroll", &AutoScroll);
            ImGui::EndPopup();
        }

        // Main window
        if (ImGui::Button("Options"))
            ImGui::OpenPopup("Options");
        ImGui::SameLine();
        bool clear = ImGui::Button("Clear");
        ImGui::SameLine();
        bool copy = ImGui::Button("Copy");
        ImGui::SameLine();
        Filter.Draw("Filter", -100.0f);

        ImGui::Separator();

        if (ImGui::BeginChild("scrolling", ImVec2(0, 0), ImGuiChildFlags_None, ImGuiWindowFlags_HorizontalScrollbar))
        {
            if (clear)
                Clear();
            if (copy)
                ImGui::LogToClipboard();

            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
            const char* buf = Buf.begin();
            const char* buf_end = Buf.end();
            if (Filter.IsActive())
            {
                // In this example we don't use the clipper when Filter is enabled.
                // This is because we don't have random access to the result of our filter.
                // A real application processing logs with ten of thousands of entries may want to store the result of
                // search/filter.. especially if the filtering function is not trivial (e.g. reg-exp).
                for (int line_no = 0; line_no < LineOffsets.Size; line_no++)
                {
                    const char* line_start = buf + LineOffsets[line_no];
                    const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;
                    if (Filter.PassFilter(line_start, line_end))
                        ImGui::TextUnformatted(line_start, line_end);
                }
            }
            else
            {
                // The simplest and easy way to display the entire buffer:
                //   ImGui::TextUnformatted(buf_begin, buf_end);
                // And it'll just work. TextUnformatted() has specialization for large blob of text and will fast-forward
                // to skip non-visible lines. Here we instead demonstrate using the clipper to only process lines that are
                // within the visible area.
                // If you have tens of thousands of items and their processing cost is non-negligible, coarse clipping them
                // on your side is recommended. Using ImGuiListClipper requires
                // - A) random access into your data
                // - B) items all being the  same height,
                // both of which we can handle since we have an array pointing to the beginning of each line of text.
                // When using the filter (in the block of code above) we don't have random access into the data to display
                // anymore, which is why we don't use the clipper. Storing or skimming through the search result would make
                // it possible (and would be recommended if you want to search through tens of thousands of entries).
                ImGuiListClipper clipper;
                clipper.Begin(LineOffsets.Size);
                while (clipper.Step())
                {
                    for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)
                    {
                        const char* line_start = buf + LineOffsets[line_no];
                        const char* line_end = (line_no + 1 < LineOffsets.Size) ? (buf + LineOffsets[line_no + 1] - 1) : buf_end;
                        ImGui::TextUnformatted(line_start, line_end);
                    }
                }
                clipper.End();
            }
            ImGui::PopStyleVar();

            // Keep up at the bottom of the scroll region if we were already at the bottom at the beginning of the frame.
            // Using a scrollbar or mouse-wheel will take away from the bottom edge.
            if (AutoScroll && ImGui::GetScrollY() >= ImGui::GetScrollMaxY())
                ImGui::SetScrollHereY(1.0f);
        }
        ImGui::EndChild();
        ImGui::End();
    }
};

// Demonstrate creating a simple log window with basic filtering.
static void ShowExampleAppLog(bool* p_open)
{
    static ExampleAppLog log;

    // For the demo: add a debug button _BEFORE_ the normal log window contents
    // We take advantage of a rarely used feature: multiple calls to Begin()/End() are appending to the _same_ window.
    // Most of the contents of the window will be added by the log.Draw() call.
    ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);
    ImGui::Begin("Example: Log", p_open);
    IMGUI_DEMO_MARKER("Examples/Log");
    if (ImGui::SmallButton("[Debug] Add 5 entries"))
    {
        static int counter = 0;
        const char* categories[3] = { "info", "warn", "error" };
        const char* words[] = { "Bumfuzzled", "Cattywampus", "Snickersnee", "Abibliophobia", "Absquatulate", "Nincompoop", "Pauciloquent" };
        for (int n = 0; n < 5; n++)
        {
            const char* category = categories[counter % IM_ARRAYSIZE(categories)];
            const char* word = words[counter % IM_ARRAYSIZE(words)];
            log.AddLog("[%05d] [%s] Hello, current time is %.1f, here's a word: '%s'\n",
                ImGui::GetFrameCount(), category, ImGui::GetTime(), word);
            counter++;
        }
    }
    ImGui::End();

    // Actually call in the regular Log helper (which will Begin() into the same window as we just did)
    log.Draw("Example: Log", p_open);
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()
//-----------------------------------------------------------------------------

// Demonstrate create a window with multiple child windows.
static void ShowExampleAppLayout(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(500, 440), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Example: Simple layout", p_open, ImGuiWindowFlags_MenuBar))
    {
        IMGUI_DEMO_MARKER("Examples/Simple layout");
        if (ImGui::BeginMenuBar())
        {
            if (ImGui::BeginMenu("File"))
            {
                if (ImGui::MenuItem("Close", "Ctrl+W")) { *p_open = false; }
                ImGui::EndMenu();
            }
            ImGui::EndMenuBar();
        }

        // Left
        static int selected = 0;
        {
            ImGui::BeginChild("left pane", ImVec2(150, 0), ImGuiChildFlags_Borders | ImGuiChildFlags_ResizeX);
            for (int i = 0; i < 100; i++)
            {
                char label[128];
                sprintf(label, "MyObject %d", i);
                if (ImGui::Selectable(label, selected == i, ImGuiSelectableFlags_SelectOnNav))
                    selected = i;
            }
            ImGui::EndChild();
        }
        ImGui::SameLine();

        // Right
        {
            ImGui::BeginGroup();
            ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetFrameHeightWithSpacing())); // Leave room for 1 line below us
            ImGui::Text("MyObject: %d", selected);
            ImGui::Separator();
            if (ImGui::BeginTabBar("##Tabs", ImGuiTabBarFlags_None))
            {
                if (ImGui::BeginTabItem("Description"))
                {
                    ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ");
                    ImGui::EndTabItem();
                }
                if (ImGui::BeginTabItem("Details"))
                {
                    ImGui::Text("ID: 0123456789");
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
            }
            ImGui::EndChild();
            if (ImGui::Button("Revert")) {}
            ImGui::SameLine();
            if (ImGui::Button("Save")) {}
            ImGui::EndGroup();
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()
//-----------------------------------------------------------------------------
// Some of the interactions are a bit lack-luster:
// - We would want pressing validating or leaving the filter to somehow restore focus.
// - We may want more advanced filtering (child nodes) and clipper support: both will need extra work.
// - We would want to customize some keyboard interactions to easily keyboard navigate between the tree and the properties.
//-----------------------------------------------------------------------------

struct ExampleAppPropertyEditor
{
    ImGuiTextFilter     Filter;
    ExampleTreeNode*    VisibleNode = NULL;

    void Draw(ExampleTreeNode* root_node)
    {
        // Left side: draw tree
        // - Currently using a table to benefit from RowBg feature
        if (ImGui::BeginChild("##tree", ImVec2(300, 0), ImGuiChildFlags_ResizeX | ImGuiChildFlags_Borders | ImGuiChildFlags_NavFlattened))
        {
            ImGui::SetNextItemWidth(-FLT_MIN);
            ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_F, ImGuiInputFlags_Tooltip);
            ImGui::PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
            if (ImGui::InputTextWithHint("##Filter", "incl,-excl", Filter.InputBuf, IM_ARRAYSIZE(Filter.InputBuf), ImGuiInputTextFlags_EscapeClearsAll))
                Filter.Build();
            ImGui::PopItemFlag();

            if (ImGui::BeginTable("##bg", 1, ImGuiTableFlags_RowBg))
            {
                for (ExampleTreeNode* node : root_node->Childs)
                    if (Filter.PassFilter(node->Name)) // Filter root node
                        DrawTreeNode(node);
                ImGui::EndTable();
            }
        }
        ImGui::EndChild();

        // Right side: draw properties
        ImGui::SameLine();

        ImGui::BeginGroup(); // Lock X position
        if (ExampleTreeNode* node = VisibleNode)
        {
            ImGui::Text("%s", node->Name);
            ImGui::TextDisabled("UID: 0x%08X", node->UID);
            ImGui::Separator();
            if (ImGui::BeginTable("##properties", 2, ImGuiTableFlags_Resizable | ImGuiTableFlags_ScrollY))
            {
                // Push object ID after we entered the table, so table is shared for all objects
                ImGui::PushID((int)node->UID);
                ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthFixed);
                ImGui::TableSetupColumn("", ImGuiTableColumnFlags_WidthStretch, 2.0f); // Default twice larger
                if (node->HasData)
                {
                    // In a typical application, the structure description would be derived from a data-driven system.
                    // - We try to mimic this with our ExampleMemberInfo structure and the ExampleTreeNodeMemberInfos[] array.
                    // - Limits and some details are hard-coded to simplify the demo.
                    for (const ExampleMemberInfo& field_desc : ExampleTreeNodeMemberInfos)
                    {
                        ImGui::TableNextRow();
                        ImGui::PushID(field_desc.Name);
                        ImGui::TableNextColumn();
                        ImGui::AlignTextToFramePadding();
                        ImGui::TextUnformatted(field_desc.Name);
                        ImGui::TableNextColumn();
                        void* field_ptr = (void*)(((unsigned char*)node) + field_desc.Offset);
                        switch (field_desc.DataType)
                        {
                        case ImGuiDataType_Bool:
                        {
                            IM_ASSERT(field_desc.DataCount == 1);
                            ImGui::Checkbox("##Editor", (bool*)field_ptr);
                            break;
                        }
                        case ImGuiDataType_S32:
                        {
                            int v_min = INT_MIN, v_max = INT_MAX;
                            ImGui::SetNextItemWidth(-FLT_MIN);
                            ImGui::DragScalarN("##Editor", field_desc.DataType, field_ptr, field_desc.DataCount, 1.0f, &v_min, &v_max);
                            break;
                        }
                        case ImGuiDataType_Float:
                        {
                            float v_min = 0.0f, v_max = 1.0f;
                            ImGui::SetNextItemWidth(-FLT_MIN);
                            ImGui::SliderScalarN("##Editor", field_desc.DataType, field_ptr, field_desc.DataCount, &v_min, &v_max);
                            break;
                        }
                        case ImGuiDataType_String:
                        {
                            ImGui::InputText("##Editor", reinterpret_cast<char*>(field_ptr), 28);
                            break;
                        }
                        }
                        ImGui::PopID();
                    }
                }
                ImGui::PopID();
                ImGui::EndTable();
            }
        }
        ImGui::EndGroup();
    }

    void DrawTreeNode(ExampleTreeNode* node)
    {
        ImGui::TableNextRow();
        ImGui::TableNextColumn();
        ImGui::PushID(node->UID);
        ImGuiTreeNodeFlags tree_flags = ImGuiTreeNodeFlags_None;
        tree_flags |= ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick;// Standard opening mode as we are likely to want to add selection afterwards
        tree_flags |= ImGuiTreeNodeFlags_NavLeftJumpsToParent;  // Left arrow support
        tree_flags |= ImGuiTreeNodeFlags_SpanFullWidth;         // Span full width for easier mouse reach
        tree_flags |= ImGuiTreeNodeFlags_DrawLinesToNodes;      // Always draw hierarchy outlines
        if (node == VisibleNode)
            tree_flags |= ImGuiTreeNodeFlags_Selected;
        if (node->Childs.Size == 0)
            tree_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_Bullet;
        if (node->DataMyBool == false)
            ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_TextDisabled]);
        bool node_open = ImGui::TreeNodeEx("", tree_flags, "%s", node->Name);
        if (node->DataMyBool == false)
            ImGui::PopStyleColor();
        if (ImGui::IsItemFocused())
            VisibleNode = node;
        if (node_open)
        {
            for (ExampleTreeNode* child : node->Childs)
                DrawTreeNode(child);
            ImGui::TreePop();
        }
        ImGui::PopID();
    }
};

// Demonstrate creating a simple property editor.
static void ShowExampleAppPropertyEditor(bool* p_open, ImGuiDemoWindowData* demo_data)
{
    ImGui::SetNextWindowSize(ImVec2(430, 450), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Property editor", p_open))
    {
        ImGui::End();
        return;
    }

    IMGUI_DEMO_MARKER("Examples/Property Editor");
    static ExampleAppPropertyEditor property_editor;
    if (demo_data->DemoTree == NULL)
        demo_data->DemoTree = ExampleTree_CreateDemoTree();
    property_editor.Draw(demo_data->DemoTree);

    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Long Text / ShowExampleAppLongText()
//-----------------------------------------------------------------------------

// Demonstrate/test rendering huge amount of text, and the incidence of clipping.
static void ShowExampleAppLongText(bool* p_open)
{
    ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Example: Long text display", p_open))
    {
        ImGui::End();
        return;
    }
    IMGUI_DEMO_MARKER("Examples/Long text display");

    static int test_type = 0;
    static ImGuiTextBuffer log;
    static int lines = 0;
    ImGui::Text("Printing unusually long amount of text.");
    ImGui::Combo("Test type", &test_type,
        "Single call to TextUnformatted()\0"
        "Multiple calls to Text(), clipped\0"
        "Multiple calls to Text(), not clipped (slow)\0");
    ImGui::Text("Buffer contents: %d lines, %d bytes", lines, log.size());
    if (ImGui::Button("Clear")) { log.clear(); lines = 0; }
    ImGui::SameLine();
    if (ImGui::Button("Add 1000 lines"))
    {
        for (int i = 0; i < 1000; i++)
            log.appendf("%i The quick brown fox jumps over the lazy dog\n", lines + i);
        lines += 1000;
    }
    ImGui::BeginChild("Log");
    switch (test_type)
    {
    case 0:
        // Single call to TextUnformatted() with a big buffer
        ImGui::TextUnformatted(log.begin(), log.end());
        break;
    case 1:
        {
            // Multiple calls to Text(), manually coarsely clipped - demonstrate how to use the ImGuiListClipper helper.
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
            ImGuiListClipper clipper;
            clipper.Begin(lines);
            while (clipper.Step())
                for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
                    ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);
            ImGui::PopStyleVar();
            break;
        }
    case 2:
        // Multiple calls to Text(), not clipped (slow)
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
        for (int i = 0; i < lines; i++)
            ImGui::Text("%i The quick brown fox jumps over the lazy dog", i);
        ImGui::PopStyleVar();
        break;
    }
    ImGui::EndChild();
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()
//-----------------------------------------------------------------------------

// Demonstrate creating a window which gets auto-resized according to its content.
static void ShowExampleAppAutoResize(bool* p_open)
{
    if (!ImGui::Begin("Example: Auto-resizing window", p_open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::End();
        return;
    }
    IMGUI_DEMO_MARKER("Examples/Auto-resizing window");

    static int lines = 10;
    ImGui::TextUnformatted(
        "Window will resize every-frame to the size of its content.\n"
        "Note that you probably don't want to query the window size to\n"
        "output your content because that would create a feedback loop.");
    ImGui::SliderInt("Number of lines", &lines, 1, 20);
    for (int i = 0; i < lines; i++)
        ImGui::Text("%*sThis is line %d", i * 4, "", i); // Pad with space to extend size horizontally
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()
//-----------------------------------------------------------------------------

// Demonstrate creating a window with custom resize constraints.
// Note that size constraints currently don't work on a docked window (when in 'docking' branch)
static void ShowExampleAppConstrainedResize(bool* p_open)
{
    struct CustomConstraints
    {
        // Helper functions to demonstrate programmatic constraints
        // FIXME: This doesn't take account of decoration size (e.g. title bar), library should make this easier.
        // FIXME: None of the three demos works consistently when resizing from borders.
        static void AspectRatio(ImGuiSizeCallbackData* data)
        {
            float aspect_ratio = *(float*)data->UserData;
            data->DesiredSize.y = (float)(int)(data->DesiredSize.x / aspect_ratio);
        }
        static void Square(ImGuiSizeCallbackData* data)
        {
            data->DesiredSize.x = data->DesiredSize.y = IM_MAX(data->DesiredSize.x, data->DesiredSize.y);
        }
        static void Step(ImGuiSizeCallbackData* data)
        {
            float step = *(float*)data->UserData;
            data->DesiredSize = ImVec2((int)(data->DesiredSize.x / step + 0.5f) * step, (int)(data->DesiredSize.y / step + 0.5f) * step);
        }
    };

    const char* test_desc[] =
    {
        "Between 100x100 and 500x500",
        "At least 100x100",
        "Resize vertical + lock current width",
        "Resize horizontal + lock current height",
        "Width Between 400 and 500",
        "Height at least 400",
        "Custom: Aspect Ratio 16:9",
        "Custom: Always Square",
        "Custom: Fixed Steps (100)",
    };

    // Options
    static bool auto_resize = false;
    static bool window_padding = true;
    static int type = 6; // Aspect Ratio
    static int display_lines = 10;

    // Submit constraint
    float aspect_ratio = 16.0f / 9.0f;
    float fixed_step = 100.0f;
    if (type == 0) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(500, 500));         // Between 100x100 and 500x500
    if (type == 1) ImGui::SetNextWindowSizeConstraints(ImVec2(100, 100), ImVec2(FLT_MAX, FLT_MAX)); // Width > 100, Height > 100
    if (type == 2) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 0),    ImVec2(-1, FLT_MAX));      // Resize vertical + lock current width
    if (type == 3) ImGui::SetNextWindowSizeConstraints(ImVec2(0, -1),    ImVec2(FLT_MAX, -1));      // Resize horizontal + lock current height
    if (type == 4) ImGui::SetNextWindowSizeConstraints(ImVec2(400, -1),  ImVec2(500, -1));          // Width Between and 400 and 500
    if (type == 5) ImGui::SetNextWindowSizeConstraints(ImVec2(-1, 400),  ImVec2(-1, FLT_MAX));      // Height at least 400
    if (type == 6) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::AspectRatio, (void*)&aspect_ratio);   // Aspect ratio
    if (type == 7) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Square);                              // Always Square
    if (type == 8) ImGui::SetNextWindowSizeConstraints(ImVec2(0, 0),     ImVec2(FLT_MAX, FLT_MAX), CustomConstraints::Step, (void*)&fixed_step);            // Fixed Step

    // Submit window
    if (!window_padding)
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
    const ImGuiWindowFlags window_flags = auto_resize ? ImGuiWindowFlags_AlwaysAutoResize : 0;
    const bool window_open = ImGui::Begin("Example: Constrained Resize", p_open, window_flags);
    if (!window_padding)
        ImGui::PopStyleVar();
    if (window_open)
    {
        IMGUI_DEMO_MARKER("Examples/Constrained Resizing window");
        if (ImGui::GetIO().KeyShift)
        {
            // Display a dummy viewport (in your real app you would likely use ImageButton() to display a texture)
            ImVec2 avail_size = ImGui::GetContentRegionAvail();
            ImVec2 pos = ImGui::GetCursorScreenPos();
            ImGui::ColorButton("viewport", ImVec4(0.5f, 0.2f, 0.5f, 1.0f), ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_NoDragDrop, avail_size);
            ImGui::SetCursorScreenPos(ImVec2(pos.x + 10, pos.y + 10));
            ImGui::Text("%.2f x %.2f", avail_size.x, avail_size.y);
        }
        else
        {
            ImGui::Text("(Hold SHIFT to display a dummy viewport)");
            if (ImGui::Button("Set 200x200")) { ImGui::SetWindowSize(ImVec2(200, 200)); } ImGui::SameLine();
            if (ImGui::Button("Set 500x500")) { ImGui::SetWindowSize(ImVec2(500, 500)); } ImGui::SameLine();
            if (ImGui::Button("Set 800x200")) { ImGui::SetWindowSize(ImVec2(800, 200)); }
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 20);
            ImGui::Combo("Constraint", &type, test_desc, IM_ARRAYSIZE(test_desc));
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 20);
            ImGui::DragInt("Lines", &display_lines, 0.2f, 1, 100);
            ImGui::Checkbox("Auto-resize", &auto_resize);
            ImGui::Checkbox("Window padding", &window_padding);
            for (int i = 0; i < display_lines; i++)
                ImGui::Text("%*sHello, sailor! Making this line long enough for the example.", i * 4, "");
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()
//-----------------------------------------------------------------------------

// Demonstrate creating a simple static window with no decoration
// + a context-menu to choose which corner of the screen to use.
static void ShowExampleAppSimpleOverlay(bool* p_open)
{
    static int location = 0;
    ImGuiIO& io = ImGui::GetIO();
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav;
    if (location >= 0)
    {
        const float PAD = 10.0f;
        const ImGuiViewport* viewport = ImGui::GetMainViewport();
        ImVec2 work_pos = viewport->WorkPos; // Use work area to avoid menu-bar/task-bar, if any!
        ImVec2 work_size = viewport->WorkSize;
        ImVec2 window_pos, window_pos_pivot;
        window_pos.x = (location & 1) ? (work_pos.x + work_size.x - PAD) : (work_pos.x + PAD);
        window_pos.y = (location & 2) ? (work_pos.y + work_size.y - PAD) : (work_pos.y + PAD);
        window_pos_pivot.x = (location & 1) ? 1.0f : 0.0f;
        window_pos_pivot.y = (location & 2) ? 1.0f : 0.0f;
        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
        window_flags |= ImGuiWindowFlags_NoMove;
    }
    else if (location == -2)
    {
        // Center window
        ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
        window_flags |= ImGuiWindowFlags_NoMove;
    }
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    if (ImGui::Begin("Example: Simple overlay", p_open, window_flags))
    {
        IMGUI_DEMO_MARKER("Examples/Simple Overlay");
        ImGui::Text("Simple overlay\n" "(right-click to change position)");
        ImGui::Separator();
        if (ImGui::IsMousePosValid())
            ImGui::Text("Mouse Position: (%.1f,%.1f)", io.MousePos.x, io.MousePos.y);
        else
            ImGui::Text("Mouse Position: <invalid>");
        if (ImGui::BeginPopupContextWindow())
        {
            if (ImGui::MenuItem("Custom",       NULL, location == -1)) location = -1;
            if (ImGui::MenuItem("Center",       NULL, location == -2)) location = -2;
            if (ImGui::MenuItem("Top-left",     NULL, location == 0)) location = 0;
            if (ImGui::MenuItem("Top-right",    NULL, location == 1)) location = 1;
            if (ImGui::MenuItem("Bottom-left",  NULL, location == 2)) location = 2;
            if (ImGui::MenuItem("Bottom-right", NULL, location == 3)) location = 3;
            if (p_open && ImGui::MenuItem("Close")) *p_open = false;
            ImGui::EndPopup();
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()
//-----------------------------------------------------------------------------

// Demonstrate creating a window covering the entire screen/viewport
static void ShowExampleAppFullscreen(bool* p_open)
{
    static bool use_work_area = true;
    static ImGuiWindowFlags flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings;

    // We demonstrate using the full viewport area or the work area (without menu-bars, task-bars etc.)
    // Based on your use case you may want one or the other.
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(use_work_area ? viewport->WorkPos : viewport->Pos);
    ImGui::SetNextWindowSize(use_work_area ? viewport->WorkSize : viewport->Size);

    if (ImGui::Begin("Example: Fullscreen window", p_open, flags))
    {
        ImGui::Checkbox("Use work area instead of main area", &use_work_area);
        ImGui::SameLine();
        HelpMarker("Main Area = entire viewport,\nWork Area = entire viewport minus sections used by the main menu bars, task bars etc.\n\nEnable the main-menu bar in Examples menu to see the difference.");

        ImGui::CheckboxFlags("ImGuiWindowFlags_NoBackground", &flags, ImGuiWindowFlags_NoBackground);
        ImGui::CheckboxFlags("ImGuiWindowFlags_NoDecoration", &flags, ImGuiWindowFlags_NoDecoration);
        ImGui::Indent();
        ImGui::CheckboxFlags("ImGuiWindowFlags_NoTitleBar", &flags, ImGuiWindowFlags_NoTitleBar);
        ImGui::CheckboxFlags("ImGuiWindowFlags_NoCollapse", &flags, ImGuiWindowFlags_NoCollapse);
        ImGui::CheckboxFlags("ImGuiWindowFlags_NoScrollbar", &flags, ImGuiWindowFlags_NoScrollbar);
        ImGui::Unindent();

        if (p_open && ImGui::Button("Close this window"))
            *p_open = false;
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Manipulating Window Titles / ShowExampleAppWindowTitles()
//-----------------------------------------------------------------------------

// Demonstrate the use of "##" and "###" in identifiers to manipulate ID generation.
// This applies to all regular items as well.
// Read FAQ section "How can I have multiple widgets with the same label?" for details.
static void ShowExampleAppWindowTitles(bool*)
{
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    const ImVec2 base_pos = viewport->Pos;

    // By default, Windows are uniquely identified by their title.
    // You can use the "##" and "###" markers to manipulate the display/ID.

    // Using "##" to display same title but have unique identifier.
    ImGui::SetNextWindowPos(ImVec2(base_pos.x + 100, base_pos.y + 100), ImGuiCond_FirstUseEver);
    ImGui::Begin("Same title as another window##1");
    IMGUI_DEMO_MARKER("Examples/Manipulating window titles");
    ImGui::Text("This is window 1.\nMy title is the same as window 2, but my identifier is unique.");
    ImGui::End();

    ImGui::SetNextWindowPos(ImVec2(base_pos.x + 100, base_pos.y + 200), ImGuiCond_FirstUseEver);
    ImGui::Begin("Same title as another window##2");
    ImGui::Text("This is window 2.\nMy title is the same as window 1, but my identifier is unique.");
    ImGui::End();

    // Using "###" to display a changing title but keep a static identifier "AnimatedTitle"
    char buf[128];
    sprintf(buf, "Animated title %c %d###AnimatedTitle", "|/-\\"[(int)(ImGui::GetTime() / 0.25f) & 3], ImGui::GetFrameCount());
    ImGui::SetNextWindowPos(ImVec2(base_pos.x + 100, base_pos.y + 300), ImGuiCond_FirstUseEver);
    ImGui::Begin(buf);
    ImGui::Text("This window has a changing title.");
    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()
//-----------------------------------------------------------------------------

// Add a |_| looking shape
static void PathConcaveShape(ImDrawList* draw_list, float x, float y, float sz)
{
    const ImVec2 pos_norms[] = { { 0.0f, 0.0f }, { 0.3f, 0.0f }, { 0.3f, 0.7f }, { 0.7f, 0.7f }, { 0.7f, 0.0f }, { 1.0f, 0.0f }, { 1.0f, 1.0f }, { 0.0f, 1.0f } };
    for (const ImVec2& p : pos_norms)
        draw_list->PathLineTo(ImVec2(x + 0.5f + (int)(sz * p.x), y + 0.5f + (int)(sz * p.y)));
}

// Demonstrate using the low-level ImDrawList to draw custom shapes.
static void ShowExampleAppCustomRendering(bool* p_open)
{
    if (!ImGui::Begin("Example: Custom rendering", p_open))
    {
        ImGui::End();
        return;
    }
    IMGUI_DEMO_MARKER("Examples/Custom Rendering");

    // Tip: If you do a lot of custom rendering, you probably want to use your own geometrical types and benefit of
    // overloaded operators, etc. Define IM_VEC2_CLASS_EXTRA in imconfig.h to create implicit conversions between your
    // types and ImVec2/ImVec4. Dear ImGui defines overloaded operators but they are internal to imgui.cpp and not
    // exposed outside (to avoid messing with your types) In this example we are not using the maths operators!

    if (ImGui::BeginTabBar("##TabBar"))
    {
        if (ImGui::BeginTabItem("Primitives"))
        {
            ImGui::PushItemWidth(-ImGui::GetFontSize() * 15);
            ImDrawList* draw_list = ImGui::GetWindowDrawList();

            // Draw gradients
            // (note that those are currently exacerbating our sRGB/Linear issues)
            // Calling ImGui::GetColorU32() multiplies the given colors by the current Style Alpha, but you may pass the IM_COL32() directly as well..
            ImGui::Text("Gradients");
            ImVec2 gradient_size = ImVec2(ImGui::CalcItemWidth(), ImGui::GetFrameHeight());
            {
                ImVec2 p0 = ImGui::GetCursorScreenPos();
                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);
                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 0, 0, 255));
                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 255, 255, 255));
                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);
                ImGui::InvisibleButton("##gradient1", gradient_size);
            }
            {
                ImVec2 p0 = ImGui::GetCursorScreenPos();
                ImVec2 p1 = ImVec2(p0.x + gradient_size.x, p0.y + gradient_size.y);
                ImU32 col_a = ImGui::GetColorU32(IM_COL32(0, 255, 0, 255));
                ImU32 col_b = ImGui::GetColorU32(IM_COL32(255, 0, 0, 255));
                draw_list->AddRectFilledMultiColor(p0, p1, col_a, col_b, col_b, col_a);
                ImGui::InvisibleButton("##gradient2", gradient_size);
            }

            // Draw a bunch of primitives
            ImGui::Text("All primitives");
            static float sz = 36.0f;
            static float thickness = 3.0f;
            static int ngon_sides = 6;
            static bool circle_segments_override = false;
            static int circle_segments_override_v = 12;
            static bool curve_segments_override = false;
            static int curve_segments_override_v = 8;
            static ImVec4 colf = ImVec4(1.0f, 1.0f, 0.4f, 1.0f);
            ImGui::DragFloat("Size", &sz, 0.2f, 2.0f, 100.0f, "%.0f");
            ImGui::DragFloat("Thickness", &thickness, 0.05f, 1.0f, 8.0f, "%.02f");
            ImGui::SliderInt("N-gon sides", &ngon_sides, 3, 12);
            ImGui::Checkbox("##circlesegmentoverride", &circle_segments_override);
            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
            circle_segments_override |= ImGui::SliderInt("Circle segments override", &circle_segments_override_v, 3, 40);
            ImGui::Checkbox("##curvessegmentoverride", &curve_segments_override);
            ImGui::SameLine(0.0f, ImGui::GetStyle().ItemInnerSpacing.x);
            curve_segments_override |= ImGui::SliderInt("Curves segments override", &curve_segments_override_v, 3, 40);
            ImGui::ColorEdit4("Color", &colf.x);

            const ImVec2 p = ImGui::GetCursorScreenPos();
            const ImU32 col = ImColor(colf);
            const float spacing = 10.0f;
            const ImDrawFlags corners_tl_br = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBottomRight;
            const float rounding = sz / 5.0f;
            const int circle_segments = circle_segments_override ? circle_segments_override_v : 0;
            const int curve_segments = curve_segments_override ? curve_segments_override_v : 0;
            const ImVec2 cp3[3] = { ImVec2(0.0f, sz * 0.6f), ImVec2(sz * 0.5f, -sz * 0.4f), ImVec2(sz, sz) }; // Control points for curves
            const ImVec2 cp4[4] = { ImVec2(0.0f, 0.0f), ImVec2(sz * 1.3f, sz * 0.3f), ImVec2(sz - sz * 1.3f, sz - sz * 0.3f), ImVec2(sz, sz) };

            float x = p.x + 4.0f;
            float y = p.y + 4.0f;
            for (int n = 0; n < 2; n++)
            {
                // First line uses a thickness of 1.0f, second line uses the configurable thickness
                float th = (n == 0) ? 1.0f : thickness;
                draw_list->AddNgon(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, ngon_sides, th);                 x += sz + spacing;  // N-gon
                draw_list->AddCircle(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, col, circle_segments, th);          x += sz + spacing;  // Circle
                draw_list->AddEllipse(ImVec2(x + sz*0.5f, y + sz*0.5f), ImVec2(sz*0.5f, sz*0.3f), col, -0.3f, circle_segments, th); x += sz + spacing;  // Ellipse
                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 0.0f, ImDrawFlags_None, th);          x += sz + spacing;  // Square
                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, ImDrawFlags_None, th);      x += sz + spacing;  // Square with all rounded corners
                draw_list->AddRect(ImVec2(x, y), ImVec2(x + sz, y + sz), col, rounding, corners_tl_br, th);         x += sz + spacing;  // Square with two rounded corners
                draw_list->AddTriangle(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col, th);x += sz + spacing;  // Triangle
                //draw_list->AddTriangle(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col, th);x+= sz*0.4f + spacing; // Thin triangle
                PathConcaveShape(draw_list, x, y, sz); draw_list->PathStroke(col, ImDrawFlags_Closed, th);          x += sz + spacing;  // Concave Shape
                //draw_list->AddPolyline(concave_shape, IM_ARRAYSIZE(concave_shape), col, ImDrawFlags_Closed, th);
                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y), col, th);                                       x += sz + spacing;  // Horizontal line (note: drawing a filled rectangle will be faster!)
                draw_list->AddLine(ImVec2(x, y), ImVec2(x, y + sz), col, th);                                       x += spacing;       // Vertical line (note: drawing a filled rectangle will be faster!)
                draw_list->AddLine(ImVec2(x, y), ImVec2(x + sz, y + sz), col, th);                                  x += sz + spacing;  // Diagonal line

                // Path
                draw_list->PathArcTo(ImVec2(x + sz*0.5f, y + sz*0.5f), sz*0.5f, 3.141592f, 3.141592f * -0.5f);
                draw_list->PathStroke(col, ImDrawFlags_None, th);
                x += sz + spacing;

                // Quadratic Bezier Curve (3 control points)
                draw_list->AddBezierQuadratic(ImVec2(x + cp3[0].x, y + cp3[0].y), ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), col, th, curve_segments);
                x += sz + spacing;

                // Cubic Bezier Curve (4 control points)
                draw_list->AddBezierCubic(ImVec2(x + cp4[0].x, y + cp4[0].y), ImVec2(x + cp4[1].x, y + cp4[1].y), ImVec2(x + cp4[2].x, y + cp4[2].y), ImVec2(x + cp4[3].x, y + cp4[3].y), col, th, curve_segments);

                x = p.x + 4;
                y += sz + spacing;
            }

            // Filled shapes
            draw_list->AddNgonFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, ngon_sides);             x += sz + spacing;  // N-gon
            draw_list->AddCircleFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, col, circle_segments);      x += sz + spacing;  // Circle
            draw_list->AddEllipseFilled(ImVec2(x + sz * 0.5f, y + sz * 0.5f), ImVec2(sz * 0.5f, sz * 0.3f), col, -0.3f, circle_segments); x += sz + spacing;// Ellipse
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col);                                    x += sz + spacing;  // Square
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f);                             x += sz + spacing;  // Square with all rounded corners
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + sz), col, 10.0f, corners_tl_br);              x += sz + spacing;  // Square with two rounded corners
            draw_list->AddTriangleFilled(ImVec2(x+sz*0.5f,y), ImVec2(x+sz, y+sz-0.5f), ImVec2(x, y+sz-0.5f), col);  x += sz + spacing;  // Triangle
            //draw_list->AddTriangleFilled(ImVec2(x+sz*0.2f,y), ImVec2(x, y+sz-0.5f), ImVec2(x+sz*0.4f, y+sz-0.5f), col); x += sz*0.4f + spacing; // Thin triangle
            PathConcaveShape(draw_list, x, y, sz); draw_list->PathFillConcave(col);                                 x += sz + spacing;  // Concave shape
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + sz, y + thickness), col);                             x += sz + spacing;  // Horizontal line (faster than AddLine, but only handle integer thickness)
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + thickness, y + sz), col);                             x += spacing * 2.0f;// Vertical line (faster than AddLine, but only handle integer thickness)
            draw_list->AddRectFilled(ImVec2(x, y), ImVec2(x + 1, y + 1), col);                                      x += sz;            // Pixel (faster than AddLine)

            // Path
            draw_list->PathArcTo(ImVec2(x + sz * 0.5f, y + sz * 0.5f), sz * 0.5f, 3.141592f * -0.5f, 3.141592f);
            draw_list->PathFillConvex(col);
            x += sz + spacing;

            // Quadratic Bezier Curve (3 control points)
            draw_list->PathLineTo(ImVec2(x + cp3[0].x, y + cp3[0].y));
            draw_list->PathBezierQuadraticCurveTo(ImVec2(x + cp3[1].x, y + cp3[1].y), ImVec2(x + cp3[2].x, y + cp3[2].y), curve_segments);
            draw_list->PathFillConvex(col);
            x += sz + spacing;

            draw_list->AddRectFilledMultiColor(ImVec2(x, y), ImVec2(x + sz, y + sz), IM_COL32(0, 0, 0, 255), IM_COL32(255, 0, 0, 255), IM_COL32(255, 255, 0, 255), IM_COL32(0, 255, 0, 255));
            x += sz + spacing;

            ImGui::Dummy(ImVec2((sz + spacing) * 13.2f, (sz + spacing) * 3.0f));
            ImGui::PopItemWidth();
            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("Canvas"))
        {
            static ImVector<ImVec2> points;
            static ImVec2 scrolling(0.0f, 0.0f);
            static bool opt_enable_grid = true;
            static bool opt_enable_context_menu = true;
            static bool adding_line = false;

            ImGui::Checkbox("Enable grid", &opt_enable_grid);
            ImGui::Checkbox("Enable context menu", &opt_enable_context_menu);
            ImGui::Text("Mouse Left: drag to add lines,\nMouse Right: drag to scroll, click for context menu.");

            // Typically you would use a BeginChild()/EndChild() pair to benefit from a clipping region + own scrolling.
            // Here we demonstrate that this can be replaced by simple offsetting + custom drawing + PushClipRect/PopClipRect() calls.
            // To use a child window instead we could use, e.g:
            //      ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));      // Disable padding
            //      ImGui::PushStyleColor(ImGuiCol_ChildBg, IM_COL32(50, 50, 50, 255));  // Set a background color
            //      ImGui::BeginChild("canvas", ImVec2(0.0f, 0.0f), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove);
            //      ImGui::PopStyleColor();
            //      ImGui::PopStyleVar();
            //      [...]
            //      ImGui::EndChild();

            // Using InvisibleButton() as a convenience 1) it will advance the layout cursor and 2) allows us to use IsItemHovered()/IsItemActive()
            ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();      // ImDrawList API uses screen coordinates!
            ImVec2 canvas_sz = ImGui::GetContentRegionAvail();   // Resize canvas to what's available
            if (canvas_sz.x < 50.0f) canvas_sz.x = 50.0f;
            if (canvas_sz.y < 50.0f) canvas_sz.y = 50.0f;
            ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

            // Draw border and background color
            ImGuiIO& io = ImGui::GetIO();
            ImDrawList* draw_list = ImGui::GetWindowDrawList();
            draw_list->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(50, 50, 50, 255));
            draw_list->AddRect(canvas_p0, canvas_p1, IM_COL32(255, 255, 255, 255));

            // This will catch our interactions
            ImGui::InvisibleButton("canvas", canvas_sz, ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight);
            const bool is_hovered = ImGui::IsItemHovered(); // Hovered
            const bool is_active = ImGui::IsItemActive();   // Held
            const ImVec2 origin(canvas_p0.x + scrolling.x, canvas_p0.y + scrolling.y); // Lock scrolled origin
            const ImVec2 mouse_pos_in_canvas(io.MousePos.x - origin.x, io.MousePos.y - origin.y);

            // Add first and second point
            if (is_hovered && !adding_line && ImGui::IsMouseClicked(ImGuiMouseButton_Left))
            {
                points.push_back(mouse_pos_in_canvas);
                points.push_back(mouse_pos_in_canvas);
                adding_line = true;
            }
            if (adding_line)
            {
                points.back() = mouse_pos_in_canvas;
                if (!ImGui::IsMouseDown(ImGuiMouseButton_Left))
                    adding_line = false;
            }

            // Pan (we use a zero mouse threshold when there's no context menu)
            // You may decide to make that threshold dynamic based on whether the mouse is hovering something etc.
            const float mouse_threshold_for_pan = opt_enable_context_menu ? -1.0f : 0.0f;
            if (is_active && ImGui::IsMouseDragging(ImGuiMouseButton_Right, mouse_threshold_for_pan))
            {
                scrolling.x += io.MouseDelta.x;
                scrolling.y += io.MouseDelta.y;
            }

            // Context menu (under default mouse threshold)
            ImVec2 drag_delta = ImGui::GetMouseDragDelta(ImGuiMouseButton_Right);
            if (opt_enable_context_menu && drag_delta.x == 0.0f && drag_delta.y == 0.0f)
                ImGui::OpenPopupOnItemClick("context", ImGuiPopupFlags_MouseButtonRight);
            if (ImGui::BeginPopup("context"))
            {
                if (adding_line)
                    points.resize(points.size() - 2);
                adding_line = false;
                if (ImGui::MenuItem("Remove one", NULL, false, points.Size > 0)) { points.resize(points.size() - 2); }
                if (ImGui::MenuItem("Remove all", NULL, false, points.Size > 0)) { points.clear(); }
                ImGui::EndPopup();
            }

            // Draw grid + all lines in the canvas
            draw_list->PushClipRect(canvas_p0, canvas_p1, true);
            if (opt_enable_grid)
            {
                const float GRID_STEP = 64.0f;
                for (float x = fmodf(scrolling.x, GRID_STEP); x < canvas_sz.x; x += GRID_STEP)
                    draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p1.y), IM_COL32(200, 200, 200, 40));
                for (float y = fmodf(scrolling.y, GRID_STEP); y < canvas_sz.y; y += GRID_STEP)
                    draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p1.x, canvas_p0.y + y), IM_COL32(200, 200, 200, 40));
            }
            for (int n = 0; n < points.Size; n += 2)
                draw_list->AddLine(ImVec2(origin.x + points[n].x, origin.y + points[n].y), ImVec2(origin.x + points[n + 1].x, origin.y + points[n + 1].y), IM_COL32(255, 255, 0, 255), 2.0f);
            draw_list->PopClipRect();

            ImGui::EndTabItem();
        }

        if (ImGui::BeginTabItem("BG/FG draw lists"))
        {
            static bool draw_bg = true;
            static bool draw_fg = true;
            ImGui::Checkbox("Draw in Background draw list", &draw_bg);
            ImGui::SameLine(); HelpMarker("The Background draw list will be rendered below every Dear ImGui windows.");
            ImGui::Checkbox("Draw in Foreground draw list", &draw_fg);
            ImGui::SameLine(); HelpMarker("The Foreground draw list will be rendered over every Dear ImGui windows.");
            ImVec2 window_pos = ImGui::GetWindowPos();
            ImVec2 window_size = ImGui::GetWindowSize();
            ImVec2 window_center = ImVec2(window_pos.x + window_size.x * 0.5f, window_pos.y + window_size.y * 0.5f);
            if (draw_bg)
                ImGui::GetBackgroundDrawList()->AddCircle(window_center, window_size.x * 0.6f, IM_COL32(255, 0, 0, 200), 0, 10 + 4);
            if (draw_fg)
                ImGui::GetForegroundDrawList()->AddCircle(window_center, window_size.y * 0.6f, IM_COL32(0, 255, 0, 200), 0, 10);
            ImGui::EndTabItem();
        }

        // Demonstrate out-of-order rendering via channels splitting
        // We use functions in ImDrawList as each draw list contains a convenience splitter,
        // but you can also instantiate your own ImDrawListSplitter if you need to nest them.
        if (ImGui::BeginTabItem("Draw Channels"))
        {
            ImDrawList* draw_list = ImGui::GetWindowDrawList();
            {
                ImGui::Text("Blue shape is drawn first: appears in back");
                ImGui::Text("Red shape is drawn after: appears in front");
                ImVec2 p0 = ImGui::GetCursorScreenPos();
                draw_list->AddRectFilled(ImVec2(p0.x, p0.y), ImVec2(p0.x + 50, p0.y + 50), IM_COL32(0, 0, 255, 255)); // Blue
                draw_list->AddRectFilled(ImVec2(p0.x + 25, p0.y + 25), ImVec2(p0.x + 75, p0.y + 75), IM_COL32(255, 0, 0, 255)); // Red
                ImGui::Dummy(ImVec2(75, 75));
            }
            ImGui::Separator();
            {
                ImGui::Text("Blue shape is drawn first, into channel 1: appears in front");
                ImGui::Text("Red shape is drawn after, into channel 0: appears in back");
                ImVec2 p1 = ImGui::GetCursorScreenPos();

                // Create 2 channels and draw a Blue shape THEN a Red shape.
                // You can create any number of channels. Tables API use 1 channel per column in order to better batch draw calls.
                draw_list->ChannelsSplit(2);
                draw_list->ChannelsSetCurrent(1);
                draw_list->AddRectFilled(ImVec2(p1.x, p1.y), ImVec2(p1.x + 50, p1.y + 50), IM_COL32(0, 0, 255, 255)); // Blue
                draw_list->ChannelsSetCurrent(0);
                draw_list->AddRectFilled(ImVec2(p1.x + 25, p1.y + 25), ImVec2(p1.x + 75, p1.y + 75), IM_COL32(255, 0, 0, 255)); // Red

                // Flatten/reorder channels. Red shape is in channel 0 and it appears below the Blue shape in channel 1.
                // This works by copying draw indices only (vertices are not copied).
                draw_list->ChannelsMerge();
                ImGui::Dummy(ImVec2(75, 75));
                ImGui::Text("After reordering, contents of channel 0 appears below channel 1.");
            }
            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()
//-----------------------------------------------------------------------------

// Simplified structure to mimic a Document model
struct MyDocument
{
    char        Name[32];   // Document title
    int         UID;        // Unique ID (necessary as we can change title)
    bool        Open;       // Set when open (we keep an array of all available documents to simplify demo code!)
    bool        OpenPrev;   // Copy of Open from last update.
    bool        Dirty;      // Set when the document has been modified
    ImVec4      Color;      // An arbitrary variable associated to the document

    MyDocument(int uid, const char* name, bool open = true, const ImVec4& color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f))
    {
        UID = uid;
        snprintf(Name, sizeof(Name), "%s", name);
        Open = OpenPrev = open;
        Dirty = false;
        Color = color;
    }
    void DoOpen()       { Open = true; }
    void DoForceClose() { Open = false; Dirty = false; }
    void DoSave()       { Dirty = false; }
};

struct ExampleAppDocuments
{
    ImVector<MyDocument>    Documents;
    ImVector<MyDocument*>   CloseQueue;
    MyDocument*             RenamingDoc = NULL;
    bool                    RenamingStarted = false;

    ExampleAppDocuments()
    {
        Documents.push_back(MyDocument(0, "Lettuce",             true,  ImVec4(0.4f, 0.8f, 0.4f, 1.0f)));
        Documents.push_back(MyDocument(1, "Eggplant",            true,  ImVec4(0.8f, 0.5f, 1.0f, 1.0f)));
        Documents.push_back(MyDocument(2, "Carrot",              true,  ImVec4(1.0f, 0.8f, 0.5f, 1.0f)));
        Documents.push_back(MyDocument(3, "Tomato",              false, ImVec4(1.0f, 0.3f, 0.4f, 1.0f)));
        Documents.push_back(MyDocument(4, "A Rather Long Title", false, ImVec4(0.4f, 0.8f, 0.8f, 1.0f)));
        Documents.push_back(MyDocument(5, "Some Document",       false, ImVec4(0.8f, 0.8f, 1.0f, 1.0f)));
    }

    // As we allow to change document name, we append a never-changing document ID so tabs are stable
    void GetTabName(MyDocument* doc, char* out_buf, size_t out_buf_size)
    {
        snprintf(out_buf, out_buf_size, "%s###doc%d", doc->Name, doc->UID);
    }

    // Display placeholder contents for the Document
    void DisplayDocContents(MyDocument* doc)
    {
        ImGui::PushID(doc);
        ImGui::Text("Document \"%s\"", doc->Name);
        ImGui::PushStyleColor(ImGuiCol_Text, doc->Color);
        ImGui::TextWrapped("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.");
        ImGui::PopStyleColor();

        ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_R, ImGuiInputFlags_Tooltip);
        if (ImGui::Button("Rename.."))
        {
            RenamingDoc = doc;
            RenamingStarted = true;
        }
        ImGui::SameLine();

        ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_M, ImGuiInputFlags_Tooltip);
        if (ImGui::Button("Modify"))
            doc->Dirty = true;

        ImGui::SameLine();
        ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_S, ImGuiInputFlags_Tooltip);
        if (ImGui::Button("Save"))
            doc->DoSave();

        ImGui::SameLine();
        ImGui::SetNextItemShortcut(ImGuiMod_Ctrl | ImGuiKey_W, ImGuiInputFlags_Tooltip);
        if (ImGui::Button("Close"))
            CloseQueue.push_back(doc);
        ImGui::ColorEdit3("color", &doc->Color.x);  // Useful to test drag and drop and hold-dragged-to-open-tab behavior.
        ImGui::PopID();
    }

    // Display context menu for the Document
    void DisplayDocContextMenu(MyDocument* doc)
    {
        if (!ImGui::BeginPopupContextItem())
            return;

        char buf[256];
        sprintf(buf, "Save %s", doc->Name);
        if (ImGui::MenuItem(buf, "Ctrl+S", false, doc->Open))
            doc->DoSave();
        if (ImGui::MenuItem("Rename...", "Ctrl+R", false, doc->Open))
            RenamingDoc = doc;
        if (ImGui::MenuItem("Close", "Ctrl+W", false, doc->Open))
            CloseQueue.push_back(doc);
        ImGui::EndPopup();
    }

    // [Optional] Notify the system of Tabs/Windows closure that happened outside the regular tab interface.
    // If a tab has been closed programmatically (aka closed from another source such as the Checkbox() in the demo,
    // as opposed to clicking on the regular tab closing button) and stops being submitted, it will take a frame for
    // the tab bar to notice its absence. During this frame there will be a gap in the tab bar, and if the tab that has
    // disappeared was the selected one, the tab bar will report no selected tab during the frame. This will effectively
    // give the impression of a flicker for one frame.
    // We call SetTabItemClosed() to manually notify the Tab Bar or Docking system of removed tabs to avoid this glitch.
    // Note that this completely optional, and only affect tab bars with the ImGuiTabBarFlags_Reorderable flag.
    void NotifyOfDocumentsClosedElsewhere()
    {
        for (MyDocument& doc : Documents)
        {
            if (!doc.Open && doc.OpenPrev)
                ImGui::SetTabItemClosed(doc.Name);
            doc.OpenPrev = doc.Open;
        }
    }
};

void ShowExampleAppDocuments(bool* p_open)
{
    static ExampleAppDocuments app;

    // Options
    static bool opt_reorderable = true;
    static ImGuiTabBarFlags opt_fitting_flags = ImGuiTabBarFlags_FittingPolicyDefault_;

    bool window_contents_visible = ImGui::Begin("Example: Documents", p_open, ImGuiWindowFlags_MenuBar);
    if (!window_contents_visible)
    {
        ImGui::End();
        return;
    }

    // Menu
    if (ImGui::BeginMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            int open_count = 0;
            for (MyDocument& doc : app.Documents)
                open_count += doc.Open ? 1 : 0;

            if (ImGui::BeginMenu("Open", open_count < app.Documents.Size))
            {
                for (MyDocument& doc : app.Documents)
                    if (!doc.Open && ImGui::MenuItem(doc.Name))
                        doc.DoOpen();
                ImGui::EndMenu();
            }
            if (ImGui::MenuItem("Close All Documents", NULL, false, open_count > 0))
                for (MyDocument& doc : app.Documents)
                    app.CloseQueue.push_back(&doc);
            if (ImGui::MenuItem("Exit") && p_open)
                *p_open = false;
            ImGui::EndMenu();
        }
        ImGui::EndMenuBar();
    }

    // [Debug] List documents with one checkbox for each
    for (int doc_n = 0; doc_n < app.Documents.Size; doc_n++)
    {
        MyDocument& doc = app.Documents[doc_n];
        if (doc_n > 0)
            ImGui::SameLine();
        ImGui::PushID(&doc);
        if (ImGui::Checkbox(doc.Name, &doc.Open))
            if (!doc.Open)
                doc.DoForceClose();
        ImGui::PopID();
    }

    ImGui::Separator();

    // About the ImGuiWindowFlags_UnsavedDocument / ImGuiTabItemFlags_UnsavedDocument flags.
    // They have multiple effects:
    // - Display a dot next to the title.
    // - Tab is selected when clicking the X close button.
    // - Closure is not assumed (will wait for user to stop submitting the tab).
    //   Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
    //   We need to assume closure by default otherwise waiting for "lack of submission" on the next frame would leave an empty
    //   hole for one-frame, both in the tab-bar and in tab-contents when closing a tab/window.
    //   The rarely used SetTabItemClosed() function is a way to notify of programmatic closure to avoid the one-frame hole.

    // Submit Tab Bar and Tabs
    {
        ImGuiTabBarFlags tab_bar_flags = (opt_fitting_flags) | (opt_reorderable ? ImGuiTabBarFlags_Reorderable : 0);
        tab_bar_flags |= ImGuiTabBarFlags_DrawSelectedOverline;
        if (ImGui::BeginTabBar("##tabs", tab_bar_flags))
        {
            if (opt_reorderable)
                app.NotifyOfDocumentsClosedElsewhere();

            // [DEBUG] Stress tests
            //if ((ImGui::GetFrameCount() % 30) == 0) docs[1].Open ^= 1;            // [DEBUG] Automatically show/hide a tab. Test various interactions e.g. dragging with this on.
            //if (ImGui::GetIO().KeyCtrl) ImGui::SetTabItemSelected(docs[1].Name);  // [DEBUG] Test SetTabItemSelected(), probably not very useful as-is anyway..

            // Submit Tabs
            for (MyDocument& doc : app.Documents)
            {
                if (!doc.Open)
                    continue;

                // As we allow to change document name, we append a never-changing document id so tabs are stable
                char doc_name_buf[64];
                app.GetTabName(&doc, doc_name_buf, sizeof(doc_name_buf));
                ImGuiTabItemFlags tab_flags = (doc.Dirty ? ImGuiTabItemFlags_UnsavedDocument : 0);
                bool visible = ImGui::BeginTabItem(doc_name_buf, &doc.Open, tab_flags);

                // Cancel attempt to close when unsaved add to save queue so we can display a popup.
                if (!doc.Open && doc.Dirty)
                {
                    doc.Open = true;
                    app.CloseQueue.push_back(&doc);
                }

                app.DisplayDocContextMenu(&doc);
                if (visible)
                {
                    app.DisplayDocContents(&doc);
                    ImGui::EndTabItem();
                }
            }

            ImGui::EndTabBar();
        }
    }

    // Display renaming UI
    if (app.RenamingDoc != NULL)
    {
        if (app.RenamingStarted)
            ImGui::OpenPopup("Rename");
        if (ImGui::BeginPopup("Rename"))
        {
            ImGui::SetNextItemWidth(ImGui::GetFontSize() * 30);
            if (ImGui::InputText("###Name", app.RenamingDoc->Name, IM_ARRAYSIZE(app.RenamingDoc->Name), ImGuiInputTextFlags_EnterReturnsTrue))
            {
                ImGui::CloseCurrentPopup();
                app.RenamingDoc = NULL;
            }
            if (app.RenamingStarted)
                ImGui::SetKeyboardFocusHere(-1);
            ImGui::EndPopup();
        }
        else
        {
            app.RenamingDoc = NULL;
        }
        app.RenamingStarted = false;
    }

    // Display closing confirmation UI
    if (!app.CloseQueue.empty())
    {
        int close_queue_unsaved_documents = 0;
        for (int n = 0; n < app.CloseQueue.Size; n++)
            if (app.CloseQueue[n]->Dirty)
                close_queue_unsaved_documents++;

        if (close_queue_unsaved_documents == 0)
        {
            // Close documents when all are unsaved
            for (int n = 0; n < app.CloseQueue.Size; n++)
                app.CloseQueue[n]->DoForceClose();
            app.CloseQueue.clear();
        }
        else
        {
            if (!ImGui::IsPopupOpen("Save?"))
                ImGui::OpenPopup("Save?");
            if (ImGui::BeginPopupModal("Save?", NULL, ImGuiWindowFlags_AlwaysAutoResize))
            {
                ImGui::Text("Save change to the following items?");
                float item_height = ImGui::GetTextLineHeightWithSpacing();
                if (ImGui::BeginChild(ImGui::GetID("frame"), ImVec2(-FLT_MIN, 6.25f * item_height), ImGuiChildFlags_FrameStyle))
                    for (MyDocument* doc : app.CloseQueue)
                        if (doc->Dirty)
                            ImGui::Text("%s", doc->Name);
                ImGui::EndChild();

                ImVec2 button_size(ImGui::GetFontSize() * 7.0f, 0.0f);
                if (ImGui::Button("Yes", button_size))
                {
                    for (MyDocument* doc : app.CloseQueue)
                    {
                        if (doc->Dirty)
                            doc->DoSave();
                        doc->DoForceClose();
                    }
                    app.CloseQueue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("No", button_size))
                {
                    for (MyDocument* doc : app.CloseQueue)
                        doc->DoForceClose();
                    app.CloseQueue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("Cancel", button_size))
                {
                    app.CloseQueue.clear();
                    ImGui::CloseCurrentPopup();
                }
                ImGui::EndPopup();
            }
        }
    }

    ImGui::End();
}

//-----------------------------------------------------------------------------
// [SECTION] Example App: Assets Browser / ShowExampleAppAssetsBrowser()
//-----------------------------------------------------------------------------

//#include "imgui_internal.h" // NavMoveRequestTryWrapping()

struct ExampleAsset
{
    ImGuiID ID;
    int     Type;

    ExampleAsset(ImGuiID id, int type) { ID = id; Type = type; }

    static const ImGuiTableSortSpecs* s_current_sort_specs;

    static void SortWithSortSpecs(ImGuiTableSortSpecs* sort_specs, ExampleAsset* items, int items_count)
    {
        s_current_sort_specs = sort_specs; // Store in variable accessible by the sort function.
        if (items_count > 1)
            qsort(items, (size_t)items_count, sizeof(items[0]), ExampleAsset::CompareWithSortSpecs);
        s_current_sort_specs = NULL;
    }

    // Compare function to be used by qsort()
    static int IMGUI_CDECL CompareWithSortSpecs(const void* lhs, const void* rhs)
    {
        const ExampleAsset* a = (const ExampleAsset*)lhs;
        const ExampleAsset* b = (const ExampleAsset*)rhs;
        for (int n = 0; n < s_current_sort_specs->SpecsCount; n++)
        {
            const ImGuiTableColumnSortSpecs* sort_spec = &s_current_sort_specs->Specs[n];
            int delta = 0;
            if (sort_spec->ColumnIndex == 0)
                delta = ((int)a->ID - (int)b->ID);
            else if (sort_spec->ColumnIndex == 1)
                delta = (a->Type - b->Type);
            if (delta > 0)
                return (sort_spec->SortDirection == ImGuiSortDirection_Ascending) ? +1 : -1;
            if (delta < 0)
                return (sort_spec->SortDirection == ImGuiSortDirection_Ascending) ? -1 : +1;
        }
        return ((int)a->ID - (int)b->ID);
    }
};
const ImGuiTableSortSpecs* ExampleAsset::s_current_sort_specs = NULL;

struct ExampleAssetsBrowser
{
    // Options
    bool            ShowTypeOverlay = true;
    bool            AllowSorting = true;
    bool            AllowDragUnselected = false;
    bool            AllowBoxSelect = true;
    float           IconSize = 32.0f;
    int             IconSpacing = 10;
    int             IconHitSpacing = 4;         // Increase hit-spacing if you want to make it possible to clear or box-select from gaps. Some spacing is required to able to amend with Shift+box-select. Value is small in Explorer.
    bool            StretchSpacing = true;

    // State
    ImVector<ExampleAsset> Items;               // Our items
    ExampleSelectionWithDeletion Selection;     // Our selection (ImGuiSelectionBasicStorage + helper funcs to handle deletion)
    ImGuiID         NextItemId = 0;             // Unique identifier when creating new items
    bool            RequestDelete = false;      // Deferred deletion request
    bool            RequestSort = false;        // Deferred sort request
    float           ZoomWheelAccum = 0.0f;      // Mouse wheel accumulator to handle smooth wheels better

    // Calculated sizes for layout, output of UpdateLayoutSizes(). Could be locals but our code is simpler this way.
    ImVec2          LayoutItemSize;
    ImVec2          LayoutItemStep;             // == LayoutItemSize + LayoutItemSpacing
    float           LayoutItemSpacing = 0.0f;
    float           LayoutSelectableSpacing = 0.0f;
    float           LayoutOuterPadding = 0.0f;
    int             LayoutColumnCount = 0;
    int             LayoutLineCount = 0;

    // Functions
    ExampleAssetsBrowser()
    {
        AddItems(10000);
    }
    void AddItems(int count)
    {
        if (Items.Size == 0)
            NextItemId = 0;
        Items.reserve(Items.Size + count);
        for (int n = 0; n < count; n++, NextItemId++)
            Items.push_back(ExampleAsset(NextItemId, (NextItemId % 20) < 15 ? 0 : (NextItemId % 20) < 18 ? 1 : 2));
        RequestSort = true;
    }
    void ClearItems()
    {
        Items.clear();
        Selection.Clear();
    }

    // Logic would be written in the main code BeginChild() and outputting to local variables.
    // We extracted it into a function so we can call it easily from multiple places.
    void UpdateLayoutSizes(float avail_width)
    {
        // Layout: when not stretching: allow extending into right-most spacing.
        LayoutItemSpacing = (float)IconSpacing;
        if (StretchSpacing == false)
            avail_width += floorf(LayoutItemSpacing * 0.5f);

        // Layout: calculate number of icon per line and number of lines
        LayoutItemSize = ImVec2(floorf(IconSize), floorf(IconSize));
        LayoutColumnCount = IM_MAX((int)(avail_width / (LayoutItemSize.x + LayoutItemSpacing)), 1);
        LayoutLineCount = (Items.Size + LayoutColumnCount - 1) / LayoutColumnCount;

        // Layout: when stretching: allocate remaining space to more spacing. Round before division, so item_spacing may be non-integer.
        if (StretchSpacing && LayoutColumnCount > 1)
            LayoutItemSpacing = floorf(avail_width - LayoutItemSize.x * LayoutColumnCount) / LayoutColumnCount;

        LayoutItemStep = ImVec2(LayoutItemSize.x + LayoutItemSpacing, LayoutItemSize.y + LayoutItemSpacing);
        LayoutSelectableSpacing = IM_MAX(floorf(LayoutItemSpacing) - IconHitSpacing, 0.0f);
        LayoutOuterPadding = floorf(LayoutItemSpacing * 0.5f);
    }

    void Draw(const char* title, bool* p_open)
    {
        ImGui::SetNextWindowSize(ImVec2(IconSize * 25, IconSize * 15), ImGuiCond_FirstUseEver);
        if (!ImGui::Begin(title, p_open, ImGuiWindowFlags_MenuBar))
        {
            ImGui::End();
            return;
        }

        // Menu bar
        if (ImGui::BeginMenuBar())
        {
            if (ImGui::BeginMenu("File"))
            {
                if (ImGui::MenuItem("Add 10000 items"))
                    AddItems(10000);
                if (ImGui::MenuItem("Clear items"))
                    ClearItems();
                ImGui::Separator();
                if (ImGui::MenuItem("Close", NULL, false, p_open != NULL))
                    *p_open = false;
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Edit"))
            {
                if (ImGui::MenuItem("Delete", "Del", false, Selection.Size > 0))
                    RequestDelete = true;
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Options"))
            {
                ImGui::PushItemWidth(ImGui::GetFontSize() * 10);

                ImGui::SeparatorText("Contents");
                ImGui::Checkbox("Show Type Overlay", &ShowTypeOverlay);
                ImGui::Checkbox("Allow Sorting", &AllowSorting);

                ImGui::SeparatorText("Selection Behavior");
                ImGui::Checkbox("Allow dragging unselected item", &AllowDragUnselected);
                ImGui::Checkbox("Allow box-selection", &AllowBoxSelect);

                ImGui::SeparatorText("Layout");
                ImGui::SliderFloat("Icon Size", &IconSize, 16.0f, 128.0f, "%.0f");
                ImGui::SameLine(); HelpMarker("Use CTRL+Wheel to zoom");
                ImGui::SliderInt("Icon Spacing", &IconSpacing, 0, 32);
                ImGui::SliderInt("Icon Hit Spacing", &IconHitSpacing, 0, 32);
                ImGui::Checkbox("Stretch Spacing", &StretchSpacing);
                ImGui::PopItemWidth();
                ImGui::EndMenu();
            }
            ImGui::EndMenuBar();
        }

        // Show a table with ONLY one header row to showcase the idea/possibility of using this to provide a sorting UI
        if (AllowSorting)
        {
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
            ImGuiTableFlags table_flags_for_sort_specs = ImGuiTableFlags_Sortable | ImGuiTableFlags_SortMulti | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Borders;
            if (ImGui::BeginTable("for_sort_specs_only", 2, table_flags_for_sort_specs, ImVec2(0.0f, ImGui::GetFrameHeight())))
            {
                ImGui::TableSetupColumn("Index");
                ImGui::TableSetupColumn("Type");
                ImGui::TableHeadersRow();
                if (ImGuiTableSortSpecs* sort_specs = ImGui::TableGetSortSpecs())
                    if (sort_specs->SpecsDirty || RequestSort)
                    {
                        ExampleAsset::SortWithSortSpecs(sort_specs, Items.Data, Items.Size);
                        sort_specs->SpecsDirty = RequestSort = false;
                    }
                ImGui::EndTable();
            }
            ImGui::PopStyleVar();
        }

        ImGuiIO& io = ImGui::GetIO();
        ImGui::SetNextWindowContentSize(ImVec2(0.0f, LayoutOuterPadding + LayoutLineCount * (LayoutItemSize.y + LayoutItemSpacing)));
        if (ImGui::BeginChild("Assets", ImVec2(0.0f, -ImGui::GetTextLineHeightWithSpacing()), ImGuiChildFlags_Borders, ImGuiWindowFlags_NoMove))
        {
            ImDrawList* draw_list = ImGui::GetWindowDrawList();

            const float avail_width = ImGui::GetContentRegionAvail().x;
            UpdateLayoutSizes(avail_width);

            // Calculate and store start position.
            ImVec2 start_pos = ImGui::GetCursorScreenPos();
            start_pos = ImVec2(start_pos.x + LayoutOuterPadding, start_pos.y + LayoutOuterPadding);
            ImGui::SetCursorScreenPos(start_pos);

            // Multi-select
            ImGuiMultiSelectFlags ms_flags = ImGuiMultiSelectFlags_ClearOnEscape | ImGuiMultiSelectFlags_ClearOnClickVoid;

            // - Enable box-select (in 2D mode, so that changing box-select rectangle X1/X2 boundaries will affect clipped items)
            if (AllowBoxSelect)
                ms_flags |= ImGuiMultiSelectFlags_BoxSelect2d;

            // - This feature allows dragging an unselected item without selecting it (rarely used)
            if (AllowDragUnselected)
                ms_flags |= ImGuiMultiSelectFlags_SelectOnClickRelease;

            // - Enable keyboard wrapping on X axis
            // (FIXME-MULTISELECT: We haven't designed/exposed a general nav wrapping api yet, so this flag is provided as a courtesy to avoid doing:
            //    ImGui::NavMoveRequestTryWrapping(ImGui::GetCurrentWindow(), ImGuiNavMoveFlags_WrapX);
            // When we finish implementing a more general API for this, we will obsolete this flag in favor of the new system)
            ms_flags |= ImGuiMultiSelectFlags_NavWrapX;

            ImGuiMultiSelectIO* ms_io = ImGui::BeginMultiSelect(ms_flags, Selection.Size, Items.Size);

            // Use custom selection adapter: store ID in selection (recommended)
            Selection.UserData = this;
            Selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self_, int idx) { ExampleAssetsBrowser* self = (ExampleAssetsBrowser*)self_->UserData; return self->Items[idx].ID; };
            Selection.ApplyRequests(ms_io);

            const bool want_delete = (ImGui::Shortcut(ImGuiKey_Delete, ImGuiInputFlags_Repeat) && (Selection.Size > 0)) || RequestDelete;
            const int item_curr_idx_to_focus = want_delete ? Selection.ApplyDeletionPreLoop(ms_io, Items.Size) : -1;
            RequestDelete = false;

            // Push LayoutSelectableSpacing (which is LayoutItemSpacing minus hit-spacing, if we decide to have hit gaps between items)
            // Altering style ItemSpacing may seem unnecessary as we position every items using SetCursorScreenPos()...
            // But it is necessary for two reasons:
            // - Selectables uses it by default to visually fill the space between two items.
            // - The vertical spacing would be measured by Clipper to calculate line height if we didn't provide it explicitly (here we do).
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(LayoutSelectableSpacing, LayoutSelectableSpacing));

            // Rendering parameters
            const ImU32 icon_type_overlay_colors[3] = { 0, IM_COL32(200, 70, 70, 255), IM_COL32(70, 170, 70, 255) };
            const ImU32 icon_bg_color = ImGui::GetColorU32(IM_COL32(35, 35, 35, 220));
            const ImVec2 icon_type_overlay_size = ImVec2(4.0f, 4.0f);
            const bool display_label = (LayoutItemSize.x >= ImGui::CalcTextSize("999").x);

            const int column_count = LayoutColumnCount;
            ImGuiListClipper clipper;
            clipper.Begin(LayoutLineCount, LayoutItemStep.y);
            if (item_curr_idx_to_focus != -1)
                clipper.IncludeItemByIndex(item_curr_idx_to_focus / column_count); // Ensure focused item line is not clipped.
            if (ms_io->RangeSrcItem != -1)
                clipper.IncludeItemByIndex((int)ms_io->RangeSrcItem / column_count); // Ensure RangeSrc item line is not clipped.
            while (clipper.Step())
            {
                for (int line_idx = clipper.DisplayStart; line_idx < clipper.DisplayEnd; line_idx++)
                {
                    const int item_min_idx_for_current_line = line_idx * column_count;
                    const int item_max_idx_for_current_line = IM_MIN((line_idx + 1) * column_count, Items.Size);
                    for (int item_idx = item_min_idx_for_current_line; item_idx < item_max_idx_for_current_line; ++item_idx)
                    {
                        ExampleAsset* item_data = &Items[item_idx];
                        ImGui::PushID((int)item_data->ID);

                        // Position item
                        ImVec2 pos = ImVec2(start_pos.x + (item_idx % column_count) * LayoutItemStep.x, start_pos.y + line_idx * LayoutItemStep.y);
                        ImGui::SetCursorScreenPos(pos);

                        ImGui::SetNextItemSelectionUserData(item_idx);
                        bool item_is_selected = Selection.Contains((ImGuiID)item_data->ID);
                        bool item_is_visible = ImGui::IsRectVisible(LayoutItemSize);
                        ImGui::Selectable("", item_is_selected, ImGuiSelectableFlags_None, LayoutItemSize);

                        // Update our selection state immediately (without waiting for EndMultiSelect() requests)
                        // because we use this to alter the color of our text/icon.
                        if (ImGui::IsItemToggledSelection())
                            item_is_selected = !item_is_selected;

                        // Focus (for after deletion)
                        if (item_curr_idx_to_focus == item_idx)
                            ImGui::SetKeyboardFocusHere(-1);

                        // Drag and drop
                        if (ImGui::BeginDragDropSource())
                        {
                            // Create payload with full selection OR single unselected item.
                            // (the later is only possible when using ImGuiMultiSelectFlags_SelectOnClickRelease)
                            if (ImGui::GetDragDropPayload() == NULL)
                            {
                                ImVector<ImGuiID> payload_items;
                                void* it = NULL;
                                ImGuiID id = 0;
                                if (!item_is_selected)
                                    payload_items.push_back(item_data->ID);
                                else
                                    while (Selection.GetNextSelectedItem(&it, &id))
                                        payload_items.push_back(id);
                                ImGui::SetDragDropPayload("ASSETS_BROWSER_ITEMS", payload_items.Data, (size_t)payload_items.size_in_bytes());
                            }

                            // Display payload content in tooltip, by extracting it from the payload data
                            // (we could read from selection, but it is more correct and reusable to read from payload)
                            const ImGuiPayload* payload = ImGui::GetDragDropPayload();
                            const int payload_count = (int)payload->DataSize / (int)sizeof(ImGuiID);
                            ImGui::Text("%d assets", payload_count);

                            ImGui::EndDragDropSource();
                        }

                        // Render icon (a real app would likely display an image/thumbnail here)
                        // Because we use ImGuiMultiSelectFlags_BoxSelect2d, clipping vertical may occasionally be larger, so we coarse-clip our rendering as well.
                        if (item_is_visible)
                        {
                            ImVec2 box_min(pos.x - 1, pos.y - 1);
                            ImVec2 box_max(box_min.x + LayoutItemSize.x + 2, box_min.y + LayoutItemSize.y + 2); // Dubious
                            draw_list->AddRectFilled(box_min, box_max, icon_bg_color); // Background color
                            if (ShowTypeOverlay && item_data->Type != 0)
                            {
                                ImU32 type_col = icon_type_overlay_colors[item_data->Type % IM_ARRAYSIZE(icon_type_overlay_colors)];
                                draw_list->AddRectFilled(ImVec2(box_max.x - 2 - icon_type_overlay_size.x, box_min.y + 2), ImVec2(box_max.x - 2, box_min.y + 2 + icon_type_overlay_size.y), type_col);
                            }
                            if (display_label)
                            {
                                ImU32 label_col = ImGui::GetColorU32(item_is_selected ? ImGuiCol_Text : ImGuiCol_TextDisabled);
                                char label[32];
                                sprintf(label, "%d", item_data->ID);
                                draw_list->AddText(ImVec2(box_min.x, box_max.y - ImGui::GetFontSize()), label_col, label);
                            }
                        }

                        ImGui::PopID();
                    }
                }
            }
            clipper.End();
            ImGui::PopStyleVar(); // ImGuiStyleVar_ItemSpacing

            // Context menu
            if (ImGui::BeginPopupContextWindow())
            {
                ImGui::Text("Selection: %d items", Selection.Size);
                ImGui::Separator();
                if (ImGui::MenuItem("Delete", "Del", false, Selection.Size > 0))
                    RequestDelete = true;
                ImGui::EndPopup();
            }

            ms_io = ImGui::EndMultiSelect();
            Selection.ApplyRequests(ms_io);
            if (want_delete)
                Selection.ApplyDeletionPostLoop(ms_io, Items, item_curr_idx_to_focus);

            // Zooming with CTRL+Wheel
            if (ImGui::IsWindowAppearing())
                ZoomWheelAccum = 0.0f;
            if (ImGui::IsWindowHovered() && io.MouseWheel != 0.0f && ImGui::IsKeyDown(ImGuiMod_Ctrl) && ImGui::IsAnyItemActive() == false)
            {
                ZoomWheelAccum += io.MouseWheel;
                if (fabsf(ZoomWheelAccum) >= 1.0f)
                {
                    // Calculate hovered item index from mouse location
                    // FIXME: Locking aiming on 'hovered_item_idx' (with a cool-down timer) would ensure zoom keeps on it.
                    const float hovered_item_nx = (io.MousePos.x - start_pos.x + LayoutItemSpacing * 0.5f) / LayoutItemStep.x;
                    const float hovered_item_ny = (io.MousePos.y - start_pos.y + LayoutItemSpacing * 0.5f) / LayoutItemStep.y;
                    const int hovered_item_idx = ((int)hovered_item_ny * LayoutColumnCount) + (int)hovered_item_nx;
                    //ImGui::SetTooltip("%f,%f -> item %d", hovered_item_nx, hovered_item_ny, hovered_item_idx); // Move those 4 lines in block above for easy debugging

                    // Zoom
                    IconSize *= powf(1.1f, (float)(int)ZoomWheelAccum);
                    IconSize = IM_CLAMP(IconSize, 16.0f, 128.0f);
                    ZoomWheelAccum -= (int)ZoomWheelAccum;
                    UpdateLayoutSizes(avail_width);

                    // Manipulate scroll to that we will land at the same Y location of currently hovered item.
                    // - Calculate next frame position of item under mouse
                    // - Set new scroll position to be used in next ImGui::BeginChild() call.
                    float hovered_item_rel_pos_y = ((float)(hovered_item_idx / LayoutColumnCount) + fmodf(hovered_item_ny, 1.0f)) * LayoutItemStep.y;
                    hovered_item_rel_pos_y += ImGui::GetStyle().WindowPadding.y;
                    float mouse_local_y = io.MousePos.y - ImGui::GetWindowPos().y;
                    ImGui::SetScrollY(hovered_item_rel_pos_y - mouse_local_y);
                }
            }
        }
        ImGui::EndChild();

        ImGui::Text("Selected: %d/%d items", Selection.Size, Items.Size);
        ImGui::End();
    }
};

void ShowExampleAppAssetsBrowser(bool* p_open)
{
    IMGUI_DEMO_MARKER("Examples/Assets Browser");
    static ExampleAssetsBrowser assets_browser;
    assets_browser.Draw("Example: Assets Browser", p_open);
}

// End of Demo code
#else

void ImGui::ShowAboutWindow(bool*) {}
void ImGui::ShowDemoWindow(bool*) {}
void ImGui::ShowUserGuide() {}
void ImGui::ShowStyleEditor(ImGuiStyle*) {}
bool ImGui::ShowStyleSelector(const char*) { return false; }

#endif // #ifndef IMGUI_DISABLE_DEMO_WINDOWS

#endif // #ifndef IMGUI_DISABLE


================================================================================
FILE: juce\Source\preset_creator\NotificationManager.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <juce_graphics/juce_graphics.h>
#include <deque>

class NotificationManager
{
public:
    enum class Type { Status, Success, Error, Warning, Info };

    // Call this from any thread to post a new notification
    static void post(Type type, const juce::String& message, float duration = 5.0f);

    // Call this once per frame inside your main ImGui render loop
    static void render();

private:
    struct Notification
    {
        uint32_t id;
        Type type;
        juce::String message;
        double startTime;
        float lifetime;
        float alpha = 0.0f; // For fade animation
    };

    // Singleton access
    static NotificationManager& getInstance();

    NotificationManager() = default;
    ~NotificationManager() = default;
    NotificationManager(const NotificationManager&) = delete;
    NotificationManager& operator=(const NotificationManager&) = delete;

    void postImpl(Type type, const juce::String& message, float duration);
    void renderImpl();

    std::deque<Notification> m_notifications;
    juce::CriticalSection m_lock;
    uint32_t m_nextId = 0;
};



================================================================================
FILE: juce\Source\preset_creator\NotificationManager.cpp
================================================================================


#include "NotificationManager.h"
#include "theme/ThemeManager.h"

#include <juce_core/juce_core.h>
#include <imgui.h>
#include <algorithm>

void NotificationManager::post(Type type, const juce::String& message, float duration)
{
    // Directly call postImpl since we're already on the UI thread
    getInstance().postImpl(type, message, duration);
}

void NotificationManager::render()
{
    getInstance().renderImpl();
}

NotificationManager& NotificationManager::getInstance()
{
    static NotificationManager instance;
    return instance;
}

void NotificationManager::postImpl(Type type, const juce::String& message, float duration)
{
    const juce::ScopedLock lock(m_lock);
    
    // When posting Success or Error, automatically dismiss any existing Status notifications
    // This allows the "Saving..." status to be replaced by "Saved!" or "Failed to save!"
    if (type == Type::Success || type == Type::Error)
    {
        m_notifications.erase(
            std::remove_if(m_notifications.begin(), m_notifications.end(),
                [](const Notification& n) { return n.type == Type::Status; }),
            m_notifications.end()
        );
    }
    
    // For Status messages, make them persist until replaced or dismissed
    if (type == Type::Status)
        duration = 3600.0f; // A very long time, effectively persistent until replaced
    // For Error messages, make them persist until clicked
    if (type == Type::Error)
        duration = 3600.0f; 
    
    m_notifications.push_back({
        ++m_nextId,
        type,
        message,
        ImGui::GetTime(),
        duration
    });

    // Debug log to verify notifications are being posted
    juce::String typeStr;
    switch (type) {
        case Type::Success: typeStr = "Success"; break;
        case Type::Error:   typeStr = "Error"; break;
        case Type::Warning: typeStr = "Warning"; break;
        case Type::Info:    typeStr = "Info"; break;
        case Type::Status:  typeStr = "Status"; break;
    }
    juce::Logger::writeToLog("[Toast] " + typeStr + ": " + message);
}

void NotificationManager::renderImpl()
{
    const juce::ScopedLock lock(m_lock);
    if (m_notifications.empty()) return;

    const float now = (float)ImGui::GetTime();
    const float padding = 10.0f;
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImVec2 work_pos = viewport->WorkPos;
    // Adjust Y position to be below the main menu bar
    float currentY = work_pos.y + padding + ImGui::GetFrameHeight();

    // Hard-pinned toast style: no animations, consistent visibility
    const float fadeInTime = 0.0f;
    const float fadeOutTime = 0.0f;

    // Use an iterator to safely remove items while looping
    for (auto it = m_notifications.begin(); it != m_notifications.end(); )
    {
        auto& notif = *it;
        float age = now - (float)notif.startTime;
        // No fade animation; always fully visible until lifetime expires
        notif.alpha = 1.0f;

        float windowWidth = 350.0f;
        float windowHeight = 60.0f;

        // Fixed top-right position (no animation)
        ImVec2 windowPos = ImVec2(viewport->WorkPos.x + viewport->WorkSize.x - windowWidth - padding, currentY);

        // Clamp inside visible work area to avoid off-screen placement
        const float minX = viewport->WorkPos.x + padding;
        const float maxX = viewport->WorkPos.x + viewport->WorkSize.x - windowWidth - padding;
        const float minY = viewport->WorkPos.y + padding + ImGui::GetFrameHeight();
        const float maxY = viewport->WorkPos.y + viewport->WorkSize.y - windowHeight - padding;
        if (maxX > minX) windowPos.x = juce::jlimit(minX, maxX, windowPos.x); else windowPos.x = minX;
        if (maxY > minY) windowPos.y = juce::jlimit(minY, maxY, windowPos.y); else windowPos.y = minY;

        // Ensure window is in the visible work area
        ImGui::SetNextWindowPos(windowPos, ImGuiCond_Always);
        ImGui::SetNextWindowSize(ImVec2(windowWidth, windowHeight));
        ImGui::SetNextWindowBgAlpha(ThemeManager::getInstance().getCurrentTheme().windows.notifications_alpha);

        char windowName[32];
        snprintf(windowName, 32, "Notification##%u", notif.id);
        
        // (No extra overlay; single source of truth to avoid duplicate text)

        ImGui::Begin(windowName, nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize);
        
        if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
            if (age <= notif.lifetime) {
                 notif.startTime = now - notif.lifetime; // Trigger fade-out
            }
        }

        ImVec4 iconColor;
        const char* iconText = nullptr;

        switch (notif.type) {
            case Type::Success: iconColor = ImVec4(0.2f, 1.0f, 0.2f, 1.0f); iconText = "\xE2\x9C\x85"; break;
            case Type::Error:   iconColor = ImVec4(1.0f, 0.2f, 0.2f, 1.0f); iconText = "\xE2\x9D\x8C"; break;
            case Type::Warning: iconColor = ImVec4(1.0f, 0.8f, 0.2f, 1.0f); iconText = "\xE2\x9A\xA0\xEF\xB8\x8F"; break;
            case Type::Info:    iconColor = ImVec4(0.2f, 0.6f, 1.0f, 1.0f); iconText = "\xE2\x84\xB9\xEF\xB8\x8F"; break;
            case Type::Status:  iconColor = ImVec4(0.8f, 0.8f, 0.8f, 1.0f); iconText = nullptr; break;
        }

        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, notif.alpha);

        ImGui::PushStyleColor(ImGuiCol_Text, iconColor);
        if (notif.type == Type::Status) {
            ImDrawList* drawList = ImGui::GetWindowDrawList();
            ImVec2 spinnerCenter = ImVec2(ImGui::GetCursorScreenPos().x + 12, ImGui::GetCursorScreenPos().y + ImGui::GetTextLineHeight() / 2 + 10);
            drawList->PathArcTo(spinnerCenter, 8.0f, now * 4.0f, now * 4.0f + 4.0f, 32);
            drawList->PathStroke(ImGui::GetColorU32(iconColor), 0, 2.0f);
        } else if (iconText) {
            ImGui::TextUnformatted(iconText);
        }
        ImGui::PopStyleColor();

        ImGui::SameLine(35.0f);
        ImGui::TextWrapped("%s", notif.message.toRawUTF8());

        if (notif.type != Type::Error && notif.type != Type::Status) {
            float progress = juce::jlimit(0.0f, 1.0f, age / notif.lifetime);
            ImVec2 p_min = ImVec2(ImGui::GetWindowPos().x, ImGui::GetWindowPos().y + windowHeight - 3.0f);
            ImVec2 p_max = ImVec2(p_min.x + windowWidth * (1.0f - progress), p_min.y + 3.0f);
            ImGui::GetWindowDrawList()->AddRectFilled(p_min, p_max, ImGui::GetColorU32(iconColor));
        }
        
        ImGui::PopStyleVar();
        ImGui::End();

        bool shouldDismiss = (notif.type != Type::Error && (now - notif.startTime) > notif.lifetime);
        if (shouldDismiss) {
            it = m_notifications.erase(it);
        } else {
            currentY += windowHeight + padding;
            ++it;
        }
    }
}



================================================================================
FILE: juce\Source\preset_creator\PresetCreatorApplication.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>

class PresetCreatorApplication : public juce::JUCEApplication
{
public:
    const juce::String getApplicationName() override { return "Preset Creator"; }
    const juce::String getApplicationVersion() override { return "0.1.0"; }
    
    // Accessors for shared components
    juce::AudioDeviceManager& getAudioDeviceManager() { return audioDeviceManager; }
    juce::AudioPluginFormatManager& getPluginFormatManager() { return pluginFormatManager; }
    juce::KnownPluginList& getKnownPluginList() { return knownPluginList; }
    
    // Static getter for global access
    static PresetCreatorApplication& getApp()
    {
        return *dynamic_cast<PresetCreatorApplication*>(juce::JUCEApplication::getInstance());
    }
    
    juce::PropertiesFile* getProperties() { return appProperties.get(); }
    
    void initialise(const juce::String&) override;
    void shutdown() override;

    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow(juce::String name, 
                   juce::AudioDeviceManager& adm,
                   juce::AudioPluginFormatManager& fm,
                   juce::KnownPluginList& kl);
        void closeButtonPressed() override { juce::JUCEApplication::getInstance()->systemRequestedQuit(); }
        bool keyPressed (const juce::KeyPress& key) override;
        
    private:
        juce::AudioDeviceManager& deviceManager;
        juce::AudioPluginFormatManager& pluginFormatManager;
        juce::KnownPluginList& knownPluginList;

        bool isMaximizedLike = false;
        juce::Rectangle<int> lastNormalBounds;

        void applyMaximizeLike();
        void restoreFromMaximizeLike();
    };

private:
    // Shared components for the entire application
    juce::AudioDeviceManager audioDeviceManager;
    juce::AudioPluginFormatManager pluginFormatManager;
    juce::KnownPluginList knownPluginList;
    juce::File pluginScanListFile;
    
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<juce::PropertiesFile> appProperties;
};



================================================================================
FILE: juce\Source\preset_creator\PresetCreatorMain.cpp
================================================================================


#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include "../utils/RtLogger.h"

void PresetCreatorApplication::initialise(const juce::String&)
    {
        DBG("[PresetCreator] initialise() starting"); RtLogger::init();
        // Crash handler to capture unexpected exceptions
        std::set_terminate([]{
            auto bt = juce::SystemStats::getStackBacktrace();
            juce::Logger::writeToLog("[PresetCreator][FATAL] terminate called. Backtrace:\n" + bt);
            std::abort();
        });
        // Set up file logger for diagnostics
        auto logsDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile)
                           .getParentDirectory().getChildFile ("juce").getChildFile ("logs");
        logsDir.createDirectory();
        auto logFile = logsDir.getChildFile ("preset_creator_" + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log");
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 0);
        juce::Logger::setCurrentLogger (fileLogger.get());
        DBG("[PresetCreator] Logger initialised at: " + logFile.getFullPathName());
        juce::Logger::writeToLog("PresetCreatorApplication::initialise called");
        
        // ADD: Load persistent audio settings
        // Define where to store the settings file
        auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                .getChildFile(getApplicationName());
        appDataDir.createDirectory(); // Ensure the directory exists
        auto settingsFile = appDataDir.getChildFile("audio_settings.xml");

        std::unique_ptr<juce::XmlElement> savedState;
        if (settingsFile.existsAsFile())
        {
            savedState = juce::XmlDocument::parse(settingsFile);
            juce::Logger::writeToLog("Loading audio settings from: " + settingsFile.getFullPathName());
        }
        else
        {
            juce::Logger::writeToLog("No saved audio settings found, using defaults");
        }
        
        // Pass the saved state to the device manager.
        // It will automatically use the saved settings or fall back to defaults.
        audioDeviceManager.initialise(2, 2, savedState.get(), true);
        
        // Initialize plugin management
        pluginFormatManager.addDefaultFormats();
        
        // Initialize application properties
        juce::PropertiesFile::Options options;
        options.applicationName = getApplicationName();
        options.filenameSuffix = ".settings";
        options.osxLibrarySubFolder = "Application Support";
        options.folderName = appDataDir.getFullPathName();
        appProperties = std::make_unique<juce::PropertiesFile>(options);
        
        // Define where to save the plugin list XML
        auto deadMansPedalFile = appDataDir.getChildFile("blacklisted_plugins.txt");
        pluginScanListFile = appDataDir.getChildFile("known_plugins.xml");
        
        // Load the list from the XML file
        if (pluginScanListFile.existsAsFile())
        {
            auto pluginListXml = juce::XmlDocument::parse(pluginScanListFile);
            if (pluginListXml != nullptr)
            {
                knownPluginList.recreateFromXml(*pluginListXml);
                juce::Logger::writeToLog("Loaded " + juce::String(knownPluginList.getNumTypes()) + " plugin(s) from cache");
            }
        }
        else
        {
            juce::Logger::writeToLog("No cached plugin list found");
        }
        
        juce::Logger::writeToLog("Attempting to create MainWindow...");
        mainWindow.reset (new MainWindow (getApplicationName(), 
                                         audioDeviceManager,
                                         pluginFormatManager,
                                         knownPluginList));
        juce::Logger::writeToLog("MainWindow created successfully");
}

void PresetCreatorApplication::shutdown()
{ 
        // Save persistent audio settings
        std::unique_ptr<juce::XmlElement> currentState(audioDeviceManager.createStateXml());

        if (currentState != nullptr)
        {
            // Define the same settings file path as in initialise()
            auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                    .getChildFile(getApplicationName());
            auto settingsFile = appDataDir.getChildFile("audio_settings.xml");

            // Write the XML to the file
            if (currentState->writeTo(settingsFile))
            {
                juce::Logger::writeToLog("Audio settings saved to: " + settingsFile.getFullPathName());
            }
            else
            {
                juce::Logger::writeToLog("Failed to save audio settings to: " + settingsFile.getFullPathName());
            }
        }
        
        // Save plugin list
        if (auto pluginListXml = knownPluginList.createXml())
        {
            if (pluginListXml->writeTo(pluginScanListFile))
            {
                juce::Logger::writeToLog("Plugin list saved to: " + pluginScanListFile.getFullPathName());
            }
        }
        
        // Save window state and application properties
        if (appProperties)
        {
            if (mainWindow != nullptr && ! mainWindow->isFullScreen())
                appProperties->setValue ("presetCreatorWindowState", mainWindow->getWindowStateAsString());
            appProperties->saveIfNeeded();
        }
        
        RtLogger::shutdown(); 
        mainWindow = nullptr; 
        juce::Logger::setCurrentLogger (nullptr); 
        fileLogger = nullptr; 
}

PresetCreatorApplication::MainWindow::MainWindow(juce::String name, 
                                                 juce::AudioDeviceManager& adm,
                                                 juce::AudioPluginFormatManager& fm,
                                                 juce::KnownPluginList& kl)
    : DocumentWindow(name,
                     juce::Desktop::getInstance().getDefaultLookAndFeel()
                         .findColour(ResizableWindow::backgroundColourId),
                     DocumentWindow::allButtons),
      deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("MainWindow constructor starting...");
    setUsingNativeTitleBar(true);
    juce::Logger::writeToLog("Attempting to create PresetCreatorComponent...");
    setContentOwned(new PresetCreatorComponent(deviceManager, pluginFormatManager, knownPluginList), true);
    juce::Logger::writeToLog("PresetCreatorComponent created and set.");
    setResizable (true, true);
    setResizeLimits (900, 600, 8192, 8192);

    // Try to restore previous window state from properties
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto state = props->getValue ("presetCreatorWindowState");
        if (state.isNotEmpty())
        {
            if (! restoreWindowStateFromString (state))
                centreWithSize (2600, 1080);
        }
        else
        {
            centreWithSize (2600, 1080);
        }
    }
    else
    {
        centreWithSize (2600, 1080);
    }
    setVisible(true);
    toFront(true);
    
    // Clamp to work area
    auto& displays = juce::Desktop::getInstance().getDisplays();
    auto* display = displays.getDisplayForRect (getBounds());
    if (display == nullptr) display = displays.getPrimaryDisplay();
    if (display != nullptr) setBounds (getBounds().constrainedWithin (display->userArea));
    juce::Logger::writeToLog("MainWindow setup complete");
}

bool PresetCreatorApplication::MainWindow::keyPressed (const juce::KeyPress& key)
{
    if (key.getKeyCode() == juce::KeyPress::F11Key)
    {
        setFullScreen (! isFullScreen());
        return true;
    }
    if (key.getKeyCode() == juce::KeyPress::returnKey && key.getModifiers().isAltDown())
    {
        if (isFullScreen())
            setFullScreen (false);
        else if (! isMaximizedLike)
            applyMaximizeLike();
        else
            restoreFromMaximizeLike();
        return true;
    }
    return DocumentWindow::keyPressed (key);
}

void PresetCreatorApplication::MainWindow::applyMaximizeLike()
{
    if (! isMaximizedLike)
    {
        lastNormalBounds = getBounds();
        auto& displays = juce::Desktop::getInstance().getDisplays();
        if (auto* d = displays.getDisplayForRect (getBounds())) setBounds (d->userArea);
        else if (auto* p = displays.getPrimaryDisplay()) setBounds (p->userArea);
        isMaximizedLike = true;
    }
}

void PresetCreatorApplication::MainWindow::restoreFromMaximizeLike()
{
    if (isMaximizedLike)
    {
        if (! lastNormalBounds.isEmpty()) setBounds (lastNormalBounds);
        isMaximizedLike = false;
    }
}

START_JUCE_APPLICATION (PresetCreatorApplication)




================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/MidiDeviceManager.h"

class PresetCreatorComponent : public juce::Component,
                               private juce::Button::Listener,
                               private juce::Timer
{
public:
    PresetCreatorComponent(juce::AudioDeviceManager& deviceManager,
                           juce::AudioPluginFormatManager& formatManager,
                           juce::KnownPluginList& knownPluginList);
    ~PresetCreatorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    
    // Unified playback control (audio engine + transport)
    void setMasterPlayState(bool shouldBePlaying);
    
    bool keyPressed (const juce::KeyPress& key) override;
    bool keyStateChanged (bool isKeyDown) override;
    void visibilityChanged() override;

    // ADD: Public function to show audio settings dialog
    void showAudioSettingsDialog();
    
    // Get MIDI activity indicator state
    int getMidiActivityFrames() const { return midiActivityFrames; }
    
    // Multi-MIDI device manager (public for access from ImGuiNodeEditorComponent)
    std::unique_ptr<MidiDeviceManager> midiDeviceManager;

private:
    int midiActivityFrames = 0; // For MIDI activity indicator

    void setWindowFileName(const juce::String& fileName);
    void buttonClicked (juce::Button*) override;
    void timerCallback() override;
    void refreshModulesList();
    void doConnect();
    void doSave();
    void startAudition();
    void stopAudition();

    juce::TextButton btnAddVCO { "Add VCO" };
    juce::TextButton btnAddVCF { "Add VCF" };
    juce::TextButton btnAddVCA { "Add VCA" };
    juce::TextButton btnConnect { "Connect" };
    juce::TextButton btnSave { "Save Preset" };
    juce::TextButton btnLoad { "Load Preset" };

    juce::ListBox listModules { "Modules", nullptr };
    struct ModulesModel : public juce::ListBoxModel
    {
        juce::StringArray rows;
        int getNumRows() override { return rows.size(); }
        void paintListBoxItem (int row, juce::Graphics& g, int w, int h, bool sel) override
        {
            g.fillAll (sel ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
            g.setColour (juce::Colours::white);
            if (row >= 0 && row < rows.size()) g.drawText (rows[row], 6, 0, w - 12, h, juce::Justification::centredLeft);
        }
    } modulesModel;

    juce::ComboBox cbSrc, cbDst, cbSrcChan, cbDstChan;
    juce::TextEditor log;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<class ImGuiNodeEditorComponent> editor;

    std::unique_ptr<ModularSynthProcessor> synth;
    double sampleRate { 48000.0 };
    int blockSize { 512 };

    std::unique_ptr<juce::FileChooser> saveChooser;
    std::unique_ptr<juce::FileChooser> loadChooser;

    // Unified spacebar control (toggle and momentary gate mode)
    juce::uint64 spacebarDownTime { 0 };
    bool wasLongPress { false };
    static constexpr int longPressThresholdMs = 250;

    juce::AudioDeviceManager& deviceManager;
    juce::AudioPluginFormatManager& pluginFormatManager;
    juce::KnownPluginList& knownPluginList;
    juce::AudioProcessorPlayer processorPlayer;
    bool auditioning { false };
};




================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.cpp
================================================================================


// RtLogger flush integrated via timer in component
#include "PresetCreatorComponent.h"
#include "ImGuiNodeEditorComponent.h"
#include "../utils/RtLogger.h"

PresetCreatorComponent::PresetCreatorComponent(juce::AudioDeviceManager& adm,
                                               juce::AudioPluginFormatManager& fm,
                                               juce::KnownPluginList& kl)
    : deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("PresetCreatorComponent constructor starting...");
    addAndMakeVisible (log);

    // Replace list/combos UI with ImGui node editor
    juce::Logger::writeToLog("Attempting to create ImGuiNodeEditorComponent...");
    editor.reset (new ImGuiNodeEditorComponent(deviceManager));
    juce::Logger::writeToLog("ImGuiNodeEditorComponent created.");
    editor->onShowAudioSettings = [this]() { this->showAudioSettingsDialog(); };
    addAndMakeVisible (editor.get());
    log.setMultiLine (true); log.setReadOnly (true);

    juce::Logger::writeToLog("Creating ModularSynthProcessor...");
    synth = std::make_unique<ModularSynthProcessor>();
    
    // --- THIS IS THE FIX ---
    // Set the managers immediately so the synth is ready for state restoration.
    synth->setPluginFormatManager(&pluginFormatManager);
    synth->setKnownPluginList(&knownPluginList);
    juce::Logger::writeToLog("Plugin managers set on ModularSynthProcessor.");
    // --- END OF FIX ---
    
    juce::Logger::writeToLog("Setting model on editor...");
    if (editor != nullptr)
    {
        editor->setModel (synth.get());
    }
    synth->prepareToPlay (sampleRate, blockSize);

    // Use the shared AudioDeviceManager settings
    if (auto* dev = deviceManager.getCurrentAudioDevice())
    {
        sampleRate = dev->getCurrentSampleRate();
        blockSize = dev->getCurrentBufferSizeSamples();
        synth->prepareToPlay (sampleRate, blockSize);
        juce::Logger::writeToLog ("Audio device: " + dev->getName() +
                                   ", sr=" + juce::String (sampleRate) +
                                   ", bs=" + juce::String (blockSize));
    }
    // AudioProcessorPlayer lives in juce_audio_utils namespace path include; type is juce::AudioSourcePlayer for routing
    // Use AudioProcessorPlayer via juce_audio_utils module
    processorPlayer.setProcessor (synth.get());
    
    // --- MULTI-MIDI DEVICE SUPPORT ---
    // Initialize multi-device MIDI manager
    midiDeviceManager = std::make_unique<MidiDeviceManager>(deviceManager);
    midiDeviceManager->scanDevices();
    midiDeviceManager->enableAllDevices();  // Enable all MIDI devices by default
    juce::Logger::writeToLog("[MIDI] Multi-device manager initialized");
    // Note: MidiDeviceManager now handles all MIDI input callbacks
    // The processorPlayer will receive MIDI through ModularSynthProcessor's processBlock
    // --- END MULTI-MIDI SUPPORT ---
    
    // === CRITICAL FIX: Audio callback must ALWAYS be active for MIDI processing ===
    // Without this, processBlock never runs and MIDI learn doesn't work!
    deviceManager.addAudioCallback(&processorPlayer);
    auditioning = true;  // Set flag to indicate audio is active
    juce::Logger::writeToLog("[Audio] Audio callback started - synth is now processing");
    // === END FIX ===
    
    setWantsKeyboardFocus (true);

    // Setup FileLogger at the same path the user checks: <exe>/juce/logs/preset_creator_*.log
    {
        auto exeDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory();
        auto juceLogsDir = exeDir.getChildFile ("juce").getChildFile ("logs");
        juceLogsDir.createDirectory();
        auto logName = juce::String ("preset_creator_") + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log";
        auto logFile = juceLogsDir.getChildFile (logName);
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 10 * 1024 * 1024);
        if (fileLogger != nullptr)
            juce::Logger::setCurrentLogger (fileLogger.get());
        juce::Logger::writeToLog ("PresetCreator log file: " + logFile.getFullPathName());
    }
    // Init RT logger and start periodic flush
    RtLogger::init (2048, 256);
    
    // NOTE: Audio Settings button removed - now using menu integration
    
    juce::Logger::writeToLog ("PresetCreator constructed");
    startTimerHz (30);
    
    setWindowFileName({}); // Set the default title on startup
}

// ADD: Implementation of the audio settings dialog function
void PresetCreatorComponent::showAudioSettingsDialog()
{
    auto* component = new juce::AudioDeviceSelectorComponent(
        deviceManager, 0, 256, 0, 256, true, true, false, false);
    
    component->setSize(500, 450);

    juce::DialogWindow::LaunchOptions o;
    o.content.setOwned(component);
    o.dialogTitle                   = "Audio Settings";
    o.dialogBackgroundColour        = juce::Colours::darkgrey;
    o.escapeKeyTriggersCloseButton  = true;
    o.resizable                     = false;
    o.launchAsync();
}

void PresetCreatorComponent::setWindowFileName(const juce::String& fileName)
{
    // Find the parent window of this component
    if (auto* window = findParentComponentOfClass<juce::DocumentWindow>())
    {
        juce::String newTitle = "Preset Creator"; // The default title
        if (fileName.isNotEmpty())
        {
            newTitle += " - " + fileName; // Append the filename if one is provided
        }
        window->setName(newTitle);
    }
}

void PresetCreatorComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void PresetCreatorComponent::resized()
{
    for (auto* c : getChildren())
        if (dynamic_cast<ImGuiNodeEditorComponent*>(c) != nullptr)
            c->setBounds (0, 0, getWidth(), getHeight());
    
    // Audio Settings button removed - now using menu integration
    
    // Keep log overlay minimal for now
    log.setBounds (10, getHeight() - 160, getWidth() - 20, 150);
}

void PresetCreatorComponent::setMasterPlayState(bool shouldBePlaying)
{
    if (synth == nullptr)
        return;

    // 1. Control the Audio Engine (start/stop pulling audio)
    if (shouldBePlaying)
    {
        if (!auditioning)
        {
            deviceManager.addAudioCallback(&processorPlayer);
            auditioning = true;
        }
    }
    else
    {
        if (auditioning)
        {
            deviceManager.removeAudioCallback(&processorPlayer);
            auditioning = false;
        }
    }

    // 2. Control the synth's internal transport clock
    synth->setPlaying(shouldBePlaying);
}

PresetCreatorComponent::~PresetCreatorComponent()
{
    // MULTI-MIDI SUPPORT: MidiDeviceManager handles cleanup automatically in its destructor
    midiDeviceManager.reset();

    stopAudition();
    processorPlayer.setProcessor (nullptr);
    juce::Logger::writeToLog ("PresetCreator destroyed");
    RtLogger::shutdown();
    juce::Logger::setCurrentLogger (nullptr);
}

void PresetCreatorComponent::buttonClicked (juce::Button* b)
{
    if (b == &btnAddVCO) { synth->addModule ("VCO"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCF) { synth->addModule ("VCF"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCA) { synth->addModule ("VCA"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnConnect) { doConnect(); }
    else if (b == &btnSave) { doSave(); }
    else if (b == &btnLoad) { if (editor) editor->startLoadDialog(); }
}

void PresetCreatorComponent::refreshModulesList()
{
    modulesModel.rows.clear();
    cbSrc.clear(); cbDst.clear();
    int idx = 1;
    for (auto [logicalId, type] : synth->getModulesInfo())
    {
        modulesModel.rows.add (juce::String ((int) logicalId) + " - " + type);
        cbSrc.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        cbDst.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        ++idx;
    }
    cbDst.addItem ("Output", 9999);
    listModules.updateContent();
}

void PresetCreatorComponent::doConnect()
{
    int selSrc = cbSrc.getSelectedId();
    int selDst = cbDst.getSelectedId();
    if (selSrc <= 0 || selDst <= 0) { log.insertTextAtCaret ("Select src/dst first\n"); return; }

    // Extract logical IDs from combo texts
    auto parseId = [] (const juce::String& s) -> juce::uint32 { return (juce::uint32) s.upToFirstOccurrenceOf(" ", false, false).getIntValue(); };
    juce::uint32 srcLogical = parseId (cbSrc.getText());
    juce::uint32 dstLogical = parseId (cbDst.getText());

    auto srcNode = synth->getNodeIdForLogical (srcLogical);
    juce::AudioProcessorGraph::NodeID dstNode;
    if (cbDst.getSelectedId() == 9999)
        dstNode = synth->getOutputNodeID();
    else
        dstNode = synth->getNodeIdForLogical (dstLogical);
    const int srcChan = cbSrcChan.getSelectedId() - 1;
    const int dstChan = cbDstChan.getSelectedId() - 1;
    if (srcNode.uid != 0 && dstNode.uid != 0)
    {
        if (synth->connect (srcNode, srcChan, dstNode, dstChan))
        {
            log.insertTextAtCaret ("Connected\n");
            synth->commitChanges();
        }
        else
        {
            log.insertTextAtCaret ("Connect failed\n");
        }
    }
}

void PresetCreatorComponent::doSave()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", startDir, "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.exists() || f.getParentDirectory().exists())
        {
            // Ensure directory exists when saving into default folder
            f.getParentDirectory().createDirectory();
            
            // --- FIX: Temporarily unmute nodes to save original connections ---
            // When nodes are muted, their connections are replaced with bypass routing.
            // We must save the ORIGINAL connections, not the bypass connections.
            
            // 1. Get a list of all currently muted nodes from the editor
            std::vector<juce::uint32> currentlyMutedNodes;
            if (editor)
            {
                for (const auto& pair : editor->mutedNodeStates)
                {
                    currentlyMutedNodes.push_back(pair.first);
                }
                
                // 2. Temporarily UNMUTE all of them to restore the original connections
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->unmuteNode(lid);
                }
            }
            
            // 3. CRITICAL: Force the synth to apply these connection changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // At this point, the synth graph is in its "true", unmuted state
            
            // 4. NOW get the state - this will save the correct, original connections
            juce::MemoryBlock mb;
            synth->getStateInformation (mb);
            auto xml = juce::XmlDocument::parse (mb.toString());
            if (! xml) return;
            
            // 5. IMMEDIATELY RE-MUTE the nodes to return the editor to its visible state
            if (editor)
            {
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->muteNode(lid);
                }
            }
            
            // 6. CRITICAL: Force the synth to apply the re-mute changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // The synth graph is now back to its bypassed state for audio processing
            // --- END OF FIX ---
            
            juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
            // Attach UI state as child (which correctly contains the "muted" flags)
            if (editor)
            {
                juce::ValueTree ui = editor->getUiValueTree();
                presetVT.addChild (ui, -1, nullptr);
            }
            // Write
            f.replaceWithText (presetVT.createXml()->toString());
            log.insertTextAtCaret ("Saved: " + f.getFullPathName() + "\n");
            
            setWindowFileName(f.getFileName()); // Update title bar with filename
        }
    });
}

// Removed legacy doLoad(): loading is centralized in ImGuiNodeEditorComponent::startLoadDialog()

bool PresetCreatorComponent::keyPressed (const juce::KeyPress& key)
{
    if (key.getKeyCode() == juce::KeyPress::spaceKey)
    {
        if (spacebarDownTime == 0) // Only record time on the initial press
        {
            spacebarDownTime = juce::Time::getMillisecondCounter();
            wasLongPress = false;
        }
        return true;
    }
    return false;
}

bool PresetCreatorComponent::keyStateChanged (bool isKeyDown)
{
    juce::ignoreUnused (isKeyDown);

    if (!juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
    {
        if (spacebarDownTime != 0) // Key was just released
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration < longPressThresholdMs && !wasLongPress)
            {
                // SHORT PRESS (TOGGLE)
                if (synth)
                {
                    const bool isCurrentlyPlaying = synth->getTransportState().isPlaying;
                    setMasterPlayState(!isCurrentlyPlaying); // Use the unified function
                }
            }
            // If it was a long press, the timer callback will handle stopping.
        }
        spacebarDownTime = 0; // Reset for next press
    }
    return false;
}

void PresetCreatorComponent::visibilityChanged()
{
    juce::Logger::writeToLog (juce::String ("Component visible? ") + (isShowing() ? "yes" : "no"));
}

void PresetCreatorComponent::startAudition()
{
    if (auditioning) return;
    deviceManager.addAudioCallback (&processorPlayer);
    auditioning = true;
    log.insertTextAtCaret ("[Audition] Start (hold space)\n");
}

void PresetCreatorComponent::stopAudition()
{
    if (! auditioning) return;
    deviceManager.removeAudioCallback (&processorPlayer);
    auditioning = false;
    log.insertTextAtCaret ("[Audition] Stop\n");
}

void PresetCreatorComponent::timerCallback()
{
    RtLogger::flushToFileLogger();
    
    // MULTI-MIDI SUPPORT: Transfer MIDI messages from MidiDeviceManager to ModularSynthProcessor
    if (midiDeviceManager && synth)
    {
        std::vector<MidiDeviceManager::MidiMessageWithSource> midiMessages;
        midiDeviceManager->swapMessageBuffer(midiMessages);
        
        if (!midiMessages.empty())
        {
            juce::Logger::writeToLog("[PresetCreator] Received " + juce::String(midiMessages.size()) + 
                                    " MIDI messages from MidiDeviceManager");
            
            // Convert to ModularSynthProcessor format
            std::vector<MidiMessageWithDevice> convertedMessages;
            convertedMessages.reserve(midiMessages.size());
            
            for (const auto& msg : midiMessages)
            {
                MidiMessageWithDevice converted;
                converted.message = msg.message;
                converted.deviceIdentifier = msg.deviceIdentifier;
                converted.deviceName = msg.deviceName;
                converted.deviceIndex = msg.deviceIndex;
                convertedMessages.push_back(converted);
            }
            
            juce::Logger::writeToLog("[PresetCreator] Passing " + juce::String(convertedMessages.size()) + 
                                    " messages to ModularSynthProcessor");
            
            // Pass to synth for distribution to modules
            synth->processMidiWithDeviceInfo(convertedMessages);
        }
    }
    
    // Check for MIDI activity from the synth
    if (synth != nullptr && synth->hasMidiActivity())
        midiActivityFrames = 30;
    
    // Update MIDI activity indicator in editor
    if (editor != nullptr)
        editor->setMidiActivityFrames(midiActivityFrames);
    
    if (synth != nullptr)
    {
        // Check for long press activation
        if (spacebarDownTime != 0 && !wasLongPress)
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration >= longPressThresholdMs)
            {
                wasLongPress = true;
                setMasterPlayState(true); // Use the unified function
            }
        }
        
        // Check for long press release
        if (wasLongPress && !juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
        {
            setMasterPlayState(false); // Use the unified function
            wasLongPress = false;
            spacebarDownTime = 0;
        }
    }

    static int counter = 0;
    if ((++counter % 60) == 0)
        juce::Logger::writeToLog ("[Heartbeat] UI alive");
}


================================================================================
FILE: guides\XML_SAVING_AND_LOADING_HOW_TO.md
================================================================================


# XML Preset Saving and Loading - Complete Technical Guide

**Target Audience:** AI assistants and developers who need to understand the complete XML preset system in this JUCE-based modular synthesizer project.

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture](#architecture)
3. [Supporting Systems](#supporting-systems)
4. [The Save Process](#the-save-process)
5. [The Load Process](#the-load-process)
6. [XML File Structure](#xml-file-structure)
7. [Module Parameter Serialization](#module-parameter-serialization)
8. [Connection Management](#connection-management)
9. [UI State Persistence](#ui-state-persistence)
10. [Special Cases](#special-cases)
11. [Code Examples](#code-examples)
12. [Improvement Opportunities](#improvement-opportunities)

---

## System Overview

This modular synthesizer uses **XML-based presets** to save and restore complete patch configurations including:

- **Modules** (VCO, VCF, VCA, effects, utilities, etc.)
- **Module parameters** (frequency, waveform, envelope settings, etc.)
- **Audio connections** (routing between modules)
- **Modulation routings** (CV parameter modulation)
- **UI state** (node positions, colors, mute states)
- **VST plugin instances** (including their internal state)

The system is built on **JUCE's ValueTree** and **AudioProcessorValueTreeState (APVTS)** framework, which provides:
- Automatic parameter management
- Undo/redo support
- Thread-safe parameter access
- XML serialization/deserialization

---

## Architecture

### Key Classes

#### 1. **ModularSynthProcessor** (`juce/Source/audio/graph/ModularSynthProcessor.cpp`)
The core audio graph that manages all modules and connections.

**Responsibilities:**
- Maintains the `AudioProcessorGraph` (JUCE's internal audio routing system)
- Tracks all modules via **logical IDs** (stable across save/load)
- Implements `getStateInformation()` and `setStateInformation()` for serialization
- Manages audio connections between modules

#### 2. **ModuleProcessor** (`juce/Source/audio/modules/ModuleProcessor.h`)
Abstract base class for all synthesizer modules.

**Responsibilities:**
- Provides `getAPVTS()` for parameter access
- Implements `getExtraStateTree()` for module-specific state (file paths, etc.)
- Handles audio processing via `processBlock()`

#### 3. **PresetCreatorComponent** (`juce/Source/preset_creator/PresetCreatorComponent.cpp`)
The UI layer that triggers save/load operations.

**Responsibilities:**
- Presents file chooser dialogs
- Orchestrates save/load sequences
- Handles mute state management during save
- Updates UI after load

#### 4. **ImGuiNodeEditorComponent** (`juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`)
The visual node graph editor.

**Responsibilities:**
- Stores node positions, colors, sizes
- Manages mute states
- Provides `getUiValueTree()` for UI serialization
- Applies UI state via `applyUiValueTreeNow()`

---

## Supporting Systems

The XML save/load system relies on two critical supporting systems that define module metadata and documentation. Understanding these systems is essential for improving save/load functionality or adding new module types.

### 1. Pin Database (`juce/Source/preset_creator/PinDatabase.cpp`)

#### Overview

The **Pin Database** is a static registry that defines the input/output pin configuration for every module type in the system. It is used by the node editor UI to render pins correctly, validate connections, and provide auto-connection features.

#### Purpose

The pin database serves multiple critical functions:

1. **UI Rendering:** Tells the node editor which pins to display for each module type
2. **Connection Validation:** Ensures connections are made to valid pin types (Audio, CV, Gate, etc.)
3. **Auto-Connection:** Enables keyboard shortcuts (C/G/B/Y/R/V) to chain modules by data type
4. **Pin Type Safety:** Defines data types (Audio, CV, Gate, Raw, Video) for each pin
5. **Channel Mapping:** Specifies absolute channel indices for multi-channel modules

#### Key Data Structures

```cpp
// From PinDatabase.h (implied structure)
struct AudioPin {
    juce::String name;          // Display name (e.g., "In L", "Frequency Mod")
    int channelIndex;           // Absolute channel index in audio bus
    PinDataType dataType;       // Audio, CV, Gate, Raw, or Video
};

struct ModPin {
    juce::String name;          // Display name (e.g., "Frequency")
    juce::String paramId;       // APVTS parameter ID (e.g., "frequency_mod")
    PinDataType dataType;       // Typically CV
};

struct ModulePinInfo {
    NodeWidth defaultWidth;     // Small, Medium, Big, ExtraWide, or Exception
    std::vector<AudioPin> audioIns;   // Input pins
    std::vector<AudioPin> audioOuts;  // Output pins
    std::vector<ModPin> modPins;      // Modulation pins (for UI parameter disabling)
};
```

#### How It Works

The database is populated once at startup via `populatePinDatabase()`. Each module type is registered with its complete pin configuration:

```cpp
db["vco"] = ModulePinInfo(
    NodeWidth::Small,
    { 
        AudioPin("Frequency", 0, PinDataType::CV),
        AudioPin("Waveform", 1, PinDataType::CV),
        AudioPin("Gate", 2, PinDataType::Gate)
    },
    { 
        AudioPin("Out", 0, PinDataType::Audio)
    },
    {}
);
```

#### Relationship to Save/Load

**Important:** The Pin Database is **NOT directly saved in XML presets**. However, it is critical for load validation and UI reconstruction:

1. **Module Type Verification:** When loading, the system checks that the `type` string in XML matches a registered module type in the pin database
2. **Connection Validation:** After loading connections, the pin database can verify that connections target valid pins
3. **UI Reconstruction:** The node editor uses the pin database to rebuild the visual representation of loaded modules
4. **Missing Module Detection:** If a module type doesn't exist in the pin database, the UI can flag it as "unknown module type"

#### Important Notes for External Developers

- **Module Type Names:** The `type` string in XML (e.g., `"VCO"`, `"sample_loader"`) must exactly match the key used in the pin database (case-insensitive matching may be used, but exact match is safest)
- **Dynamic Pins:** Some modules (Timeline, BPM Monitor, Color Tracker) have **dynamic pins** that are added programmatically at runtime. These modules use empty pin lists in the database:
  ```cpp
  db["timeline"] = ModulePinInfo(
      NodeWidth::Big,
      {}, // Dynamic - defined by module at runtime
      {}, // Dynamic - defined by module at runtime
      {}
  );
  ```
- **Channel Indices:** The `channelIndex` in AudioPin corresponds to the **absolute bus channel index** used in JUCE's audio graph. Connection restoration uses these indices:
  ```xml
  <connection srcId="3" srcChan="0" dstId="4" dstChan="0"/>
  ```
  The `srcChan="0"` and `dstChan="0"` values come from the pin database's `channelIndex` fields.

#### Adding New Modules

When adding a new module type to the system:

1. **Add to Pin Database:** Register the module's pins in `populatePinDatabase()`
2. **Match Type String:** Ensure the `type` property saved in XML matches the database key
3. **Channel Consistency:** Keep channel indices consistent between pin database and module's actual bus layout

#### Example: VCO Pin Configuration

```cpp
// In PinDatabase.cpp
db["vco"] = ModulePinInfo(
    NodeWidth::Small,
    // Inputs: 3 pins on bus channels 0, 1, 2
    { 
        AudioPin("Frequency", 0, PinDataType::CV),    // Bus channel 0
        AudioPin("Waveform", 1, PinDataType::CV),      // Bus channel 1
        AudioPin("Gate", 2, PinDataType::Gate)         // Bus channel 2
    },
    // Outputs: 1 pin on bus channel 0
    { 
        AudioPin("Out", 0, PinDataType::Audio)         // Bus channel 0
    },
    {}  // No modulation pins (uses standard CV modulation)
);
```

When a connection is saved:
```xml
<connection srcId="5" srcChan="0" dstId="6" dstChan="0"/>
```

This means: Module 5's output pin at channel 0 ‚Üí Module 6's input pin at channel 0.

---

### 2. Nodes Dictionary (`USER_MANUAL/Nodes_Dictionary.md`)

#### Overview

The **Nodes Dictionary** is a comprehensive user-facing documentation file that describes every module in the system. It provides detailed information about inputs, outputs, parameters, and usage instructions for each module type.

#### Purpose

While not directly used by the save/load code, the Nodes Dictionary is essential for:

1. **Human-Readable Documentation:** Provides user-facing descriptions of what each module does
2. **Module Discovery:** Helps users understand what modules are available
3. **Parameter Reference:** Documents all parameters that get saved via APVTS
4. **Connection Guidance:** Shows what types of signals can connect where
5. **External Developer Reference:** Critical for understanding the expected behavior of modules during save/load

#### Structure

Each module entry in the dictionary includes:

- **Module Name:** Display name (e.g., "VCO", "Sample Loader")
- **Category:** Source, Effect, Modulator, Utility, etc.
- **Inputs:** List of input pins with data types
- **Outputs:** List of output pins with data types
- **Parameters:** All adjustable parameters with ranges
- **Usage Instructions:** How to use the module effectively

#### Relationship to Save/Load

The dictionary documents what gets saved/loaded for each module:

1. **Parameter Names:** All parameters listed in the dictionary are saved via APVTS:
   ```xml
   <PARAM id="frequency" value="440.0"/>
   ```
   The `id` must match the parameter ID in the module's `createParameterLayout()`.

2. **Module Types:** The dictionary lists all module type strings that can appear in XML:
   ```xml
   <module logicalId="3" type="VCO">
   ```
   The `type` string should match the module's registration name.

3. **Extra State:** Modules that use extra state (Sample Loader, Comment, VST Host) are documented in the dictionary's "Special Cases" section

4. **Connection Types:** The dictionary shows what data types connect where, which helps understand why certain connections work or fail during load

#### Example Entry: Sample Loader

From the dictionary:
```
### Sample Loader
**Audio Sample Player**

**Inputs:**
- `Pitch Mod` (CV) - Pitch modulation in semitones
- `Speed Mod` (CV) - Playback speed modulation
...
**Parameters:**
- `File` (Button) - Load audio file
- `Pitch` (-48 to +48 semitones) - Pitch shift amount
...
```

What gets saved in XML:
```xml
<module logicalId="4" type="Sample_Loader">
  <params>
    <SampleLoaderParams>
      <PARAM id="pitch" value="0.0"/>
      <PARAM id="speed" value="1.0"/>
      <!-- etc -->
    </SampleLoaderParams>
  </params>
  <extra>
    <SampleLoaderState audioFilePath="H:\audio\samples\kick.wav" 
                      loopMode="0" loopStart="0" loopEnd="44100"/>
  </extra>
</module>
```

The dictionary explains:
- What the `pitch` parameter does (pitch shift in semitones)
- That `audioFilePath` is stored in extra state (not in params)
- The expected file formats (WAV, AIFF, FLAC, MP3)

#### For External Developers

When improving the save/load system, refer to the Nodes Dictionary to:

1. **Verify Parameter Names:** Ensure parameter IDs in code match what's documented
2. **Understand Module Behavior:** Know what each module does to correctly restore state
3. **Identify Special Cases:** Find modules with unusual save/load requirements (dynamic pins, extra state, etc.)
4. **Validate Test Cases:** Use dictionary examples to create test presets

#### Maintaining Consistency

**Critical:** Keep the dictionary synchronized with code:

- ‚úÖ When adding a new parameter to a module, update the dictionary
- ‚úÖ When changing a module's type string, update both pin database AND dictionary
- ‚úÖ When adding a new module type, add it to pin database, dictionary, AND module factory
- ‚úÖ Document all extra state properties that get saved

#### Example: Finding Module Information

To understand what gets saved for the "Function Generator" module:

1. **Look up in Dictionary:** Find "Function Generator" entry
2. **Read Parameters Section:** Lists all APVTS parameters (Rate, Slew, Gate Threshold, etc.)
3. **Check Extra State:** Dictionary notes if module uses extra state (Function Generator does NOT use extra state)
4. **Understand Pin Configuration:** Dictionary shows inputs/outputs, but for exact channel indices, check PinDatabase.cpp
5. **Verify Save Format:** Dictionary + PinDatabase + code = complete picture of what XML should contain

---

### Interdependence of Systems

These three systems work together:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  XML Preset File                                    ‚îÇ
‚îÇ  - Module types (from Pin Database)                ‚îÇ
‚îÇ  - Parameter IDs (from Module code)                ‚îÇ
‚îÇ  - Connection channels (from Pin Database)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚îÇ Load/Save
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Pin Database (PinDatabase.cpp)                   ‚îÇ
‚îÇ  - Validates module types                          ‚îÇ
‚îÇ  - Provides pin configuration for UI               ‚îÇ
‚îÇ  - Maps display names to channel indices           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚îÇ Reference
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Nodes Dictionary (Nodes_Dictionary.md)           ‚îÇ
‚îÇ  - Documents module behavior                       ‚îÇ
‚îÇ  - Lists all parameters                            ‚îÇ
‚îÇ  - Explains usage                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Takeaway:** When improving save/load:
- **XML structure** defines what's stored
- **Pin Database** validates and enables UI reconstruction
- **Nodes Dictionary** provides human-readable reference and documentation

---

## The Save Process

### High-Level Flow

```
User clicks Save ‚Üí File chooser ‚Üí Unmute nodes ‚Üí Get synth state ‚Üí 
Re-mute nodes ‚Üí Append UI state ‚Üí Write XML file
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doSave()`)

```cpp
void PresetCreatorComponent::doSave()
{
    // Find default save location (project-root/Synth_presets)
    juce::File startDir;
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    // Search up to 8 parent directories for Synth_presets folder
    auto dir = exeDir;
    for (int i = 0; i < 8 && dir.exists(); ++i)
    {
        auto candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.exists() && candidate.isDirectory()) 
        { 
            startDir = candidate; 
            break; 
        }
        dir = dir.getParentDirectory();
    }
    
    // Launch async file chooser
    saveChooser = std::make_unique<juce::FileChooser>("Save preset", startDir, "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        // Callback continues in Step 2...
    });
}
```

#### Step 2: Unmute Nodes (Critical Fix)

**Problem:** Muted nodes have their connections replaced with bypass routing in the audio graph. If we save while nodes are muted, we'll save the bypass routing instead of the original connections.

**Solution:** Temporarily unmute all nodes before getting state, then immediately re-mute them.

```cpp
// 1. Get list of currently muted nodes
std::vector<juce::uint32> currentlyMutedNodes;
if (editor)
{
    for (const auto& pair : editor->mutedNodeStates)
    {
        currentlyMutedNodes.push_back(pair.first);
    }
    
    // 2. Temporarily UNMUTE all of them
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->unmuteNode(lid);
    }
}

// 3. Force synth to apply connection changes immediately
if (synth)
{
    synth->commitChanges();
}
```

#### Step 3: Get Synth State (`ModularSynthProcessor::getStateInformation()`)

This is where the core serialization happens.

```cpp
void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock(moduleLock);
    
    // Create root ValueTree
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    // === SERIALIZE MODULES ===
    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32)kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int)logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                // Special handling for VST modules
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    // Standard module: save APVTS parameters
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    // Save extra state (file paths, custom data)
                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    // === SERIALIZE CONNECTIONS ===
    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32)c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32)c.destination.nodeID.uid;
        
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            // Module-to-module connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int)dstIt->second, nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            // Module-to-output connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else
        {
            continue; // Skip internal graph connections
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    // === CONVERT TO XML ===
    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}
```

**Key Concepts:**

- **Logical IDs:** Each module gets a stable logical ID (1, 2, 3...) that persists across sessions
- **Node UIDs:** JUCE's internal graph node IDs (unstable, change on reload)
- **Parameter Storage:** Uses JUCE's APVTS `.copyState()` to serialize all parameters
- **Extra State:** Custom data (file paths, text, etc.) stored separately via `getExtraStateTree()`

#### Step 4: Re-mute Nodes and Add UI State

```cpp
// 5. IMMEDIATELY RE-MUTE the nodes to return editor to visible state
if (editor)
{
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->muteNode(lid);
    }
}

// 6. Force synth to apply the re-mute changes
if (synth)
{
    synth->commitChanges();
}

// === ADD UI STATE ===
juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);
if (editor)
{
    juce::ValueTree ui = editor->getUiValueTree();
    presetVT.addChild(ui, -1, nullptr);
}

// Write to file
f.replaceWithText(presetVT.createXml()->toString());
```

The UI state includes:
- Node X/Y positions
- Node colors
- Mute states
- Node widths/heights (for custom-sized modules)

---

## The Load Process

### High-Level Flow

```
User clicks Load ‚Üí File chooser ‚Üí Parse XML ‚Üí Clear existing state ‚Üí 
Recreate modules ‚Üí Restore parameters ‚Üí Recreate connections ‚Üí Apply UI state
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doLoad()`)

```cpp
void PresetCreatorComponent::doLoad()
{
    // Find default location
    juce::File startDir;
    // (same directory search logic as save)
    
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", startDir, "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData(mb);
                
                // First: set the synth state
                synth->setStateInformation(mb.getData(), (int)mb.getSize());
                
                // Then: parse and apply UI state
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse(mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml(*xml);
                        auto ui = vt.getChildWithName("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow(ui);
                    }
                }
                
                refreshModulesList();
                log.insertTextAtCaret("Loaded: " + f.getFullPathName() + "\n");
            }
        } catch (...) {
            juce::Logger::writeToLog("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}
```

#### Step 2: Set State (`ModularSynthProcessor::setStateInformation()`)

This is the most complex part of the system.

```cpp
void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    
    // Parse XML
    std::unique_ptr<juce::XmlElement> xml(
        juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes))
    );
    
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML");
        return;
    }

    // === CLEAR EXISTING STATE ===
    clearAll();
    
    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // === RESTORE GLOBAL SETTINGS ===
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found");
        return;
    }
    
    // === FIND HIGHEST LOGICAL ID ===
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    // === RECREATE MODULES ===
    std::map<juce::uint32, NodeID> logicalToNodeId;
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module")) continue;

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module: logicalId=" + juce::String(logicalId) + 
                                " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            // Check if this is a VST module
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr)
                    {
                        // Find VST in known plugins list
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE] Loading VST: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                break;
                            }
                        }
                    }
                }
            }
            
            if (!isVstModule)
            {
                // Standard module
                nodeId = addModule(type, false);
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                if (!isVstModule)
                {
                    // Update logical ID mapping
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;

                // === RESTORE STATE (ORDER MATTERS!) ===
                
                // FIRST: Restore extra state
                // This loads files, initializes custom data structures, etc.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE] Restored extra state.");
                    }
                }

                // SECOND: Restore parameters
                // This overwrites any defaults set by extra state loading
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE] Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE] ERROR: Node creation failed!");
            }
        }
    }
    
    // === RESTORE CONNECTIONS ===
    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connected " + juce::String(connectedCount) + " connections.");
    }

    // === FINALIZE ===
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}
```

**Critical Points:**

1. **Order of restoration:** Extra state BEFORE parameters (file loading sets defaults, then parameters overwrite them)
2. **Logical ID assignment:** Must match saved logical IDs for connections to work
3. **VST handling:** Separate code path for loading VST plugins vs. built-in modules
4. **Connection restoration:** Uses logical ID mapping to reconnect modules

#### Step 3: Apply UI State (`ImGuiNodeEditorComponent::applyUiValueTreeNow()`)

```cpp
void ImGuiNodeEditorComponent::applyUiValueTreeNow(const juce::ValueTree& uiTree)
{
    if (!uiTree.isValid()) return;
    
    // Clear existing UI state
    nodePositions.clear();
    nodeColors.clear();
    mutedNodeStates.clear();
    
    // Restore node positions and properties
    for (int i = 0; i < uiTree.getNumChildren(); ++i)
    {
        auto child = uiTree.getChild(i);
        if (child.hasType("node"))
        {
            int logicalId = child.getProperty("id", 0);
            float x = child.getProperty("x", 0.0f);
            float y = child.getProperty("y", 0.0f);
            
            nodePositions[logicalId] = ImVec2(x, y);
            
            // Restore color if saved
            if (child.hasProperty("color"))
            {
                juce::uint32 colorInt = child.getProperty("color", 0);
                nodeColors[logicalId] = ImColor(colorInt);
            }
            
            // Restore mute state
            if (child.getProperty("muted", false))
            {
                mutedNodeStates[logicalId] = true;
                // Apply mute routing
                muteNode(logicalId);
            }
            
            // Restore width override
            if (child.hasProperty("width"))
            {
                float width = child.getProperty("width", 0.0f);
                nodeWidthOverrides[logicalId] = width;
            }
        }
    }
    
    graphNeedsRebuild = true;
}
```

---

## XML File Structure

### Complete Example

```xml
<?xml version="1.0" encoding="UTF-8"?>

<ModularSynthPreset version="1">
  <modules>
    <module logicalId="3" type="VCO">
      <params>
        <VCOParams>
          <PARAM id="frequency" value="440.0"/>
          <PARAM id="waveform" value="0.0"/>
        </VCOParams>
      </params>
    </module>
    
    <module logicalId="4" type="Sample_Loader">
      <params>
        <SampleLoaderParams>
          <PARAM id="trimStart" value="0.0"/>
          <PARAM id="trimEnd" value="1.0"/>
          <PARAM id="cvMax" value="1.0"/>
          <PARAM id="cvMin" value="0.0"/>
        </SampleLoaderParams>
      </params>
      <extra>
        <SampleLoaderState audioFilePath="H:\audio\samples\kick.wav" 
                          loopMode="0" loopStart="0" loopEnd="44100"/>
      </extra>
    </module>
    
    <module logicalId="5" type="Pro-Q 3">
      <extra>
        <VstHostState fileOrIdentifier="C:\VST\FabFilter Pro-Q 3.vst3"
                      name="Pro-Q 3" 
                      manufacturerName="FabFilter" 
                      version="3.2.1.0"
                      pluginFormatName="VST3" 
                      pluginState="(base64 encoded state data)"/>
      </extra>
    </module>
  </modules>
  
  <connections>
    <connection srcId="3" srcChan="0" dstId="4" dstChan="0"/>
    <connection srcId="4" srcChan="0" dstId="5" dstChan="0"/>
    <connection srcId="5" srcChan="0" dstId="output" dstChan="0"/>
  </connections>
  
  <NodeEditorUI>
    <node id="3" x="100.0" y="200.0" color="4294901760" width="200.0"/>
    <node id="4" x="400.0" y="200.0" muted="true"/>
    <node id="5" x="700.0" y="200.0"/>
    <node id="0" x="1000.0" y="200.0"/>
  </NodeEditorUI>
</ModularSynthPreset>
```

### Structure Breakdown

#### Root Element
```xml
<ModularSynthPreset version="1">
```
- `version`: Schema version (for future compatibility)

#### Modules Section
```xml
<modules>
  <module logicalId="X" type="ModuleType">
    <params>
      <ModuleTypeParams>
        <PARAM id="paramId" value="0.5"/>
      </ModuleTypeParams>
    </params>
    <extra>
      <!-- Module-specific state -->
    </extra>
  </module>
</modules>
```

- `logicalId`: Stable identifier for this module instance
- `type`: Module type string (must match factory registration)
- `params`: APVTS-generated parameter state
- `extra`: Custom state (file paths, text, etc.)

#### Connections Section
```xml
<connections>
  <connection srcId="1" srcChan="0" dstId="2" dstChan="1"/>
  <connection srcId="2" srcChan="0" dstId="output" dstChan="0"/>
</connections>
```

- `srcId`: Source module logical ID
- `srcChan`: Source output channel (0-indexed)
- `dstId`: Destination module logical ID (or "output")
- `dstChan`: Destination input channel (0-indexed)

#### UI Section
```xml
<NodeEditorUI>
  <node id="X" x="123.45" y="678.90" color="4294901760" muted="true" width="250.0"/>
</NodeEditorUI>
```

- `id`: Module logical ID (or 0 for output node)
- `x`, `y`: Node position in canvas space
- `color`: ARGB color as 32-bit integer (optional)
- `muted`: Boolean mute state (optional)
- `width`: Custom width override (optional)

---

## Module Parameter Serialization

### How APVTS Works

**AudioProcessorValueTreeState (APVTS)** is JUCE's parameter management system. Each module creates an APVTS in its constructor:

```cpp
class VCOModuleProcessor : public ModuleProcessor
{
public:
    VCOModuleProcessor()
        : ModuleProcessor(/* bus layout */),
          apvts(*this, nullptr, "VCOParams", createParameterLayout())
    {
    }
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
    {
        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        
        layout.add(std::make_unique<juce::AudioParameterFloat>(
            "frequency",                    // Parameter ID
            "Frequency",                    // Display name
            juce::NormalisableRange<float>(20.0f, 20000.0f, 0.01f, 0.3f),
            440.0f));                       // Default value
        
        layout.add(std::make_unique<juce::AudioParameterChoice>(
            "waveform",
            "Waveform",
            juce::StringArray{"Sine", "Square", "Saw", "Triangle"},
            0));
        
        return layout;
    }
};
```

### Serialization

When we call `apvts.copyState()`, JUCE creates a ValueTree:

```xml
<VCOParams>
  <PARAM id="frequency" value="440.0"/>
  <PARAM id="waveform" value="0.0"/>
</VCOParams>
```

### Deserialization

When we call `apvts.replaceState(params)`, JUCE:
1. Finds each parameter by ID
2. Converts the string value to the parameter's native type
3. Sets the parameter value
4. Triggers any attached listeners

---

## Connection Management

### Connection Storage

Connections are stored in `juce::AudioProcessorGraph` as:

```cpp
struct Connection
{
    struct EndPoint
    {
        NodeID nodeID;
        int channelIndex;
    } source, destination;
};
```

### Channel Types

- **Audio channels:** 0, 1, 2, ... (stereo = channels 0 and 1)
- **MIDI channel:** `juce::AudioProcessorGraph::midiChannelIndex` (special constant)

### Connection Creation

```cpp
bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel,
                                    const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection{
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    // Check for duplicate
    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            return true; // Already connected
        }
    }

    // Add connection (deferred until commitChanges())
    return internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}
```

### Why Logical IDs?

**Problem:** JUCE's `NodeID::uid` values are unstable - they change every time you load a preset.

**Solution:** We maintain a separate `logicalId` system:

```cpp
// Mapping stored in ModularSynthProcessor
std::map<juce::uint32, LogicalModule> logicalIdToModule;

struct LogicalModule
{
    juce::AudioProcessorGraph::NodeID nodeID;  // Changes on reload
    juce::String type;
};
```

When saving:
```cpp
// Convert NodeID ‚Üí Logical ID
nodeUidToLogical[nodeID.uid] = logicalId;
```

When loading:
```cpp
// Convert Logical ID ‚Üí NodeID (new UID)
logicalToNodeId[logicalId] = newNodeId;
```

---

## UI State Persistence

### What UI State Includes

- **Node positions** (X, Y coordinates)
- **Node colors** (custom color per node)
- **Mute states** (which nodes are bypassed)
- **Width overrides** (custom widths for nodes)
- **Canvas pan/zoom** (viewport state)

### Generation (`ImGuiNodeEditorComponent::getUiValueTree()`)

```cpp
juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui("NodeEditorUI");
    
    // Save all module nodes
    for (const auto& pair : nodePositions)
    {
        int logicalId = pair.first;
        ImVec2 pos = pair.second;
        
        juce::ValueTree nodeVT("node");
        nodeVT.setProperty("id", logicalId, nullptr);
        nodeVT.setProperty("x", pos.x, nullptr);
        nodeVT.setProperty("y", pos.y, nullptr);
        
        // Optional: color
        if (nodeColors.count(logicalId))
        {
            ImU32 colorInt = nodeColors.at(logicalId);
            nodeVT.setProperty("color", (int)colorInt, nullptr);
        }
        
        // Optional: mute state
        if (mutedNodeStates.count(logicalId) && mutedNodeStates.at(logicalId))
        {
            nodeVT.setProperty("muted", true, nullptr);
        }
        
        // Optional: width override
        if (nodeWidthOverrides.count(logicalId))
        {
            nodeVT.setProperty("width", nodeWidthOverrides.at(logicalId), nullptr);
        }
        
        ui.addChild(nodeVT, -1, nullptr);
    }
    
    // Always save output node position
    if (outputNodePosition.x != 0.0f || outputNodePosition.y != 0.0f)
    {
        juce::ValueTree outputVT("node");
        outputVT.setProperty("id", 0, nullptr); // Output node is always ID 0
        outputVT.setProperty("x", outputNodePosition.x, nullptr);
        outputVT.setProperty("y", outputNodePosition.y, nullptr);
        ui.addChild(outputVT, -1, nullptr);
    }
    
    return ui;
}
```

### Restoration (shown earlier in Load Process)

---

## Special Cases

### 1. VST Plugins

VST plugins have opaque internal state that we can't inspect. JUCE provides:

```cpp
// Get plugin state
juce::MemoryBlock stateData;
plugin->getStateInformation(stateData);

// Restore plugin state
plugin->setStateInformation(stateData.getData(), stateData.getSize());
```

We wrap this in `VstHostModuleProcessor` and store:
- Plugin identifier (file path)
- Plugin metadata (name, manufacturer, version)
- Plugin state (base64 encoded in XML)

### 2. Sample Loader

The Sample Loader module needs to store:
- File path (absolute path to audio file)
- Trim points (start/end in samples)
- Loop settings

This uses "extra state":

```cpp
juce::ValueTree SampleLoaderModuleProcessor::getExtraStateTree()
{
    juce::ValueTree state("SampleLoaderState");
    state.setProperty("audioFilePath", currentFilePath, nullptr);
    state.setProperty("loopMode", (int)loopMode, nullptr);
    state.setProperty("loopStart", loopStart, nullptr);
    state.setProperty("loopEnd", loopEnd, nullptr);
    return state;
}

void SampleLoaderModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    if (!state.hasType("SampleLoaderState")) return;
    
    currentFilePath = state.getProperty("audioFilePath", "").toString();
    loopMode = (LoopMode)(int)state.getProperty("loopMode", 0);
    loopStart = state.getProperty("loopStart", 0);
    loopEnd = state.getProperty("loopEnd", 0);
    
    // Load the audio file
    if (currentFilePath.isNotEmpty())
    {
        loadAudioFile(juce::File(currentFilePath));
    }
}
```

### 3. Comment Module

Comments store text and dimensions:

```cpp
<extra>
  <CommentState title="My Note" 
                text="This is important!" 
                width="250.0" 
                height="150.0"/>
</extra>
```

### 4. Mute States

Muting is complex because it modifies the audio graph:

**When a node is muted:**
1. Store original connections
2. Remove all connections to/from node
3. Create bypass connections (input ‚Üí output directly)

**When saving with muted nodes:**
1. Temporarily unmute all nodes (restore original connections)
2. Save the unmuted connections
3. Immediately re-mute nodes

**When loading with muted nodes:**
1. Load normal connections
2. Apply mute states from UI tree
3. This triggers the mute logic, which replaces connections with bypasses

---

## Code Examples

### Example 1: Creating a Simple Module with APVTS

```cpp
// SimpleGainModule.h
#pragma once
#include "ModuleProcessor.h"

class SimpleGainModuleProcessor : public ModuleProcessor
{
public:
    SimpleGainModuleProcessor();
    ~SimpleGainModuleProcessor() override = default;
    
    const juce::String getName() const override { return "Simple Gain"; }
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override;
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SimpleGainModuleProcessor)
};

// SimpleGainModule.cpp
#include "SimpleGainModuleProcessor.h"

SimpleGainModuleProcessor::SimpleGainModuleProcessor()
    : ModuleProcessor(BusesProperties()
                       .withInput("Input", juce::AudioChannelSet::stereo())
                       .withOutput("Output", juce::AudioChannelSet::stereo())),
      apvts(*this, nullptr, "SimpleGainParams", createParameterLayout())
{
}

juce::AudioProcessorValueTreeState::ParameterLayout SimpleGainModuleProcessor::createParameterLayout()
{
    juce::AudioProcessorValueTreeState::ParameterLayout layout;
    
    layout.add(std::make_unique<juce::AudioParameterFloat>(
        "gain",                                           // Parameter ID
        "Gain",                                          // Display name
        juce::NormalisableRange<float>(0.0f, 2.0f),     // Range
        1.0f));                                          // Default value
    
    return layout;
}

void SimpleGainModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Read parameter value
    float gain = apvts.getRawParameterValue("gain")->load();
    
    // Apply gain
    buffer.applyGain(gain);
    
    // Update telemetry for visualization
    updateOutputTelemetry(buffer);
}
```

**What gets saved automatically:**
```xml
<module logicalId="X" type="Simple Gain">
  <params>
    <SimpleGainParams>
      <PARAM id="gain" value="1.5"/>
    </SimpleGainParams>
  </params>
</module>
```

### Example 2: Adding Extra State (File Path)

```cpp
class MyFileModuleProcessor : public ModuleProcessor
{
public:
    // ... (constructor, APVTS, etc.)
    
    // Override these two methods
    juce::ValueTree getExtraStateTree() override
    {
        juce::ValueTree state("MyFileModuleState");
        state.setProperty("filePath", currentFilePath, nullptr);
        state.setProperty("customData", someOtherData, nullptr);
        return state;
    }
    
    void setExtraStateTree(const juce::ValueTree& state) override
    {
        if (!state.hasType("MyFileModuleState")) return;
        
        currentFilePath = state.getProperty("filePath", "").toString();
        someOtherData = state.getProperty("customData", 0);
        
        // Do something with the loaded data
        if (currentFilePath.isNotEmpty())
        {
            loadFile(juce::File(currentFilePath));
        }
    }
    
private:
    juce::String currentFilePath;
    int someOtherData = 0;
};
```

**What gets saved:**
```xml
<module logicalId="X" type="MyFileModule">
  <params>
    <!-- APVTS parameters -->
  </params>
  <extra>
    <MyFileModuleState filePath="C:\audio\file.wav" customData="42"/>
  </extra>
</module>
```

### Example 3: Programmatic Save/Load

```cpp
// Save preset programmatically
void savePresetToFile(ModularSynthProcessor* synth, const juce::File& file)
{
    juce::MemoryBlock mb;
    synth->getStateInformation(mb);
    
    auto xml = juce::XmlDocument::parse(mb.toString());
    if (xml)
    {
        file.replaceWithText(xml->toString());
    }
}

// Load preset programmatically
void loadPresetFromFile(ModularSynthProcessor* synth, const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);
    
    synth->setStateInformation(mb.getData(), (int)mb.getSize());
}
```

---

## Summary

The XML preset system in this modular synthesizer is built on these key principles:

1. **Logical IDs** provide stable module references across save/load cycles
2. **JUCE's APVTS** handles automatic parameter serialization
3. **Extra state trees** allow modules to store custom data (files, text, etc.)
4. **Connection serialization** uses logical IDs instead of unstable node IDs
5. **UI state separation** keeps visual data separate from audio graph data
6. **Mute state handling** requires careful connection management during save
7. **VST support** wraps opaque plugin state in a standardized format

The complete flow is:
```
Save: UI ‚Üí Get State ‚Üí Serialize ‚Üí Write XML
Load: Read XML ‚Üí Parse ‚Üí Recreate Graph ‚Üí Apply UI
```

This architecture provides:
- ‚úÖ **Stability:** Presets work across app restarts
- ‚úÖ **Extensibility:** Easy to add new module types
- ‚úÖ **Debugging:** Human-readable XML format
- ‚úÖ **Performance:** Deferred graph updates via `commitChanges()`
- ‚úÖ **Completeness:** Captures all module state, connections, and UI layout

---

## Key Files Reference

| File | Purpose |
|------|---------|
| `ModularSynthProcessor.cpp` | Core save/load implementation |
| `ModularSynthProcessor.h` | Logical ID management |
| `ModuleProcessor.h` | Base class for all modules |
| `PresetCreatorComponent.cpp` | UI save/load dialogs |
| `ImGuiNodeEditorComponent.cpp` | UI state management |
| `PinDatabase.cpp` | Module pin configuration registry (see [Supporting Systems](#supporting-systems)) |
| `Nodes_Dictionary.md` | Module documentation and parameter reference (see [Supporting Systems](#supporting-systems)) |
| `VCOModuleProcessor.cpp` | Example APVTS usage |
| `SampleLoaderModuleProcessor.cpp` | Example extra state usage |
| `VstHostModuleProcessor.cpp` | VST plugin state handling |

---

## Improvement Opportunities

This section identifies known issues in the current save/load system and provides guidance for external developers on how to implement improvements.

### Issue 1: Blocking Save Operation

#### Problem Description

When saving presets, the operation blocks the UI thread for several seconds, causing noticeable stuttering and freezing. Users cannot interact with the application during save.

#### Root Cause Analysis

The blocking occurs in `PresetCreatorComponent::doSave()` callback:

```cpp
// Current synchronous save flow (BLOCKING)
void PresetCreatorComponent::doSave()
{
    saveChooser->launchAsync(..., [this](const juce::FileChooser& fc)
    {
        // === ALL THESE OPERATIONS RUN ON UI THREAD ===
        
        // 1. Unmute nodes (synchronous)
        for (juce::uint32 lid : currentlyMutedNodes)
            editor->unmuteNode(lid);
        synth->commitChanges();  // Blocks waiting for audio thread
        
        // 2. Get state (synchronous, locks moduleLock)
        juce::MemoryBlock mb;
        synth->getStateInformation(mb);  // Iterates all modules, locks
        
        // 3. Re-mute nodes (synchronous)
        for (juce::uint32 lid : currentlyMutedNodes)
            editor->muteNode(lid);
        synth->commitChanges();  // Blocks again
        
        // 4. Parse XML and add UI state (synchronous)
        auto xml = juce::XmlDocument::parse(mb.toString());
        auto vt = juce::ValueTree::fromXml(*xml);
        // ... add UI state ...
        
        // 5. Write to disk (synchronous I/O)
        f.replaceWithText(vt.createXml()->toString());  // BLOCKS on disk I/O
    });
}
```

**Performance Bottlenecks:**
- `commitChanges()` blocks waiting for audio thread synchronization
- `getStateInformation()` locks `moduleLock` and iterates all modules synchronously
- XML parsing happens synchronously on UI thread
- File I/O is synchronous and blocking

#### Solution Strategy: Asynchronous Saving with UI Feedback

The complete solution is to offload the entire save operation to a background thread pool, while providing non-blocking visual feedback to the user.

**Step 1: Create a Background Save Task**

We'll define a `ThreadPoolJob` that runs the entire save process isolated from the UI thread. Critical: UI modifications (like unmute/mute) must be done on the message thread using `juce::WaitableEvent` for proper thread synchronization.

**Important:** The `SavePresetJob` class should be in its own files (`SavePresetJob.h` and `SavePresetJob.cpp`) to avoid circular dependencies and compilation issues.

```cpp
// Create new file: juce/Source/preset_creator/SavePresetJob.h

class SavePresetJob : public juce::ThreadPoolJob
{
public:
    SavePresetJob(ModularSynthProcessor& synth, ImGuiNodeEditorComponent& editor, 
                  juce::File targetFile)
        : ThreadPoolJob("Save Preset"), 
          synthProcessor(synth), 
          nodeEditor(editor), 
          fileToSave(targetFile)
    {}

    JobStatus runJob() override
    {
        // This entire function runs on a background thread
        
        // 1. Get a list of muted nodes from the editor
        // Note: getMutedNodeIds() is const and thread-safe (only reads from map)
        auto mutedNodeIDs = nodeEditor.getMutedNodeIds();

        // 2. Temporarily unmute nodes (must be done on message thread)
        // Use WaitableEvent to safely synchronize with the UI thread
        {
            juce::WaitableEvent waitEvent;
            juce::MessageManager::callAsync([&]() {
                for (auto lid : mutedNodeIDs) nodeEditor.unmuteNode(lid);
                waitEvent.signal(); // Signal the background thread to continue
            });
            waitEvent.wait(); // Wait here until the message thread is done
        }
        synthProcessor.commitChanges(); // This blocks, but on our background thread

        // 3. Get the full synth and UI state
        juce::MemoryBlock synthState;
        synthProcessor.getStateInformation(synthState);
        
        // Get UI state on message thread to ensure thread safety
        juce::ValueTree uiState;
        {
            juce::WaitableEvent waitEvent;
            juce::MessageManager::callAsync([&]() {
                uiState = nodeEditor.getUiValueTree();
                waitEvent.signal();
            });
            waitEvent.wait();
        }

        // 4. Immediately re-mute the nodes to restore the UI state
        {
            juce::WaitableEvent waitEvent;
            juce::MessageManager::callAsync([&]() {
                for (auto lid : mutedNodeIDs) nodeEditor.muteNode(lid);
                waitEvent.signal(); // Signal the background thread to continue
            });
            waitEvent.wait(); // Wait here until the message thread is done
        }
        synthProcessor.commitChanges();

        // 5. Combine states and write to disk (all on background thread)
        std::unique_ptr<juce::XmlElement> xml = juce::XmlDocument::parse(synthState.toString());
        if (xml && xml->hasTagName("ModularSynthPreset"))
        {
            auto presetVT = juce::ValueTree::fromXml(*xml);
            if (uiState.isValid())
                presetVT.addChild(uiState, -1, nullptr);
            
            fileToSave.replaceWithText(presetVT.createXml()->toString());
            wasSuccessful = true;
        }

        // 6. Signal completion to the UI thread
        juce::MessageManager::callAsync([this]() {
            // This lambda runs back on the UI thread
            if (onSaveComplete)
                onSaveComplete(fileToSave, wasSuccessful);
        });
        
        return jobHasFinished;
    }

    std::function<void(const juce::File&, bool success)> onSaveComplete;

private:
    ModularSynthProcessor& synthProcessor;
    ImGuiNodeEditorComponent& nodeEditor;
    juce::File fileToSave;
    bool wasSuccessful = false;
};
```

**Step 2: Implement Non-Blocking Notification UI**

Create a simple, non-intrusive notification component that appears in a corner of the screen:

```cpp
// In PresetCreatorComponent.h
std::unique_ptr<juce::Label> saveStatusLabel;
juce::ThreadPool threadPool { 2 }; // Thread pool for background jobs
```

```cpp
// In PresetCreatorComponent.cpp

void PresetCreatorComponent::showSaveNotification(const juce::String& message, juce::Colour color)
{
    if (!saveStatusLabel) 
    {
        saveStatusLabel = std::make_unique<juce::Label>();
        saveStatusLabel->setJustificationType(juce::Justification::centred);
        saveStatusLabel->setColour(juce::Label::textColourId, juce::Colours::white);
        addAndMakeVisible(*saveStatusLabel);
    }
    
    saveStatusLabel->setText(message, juce::dontSendNotification);
    saveStatusLabel->setColour(juce::Label::backgroundColourId, color);
    
    // Position in top-right corner
    saveStatusLabel->setBounds(getWidth() - 310, 30, 300, 40);
    saveStatusLabel->setVisible(true);
    saveStatusLabel->toFront(false); // Bring to front but don't grab focus

    // Auto-hide after 4 seconds
    juce::Timer::callAfterDelay(4000, [this]() { 
        if (saveStatusLabel) 
            saveStatusLabel->setVisible(false); 
    });
}

// Replace the existing doSave() logic with this:
void PresetCreatorComponent::doSave()
{
    // Find default save location (existing code)
    juce::File startDir;
    // ... (existing directory search logic) ...
    
    saveChooser = std::make_unique<juce::FileChooser>("Save preset", startDir, "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
        {
            auto file = fc.getResult();
            if (file == juce::File{}) return;

            // Show initial notification
            showSaveNotification("Saving preset: " + file.getFileName(), 
                               juce::Colours::darkgrey);
            
            // Launch background save job
            auto* job = new SavePresetJob(*synth, *editor, file);
            job->onSaveComplete = [this](const juce::File& savedFile, bool success) {
                if (success) 
                {
                    showSaveNotification("Saved: " + savedFile.getFileName(), 
                                       juce::Colours::darkgreen);
                    // Update UI state if needed
                    // isPatchDirty = false;
                    // currentPresetFile = savedFile.getFileName();
                } 
                else 
                {
                    showSaveNotification("Error saving preset!", 
                                       juce::Colours::darkred);
                }
            };
            
            threadPool.addJob(job, true); // true = delete job when done
        });
}
```

**Key Benefits:**

- **Zero UI Blocking:** All heavy operations run on background thread
- **Thread-Safe UI Access:** Uses `juce::WaitableEvent` with `MessageManager::callAsync` for UI modifications
- **User Feedback:** Non-blocking notifications inform user of progress
- **Error Handling:** Completion callback handles both success and failure cases
- **Automatic Cleanup:** ThreadPool automatically deletes job when finished

#### Step 3: Implement Professional Save Workflow

For an improved user experience, implement two separate save commands:

- **`Ctrl+S` (Save)**: If the patch is already saved, saves instantly in the background to the same file without a dialog. If the patch is new/unsaved, automatically triggers "Save As" dialog.
- **`Ctrl+Alt+S` (Save As)**: Always opens the file dialog to save to a new location.

**Architecture Note:** The `SavePresetJob` class is now in its own files (`SavePresetJob.h` and `SavePresetJob.cpp`) to avoid circular dependencies and compilation issues. This is the correct C++ practice.

**Implementation:**

```cpp
// In ImGuiNodeEditorComponent.h

// Add member variables:
juce::File currentPresetFile;  // Track the current save file (changed from String to File)
bool isPatchDirty = false;      // Track if patch has unsaved changes
juce::ThreadPool threadPool { 2 }; // Thread pool for background jobs
std::unique_ptr<juce::Label> saveStatusLabel; // Non-blocking notification

// Add member functions:
void savePresetToFile(const juce::File& file);  // Core async save function
void startSaveDialog();                          // Save As dialog
std::vector<juce::uint32> getMutedNodeIds() const; // Thread-safe getter
void showSaveNotification(const juce::String& message, juce::Colour color); // Notification UI
```

```cpp
// In ImGuiNodeEditorComponent.cpp

// 1. Update keyboard shortcut handler
void ImGuiNodeEditorComponent::handleKeyboardShortcuts()
{
    if (!ImGui::GetIO().WantCaptureKeyboard)
    {
        const bool ctrl = ImGui::GetIO().KeyCtrl;
        const bool alt = ImGui::GetIO().KeyAlt;

        // Save As (Ctrl+Alt+S) - Always opens dialog
        if (ctrl && alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
        {
            startSaveDialog();
        }
        // Save (Ctrl+S) - Quick save if file exists, otherwise Save As
        else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
        {
            if (currentPresetFile.existsAsFile())
            {
                // File already exists, so save directly without a dialog
                savePresetToFile(currentPresetFile);
            }
            else
            {
                // This is a new, unsaved patch, so "Save" should act like "Save As"
                startSaveDialog();
            }
        }
        
        // ... (rest of keyboard shortcuts like Ctrl+O, Ctrl+P, etc.)
    }
}

// 2. Core asynchronous save function
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    if (synth == nullptr) 
    {
        showSaveNotification("ERROR: Synth not ready!", juce::Colours::darkred);
        return;
    }

    // Show a non-blocking "Saving..." message
    showSaveNotification("Saving: " + file.getFileNameWithoutExtension(), 
                        juce::Colours::darkgrey);

    // Create and launch the background save job
    auto* job = new SavePresetJob(*synth, *this, file);

    job->onSaveComplete = [this](const juce::File& savedFile, bool success) {
        // This lambda will be called on the UI thread when the job is done
        if (success) 
        {
            showSaveNotification("Saved: " + savedFile.getFileNameWithoutExtension(), 
                               juce::Colours::darkgreen);
            isPatchDirty = false;
            currentPresetFile = savedFile; // Update the current file reference
        } 
        else 
        {
            showSaveNotification("Error: Failed to save preset!", 
                               juce::Colours::darkred);
        }
    };

    threadPool.addJob(job, true); // true = delete job when done
}

// 3. Save As dialog (simplified, always opens dialog)
void ImGuiNodeEditorComponent::startSaveDialog()
{
    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      findPresetsDirectory(), 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto fileToSave = fc.getResult();
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
    });
}
```

**Benefits of This Workflow:**

- ‚úÖ **Fast Quick Save:** `Ctrl+S` saves instantly if file exists (no dialog delay)
- ‚úÖ **Intuitive:** New patches automatically prompt for filename
- ‚úÖ **Flexible:** `Ctrl+Alt+S` always allows choosing new location
- ‚úÖ **Non-Blocking:** Both commands use background thread
- ‚úÖ **User Feedback:** Clear notifications for all save operations

**Note on Thread Safety:**

The `getMutedNodeIds()` method referenced above needs to be added to `ImGuiNodeEditorComponent`:

```cpp
// In ImGuiNodeEditorComponent.h
std::vector<juce::uint32> getMutedNodeIds() const
{
    const juce::ScopedLock lock(muteStateLock); // Use existing lock if available
    std::vector<juce::uint32> ids;
    for (const auto& pair : mutedNodeStates)
    {
        if (pair.second) // If node is muted
            ids.push_back(pair.first);
    }
    return ids;
}
```

#### Implementation Checklist

- [ ] Create `SaveTask` class extending `ThreadPoolJob`
- [ ] Move all heavy operations to background thread
- [ ] Add progress indicator UI component
- [ ] Update `doSave()` to use thread pool
- [ ] Test with large presets (100+ modules)
- [ ] Verify UI remains responsive during save
- [ ] Add error handling for background thread failures

---

### Issue 2: Silent Load Failures

#### Problem Description

When loading presets, if module names have changed, pins have been reconfigured, or channels have shifted, the system fails silently. The preset appears to load, but connections are broken, modules are missing, or parameters are wrong. Users have no indication that something went wrong.

#### Root Cause Analysis

The current load code in `ModularSynthProcessor::setStateInformation()`:

```cpp
void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    // ... parse XML ...
    
    // === NO VALIDATION OCCURS HERE ===
    
    // Module recreation - silently fails if type doesn't exist
    NodeID nodeId = addModule(type, false);  // Returns invalid NodeID if type unknown
    
    // Connection restoration - silently fails if channels invalid
    connect(srcNodeId, srcChan, dstNodeId, dstChan);  // Returns false on failure, but nobody checks!
    
    // Parameter restoration - silently fails if parameter ID changed
    mp->getAPVTS().replaceState(params);  // Ignores unknown parameters
}
```

**Failure Points:**
1. **Module Type Mismatch:** If `type="OldModuleName"` but module renamed to `"NewModuleName"`, `addModule()` fails silently
2. **Pin Changes:** If channel indices changed (e.g., VCO output moved from channel 0 to channel 1), connections fail silently
3. **Parameter ID Changes:** If parameter renamed (e.g., `"frequency"` ‚Üí `"freq"`), APVTS silently ignores it
4. **No User Feedback:** All failures are logged but never shown to user

#### Solution Strategy: Three-Stage Load Process

Instead of loading directly, we implement a robust pipeline: **Validate ‚Üí Auto-Heal ‚Üí Load & Notify**. This ensures presets are checked against the current system state (Pin Database, module factory) before loading, with automatic fixing of common issues.

**Step 1: Create a `PresetValidator`**

This class analyzes a preset `ValueTree` and produces a structured report of all discrepancies:

```cpp
// PresetValidator.h

class PresetValidator
{
public:
    struct Issue {
        enum Severity { Warning, Error };
        Severity severity;
        juce::String message;
        juce::ValueTree problematicNode; // Reference to the node in the ValueTree
    };

    std::vector<Issue> validate(const juce::ValueTree& preset)
    {
        std::vector<Issue> issues;
        auto modulesVT = preset.getChildWithName("modules");
        auto connsVT = preset.getChildWithName("connections");
        auto& pinDb = getModulePinDatabase();
        
        // Rule 1: Check if all module types exist in module factory
        // (Assuming you have access to moduleFactory or can check against PinDatabase)
        for (int i = 0; i < modulesVT.getNumChildren(); ++i)
        {
            auto moduleNode = modulesVT.getChild(i);
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Check against Pin Database (all valid modules should be registered there)
            auto it = pinDb.find(type.toLowerCase());
            if (it == pinDb.end())
            {
                issues.push_back({
                    Issue::Error, 
                    "Unknown module type: '" + type + "'", 
                    moduleNode
                });
            }
        }
        
        // Rule 2: Check if connection channels are valid
        // Build a map of logicalId -> module type for quick lookup
        std::map<juce::uint32, juce::String> logicalIdToType;
        for (int i = 0; i < modulesVT.getNumChildren(); ++i)
        {
            auto moduleNode = modulesVT.getChild(i);
            juce::uint32 logicalId = moduleNode.getProperty("logicalId", 0);
            juce::String type = moduleNode.getProperty("type").toString();
            logicalIdToType[logicalId] = type;
        }
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto connNode = connsVT.getChild(i);
            juce::uint32 srcId = connNode.getProperty("srcId", 0);
            int srcChan = connNode.getProperty("srcChan", 0);
            
            auto srcTypeIt = logicalIdToType.find(srcId);
            if (srcTypeIt != logicalIdToType.end())
            {
                juce::String srcModuleType = srcTypeIt->second;
                auto pinDbIt = pinDb.find(srcModuleType.toLowerCase());
                
                if (pinDbIt != pinDb.end())
                {
                    // Check if srcChan is a valid output channel for this module type
                    const auto& outputs = pinDbIt->second.audioOuts;
                    bool isValidChannel = std::any_of(outputs.begin(), outputs.end(),
                        [srcChan](const AudioPin& pin) { return pin.channelIndex == srcChan; });
                    
                    if (!isValidChannel)
                    {
                        issues.push_back({
                            Issue::Warning,
                            "Source channel " + juce::String(srcChan) + 
                            " is invalid for module type '" + srcModuleType + "'",
                            connNode
                        });
                    }
                }
            }
            
            // Similar validation for destination channels...
        }
        
        // Rule 3: Validate parameters (would need module instances or parameter registry)
        // TODO: Add parameter validation logic
        
        return issues;
    }
};
```

**Step 2: Create a `PresetAutoHealer`**

This class takes the `ValueTree` and attempts to fix common problems based on rules:

```cpp
// PresetAutoHealer.h

class PresetAutoHealer
{
public:
    // A simple map of known module renames (maintain this as modules evolve)
    const std::map<juce::String, juce::String> moduleRenames = {
        {"Sequencer", "sequencer"},
        {"VCO", "vco"},
        {"SampleLoader", "sample_loader"},
        {"OldVCO", "VCO"}, // Example: legacy name mapping
        // Add more mappings as modules are renamed across versions
    };

    juce::ValueTree heal(const juce::ValueTree& preset)
    {
        juce::ValueTree healed = preset.createCopy();
        auto modulesVT = healed.getChildWithName("modules");
        auto connsVT = healed.getChildWithName("connections");
        auto& pinDb = getModulePinDatabase();
        
        // Heal 1: Module Renames
        for (int i = 0; i < modulesVT.getNumChildren(); ++i)
        {
            auto moduleNode = modulesVT.getChild(i);
            juce::String currentType = moduleNode.getProperty("type").toString();
            
            if (moduleRenames.count(currentType))
            {
                juce::String newType = moduleRenames.at(currentType);
                moduleNode.setProperty("type", newType, nullptr);
                // Could log: "Healed: Renamed module type '" + currentType + "' ‚Üí '" + newType + "'"
            }
        }
        
        // Heal 2: Connection Channel Remapping
        // If a connection to channel X fails, but a pin with a similar name exists at channel Y,
        // attempt to remap the connection
        // TODO: Implement channel remapping by pin name matching
        // Example: If connection to channel 2 fails, but "Cutoff Mod" pin exists at channel 3,
        //          and the old pin was also named "Cutoff Mod", remap connection to channel 3
        
        return healed;
    }
};
```

**Step 3: Integrate into the Load Process**

Update the `doLoad()` function to use the validation and healing system. This reuses the `showSaveNotification()` function from the save solution:

```cpp
// In PresetCreatorComponent.cpp

void PresetCreatorComponent::doLoad()
{
    // Find default location (existing code)
    juce::File startDir;
    // ... (existing directory search logic) ...
    
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", startDir, "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc) noexcept
        {
            try {
                auto file = fc.getResult();
                if (!file.existsAsFile()) return;

                // Parse XML file
                auto xml = juce::XmlDocument::parse(file);
                if (!xml) 
                {
                    showSaveNotification("Failed to parse XML!", juce::Colours::darkred);
                    return;
                }

                juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);

                // === STAGE 1: VALIDATE ===
                PresetValidator validator;
                auto issues = validator.validate(presetVT);

                // === STAGE 2: AUTO-HEAL (if issues found) ===
                PresetAutoHealer healer;
                juce::ValueTree healedVT = presetVT;
                bool wasHealed = false;
                
                if (!issues.empty())
                {
                    healedVT = healer.heal(presetVT);
                    wasHealed = (healedVT != presetVT);
                    
                    // Re-validate the healed version to see if fixes worked
                    auto healedIssues = validator.validate(healedVT);
                    issues = healedIssues; // Use healed issues for notification
                }

                // === STAGE 3: LOAD & NOTIFY ===
                // Convert healed ValueTree to MemoryBlock for loading
                juce::MemoryBlock mb;
                juce::MemoryOutputStream mos(mb, false);
                healedVT.createXml()->writeTo(mos);
                
                // Load into synth
                synth->setStateInformation(mb.getData(), (int)mb.getSize());

                // Apply UI state from the file
                if (editor)
                {
                    auto uiState = healedVT.getChildWithName("NodeEditorUI");
                    if (uiState.isValid())
                        editor->applyUiValueTreeNow(uiState);
                }

                // Show non-blocking notification with results
                if (issues.empty()) 
                {
                    showSaveNotification("Preset loaded successfully!", 
                                       juce::Colours::darkgreen);
                } 
                else 
                {
                    int errorCount = 0;
                    int warningCount = 0;
                    for (const auto& issue : issues)
                    {
                        if (issue.severity == PresetValidator::Issue::Error)
                            errorCount++;
                        else
                            warningCount++;
                    }
                    
                    juce::String msg;
                    if (wasHealed && errorCount == 0)
                    {
                        msg = "Loaded with " + juce::String(warningCount) + 
                              " warnings (auto-healed)";
                        showSaveNotification(msg, juce::Colours::orange);
                    }
                    else
                    {
                        msg = "Loaded with " + juce::String(errorCount) + 
                              " errors, " + juce::String(warningCount) + " warnings";
                        if (wasHealed)
                            msg += " (partially healed)";
                        showSaveNotification(msg, juce::Colours::darkred);
                        
                        // TODO: Add a "Show Details" button that opens a log window
                        // showing all issues for debugging
                    }
                }

                refreshModulesList();
                
            } catch (...) {
                juce::Logger::writeToLog("[PresetCreator][FATAL] Exception in doLoad callback");
                showSaveNotification("Fatal error loading preset!", juce::Colours::darkred);
            }
        });
}
```

**Complete Flow Summary:**

```
1. Parse XML ‚Üí ValueTree
2. Validate ‚Üí List of Issues
3. Auto-Heal ‚Üí Fixed ValueTree (if issues found)
4. Re-Validate ‚Üí Check if healing worked
5. Load ‚Üí Apply to synth + UI
6. Notify ‚Üí Non-blocking status message
```

This three-stage approach ensures:
- ‚úÖ **Validation catches problems before loading**
- ‚úÖ **Auto-healing fixes common issues automatically**
- ‚úÖ **User gets clear feedback** about what happened
- ‚úÖ **System remains responsive** throughout the process

**4. Enhanced Logging for Debugging**

Create detailed load logs that can be shown to users:

```cpp
class LoadLogger
{
public:
    struct LogEntry {
        juce::Time timestamp;
        juce::String moduleType;
        juce::uint32 logicalId;
        juce::String action;      // "Created", "Connected", "ParameterSet", "Failed"
        juce::String details;
        bool success;
    };
    
    void logModuleCreation(juce::uint32 logicalId, const juce::String& type, bool success)
    {
        entries.push_back({
            juce::Time::getCurrentTime(),
            type,
            logicalId,
            "Created",
            success ? "OK" : "Module type not found",
            success
        });
    }
    
    void logConnection(juce::uint32 srcId, int srcChan, 
                      juce::uint32 dstId, int dstChan, bool success)
    {
        entries.push_back({
            juce::Time::getCurrentTime(),
            "",
            0,
            "Connected",
            "Module " + juce::String(srcId) + ":" + juce::String(srcChan) + 
            " ‚Üí " + juce::String(dstId) + ":" + juce::String(dstChan),
            success
        });
    }
    
    juce::String generateReport() const
    {
        juce::String report = "=== Preset Load Report ===\n\n";
        
        int successCount = 0;
        int failureCount = 0;
        
        for (const auto& entry : entries)
        {
            if (entry.success) successCount++;
            else failureCount++;
            
            report += "[" + entry.timestamp.toString(true, true) + "] ";
            report += entry.action;
            if (entry.logicalId > 0)
                report += " (Module " + juce::String(entry.logicalId);
            if (entry.moduleType.isNotEmpty())
                report += ", Type: " + entry.moduleType;
            report += "): " + entry.details + "\n";
        }
        
        report += "\nSummary: " + juce::String(successCount) + " successful, " +
                 juce::String(failureCount) + " failed\n";
        
        return report;
    }
    
private:
    std::vector<LogEntry> entries;
};
```

#### Implementation Checklist

**Validation System:**
- [ ] Create `PresetValidator` class with `Issue` struct
- [ ] Implement module type validation against Pin Database
- [ ] Implement connection channel validation (source and destination)
- [ ] Build logicalId ‚Üí moduleType lookup map for connection validation
- [ ] Add parameter validation (requires module instance or parameter registry)

**Auto-Healing System:**
- [ ] Create `PresetAutoHealer` class
- [ ] Maintain `moduleRenames` lookup table (update as modules evolve)
- [ ] Implement module name remapping in `heal()` method
- [ ] (Optional) Implement channel index remapping by pin name matching

**Integration:**
- [ ] Update `doLoad()` to use three-stage process (Validate ‚Üí Heal ‚Üí Load)
- [ ] Reuse `showSaveNotification()` for load feedback
- [ ] Add error handling for XML parsing failures
- [ ] Test with old presets containing renamed modules
- [ ] Test with presets containing invalid channels
- [ ] Test notification display with various issue combinations

**Future Enhancements:**
- [ ] Add "Show Details" button to notification (opens issue log window)
- [ ] Create `LoadLogger` class for detailed debugging reports
- [ ] Implement channel remapping by pin name similarity
- [ ] Document all auto-healing rules in code comments

#### Using Pin Database for Validation

**Example: Validating Connection Channels**

```cpp
bool validateConnectionChannel(const juce::String& moduleType,
                               int channelIndex,
                               bool isOutput)
{
    auto& pinDb = getModulePinDatabase();
    auto it = pinDb.find(moduleType.toLowerCase());
    
    if (it == pinDb.end())
        return false; // Module type doesn't exist
    
    const auto& pinInfo = it->second;
    const auto& pinList = isOutput ? pinInfo.audioOuts : pinInfo.audioIns;
    
    // Check if channel index exists in pin list
    return std::any_of(pinList.begin(), pinList.end(),
        [channelIndex](const AudioPin& pin) {
            return pin.channelIndex == channelIndex;
        });
}
```

**Example: Finding Alternate Channel Index**

```cpp
int findAlternateChannel(const juce::String& moduleType,
                        const juce::String& pinName,
                        bool isOutput)
{
    auto& pinDb = getModulePinDatabase();
    auto it = pinDb.find(moduleType.toLowerCase());
    if (it == pinDb.end()) return -1;
    
    const auto& pinList = isOutput ? it->second.audioOuts : it->second.audioIns;
    
    // Find pin with matching or similar name
    for (const auto& pin : pinList)
    {
        if (pin.name.toLowerCase().contains(pinName.toLowerCase()) ||
            pinName.toLowerCase().contains(pin.name.toLowerCase()))
        {
            return pin.channelIndex;
        }
    }
    
    return -1; // Not found
}
```

#### Using Nodes Dictionary for Parameter Validation

While the dictionary is Markdown (not directly parseable), you can:

1. **Extract Parameter Lists:** Create a script to parse `Nodes_Dictionary.md` and generate a parameter registry
2. **Maintain Registry:** Keep a `std::map<juce::String, std::vector<juce::String>>` mapping module types to parameter IDs
3. **Version History:** Document parameter renames in a lookup table

```cpp
// Parameter rename registry (maintained manually or via script)
std::map<std::pair<juce::String, juce::String>, juce::String> parameterRenames = {
    {{"VCO", "frequency"}, "freq"},  // Old param ID ‚Üí New param ID
    {{"VCF", "cutoff"}, "cutoffFreq"},
    // ... etc
};

juce::String healParameterId(const juce::String& moduleType, const juce::String& oldParamId)
{
    auto key = std::make_pair(moduleType, oldParamId);
    auto it = parameterRenames.find(key);
    return it != parameterRenames.end() ? it->second : oldParamId;
}
```

---

## Common Pitfalls

### ‚ùå Don't: Use Node UID in Connections
```cpp
// BAD: Node UIDs change on reload!
save_connection(node->nodeID.uid, otherNode->nodeID.uid);
```

### ‚úÖ Do: Use Logical IDs
```cpp
// GOOD: Logical IDs are stable
save_connection(logicalId1, logicalId2);
```

### ‚ùå Don't: Save Parameters Manually
```cpp
// BAD: Duplicate work, error-prone
xml->setAttribute("frequency", frequency);
xml->setAttribute("waveform", waveform);
```

### ‚úÖ Do: Use APVTS
```cpp
// GOOD: Automatic, correct, handles undo/redo
juce::ValueTree params = apvts.copyState();
```

### ‚ùå Don't: Forget commitChanges()
```cpp
// BAD: Changes not applied to audio thread
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
// Missing: synth->commitChanges();
```

### ‚úÖ Do: Always Commit
```cpp
// GOOD: Audio graph updated properly
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
synth->commitChanges(); // ‚úì
```

---

**End of Guide**

This document provides a complete understanding of the XML preset save/load system. For specific module implementation details, refer to the individual module processor files in `juce/Source/audio/modules/`.



================================================================================
FILE: juce\Source\preset_creator\PresetManager.h
================================================================================


#pragma once
#include <juce_core/juce_core.h>
#include <vector>
#include <memory>

class PresetManager
{
public:
    struct PresetInfo
    {
        juce::String name;
        juce::File file;
        juce::String description;
        juce::StringArray tags;
    };

    struct DirectoryNode
    {
        juce::String name;
        juce::File directory;
        std::vector<PresetInfo> presets;
        std::vector<std::unique_ptr<DirectoryNode>> subdirectories;
    };

    PresetManager() : rootNode(std::make_unique<DirectoryNode>()) {}

    DirectoryNode* getRootNode() const { return rootNode.get(); }

    void scanDirectory(const juce::File& directory)
    {
        rootNode->name = directory.getFileName();
        rootNode->directory = directory;
        rootNode->presets.clear();
        rootNode->subdirectories.clear();
        scanRecursively(rootNode.get());
    }

    void clearCache()
    {
        rootNode = std::make_unique<DirectoryNode>();
    }

private:
    void scanRecursively(DirectoryNode* node)
    {
        if (!node->directory.isDirectory()) return;

        for (const auto& entry : juce::RangedDirectoryIterator(node->directory, false, "*", juce::File::findFilesAndDirectories))
        {
            const auto& file = entry.getFile();
            if (file.isDirectory())
            {
                auto subdir = std::make_unique<DirectoryNode>();
                subdir->name = file.getFileName();
                subdir->directory = file;
                scanRecursively(subdir.get());
                node->subdirectories.push_back(std::move(subdir));
            }
            else if (file.hasFileExtension(".xml"))
            {
                PresetInfo info;
                info.name = file.getFileNameWithoutExtension();
                info.file = file;
                if (auto xml = juce::parseXML(file))
                {
                    info.description = xml->getStringAttribute("description", "");
                    info.tags = juce::StringArray::fromTokens(xml->getStringAttribute("tags", ""), ",", "");
                }
                node->presets.push_back(info);
            }
        }
    }

    std::unique_ptr<DirectoryNode> rootNode;
};


================================================================================
FILE: juce\Source\preset_creator\PresetManager.cpp
================================================================================


#include "PresetManager.h"

PresetManager::PresetManager()
{
}

void PresetManager::scanDirectory(const juce::File& directory)
{
    if (!directory.exists() || !directory.isDirectory())
        return;
    
    // Find all .xml preset files
    juce::Array<juce::File> presetFiles;
    directory.findChildFiles(presetFiles, juce::File::findFiles, false, "*.xml");
    
    for (const auto& file : presetFiles)
    {
        PresetInfo info = extractMetadata(file);
        m_presets.push_back(info);
    }
    
    juce::Logger::writeToLog("[PresetManager] Scanned " + juce::String(m_presets.size()) + 
                            " presets from: " + directory.getFullPathName());
}

std::vector<PresetManager::PresetInfo> PresetManager::searchPresets(const juce::String& searchTerm) const
{
    std::vector<PresetInfo> results;
    
    for (const auto& preset : m_presets)
    {
        if (preset.matchesSearch(searchTerm))
            results.push_back(preset);
    }
    
    return results;
}

std::vector<PresetManager::PresetInfo> PresetManager::getPresetsByTag(const juce::String& tag) const
{
    std::vector<PresetInfo> results;
    
    for (const auto& preset : m_presets)
    {
        if (preset.tags.contains(tag))
            results.push_back(preset);
    }
    
    return results;
}

juce::StringArray PresetManager::getAllTags() const
{
    juce::StringArray allTags;
    
    for (const auto& preset : m_presets)
    {
        for (const auto& tag : preset.tags)
        {
            if (!allTags.contains(tag))
                allTags.add(tag);
        }
    }
    
    allTags.sort(true);
    return allTags;
}

juce::XmlElement* PresetManager::loadPreset(const juce::File& file)
{
    if (!file.exists())
        return nullptr;
    
    return juce::XmlDocument::parse(file).release();
}

bool PresetManager::savePreset(const juce::File& file, 
                               const juce::XmlElement& presetData,
                               const juce::String& description,
                               const juce::StringArray& tags)
{
    // Create a copy of the preset data and add metadata
    std::unique_ptr<juce::XmlElement> presetCopy(new juce::XmlElement(presetData));
    
    // Add metadata properties to the root element
    if (description.isNotEmpty())
        presetCopy->setAttribute("description", description);
    
    if (!tags.isEmpty())
        presetCopy->setAttribute("tags", tags.joinIntoString(","));
    
    // Write to file
    if (presetCopy->writeTo(file))
    {
        // Update cache
        PresetInfo info = extractMetadata(file);
        
        // Remove old entry if exists
        m_presets.erase(std::remove_if(m_presets.begin(), m_presets.end(),
            [&file](const PresetInfo& p) { return p.file == file; }), m_presets.end());
        
        // Add new entry
        m_presets.push_back(info);
        
        return true;
    }
    
    return false;
}

PresetManager::PresetInfo PresetManager::extractMetadata(const juce::File& file)
{
    PresetInfo info;
    info.file = file;
    info.name = file.getFileNameWithoutExtension();
    info.lastModified = file.getLastModificationTime();
    
    // Parse the XML to extract metadata
    std::unique_ptr<juce::XmlElement> xml = juce::XmlDocument::parse(file);
    
    if (xml != nullptr)
    {
        // Extract description
        info.description = xml->getStringAttribute("description", "");
        
        // Extract tags
        juce::String tagsStr = xml->getStringAttribute("tags", "");
        if (tagsStr.isNotEmpty())
        {
            info.tags.addTokens(tagsStr, ",", "");
            info.tags.trim();
        }
    }
    
    return info;
}



================================================================================
FILE: juce\CMakeLists.txt
================================================================================


cmake_minimum_required(VERSION 3.22)
project(ColliderAudioEngine VERSION 0.1.0)

if(MSVC)
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /Z7")
    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /Z7")
endif()

# ==============================================================================
# [OPTIONAL] Enable sccache for faster C/C++/CUDA rebuilds
# ==============================================================================
# Add an option to control sccache usage, default to ON
option(ENABLE_SCCACHE "Enable sccache if found for faster builds" ON)

if(ENABLE_SCCACHE)
    find_program(SCCACHE_EXECUTABLE sccache)
    if(SCCACHE_EXECUTABLE)
        message(STATUS "‚úì sccache found, enabling compiler cache: ${SCCACHE_EXECUTABLE}")
        set(CMAKE_C_COMPILER_LAUNCHER ${SCCACHE_EXECUTABLE})
        set(CMAKE_CXX_COMPILER_LAUNCHER ${SCCACHE_EXECUTABLE})
        set(CMAKE_CUDA_COMPILER_LAUNCHER ${SCCACHE_EXECUTABLE})
    else()
        message(WARNING "sccache not found in PATH. Compiler cache is DISABLED. \
                         Install with 'brew install sccache' or 'cargo install sccache' for faster builds.")
    endif()
else()
    message(STATUS "sccache disabled by user (ENABLE_SCCACHE=OFF).")
endif()
# ==============================================================================

# --- TTS Integration (Piper) ---

# 1. Set paths to pre-built Piper and ONNX Runtime
set(PIPER_DIR "${CMAKE_SOURCE_DIR}/../vendor/piper/piper" CACHE PATH "Path to Piper TTS")
set(ONNXRUNTIME_DIR "${CMAKE_SOURCE_DIR}/../vendor/onnxruntime" CACHE PATH "Path to ONNX Runtime")

if(NOT EXISTS "${PIPER_DIR}")
    message(WARNING "Piper TTS not found at ${PIPER_DIR}. TTS features will be limited.")
endif()

if(NOT EXISTS "${ONNXRUNTIME_DIR}")
    message(WARNING "ONNX Runtime not found at ${ONNXRUNTIME_DIR}. TTS features will be limited.")
endif()

# 2. Add SoundTouch library
set(SOUNDTOUCH_SOURCE_DIR "${CMAKE_SOURCE_DIR}/../soundtouch/source")
add_library(soundtouch STATIC
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/AAFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/BPMDetect.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIFOSampleBuffer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIRFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateCubic.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateLinear.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateShannon.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/PeakFinder.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/RateTransposer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/SoundTouch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/TDStretch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/cpu_detect_x86.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/mmx_optimized.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/sse_optimized.cpp
)
target_include_directories(soundtouch PUBLIC 
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(FetchContent)

# ------------------------------------------------------------------------------
# ImNodes Zoom Integration Toggle (fork-based)
# ------------------------------------------------------------------------------
# If PRESET_CREATOR_IMNODES_ZOOM is ON and both IMNODES_FORK_URL and IMNODES_FORK_TAG
# are provided, we'll fetch imnodes from the fork at the specified commit/tag.
# Otherwise, we fall back to upstream imnodes at the pinned upstream tag.
option(PRESET_CREATOR_IMNODES_ZOOM "Use fork of imnodes with zoom feature" OFF)
set(IMNODES_FORK_URL "" CACHE STRING "Fork URL for imnodes (with zoom commit)")
set(IMNODES_FORK_TAG "" CACHE STRING "Fork commit/tag for imnodes (with zoom)")

# ==============================================================================
# Third-Party Dependencies (Fetch Only)
# ==============================================================================

FetchContent_Declare(JUCE
    GIT_REPOSITORY https://github.com/juce-framework/JUCE.git
    GIT_TAG 7.0.9
)
set(JUCE_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(JUCE_BUILD_EXTRAS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(JUCE)

FetchContent_Declare(imgui_fc
    GIT_REPOSITORY https://github.com/ocornut/imgui.git
    # Use docking branch to ensure PlatformIO/viewport APIs are present
    GIT_TAG docking
)
FetchContent_MakeAvailable(imgui_fc)

# imnodes uses find_package(imgui) in its CMake; build as sources instead
if(PRESET_CREATOR_IMNODES_ZOOM AND IMNODES_FORK_URL AND IMNODES_FORK_TAG)
    message(STATUS "Using forked imnodes for zoom: ${IMNODES_FORK_URL} @ ${IMNODES_FORK_TAG}")
    FetchContent_Declare(imnodes_fc
        GIT_REPOSITORY ${IMNODES_FORK_URL}
        GIT_TAG ${IMNODES_FORK_TAG}
    )
else()
    message(STATUS "Using upstream imnodes (no zoom fork)")
    FetchContent_Declare(imnodes_fc
        GIT_REPOSITORY https://github.com/Nelarius/imnodes.git
        GIT_TAG b2ec254ce576ac3d42dfb7aef61deadbff8e7211
    )
endif()
FetchContent_GetProperties(imnodes_fc)
if(NOT imnodes_fc_POPULATED)
  FetchContent_Populate(imnodes_fc)
endif()

# imgui_juce backend (dedicated JUCE bridge for ImGui)
FetchContent_Declare(imgui_juce_fc
    GIT_REPOSITORY https://github.com/Krasjet/imgui_juce.git
    GIT_TAG master
)
FetchContent_MakeAvailable(imgui_juce_fc)

# --------------------------------------------------------------
# Box2D (2D physics engine for physics-based audio module)
# --------------------------------------------------------------
FetchContent_Declare(box2d_fc
    GIT_REPOSITORY https://github.com/erincatto/box2d.git
    GIT_TAG v2.4.1
)
set(BOX2D_BUILD_UNIT_TESTS OFF CACHE BOOL "" FORCE)
set(BOX2D_BUILD_TESTBED OFF CACHE BOOL "" FORCE)
set(BOX2D_BUILD_DOCS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(box2d_fc)

# --------------------------------------------------------------
# GLM (OpenGL Mathematics library for 3D vector/matrix math)
# --------------------------------------------------------------
FetchContent_Declare(
  glm
  GIT_REPOSITORY https://github.com/g-truc/glm.git
  GIT_TAG        1.0.1 # Latest stable version
)
FetchContent_MakeAvailable(glm)

# --------------------------------------------------------------
# nlohmann/json (required by tinygltf)
# --------------------------------------------------------------
FetchContent_Declare(
  nlohmann_json
  GIT_REPOSITORY https://github.com/nlohmann/json.git
  GIT_TAG        v3.11.3 # A recent stable version
)
FetchContent_MakeAvailable(nlohmann_json)

# --------------------------------------------------------------
# tinygltf (glTF 2.0 file loader for animation system)
# --------------------------------------------------------------
FetchContent_Declare(
  tinygltf
  GIT_REPOSITORY https://github.com/syoyo/tinygltf.git
  GIT_TAG        v2.8.20 # A recent stable version
)
FetchContent_MakeAvailable(tinygltf)

# --------------------------------------------------------------
# ufbx (FBX file loader for animation system)
# --------------------------------------------------------------
FetchContent_Declare(
  ufbx
  GIT_REPOSITORY https://github.com/ufbx/ufbx.git
  GIT_TAG        v0.10.0 # A recent stable version of ufbx
)
FetchContent_MakeAvailable(ufbx)

# Get the path to the downloaded ufbx source code
FetchContent_GetProperties(ufbx SOURCE_DIR ufbx_SOURCE_DIR)

# Create a dedicated static library target for ufbx (single-header library needs separate compilation unit)
add_library(ufbx_static STATIC ${ufbx_SOURCE_DIR}/ufbx.c)
target_include_directories(ufbx_static PUBLIC ${ufbx_SOURCE_DIR})

# ==============================================================================
# CUDA & cuDNN Configuration (MUST be done before OpenCV)
# ==============================================================================
# Find the CUDA Toolkit. This will use the default installation path or environment
# variables. This is essential for OpenCV's configuration to detect CUDA correctly.
find_package(CUDAToolkit REQUIRED)

# Find CUDA runtime library for direct linking if CUDAToolkit::cudart target is not available
if(MSVC)
    find_library(CUDA_CUDART_LIBRARY
        NAMES cudart_static.lib cudart.lib
        PATHS "${CUDAToolkit_LIBRARY_DIR}"
        NO_DEFAULT_PATH
    )
else()
    find_library(CUDA_CUDART_LIBRARY
        NAMES cudart
        PATHS "${CUDAToolkit_LIBRARY_DIR}"
        NO_DEFAULT_PATH
    )
endif()

# --- NPP (NVIDIA Performance Primitives) Configuration ---
# Explicitly set CUDA and NPP paths for OpenCV to find them
set(CUDA_TOOLKIT_ROOT_DIR "${CUDAToolkit_TARGET_DIR}" CACHE PATH "CUDA Toolkit root directory")
set(CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES "${CUDAToolkit_INCLUDE_DIRS}" CACHE PATH "CUDA Toolkit include directories")

# Set NPP include and library directories explicitly
# NPP headers are in the CUDA Toolkit include directory
set(CUDA_INCLUDE_DIRS "${CUDAToolkit_INCLUDE_DIRS}" CACHE PATH "CUDA include directories")
set(CUDA_NPP_LIBRARY_ROOT_DIR "${CUDAToolkit_LIBRARY_DIR}" CACHE PATH "NPP library root directory")

# Provide hints for cuDNN path.
# First check if cuDNN is integrated into CUDA Toolkit (recommended approach)
# Then fall back to standalone cuDNN installation
set(CUDNN_FOUND FALSE)

# CRITICAL FIX: CUDAToolkit_INCLUDE_DIRS is a LIST, extract the first element
list(GET CUDAToolkit_INCLUDE_DIRS 0 CUDA_MAIN_INCLUDE_DIR)

# Check in CUDA Toolkit directory first
if(EXISTS "${CUDA_MAIN_INCLUDE_DIR}/cudnn.h")
    set(CUDNN_INCLUDE_DIR "${CUDA_MAIN_INCLUDE_DIR}" CACHE PATH "Path to cuDNN include directory")
    set(CUDNN_LIBRARY "${CUDAToolkit_LIBRARY_DIR}/cudnn.lib" CACHE FILEPATH "Path to cuDNN library")
    set(CUDNN_FOUND TRUE)
    message(STATUS "Found cuDNN integrated into CUDA Toolkit at ${CUDA_MAIN_INCLUDE_DIR}")
# Fall back to standalone cuDNN installation
elseif(EXISTS "C:/Program Files/NVIDIA/CUDNN/v9.14/include/cudnn.h")
    set(CUDNN_INCLUDE_DIR "C:/Program Files/NVIDIA/CUDNN/v9.14/include" CACHE PATH "Path to cuDNN include directory")
    set(CUDNN_LIBRARY "C:/Program Files/NVIDIA/CUDNN/v9.14/lib/x64/cudnn.lib" CACHE FILEPATH "Path to cuDNN library")
    set(CUDNN_FOUND TRUE)
    message(STATUS "Found standalone cuDNN at C:/Program Files/NVIDIA/CUDNN/v9.14/")
endif()

# Configure OpenCV based on cuDNN availability
if(CUDNN_FOUND)
    set(WITH_CUDNN ON CACHE BOOL "" FORCE)
    set(OPENCV_DNN_CUDA ON CACHE BOOL "" FORCE)
else()
    message(WARNING "cuDNN not found. OpenCV will build without cuDNN support.")
    message(WARNING "Disabling OPENCV_DNN_CUDA since cuDNN is required for CUDA DNN backend.")
    set(WITH_CUDNN OFF CACHE BOOL "" FORCE)
    set(OPENCV_DNN_CUDA OFF CACHE BOOL "" FORCE)
endif()

# ==============================================================================
# OpenCV (Computer Vision Library - with CUDA Support)
# ==============================================================================
# NEW ISOLATION STRATEGY:
# 1. Try to find pre-built OpenCV (from standalone builder)
# 2. Fall back to building from source if not found
# 
# This prevents OpenCV CUDA from rebuilding when CMakeLists.txt changes!
# 
# To build OpenCV once: .\build_opencv_cuda_once.ps1
# ==============================================================================

# Add CUDA include directories for all builds
include_directories(SYSTEM ${CUDAToolkit_INCLUDE_DIRS})

# Check for standalone pre-built OpenCV
set(OPENCV_INSTALL_PREFIX "${CMAKE_SOURCE_DIR}/opencv_cuda_install")
set(OPENCV_PREBUILT FALSE)
set(OPENCV_HAS_RELEASE FALSE)
set(OPENCV_HAS_DEBUG FALSE)

# Check if the standalone installation exists
if(EXISTS "${OPENCV_INSTALL_PREFIX}/lib/opencv_world4130.lib")
    set(OPENCV_HAS_RELEASE TRUE)
endif()
if(EXISTS "${OPENCV_INSTALL_PREFIX}/lib/opencv_world4130d.lib")
    set(OPENCV_HAS_DEBUG TRUE)
endif()

if(OPENCV_HAS_RELEASE OR OPENCV_HAS_DEBUG)
    # Found standalone OpenCV - use find_package() to get everything
    set(OPENCV_PREBUILT TRUE)
    
    message(STATUS "")
    message(STATUS "========================================")
    message(STATUS "  Found Pre-Built OpenCV with CUDA!")
    message(STATUS "========================================")
    message(STATUS "Location: ${OPENCV_INSTALL_PREFIX}")
    message(STATUS "")
    if(OPENCV_HAS_RELEASE)
        message(STATUS "‚úì Release configuration available")
    endif()
    if(OPENCV_HAS_DEBUG)
        message(STATUS "‚úì Debug configuration available")
    endif()
    message(STATUS "")
    message(STATUS "‚úì Using cached build (no rebuild needed!)")
    message(STATUS "  You can modify CMakeLists.txt without rebuilding OpenCV!")
    message(STATUS "")
    
    # Use find_package to get ALL transitive dependencies automatically
    set(OpenCV_DIR "${OPENCV_INSTALL_PREFIX}/lib/cmake/OpenCV")
    find_package(OpenCV 4.13 REQUIRED)
    
    if(NOT OpenCV_FOUND)
        message(FATAL_ERROR "OpenCV installation found but CMake config is broken!")
    endif()
    
    message(STATUS "‚úì OpenCV CMake config loaded successfully")
    message(STATUS "  - Include dirs: ${OpenCV_INCLUDE_DIRS}")
    message(STATUS "  - Libraries: ${OpenCV_LIBS}")
    message(STATUS "  - Version: ${OpenCV_VERSION}")
    
    # Set paths for compatibility with rest of CMakeLists
    set(opencv_SOURCE_DIR "${OPENCV_INSTALL_PREFIX}/include")
    set(OPENCV_BUILD_DIR "${OPENCV_INSTALL_PREFIX}/include")
    set(opencv_contrib_SOURCE_DIR "${OPENCV_INSTALL_PREFIX}/include")
    
else()
    message(STATUS "")
    message(STATUS "========================================")
    message(STATUS "  Pre-Built OpenCV NOT Found")
    message(STATUS "========================================")
    message(STATUS "Will build from source (takes 30-45 minutes)")
    message(STATUS "")
    message(STATUS "To avoid future rebuilds, run:")
    message(STATUS "  .\\build_opencv_cuda_once.ps1")
    message(STATUS "")
    
    # Add /FS flag for MSVC BEFORE declaring OpenCV
    if(MSVC)
        set(SAVED_CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
        set(SAVED_CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
        set(CMAKE_CXX_FLAGS_INIT "${CMAKE_CXX_FLAGS_INIT} /FS" CACHE STRING "" FORCE)
        set(CMAKE_C_FLAGS_INIT "${CMAKE_C_FLAGS_INIT} /FS" CACHE STRING "" FORCE)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /FS")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /FS")
    endif()
    
    # Fetch OpenCV from source
    FetchContent_Declare(
      opencv
      GIT_REPOSITORY https://github.com/opencv/opencv.git
      GIT_TAG        4.x
    )
    
    FetchContent_Declare(
      opencv_contrib
      GIT_REPOSITORY https://github.com/opencv/opencv_contrib.git
      GIT_TAG        4.x
    )
    
    # Populate opencv_contrib first
    FetchContent_GetProperties(opencv_contrib)
    if(NOT opencv_contrib_POPULATED)
        FetchContent_Populate(opencv_contrib)
    endif()
    FetchContent_GetProperties(opencv_contrib SOURCE_DIR opencv_contrib_SOURCE_DIR)
    
    set(OPENCV_EXTRA_MODULES_PATH "${opencv_contrib_SOURCE_DIR}/modules" CACHE PATH "" FORCE)
    
    # OpenCV Build Configuration
    set(BUILD_SHARED_LIBS OFF)
    set(BUILD_opencv_world ON)
    set(BUILD_TESTS OFF)
    set(BUILD_PERF_TESTS OFF)
    set(BUILD_EXAMPLES OFF)
    set(BUILD_opencv_apps OFF)
    set(ENABLE_PRECOMPILED_HEADERS OFF)
    set(BUILD_WITH_STATIC_CRT OFF)
    set(WITH_IPP OFF)
    
    # CUDA Configuration
    set(WITH_CUDA ON CACHE BOOL "" FORCE)
    set(WITH_NVIDIA_NPP ON CACHE BOOL "" FORCE)
    set(WITH_NVCUVID OFF)
    set(WITH_NVCUVENC OFF)
    
    set(CUDA_TOOLKIT_ROOT_DIR "${CUDAToolkit_TARGET_DIR}" CACHE PATH "" FORCE)
    set(CUDA_INCLUDE_DIRS "${CUDAToolkit_INCLUDE_DIRS}" CACHE PATH "" FORCE)
    
    # CUDA Architecture
    set(CUDA_ARCH_BIN "8.6;8.9;12.0")
    set(CUDA_ARCH_PTX "12.0")
    
    # Required modules
    set(BUILD_opencv_core ON)
    set(BUILD_opencv_dnn ON)
    set(BUILD_opencv_features2d ON)
    set(BUILD_opencv_highgui ON)
    set(BUILD_opencv_imgcodecs ON)
    set(BUILD_opencv_imgproc ON)
    set(BUILD_opencv_objdetect ON)
    set(BUILD_opencv_tracking ON)
    set(BUILD_opencv_video ON)
    set(BUILD_opencv_videoio ON)
    set(BUILD_opencv_calib3d ON)
    set(OPENCV_DNN_CAFFE ON)
    
    # Build OpenCV
    FetchContent_MakeAvailable(opencv)
    
    # Get build directory
    FetchContent_GetProperties(opencv)
    if(NOT opencv_POPULATED)
        FetchContent_Populate(opencv)
    endif()
    set(OPENCV_BUILD_DIR "${CMAKE_BINARY_DIR}/_deps/opencv-build")
    
    # Generate opencv_modules.hpp if missing
    set(OPENCV_MODULES_HPP "${OPENCV_BUILD_DIR}/opencv2/opencv_modules.hpp")
    if(NOT EXISTS "${OPENCV_MODULES_HPP}")
        message(STATUS "Generating opencv_modules.hpp...")
        file(MAKE_DIRECTORY "${OPENCV_BUILD_DIR}/opencv2")
        file(WRITE "${OPENCV_MODULES_HPP}"
"/*
 * Auto-generated by CMake
 */

#ifndef OPENCV_MODULES_HPP
#define OPENCV_MODULES_HPP

#define HAVE_OPENCV_CALIB3D
#define HAVE_OPENCV_CORE
#define HAVE_OPENCV_DNN
#define HAVE_OPENCV_FEATURES2D
#define HAVE_OPENCV_FLANN
#define HAVE_OPENCV_GAPI
#define HAVE_OPENCV_HIGHGUI
#define HAVE_OPENCV_IMGCODECS
#define HAVE_OPENCV_IMGPROC
#define HAVE_OPENCV_ML
#define HAVE_OPENCV_OBJDETECT
#define HAVE_OPENCV_PHOTO
#define HAVE_OPENCV_STITCHING
#define HAVE_OPENCV_VIDEO
#define HAVE_OPENCV_VIDEOIO
#define HAVE_OPENCV_WORLD

#endif
")
    endif()
    
    # Restore flags
    if(MSVC)
        set(CMAKE_CXX_FLAGS "${SAVED_CMAKE_CXX_FLAGS} /FS")
        set(CMAKE_C_FLAGS "${SAVED_CMAKE_C_FLAGS} /FS")
    endif()
endif()

# ==============================================================================
# Post-Configuration (Common to both pre-built and source builds)
# ==============================================================================
# Set OpenCV link libraries based on whether we're using pre-built or source-built

if(OPENCV_PREBUILT)
    # Pre-built: Use ${OpenCV_LIBS} which includes all transitive dependencies
    set(OPENCV_LINK_LIBS ${OpenCV_LIBS})
    message(STATUS "Using pre-built OpenCV: ${OpenCV_LIBS}")
else()
    # Source-built: Use the opencv_world target directly
    set(OPENCV_LINK_LIBS opencv_world)
    message(STATUS "Using source-built OpenCV: opencv_world target")
endif()

# ==============================================================================
# Define CUDA Support Preprocessor Macro for Application Code
# ==============================================================================
# This allows C++ code to check #if WITH_CUDA_SUPPORT at compile time
# Only define if both CUDA and cuDNN are available (required for full DNN CUDA support)
if(WITH_CUDA AND CUDNN_FOUND)
    message(STATUS "‚úì Enabling WITH_CUDA_SUPPORT preprocessor definition")
    message(STATUS "  - CUDA Version: ${CUDAToolkit_VERSION}")
    message(STATUS "  - cuDNN Found: ${CUDNN_INCLUDE_DIR}")
    # Will be added to targets later via target_compile_definitions
    set(CUDA_SUPPORT_ENABLED TRUE)
else()
    message(STATUS "CUDA support disabled - WITH_CUDA_SUPPORT not defined")
    if(NOT WITH_CUDA)
        message(STATUS "  Reason: WITH_CUDA is OFF")
    elseif(NOT CUDNN_FOUND)
        message(STATUS "  Reason: cuDNN not found")
    endif()
    set(CUDA_SUPPORT_ENABLED FALSE)
endif()

# ==============================================================================
# FFmpeg (Pre-built vendor binaries - SIMPLIFIED!)
# ==============================================================================
# Windows: Download from https://github.com/BtbN/FFmpeg-Builds/releases
# Extract to vendor/ffmpeg/ (see FFMPEG_SETUP_GUIDE.md)
set(FFMPEG_DIR "${CMAKE_SOURCE_DIR}/../vendor/ffmpeg" CACHE PATH "Path to FFmpeg")
set(FFMPEG_FOUND FALSE)

if(WIN32)
    # Windows: Use pre-built vendor binaries
    if(EXISTS "${FFMPEG_DIR}/include/libavformat/avformat.h")
        message(STATUS "‚úì FFmpeg found at ${FFMPEG_DIR}")
        
        set(FFMPEG_INCLUDE_DIR "${FFMPEG_DIR}/include")
        set(FFMPEG_LIB_DIR "${FFMPEG_DIR}/lib")
        set(FFMPEG_BIN_DIR "${FFMPEG_DIR}/bin")
        
        # Find all required libraries
        find_library(AVFORMAT_LIBRARY avformat PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(AVCODEC_LIBRARY avcodec PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(AVUTIL_LIBRARY avutil PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(SWRESAMPLE_LIBRARY swresample PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(SWSCALE_LIBRARY swscale PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        
        set(FFMPEG_LIBRARIES 
            ${AVFORMAT_LIBRARY}
            ${AVCODEC_LIBRARY}
            ${AVUTIL_LIBRARY}
            ${SWRESAMPLE_LIBRARY}
            ${SWSCALE_LIBRARY}
        )
        
        message(STATUS "  - Include: ${FFMPEG_INCLUDE_DIR}")
        message(STATUS "  - Libraries: ${FFMPEG_LIBRARIES}")
        set(FFMPEG_FOUND TRUE)
    else()
        message(FATAL_ERROR 
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "‚ùå FFmpeg NOT FOUND!\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "Expected location: ${FFMPEG_DIR}\n"
            "\n"
            "üì¶ Quick Setup (5 minutes):\n"
            "  1. Download: https://github.com/BtbN/FFmpeg-Builds/releases\n"
            "     Get: ffmpeg-master-latest-win64-gpl-shared.zip\n"
            "  2. Extract to: ${FFMPEG_DIR}\n"
            "  3. Folder structure should be:\n"
            "     vendor/ffmpeg/\n"
            "       ‚îú‚îÄ‚îÄ bin/     (DLL files)\n"
            "       ‚îú‚îÄ‚îÄ include/ (header files)\n"
            "       ‚îî‚îÄ‚îÄ lib/     (.lib files)\n"
            "\n"
            "üìñ See FFMPEG_SETUP_GUIDE.md for detailed instructions\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        )
    endif()
else()
    # Linux/Mac: Use system packages
    find_package(PkgConfig QUIET)
    if(PKG_CONFIG_FOUND)
        pkg_check_modules(FFMPEG
            libavformat>=57.0
            libavcodec>=57.0
            libavutil>=55.0
            libswresample>=3.0
            libswscale>=5.0
        )
        if(FFMPEG_FOUND)
            set(FFMPEG_INCLUDE_DIR ${FFMPEG_INCLUDE_DIRS})
            set(FFMPEG_LIBRARIES ${FFMPEG_LIBRARIES})
            message(STATUS "‚úì FFmpeg found via pkg-config")
            message(STATUS "  - Include: ${FFMPEG_INCLUDE_DIR}")
        endif()
    endif()
    
    # Fallback: try finding libraries directly
    if(NOT FFMPEG_FOUND)
        find_path(FFMPEG_INCLUDE_DIR NAMES libavformat/avformat.h
            PATHS /usr/include /usr/local/include /opt/homebrew/include
        )
        find_library(AVFORMAT_LIBRARY avformat)
        find_library(AVCODEC_LIBRARY avcodec)
        find_library(AVUTIL_LIBRARY avutil)
        find_library(SWRESAMPLE_LIBRARY swresample)
        find_library(SWSCALE_LIBRARY swscale)
        
        if(FFMPEG_INCLUDE_DIR AND AVFORMAT_LIBRARY)
            set(FFMPEG_LIBRARIES 
                ${AVFORMAT_LIBRARY}
                ${AVCODEC_LIBRARY}
                ${AVUTIL_LIBRARY}
                ${SWRESAMPLE_LIBRARY}
                ${SWSCALE_LIBRARY}
            )
            set(FFMPEG_FOUND TRUE)
            message(STATUS "‚úì FFmpeg found")
        else()
            message(FATAL_ERROR
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                "‚ùå FFmpeg NOT FOUND!\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                "üì¶ Install FFmpeg:\n"
                "  Linux:  sudo apt-get install libavformat-dev libavcodec-dev libavutil-dev libswresample-dev libswscale-dev\n"
                "  macOS:  brew install ffmpeg\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            )
        endif()
    endif()
endif()

# --------------------------------------------------------------
# Rubber Band (optional, real-time timestretcher/pitch-shifter)
# --------------------------------------------------------------
set(USE_RUBBERBAND ON CACHE BOOL "Enable Rubber Band time/pitch processing")
if (USE_RUBBERBAND)
  FetchContent_Declare(rubberband_fc
    GIT_REPOSITORY https://github.com/breakfastquay/rubberband.git
    GIT_TAG v3.3.0
  )
  FetchContent_MakeAvailable(rubberband_fc)
  # Build from single-file amalgamation to avoid external link issues
  # Use official amalgamated single-file build (works cross-platform)
  add_library(rubberband_single STATIC
    ${rubberband_fc_SOURCE_DIR}/single/RubberBandSingle.cpp
  )
  target_include_directories(rubberband_single PUBLIC
    ${rubberband_fc_SOURCE_DIR}
    ${rubberband_fc_SOURCE_DIR}/single
  )
  target_compile_definitions(rubberband_single PUBLIC
    NOMINMAX
    _USE_MATH_DEFINES
    RUBBERBAND_USE_R3=1
    RUBBERBAND_BUILD_FFT=KISSFFT
    RUBBERBAND_BUILD_RESAMPLER=NONE
  )
  set(RUBBERBAND_TARGET rubberband_single)
  set(RUBBERBAND_INCLUDE_DIR "${rubberband_fc_SOURCE_DIR}")
endif()

# ==============================================================================
# Main Engine App Target (Unchanged)
# ==============================================================================
juce_add_gui_app(ColliderApp
    PRODUCT_NAME "Collider Audio Engine"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(ColliderApp PRIVATE
    Source/main.cpp
    Source/app/MainApplication.cpp
    Source/app/MainApplication.h
    Source/ui/MainComponent.cpp
    Source/ui/MainComponent.h
    Source/ui/TestHarnessComponent.cpp
    Source/ui/TestHarnessComponent.h
    Source/ui/VisualiserComponent.cpp
    Source/ui/VisualiserComponent.h
    Source/ui/DebugInfo.h
    Source/audio/AudioEngine.h
    Source/audio/AudioEngine.cpp
    Source/audio/MidiDeviceManager.h
    Source/audio/MidiDeviceManager.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/voices/SynthVoiceProcessor.h
    Source/audio/voices/SynthVoiceProcessor.cpp
    Source/audio/voices/NoiseVoiceProcessor.h
    Source/audio/voices/NoiseVoiceProcessor.cpp
    Source/audio/voices/ModularVoice.h
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/fx/FXChain.h
    Source/audio/fx/GainProcessor.h
    Source/audio/fx/GainProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/ModuleProcessor.cpp
    Source/audio/modules/AudioInputModuleProcessor.h
    Source/audio/modules/AudioInputModuleProcessor.cpp
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/CVMixerModuleProcessor.h
    Source/audio/modules/CVMixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MultiSequencerModuleProcessor.h
    Source/audio/modules/MultiSequencerModuleProcessor.cpp
    Source/audio/modules/LagProcessorModuleProcessor.h
    Source/audio/modules/LagProcessorModuleProcessor.cpp
    Source/audio/modules/DeCrackleModuleProcessor.h
    Source/audio/modules/DeCrackleModuleProcessor.cpp
    Source/audio/modules/GraphicEQModuleProcessor.h
    Source/audio/modules/GraphicEQModuleProcessor.cpp
    Source/audio/modules/FrequencyGraphModuleProcessor.h
    Source/audio/modules/FrequencyGraphModuleProcessor.cpp
    Source/audio/modules/ChorusModuleProcessor.h
    Source/audio/modules/ChorusModuleProcessor.cpp
    Source/audio/modules/PhaserModuleProcessor.h
    Source/audio/modules/PhaserModuleProcessor.cpp
    Source/audio/modules/CompressorModuleProcessor.h
    Source/audio/modules/CompressorModuleProcessor.cpp
    Source/audio/modules/RecordModuleProcessor.h
    Source/audio/modules/RecordModuleProcessor.cpp
    Source/audio/modules/CommentModuleProcessor.h
    Source/audio/modules/CommentModuleProcessor.cpp
    Source/audio/modules/LimiterModuleProcessor.h
    Source/audio/modules/LimiterModuleProcessor.cpp
    Source/audio/modules/GateModuleProcessor.h
    Source/audio/modules/GateModuleProcessor.cpp
    Source/audio/modules/DriveModuleProcessor.h
    Source/audio/modules/DriveModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/ComparatorModuleProcessor.h
    Source/audio/modules/ComparatorModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/MultiBandShaperModuleProcessor.h
    Source/audio/modules/MultiBandShaperModuleProcessor.cpp
    Source/audio/modules/GranulatorModuleProcessor.h
    Source/audio/modules/GranulatorModuleProcessor.cpp
    Source/audio/modules/HarmonicShaperModuleProcessor.h
    Source/audio/modules/HarmonicShaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
    Source/audio/modules/TimePitchModuleProcessor.h
    Source/audio/modules/TimePitchModuleProcessor.cpp
    Source/audio/modules/MIDIPlayerModuleProcessor.h
    Source/audio/modules/MIDIPlayerModuleProcessor.cpp
        Source/audio/modules/TrackMixerModuleProcessor.h
        Source/audio/modules/TrackMixerModuleProcessor.cpp
    Source/audio/modules/PolyVCOModuleProcessor.h
    Source/audio/modules/PolyVCOModuleProcessor.cpp
        Source/audio/modules/DebugModuleProcessor.h
        Source/audio/modules/DebugModuleProcessor.cpp
        Source/audio/modules/CommentModuleProcessor.h
        Source/audio/modules/CommentModuleProcessor.cpp
        Source/audio/modules/RerouteModuleProcessor.h
        Source/audio/modules/RerouteModuleProcessor.cpp
        Source/audio/modules/InputDebugModuleProcessor.h
        Source/audio/modules/InputDebugModuleProcessor.cpp
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/TimingData.h
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/FunctionGeneratorModuleProcessor.h
    Source/audio/modules/FunctionGeneratorModuleProcessor.cpp
    Source/audio/modules/BestPracticeNodeProcessor.h
    Source/audio/modules/BestPracticeNodeProcessor.cpp
    Source/audio/modules/TimelineModuleProcessor.h
    Source/audio/modules/TimelineModuleProcessor.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/modules/VstHostModuleProcessor.h
    Source/audio/modules/VstHostModuleProcessor.cpp
    Source/audio/modules/ShapingOscillatorModuleProcessor.h
    Source/audio/modules/ShapingOscillatorModuleProcessor.cpp
    Source/audio/modules/InletModuleProcessor.h
    Source/audio/modules/InletModuleProcessor.cpp
    Source/audio/modules/OutletModuleProcessor.h
    Source/audio/modules/OutletModuleProcessor.cpp
    Source/audio/modules/MetaModuleProcessor.h
    Source/audio/modules/MetaModuleProcessor.cpp
    Source/audio/modules/SnapshotSequencerModuleProcessor.h
    Source/audio/modules/SnapshotSequencerModuleProcessor.cpp
    Source/audio/modules/MIDICVModuleProcessor.h
    Source/audio/modules/MIDICVModuleProcessor.cpp
    Source/audio/modules/MIDIFadersModuleProcessor.h
    Source/audio/modules/MIDIFadersModuleProcessor.cpp
    Source/audio/modules/MIDIKnobsModuleProcessor.h
    Source/audio/modules/MIDIKnobsModuleProcessor.cpp
    Source/audio/modules/MIDIButtonsModuleProcessor.h
    Source/audio/modules/MIDIButtonsModuleProcessor.cpp
    Source/audio/modules/MIDIJogWheelModuleProcessor.h
    Source/audio/modules/MIDIJogWheelModuleProcessor.cpp
    Source/audio/modules/MIDIPadModuleProcessor.h
    Source/audio/modules/MIDIPadModuleProcessor.cpp
    Source/audio/modules/MidiLoggerModuleProcessor.h
    Source/audio/modules/MidiLoggerModuleProcessor.cpp
    Source/audio/modules/TempoClockModuleProcessor.h
    Source/audio/modules/TempoClockModuleProcessor.cpp
    Source/audio/modules/PhysicsModuleProcessor.h
    Source/audio/modules/PhysicsModuleProcessor.cpp
    Source/audio/modules/StrokeSequencerModuleProcessor.h
    Source/audio/modules/StrokeSequencerModuleProcessor.cpp
    Source/audio/modules/TapTempo.h
    Source/audio/modules/TapTempo.cpp
    Source/audio/modules/BPMMonitorModuleProcessor.h
    Source/audio/modules/BPMMonitorModuleProcessor.cpp
    Source/audio/modules/AnimationModuleProcessor.h
    Source/audio/modules/AnimationModuleProcessor.cpp
    Source/video/VideoFrameManager.h
    Source/video/CameraEnumerator.h
    Source/audio/modules/WebcamLoaderModule.h
    Source/audio/modules/WebcamLoaderModule.cpp
    Source/audio/modules/VideoFileLoaderModule.h
    Source/audio/modules/VideoFileLoaderModule.cpp
    Source/audio/modules/FFmpegAudioReader.h
    Source/audio/modules/FFmpegAudioReader.cpp
    Source/audio/modules/TimeStretcherAudioSource.h
    Source/audio/modules/TimeStretcherAudioSource.cpp
    Source/audio/modules/VideoFXModule.h
    Source/audio/modules/VideoFXModule.cpp
    Source/audio/modules/MovementDetectorModule.h
    Source/audio/modules/MovementDetectorModule.cpp
    Source/audio/modules/HumanDetectorModule.h
    Source/audio/modules/HumanDetectorModule.cpp
    Source/audio/modules/PoseEstimatorModule.h
    Source/audio/modules/PoseEstimatorModule.cpp
    Source/audio/modules/HandTrackerModule.h
    Source/audio/modules/HandTrackerModule.cpp
    Source/audio/modules/FaceTrackerModule.h
    Source/audio/modules/FaceTrackerModule.cpp
    Source/audio/modules/ObjectDetectorModule.h
    Source/audio/modules/ObjectDetectorModule.cpp
    Source/audio/modules/ColorTrackerModule.h
    Source/audio/modules/ColorTrackerModule.cpp
    Source/audio/modules/ContourDetectorModule.h
    Source/audio/modules/ContourDetectorModule.cpp
    Source/audio/modules/SemanticSegmentationModule.h
    Source/audio/modules/SemanticSegmentationModule.cpp
    Source/audio/modules/CropVideoModule.h
    Source/audio/modules/CropVideoModule.cpp
    Source/animation/AnimationData.h
    Source/animation/RawAnimationData.h
    Source/animation/RawAnimationData.cpp
    Source/animation/AnimationBinder.h
    Source/animation/AnimationBinder.cpp
    Source/animation/Animator.h
    Source/animation/Animator.cpp
    Source/animation/AnimationFileLoader.h
    Source/animation/AnimationFileLoader.cpp
    Source/animation/GltfLoader.h
    Source/animation/GltfLoader.cpp
    Source/animation/FbxLoader.h
    Source/animation/FbxLoader.cpp
    Source/animation/AnimationRenderer.h
    Source/animation/AnimationRenderer.cpp
    Source/ipc/IpcServer.cpp
    Source/ipc/IpcServer.h
    Source/ipc/OscClient.h
    Source/ipc/CommandBus.cpp
    Source/ipc/CommandBus.h
    Source/audio/utils/VoiceDeletionUtils.h
    Source/audio/dsp/TimePitchProcessor.h
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
)

target_compile_definitions(ColliderApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:ColliderApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:ColliderApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    JUCE_PLUGINHOST_VST3=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:WITH_CUDA_SUPPORT=1>
)

target_link_libraries(ColliderApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    juce::juce_osc
    soundtouch
    box2d
    glm::glm
    tinygltf
    ufbx_static
    ${OPENCV_LINK_LIBS}
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVFORMAT_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVCODEC_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVUTIL_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${SWRESAMPLE_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${SWSCALE_LIBRARY}>
    # Piper TTS libraries (pre-built)
    ${ONNXRUNTIME_DIR}/lib/onnxruntime.lib
)

# Link CUDA runtime for OpenCV CUDA symbols
# Use CUDAToolkit::cudart if available, otherwise link directly
if(TARGET CUDAToolkit::cudart)
    target_link_libraries(ColliderApp PRIVATE CUDAToolkit::cudart)
elseif(CUDA_CUDART_LIBRARY)
    target_link_libraries(ColliderApp PRIVATE ${CUDA_CUDART_LIBRARY})
endif()

# Link Windows libraries for native camera enumeration (DirectShow)
if(WIN32)
    target_link_libraries(ColliderApp PRIVATE ole32 strmiids)
endif()

# Add include directories for ColliderApp
target_include_directories(ColliderApp PRIVATE
    ${PIPER_DIR}
    ${ONNXRUNTIME_DIR}/include
    ${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64/samples/cpp/thirdparty/nlohmann_json/single_include
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    ${ufbx_SOURCE_DIR}
    $<$<BOOL:${FFMPEG_FOUND}>:${FFMPEG_INCLUDE_DIR}>
    # OpenCV include directories - source and generated headers
    ${opencv_SOURCE_DIR}/include
    ${opencv_SOURCE_DIR}/modules/core/include
    ${opencv_SOURCE_DIR}/modules/imgproc/include
    ${opencv_SOURCE_DIR}/modules/imgcodecs/include
    ${opencv_SOURCE_DIR}/modules/videoio/include
    ${opencv_SOURCE_DIR}/modules/highgui/include
    ${opencv_SOURCE_DIR}/modules/video/include
    ${opencv_SOURCE_DIR}/modules/objdetect/include
    ${opencv_SOURCE_DIR}/modules/features2d/include
    ${opencv_SOURCE_DIR}/modules/calib3d/include
    ${opencv_SOURCE_DIR}/modules/dnn/include              # For DNN headers (dnn.hpp)
    ${OPENCV_BUILD_DIR}
    ${OPENCV_BUILD_DIR}/modules/world
    # OpenCV CUDA modules (from opencv_contrib source)
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaimgproc/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudawarping/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaarithm/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafilters/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafeatures2d/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaobjdetect/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaoptflow/include>
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# ==============================================================================
# Preset Creator App Target (Final Corrected Version)
# ==============================================================================

juce_add_gui_app(PresetCreatorApp
    PRODUCT_NAME "Preset Creator"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(PresetCreatorApp PRIVATE
    # Your application sources
    Source/preset_creator/PresetCreatorMain.cpp
    Source/preset_creator/PinDatabase.h
    Source/preset_creator/PinDatabase.cpp
    Source/preset_creator/NotificationManager.h
    Source/preset_creator/NotificationManager.cpp
    Source/preset_creator/PresetValidator.h
    Source/preset_creator/PresetValidator.cpp
    Source/preset_creator/PresetAutoHealer.h
    Source/preset_creator/PresetAutoHealer.cpp
    Source/preset_creator/SavePresetJob.h
    Source/preset_creator/SavePresetJob.cpp
    Source/preset_creator/ShortcutManager.h
    Source/preset_creator/ShortcutManager.cpp
    Source/preset_creator/ImGuiNodeEditorComponent.h
    Source/preset_creator/ImGuiNodeEditorComponent.cpp
    Source/preset_creator/PresetCreatorComponent.h
    Source/preset_creator/PresetCreatorComponent.cpp
    Source/preset_creator/ControllerPresetManager.h
    Source/preset_creator/ControllerPresetManager.cpp
    
    # Theme system
    Source/preset_creator/theme/Theme.h
    Source/preset_creator/theme/ThemeManager.h
    Source/preset_creator/theme/ThemeManager.cpp
    Source/preset_creator/theme/ThemeEditorComponent.h
    Source/preset_creator/theme/ThemeEditorComponent.cpp

    # Add ImGui, imnodes, and the backend DIRECTLY as source files
    ${imgui_fc_SOURCE_DIR}/imgui.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_widgets.cpp
    ${imgui_fc_SOURCE_DIR}/backends/imgui_impl_opengl2.cpp
    ${imnodes_fc_SOURCE_DIR}/imnodes.cpp

    # Your other reused engine modules
    Source/audio/MidiDeviceManager.h
    Source/audio/MidiDeviceManager.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/ModuleProcessor.cpp
    Source/audio/modules/AudioInputModuleProcessor.h
    Source/audio/modules/AudioInputModuleProcessor.cpp
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/CVMixerModuleProcessor.h
    Source/audio/modules/CVMixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/ComparatorModuleProcessor.h
    Source/audio/modules/ComparatorModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/MultiBandShaperModuleProcessor.h
    Source/audio/modules/MultiBandShaperModuleProcessor.cpp
    Source/audio/modules/GranulatorModuleProcessor.h
    Source/audio/modules/GranulatorModuleProcessor.cpp
    Source/audio/modules/HarmonicShaperModuleProcessor.h
    Source/audio/modules/HarmonicShaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
        Source/audio/modules/DebugModuleProcessor.h
        Source/audio/modules/DebugModuleProcessor.cpp
        Source/audio/modules/CommentModuleProcessor.h
        Source/audio/modules/CommentModuleProcessor.cpp
        Source/audio/modules/InputDebugModuleProcessor.h
        Source/audio/modules/InputDebugModuleProcessor.cpp
    Source/audio/modules/TimePitchModuleProcessor.h
    Source/audio/modules/TimePitchModuleProcessor.cpp
    Source/audio/modules/MIDIPlayerModuleProcessor.h
    Source/audio/modules/MIDIPlayerModuleProcessor.cpp
        Source/audio/modules/TrackMixerModuleProcessor.h
        Source/audio/modules/TrackMixerModuleProcessor.cpp
    Source/audio/modules/PolyVCOModuleProcessor.h
    Source/audio/modules/PolyVCOModuleProcessor.cpp
    Source/audio/modules/RerouteModuleProcessor.h
    Source/audio/modules/RerouteModuleProcessor.cpp
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/TimingData.h
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/FunctionGeneratorModuleProcessor.h
    Source/audio/modules/FunctionGeneratorModuleProcessor.cpp
    Source/audio/modules/BestPracticeNodeProcessor.h
    Source/audio/modules/BestPracticeNodeProcessor.cpp
    Source/audio/modules/TimelineModuleProcessor.h
    Source/audio/modules/TimelineModuleProcessor.cpp
    Source/audio/modules/ShapingOscillatorModuleProcessor.h
    Source/audio/modules/ShapingOscillatorModuleProcessor.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/modules/VstHostModuleProcessor.h
    Source/audio/modules/VstHostModuleProcessor.cpp
    Source/audio/modules/MultiSequencerModuleProcessor.h
    Source/audio/modules/MultiSequencerModuleProcessor.cpp
    Source/audio/modules/LagProcessorModuleProcessor.h
    Source/audio/modules/LagProcessorModuleProcessor.cpp
    Source/audio/modules/DeCrackleModuleProcessor.h
    Source/audio/modules/DeCrackleModuleProcessor.cpp
    Source/audio/modules/GraphicEQModuleProcessor.h
    Source/audio/modules/GraphicEQModuleProcessor.cpp
    Source/audio/modules/FrequencyGraphModuleProcessor.h
    Source/audio/modules/FrequencyGraphModuleProcessor.cpp
    Source/audio/modules/ChorusModuleProcessor.h
    Source/audio/modules/ChorusModuleProcessor.cpp
    Source/audio/modules/PhaserModuleProcessor.h
    Source/audio/modules/PhaserModuleProcessor.cpp
    Source/audio/modules/CompressorModuleProcessor.h
    Source/audio/modules/CompressorModuleProcessor.cpp
    Source/audio/modules/RecordModuleProcessor.h
    Source/audio/modules/RecordModuleProcessor.cpp
    Source/audio/modules/CommentModuleProcessor.h
    Source/audio/modules/CommentModuleProcessor.cpp
    Source/audio/modules/LimiterModuleProcessor.h
    Source/audio/modules/LimiterModuleProcessor.cpp
    Source/audio/modules/GateModuleProcessor.h
    Source/audio/modules/GateModuleProcessor.cpp
    Source/audio/modules/DriveModuleProcessor.h
    Source/audio/modules/DriveModuleProcessor.cpp
    Source/audio/modules/InletModuleProcessor.h
    Source/audio/modules/InletModuleProcessor.cpp
    Source/audio/modules/OutletModuleProcessor.h
    Source/audio/modules/OutletModuleProcessor.cpp
    Source/audio/modules/MetaModuleProcessor.h
    Source/audio/modules/MetaModuleProcessor.cpp
    Source/audio/modules/SnapshotSequencerModuleProcessor.h
    Source/audio/modules/SnapshotSequencerModuleProcessor.cpp
    Source/audio/modules/MIDICVModuleProcessor.h
    Source/audio/modules/MIDICVModuleProcessor.cpp
    Source/audio/modules/MIDIFadersModuleProcessor.h
    Source/audio/modules/MIDIFadersModuleProcessor.cpp
    Source/audio/modules/MIDIKnobsModuleProcessor.h
    Source/audio/modules/MIDIKnobsModuleProcessor.cpp
    Source/audio/modules/MIDIButtonsModuleProcessor.h
    Source/audio/modules/MIDIButtonsModuleProcessor.cpp
    Source/audio/modules/MIDIJogWheelModuleProcessor.h
    Source/audio/modules/MIDIJogWheelModuleProcessor.cpp
    Source/audio/modules/MIDIPadModuleProcessor.h
    Source/audio/modules/MIDIPadModuleProcessor.cpp
    Source/audio/modules/MidiLoggerModuleProcessor.h
    Source/audio/modules/MidiLoggerModuleProcessor.cpp
    Source/audio/modules/TempoClockModuleProcessor.h
    Source/audio/modules/TempoClockModuleProcessor.cpp
    Source/audio/modules/PhysicsModuleProcessor.h
    Source/audio/modules/PhysicsModuleProcessor.cpp
    Source/audio/modules/StrokeSequencerModuleProcessor.h
    Source/audio/modules/StrokeSequencerModuleProcessor.cpp
    Source/audio/modules/TapTempo.h
    Source/audio/modules/TapTempo.cpp
    Source/audio/modules/BPMMonitorModuleProcessor.h
    Source/audio/modules/BPMMonitorModuleProcessor.cpp
    Source/audio/modules/AnimationModuleProcessor.h
    Source/audio/modules/AnimationModuleProcessor.cpp
    Source/video/VideoFrameManager.h
    Source/video/CameraEnumerator.h
    Source/audio/modules/WebcamLoaderModule.h
    Source/audio/modules/WebcamLoaderModule.cpp
    Source/audio/modules/VideoFileLoaderModule.h
    Source/audio/modules/VideoFileLoaderModule.cpp
    Source/audio/modules/FFmpegAudioReader.h
    Source/audio/modules/FFmpegAudioReader.cpp
    Source/audio/modules/TimeStretcherAudioSource.h
    Source/audio/modules/TimeStretcherAudioSource.cpp
    Source/audio/modules/VideoFXModule.h
    Source/audio/modules/VideoFXModule.cpp
    Source/audio/modules/MovementDetectorModule.h
    Source/audio/modules/MovementDetectorModule.cpp
    Source/audio/modules/HumanDetectorModule.h
    Source/audio/modules/HumanDetectorModule.cpp
    Source/audio/modules/PoseEstimatorModule.h
    Source/audio/modules/PoseEstimatorModule.cpp
    Source/audio/modules/HandTrackerModule.h
    Source/audio/modules/HandTrackerModule.cpp
    Source/audio/modules/FaceTrackerModule.h
    Source/audio/modules/FaceTrackerModule.cpp
    Source/audio/modules/ObjectDetectorModule.h
    Source/audio/modules/ObjectDetectorModule.cpp
    Source/audio/modules/ColorTrackerModule.h
    Source/audio/modules/ColorTrackerModule.cpp
    Source/audio/modules/ContourDetectorModule.h
    Source/audio/modules/ContourDetectorModule.cpp
    Source/audio/modules/SemanticSegmentationModule.h
    Source/audio/modules/SemanticSegmentationModule.cpp
    Source/audio/modules/CropVideoModule.h
    Source/audio/modules/CropVideoModule.cpp
    Source/animation/AnimationData.h
    Source/animation/RawAnimationData.h
    Source/animation/RawAnimationData.cpp
    Source/animation/AnimationBinder.h
    Source/animation/AnimationBinder.cpp
    Source/animation/Animator.h
    Source/animation/Animator.cpp
    Source/animation/AnimationFileLoader.h
    Source/animation/AnimationFileLoader.cpp
    Source/animation/GltfLoader.h
    Source/animation/GltfLoader.cpp
    Source/animation/FbxLoader.h
    Source/animation/FbxLoader.cpp
    Source/animation/AnimationRenderer.h
    Source/animation/AnimationRenderer.cpp
)

# This target now needs to know where to find all the headers
target_include_directories(PresetCreatorApp PRIVATE
    ${imgui_fc_SOURCE_DIR}
    ${imgui_fc_SOURCE_DIR}/backends
    ${imnodes_fc_SOURCE_DIR}
    ${imgui_juce_fc_SOURCE_DIR}
    ${PIPER_DIR}
    ${ONNXRUNTIME_DIR}/include
    ${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64/samples/cpp/thirdparty/nlohmann_json/single_include
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    ${ufbx_SOURCE_DIR}
    $<$<BOOL:${FFMPEG_FOUND}>:${FFMPEG_INCLUDE_DIR}>
    # OpenCV include directories - source and generated headers
    ${opencv_SOURCE_DIR}/include
    ${opencv_SOURCE_DIR}/modules/core/include
    ${opencv_SOURCE_DIR}/modules/imgproc/include
    ${opencv_SOURCE_DIR}/modules/imgcodecs/include
    ${opencv_SOURCE_DIR}/modules/videoio/include
    ${opencv_SOURCE_DIR}/modules/highgui/include
    ${opencv_SOURCE_DIR}/modules/video/include
    ${opencv_SOURCE_DIR}/modules/objdetect/include
    ${opencv_SOURCE_DIR}/modules/features2d/include
    ${opencv_SOURCE_DIR}/modules/calib3d/include
    ${opencv_SOURCE_DIR}/modules/dnn/include              # For DNN headers (dnn.hpp)
    ${OPENCV_BUILD_DIR}
    ${OPENCV_BUILD_DIR}/modules/world
    # OpenCV CUDA modules (from opencv_contrib source)
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaimgproc/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudawarping/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaarithm/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafilters/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafeatures2d/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaobjdetect/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaoptflow/include>
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# This target also needs the compile definitions
target_compile_definitions(PresetCreatorApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:PresetCreatorApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:PresetCreatorApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    JUCE_PLUGINHOST_VST3=1
    IMGUI_IMPL_JUCE_BEZEL=0
    IMGUI_ENABLE_VIEWPORTS
    IMGUI_DEFINE_MATH_OPERATORS
    IMNODES_NAMESPACE=ImNodes
    IMNODES_STATIC_DEFINE
    PRESET_CREATOR_UI=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:WITH_CUDA_SUPPORT=1>
)

target_link_libraries(PresetCreatorApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_devices
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    imgui_impl_juce
    soundtouch
    box2d
    glm::glm
    tinygltf
    ufbx_static
    ${OPENCV_LINK_LIBS}  # Uses ${OpenCV_LIBS} for pre-built (includes all deps) or opencv_world for source-built
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVFORMAT_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVCODEC_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVUTIL_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${SWRESAMPLE_LIBRARY}>
    # Piper TTS libraries (pre-built)
    ${ONNXRUNTIME_DIR}/lib/onnxruntime.lib
)

# Link CUDA runtime for OpenCV CUDA symbols
# Use CUDAToolkit::cudart if available, otherwise link directly
if(TARGET CUDAToolkit::cudart)
    target_link_libraries(PresetCreatorApp PRIVATE CUDAToolkit::cudart)
elseif(CUDA_CUDART_LIBRARY)
    target_link_libraries(PresetCreatorApp PRIVATE ${CUDA_CUDART_LIBRARY})
endif()

# Link Windows libraries for native camera enumeration (DirectShow)
if(WIN32)
    target_link_libraries(PresetCreatorApp PRIVATE ole32 strmiids)
endif()

# ==============================================================================
# FORCE EMBEDDED DEBUG INFO (/Z7) FOR ALL TARGETS TO FIX NINJA PDB LOCKING
# ==============================================================================
if(MSVC)
    target_compile_options(soundtouch PRIVATE "$<$<CONFIG:Debug>:/Z7>")
    target_compile_options(box2d PRIVATE "$<$<CONFIG:Debug>:/Z7>")
    target_compile_options(ufbx_static PRIVATE "$<$<CONFIG:Debug>:/Z7>")
    target_compile_options(rubberband_single PRIVATE "$<$<CONFIG:Debug>:/Z7>")
    target_compile_options(ColliderApp PRIVATE "$<$<CONFIG:Debug>:/Z7>")
    target_compile_options(PresetCreatorApp PRIVATE "$<$<CONFIG:Debug>:/Z7>")
endif()

# Add compile definition to signal zoom mode for app code if enabled
if(PRESET_CREATOR_IMNODES_ZOOM)
    target_compile_definitions(PresetCreatorApp PRIVATE IMNODES_ZOOM_ENABLED=1)
endif()

if(WIN32)
    # Copy Piper executable and DLLs to output directories
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper.exe"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper_phonemize.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/espeak-ng.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime_providers_shared.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        # Copy OpenCV FFmpeg video backend DLL (if it exists - optional video codec)
        # Path differs between pre-built and source-built OpenCV
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "$<IF:$<BOOL:${OPENCV_PREBUILT}>,${OPENCV_INSTALL_PREFIX}/bin/opencv_videoio_ffmpeg4130_64.dll,${CMAKE_BINARY_DIR}/_deps/opencv-build/bin/$<CONFIG>/opencv_videoio_ffmpeg4130_64.dll>"
                "$<TARGET_FILE_DIR:ColliderApp>"
        || ${CMAKE_COMMAND} -E echo "Note: OpenCV FFmpeg DLL not found (optional video codec)"
    )
    
    # Copy FFmpeg DLLs separately (if FFmpeg is found)
    # We need to copy each DLL individually to avoid generator expression issues
    if(FFMPEG_FOUND AND EXISTS "${FFMPEG_BIN_DIR}")
        file(GLOB FFMPEG_DLLS "${FFMPEG_BIN_DIR}/*.dll")
        if(FFMPEG_DLLS)
            foreach(DLL ${FFMPEG_DLLS})
                get_filename_component(DLL_NAME ${DLL} NAME)
                add_custom_command(
                    TARGET ColliderApp POST_BUILD
                    COMMAND ${CMAKE_COMMAND} -E copy_if_different
                            "${DLL}"
                            "$<TARGET_FILE_DIR:ColliderApp>"
                    COMMENT "Copying ${DLL_NAME} to ColliderApp"
                )
                add_custom_command(
                    TARGET PresetCreatorApp POST_BUILD
                    COMMAND ${CMAKE_COMMAND} -E copy_if_different
                            "${DLL}"
                            "$<TARGET_FILE_DIR:PresetCreatorApp>"
                    COMMENT "Copying ${DLL_NAME} to PresetCreatorApp"
                )
            endforeach()
        endif()
    endif()
    
    # Continue with other files for ColliderApp
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${PIPER_DIR}/espeak-ng-data"
                "$<TARGET_FILE_DIR:ColliderApp>/espeak-ng-data"
        COMMENT "Copying espeak-ng-data to ColliderApp output directory"
    )
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${opencv_SOURCE_DIR}/data/haarcascades/haarcascade_frontalface_default.xml"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMENT "Copying OpenCV data to ColliderApp output directory"
    )
    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper.exe"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper_phonemize.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/espeak-ng.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime_providers_shared.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        # Copy OpenCV FFmpeg video backend DLL (if it exists - optional video codec)
        # Path differs between pre-built and source-built OpenCV
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "$<IF:$<BOOL:${OPENCV_PREBUILT}>,${OPENCV_INSTALL_PREFIX}/bin/opencv_videoio_ffmpeg4130_64.dll,${CMAKE_BINARY_DIR}/_deps/opencv-build/bin/$<CONFIG>/opencv_videoio_ffmpeg4130_64.dll>"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        || ${CMAKE_COMMAND} -E echo "Note: OpenCV FFmpeg DLL not found (optional video codec)"
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${PIPER_DIR}/espeak-ng-data"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/espeak-ng-data"
        # NEW (Corrected): Copy the entire assets folder
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${CMAKE_SOURCE_DIR}/assets"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/assets"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${opencv_SOURCE_DIR}/data/haarcascades/haarcascade_frontalface_default.xml"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMENT "Copying Piper TTS, OpenPose, FFmpeg, and other runtime assets to PresetCreatorApp output directory"
    )

    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory
                "$<TARGET_FILE_DIR:PresetCreatorApp>/themes"
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${CMAKE_SOURCE_DIR}/Source/preset_creator/theme/presets"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/themes"
        COMMENT "Copying theme presets to PresetCreatorApp/themes"
    )

    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${CMAKE_SOURCE_DIR}/assets/fonts"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/fonts"
        COMMENT "Copying fonts to PresetCreatorApp/fonts"
    )

    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory
                "$<TARGET_FILE_DIR:ColliderApp>/themes"
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${CMAKE_SOURCE_DIR}/Source/preset_creator/theme/presets"
                "$<TARGET_FILE_DIR:ColliderApp>/themes"
        COMMENT "Copying theme presets to ColliderApp/themes"
    )
endif()

