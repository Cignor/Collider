
================================================================================
FILE: juce\Source\audio\modules\BPMMonitorModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "TapTempo.h"
#include <vector>
#include <array>

/**
 * BPM Monitor Node - Hybrid Smart System
 * 
 * This node automatically detects and reports BPM from rhythm-producing modules
 * using two complementary approaches:
 * 
 * 1. INTROSPECTION (Fast Path): Directly queries modules that implement getRhythmInfo()
 *    - Instant, accurate BPM reporting
 *    - Works with sequencers, animations, etc.
 * 
 * 2. BEAT DETECTION (Universal Fallback): Analyzes audio inputs for beat patterns
 *    - Tap tempo algorithm with rolling average
 *    - Works with any rhythmic signal (including external audio/VSTs)
 * 
 * The node dynamically generates output pins for each detected rhythm source:
 * - [Name] BPM (Raw) - Absolute BPM value
 * - [Name] CV - Normalized 0-1 for modulation
 * - [Name] Active/Confidence - Gate or confidence level
 * 
 * This node is always present (like the output node) and undeletable.
 */
class BPMMonitorModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_DETECTION_INPUTS = 16;  // Max beat detection inputs
    
    /**
     * Operation modes for the BPM Monitor
     */
    enum class OperationMode
    {
        Auto = 0,           // Use both introspection + beat detection
        IntrospectionOnly,  // Only scan modules with getRhythmInfo()
        DetectionOnly       // Only analyze audio inputs
    };
    
    BPMMonitorModuleProcessor();
    ~BPMMonitorModuleProcessor() override = default;

    // === JUCE AudioProcessor Interface ===
    const juce::String getName() const override { return "BPM Monitor"; }
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    // === Dynamic Pin Interface ===
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;
    std::vector<DynamicPinInfo> getDynamicInputPins() const override;
    
    // === Pin Labels ===
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
    
#if defined(PRESET_CREATOR_UI)
    // === UI Drawing ===
    void drawParametersInNode(float itemWidth, 
                             const std::function<bool(const juce::String&)>& isParamModulated,
                             const std::function<void()>& onModificationEnded) override;
#endif

private:
    // === Parameter Layout ===
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    double m_sampleRate = 44100.0;
    
    // === INTROSPECTION ENGINE ===
    
    /**
     * Cached information about a rhythm source discovered via introspection
     */
    struct IntrospectedSource {
        juce::String name;      // Display name (e.g., "Sequencer #3")
        juce::String type;      // Source type (e.g., "sequencer", "animation")
        float bpm;              // Current BPM
        bool isActive;          // Is currently running?
        bool isSynced;          // Synced to global transport?
    };
    
    std::vector<IntrospectedSource> m_introspectedSources;
    mutable juce::CriticalSection m_sourcesLock;  // Thread safety for dynamic pin queries
    
    /**
     * Scan the parent graph for modules with getRhythmInfo()
     * Updates m_introspectedSources
     */
    void scanGraphForRhythmSources();
    
    // === BEAT DETECTION ENGINE ===
    
    std::array<TapTempo, MAX_DETECTION_INPUTS> m_tapAnalyzers;
    std::vector<DetectedRhythmSource> m_detectedSources;
    
    /**
     * Process beat detection on all active input channels
     * Updates m_detectedSources
     */
    void processDetection(const juce::AudioBuffer<float>& buffer);
    
    // === OUTPUT MANAGEMENT ===
    
    /**
     * Normalize BPM to 0-1 range for CV output
     */
    float normalizeBPM(float bpm, float minBPM, float maxBPM) const;
    
    // === PERFORMANCE OPTIMIZATION ===
    
    int m_scanCounter { 0 };  // Counter to reduce graph scan frequency
};



================================================================================
FILE: juce\Source\audio\modules\BPMMonitorModuleProcessor.cpp
================================================================================


#include "BPMMonitorModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"

juce::AudioProcessorValueTreeState::ParameterLayout BPMMonitorModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    
    // Operation mode selector
    params.push_back(std::make_unique<juce::AudioParameterChoice>("mode", "Mode",
        juce::StringArray{"Auto", "Introspection Only", "Detection Only"}, 0));
    
    // BPM normalization range for CV outputs
    params.push_back(std::make_unique<juce::AudioParameterFloat>("minBPM", "Min BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 60.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("maxBPM", "Max BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 240.0f));
    
    // Beat detection settings
    params.push_back(std::make_unique<juce::AudioParameterFloat>("sensitivity", "Detection Sensitivity", 
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.01f), 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("detMinBPM", "Det Min BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 30.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("detMaxBPM", "Det Max BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 300.0f));
    
    // Number of active detection inputs (0-16)
    params.push_back(std::make_unique<juce::AudioParameterInt>("numInputs", "Num Detection Inputs", 
        0, MAX_DETECTION_INPUTS, 4));
    
    return { params.begin(), params.end() };
}

BPMMonitorModuleProcessor::BPMMonitorModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Detection Inputs", juce::AudioChannelSet::discreteChannels(MAX_DETECTION_INPUTS), true)
                        .withOutput("Outputs", juce::AudioChannelSet::discreteChannels(96), true)), // Max 32 sources * 3 outputs each
      apvts(*this, nullptr, "BPMMonitorParams", createParameterLayout())
{
    // Initialize output telemetry for tooltips
    for (int i = 0; i < 96; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

void BPMMonitorModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    m_sampleRate = sampleRate;
    
    // Reset all tap tempo analyzers
    for (auto& analyzer : m_tapAnalyzers)
        analyzer.reset();
    
    // Reset scan counter
    m_scanCounter = 0;
}

void BPMMonitorModuleProcessor::scanGraphForRhythmSources()
{
    const juce::ScopedLock lock(m_sourcesLock);
    m_introspectedSources.clear();
    
    // Get parent synth
    auto* synth = getParent();
    if (!synth)
        return;
    
    // Iterate through all modules in the graph
    auto modules = synth->getModulesInfo();
    for (const auto& [logicalId, moduleType] : modules)
    {
        // Skip ourselves
        if (logicalId == getLogicalId())
            continue;
        
        // Get the module processor
        auto* module = synth->getModuleForLogical(logicalId);
        if (!module)
            continue;
        
        // Query for rhythm info
        auto rhythmInfo = module->getRhythmInfo();
        if (rhythmInfo.has_value())
        {
            IntrospectedSource source;
            source.name = rhythmInfo->displayName;
            source.type = rhythmInfo->sourceType;
            source.bpm = rhythmInfo->bpm;
            source.isActive = rhythmInfo->isActive;
            source.isSynced = rhythmInfo->isSynced;
            m_introspectedSources.push_back(source);
        }
    }
}

void BPMMonitorModuleProcessor::processDetection(const juce::AudioBuffer<float>& buffer)
{
    const juce::ScopedLock lock(m_sourcesLock);
    m_detectedSources.clear();
    
    const int numInputs = apvts.getRawParameterValue("numInputs")->load();
    const float sensitivity = apvts.getRawParameterValue("sensitivity")->load();
    const float detMinBPM = apvts.getRawParameterValue("detMinBPM")->load();
    const float detMaxBPM = apvts.getRawParameterValue("detMaxBPM")->load();
    
    const int numSamples = buffer.getNumSamples();
    const int numChannels = buffer.getNumChannels();
    
    // Process each active detection input
    for (int ch = 0; ch < std::min(numInputs, MAX_DETECTION_INPUTS); ++ch)
    {
        if (ch >= numChannels)
            break;
        
        // Configure analyzer for this channel
        auto& analyzer = m_tapAnalyzers[ch];
        analyzer.setSensitivity(sensitivity);
        analyzer.setMinBPM(detMinBPM);
        analyzer.setMaxBPM(detMaxBPM);
        
        // Process all samples in this block
        const float* inputData = buffer.getReadPointer(ch);
        for (int i = 0; i < numSamples; ++i)
            analyzer.processSample(inputData[i], m_sampleRate);
        
        // If analyzer is active (stable detection), add to detected sources
        if (analyzer.isActive())
        {
            DetectedRhythmSource source;
            source.name = "Input " + juce::String(ch + 1) + " (Detected)";
            source.inputChannel = ch;
            source.detectedBPM = analyzer.getBPM();
            source.confidence = analyzer.getConfidence();
            source.isActive = true;
            m_detectedSources.push_back(source);
        }
    }
}

float BPMMonitorModuleProcessor::normalizeBPM(float bpm, float minBPM, float maxBPM) const
{
    return juce::jmap(bpm, minBPM, maxBPM, 0.0f, 1.0f);
}

void BPMMonitorModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Read parameters
    const int mode = apvts.getRawParameterValue("mode")->load();
    const float minBPM = apvts.getRawParameterValue("minBPM")->load();
    const float maxBPM = apvts.getRawParameterValue("maxBPM")->load();
    
    // === INTROSPECTION ENGINE ===
    // Scan graph periodically to reduce overhead (every 128 blocks ≈ 2.9ms at 44.1kHz)
    if (++m_scanCounter % 128 == 0)
    {
        if (mode == (int)OperationMode::Auto || mode == (int)OperationMode::IntrospectionOnly)
            scanGraphForRhythmSources();
        else
        {
            const juce::ScopedLock lock(m_sourcesLock);
            m_introspectedSources.clear();
        }
    }
    
    // === BEAT DETECTION ENGINE ===
    if (mode == (int)OperationMode::Auto || mode == (int)OperationMode::DetectionOnly)
        processDetection(buffer);
    else
    {
        const juce::ScopedLock lock(m_sourcesLock);
        m_detectedSources.clear();
    }
    
    // === OUTPUT GENERATION ===
    buffer.clear();
    
    int channelIndex = 0;
    const int numSamples = buffer.getNumSamples();
    
    // Copy sources for safe iteration
    std::vector<IntrospectedSource> introspected;
    std::vector<DetectedRhythmSource> detected;
    {
        const juce::ScopedLock lock(m_sourcesLock);
        introspected = m_introspectedSources;
        detected = m_detectedSources;
    }
    
    // Introspected sources first (fast, accurate)
    for (const auto& source : introspected)
    {
        if (channelIndex + 2 >= buffer.getNumChannels())
            break;
        
        // Channel 0: BPM Raw (absolute value)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.bpm, numSamples);
        
        // Channel 1: BPM CV (normalized 0-1)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         normalizeBPM(source.bpm, minBPM, maxBPM), numSamples);
        
        // Channel 2: Active gate (0.0 or 1.0)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.isActive ? 1.0f : 0.0f, numSamples);
    }
    
    // Detected sources next (universal fallback)
    for (const auto& source : detected)
    {
        if (channelIndex + 2 >= buffer.getNumChannels())
            break;
        
        // Channel 0: Detected BPM Raw
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.detectedBPM, numSamples);
        
        // Channel 1: Detected BPM CV (normalized)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         normalizeBPM(source.detectedBPM, minBPM, maxBPM), numSamples);
        
        // Channel 2: Confidence level (0-1)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.confidence, numSamples);
    }
    
    // Update output telemetry for tooltips
    updateOutputTelemetry(buffer);
}

std::vector<DynamicPinInfo> BPMMonitorModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    const juce::ScopedLock lock(m_sourcesLock);
    
    // Introspected sources
    for (const auto& source : m_introspectedSources)
    {
        const int baseChannel = (int)pins.size();
        pins.push_back({ source.name + " BPM", baseChannel, PinDataType::Raw });
        pins.push_back({ source.name + " CV", baseChannel + 1, PinDataType::CV });
        pins.push_back({ source.name + " Active", baseChannel + 2, PinDataType::Gate });
    }
    
    // Detected sources
    for (const auto& source : m_detectedSources)
    {
        const int baseChannel = (int)pins.size();
        pins.push_back({ source.name + " BPM", baseChannel, PinDataType::Raw });
        pins.push_back({ source.name + " CV", baseChannel + 1, PinDataType::CV });
        pins.push_back({ source.name + " Confidence", baseChannel + 2, PinDataType::CV });
    }
    
    return pins;
}

std::vector<DynamicPinInfo> BPMMonitorModuleProcessor::getDynamicInputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    const int numInputs = apvts.getRawParameterValue("numInputs")->load();
    for (int i = 0; i < numInputs; ++i)
    {
        pins.push_back({ "Detect In " + juce::String(i + 1), i, PinDataType::Gate });
    }
    
    return pins;
}

juce::String BPMMonitorModuleProcessor::getAudioInputLabel(int channel) const
{
    return "Detect In " + juce::String(channel + 1);
}

juce::String BPMMonitorModuleProcessor::getAudioOutputLabel(int channel) const
{
    // Outputs are dynamic - use getDynamicOutputPins() for proper names
    return "Out " + juce::String(channel + 1);
}

#if defined(PRESET_CREATOR_UI)
void BPMMonitorModuleProcessor::drawParametersInNode(float itemWidth, 
                                                      const std::function<bool(const juce::String&)>& isParamModulated,
                                                      const std::function<void()>& onModificationEnded)
{
    juce::ignoreUnused(isParamModulated);
    
    ImGui::PushItemWidth(itemWidth);
    
    ImGui::TextColored(ImVec4(0.3f, 0.8f, 1.0f, 1.0f), "BPM MONITOR");
    ImGui::Separator();
    
    // Mode selector
    int mode = apvts.getRawParameterValue("mode")->load();
    if (ImGui::Combo("Mode", &mode, "Auto\0Introspection Only\0Detection Only\0\0"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("mode")))
        {
            *p = mode;
            onModificationEnded();
        }
    }
    
    // BPM Normalization Range
    ImGui::Separator();
    ImGui::Text("CV Normalization Range:");
    
    float minBPM = apvts.getRawParameterValue("minBPM")->load();
    if (ImGui::SliderFloat("Min BPM", &minBPM, 20.0f, 300.0f, "%.0f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("minBPM")))
            *p = minBPM;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    
    float maxBPM = apvts.getRawParameterValue("maxBPM")->load();
    if (ImGui::SliderFloat("Max BPM", &maxBPM, 20.0f, 300.0f, "%.0f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("maxBPM")))
            *p = maxBPM;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    
    // Beat Detection Settings (only show if detection is enabled)
    if (mode == (int)OperationMode::Auto || mode == (int)OperationMode::DetectionOnly)
    {
        ImGui::Separator();
        ImGui::Text("Beat Detection Settings:");
        
        int numInputs = apvts.getRawParameterValue("numInputs")->load();
        if (ImGui::SliderInt("Detection Inputs", &numInputs, 0, MAX_DETECTION_INPUTS))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numInputs")))
                *p = numInputs;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        
        float sensitivity = apvts.getRawParameterValue("sensitivity")->load();
        if (ImGui::SliderFloat("Sensitivity", &sensitivity, 0.0f, 1.0f, "%.2f"))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("sensitivity")))
                *p = sensitivity;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        
        float detMinBPM = apvts.getRawParameterValue("detMinBPM")->load();
        if (ImGui::SliderFloat("Det Min BPM", &detMinBPM, 20.0f, 300.0f, "%.0f"))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("detMinBPM")))
                *p = detMinBPM;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        
        float detMaxBPM = apvts.getRawParameterValue("detMaxBPM")->load();
        if (ImGui::SliderFloat("Det Max BPM", &detMaxBPM, 20.0f, 300.0f, "%.0f"))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("detMaxBPM")))
                *p = detMaxBPM;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    }
    
    // Display detected rhythm sources
    ImGui::Separator();
    ImGui::Text("Detected Rhythm Sources:");
    
    {
        const juce::ScopedLock lock(m_sourcesLock);
        if (m_introspectedSources.empty() && m_detectedSources.empty())
        {
            ImGui::TextDisabled("  None");
        }
        else
        {
            // Introspected sources
            if (!m_introspectedSources.empty())
            {
                ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Introspected:");
                for (const auto& source : m_introspectedSources)
                {
                    ImGui::BulletText("%s: %.1f BPM %s", 
                                     source.name.toRawUTF8(), 
                                     source.bpm,
                                     source.isActive ? "[ACTIVE]" : "[STOPPED]");
                }
            }
            
            // Detected sources
            if (!m_detectedSources.empty())
            {
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.3f, 1.0f), "Detected:");
                for (const auto& source : m_detectedSources)
                {
                    ImGui::BulletText("%s: %.1f BPM (%.0f%% conf)", 
                                     source.name.toRawUTF8(), 
                                     source.detectedBPM,
                                     source.confidence * 100.0f);
                }
            }
        }
    }
    
    ImGui::PopItemWidth();
}
#endif



================================================================================
FILE: juce\Source\audio\modules\TapTempo.h
================================================================================


#pragma once

#include <juce_audio_basics/juce_audio_basics.h>
#include <array>

/**
 * Beat detection and BPM calculation from gate/trigger signals
 * 
 * Uses tap tempo algorithm with rolling average for stable BPM detection
 * Analyzes rising edges of input signals to measure time intervals between beats
 */
class TapTempo
{
public:
    TapTempo() = default;
    
    /**
     * Process a single sample
     * @param sample Input sample value (gate/trigger signal)
     * @param sampleRate Current audio sample rate
     * @return true if a beat was detected this sample
     */
    bool processSample(float sample, double sampleRate);
    
    /**
     * Get current detected BPM
     * @return BPM value, or 0.0 if no stable detection yet
     */
    float getBPM() const { return m_detectedBPM; }
    
    /**
     * Get confidence level (0-1, based on variance of intervals)
     * Higher confidence means more consistent timing between beats
     */
    float getConfidence() const { return m_confidence; }
    
    /**
     * Is actively detecting beats?
     * Returns true when enough beats have been detected with sufficient confidence
     */
    bool isActive() const { return m_isActive; }
    
    /**
     * Reset detection state (clears all tap history)
     */
    void reset();
    
    // === Configuration ===
    
    /**
     * Set detection threshold (0-1)
     * Rising edge detected when signal crosses from below to above this value
     */
    void setSensitivity(float threshold) { m_threshold = juce::jlimit(0.0f, 1.0f, threshold); }
    
    /**
     * Set minimum valid BPM (rejects intervals outside this range)
     */
    void setMinBPM(float minBPM) { m_minBPM = juce::jlimit(10.0f, 500.0f, minBPM); }
    
    /**
     * Set maximum valid BPM (rejects intervals outside this range)
     */
    void setMaxBPM(float maxBPM) { m_maxBPM = juce::jlimit(10.0f, 500.0f, maxBPM); }
    
private:
    static constexpr int MAX_TAPS = 8;              // Number of intervals to average
    static constexpr double TIMEOUT_SECONDS = 3.0;  // Reset if no beat for this long
    
    // Configuration
    float m_threshold = 0.5f;
    float m_minBPM = 30.0f;
    float m_maxBPM = 300.0f;
    
    // Edge detection state
    float m_lastSample = 0.0f;
    bool m_wasAboveThreshold = false;
    
    // Tap tempo buffer
    std::array<double, MAX_TAPS> m_tapIntervals{};
    int m_tapCount = 0;
    
    // Timing
    double m_lastTapTime = 0.0;
    double m_currentTime = 0.0;
    
    // Results
    float m_detectedBPM = 0.0f;
    float m_confidence = 0.0f;
    bool m_isActive = false;
    
    // Calculate BPM from current tap buffer
    void calculateBPM();
};



================================================================================
FILE: juce\Source\audio\modules\TapTempo.cpp
================================================================================


#include "TapTempo.h"
#include <numeric>
#include <algorithm>
#include <cmath>

bool TapTempo::processSample(float sample, double sampleRate)
{
    if (sampleRate <= 0.0)
        return false;
    
    // Increment current time
    m_currentTime += 1.0 / sampleRate;
    
    // Detect rising edge (transition from below threshold to above threshold)
    const bool isAboveThreshold = sample >= m_threshold;
    const bool risingEdge = isAboveThreshold && !m_wasAboveThreshold;
    m_wasAboveThreshold = isAboveThreshold;
    
    // Check for timeout (no beats detected recently - reset detection)
    if (m_currentTime - m_lastTapTime > TIMEOUT_SECONDS)
    {
        reset();
        return false;
    }
    
    // Process rising edge (beat detected)
    if (risingEdge)
    {
        const double interval = m_currentTime - m_lastTapTime;
        m_lastTapTime = m_currentTime;
        
        // Ignore first tap (no interval yet)
        if (m_tapCount == 0)
        {
            m_tapCount = 1;
            return true;
        }
        
        // Calculate instantaneous BPM from this interval
        const float instantBPM = static_cast<float>(60.0 / interval);
        
        // Reject intervals outside valid BPM range (noise filtering)
        if (instantBPM < m_minBPM || instantBPM > m_maxBPM)
            return false;
        
        // Add interval to rolling buffer
        if (m_tapCount < MAX_TAPS)
        {
            // Buffer not full yet - just append
            m_tapIntervals[m_tapCount - 1] = interval;
            m_tapCount++;
        }
        else
        {
            // Buffer full - shift left and add new interval at end
            std::shift_left(m_tapIntervals.begin(), m_tapIntervals.end(), 1);
            m_tapIntervals[MAX_TAPS - 1] = interval;
        }
        
        // Recalculate BPM with new data
        calculateBPM();
        return true;
    }
    
    return false;
}

void TapTempo::calculateBPM()
{
    // Need at least 2 taps to calculate BPM (1 interval)
    if (m_tapCount < 2)
    {
        m_detectedBPM = 0.0f;
        m_confidence = 0.0f;
        m_isActive = false;
        return;
    }
    
    // Calculate average interval
    const int validTaps = std::min(m_tapCount - 1, MAX_TAPS);
    const double avgInterval = std::accumulate(m_tapIntervals.begin(), 
                                               m_tapIntervals.begin() + validTaps, 
                                               0.0) / validTaps;
    
    // Calculate variance (for confidence metric)
    double variance = 0.0;
    for (int i = 0; i < validTaps; ++i)
    {
        const double diff = m_tapIntervals[i] - avgInterval;
        variance += diff * diff;
    }
    variance /= validTaps;
    
    // Convert average interval to BPM
    m_detectedBPM = static_cast<float>(60.0 / avgInterval);
    
    // Calculate confidence: high when variance is low (consistent timing)
    // Using coefficient of variation (standard deviation / mean)
    const double stdDev = std::sqrt(variance);
    const double coefficientOfVariation = stdDev / avgInterval;
    
    // Map to 0-1 range (lower variation = higher confidence)
    // CoV of 0.2 (20% variation) maps to ~0 confidence
    // CoV of 0.0 (perfect consistency) maps to 1.0 confidence
    m_confidence = juce::jlimit(0.0f, 1.0f, static_cast<float>(1.0 - coefficientOfVariation * 5.0));
    
    // Consider detection "active" when we have:
    // - At least 3 taps (2 intervals) for stability
    // - Confidence above 30% (reasonably consistent timing)
    m_isActive = (m_tapCount >= 3 && m_confidence > 0.3f);
}

void TapTempo::reset()
{
    m_tapCount = 0;
    m_lastTapTime = 0.0;
    m_currentTime = 0.0;
    m_detectedBPM = 0.0f;
    m_confidence = 0.0f;
    m_isActive = false;
    m_wasAboveThreshold = false;
    m_lastSample = 0.0f;
}



================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <functional> // Required for std::function
#include <vector>
#include <map>
#include <unordered_map>
#include <atomic>

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#include <cmath>
#endif

// <<< TRANSPORT STATE FOR GLOBAL CLOCK >>>
// Transport state struct shared by all modules
struct TransportState {
    bool isPlaying = false;
    double bpm = 120.0;
    double songPositionBeats = 0.0;
    double songPositionSeconds = 0.0;
    // Optional global division broadcast from a master tempo/clock (-1 means inactive)
    std::atomic<int> globalDivisionIndex { -1 };
    // Flag to indicate if a Tempo Clock module is controlling the BPM (for UI feedback)
    std::atomic<bool> isTempoControlledByModule { false };
    
    // Custom copy constructor (atomics are not copyable by default)
    TransportState() = default;
    TransportState(const TransportState& other)
        : isPlaying(other.isPlaying)
        , bpm(other.bpm)
        , songPositionBeats(other.songPositionBeats)
        , songPositionSeconds(other.songPositionSeconds)
        , globalDivisionIndex(other.globalDivisionIndex.load())
        , isTempoControlledByModule(other.isTempoControlledByModule.load())
    {}
    
    // Custom copy assignment operator
    TransportState& operator=(const TransportState& other)
    {
        if (this != &other)
        {
            isPlaying = other.isPlaying;
            bpm = other.bpm;
            songPositionBeats = other.songPositionBeats;
            songPositionSeconds = other.songPositionSeconds;
            globalDivisionIndex.store(other.globalDivisionIndex.load());
            isTempoControlledByModule.store(other.isTempoControlledByModule.load());
        }
        return *this;
    }
};

// === RHYTHM REPORTING SYSTEM ===
// Allows modules to report their rhythmic timing for the BPM Monitor node

/**
 * Rhythm information reported by modules that produce rhythmic patterns
 */
struct RhythmInfo
{
    juce::String displayName;    // e.g., "Sequencer #3", "Animation: Walk Cycle"
    float bpm;                    // Current BPM (can be modulated live value)
    bool isActive;                // Is this source currently producing rhythm?
    bool isSynced;                // Is it synced to global transport?
    juce::String sourceType;      // "sequencer", "animation", "physics", etc.
    
    RhythmInfo() : bpm(0.0f), isActive(false), isSynced(false) {}
    RhythmInfo(const juce::String& name, float bpmValue, bool active, bool synced, const juce::String& type = "")
        : displayName(name), bpm(bpmValue), isActive(active), isSynced(synced), sourceType(type) {}
};

/**
 * Beat detection source (from audio input analysis)
 * Used by the BPM Monitor's tap tempo engine
 */
struct DetectedRhythmSource
{
    juce::String name;            // e.g., "Input 1 (Detected)"
    int inputChannel;             // Which input is being analyzed
    float detectedBPM;            // Calculated BPM from beat detection
    float confidence;             // 0.0-1.0 (how stable is the detection)
    bool isActive;                // Currently detecting beats?
    
    DetectedRhythmSource() : inputChannel(-1), detectedBPM(0.0f), confidence(0.0f), isActive(false) {}
};

// <<< MULTI-MIDI DEVICE SUPPORT >>>
// MIDI message with device source information
// This struct allows modules to filter MIDI by device and channel
struct MidiMessageWithDevice {
    juce::MidiMessage message;
    juce::String deviceIdentifier;
    juce::String deviceName;
    int deviceIndex = -1;
};

// <<< ALL PIN-RELATED DEFINITIONS ARE NOW CENTRALIZED HERE >>>

// Defines the data type of a modulation or audio signal
enum class PinDataType { CV, Audio, Gate, Raw };

// Forward declare NodeWidth enum (defined in ImGuiNodeEditorComponent.h)
// This avoids circular dependency while allowing ModulePinInfo to store it
enum class NodeWidth;

// Describes a single audio/CV input or output pin
struct AudioPin
{
    juce::String name;
    int channel;
    PinDataType type;
    
    AudioPin(const juce::String& n, int ch, PinDataType t) : name(n), channel(ch), type(t) {}
};

// Renamed to avoid conflict with ImGuiNodeEditorComponent's PinInfo
struct DynamicPinInfo {
    juce::String name;
    int channel;
    PinDataType type;

    // Constructor to allow brace-initialization
    DynamicPinInfo(const juce::String& n, int c, PinDataType t) : name(n), channel(c), type(t) {}
};

// Describes a single modulation input pin targeting a parameter
struct ModPin
{
    juce::String name;
    juce::String paramId;
    PinDataType type;
    
    ModPin(const juce::String& n, const juce::String& p, PinDataType t) : name(n), paramId(p), type(t) {}
};

// A collection of all pins for a given module type
struct ModulePinInfo
{
    NodeWidth defaultWidth;  // Standardized node width category
    std::vector<AudioPin> audioIns;
    std::vector<AudioPin> audioOuts;
    std::vector<ModPin> modIns;
    
    ModulePinInfo() : defaultWidth(static_cast<NodeWidth>(0)) {}  // Default to Small (0)
    
    ModulePinInfo(NodeWidth width,
                  std::initializer_list<AudioPin> ins,
                  std::initializer_list<AudioPin> outs,
                  std::initializer_list<ModPin> mods)
        : defaultWidth(width), audioIns(ins), audioOuts(outs), modIns(mods) {}
};

// Forward declaration for NodePinHelpers
class ModuleProcessor;

// Helper struct passed to modules for drawing their pins
struct NodePinHelpers
{
    std::function<void(const char* label, int channel)> drawAudioInputPin;
    std::function<void(const char* label, int channel)> drawAudioOutputPin;
    std::function<void(const char* inLabel, int inChannel, const char* outLabel, int outChannel)> drawParallelPins;
    std::function<void(ModuleProcessor* module)> drawIoPins;
};

class ModularSynthProcessor; // forward declaration

/**
    An abstract base class for all modular synthesizer components.

    This class enforces a common interface for modules, ensuring they can be
    managed by the ModularSynthProcessor. The key requirement is providing access
    to the module's own parameter state via getAPVTS().
*/
class ModuleProcessor : public juce::AudioProcessor
{
public:
    ModuleProcessor(const BusesProperties& ioLayouts) : juce::AudioProcessor(ioLayouts) {}
    ~ModuleProcessor() override = default;

    // Parent container link (set by ModularSynthProcessor when node is created)
    void setParent(ModularSynthProcessor* parent) { parentSynth = parent; }
    ModularSynthProcessor* getParent() const { return parentSynth; }

    // Pure virtual method that all concrete modules MUST implement.
    // This is crucial for the parameter proxy system.
    virtual juce::AudioProcessorValueTreeState& getAPVTS() = 0;

    // Optional UI hook for drawing parameters inside nodes (used by Preset Creator)
    virtual void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
    {
        juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded);
    }

    // Optional UI hook for drawing IO pins inside nodes
    virtual void drawIoPins(const NodePinHelpers& /*helpers*/) {}

#if defined(PRESET_CREATOR_UI)
    // Optional UI hook for modules that need custom node dimensions (Exception size category)
    // Return ImVec2(width, height) for custom size, or ImVec2(0, 0) to use default from PinDatabase
    // Height of 0 means auto-size to content (recommended for most cases)
    virtual ImVec2 getCustomNodeSize() const 
    { 
        return ImVec2(0.0f, 0.0f); // Default: use PinDatabase size
    }
#endif


    // Get the current output value for a channel (for visualization)
    virtual float getOutputChannelValue(int channel) const
    {
        if (juce::isPositiveAndBelow(channel, (int)lastOutputValues.size()) && lastOutputValues[channel])
            return lastOutputValues[channel]->load();
        return 0.0f;
    }
    
    // Helper method to update output telemetry with peak magnitude
    // Call this at the end of processBlock to update visualization values
    void updateOutputTelemetry(const juce::AudioBuffer<float>& buffer)
    {
        const int numChannels = juce::jmin(buffer.getNumChannels(), (int)lastOutputValues.size());
        for (int ch = 0; ch < numChannels; ++ch)
        {
            if (lastOutputValues[ch])
            {
                // Use peak magnitude (max absolute value) for better visualization
                const float peak = buffer.getMagnitude(ch, 0, buffer.getNumSamples());
                lastOutputValues[ch]->store(peak, std::memory_order_relaxed);
            }
        }
    }

    // Standardized labels for module audio I/O channels (override per module if needed)
    virtual juce::String getAudioInputLabel(int channel) const
    {
        return juce::String("In ") + juce::String(channel + 1);
    }

    virtual juce::String getAudioOutputLabel(int channel) const
    {
        return juce::String("Out ") + juce::String(channel + 1);
    }

    // Stable logical ID assigned by ModularSynthProcessor upon node creation.
    void setLogicalId(juce::uint32 id) { storedLogicalId = id; }
    juce::uint32 getLogicalId() const { return storedLogicalId; }

    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get detailed connection information for debugging
    virtual juce::String getConnectionDiagnostics() const
    {
        juce::String result = "=== CONNECTION DIAGNOSTICS ===\n";
        
        // Bus layout info
        result += "Input Buses: " + juce::String(getBusCount(true)) + "\n";
        result += "Output Buses: " + juce::String(getBusCount(false)) + "\n";
        
        for (int bus = 0; bus < getBusCount(true); ++bus)
        {
            auto busName = getBus(true, bus)->getName();
            auto numChannels = getBus(true, bus)->getNumberOfChannels();
            result += "  Input Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        for (int bus = 0; bus < getBusCount(false); ++bus)
        {
            auto busName = getBus(false, bus)->getName();
            auto numChannels = getBus(false, bus)->getNumberOfChannels();
            result += "  Output Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        return result;
    }
    
    // Get parameter routing diagnostics
    virtual juce::String getParameterRoutingDiagnostics() const
    {
        juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
        
        // Note: This method is const, so we can't access getAPVTS() directly
        // We'll return a placeholder for now
        result += "Parameter routing diagnostics require non-const access.\n";
        result += "Use getModuleDiagnostics() from ModularSynthProcessor instead.\n";
        
        return result;
    }
    
    // Get live parameter values for debugging
    virtual juce::String getLiveParameterDiagnostics() const
    {
        juce::String result = "=== LIVE PARAMETER VALUES ===\n";
        
        for (const auto& pair : paramLiveValues)
        {
            result += "  " + pair.first + ": " + juce::String(pair.second.load(), 4) + "\n";
        }
        
        return result;
    }
    
    // Get comprehensive module diagnostics
    virtual juce::String getAllDiagnostics() const
    {
        juce::String result = "=== MODULE DIAGNOSTICS ===\n";
        result += "Module Type: " + getName() + "\n\n";
        result += getConnectionDiagnostics() + "\n";
        result += getParameterRoutingDiagnostics() + "\n";
        result += getLiveParameterDiagnostics();
        return result;
    }


    /**
        Resolves a parameter's string ID to its modulation bus and channel.

        This is a virtual function that each module must override to declare which of its
        parameters can be modulated by an external signal. The function maps parameter IDs
        to their corresponding input bus and channel indices within that bus.

        @param paramId              The string ID of the parameter to query (e.g., "cutoff", "frequency").
        @param outBusIndex          Receives the index of the input bus used for modulation.
        @param outChannelIndexInBus Receives the channel index within that bus.
        @returns                    True if the parameter supports modulation, false otherwise.
        
        @see isParamInputConnected
    */
    virtual bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const;

    /**
        Checks if a parameter's modulation input is connected in the synth graph.

        This is the single, reliable method for a module's audio thread to determine
        if it should use an incoming CV signal instead of its internal parameter value.
        The function internally uses getParamRouting() to resolve the parameter to its
        bus/channel location, then queries the parent synth's connection graph.

        @param paramId The string ID of the parameter to check (e.g., "cutoff", "frequency").
        @returns       True if a cable is connected to this parameter's modulation input.
        
        @see getParamRouting
    */
    bool isParamInputConnected(const juce::String& paramId) const;

    // --- Live telemetry for UI (thread-safe, lock-free) ---
    void setLiveParamValue(const juce::String& paramId, float value)
    {
        auto result = paramLiveValues.try_emplace(paramId, value);
        if (!result.second)
            result.first->second.store(value, std::memory_order_relaxed);
    }

    float getLiveParamValue(const juce::String& paramId, float fallback) const
    {
        // FIX: Only return the "live" (modulated) value if the corresponding
        // modulation input is actually connected. Otherwise, always return the
        // fallback, which is the base parameter's real value.
        if (isParamInputConnected(paramId))
        {
            if (auto it = paramLiveValues.find(paramId); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // New helper: decouple the connectivity check (modParamId) from the live value key (liveKey).
    // This allows UI code to ask "is X_mod connected?" while reading the corresponding
    // live telemetry stored under a different key like "X_live".
    float getLiveParamValueFor(const juce::String& modParamId,
                               const juce::String& liveKey,
                               float fallback) const
    {
        if (isParamInputConnected(modParamId))
        {
            if (auto it = paramLiveValues.find(liveKey); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // Optional extra state hooks for modules that need to persist non-parameter data
    // Default: return invalid tree / ignore.
    virtual juce::ValueTree getExtraStateTree() const { return {}; }
    virtual void setExtraStateTree(const juce::ValueTree&) {}
    
    // Optional timing info hook for modules that need global clock/transport
    // Default: ignore (modules that don't need timing can skip implementing this)
    virtual void setTimingInfo(const TransportState& state) { juce::ignoreUnused(state); }
    
    // Optional rhythm reporting hook for BPM Monitor node
    // Modules that produce rhythmic patterns can implement this to report their BPM
    // Default: return empty (module doesn't produce rhythm)
    virtual std::optional<RhythmInfo> getRhythmInfo() const { return std::nullopt; }
    
    // Optional dynamic pin interface for modules with variable I/O (e.g., polyphonic modules)
    // Default: return empty vector (no dynamic pins)
    virtual std::vector<DynamicPinInfo> getDynamicInputPins() const { return {}; }
    virtual std::vector<DynamicPinInfo> getDynamicOutputPins() const { return {}; }
    
    /**
        Device-aware MIDI processing (MULTI-MIDI CONTROLLER SUPPORT)
        
        This method is called by ModularSynthProcessor BEFORE the standard graph processing
        begins. It provides MIDI modules with device-aware MIDI messages that include the
        source device information (name, identifier, index).
        
        MIDI modules should override this method to:
        - Filter messages by device (e.g., only respond to a specific controller)
        - Filter messages by MIDI channel
        - Update internal state based on filtered MIDI input
        
        The regular processBlock() can then use this updated state to generate CV outputs.
        
        @param midiMessages A vector of MIDI messages with device source information
        
        Default implementation: Does nothing (opt-in for MIDI modules only)
        
        @see MidiMessageWithDevice
    */
    virtual void handleDeviceSpecificMidi(const std::vector<MidiMessageWithDevice>& midiMessages)
    {
        juce::ignoreUnused(midiMessages);
        // Default: do nothing. MIDI-aware modules will override this method.
    }

public:
    // OPTION 9: Make public for TTS debugging
    // Live, modulated parameter values for UI feedback
    std::unordered_map<juce::String, std::atomic<float>> paramLiveValues;

protected:
    // Thread-safe storage for last known output values (for tooltips)
    std::vector<std::unique_ptr<std::atomic<float>>> lastOutputValues;

#if defined(PRESET_CREATOR_UI)

    static void adjustParamOnWheel (juce::RangedAudioParameter* parameter,
                                    const juce::String& idOrName,
                                    float displayedValue)
    {
        if (parameter == nullptr) return;
        if (! ImGui::IsItemHovered()) return;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel == 0.0f) return;

        if (auto* pf = dynamic_cast<juce::AudioParameterFloat*>(parameter))
        {
            // No right-click editing here; modules can add InputFloat next to sliders

            const auto& range = pf->range;
            const float span = range.end - range.start;
            const juce::String id = idOrName.toLowerCase();

            float step = span / 200.0f; // default ~0.5% of range
            if (span <= 1.0f) step = 0.01f;
            // Custom: fine tune for sequencer steps
            if (id.contains ("step"))
            {
                step = 0.05f;
            }
            if (id.contains ("hz") || id.contains ("freq") || id.contains ("cutoff") || id.contains ("rate"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (1.0f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("ms") || id.contains ("time"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (0.1f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("db") || id.contains ("gain"))
            {
                step = 0.5f;
            }
            else if (id.contains ("mix") || id.contains ("depth") || id.contains ("amount") || id.contains ("resonance") || id.contains ("q") || id.contains ("size") || id.contains ("damp") || id.contains ("pan") || id.contains ("threshold"))
            {
                step = 0.01f;
            }

            float newVal = pf->get() + (wheel > 0 ? step : -step);
            newVal = juce::jlimit (range.start, range.end, newVal);
            *pf = newVal;
        }
        else if (auto* pc = dynamic_cast<juce::AudioParameterChoice*>(parameter))
        {
            int idx = pc->getIndex();
            idx += (ImGui::GetIO().MouseWheel > 0 ? 1 : -1);
            idx = juce::jlimit (0, pc->choices.size() - 1, idx);
            *pc = idx;
        }
        else if (auto* pi = dynamic_cast<juce::AudioParameterInt*>(parameter))
        {
            int currentVal = pi->get();
            int newVal = currentVal + (wheel > 0 ? 1 : -1);
            const auto& range = pi->getNormalisableRange();
            newVal = juce::jlimit((int)range.start, (int)range.end, newVal);
            *pi = newVal;
        }
        else if (auto* pb = dynamic_cast<juce::AudioParameterBool*>(parameter))
        {
            // Optional: toggle on strong scroll
            juce::ignoreUnused (pb);
        }
    }

#endif

public:
    //==============================================================================
    // Helper function to convert bus index and channel-in-bus to absolute channel index
    //==============================================================================
    int getChannelIndexInProcessBlockBuffer(bool isInput, int busIndex, int channelIndexInBus) const
    {
        int absoluteChannel = channelIndexInBus;
        if (busIndex > 0)
        {
            int sum = 0;
            const int numBuses = getBusCount(isInput);
            for (int b = 0; b < numBuses && b < busIndex; ++b)
                sum += getChannelCountOfBus(isInput, b);
            absoluteChannel = sum + channelIndexInBus;
        }
        return absoluteChannel;
    }

    //==============================================================================
    // Provide default implementations for the pure virtuals to reduce boilerplate
    // in concrete module classes.
    //==============================================================================
    const juce::String getName() const override { return "Module"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModuleProcessor)

protected:
    ModularSynthProcessor* parentSynth { nullptr };
    juce::uint32 storedLogicalId { 0 };
};

================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class StepSequencerModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_STEPS = 16;
    StepSequencerModuleProcessor();
    ~StepSequencerModuleProcessor() override = default;

    const juce::String getName() const override { return "sequencer"; }

    void prepareToPlay (double newSampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // State management for transport settings
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree&) override;

    // Pin label overrides
    juce::String getAudioOutputLabel(int channel) const override;
    juce::String getAudioInputLabel(int channel) const override;
    
    // Parameter bus contract implementation
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    
    // Rhythm reporting for BPM Monitor
    std::optional<RhythmInfo> getRhythmInfo() const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    void setTimingInfo(const TransportState& state) override;

    juce::AudioProcessorValueTreeState apvts;

    std::atomic<int> currentStep { 0 };
    double phase { 0.0 };
    double sampleRate { 44100.0 };

    TransportState m_currentTransport;
    bool wasPlaying = false;

    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* gateLengthParam { nullptr };
    std::atomic<float>* gateThresholdParam { nullptr };
    std::atomic<float>* rateModParam { nullptr };
    std::atomic<float>* gateLengthModParam { nullptr };
    std::atomic<float>* numStepsModParam { nullptr };
    std::atomic<float>* stepsModMaxParam { nullptr };
    std::vector<std::atomic<float>*> pitchParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepModParams; // size MAX_STEPS
    // Per-step trigger base (checkbox) and modulation
    std::vector<juce::AudioParameterBool*> stepTrigParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepTrigModParams;    // size MAX_STEPS (0..1)
    // Per-step gate level parameters
    std::vector<std::atomic<float>*> stepGateParams;       // size MAX_STEPS (0..1)
    std::atomic<float>* numStepsParam { nullptr };

    // Pulse generator state for Trigger Out
    int pendingTriggerSamples { 0 };
    
    // Gate fade-in state
    bool previousGateOn { false };
    float gateFadeProgress { 0.0f };
    static constexpr float GATE_FADE_TIME_MS = 5.0f; // 5ms fade-in time
};

// Pin label overrides
inline juce::String StepSequencerModuleProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Pitch";
        case 1: return "Gate";
        case 2: return "Gate Nuanced";
        case 3: return "Velocity";
        case 4: return "Mod";
        case 5: return "Trigger";
        default: return juce::String("Out ") + juce::String(channel + 1);
    }
}

inline juce::String StepSequencerModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Mod In L";
        case 1: return "Mod In R";
        case 2: return "Rate Mod";
        case 3: return "Gate Mod";
        case 4: return "Steps Mod";
        default: return juce::String("In ") + juce::String(channel + 1);
    }
}




================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.cpp
================================================================================


#include "StepSequencerModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <iostream>
#include <array>

using APVTS = juce::AudioProcessorValueTreeState;

static juce::NormalisableRange<float> makeRateRange()
{
    // FIX: Change the interval from 0.0f to a small, non-zero value like 0.01f.
    juce::NormalisableRange<float> r (0.1f, 20.0f, 0.01f, 0.5f); // semi-log response
    return r;
}

APVTS::ParameterLayout StepSequencerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps", "Number of Steps", 1, StepSequencerModuleProcessor::MAX_STEPS, 8));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate", "Rate", makeRateRange(), 2.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength", "Gate Length", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    // Threshold to generate gate when step value >= threshold
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateThreshold", "Gate Threshold", juce::NormalisableRange<float> (0.0f, 1.0f, 0.001f), 0.5f));
    
    // Add modulation parameters for rate, gate length and number of steps (absolute 0..1)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate_mod", "Rate Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength_mod", "Gate Length Mod", 0.0f, 1.0f, 0.5f));
    // Neutral default at 0.5 means "no override" (we'll treat values ~0.5 as disconnected)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("numSteps_mod", "Num Steps Mod", 0.0f, 1.0f, 0.5f));
    // Optional maximum steps bound (1..MAX_STEPS), default MAX_STEPS
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps_max", "Num Steps Max", 1, StepSequencerModuleProcessor::MAX_STEPS, StepSequencerModuleProcessor::MAX_STEPS));
    
    // Transport sync parameters
    params.push_back(std::make_unique<juce::AudioParameterBool>("sync", "Sync to Transport", false));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("rate_division", "Division", 
        juce::StringArray{ "1/32", "1/16", "1/8", "1/4", "1/2", "1", "2", "4", "8" }, 3)); // Default: 1/4 note
    
    for (int i = 0; i < StepSequencerModuleProcessor::MAX_STEPS; ++i)
    {
        const juce::String pid = "step" + juce::String (i + 1);
        params.push_back (std::make_unique<juce::AudioParameterFloat> (pid, pid, juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));

        // ADD THIS: A new parameter for this step's modulation input
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        // Default 0.5 => no offset (unipolar 0..1 centered to bipolar -0.5..+0.5)
        params.push_back(std::make_unique<juce::AudioParameterFloat>(modPid, modPid, 0.0f, 1.0f, 0.5f));

        // NEW: per-step Trigger checkbox and its modulation (absolute 0..1)
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        params.push_back(std::make_unique<juce::AudioParameterBool>(trigPid, trigPid, false));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(trigModPid, trigModPid, 0.0f, 1.0f, 0.5f));

        // NEW: per-step Gate Level parameters
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gatePid, gatePid, 0.0f, 1.0f, 0.8f));
        const juce::String gateModPid = "step" + juce::String(i + 1) + "_gate_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gateModPid, gateModPid, 0.0f, 1.0f, 0.5f));
    }
    return { params.begin(), params.end() };
}

StepSequencerModuleProcessor::StepSequencerModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        // ARCHITECTURAL FIX: Single large bus for all inputs:
                        // 2 (Audio) + 4 (Global Mods: rate, gate, steps, stepsMax) + 16 (Step Mods) + 16 (Trig Mods) + 16 (Gate Mods) = 54 channels
                        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(2 + 4 + (MAX_STEPS * 3)), true)
                        // expand to 5 outputs (Pitch, Gate, Velocity, Mod, Trigger)
                        .withOutput ("CV Outputs", juce::AudioChannelSet::discreteChannels(6), true))
    , apvts (*this, nullptr, "SeqParams", createParameterLayout())
{
    // ADD THIS VERIFICATION LOGIC
    std::cout << "--- StepSequencerModuleProcessor Initializing ---" << std::endl;
    
    numStepsParam   = apvts.getRawParameterValue ("numSteps");
    rateParam       = apvts.getRawParameterValue ("rate");
    gateLengthParam = apvts.getRawParameterValue ("gateLength");
    gateThresholdParam = apvts.getRawParameterValue ("gateThreshold");
    rateModParam    = apvts.getRawParameterValue ("rate_mod");
    gateLengthModParam = apvts.getRawParameterValue ("gateLength_mod");
    numStepsModParam = apvts.getRawParameterValue ("numSteps_mod");
    stepsModMaxParam = apvts.getRawParameterValue ("numSteps_max");
    
    if (numStepsParam == nullptr) std::cout << "ERROR: 'numSteps' parameter is NULL!" << std::endl;
    if (rateParam == nullptr) std::cout << "ERROR: 'rate' parameter is NULL!" << std::endl;
    if (gateLengthParam == nullptr) std::cout << "ERROR: 'gateLength' parameter is NULL!" << std::endl;

    pitchParams.resize (MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        pitchParams[i] = apvts.getRawParameterValue ("step" + juce::String (i + 1));
        if (pitchParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "' parameter is NULL!" << std::endl;
        }
    }

    // Initialize stepModParams
    stepModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        stepModParams[i] = apvts.getRawParameterValue(modPid);
        if (stepModParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "_mod' parameter is NULL!" << std::endl;
        }
    }
    std::cout << "--- Initialization Check Complete ---" << std::endl;
    
    // Initialize output value tracking for tooltips (6 outputs: Pitch, Gate, Gate Nuanced, Velocity, Mod, Trigger)
    for (int i = 0; i < 6; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));

    // Cache pointers for per-step trigger params
    stepTrigParams.resize(MAX_STEPS);
    stepTrigModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        stepTrigParams[i] = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(trigPid));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        stepTrigModParams[i] = apvts.getRawParameterValue(trigModPid);
    }

    // Initialize gate parameter pointers
    stepGateParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        stepGateParams[i] = apvts.getRawParameterValue(gatePid);
    }
}

void StepSequencerModuleProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sampleRate = newSampleRate > 0.0 ? newSampleRate : 44100.0;
    phase = 0.0;
}

void StepSequencerModuleProcessor::setTimingInfo(const TransportState& state)
{
    // Check if the transport has just started playing
    if (state.isPlaying && !wasPlaying)
    {
        // Reset to the beginning when play is pressed
        currentStep.store(0);
        phase = 0.0;
    }
    wasPlaying = state.isPlaying;
    
    m_currentTransport = state;
}

juce::ValueTree StepSequencerModuleProcessor::getExtraStateTree() const
{
    juce::ValueTree vt("SequencerState");
    vt.setProperty("sync", apvts.getRawParameterValue("sync")->load(), nullptr);
    vt.setProperty("rate_division", apvts.getRawParameterValue("rate_division")->load(), nullptr);
    return vt;
}

void StepSequencerModuleProcessor::setExtraStateTree(const juce::ValueTree& vt)
{
    if (vt.hasType("SequencerState"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync")))
            *p = (bool)vt.getProperty("sync", false);
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division")))
            *p = (int)vt.getProperty("rate_division", 3);
    }
}

void StepSequencerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    if (rateParam == nullptr || numStepsParam == nullptr || gateLengthParam == nullptr)
    {
        buffer.clear();
        return;
    }

    const int numSamples = buffer.getNumSamples();
    
    // ARCHITECTURAL FIX: Read CV from single input bus
    const auto& inputBus = getBusBuffer(buffer, true, 0); // All inputs are now on bus 0
    
    // Get pointers to global modulation CV inputs, if they are connected
    const bool isRateMod = isParamInputConnected("rate_mod");
    const bool isGateLenMod = isParamInputConnected("gateLength_mod");
    const bool isStepsMod = isParamInputConnected("numSteps_mod");
    
    // Absolute channel map on single input bus:
    // 0=L,1=R, 2=rate, 3=gateLen, 4=steps, 5=stepsMax,
    // 6..21: step1..step16 value mods, 22..37: step1..step16 trig mods, 38..53: step1..step16 gate mods
    const float* rateCV = isRateMod && inputBus.getNumChannels() > 2 ? inputBus.getReadPointer(2) : nullptr;
    const float* gateLenCV = isGateLenMod && inputBus.getNumChannels() > 3 ? inputBus.getReadPointer(3) : nullptr;
    const float* stepsCV = isStepsMod && inputBus.getNumChannels() > 4 ? inputBus.getReadPointer(4) : nullptr;
    
    // Get write pointers for all 6 output channels
    auto* pitchOut       = buffer.getWritePointer(0);
    auto* gateOut        = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : nullptr;
    auto* gateNuancedOut = buffer.getNumChannels() > 2 ? buffer.getWritePointer(2) : nullptr;
    auto* velocityOut    = buffer.getNumChannels() > 3 ? buffer.getWritePointer(3) : nullptr;
    auto* modOut         = buffer.getNumChannels() > 4 ? buffer.getWritePointer(4) : nullptr;
    auto* trigOut        = buffer.getNumChannels() > 5 ? buffer.getWritePointer(5) : nullptr;
    
    // The old, commented-out input logic can now be completely removed.
    
    // Get base parameter values ONCE
    const float baseRate = rateParam->load();
    const float baseGate = gateLengthParam != nullptr ? gateLengthParam->load() : 0.5f;
    const int baseSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMax = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const float gateThreshold = gateThresholdParam != nullptr ? juce::jlimit(0.0f, 1.0f, gateThresholdParam->load()) : 0.5f;
    

    // --- UI Telemetry Bootstrap ---
    // Publish per-step live values for ALL steps this block (use first-sample snapshot)
    {
        const int totalCh = inputBus.getNumChannels();
        for (int si = 0; si < MAX_STEPS; ++si)
        {
            // Absolute channel for per-step value mod: 6..21
            const int ch = 6 + si;
            const bool hasCh = totalCh > ch;
            const float base = (pitchParams.size() > (size_t) si && pitchParams[si] != nullptr) ? pitchParams[si]->load() : 0.0f;
            float live = base;
            if (hasCh)
            {
                const float cv0 = inputBus.getReadPointer(ch)[0];
                live = juce::jlimit(0.0f, 1.0f, base + (cv0 - 0.5f));
            }
            setLiveParamValue("step_live_" + juce::String(si + 1), live);

            // Per-step gate live values: channels 38..53
            const int gateCh = 38 + si;
            const bool hasGateCh = totalCh > gateCh;
            const float baseGate = (stepGateParams.size() > (size_t) si && stepGateParams[si] != nullptr) ? stepGateParams[si]->load() : 0.8f;
            float liveGate = baseGate;
            if (hasGateCh)
            {
                const float cv0 = inputBus.getReadPointer(gateCh)[0];
                liveGate = juce::jlimit(0.0f, 1.0f, baseGate + (cv0 - 0.5f));
            }
            setLiveParamValue("gate_live_" + juce::String(si + 1), liveGate);

            // Per-step trigger live values: channels 22..37
            const int trigCh = 22 + si;
            const bool hasTrigCh = totalCh > trigCh;
            const bool baseTrig = (stepTrigParams.size() > (size_t) si && stepTrigParams[si] != nullptr) ? (bool)(*stepTrigParams[si]) : false;
            bool liveTrig = baseTrig;
            if (hasTrigCh)
            {
                const float cv0 = inputBus.getReadPointer(trigCh)[0];
                liveTrig = cv0 > 0.5f;
            }
            setLiveParamValue("trig_live_" + juce::String(si + 1), liveTrig ? 1.0f : 0.0f);
        }
    }

    bool stepAdvanced = false;
    float lastRateLive = baseRate;
    float lastGateLive = baseGate;
    float lastGateThresholdLive = gateThreshold;
    int   lastStepsLive = baseSteps;
    for (int i = 0; i < numSamples; ++i)
    {
        // PER-SAMPLE FIX: Calculate global modulation parameters FOR THIS SAMPLE
        int activeSteps = baseSteps;
        if (isStepsMod && stepsCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, stepsCV[i]);
            // CV adds/subtracts steps around base (±8 steps)
            const int offset = (int)std::round((cv - 0.5f) * 16.0f);
            activeSteps = baseSteps + offset;
            activeSteps = juce::jlimit(1, boundMax, activeSteps);
        }
        // FIX: clamp playhead immediately when steps shrink
        if (currentStep.load() >= activeSteps)
            currentStep.store(0);
        
        float rate = baseRate;
        if (isRateMod && rateCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, rateCV[i]);
            // CV modulates ±2 octaves (0.25x to 4x)
            const float octaveOffset = (cv - 0.5f) * 4.0f;
            rate = baseRate * std::pow(2.0f, octaveOffset);
            rate = juce::jlimit(0.1f, 20.0f, rate);
        }
        lastRateLive = rate;
        
        float gateLen = baseGate;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            // CV adds offset to base gate length (±0.5)
            const float offset = (cv - 0.5f) * 1.0f;
            gateLen = baseGate + offset;
            gateLen = juce::jlimit(0.0f, 1.0f, gateLen);
        }
        lastGateLive = gateLen;
        
        // Use gateLenCV for gate threshold modulation (reusing the existing "Gate Mod" input)
        float gateThreshold = gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            gateThreshold = juce::jlimit(0.0f, 1.0f, cv);
        }
        lastGateThresholdLive = gateThreshold;
        
        // --- Transport Sync Logic ---
        const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;

        if (syncEnabled && m_currentTransport.isPlaying)
        {
            // SYNC MODE: Use the global beat position
            int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
            // Use global division if a Tempo Clock has override enabled
            // IMPORTANT: Read from parent's LIVE transport state, not cached copy (which is stale)
            if (getParent())
            {
                int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
                if (globalDiv >= 0)
                    divisionIndex = globalDiv;
            }
            static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
            const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
            
            // Calculate which step we should be on based on song position
            const int totalSteps = juce::jlimit(1, MAX_STEPS, activeSteps);
            const int stepForBeat = static_cast<int>(std::fmod(m_currentTransport.songPositionBeats * beatDivision, totalSteps));

            if (stepForBeat != currentStep.load())
            {
                currentStep.store(stepForBeat);
                stepAdvanced = true;
            }
        }
        else
        {
            // FREE-RUNNING MODE: Use the internal phase clock
            const double phaseInc = (sampleRate > 0.0 ? (double) rate / sampleRate : 0.0);
            phase += phaseInc;
            if (phase >= 1.0)
            {
                phase -= 1.0;
                const int next = (currentStep.load() + 1) % juce::jlimit (1, MAX_STEPS, activeSteps);
                currentStep.store(next);
                stepAdvanced = true;
            }
        }
        lastStepsLive = activeSteps;

        const int currentStepIndex = currentStep.load();
        const float sliderValue = pitchParams[currentStepIndex] != nullptr ? pitchParams[currentStepIndex]->load() : 0.0f;
        
        // PER-SAMPLE FIX: Read modulation from CV input bus for THIS SAMPLE
        float rawModValue = 0.5f; // neutral
        {
            const juce::String stepModId = "step" + juce::String(currentStepIndex + 1) + "_mod";
            const bool stepModConnected = isParamInputConnected(stepModId);
            if (stepModConnected)
            {
                // Absolute: step1_mod at 6, step2_mod at 7, ...
                const int modChannel = 6 + currentStepIndex;
                if (inputBus.getNumChannels() > modChannel)
                    rawModValue = inputBus.getReadPointer(modChannel)[i];
            }
        }
        // Center modulation around 0.0 (convert unipolar 0-1 to bipolar -0.5 to +0.5)
        const float modValue = rawModValue - 0.5f;

        const float pitchValue = juce::jlimit (0.0f, 1.0f, sliderValue + modValue);
        
        // --- REWRITTEN GATE LOGIC ---
        // 1. Get the gate level for the current step from its own slider.
        float stepGateLevel = (stepGateParams[currentStepIndex] != nullptr) ? stepGateParams[currentStepIndex]->load() : 0.8f;

        // 2. Apply modulation to the step's gate level if connected.
        const juce::String gateModId = "step" + juce::String(currentStepIndex + 1) + "_gate_mod";
        if (isParamInputConnected(gateModId))
        {
            const int gateModChannel = 38 + currentStepIndex;
            if (inputBus.getNumChannels() > gateModChannel)
            {
                const float cv = inputBus.getReadPointer(gateModChannel)[i];
                stepGateLevel = juce::jlimit(0.0f, 1.0f, stepGateLevel + (cv - 0.5f));
            }
        }

        // --- NEW DUAL GATE LOGIC WITH FADE-IN ---
        // 1. Perform the comparison once.
        const bool isGateOn = (stepGateLevel >= gateThreshold);
        
        // 2. Handle gate fade-in transition
        if (isGateOn && !previousGateOn) {
            // Gate just turned on - start fade-in
            gateFadeProgress = 0.0f;
        } else if (isGateOn && previousGateOn) {
            // Gate is on - continue fade-in
            const float fadeIncrement = sampleRate > 0.0f ? (1000.0f / GATE_FADE_TIME_MS) / sampleRate : 0.0f;
            gateFadeProgress = juce::jmin(1.0f, gateFadeProgress + fadeIncrement);
        } else {
            // Gate is off - reset fade progress
            gateFadeProgress = 0.0f;
        }
        previousGateOn = isGateOn;
        
        // 3. Generate the binary "Gate" output with fade-in.
        const float gateBinaryValue = isGateOn ? gateFadeProgress : 0.0f;
        
        // 4. Generate the analog "Gate Nuanced" output with fade-in.
        const float gateNuancedValue = isGateOn ? (stepGateLevel * gateFadeProgress) : 0.0f;
        // --- END OF NEW LOGIC ---
        
        // Live gate level is already stored in the UI telemetry bootstrap

        // Determine Trigger state for this step (checkbox + mod, but only count mod when connected)
        bool trigBase = false;
        if (stepTrigParams.size() > (size_t) currentStepIndex && stepTrigParams[currentStepIndex] != nullptr)
            trigBase = (bool) (*stepTrigParams[currentStepIndex]);
        bool trigActive = trigBase;
        {
            const juce::String trigModId = "step" + juce::String(currentStepIndex + 1) + "_trig_mod";
            const bool trigModConnected = isParamInputConnected(trigModId);
            if (trigModConnected)
            {
                // Absolute: step1_trig_mod at 22, step2 at 23, ...
                const int trigModChannel = 22 + currentStepIndex;
                if (inputBus.getNumChannels() > trigModChannel)
                {
                    const float trigModNorm = inputBus.getReadPointer(trigModChannel)[i];
                    if (trigModNorm > 0.5f) trigActive = true;
                }
            }
        }

        // If we advanced to this step, only emit a pulse if this step is enabled (checkbox or connected mod>0.5)
        if (stepAdvanced)
        {
            pendingTriggerSamples = trigActive ? (int) std::round (0.001 * sampleRate) : 0;
            stepAdvanced = false;
        }

        pitchOut[i] = pitchValue;
        // Live step value is already stored in the UI telemetry bootstrap
        if (gateOut != nullptr)         gateOut[i] = gateBinaryValue;
        if (gateNuancedOut != nullptr)  gateNuancedOut[i] = gateNuancedValue;
        if (velocityOut != nullptr) velocityOut[i] = 0.85f;
        if (modOut != nullptr)      modOut[i] = 0.0f;
        // Timed gate remains level-based
        // Trigger Out: 1ms pulse after each step advance
        if (trigOut != nullptr)
        {
            float pulse = 0.0f;
            if (pendingTriggerSamples > 0)
            {
                pulse = 1.0f;
                --pendingTriggerSamples;
            }
            trigOut[i] = pulse;
        }
    }
    // Publish block-level live telemetry for UI reflection
    setLiveParamValue("rate_live", lastRateLive);
    setLiveParamValue("gateLength_live", lastGateLive);
    setLiveParamValue("gateThreshold_live", lastGateThresholdLive);
    setLiveParamValue("steps_live", (float) lastStepsLive);
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 6)
    {
        if (lastOutputValues[0] && pitchOut) lastOutputValues[0]->store(pitchOut[numSamples - 1]);
        if (lastOutputValues[1] && gateOut) lastOutputValues[1]->store(gateOut[numSamples - 1]);
        if (lastOutputValues[2] && gateNuancedOut) lastOutputValues[2]->store(gateNuancedOut[numSamples - 1]);
        if (lastOutputValues[3] && velocityOut) lastOutputValues[3]->store(velocityOut[numSamples - 1]);
        if (lastOutputValues[4] && modOut) lastOutputValues[4]->store(modOut[numSamples - 1]);
        if (lastOutputValues[5] && trigOut) lastOutputValues[5]->store(trigOut[numSamples - 1]);
    }

}

#if defined(PRESET_CREATOR_UI)
void StepSequencerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMaxUi = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const bool stepsAreModulated = isParamModulated("numSteps_mod");
    if (stepsAreModulated) {
        // Reflect live steps from audio thread telemetry
        const int liveSteps = (int) std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float) activeSteps));
        activeSteps = juce::jlimit (1, boundMaxUi, liveSteps);
    }

    // Step count controls - now using a slider instead of +/- buttons
    int currentSteps = numStepsParam != nullptr ? (int)numStepsParam->load() : 8;

    // If modulated, the displayed value comes from the modulation input.
    // Otherwise, it comes from the parameter itself.
    int displayedSteps = currentSteps;
    if (stepsAreModulated) {
        const int liveSteps = (int) std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float) currentSteps));
        displayedSteps = juce::jlimit (1, boundMaxUi, liveSteps);
    }

    // Ensure the displayed value never exceeds the max bound
    displayedSteps = juce::jmin(displayedSteps, boundMaxUi);

    // Disable the slider if steps are being modulated
    if (stepsAreModulated) ImGui::BeginDisabled();

    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderInt("Steps", &displayedSteps, 1, boundMaxUi))
    {
        // Only update the parameter if the slider is not disabled
        if (!stepsAreModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numSteps"))) {
                *p = displayedSteps;
            }
        }
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    
    // Add scroll wheel support for the Steps slider
    if (!stepsAreModulated)
    {
        adjustParamOnWheel(apvts.getParameter("numSteps"), "numSteps", (float)displayedSteps);
    }
    
    ImGui::PopItemWidth();

    if (stepsAreModulated) {
        ImGui::EndDisabled();
        ImGui::SameLine(); 
        ImGui::TextUnformatted("(mod)");
    }

    // Use the displayed steps value for the slider strip
    const int shown = juce::jlimit (1, MAX_STEPS, displayedSteps);
    const float sliderW = itemWidth / (float) juce::jmax (8, shown) * 0.8f;

    ImGui::PushItemWidth (sliderW);
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();

        // Build display and interaction state
        float baseValue = (pitchParams[i] != nullptr ? pitchParams[i]->load() : 0.5f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        const bool modConnected = isParamModulated(modPid);

        // Reflect live per-step value for the currently active step when modulated
        float liveValue = getLiveParamValueFor("step" + juce::String(i + 1) + "_mod",
                                              "step_live_" + juce::String(i + 1),
                                              baseValue);
        float sliderValue = modConnected ? liveValue : baseValue; // widget bound to display value

        const bool isActive = (i == currentStep.load());
        if (isActive)
        {
            ImGui::PushStyleColor (ImGuiCol_FrameBg, ImVec4(0.3f, 0.7f, 1.0f, 1.0f));
            ImGui::PushStyleColor (ImGuiCol_SliderGrab, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
        }

        const std::string label = "##s" + std::to_string(i);
        if (modConnected) ImGui::BeginDisabled();
        if (ImGui::VSliderFloat (label.c_str(), ImVec2 (sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected) {
                // Only update if not modulated
                float newBaseValue = juce::jlimit (0.0f, 1.0f, sliderValue);
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                    *p = newBaseValue;
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit (0.0f, 1.0f, baseValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                        *p = newBaseValue;
                }
            }
        }

        if (modConnected) { ImGui::EndDisabled(); }

        if (isActive) ImGui::PopStyleColor(2);
    }
    ImGui::PopItemWidth();


    // Per-step Gate Sliders
    ImGui::PushItemWidth(sliderW);
    
    // Capture the screen position before drawing the gate sliders
    ImVec2 gate_sliders_p0 = ImGui::GetCursorScreenPos();
    
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();
        ImGui::PushID(2000 + i); // Use a new ID base to avoid collisions

        float baseGateValue = (stepGateParams[i] != nullptr ? stepGateParams[i]->load() : 0.8f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_gate_mod";
        const bool modConnected = isParamModulated(modPid);
        
        // Reflect live modulated value for gate level
        float sliderValue = baseGateValue;
        if (modConnected) {
            // Use live gate value from audio thread
            sliderValue = getLiveParamValueFor("step" + juce::String(i + 1) + "_gate_mod",
                                              "gate_live_" + juce::String(i + 1),
                                              baseGateValue);
        }
        const bool isActive = (i == currentStep.load());

        if (isActive) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.7f, 0.3f, 1.0f));
        if (modConnected) ImGui::BeginDisabled();
        
        if (ImGui::VSliderFloat("##g", ImVec2(sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected && stepGateParams[i] != nullptr) {
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("step" + juce::String(i + 1) + "_gate"))) {
                    *p = sliderValue;
                }
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        
        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit(0.0f, 1.0f, sliderValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("step" + juce::String(i + 1) + "_gate"))) {
                        *p = newBaseValue;
                    }
                }
            }
        }
        
        if (modConnected) ImGui::EndDisabled();
        if (isActive) ImGui::PopStyleColor();
        
        ImGui::PopID();
    }
    ImGui::PopItemWidth();

    // Draw the yellow threshold line immediately after the gate sliders
    // Use the same threshold value that will be used by the Gate Threshold slider
    const bool gtIsModulatedForLine = isParamModulated("gateLength_mod");
    const float threshold_value = gtIsModulatedForLine ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f))
                                                          : (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f);
    const float slider_height = 60.0f; // This must match the VSliderFloat height
    const float row_width = (sliderW * shown) + (ImGui::GetStyle().ItemSpacing.x * (shown - 1));

    // Calculate the Y coordinate for the line. 
    // A threshold of 1.0 is at the top (y=0), 0.0 is at the bottom (y=height).
    const float line_y = gate_sliders_p0.y + (1.0f - threshold_value) * slider_height;

    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    draw_list->AddLine(
        ImVec2(gate_sliders_p0.x, line_y),
        ImVec2(gate_sliders_p0.x + row_width, line_y),
        IM_COL32(255, 255, 0, 200), // A bright, slightly transparent yellow
        2.0f
    );

    // Current step indicator
    ImGui::Text("Current Step: %d", currentStep.load() + 1);

    // --- SYNC CONTROLS ---
    bool sync = apvts.getRawParameterValue("sync")->load() > 0.5f;
    if (ImGui::Checkbox("Sync to Transport", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync"))) *p = sync;
        onModificationEnded();
    }

    ImGui::PushItemWidth(itemWidth);
    if (sync)
    {
        // Check if global division is active (Tempo Clock override)
        // IMPORTANT: Read from parent's LIVE transport state, not cached copy
        int globalDiv = getParent() ? getParent()->getTransportState().globalDivisionIndex.load() : -1;
        bool isGlobalDivisionActive = globalDiv >= 0;
        int division = isGlobalDivisionActive ? globalDiv : (int)apvts.getRawParameterValue("rate_division")->load();
        
        // Grey out if controlled by Tempo Clock
        if (isGlobalDivisionActive) ImGui::BeginDisabled();
        
        if (ImGui::Combo("Division", &division, "1/32\0""1/16\0""1/8\0""1/4\0""1/2\0""1\0""2\0""4\0""8\0\0"))
        {
            if (!isGlobalDivisionActive)
            {
                if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division"))) *p = division;
                onModificationEnded();
            }
        }
        
        if (isGlobalDivisionActive)
        {
            ImGui::EndDisabled();
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
            {
                ImGui::BeginTooltip();
                ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Division Override Active");
                ImGui::TextUnformatted("A Tempo Clock node with 'Division Override' enabled is controlling the global division.");
                ImGui::PopTextWrapPos();
                ImGui::EndTooltip();
            }
        }
    }
    else
    {
        // Rate slider (only shown in free-running mode)
        const bool isRateModulated = isParamModulated("rate_mod");
        float rateDisplay = isRateModulated ? getLiveParamValueFor("rate_mod", "rate_live", rateParam->load()) : rateParam->load();
        
        if (isRateModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat("Rate (Hz)", &rateDisplay, 0.1f, 20.0f, "%.2f")) {
            if (!isRateModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("rate"))) *p = rateDisplay;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (!isRateModulated) adjustParamOnWheel(apvts.getParameter("rate"), "rate", rateDisplay);
        if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
    ImGui::PopItemWidth();
    // --- END SYNC CONTROLS ---

    ImGui::PushItemWidth(itemWidth);

    const bool gtIsModulated = isParamModulated("gateLength_mod");
    float gtEff = gtIsModulated ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f))
                                 : (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f);

    if (gtIsModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Gate Threshold", &gtEff, 0.0f, 1.0f))
    {
        if (! gtIsModulated)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"))) *p = gtEff;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (! gtIsModulated)
        adjustParamOnWheel (apvts.getParameter ("gateThreshold"), "gateThreshold", gtEff);
    if (gtIsModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::PopItemWidth();

    // --- Per-step Trigger checkboxes row ---
    // Place checkboxes exactly under each slider, matching widths and exact columns
    {
        const float cbWidth = sliderW; // same width as sliders
        for (int i = 0; i < shown; ++i)
        {
            // Compute the same X layout as sliders
            if (i > 0) ImGui::SameLine();

            bool baseTrig = (stepTrigParams.size() > (size_t) i && stepTrigParams[i] != nullptr) ? (bool) (*stepTrigParams[i]) : false;
            // Only grey out when the TRIGGER mod is connected (not the value mod)
            const juce::String trigModId = "step" + juce::String(i + 1) + "_trig_mod";
            const bool trigIsModulated = isParamModulated(trigModId);

            // Use live value for display when modulated
            bool displayTrig = baseTrig;
            if (trigIsModulated) {
                displayTrig = getLiveParamValueFor("step" + juce::String(i + 1) + "_trig_mod",
                                                  "trig_live_" + juce::String(i + 1),
                                                  baseTrig ? 1.0f : 0.0f) > 0.5f;
            }

            if (trigIsModulated) ImGui::BeginDisabled();
            ImGui::PushID(1000 + i);
            ImGui::SetNextItemWidth(cbWidth);
            ImGui::PushItemWidth(cbWidth);
            bool changed = ImGui::Checkbox("##trig", &displayTrig);
            ImGui::PopItemWidth();
            if (changed && !trigIsModulated && stepTrigParams.size() > (size_t) i && stepTrigParams[i] != nullptr)
            {
                // Only update parameter if not modulated
                *stepTrigParams[i] = displayTrig;
            }
            // Fill remaining width so columns align exactly to sliderW
            {
                float used = ImGui::GetItemRectSize().x;
                if (used < cbWidth) { ImGui::SameLine(0.0f, 0.0f); ImGui::Dummy(ImVec2(cbWidth - used, 0.0f)); }
            }
            if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
            ImGui::PopID();
            if (trigIsModulated) { ImGui::EndDisabled(); }
        }
        // Mod banner if any are modulated
        bool anyTrigMod = false;
        for (int i = 0; i < shown; ++i)
        {
            const juce::String trigModId = "step" + juce::String(i + 1) + "_trig_mod";
            if (isParamInputConnected(trigModId)) { anyTrigMod = true; break; }
        }
        if (anyTrigMod) { ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
}

void StepSequencerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // ARCHITECTURAL FIX: All inputs are now on a single bus, so we can use direct channel indices
    
    // Main stereo audio input pins (Channels 0-1)
    helpers.drawAudioInputPin("Mod In L", 0);
    helpers.drawAudioInputPin("Mod In R", 1);
    
    // Global modulation inputs (Channels 2-4)
    helpers.drawAudioInputPin("Rate Mod", 2);
    helpers.drawAudioInputPin("Gate Mod", 3);
    helpers.drawAudioInputPin("Steps Mod", 4);
    
    // Dynamic per-step modulation inputs
    const int boundMaxPins = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;

    // FIX: reflect live, modulated steps value (from audio thread telemetry)
    if (isParamInputConnected("numSteps_mod"))
    {
        const int liveSteps = (int) std::round (getLiveParamValueFor("numSteps_mod", "steps_live", (float) activeSteps));
        activeSteps = juce::jlimit (1, boundMaxPins, liveSteps);
    }
    else
    {
        activeSteps = juce::jlimit (1, boundMaxPins, activeSteps);
    }
    
    // Interleaved per-step pins: Step n Mod, Step n Trig Mod, Step n Gate Mod (absolute channels match pin DB)
    for (int i = 0; i < activeSteps; ++i)
    {
        const int stepIdx = i + 1;
        const int valChan  = 6 + (stepIdx - 1);           // 6..21
        const int trigChan = 22 + (stepIdx - 1);          // 22..37
        const int gateChan = 38 + (stepIdx - 1);          // 38..53
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Mod").toRawUTF8(), valChan);
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Trig Mod").toRawUTF8(), trigChan);
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Gate Mod").toRawUTF8(), gateChan);
    }

    // Output pins
    helpers.drawAudioOutputPin("Pitch", 0);
    helpers.drawAudioOutputPin("Gate", 1);
    helpers.drawAudioOutputPin("Gate Nuanced", 2);
    helpers.drawAudioOutputPin("Velocity", 3);
    helpers.drawAudioOutputPin("Mod", 4);
    helpers.drawAudioOutputPin("Trigger", 5);

    // Note: helpers API handles pin disappearance when the number of steps shrinks; no manual clear required here.
}
#endif

// Parameter bus contract implementation
bool StepSequencerModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    // ARCHITECTURAL FIX: All modulation is now on the single input bus at index 0
    outBusIndex = 0;

    // Global Audio/Mod Inputs (Absolute Channels)
    // 0-1: Mod In L/R, 2: Rate, 3: GateLen, 4: Steps, 5: Steps Max
    if (paramId == "rate_mod")       { outChannelIndexInBus = 2; return true; }
    if (paramId == "gateLength_mod") { outChannelIndexInBus = 3; return true; }
    if (paramId == "numSteps_mod")   { outChannelIndexInBus = 4; return true; }

    // Per-Step Trigger Modulation (Absolute Channels 22..37) — check TRIGGER first to avoid matching generic "_mod" suffix
    if (paramId.startsWith("step") && paramId.endsWith("_trig_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_trig_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 22 + (stepNum - 1); // e.g., step1_trig_mod is on channel 22
            return true;
        }
    }

    // Per-Step Value Modulation (Absolute Channels 6..21)
    if (paramId.startsWith("step") && paramId.endsWith("_mod") && !paramId.endsWith("_trig_mod") && !paramId.endsWith("_gate_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 6 + (stepNum - 1); // e.g., step1_mod is on channel 6
            return true;
        }
    }

    // Per-Step Gate Level Modulation (Absolute Channels 38..53)
    if (paramId.startsWith("step") && paramId.endsWith("_gate_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_gate_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 38 + (stepNum - 1); // e.g., step1_gate_mod is on channel 38
            return true;
        }
    }
    
    return false;
}

std::optional<RhythmInfo> StepSequencerModuleProcessor::getRhythmInfo() const
{
    RhythmInfo info;
    
    // Build display name with logical ID
    info.displayName = "Sequencer #" + juce::String(getLogicalId());
    info.sourceType = "sequencer";
    
    // Check if synced to transport
    const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;
    info.isSynced = syncEnabled;
    
    // Check if active (transport playing in sync mode, or always active in free-running)
    if (syncEnabled)
    {
        info.isActive = m_currentTransport.isPlaying;
    }
    else
    {
        info.isActive = true; // Free-running is always active
    }
    
    // Calculate effective BPM
    if (syncEnabled && info.isActive)
    {
        // In sync mode: calculate effective BPM from transport + division
        int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
        
        // Check for global division override from Tempo Clock
        if (getParent())
        {
            int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
            if (globalDiv >= 0)
                divisionIndex = globalDiv;
        }
        
        // Division multipliers: 1/32, 1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8
        static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
        const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
        
        // Effective BPM = transport BPM * division * num_steps
        // (Each complete cycle through all steps = one "measure" in BPM terms)
        const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
        info.bpm = static_cast<float>(m_currentTransport.bpm * beatDivision * numSteps);
    }
    else if (!syncEnabled)
    {
        // Free-running mode: convert Hz rate to BPM
        // Rate is in steps per second, convert to beats per minute
        const float rate = rateParam ? rateParam->load() : 2.0f;
        const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
        
        // One full cycle through all steps = one "beat"
        // BPM = (cycles_per_second) * 60
        // cycles_per_second = rate_hz / num_steps
        info.bpm = (rate / static_cast<float>(numSteps)) * 60.0f;
    }
    else
    {
        // Synced but transport stopped
        info.bpm = 0.0f;
    }
    
    return info;
}




================================================================================
FILE: juce\Source\audio\modules\AnimationModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "../../animation/AnimationFileLoader.h"
#include "../../animation/AnimationBinder.h"
#include "../../animation/Animator.h"
#include "../../animation/AnimationRenderer.h"
#include <memory>
#include <atomic>
#include <algorithm>
#include <glm/glm.hpp>

// Inherit from juce::ChangeListener to receive notifications from the background loader
class AnimationModuleProcessor : public ModuleProcessor,
                                 public juce::ChangeListener
{
public:
    AnimationModuleProcessor();
    ~AnimationModuleProcessor() override;

    // --- Main JUCE Functions ---
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    const juce::String getName() const override { return "Animation Node"; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // --- Force this node to always be processed ---
    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;
    
    // Tell the UI about our output pins
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;
    
    // Rhythm reporting for BPM Monitor
    std::optional<RhythmInfo> getRhythmInfo() const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth,
                              const std::function<bool(const juce::String& paramId)>& isParamModulated,
                              const std::function<void()>& onModificationEnded) override;
#endif

    // --- Custom Functions ---
    
    // Opens a file chooser and loads the selected animation file in the background
    void openAnimationFile();
    
    // Check if an animation file is currently being loaded in the background
    bool isCurrentlyLoading() const;
    
    // Callback executed on the main thread when background loading completes
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;
    
    const std::vector<glm::mat4>& getFinalBoneMatrices() const;
    
    // Dynamic bone tracking
    void addTrackedBone(const std::string& boneName);
    void removeTrackedBone(const std::string& boneName);
    
    // Ground Plane data structure with depth
    struct GroundPlane {
        float y = 0.0f;
        float depth = 0.0f;
    };
    void addGroundPlane(float initialY = 0.0f, float initialDepth = 0.0f);
    void removeGroundPlane(int index = -1);
    std::vector<GroundPlane> getGroundPlanes() const;

    // --- State Management (for saving/loading presets) ---
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree& state) override;

#if defined(PRESET_CREATOR_UI)
    // Auto-connection feature flags
    std::atomic<bool> autoBuildTriggersAudioTriggered { false };
#endif

private:
    static constexpr int MAX_TRACKED_BONES = 10; // Maximum number of bones we can track simultaneously
    
    // Update bone IDs for all tracked bones from the currently loaded animation
    void updateTrackedBoneIDs();
    
    // Helper structure for tracking multiple bones
    struct TrackedBone
    {
        std::string name;
        int boneId = -1;

        // UI-thread state for kinematics
        glm::vec2 lastScreenPos { 0.0f, 0.0f };
        bool isFirstFrame = true;
        bool wasBelowGround = false; // Legacy screen-space flag
        bool wasBelowWorldGround = false; // Legacy single-plane flag
        std::vector<bool> wasAboveCenter; // NEW: Tracks if bone was above the plane's center line last frame
        float previousScreenY = 0.0f; // Kept for compatibility
        float hitFlashTimer = 0.0f; // Countdown timer for red flash visual feedback

        // Atomics for audio thread
        std::atomic<float> velX { 0.0f };
        std::atomic<float> velY { 0.0f };
        std::atomic<bool> triggerState { false };
        
        // Copy constructor (atomics can't be copied, so load/store their values)
        TrackedBone(const TrackedBone& other)
            : name(other.name), boneId(other.boneId),
              lastScreenPos(other.lastScreenPos), isFirstFrame(other.isFirstFrame),
              wasBelowGround(other.wasBelowGround), wasBelowWorldGround(other.wasBelowWorldGround),
              wasAboveCenter(other.wasAboveCenter), previousScreenY(other.previousScreenY),
              hitFlashTimer(other.hitFlashTimer),
              velX(other.velX.load()), velY(other.velY.load()),
              triggerState(other.triggerState.load())
        {}
        
        // Copy assignment operator
        TrackedBone& operator=(const TrackedBone& other)
        {
            if (this != &other)
            {
                name = other.name;
                boneId = other.boneId;
                lastScreenPos = other.lastScreenPos;
                isFirstFrame = other.isFirstFrame;
                wasBelowGround = other.wasBelowGround;
                wasBelowWorldGround = other.wasBelowWorldGround;
                wasAboveCenter = other.wasAboveCenter;
                previousScreenY = other.previousScreenY;
                hitFlashTimer = other.hitFlashTimer;
                velX.store(other.velX.load());
                velY.store(other.velY.load());
                triggerState.store(other.triggerState.load());
            }
            return *this;
        }
        
        // Default constructor
        TrackedBone() = default;
    };

    // Called after raw data is loaded to bind and set up the animation
    void setupAnimationFromRawData(std::unique_ptr<RawAnimationData> rawData);
    
    // Parameter state (empty for this module, but required by ModuleProcessor)
    juce::AudioProcessorValueTreeState apvts;

    // Background animation file loader
    AnimationFileLoader m_fileLoader;

    // --- Thread-Safe Animation Data Management ---
    
    // The audio thread reads from this atomic pointer (lock-free).
    // It points to the currently active Animator that's being used for audio processing.
    std::atomic<Animator*> m_activeAnimator { nullptr };
    
    // This owns the AnimationData for the currently active animator.
    // We must keep this alive as long as the active animator might be in use.
    std::unique_ptr<AnimationData> m_activeData;
    
    // When new data is loaded, it's prepared here first, away from the audio thread.
    std::unique_ptr<AnimationData> m_stagedAnimationData;
    std::unique_ptr<Animator> m_stagedAnimator;
    
    // Old animators/data that need to be deleted safely after the audio thread is done with them.
    // We can't delete immediately after swapping because the audio thread might still be using it.
    std::vector<std::unique_ptr<Animator>> m_animatorsToFree;
    std::vector<std::unique_ptr<AnimationData>> m_dataToFree;
    juce::CriticalSection m_freeingLock; // Protects the above arrays
    
    // Tracked bones (dynamic list) for dedicated outputs - preserves insertion order
    std::vector<TrackedBone> m_trackedBones;
    juce::CriticalSection m_trackedBonesLock; // Protects m_trackedBones from concurrent access
    
    // Dynamic ground planes for multi-level trigger detection
    std::vector<GroundPlane> m_groundPlanes;
    mutable juce::CriticalSection m_groundPlanesLock; // Protects m_groundPlanes from concurrent access
    
    // Rendering
    std::unique_ptr<AnimationRenderer> m_Renderer;
    
    // Per-frame bone colors for rendering (green=tracked, red=hit flash, white=default)
    std::vector<glm::vec3> m_boneColors;

    // NEW: Per-frame vertex pairs for bone edges
    std::vector<glm::vec3> m_boneEdges;

    // File chooser (kept alive during async operation)
    std::unique_ptr<juce::FileChooser> m_FileChooser;

    // Zoom and pan for the animation viewport
    float m_zoom = 10.0f;
    float m_panX = 0.0f;
    float m_panY = 0.0f;

    // View rotation angles (in radians)
    float m_viewRotationX = 0.0f;
    float m_viewRotationY = 0.0f;
    float m_viewRotationZ = 0.0f;

    // Ground line Y position for trigger detection
    float m_groundY = 180.0f;
    
    // UI bone selection (for visualization, not directly tied to outputs anymore)
    int m_selectedBoneIndex = -1;
    std::string m_selectedBoneName = "None";
    int m_selectedBoneID = -1; // Cached bone ID to avoid map lookups
    std::vector<std::string> m_cachedBoneNames; // Thread-safe cache of bone names for UI

    // Name of the animation clip to play when a preset is loaded
    juce::String m_clipToPlayOnLoad;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AnimationModuleProcessor)
};



================================================================================
FILE: juce\Source\audio\modules\AnimationModuleProcessor.cpp
================================================================================


#include "AnimationModuleProcessor.h"
#include "../../animation/AnimationData.h"
#include <glm/gtc/matrix_transform.hpp>
#include <algorithm>

// Helper function to recursively build edge list from skeleton hierarchy
void buildEdgeListRecursive(
    const NodeData& node,
    const std::vector<glm::mat4>& worldTransforms,
    const std::map<std::string, BoneInfo>& boneInfoMap,
    std::vector<glm::vec3>& outEdges)
{
    // Check if the current node is a bone and has a valid transform
    if (boneInfoMap.count(node.name))
    {
        const int boneId = boneInfoMap.at(node.name).id;
        
        // If this node has a parent which is also a bone, create an edge
        if (node.parent && boneInfoMap.count(node.parent->name))
        {
            const int parentBoneId = boneInfoMap.at(node.parent->name).id;
            
            if (boneId < worldTransforms.size() && parentBoneId < worldTransforms.size())
            {
                glm::vec3 childPos = worldTransforms[boneId][3];
                glm::vec3 parentPos = worldTransforms[parentBoneId][3];
                
                // Add the two vertices that form the line segment
                outEdges.push_back(parentPos);
                outEdges.push_back(childPos);
            }
        }
    }

    // Recurse to children
    for (const auto& child : node.children)
    {
        buildEdgeListRecursive(child, worldTransforms, boneInfoMap, outEdges);
    }
}

AnimationModuleProcessor::AnimationModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withOutput("Output", juce::AudioChannelSet::discreteChannels(30), true)), // Max 10 bones * 3 outputs each
      apvts(*this, nullptr, "AnimationParams", {})
{
    // Constructor: m_AnimationData and m_Animator are nullptrs initially.
    m_Renderer = std::make_unique<AnimationRenderer>();
    
    // Register this class to listen for changes from our file loader
    m_fileLoader.addChangeListener(this);
    
    // Tracked bones start empty - they will be added when an animation is loaded
    
    // Initialize with one default ground plane at Y=0
    m_groundPlanes.push_back({0.0f, 0.0f}); // y=0, depth=0
    
    // DEBUG: Verify output channel count
    juce::Logger::writeToLog("[AnimationModule] Constructor: getTotalNumOutputChannels() = " + 
                             juce::String(getTotalNumOutputChannels()));
}

AnimationModuleProcessor::~AnimationModuleProcessor()
{
    // Remove listener before destruction
    m_fileLoader.removeChangeListener(this);
    
    // Safely clean up the active animator
    Animator* oldAnimator = m_activeAnimator.exchange(nullptr);
    if (oldAnimator)
    {
        // Move to deletion queue to be freed safely
        const juce::ScopedLock lock(m_freeingLock);
        m_animatorsToFree.push_back(std::unique_ptr<Animator>(oldAnimator));
    }
    
    // Clear all pending deletions
    {
        const juce::ScopedLock lock(m_freeingLock);
        m_animatorsToFree.clear();
        m_dataToFree.clear();
    }
}

void AnimationModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // We don't need to do anything special here for this module,
    // but the override is required.
}

void AnimationModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // This is the REAL-TIME AUDIO THREAD - must NOT block!
    
    // === STEP 1: Clean up old data (non-blocking try-lock) ===
    // This is a safe place to delete old animation data that was swapped out.
    {
        const juce::ScopedTryLock tryLock(m_freeingLock);
        if (tryLock.isLocked())
        {
            // We got the lock without blocking - safe to clear old data
            m_animatorsToFree.clear();
            m_dataToFree.clear();
        }
        // If we didn't get the lock, that's fine - we'll try again next block
    }
    
    // === STEP 2: Get current animator (LOCK-FREE atomic load) ===
    // Load the active animator pointer atomically.
    // This is lock-free and safe - even if the main thread swaps in new data,
    // our local pointer remains valid for this entire block.
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    // === STEP 3: Update animation if we have one ===
    if (currentAnimator != nullptr)
    {
        // Calculate the time elapsed for this audio block.
        const float deltaTime = buffer.getNumSamples() / getSampleRate();
        
        // Update the animation - this is now completely lock-free!
        currentAnimator->Update(deltaTime);
    }
    
    // Clear the output buffer first
    buffer.clear();
    
    // --- Bone Trigger and Velocity Outputs (Starting from Channel 0) ---
    const juce::ScopedTryLock tryLock(m_trackedBonesLock);
    if (tryLock.isLocked() && !m_trackedBones.empty())
    {
        for (int i = 0; i < m_trackedBones.size(); ++i)
        {
            auto& bone = m_trackedBones[i];
            if (bone.boneId != -1)
            {
                int baseChannel = i * 3; // Correct base channel

                if (baseChannel + 2 >= buffer.getNumChannels()) break;

                // --- Velocity Outputs (Continuous) ---
                float* velX_ptr = buffer.getWritePointer(baseChannel + 0);
                float* velY_ptr = buffer.getWritePointer(baseChannel + 1);
                juce::FloatVectorOperations::fill(velX_ptr, bone.velX.load(), buffer.getNumSamples());
                juce::FloatVectorOperations::fill(velY_ptr, bone.velY.load(), buffer.getNumSamples());
                
                // --- Hit Trigger Output (Single-Sample Pulse) ---
                if (bone.triggerState.load())
                {
                    buffer.setSample(baseChannel + 2, 0, 1.0f); // Fire trigger
                    bone.triggerState.store(false);             // Reset the flag
                    
                    // Log ONLY when a trigger is fired
                    juce::Logger::writeToLog("AnimationModule: Fired trigger for bone '" + bone.name + "'");
                }
            }
        }
    }
}

bool AnimationModuleProcessor::isCurrentlyLoading() const
{
    return m_fileLoader.isLoading();
}

void AnimationModuleProcessor::openAnimationFile()
{
    // If already loading, ignore the request
    if (isCurrentlyLoading())
    {
        juce::Logger::writeToLog("AnimationModule: Already loading a file. Ignoring new request.");
        return;
    }

    // Create a file chooser to let the user select an animation file
    // Store it as a member to keep it alive during the async operation
    m_FileChooser = std::make_unique<juce::FileChooser>(
        "Select an animation file (glTF/FBX)...",
        juce::File{},
        "*.gltf;*.glb;*.fbx");

    auto flags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

    // Launch the file chooser asynchronously
    m_FileChooser->launchAsync(flags, [this](const juce::FileChooser& chooser)
    {
        if (chooser.getResults().isEmpty())
        {
            juce::Logger::writeToLog("AnimationModule: File selection cancelled.");
            return; // User cancelled
        }

        juce::File file = chooser.getResult();
        
        if (!file.existsAsFile())
        {
            juce::Logger::writeToLog("AnimationModule: Selected file does not exist.");
            return;
        }
        
        juce::Logger::writeToLog("AnimationModule: Starting background load of: " + file.getFullPathName());
        
        // Start the background loading process
        // The UI will remain responsive while this happens!
        m_fileLoader.startLoadingFile(file);
    });
}

void AnimationModuleProcessor::addTrackedBone(const std::string& boneName)
{
    if (boneName == "None" || boneName.empty())
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);

    if (m_trackedBones.size() >= MAX_TRACKED_BONES)
    {
        juce::Logger::writeToLog("AnimationModule: Cannot add more than " + juce::String(MAX_TRACKED_BONES) + " tracked bones.");
        return;
    }

    // Check if the bone is already being tracked
    auto it = std::find_if(m_trackedBones.begin(), m_trackedBones.end(),
                           [&](const TrackedBone& bone) { return bone.name == boneName; });

    if (it != m_trackedBones.end())
        return; // Already exists, do nothing

    // Add the new bone to the END of the list (preserves insertion order)
    TrackedBone newBone;
    newBone.name = boneName;
    
    // Find the bone ID if an animation is already loaded
    if (m_activeData)
    {
        if (m_activeData->boneInfoMap.count(boneName))
        {
            newBone.boneId = m_activeData->boneInfoMap.at(boneName).id;
            juce::Logger::writeToLog("AnimationModule: Added tracked bone '" + juce::String(boneName) + "' with ID " + juce::String(newBone.boneId));
        }
    }
    
    m_trackedBones.push_back(newBone); // This preserves the order!
    
    // Note: Pins will update on next module reload/patch load
}

void AnimationModuleProcessor::removeTrackedBone(const std::string& boneName)
{
    if (boneName == "None" || boneName.empty())
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);

    // Use the erase-remove idiom to find and remove the bone by name
    auto it = std::remove_if(m_trackedBones.begin(), m_trackedBones.end(),
                             [&](const TrackedBone& bone) { return bone.name == boneName; });
    
    if (it != m_trackedBones.end())
    {
        m_trackedBones.erase(it, m_trackedBones.end());
        juce::Logger::writeToLog("AnimationModule: Removed tracked bone '" + juce::String(boneName) + "'");

        // Note: Pins will update on next module reload/patch load
    }
}

void AnimationModuleProcessor::addGroundPlane(float initialY, float initialDepth)
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    m_groundPlanes.push_back({initialY, initialDepth});
    juce::Logger::writeToLog("AnimationModule: Added ground plane at Y=" + juce::String(initialY) + " with Depth=" + juce::String(initialDepth));
}

void AnimationModuleProcessor::removeGroundPlane(int index)
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    if (m_groundPlanes.empty()) return;

    if (index < 0 || index >= (int)m_groundPlanes.size())
    {
        m_groundPlanes.pop_back(); // Default to removing the last one
    }
    else
    {
        m_groundPlanes.erase(m_groundPlanes.begin() + index);
    }
    juce::Logger::writeToLog("AnimationModule: Removed ground plane (count now: " + juce::String((int)m_groundPlanes.size()) + ")");
}

std::vector<AnimationModuleProcessor::GroundPlane> AnimationModuleProcessor::getGroundPlanes() const
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    return m_groundPlanes;
}

void AnimationModuleProcessor::updateTrackedBoneIDs()
{
    // No animation loaded, nothing to do
    if (m_activeData == nullptr)
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);
    
    // Go through all currently tracked bones and find matching bone IDs in the animation
    for (auto& bone : m_trackedBones)
    {
        const std::string& trackedBoneName = bone.name;
        int foundId = -1;

        // Search for this bone name in the animation's bone info map
        if (m_activeData->boneInfoMap.count(trackedBoneName))
        {
            foundId = m_activeData->boneInfoMap.at(trackedBoneName).id;
            juce::Logger::writeToLog("AnimationModule: Mapped tracked bone '" + juce::String(trackedBoneName) + 
                                     "' to ID " + juce::String(foundId));
        }
        else
        {
            juce::Logger::writeToLog("AnimationModule: WARNING - Tracked bone '" + juce::String(trackedBoneName) + 
                                     "' not found in animation");
        }
        
        bone.boneId = foundId;
    }
}

// THIS IS THE MOST IMPORTANT PART
// This function will be called on the MESSAGE THREAD when the background thread finishes
void AnimationModuleProcessor::changeListenerCallback(juce::ChangeBroadcaster* source)
{
    // Make sure the notification is coming from our file loader
    if (source == &m_fileLoader)
    {
        juce::Logger::writeToLog("AnimationModule: Background loading complete. Processing data...");
        
        // Get the loaded data from the loader (transfers ownership)
        std::unique_ptr<RawAnimationData> rawData = m_fileLoader.getLoadedData();

        if (rawData != nullptr)
        {
            // Success! The file was loaded and parsed in the background.
            // Now we can do the binding and setup work on the message thread.
            juce::String filePath = m_fileLoader.getLoadedFilePath();
            juce::Logger::writeToLog("AnimationModule: File loaded successfully: " + filePath);
            juce::Logger::writeToLog("   Raw Nodes: " + juce::String(rawData->nodes.size()));
            juce::Logger::writeToLog("   Raw Bones: " + juce::String(rawData->bones.size()));
            juce::Logger::writeToLog("   Raw Clips: " + juce::String(rawData->clips.size()));
            
            setupAnimationFromRawData(std::move(rawData));
        }
        else
        {
            // Failure - the loader returned nullptr
            juce::Logger::writeToLog("AnimationModule ERROR: Failed to load animation file. Check logs for details.");
            
            // Show error message to the user
            juce::AlertWindow::showMessageBoxAsync(
                juce::MessageBoxIconType::WarningIcon,
                "Loading Failed",
                "The selected animation file could not be loaded.\nCheck the console logs for details.",
                "OK");
        }
    }
}

void AnimationModuleProcessor::setupAnimationFromRawData(std::unique_ptr<RawAnimationData> rawData)
{
    // This is called on the MESSAGE THREAD after background loading completes
    
    juce::Logger::writeToLog("AnimationModule: Binding raw data to create AnimationData...");
    auto finalData = AnimationBinder::Bind(*rawData);

    if (!finalData)
    {
        juce::Logger::writeToLog("AnimationModule ERROR: AnimationBinder failed to create final AnimationData.");
        
        juce::AlertWindow::showMessageBoxAsync(
            juce::MessageBoxIconType::WarningIcon,
            "Binding Failed",
            "The animation data could not be processed after loading.",
            "OK");
        return;
    }
    
    juce::Logger::writeToLog("AnimationModule: Binder SUCCESS - Final data created.");
    juce::Logger::writeToLog("   Final Bones: " + juce::String(finalData->boneInfoMap.size()));
    juce::Logger::writeToLog("   Final Clips: " + juce::String(finalData->animationClips.size()));

    // === THREAD-SAFE DATA SWAP ===
    // Prepare the new animator and data in "staging" area (not visible to audio thread yet)
    m_stagedAnimationData = std::move(finalData);
    m_stagedAnimator = std::make_unique<Animator>(m_stagedAnimationData.get());
    
    // --- FIX: Play the correct animation clip from the preset ---
    bool playedSpecificClip = false;
    if (m_clipToPlayOnLoad.isNotEmpty())
    {
        // Try to find and play the clip saved in the preset.
        for (const auto& clip : m_stagedAnimationData->animationClips)
        {
            if (clip.name == m_clipToPlayOnLoad.toStdString())
            {
                m_stagedAnimator->PlayAnimation(clip.name);
                juce::Logger::writeToLog("AnimationModule: Playing saved animation clip: " + juce::String(clip.name));
                playedSpecificClip = true;
                break;
            }
        }
        m_clipToPlayOnLoad.clear(); // Clear after use
    }

    // Fallback: If no specific clip was played (or none was saved), play the first one.
    if (!playedSpecificClip && !m_stagedAnimationData->animationClips.empty())
    {
        const auto& firstClip = m_stagedAnimationData->animationClips[0];
        m_stagedAnimator->PlayAnimation(firstClip.name);
        juce::Logger::writeToLog("AnimationModule: No saved clip found. Playing first clip: " + juce::String(firstClip.name));
    }
    
    // Cache bone names for thread-safe UI access (on main thread, before audio thread gets it)
    m_cachedBoneNames.clear();
    for (const auto& pair : m_stagedAnimationData->boneInfoMap)
    {
        m_cachedBoneNames.push_back(pair.first);
    }
    juce::Logger::writeToLog("AnimationModule: Cached " + juce::String((int)m_cachedBoneNames.size()) + " bone names for UI.");
    
    // Update tracked bone IDs for the new animation (NON-DESTRUCTIVE)
    // This does NOT clear the list - it only refreshes the IDs
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        
        // If this is a completely fresh load (no bones tracked yet), add defaults
        if (m_trackedBones.empty())
        {
            TrackedBone leftFoot;
            leftFoot.name = "LeftFoot";
            m_trackedBones.push_back(leftFoot);
            
            TrackedBone rightFoot;
            rightFoot.name = "RightFoot";
            m_trackedBones.push_back(rightFoot);
            
            juce::Logger::writeToLog("AnimationModule: Initialized default tracked bones (LeftFoot, RightFoot)");
        }
        
        // Update bone IDs for ALL currently tracked bones from the new animation
        for (auto& bone : m_trackedBones)
        {
            const std::string& trackedBoneName = bone.name;
            int foundId = -1;

            // Search for a matching bone in the animation
            for (const auto& boneInfoPair : m_stagedAnimationData->boneInfoMap)
            {
                const std::string& boneNameFromFile = boneInfoPair.first;
                
                if (juce::String(boneNameFromFile).endsWithIgnoreCase(trackedBoneName))
                {
                    foundId = boneInfoPair.second.id;
                    juce::Logger::writeToLog("AnimationModule: Refreshed tracked bone '" + juce::String(trackedBoneName) + 
                                             "' with ID " + juce::String(foundId));
                    break;
                }
            }
            
            bone.boneId = foundId;
            
            if (foundId == -1)
            {
                juce::Logger::writeToLog("AnimationModule: WARNING - Tracked bone '" + juce::String(trackedBoneName) + 
                                         "' not found in new animation");
            }
        }
    }
    
    juce::Logger::writeToLog("AnimationModule: Preparing to swap animation data...");
    
    // 1. Release the raw pointer for the new animator from its unique_ptr.
    Animator* newAnimator = m_stagedAnimator.release();
    
    // 2. Atomically swap the new animator into the 'active' slot.
    // The audio thread will pick this up on its next processBlock().
    Animator* oldAnimator = m_activeAnimator.exchange(newAnimator, std::memory_order_release);
    
    // 3. Now, swap the unique_ptr that owns the AnimationData.
    // m_stagedAnimationData (holding the NEW data) is moved into m_activeData.
    // The previous m_activeData (holding the OLD data) is moved into a temporary.
    std::unique_ptr<AnimationData> oldDataToFree = std::move(m_activeData);
    m_activeData = std::move(m_stagedAnimationData);

    juce::Logger::writeToLog("AnimationModule: New animator is now active.");

    // 4. Queue the OLD animator and OLD data for safe deletion.
    // We can't delete them immediately, as the audio thread might still be using them.
    {
        const juce::ScopedLock lock(m_freeingLock);
        if (oldAnimator)
        {
            m_animatorsToFree.push_back(std::unique_ptr<Animator>(oldAnimator));
            juce::Logger::writeToLog("AnimationModule: Old animator queued for safe deletion.");
        }
        if (oldDataToFree)
        {
            m_dataToFree.push_back(std::move(oldDataToFree));
            juce::Logger::writeToLog("AnimationModule: Old animation data queued for safe deletion.");
        }
    }
    
    // Reset UI state now that new data is active
    m_selectedBoneIndex = -1;
    m_selectedBoneName = "None";
    
    juce::Logger::writeToLog("AnimationModule: Animation atomically swapped and ready for audio thread!");
}

const std::vector<glm::mat4>& AnimationModuleProcessor::getFinalBoneMatrices() const
{
    // This is called from the UI/message thread to get bone matrices for rendering.
    // We use the same atomic pointer the audio thread uses - this is safe and lock-free!
    
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);

    if (currentAnimator != nullptr)
    {
        return currentAnimator->GetFinalBoneMatrices();
    }

    // If there's no animator, return a static empty vector to avoid crashes.
    static const std::vector<glm::mat4> empty;
    return empty;
}

#if defined(PRESET_CREATOR_UI)

// Helper function to project a 3D point to 2D screen space
static glm::vec2 worldToScreen(const glm::vec3& worldPos, const glm::mat4& viewMatrix, const glm::mat4& projectionMatrix, ImVec2 viewportPos, ImVec2 viewportSize)
{
    glm::vec4 clipSpacePos = projectionMatrix * viewMatrix * glm::vec4(worldPos, 1.0f);
    if (clipSpacePos.w == 0.0f) return {0,0};
    glm::vec3 ndcSpacePos = glm::vec3(clipSpacePos.x, clipSpacePos.y, clipSpacePos.z) / clipSpacePos.w;
    glm::vec2 screenPos;
    screenPos.x = (ndcSpacePos.x + 1.0f) / 2.0f * viewportSize.x + viewportPos.x;
    screenPos.y = (1.0f - ndcSpacePos.y) / 2.0f * viewportSize.y + viewportPos.y;
    return screenPos;
}

// Helper function for tooltip with help marker
static void HelpMarker(const char* desc)
{
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

void AnimationModuleProcessor::drawParametersInNode(float itemWidth,
                                                     const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                                     const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth(itemWidth);
    
    // File loading section
    ImGui::TextWrapped("glTF File:");
    
    // Show loading status or loaded file info
    // Get current animator atomically (lock-free)
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    if (isCurrentlyLoading())
    {
        // Show a loading indicator while file is being loaded in the background
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Loading...");
        ImGui::SameLine();
        // Simple animated spinner
        static float spinnerAngle = 0.0f;
        spinnerAngle += ImGui::GetIO().DeltaTime * 10.0f;
        ImGui::Text("%.1f", spinnerAngle); // Simple animation placeholder
    }
    else if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "Loaded");
        ImGui::Text("Bones: %zu", animData->boneInfoMap.size());
        ImGui::Text("Clips: %zu", animData->animationClips.size());
    }
    else
    {
        ImGui::TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "No file loaded");
    }
    
    // Disable button while loading
    if (isCurrentlyLoading())
        ImGui::BeginDisabled();
    
    if (ImGui::Button("Load Animation File...", ImVec2(itemWidth, 0)))
    {
        // Use the new async loading method!
        // This will not block the UI - the file chooser and loading happen in the background
        openAnimationFile();
    }
    
    if (isCurrentlyLoading())
        ImGui::EndDisabled();
    
    
    // --- BONE SELECTION ---
    if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        if (!animData->boneInfoMap.empty())
        {
            if (ImGui::BeginCombo("Selected Bone", m_selectedBoneName.c_str()))
            {
                // Add a "None" option
                bool isNoneSelected = (m_selectedBoneIndex == -1);
                if (ImGui::Selectable("None", isNoneSelected))
                {
                    m_selectedBoneIndex = -1;
                    m_selectedBoneName = "None";
                    m_selectedBoneID = -1;
                }

                // Iterate through cached bone names (thread-safe)
                int currentIndex = 0;
                for (const auto& boneName : m_cachedBoneNames)
                {
                    bool isSelected = (m_selectedBoneName == boneName);

                    if (ImGui::Selectable(boneName.c_str(), isSelected))
                    {
                        m_selectedBoneName = boneName;
                        m_selectedBoneIndex = currentIndex;
                        
                        // Cache the bone ID to avoid map lookups every frame
                        if (animData->boneInfoMap.count(boneName))
                        {
                            m_selectedBoneID = animData->boneInfoMap.at(boneName).id;
                        }
                        else
                        {
                            m_selectedBoneID = -1;
                        }
                    }
                    if (isSelected)
                    {
                        ImGui::SetItemDefaultFocus();
                    }
                    currentIndex++;
                }
                ImGui::EndCombo();
            }
            
            // Add/Remove Bone Output Buttons (with Undo/Redo support)
            bool isSelected = (m_selectedBoneName != "None" && !m_selectedBoneName.empty());
            bool isAlreadyTracked = false;
            if (isSelected)
            {
                const juce::ScopedLock lock(m_trackedBonesLock);
                auto it = std::find_if(m_trackedBones.begin(), m_trackedBones.end(),
                                       [this](const TrackedBone& bone) { return bone.name == m_selectedBoneName; });
                isAlreadyTracked = (it != m_trackedBones.end());
            }

            // "Add Bone Output" button
            if (!isSelected || isAlreadyTracked) ImGui::BeginDisabled();
            if (ImGui::Button("Add Bone Output", ImVec2(itemWidth / 2 - 2, 0)))
            {
                addTrackedBone(m_selectedBoneName);
                onModificationEnded(); // Trigger undo/redo snapshot
            }
            if (!isSelected || isAlreadyTracked) ImGui::EndDisabled();

            ImGui::SameLine();

            // "Remove Bone Output" button
            if (!isSelected || !isAlreadyTracked) ImGui::BeginDisabled();
            if (ImGui::Button("Remove Bone Output", ImVec2(itemWidth / 2 - 2, 0)))
            {
                removeTrackedBone(m_selectedBoneName);
                onModificationEnded(); // Trigger undo/redo snapshot
            }
            if (!isSelected || !isAlreadyTracked) ImGui::EndDisabled();
        }
    }
    
    // Build Triggers Audio Quick-Connect Button (80s blue style)
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.15f, 0.6f, 0.85f, 0.8f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.7f, 0.95f, 0.95f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.35f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.0f));
    if (ImGui::Button("BUILD TRIGGERS AUDIO", ImVec2(itemWidth, 0)))
    {
        autoBuildTriggersAudioTriggered = true;
    }
    ImGui::PopStyleColor(4);
    HelpMarker("Auto-create samplers + mixer, wire triggers to pads.");
    
    
    // Animation playback controls
    if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        ImGui::Text("Animation Controls:");
        
        // List available clips
        if (!animData->animationClips.empty())
        {
            ImGui::Text("Available Clips:");
            for (size_t i = 0; i < animData->animationClips.size(); ++i)
            {
                const auto& clip = animData->animationClips[i];
                if (ImGui::Button(clip.name.c_str(), ImVec2(itemWidth, 0)))
                {
                    // Safe to call directly - the animator pointer is valid for this frame
                    currentAnimator->PlayAnimation(clip.name);
                }
            }
        }
        
        
        // Speed control
        static float speed = 1.0f;
        if (ImGui::SliderFloat("Speed", &speed, 0.1f, 3.0f, "%.2f"))
        {
            // Safe to call directly - the animator pointer is valid for this frame
            currentAnimator->SetAnimationSpeed(speed);
        }
        
        // DEBUG: Display basic info (accessing animator state directly is unsafe due to audio thread)
        ImGui::Separator();
        ImGui::Text("Debug Info:");
        ImGui::Text("Bones: %d", (int)animData->boneInfoMap.size());
        ImGui::Text("Clips: %d", (int)animData->animationClips.size());
        ImGui::Separator();
        
        
        // --- RENDERING VIEWPORT ---
        
        ImGui::Text("Animation Viewport:");
        
        // Camera controls
        ImGui::SliderFloat("Zoom", &m_zoom, 1.0f, 50.0f, "%.1f");
        ImGui::SliderFloat("Pan X", &m_panX, -20.0f, 20.0f, "%.1f");
        ImGui::SliderFloat("Pan Y", &m_panY, -20.0f, 20.0f, "%.1f");
        
        // View rotation controls
        ImGui::Text("View Rotation:");
        ImGui::PushItemWidth(itemWidth / 3.0f - 5.0f); // Adjust width for 3 buttons side-by-side
        if (ImGui::Button("Rot X")) { m_viewRotationX += glm::radians(90.0f); }
        ImGui::SameLine();
        if (ImGui::Button("Rot Y")) { m_viewRotationY += glm::radians(90.0f); }
        ImGui::SameLine();
        if (ImGui::Button("Rot Z")) { m_viewRotationZ += glm::radians(90.0f); }
        ImGui::PopItemWidth();

        // Reset view button - resets rotation and frames the animation
        if (ImGui::Button("Reset View", ImVec2(itemWidth, 0)))
        {
            m_viewRotationX = 0.0f;
            m_viewRotationY = 0.0f;
            m_viewRotationZ = 0.0f;
            if (currentAnimator != nullptr)
            {
                glm::vec2 newPan;
                m_Renderer->frameView(currentAnimator->GetBoneWorldTransforms(), m_zoom, newPan);
                m_panX = newPan.x;
                m_panY = newPan.y;
            }
        }
        
        
        // === GROUND PLANE CONTROLS (FIXED) ===
        ImGui::Separator();
        ImGui::Text("Ground Planes:");

        // --- Step 1: Calculate the animation's current Y-bounds for a sensible slider range ---
        float sliderMin = -5.0f;
        float sliderMax = 5.0f;
        if (currentAnimator && !currentAnimator->GetBoneWorldTransforms().empty())
        {
            const auto& worldTransforms = currentAnimator->GetBoneWorldTransforms();
            float minY = 0.0f, maxY = 0.0f;
            bool boundsInitialized = false;
            for (const auto& matrix : worldTransforms)
            {
                glm::vec3 pos = matrix[3];
                if (glm::length(pos) < 0.001f) continue; // Ignore bones at origin

                if (!boundsInitialized) {
                    minY = maxY = pos.y;
                    boundsInitialized = true;
                } else {
                    minY = std::min(minY, pos.y);
                    maxY = std::max(maxY, pos.y);
                }
            }

            // Add padding to the range to allow placing planes above/below the animation
            if (boundsInitialized)
            {
                const float yRange = maxY - minY;
                const float padding = (yRange > 0.01f) ? yRange * 0.5f : 2.0f;
                sliderMin = minY - padding;
                sliderMax = maxY + padding;
            }
        }
        
        // Add/Remove Buttons
        if (ImGui::Button("Add Ground Plane", ImVec2(itemWidth / 2 - 2, 0)))
        {
            addGroundPlane(0.0f, 0.0f); // Default: line at world origin
            onModificationEnded(); 
        }
        ImGui::SameLine();
        bool canRemove = false;
        {
            const juce::ScopedLock lock(m_groundPlanesLock);
            canRemove = m_groundPlanes.size() > 1;
        }
        if (!canRemove) ImGui::BeginDisabled();
        if (ImGui::Button("Remove Ground Plane", ImVec2(itemWidth / 2 - 2, 0)))
        {
            removeGroundPlane();
            onModificationEnded();
        }
        if (!canRemove) ImGui::EndDisabled();

        // Colored Sliders for each ground plane
        {
            const juce::ScopedLock lock(m_groundPlanesLock);
            for (int i = 0; i < (int)m_groundPlanes.size(); ++i)
            {
                ImGui::PushID(i);
                float hue = fmodf((float)i * 0.2f, 1.0f);
                ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(hue, 0.5f, 0.5f));
                ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));
                ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));
                ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(hue, 0.9f, 0.9f));

                // Slider for Y position (center line)
                ImGui::SliderFloat("Ground Y", &m_groundPlanes[i].y, sliderMin, sliderMax, "%.2f");
                if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();

                // Slider for Depth (monitoring zone size)
                ImGui::SliderFloat("Depth", &m_groundPlanes[i].depth, 0.0f, 2.0f, "%.2f");
                if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();

                ImGui::PopStyleColor(4);
                ImGui::PopID();
            }
        }
        ImGui::Separator();
        
        
        // Pass the latest values to the renderer before drawing
        m_Renderer->setZoom(m_zoom);
        m_Renderer->setPan({m_panX, m_panY});
        m_Renderer->setViewRotation({m_viewRotationX, m_viewRotationY, m_viewRotationZ});
        
        // Define the size of our viewport
        const ImVec2 viewportSize(400, 400);
        
        // Setup the renderer (it will only run once internally)
        m_Renderer->setup(static_cast<int>(viewportSize.x), static_cast<int>(viewportSize.y));
        
        // Get world transforms for visualization (NOT skinning matrices!)
        const auto& worldTransforms = currentAnimator->GetBoneWorldTransforms();

        // --- NEW: Build the edge list for drawing lines between bones ---
        m_boneEdges.clear();
        if (currentAnimator->GetAnimationData())
        {
            const auto* animData = currentAnimator->GetAnimationData();
            buildEdgeListRecursive(animData->rootNode, worldTransforms, animData->boneInfoMap, m_boneEdges);
        }
        
        // --- DEBUG: Log bone positions to diagnose rendering issues ---
        static int debugFrameCounter = 0;
        if (++debugFrameCounter % 60 == 0 && !worldTransforms.empty()) // Log once per second at 60fps
        {
            juce::Logger::writeToLog("=== Animation Frame Debug ===");
            juce::Logger::writeToLog("Total bones: " + juce::String(worldTransforms.size()));
            
            // Log the first 3 bone positions to see if they're all at origin or varying
            for (size_t i = 0; i < std::min(size_t(3), worldTransforms.size()); ++i)
            {
                glm::vec3 pos = worldTransforms[i][3];
                juce::Logger::writeToLog("Bone[" + juce::String(i) + "] Position: (" + 
                    juce::String(pos.x, 2) + ", " + 
                    juce::String(pos.y, 2) + ", " + 
                    juce::String(pos.z, 2) + ")");
            }
        }
        
        // --- BONE COLOR, KINEMATIC, AND HIT-DETECTION LOGIC (MOVED BEFORE RENDER) ---
        const int numBones = worldTransforms.size();
        m_boneColors.assign(numBones, glm::vec3(1.0f, 1.0f, 1.0f)); // Default all to white

        const float deltaTime = ImGui::GetIO().DeltaTime;
        auto groundPlanesToDraw = getGroundPlanes();
        
        // Recreate matrices for hit detection and velocity
        glm::mat4 projection = glm::ortho(-m_zoom + m_panX, m_zoom + m_panX, -m_zoom + m_panY, m_zoom + m_panY, -10.0f, 10.0f);
        glm::mat4 view = glm::mat4(1.0f);
        view = glm::rotate(view, m_viewRotationX, glm::vec3(1.0f, 0.0f, 0.0f));
        view = glm::rotate(view, m_viewRotationY, glm::vec3(0.0f, 1.0f, 0.0f));
        view = glm::rotate(view, m_viewRotationZ, glm::vec3(0.0f, 0.0f, 1.0f));
        
        const juce::ScopedLock lock(m_trackedBonesLock);

        // First, set the base green color for all currently tracked bones
        for (const auto& bone : m_trackedBones) {
            if (bone.boneId != -1 && bone.boneId < numBones) {
                m_boneColors[bone.boneId] = glm::vec3(0.0f, 1.0f, 0.0f); // Green
            }
        }

        // Now iterate again to handle hits, timers, and velocity
        for (auto& bone : m_trackedBones)
        {
            // Update this bone's flash timer
            bone.hitFlashTimer = std::max(0.0f, bone.hitFlashTimer - deltaTime);

            if (bone.boneId != -1 && bone.boneId < numBones)
            {
                // Ensure the state vector is the correct size
                if (bone.wasAboveCenter.size() != groundPlanesToDraw.size()) {
                    bone.wasAboveCenter.assign(groundPlanesToDraw.size(), false);
                }

                glm::mat4 worldMatrix = worldTransforms[bone.boneId];
                glm::vec3 worldPos = worldMatrix[3];

                // Per-plane world-space hit detection
                for (int i = 0; i < (int)groundPlanesToDraw.size(); ++i) {
                    const auto& plane = groundPlanesToDraw[i];
                    float centerY = plane.y;
                    float topY = plane.y + plane.depth / 2.0f;
                    float bottomY = plane.y - plane.depth / 2.0f;
                    bool isCurrentlyInsideZone = (worldPos.y >= bottomY && worldPos.y <= topY);
                    
                    // Fire only if we are inside the zone AND we just crossed the center line downwards
                    if (isCurrentlyInsideZone && bone.wasAboveCenter[i] && worldPos.y <= centerY) {
                        bone.triggerState.store(true);
                        bone.hitFlashTimer = 0.5f;
                    }
                    bone.wasAboveCenter[i] = (worldPos.y > centerY);
                }

                // Velocity calculation
                ImVec2 viewportPos = ImGui::GetItemRectMin();
                glm::vec2 currentScreenPos = worldToScreen(worldPos, view, projection, viewportPos, viewportSize);
                if (bone.isFirstFrame) {
                    bone.lastScreenPos = currentScreenPos;
                    bone.isFirstFrame = false;
                }
                glm::vec2 velocity(0.0f);
                if (deltaTime > 0.0f) {
                    velocity = (currentScreenPos - bone.lastScreenPos) / deltaTime;
                }
                bone.lastScreenPos = currentScreenPos;
                bone.velX.store(velocity.x);
                bone.velY.store(velocity.y);
            } else {
                bone.wasAboveCenter.clear();
                bone.isFirstFrame = true;
                bone.hitFlashTimer = 0.0f;
            }

            // After all updates, set the final color for this bone
            if (bone.boneId != -1 && bone.boneId < numBones) {
                if (bone.hitFlashTimer > 0.0f) {
                    m_boneColors[bone.boneId] = glm::vec3(1.0f, 0.0f, 0.0f); // Red flash
                }
            }
        }

        // FIX: Call render AFTER calculating colors and pass the color AND edge data
        m_Renderer->render(worldTransforms, m_boneColors, m_boneEdges);
        
        // Display the texture from the FBO (flipped vertically)
        ImGui::Image((void*)(intptr_t)m_Renderer->getTextureID(), viewportSize, ImVec2(0, 1), ImVec2(1, 0));

        // --- DRAW GROUND ZONES WITH CENTER LINES ---
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 p1 = ImGui::GetItemRectMin();
        ImVec2 p2 = ImGui::GetItemRectMax();
        
        for (int i = 0; i < (int)groundPlanesToDraw.size(); ++i)
        {
            const auto& plane = groundPlanesToDraw[i];
            float topY = plane.y + plane.depth / 2.0f;
            float bottomY = plane.y - plane.depth / 2.0f;
            
            glm::vec2 screenTop = worldToScreen({0.0f, topY, 0.0f}, view, projection, p1, viewportSize);
            glm::vec2 screenBottom = worldToScreen({0.0f, bottomY, 0.0f}, view, projection, p1, viewportSize);
            glm::vec2 screenCenter = worldToScreen({0.0f, plane.y, 0.0f}, view, projection, p1, viewportSize);

            float hue = fmodf((float)i * 0.2f, 1.0f);
            ImVec4 colorVec = (ImVec4)ImColor::HSV(hue, 0.9f, 0.9f);
            ImU32 color = IM_COL32((int)(colorVec.x * 255), (int)(colorVec.y * 255), (int)(colorVec.z * 255), 255);
            ImU32 fillColor = IM_COL32((int)(colorVec.x * 255), (int)(colorVec.y * 255), (int)(colorVec.z * 255), 50);

            if (plane.depth > 0.001f) {
                drawList->AddRectFilled(ImVec2(p1.x, screenTop.y), ImVec2(p2.x, screenBottom.y), fillColor);
                drawList->AddLine(ImVec2(p1.x, screenCenter.y), ImVec2(p2.x, screenCenter.y), color, 1.5f);
            } else {
                drawList->AddLine(ImVec2(p1.x, screenCenter.y), ImVec2(p2.x, screenCenter.y), color, 2.0f);
            }
        }
    }
    else
    {
        // Show a placeholder when no animation is loaded to maintain consistent node size
        ImGui::TextDisabled("Load an animation file to see animation");
        ImGui::Dummy(ImVec2(400, 400)); // Reserve space for the viewport
    }
    
    ImGui::PopItemWidth();
}
#endif

bool AnimationModuleProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    // Support up to our max channels (10 bones * 3 outputs), and no inputs.
    const int maxChannels = 30; // Max 10 bones
    return layouts.getMainOutputChannelSet().size() <= maxChannels
           && layouts.getMainInputChannelSet() == juce::AudioChannelSet::disabled();
}

std::vector<DynamicPinInfo> AnimationModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    const juce::ScopedLock lock(m_trackedBonesLock);
    
    // The loop now starts correctly at channel 0
    for (int i = 0; i < m_trackedBones.size(); ++i)
    {
        const auto& bone = m_trackedBones[i];
        int baseChannel = i * 3; // Correct base channel
        
        pins.push_back({ juce::String(bone.name) + " Vel X", baseChannel + 0, PinDataType::CV });
        pins.push_back({ juce::String(bone.name) + " Vel Y", baseChannel + 1, PinDataType::CV });
        pins.push_back({ juce::String(bone.name) + " Hit",   baseChannel + 2, PinDataType::Gate });
    }
    
    return pins;
}

// === State Management (for saving/loading presets) ===

juce::ValueTree AnimationModuleProcessor::getExtraStateTree() const
{
    // This function is called by the synth when saving a preset.
    // We create a ValueTree to hold our module's unique state.
    juce::ValueTree state("AnimationModuleState");

    // 1. Save the absolute path of the currently loaded animation file.
    state.setProperty("animationFilePath", m_fileLoader.getLoadedFilePath(), nullptr);

    // 2. Save the viewport/camera settings.
    state.setProperty("zoom", m_zoom, nullptr);
    state.setProperty("panX", m_panX, nullptr);
    state.setProperty("panY", m_panY, nullptr);
    state.setProperty("viewRotationX", m_viewRotationX, nullptr);
    state.setProperty("viewRotationY", m_viewRotationY, nullptr);
    state.setProperty("viewRotationZ", m_viewRotationZ, nullptr);

    // Save the name of the currently playing animation clip
    juce::String currentClipName;
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    if (currentAnimator != nullptr && currentAnimator->GetCurrentAnimation() != nullptr)
    {
        currentClipName = currentAnimator->GetCurrentAnimation()->name;
    }
    state.setProperty("animationClipName", currentClipName, nullptr);

    // 3. Save the list of ground planes
    juce::ValueTree groundPlanesNode("GroundPlanes");
    {
        const juce::ScopedLock lock(m_groundPlanesLock);
        for (const auto& plane : m_groundPlanes)
        {
            juce::ValueTree planeNode("Plane");
            planeNode.setProperty("y", plane.y, nullptr);
            planeNode.setProperty("depth", plane.depth, nullptr);
            groundPlanesNode.addChild(planeNode, -1, nullptr);
        }
    }
    state.addChild(groundPlanesNode, -1, nullptr);

    // 4. Save the list of tracked bones (preserves insertion order)
    juce::ValueTree trackedBonesNode("TrackedBones");
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        for (const auto& bone : m_trackedBones)
        {
            juce::ValueTree boneNode("Bone");
            boneNode.setProperty("name", juce::String(bone.name), nullptr);
            trackedBonesNode.addChild(boneNode, -1, nullptr);
        }
    }
    state.addChild(trackedBonesNode, -1, nullptr);

    // 5. Save the name of the currently selected bone.
    state.setProperty("selectedBoneName", juce::String(m_selectedBoneName), nullptr);

    juce::Logger::writeToLog("[AnimationModule] Saving state: file='" + 
                              m_fileLoader.getLoadedFilePath() + 
                              "', bone='" + juce::String(m_selectedBoneName) + "'");
    
    return state;
}

void AnimationModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    // This function is called by the synth when loading a preset.
    // We restore our state from the provided ValueTree.
    
    if (!state.hasType("AnimationModuleState"))
        return;

    juce::Logger::writeToLog("[AnimationModule] Loading state from preset...");

    // === CRITICAL: ORDER OF OPERATIONS FOR PRESET LOADING ===
    // We must load the animation file FIRST so that bone names can be matched to IDs afterward.
    
    // 1. Restore the viewport/camera settings.
    m_zoom = state.getProperty("zoom", 10.0f);
    m_panX = state.getProperty("panX", 0.0f);
    m_panY = state.getProperty("panY", 0.0f);
    m_viewRotationX = state.getProperty("viewRotationX", 0.0f);
    m_viewRotationY = state.getProperty("viewRotationY", 0.0f);
    m_viewRotationZ = state.getProperty("viewRotationZ", 0.0f);

    // 2. Restore the selected bone name (for UI dropdown).
    m_selectedBoneName = state.getProperty("selectedBoneName", "None").toString().toStdString();

    // Restore the name of the animation clip to be played after the file loads.
    m_clipToPlayOnLoad = state.getProperty("animationClipName", "").toString();

    // 3. IMPORTANT: Load the animation file BEFORE restoring tracked bones.
    juce::String filePath = state.getProperty("animationFilePath", "").toString();
    
    if (filePath.isNotEmpty())
    {
        juce::File fileToLoad(filePath);
        
        if (fileToLoad.existsAsFile())
        {
            juce::Logger::writeToLog("[AnimationModule] Restoring animation from preset: " + fileToLoad.getFullPathName());
            m_fileLoader.startLoadingFile(fileToLoad);
            // Note: This is async, but setupAnimationFromRawData is now non-destructive, so the
            // tracked bones we restore next won't be cleared.
        }
        else
        {
            juce::Logger::writeToLog("[AnimationModule] Warning: Animation file not found at: " + filePath);
        }
    }
    else
    {
        juce::Logger::writeToLog("[AnimationModule] No animation file path in preset.");
    }

    // 4. Restore the list of tracked bones from the preset (preserves saved order).
    // This happens AFTER we've started loading the file (which is async).
    // Since setupAnimationFromRawData is now non-destructive, it won't clear this list.
    if (auto trackedBonesNode = state.getChildWithName("TrackedBones"); trackedBonesNode.isValid())
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        m_trackedBones.clear(); // Clear the current list
        for (const auto& boneNode : trackedBonesNode)
        {
            if (boneNode.hasType("Bone"))
            {
                juce::String boneName = boneNode.getProperty("name").toString();
                if (boneName.isNotEmpty())
                {
                    TrackedBone newBone;
                    newBone.name = boneName.toStdString();
                    m_trackedBones.push_back(newBone); // Preserves order!
                    juce::Logger::writeToLog("[AnimationModule] Restored tracked bone: " + boneName);
                }
            }
        }
    }

    // 5. Restore the list of ground planes.
    if (auto groundPlanesNode = state.getChildWithName("GroundPlanes"); groundPlanesNode.isValid())
    {
        const juce::ScopedLock lock(m_groundPlanesLock);
        m_groundPlanes.clear();
        for (const auto& planeNode : groundPlanesNode)
        {
            if (planeNode.hasType("Plane"))
            {
                // Read both y and depth, providing a default of 0.0 for depth for old presets.
                m_groundPlanes.push_back({ (float)planeNode.getProperty("y", 0.0f), (float)planeNode.getProperty("depth", 0.0f) });
            }
        }
        // Fallback: if loading results in no ground planes, add one as a safety
        if (m_groundPlanes.empty())
        {
            m_groundPlanes.push_back({0.0f, 0.0f});
        }
    }
    else
    {
        // Legacy support: try to load single groundY value (depth will be 0)
        float legacyGroundY = state.getProperty("groundY", 0.0f);
        const juce::ScopedLock lock(m_groundPlanesLock);
        m_groundPlanes.clear();
        m_groundPlanes.push_back({legacyGroundY, 0.0f});
    }
    
    juce::Logger::writeToLog("[AnimationModule] Preset loading complete.");
}

std::optional<RhythmInfo> AnimationModuleProcessor::getRhythmInfo() const
{
    // Load animator atomically (thread-safe)
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    if (!currentAnimator || !currentAnimator->GetCurrentAnimation())
        return std::nullopt; // No animation loaded or playing
    
    RhythmInfo info;
    info.displayName = "Animation #" + juce::String(getLogicalId());
    info.sourceType = "animation";
    info.isActive = true; // Animation is playing if we got here
    info.isSynced = false; // Animations are always free-running
    
    // Calculate BPM from animation clip duration
    const auto* currentClip = currentAnimator->GetCurrentAnimation();
    if (currentClip && currentClip->durationInTicks > 0.0 && currentClip->ticksPerSecond > 0.0)
    {
        // Calculate duration in seconds
        const double durationSeconds = currentClip->durationInTicks / currentClip->ticksPerSecond;
        
        // One loop = one "beat" in BPM terms
        // Calculate base BPM
        info.bpm = static_cast<float>(60.0 / durationSeconds);
        
        // Apply animation speed multiplier
        const float speedMultiplier = currentAnimator->GetAnimationSpeed();
        info.bpm *= speedMultiplier;
    }
    else
    {
        info.bpm = 0.0f;
    }
    
    return info;
}



================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <atomic>
#include <vector>
#include <memory>
#include "../modules/ModuleProcessor.h"
#include "../modules/InputDebugModuleProcessor.h"

class ModularSynthProcessor : public juce::AudioProcessor
{
public:
    ModularSynthProcessor();
    ~ModularSynthProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    const juce::String getName() const override { return "Modular Synth"; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return true; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    // Public API (initial)
public:
    using Node = juce::AudioProcessorGraph::Node;
    using NodeID = juce::AudioProcessorGraph::NodeID;
    

    NodeID addModule(const juce::String& moduleType, bool commit = true);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc, juce::uint32 logicalIdToAssign);
    void removeModule(const NodeID& nodeID);
    void clearAll(); // Add this line
    void clearAllConnections(); // Add this line
    void clearOutputConnections(); // <<< ADD THIS LINE
    void clearConnectionsForNode(const NodeID& nodeID); // <<< ADD THIS LINE
    bool connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    
    // Set the hardware input channel mapping for an Audio Input module
    void setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap);
    
    void commitChanges();
    NodeID getOutputNodeID() const { return audioOutputNode ? audioOutputNode->nodeID : NodeID{}; }
    NodeID getBPMMonitorNodeID() const { return bpmMonitorNode ? bpmMonitorNode->nodeID : NodeID{}; }
    // Introspection for editor
    std::vector<std::pair<juce::uint32, juce::String>> getModulesInfo() const;
    juce::AudioProcessorGraph::NodeID getNodeIdForLogical (juce::uint32 logicalId) const;
    juce::uint32 getLogicalIdForNode (const NodeID& nodeId) const;
    juce::String getModuleTypeForLogical(juce::uint32 logicalId) const;
    bool disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    struct ConnectionInfo
    {
        juce::uint32 srcLogicalId { 0 };
        int srcChan { 0 };
        juce::uint32 dstLogicalId { 0 }; // 0 means audio output
        int dstChan { 0 };
        bool dstIsOutput { false };
    };
    std::vector<ConnectionInfo> getConnectionsInfo() const;
    // Access a module processor for UI parameter editing
    ModuleProcessor* getModuleForLogical (juce::uint32 logicalId) const;
    
    // === GLOBAL TRANSPORT & TIMING ===
    // (TransportState struct is defined in ModuleProcessor.h)
    
    TransportState getTransportState() const { return m_transportState; }
    void setPlaying(bool playing) {
        m_transportState.isPlaying = playing;
        // Immediately broadcast timing change to modules even if audio callback is stopped
        if (auto processors = activeAudioProcessors.load())
        {
            for (const auto& modulePtr : *processors)
                if (modulePtr)
                    modulePtr->setTimingInfo(m_transportState);
        }
    }
    void setBPM(double bpm) { m_transportState.bpm = juce::jlimit(20.0, 999.0, bpm); }
    void setGlobalDivisionIndex(int idx) { m_transportState.globalDivisionIndex.store(idx); }
    void setTempoControlledByModule(bool controlled) { m_transportState.isTempoControlledByModule.store(controlled); }
    
    // MIDI activity indicator
    bool hasMidiActivity() const { return m_midiActivityFlag.exchange(false); }
    void resetTransportPosition() { m_samplePosition = 0; m_transportState.songPositionBeats = 0.0; m_transportState.songPositionSeconds = 0.0; }
    
    // === MULTI-MIDI DEVICE SUPPORT ===
    
    /**
     * @brief Process device-aware MIDI messages
     * 
     * This method receives MIDI messages with device source information and
     * distributes them to all modules via handleDeviceSpecificMidi().
     * Should be called from the message thread (timer callback in PresetCreatorComponent).
     * 
     * @param messages Vector of MIDI messages with device information
     */
    void processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages);
    
    /**
     * @brief MIDI activity state per device and channel
     */
    struct MidiActivityState {
        std::map<int, std::array<bool, 16>> deviceChannelActivity;  // deviceIndex -> channels[16]
        std::map<int, juce::String> deviceNames;                    // deviceIndex -> name
    };
    
    /**
     * @brief Get snapshot of current MIDI activity
     * 
     * Used by UI for visualization (top bar indicator).
     * Thread-safe.
     * 
     * @return MidiActivityState structure
     */
    MidiActivityState getMidiActivityState() const;
    
    // === VOICE MANAGEMENT FOR POLYPHONY ===
    struct Voice {
        bool isActive = false;
        int noteNumber = -1;
        float velocity = 0.0f;
        juce::uint32 age = 0;  // Used for note stealing (oldest voice)
        juce::uint32 targetModuleLogicalId = 0;  // Which PolyVCO this voice is assigned to
    };
    
    void setVoiceManagerEnabled(bool enabled) { m_voiceManagerEnabled = enabled; }
    bool isVoiceManagerEnabled() const { return m_voiceManagerEnabled; }
    void setMaxVoices(int numVoices) { m_voices.resize(numVoices); }
    int getMaxVoices() const { return static_cast<int>(m_voices.size()); }
    const std::vector<Voice>& getVoices() const { return m_voices; }
    
    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get system-wide diagnostics
    juce::String getSystemDiagnostics() const;
    
    // Get diagnostics for a specific module
    juce::String getModuleDiagnostics(juce::uint32 logicalId) const;
    
    // Get parameter routing diagnostics for a specific module
    juce::String getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const;
    
    // Get all connection diagnostics
    juce::String getConnectionDiagnostics() const;
    
    // Check if any recorder module is currently recording (prevents spacebar from stopping audio)
    bool isAnyModuleRecording() const;
    
    // Pause/Resume all active recorders (used by spacebar during audition)
    void pauseAllRecorders();
    void resumeAllRecorders();
    
    // Global start/stop all recorders (used by menu bar)
    void startAllRecorders();
    void stopAllRecorders();
    
    // Plugin format manager for VST support (optional, set by application)
    void setPluginFormatManager(juce::AudioPluginFormatManager* manager) { pluginFormatManager = manager; }
    void setKnownPluginList(juce::KnownPluginList* list) { knownPluginList = list; }
    
    // === PROBE TOOL API ===
    // Probe system for instant signal debugging without manual patching
    void setProbeConnection(const NodeID& sourceNodeID, int sourceChannel);
    void clearProbeConnection();
    ModuleProcessor* getProbeScopeProcessor() const;

private:
    // The internal graph that represents the modular patch
    std::unique_ptr<juce::AudioProcessorGraph> internalGraph;

    // Special nodes for handling I/O within the internal graph
    Node::Ptr audioInputNode;
    Node::Ptr audioOutputNode;
    Node::Ptr midiInputNode;
    
    
    // MIDI activity indicator (mutable because hasMidiActivity() is const)
    mutable std::atomic<bool> m_midiActivityFlag{false};
    
    // Multi-MIDI device support
    std::vector<MidiMessageWithDevice> currentBlockMidiMessages;
    mutable juce::CriticalSection midiActivityLock;
    MidiActivityState currentActivity;

    // The APVTS that will expose proxy parameters to the host/AudioEngine
    juce::AudioProcessorValueTreeState apvts;

    // Thread-safe module access for audio thread
    mutable juce::CriticalSection moduleLock;
    std::atomic<std::shared_ptr<const std::vector<std::shared_ptr<ModuleProcessor>>>> activeAudioProcessors;

    // Manage module nodes (legacy map by NodeID.uid)
    std::map<juce::uint32, Node::Ptr> modules; // keyed by NodeID.uid
    // Logical ID mapping for preset save/load
    struct LogicalModule
    {
        juce::AudioProcessorGraph::NodeID nodeID;
        juce::String type;
    };
    std::map<juce::uint32, LogicalModule> logicalIdToModule; // logicalId -> module
    juce::uint32 nextLogicalId { 1 };
    
    // Optional pointers for VST support
    juce::AudioPluginFormatManager* pluginFormatManager { nullptr };
    juce::KnownPluginList* knownPluginList { nullptr };
    
    // Probe scope for instant signal debugging (hidden from user, not saved in presets)
    Node::Ptr probeScopeNode;
    NodeID probeScopeNodeId;
    
    // BPM Monitor node (always present, undeletable like output node)
    Node::Ptr bpmMonitorNode;
    
    // Transport state
    TransportState m_transportState;
    juce::uint64 m_samplePosition { 0 };
    
    // Voice management state
    std::vector<Voice> m_voices;
    bool m_voiceManagerEnabled { false };
    juce::uint32 m_globalVoiceAge { 0 };  // Incremented for each note-on
    
    // Voice management helper methods
    int findFreeVoice();
    int findOldestVoice();
    void assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn);
    void releaseVoice(const juce::MidiMessage& noteOff);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModularSynthProcessor)
};

================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.cpp
================================================================================


#include "ModularSynthProcessor.h"
#include "../modules/AudioInputModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/VCOModuleProcessor.h"
#include "../modules/VCFModuleProcessor.h"
#include "../modules/VCAModuleProcessor.h"
#include "../modules/NoiseModuleProcessor.h"
#include "../modules/LFOModuleProcessor.h"
#include "../modules/ADSRModuleProcessor.h"
#include "../modules/MixerModuleProcessor.h"
#include "../modules/DelayModuleProcessor.h"
#include "../modules/ReverbModuleProcessor.h"
#include "../modules/AttenuverterModuleProcessor.h"
#include "../modules/ScopeModuleProcessor.h"
#include "../modules/SAndHModuleProcessor.h"
#include "../modules/StepSequencerModuleProcessor.h"
#include "../modules/MathModuleProcessor.h"
#include "../modules/MapRangeModuleProcessor.h"
#include "../modules/RandomModuleProcessor.h"
#include "../modules/RateModuleProcessor.h"
#include "../modules/QuantizerModuleProcessor.h"
#include "../modules/SequentialSwitchModuleProcessor.h"
#include "../modules/LogicModuleProcessor.h"
#include "../modules/ValueModuleProcessor.h"
#include "../modules/ClockDividerModuleProcessor.h"
#include "../modules/WaveshaperModuleProcessor.h"
#include "../modules/MultiBandShaperModuleProcessor.h"
#include "../modules/GranulatorModuleProcessor.h"
#include "../modules/HarmonicShaperModuleProcessor.h"
#include "../modules/TrackMixerModuleProcessor.h"
#include "../modules/TTSPerformerModuleProcessor.h"
#include "../modules/ComparatorModuleProcessor.h"
#include "../modules/VocalTractFilterModuleProcessor.h"
#include "../modules/VstHostModuleProcessor.h"
#include "../modules/SampleLoaderModuleProcessor.h"
#include "../modules/FunctionGeneratorModuleProcessor.h"
#include "../modules/TimePitchModuleProcessor.h"
#include "../modules/DebugModuleProcessor.h"
#include "../modules/CommentModuleProcessor.h"
#include "../modules/MIDIPlayerModuleProcessor.h"
#include "../modules/PolyVCOModuleProcessor.h"
#include "../modules/BestPracticeNodeProcessor.h"
#include "../modules/TimelineModuleProcessor.h"
#include "../modules/BPMMonitorModuleProcessor.h"
#include "../modules/ShapingOscillatorModuleProcessor.h"
#include "../modules/MultiSequencerModuleProcessor.h"
#include "../modules/LagProcessorModuleProcessor.h"
#include "../modules/DeCrackleModuleProcessor.h"
#include "../modules/CVMixerModuleProcessor.h"
#include "../modules/GraphicEQModuleProcessor.h"
#include "../modules/FrequencyGraphModuleProcessor.h"
#include "../modules/ChorusModuleProcessor.h"
#include "../modules/PhaserModuleProcessor.h"
#include "../modules/CompressorModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/LimiterModuleProcessor.h"
#include "../modules/GateModuleProcessor.h"
#include "../modules/DriveModuleProcessor.h"
#include "../modules/SnapshotSequencerModuleProcessor.h"
#include "../modules/MIDICVModuleProcessor.h"
#include "../modules/MIDIFadersModuleProcessor.h"
#include "../modules/MIDIKnobsModuleProcessor.h"
#include "../modules/MIDIButtonsModuleProcessor.h"
#include "../modules/MIDIJogWheelModuleProcessor.h"
#include "../modules/MIDIPadModuleProcessor.h"
#include "../modules/MidiLoggerModuleProcessor.h"
#include "../modules/TempoClockModuleProcessor.h"
#include "../modules/PhysicsModuleProcessor.h"
#include "../modules/StrokeSequencerModuleProcessor.h"
#include "../modules/AnimationModuleProcessor.h"
#include "../modules/WebcamLoaderModule.h"
#include "../modules/VideoFileLoaderModule.h"
#include "../modules/MovementDetectorModule.h"
#include "../modules/HumanDetectorModule.h"
#include "../modules/PoseEstimatorModule.h"
#include "../modules/HandTrackerModule.h"
#include "../modules/FaceTrackerModule.h"
#include "../modules/ObjectDetectorModule.h"
#include "../modules/ColorTrackerModule.h"
#include "../modules/ContourDetectorModule.h"
#include "../modules/SemanticSegmentationModule.h"
#include "../modules/InletModuleProcessor.h"
#include "../modules/OutletModuleProcessor.h"
#include "../modules/MetaModuleProcessor.h"

ModularSynthProcessor::ModularSynthProcessor()
    : juce::AudioProcessor(BusesProperties()
                            .withInput("Input", juce::AudioChannelSet::stereo(), true)
                            .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "ModularSynthParams", {})
{
    internalGraph = std::make_unique<juce::AudioProcessorGraph>();

    using IOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor;
    audioInputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioInputNode));
    audioOutputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioOutputNode));
    midiInputNode  = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::midiInputNode));

    internalGraph->addConnection({ { midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex },
                                   { audioOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex } });
    
    probeScopeNode = internalGraph->addNode(std::make_unique<ScopeModuleProcessor>());
    probeScopeNodeId = probeScopeNode->nodeID;
    juce::Logger::writeToLog("[ModularSynth] Initialized probe scope with nodeID: " + juce::String(probeScopeNodeId.uid));
    
    // Create BPM Monitor node (always present, undeletable like output node)
    auto bpmMonitor = std::make_unique<BPMMonitorModuleProcessor>();
    bpmMonitor->setLogicalId(999); // Special ID to make it undeletable
    bpmMonitorNode = internalGraph->addNode(std::move(bpmMonitor));
    if (auto* processor = dynamic_cast<ModuleProcessor*>(bpmMonitorNode->getProcessor()))
        processor->setParent(this);
    juce::Logger::writeToLog("[ModularSynth] Initialized BPM Monitor with logicalID: 999");
    
    activeAudioProcessors.store(std::make_shared<const std::vector<std::shared_ptr<ModuleProcessor>>>());
    
    m_voices.resize(8);
    for (auto& voice : m_voices)
    {
        voice.isActive = false;
        voice.noteNumber = -1;
        voice.velocity = 0.0f;
        voice.age = 0;
        voice.targetModuleLogicalId = 0;
    }
}

ModularSynthProcessor::~ModularSynthProcessor() {}

void ModularSynthProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    internalGraph->setPlayConfigDetails(getTotalNumInputChannels(), getTotalNumOutputChannels(), sampleRate, samplesPerBlock);
    internalGraph->prepareToPlay(sampleRate, samplesPerBlock);
}

void ModularSynthProcessor::releaseResources()
{
    internalGraph->releaseResources();
}

//==============================================================================
// Multi-MIDI Device Support
//==============================================================================

void ModularSynthProcessor::processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages)
{
    const juce::ScopedLock lock(midiActivityLock);
    currentBlockMidiMessages = messages;
    
    // DEBUG LOGGING
    if (!messages.empty())
    {
        juce::Logger::writeToLog("[ModularSynth] processMidiWithDeviceInfo received " + 
                                juce::String(messages.size()) + " MIDI messages");
    }
    
    // Update activity tracking
    currentActivity.deviceChannelActivity.clear();
    currentActivity.deviceNames.clear();
    
    for (const auto& msg : messages)
    {
        // Skip system realtime messages
        if (msg.message.isMidiClock() || msg.message.isActiveSense())
            continue;
        
        int channel = msg.message.getChannel();
        if (channel >= 1 && channel <= 16)
        {
            int channelIndex = channel - 1;  // 0-15
            currentActivity.deviceChannelActivity[msg.deviceIndex][channelIndex] = true;
            currentActivity.deviceNames[msg.deviceIndex] = msg.deviceName;
        }
    }
}

ModularSynthProcessor::MidiActivityState ModularSynthProcessor::getMidiActivityState() const
{
    const juce::ScopedLock lock(midiActivityLock);
    return currentActivity;
}

//==============================================================================
// Audio Processing
//==============================================================================

void ModularSynthProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    try {
        // NOTE: Both tempo and division control flags are managed by Tempo Clock modules directly
        // No resets here to avoid flickering in UI
        
        // --- ADD THIS LOGGING BLOCK ---
        if (!midiMessages.isEmpty())
        {
            // If we get this message, it means MIDI is successfully reaching the synth.
            juce::Logger::writeToLog("[SynthCore] Received " + juce::String(midiMessages.getNumEvents()) + " MIDI events this block.");
            m_midiActivityFlag.store(true);
        }
        // --- END OF BLOCK ---
        
        if (m_transportState.isPlaying)
        {
            m_samplePosition += buffer.getNumSamples();
            m_transportState.songPositionSeconds = m_samplePosition / getSampleRate();
            m_transportState.songPositionBeats = (m_transportState.songPositionSeconds / 60.0) * m_transportState.bpm;
        }

        // --- FINAL THREAD-SAFE FIX ---
        auto currentProcessors = activeAudioProcessors.load();
        if (currentProcessors)
        {
            // Iterate over the safe, shared list.
            for (const auto& modulePtr : *currentProcessors)
            {
                // SAFETY NET + GRANULAR LOGGING
                if (modulePtr != nullptr)
                {
                    // Log the memory address before calling the function
                    // juce::Logger::writeToLog("[AudioThread] Ticking module at 0x" + juce::String::toHexString((juce::pointer_sized_int)modulePtr.get()));
                    modulePtr->setTimingInfo(m_transportState);
                }
                else
                {
                    // This should never happen with the shared_ptr fix, but if it does, it's critical info.
                    juce::Logger::writeToLog("[AudioThread] CRITICAL WARNING: Encountered nullptr in active processor list!");
                }
            }
        }
        // --- END OF FIX ---
        
        // === MULTI-MIDI DEVICE SUPPORT: Distribute device-aware MIDI to modules ===
        // This happens BEFORE voice management and graph processing
        // Modules receive device info and can filter by device/channel
        {
            const juce::ScopedLock lock(midiActivityLock);
            
            // DEBUG: Log every processBlock attempt to check the buffer
            static int checkCount = 0;
            static int distributionCount = 0;
            checkCount++;
            
            if (!currentBlockMidiMessages.empty())
            {
                distributionCount++;
                
                // Log only first few times to avoid spam
                if (distributionCount <= 5)
                {
                    juce::Logger::writeToLog("[ModularSynth processBlock] CHECK #" + juce::String(checkCount) + 
                                            " - Found " + juce::String(currentBlockMidiMessages.size()) + " messages to distribute");
                }
                
                if (internalGraph)
                {
                    int nodeCount = internalGraph->getNodes().size();
                    int moduleCount = 0;
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Distributing to " + juce::String(nodeCount) + " nodes");
                    }
                    
                    for (auto* node : internalGraph->getNodes())
                    {
                        if (auto* module = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                        {
                            moduleCount++;
                            module->handleDeviceSpecificMidi(currentBlockMidiMessages);
                        }
                    }
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Called handleDeviceSpecificMidi on " + 
                                                juce::String(moduleCount) + " modules");
                    }
                    
                    // Merge device-aware MIDI into standard MidiBuffer for backward compatibility
                    for (const auto& msg : currentBlockMidiMessages)
                    {
                        midiMessages.addEvent(msg.message, 0);
                    }
                    
                    // Clear for next block
                    currentBlockMidiMessages.clear();
                }
                else
                {
                    juce::Logger::writeToLog("[ModularSynth] WARNING: Have MIDI messages but internalGraph is null!");
                }
            }
        }
        // === END MULTI-MIDI DISTRIBUTION ===
        
        if (m_voiceManagerEnabled && !m_voices.empty())
        {
            juce::MidiBuffer processedMidi;
            for (const auto metadata : midiMessages)
            {
                const auto msg = metadata.getMessage();
                if (msg.isNoteOn())
                {
                    int voiceIndex = findFreeVoice();
                    if (voiceIndex < 0) voiceIndex = findOldestVoice();
                    if (voiceIndex >= 0)
                    {
                        assignNoteToVoice(voiceIndex, msg);
                        processedMidi.addEvent(msg, metadata.samplePosition);
                    }
                }
                else if (msg.isNoteOff())
                {
                    releaseVoice(msg);
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
                else
                {
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
            }
            midiMessages.swapWith(processedMidi);
        }
        
        internalGraph->processBlock(buffer, midiMessages);
        static int silentCtr = 0;
        if (buffer.getMagnitude(0, buffer.getNumSamples()) < 1.0e-6f)
        {
            if ((++silentCtr % 600) == 0)
                juce::Logger::writeToLog("[ModularSynthProcessor] silent block from internal graph");
        }
        else
        {
            silentCtr = 0;
        }
    } catch (const std::exception& e) {
        juce::Logger::writeToLog(juce::String("[ModSynth][FATAL] Exception in processBlock: ") + e.what());
        buffer.clear();
        return;
    } catch (...) {
        juce::Logger::writeToLog("[ModSynth][FATAL] Unknown exception in processBlock");
        buffer.clear();
        return;
    }
}

void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock (moduleLock);
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32) kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int) logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32) c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32) c.destination.nodeID.uid;
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int) dstIt->second, nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else
        {
            continue;
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}

void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes)));
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML or wrong root tag. Aborting restore.");
        return;
    }

    clearAll();
    juce::Logger::writeToLog("[STATE] Cleared existing state.");

    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // Restore global transport settings
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    juce::Logger::writeToLog("[STATE] Restored BPM to " + juce::String(m_transportState.bpm));
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found in preset.");
        return;
    }
    
    juce::Logger::writeToLog("[STATE] Found <modules> block with " + juce::String(modsVT.getNumChildren()) + " children.");
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    std::map<juce::uint32, NodeID> logicalToNodeId;
    juce::Logger::writeToLog("[STATE] Starting module recreation pass...");
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module"))
        {
            juce::Logger::writeToLog("[STATE] Skipping non-module child at index " + juce::String(i));
            continue;
        }

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module " + juce::String(i) + ": logicalId=" + juce::String(logicalId) + " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::Logger::writeToLog("[STATE]   Loading VST module...");
                    
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr && knownPluginList != nullptr)
                    {
                        bool found = false;
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE]   Found VST to load: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found)
                        {
                            juce::Logger::writeToLog("[STATE]   ERROR: VST plugin not found: " + identifier);
                        }
                    }
                    else
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: No plugin identifier or format manager/list not available");
                    }
                    
                    if (nodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: Failed to create VST module, skipping...");
                        continue;
                    }
                }
            }
            
            if (!isVstModule)
            {
                juce::Logger::writeToLog("[STATE]   Calling addModule('" + type + "')...");
                nodeId = addModule(type, false);
                juce::Logger::writeToLog("[STATE]   addModule returned nodeId.uid=" + juce::String(nodeId.uid));
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                juce::Logger::writeToLog("[STATE]   Node created successfully.");
                
                if (!isVstModule)
                {
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;
                juce::Logger::writeToLog("[STATE]   Mapped logicalId " + juce::String(logicalId) + " to nodeId.uid " + juce::String(nodeId.uid));

                // --- FIX: Restore extra state FIRST ---
                // This will load the clip and reset trim sliders to defaults.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE]   Restored extra state.");
                    }
                }

                // Now restore parameters SECOND.
                // This will overwrite the temporary default trim values with the correct saved values.
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE]   Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   ERROR: Node creation failed! nodeId.uid was " + juce::String(nodeId.uid) + " but getNodeForId returned nullptr.");
            }
        }
        else
        {
            juce::Logger::writeToLog("[STATE]   Skipping module: logicalId=" + juce::String(logicalId) + " (valid=" + juce::String(logicalId > 0 ? "yes" : "no") + ") type='" + type + "' (empty=" + juce::String(type.isEmpty() ? "yes" : "no") + ")");
        }
    }
    
    juce::Logger::writeToLog("[STATE] Module recreation complete. Created " + juce::String(logicalToNodeId.size()) + " modules.");

    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        int skippedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   WARNING: Skipping connection " + juce::String(i) + 
                                        ": srcId=" + juce::String(srcId) + " (uid=" + juce::String(srcNodeId.uid) + 
                                        ") → dstId=" + (dstIsOutput ? "output" : juce::String(dstId)) + 
                                        " (uid=" + juce::String(dstNodeId.uid) + ")");
                skippedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connection restore complete: " + juce::String(connectedCount) + 
                                " connected, " + juce::String(skippedCount) + " skipped.");
    }
    else
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <connections> block found in preset.");
    }


    juce::Logger::writeToLog("[STATE] Calling commitChanges()...");
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}

namespace {
    static juce::String toLowerId (const juce::String& s)
    {
        return s.toLowerCase();
    }

    using Creator = std::function<std::unique_ptr<juce::AudioProcessor>()>;

    static std::map<juce::String, Creator>& getModuleFactory()
    {
        static std::map<juce::String, Creator> factory;
        static bool initialised = false;
        if (!initialised)
        {
            auto reg = [&](const juce::String& key, Creator c) { factory.emplace(toLowerId(key), std::move(c)); };

            reg("vco", []{ return std::make_unique<VCOModuleProcessor>(); });
            reg("audio_input", []{ return std::make_unique<AudioInputModuleProcessor>(); });
            reg("vcf", []{ return std::make_unique<VCFModuleProcessor>(); });
            reg("vca", []{ return std::make_unique<VCAModuleProcessor>(); });
            reg("noise", []{ return std::make_unique<NoiseModuleProcessor>(); });
            reg("lfo", []{ return std::make_unique<LFOModuleProcessor>(); });
            reg("adsr", []{ return std::make_unique<ADSRModuleProcessor>(); });
            reg("mixer", []{ return std::make_unique<MixerModuleProcessor>(); });
            reg("cv_mixer", []{ return std::make_unique<CVMixerModuleProcessor>(); });
            reg("track_mixer", []{ return std::make_unique<TrackMixerModuleProcessor>(); });
            reg("delay", []{ return std::make_unique<DelayModuleProcessor>(); });
            reg("reverb", []{ return std::make_unique<ReverbModuleProcessor>(); });
            reg("attenuverter", []{ return std::make_unique<AttenuverterModuleProcessor>(); });
            reg("scope", []{ return std::make_unique<ScopeModuleProcessor>(); });
            reg("frequency_graph", []{ return std::make_unique<FrequencyGraphModuleProcessor>(); });
            reg("s_and_h", []{ return std::make_unique<SAndHModuleProcessor>(); });
            reg("sequencer", []{ return std::make_unique<StepSequencerModuleProcessor>(); });
            reg("math", []{ return std::make_unique<MathModuleProcessor>(); });
            reg("map_range", []{ return std::make_unique<MapRangeModuleProcessor>(); });
            reg("comparator", []{ return std::make_unique<ComparatorModuleProcessor>(); });
            reg("random", []{ return std::make_unique<RandomModuleProcessor>(); });
            reg("rate", []{ return std::make_unique<RateModuleProcessor>(); });
            reg("quantizer", []{ return std::make_unique<QuantizerModuleProcessor>(); });
            reg("sequential_switch", []{ return std::make_unique<SequentialSwitchModuleProcessor>(); });
            reg("logic", []{ return std::make_unique<LogicModuleProcessor>(); });
            reg("clock_divider", []{ return std::make_unique<ClockDividerModuleProcessor>(); });
            reg("waveshaper", []{ return std::make_unique<WaveshaperModuleProcessor>(); });
            reg("8bandshaper", []{ return std::make_unique<MultiBandShaperModuleProcessor>(); });
            reg("granulator", []{ return std::make_unique<GranulatorModuleProcessor>(); });
            reg("harmonic_shaper", []{ return std::make_unique<HarmonicShaperModuleProcessor>(); });
            reg("debug", []{ return std::make_unique<DebugModuleProcessor>(); });
            reg("input_debug", []{ return std::make_unique<InputDebugModuleProcessor>(); });
            reg("vocal_tract_filter", []{ return std::make_unique<VocalTractFilterModuleProcessor>(); });
            reg("value", []{ return std::make_unique<ValueModuleProcessor>(); });
            reg("tts_performer", []{ return std::make_unique<TTSPerformerModuleProcessor>(); });
            reg("sample_loader", []{ return std::make_unique<SampleLoaderModuleProcessor>(); });
            reg("function_generator", []{ return std::make_unique<FunctionGeneratorModuleProcessor>(); });
            reg("timepitch", []{ return std::make_unique<TimePitchModuleProcessor>(); });
            reg("midi_player", []{ return std::make_unique<MIDIPlayerModuleProcessor>(); });
            reg("polyvco", []{ return std::make_unique<PolyVCOModuleProcessor>(); });
            reg("best_practice", []{ return std::make_unique<BestPracticeNodeProcessor>(); });
            reg("timeline", []{ return std::make_unique<TimelineModuleProcessor>(); });
            reg("shaping_oscillator", []{ return std::make_unique<ShapingOscillatorModuleProcessor>(); });
            reg("multi_sequencer", []{ return std::make_unique<MultiSequencerModuleProcessor>(); });
            reg("lag_processor", []{ return std::make_unique<LagProcessorModuleProcessor>(); });
            reg("de_crackle", []{ return std::make_unique<DeCrackleModuleProcessor>(); });
            reg("graphic_eq", []{ return std::make_unique<GraphicEQModuleProcessor>(); });
            reg("chorus", []{ return std::make_unique<ChorusModuleProcessor>(); });
            reg("phaser", []{ return std::make_unique<PhaserModuleProcessor>(); });
            reg("compressor", []{ return std::make_unique<CompressorModuleProcessor>(); });
            reg("recorder", []{ return std::make_unique<RecordModuleProcessor>(); });
            reg("limiter", []{ return std::make_unique<LimiterModuleProcessor>(); });
            reg("gate", []{ return std::make_unique<GateModuleProcessor>(); });
            reg("drive", []{ return std::make_unique<DriveModuleProcessor>(); });
            reg("comment", []{ return std::make_unique<CommentModuleProcessor>(); });
            reg("snapshot_sequencer", []{ return std::make_unique<SnapshotSequencerModuleProcessor>(); });
            reg("midi_cv", []{ return std::make_unique<MIDICVModuleProcessor>(); });
            reg("midi_faders", []{ return std::make_unique<MIDIFadersModuleProcessor>(); });
            reg("midi_knobs", []{ return std::make_unique<MIDIKnobsModuleProcessor>(); });
            reg("midi_buttons", []{ return std::make_unique<MIDIButtonsModuleProcessor>(); });
            reg("midi_jog_wheel", []{ return std::make_unique<MIDIJogWheelModuleProcessor>(); });
            reg("midi_pads", []{ return std::make_unique<MIDIPadModuleProcessor>(); });
            reg("midi_logger", []{ return std::make_unique<MidiLoggerModuleProcessor>(); });
            reg("tempo_clock", []{ return std::make_unique<TempoClockModuleProcessor>(); });
            reg("physics", []{ return std::make_unique<PhysicsModuleProcessor>(); });
            reg("animation", []{ return std::make_unique<AnimationModuleProcessor>(); });
            reg("bpm_monitor", []{ return std::make_unique<BPMMonitorModuleProcessor>(); });
            reg("webcam_loader", []{ return std::make_unique<WebcamLoaderModule>(); });
            reg("video_file_loader", []{ return std::make_unique<VideoFileLoaderModule>(); });
            reg("movement_detector", []{ return std::make_unique<MovementDetectorModule>(); });
            reg("human_detector", []{ return std::make_unique<HumanDetectorModule>(); });
            reg("pose_estimator", []{ return std::make_unique<PoseEstimatorModule>(); });
            reg("hand_tracker", []{ return std::make_unique<HandTrackerModule>(); });
            reg("face_tracker", []{ return std::make_unique<FaceTrackerModule>(); });
            reg("object_detector", []{ return std::make_unique<ObjectDetectorModule>(); });
            reg("color_tracker", []{ return std::make_unique<ColorTrackerModule>(); });
            reg("contour_detector", []{ return std::make_unique<ContourDetectorModule>(); });
            reg("semantic_segmentation", []{ return std::make_unique<SemanticSegmentationModule>(); });
            reg("stroke_sequencer", []{ return std::make_unique<StrokeSequencerModuleProcessor>(); });
            
            reg("meta module", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("metamodule", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("inlet", []{ return std::make_unique<InletModuleProcessor>(); });
            reg("outlet", []{ return std::make_unique<OutletModuleProcessor>(); });

            initialised = true;
        }
        return factory;
    }
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addModule(const juce::String& moduleType, bool commit)
{
    const juce::ScopedLock lock (moduleLock);
    auto& factory = getModuleFactory();
    const juce::String key = moduleType.toLowerCase();
    std::unique_ptr<juce::AudioProcessor> processor;

    if (auto it = factory.find(key); it != factory.end())
        processor = it->second();

    if (! processor)
    {
        for (const auto& kv : factory)
            if (moduleType.equalsIgnoreCase(kv.first)) { processor = kv.second(); break; }
    }

    if (processor)
    {
        auto node = internalGraph->addNode(std::move(processor), {}, juce::AudioProcessorGraph::UpdateKind::none);
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setParent(this);
        modules[(juce::uint32) node->nodeID.uid] = node;
        const juce::uint32 logicalId = nextLogicalId++;
        logicalIdToModule[logicalId] = LogicalModule{ node->nodeID, moduleType };
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setLogicalId(logicalId);
        
        if (moduleType.equalsIgnoreCase("audio_input"))
        {
            std::vector<int> defaultMapping = {0, 1};
            setAudioInputChannelMapping(node->nodeID, defaultMapping);
        }
        
        if (commit)
        {
            // Ensure the new module is immediately active
            commitChanges();
        }
        
        return node->nodeID;
    }

    juce::Logger::writeToLog("[ModSynth][WARN] Unknown module type: " + moduleType);
    return {};
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc,
    juce::uint32 logicalIdToAssign)
{
    juce::String errorMessage;
    std::unique_ptr<juce::AudioPluginInstance> instance = 
        formatManager.createPluginInstance(vstDesc, getSampleRate(), getBlockSize(), errorMessage);

    if (instance == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] Could not create VST instance: " + errorMessage);
        return {};
    }

    auto wrapper = std::make_unique<VstHostModuleProcessor>(std::move(instance), vstDesc);
    
    auto node = internalGraph->addNode(std::move(wrapper), {}, juce::AudioProcessorGraph::UpdateKind::none);

    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setParent(this);
    
    modules[(juce::uint32) node->nodeID.uid] = node;
    
    logicalIdToModule[logicalIdToAssign] = LogicalModule{ node->nodeID, vstDesc.name };
    
    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setLogicalId(logicalIdToAssign);
    
    juce::Logger::writeToLog("[ModSynth] Added VST module: " + vstDesc.name + " with logical ID " + juce::String(logicalIdToAssign));
    return node->nodeID;
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc)
{
    const juce::uint32 logicalId = nextLogicalId++;
    auto nodeId = addVstModule(formatManager, vstDesc, logicalId);
    
    if (nodeId.uid != 0)
        commitChanges();
    
    return nodeId;
}

void ModularSynthProcessor::removeModule(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;
    const juce::ScopedLock lock(moduleLock); // Ensure thread-safe access

    // --- LOGGING ---
    if (auto* node = internalGraph->getNodeForId(nodeID))
    {
        if (auto* proc = node->getProcessor())
        {
            juce::Logger::writeToLog("[GraphSync] Deleting module L-ID " + juce::String(getLogicalIdForNode(nodeID)) + 
                                   " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
        }
    }
    // --- END LOGGING ---

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    internalGraph->removeNode(nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    
    modules.erase((juce::uint32) nodeID.uid);
    if (logicalId != 0)
    {
        logicalIdToModule.erase(logicalId);
    }
}

bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            juce::Logger::writeToLog("[ModSynth][INFO] Skipping duplicate connection [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                     + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
            return true;
        }
    }

    const bool ok = internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
    if (! ok)
    {
        juce::Logger::writeToLog("[ModSynth][WARN] Failed to connect [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                 + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
    }
    return ok;
}

void ModularSynthProcessor::commitChanges()
{
    internalGraph->rebuild();
    
    if (getSampleRate() > 0 && getBlockSize() > 0)
    {
        internalGraph->prepareToPlay(getSampleRate(), getBlockSize());
    }

    juce::Logger::writeToLog("--- Modular Synth Internal Patch State ---");
    juce::Logger::writeToLog("Num Nodes: " + juce::String(internalGraph->getNodes().size()));
    juce::Logger::writeToLog("Num Connections: " + juce::String(internalGraph->getConnections().size()));
    for (const auto& node : internalGraph->getNodes())
    {
        auto* p = node->getProcessor();
        juce::String name = p ? p->getName() : juce::String("<null>");
        const int ins  = p ? p->getTotalNumInputChannels()  : -1;
        const int outs = p ? p->getTotalNumOutputChannels() : -1;
        juce::Logger::writeToLog("  Node: id=" + juce::String(node->nodeID.uid) + " name='" + name + "' ins=" + juce::String(ins) + " outs=" + juce::String(outs));
    }
    for (const auto& conn : internalGraph->getConnections())
    {
        juce::Logger::writeToLog("  Connection: [" + juce::String(conn.source.nodeID.uid) + ":" + juce::String(conn.source.channelIndex)
            + "] -> [" + juce::String(conn.destination.nodeID.uid) + ":" + juce::String(conn.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog("-----------------------------------------");
    
    for (const auto& kv : logicalIdToModule)
    {
        if (ModuleProcessor* mp = getModuleForLogical(kv.first))
        {
            mp->setLogicalId(kv.first);
        }
    }
    
    // --- FINAL THREAD-SAFE FIX: Rebuild the list of active processors for the audio thread ---
    auto newProcessors = std::make_shared<std::vector<std::shared_ptr<ModuleProcessor>>>();
    {
        const juce::ScopedLock lock(moduleLock);
        newProcessors->reserve(logicalIdToModule.size());
        juce::Logger::writeToLog("[GraphSync] Building new processor list...");
        for (const auto& pair : logicalIdToModule)
        {
            // Find the Node::Ptr from the modules map
            auto modIt = modules.find((juce::uint32)pair.second.nodeID.uid);
            if (modIt != modules.end())
            {
                auto nodePtr = modIt->second; // This is a Node::Ptr (shared_ptr<Node>)
                if (auto* proc = dynamic_cast<ModuleProcessor*>(nodePtr->getProcessor()))
                {
                    // Create a shared_ptr to the processor with a custom deleter that keeps the Node alive
                    auto processor = std::shared_ptr<ModuleProcessor>(proc, [nodePtr](ModuleProcessor*) {
                        // Custom deleter: just hold the nodePtr, don't actually delete the processor
                        // When this shared_ptr is destroyed, the nodePtr will be released
                    });
                    newProcessors->push_back(processor);
                    juce::Logger::writeToLog("  [+] Adding module L-ID " + juce::String(pair.first) + 
                                           " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
                }
            }
        }
    }
    activeAudioProcessors.store(newProcessors);
    juce::Logger::writeToLog("[GraphSync] Updated active processor list for audio thread with " + juce::String(newProcessors->size()) + " modules.");
}

void ModularSynthProcessor::clearAll()
{
    const juce::ScopedLock lock (moduleLock);
    
    // --- LOGGING ---
    juce::Logger::writeToLog("[GraphSync] clearAll() initiated - removing " + juce::String(logicalIdToModule.size()) + " modules");
    // --- END LOGGING ---
    
    for (const auto& kv : logicalIdToModule)
    {
        internalGraph->removeNode(kv.second.nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    }

    modules.clear();
    logicalIdToModule.clear();
    nextLogicalId = 1;

    commitChanges();
}

void ModularSynthProcessor::clearAllConnections()
{
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex && 
            conn.destination.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearOutputConnections()
{
    if (audioOutputNode == nullptr)
        return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == audioOutputNode->nodeID)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearConnectionsForNode(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == nodeID || conn.destination.nodeID == nodeID)
        {
            if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
            {
                internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            }
        }
    }

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    commitChanges();
}

void ModularSynthProcessor::setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap)
{
    if (audioInputNode == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] setAudioInputChannelMapping called but main audioInputNode is null.");
        return;
    }

    juce::String mapStr;
    for (int i = 0; i < (int)channelMap.size(); ++i)
    {
        if (i > 0) mapStr += ", ";
        mapStr += juce::String(channelMap[i]);
    }
    juce::Logger::writeToLog("[ModSynth] Remapping Audio Input Module " + juce::String(audioInputNodeId.uid) +
                             " to channels: [" + mapStr + "]");

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == audioInputNode->nodeID && conn.destination.nodeID == audioInputNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }

    for (int moduleChannel = 0; moduleChannel < (int)channelMap.size(); ++moduleChannel)
    {
        int hardwareChannel = channelMap[moduleChannel];
        internalGraph->addConnection({ { audioInputNode->nodeID, hardwareChannel }, { audioInputNodeId, moduleChannel } }, 
                                     juce::AudioProcessorGraph::UpdateKind::none);
    }

    commitChanges();
}

std::vector<std::pair<juce::uint32, juce::String>> ModularSynthProcessor::getModulesInfo() const
{
    const juce::ScopedLock lock (moduleLock);
    std::vector<std::pair<juce::uint32, juce::String>> out;
    out.reserve(logicalIdToModule.size());
    for (const auto& kv : logicalIdToModule)
        out.emplace_back(kv.first, kv.second.type);
    return out;
}

juce::AudioProcessorGraph::NodeID ModularSynthProcessor::getNodeIdForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return {};
    return it->second.nodeID;
}

juce::uint32 ModularSynthProcessor::getLogicalIdForNode (const NodeID& nodeId) const
{
    const juce::ScopedLock lock (moduleLock);
    for (const auto& kv : logicalIdToModule)
        if (kv.second.nodeID == nodeId)
            return kv.first;
    return 0;
}

bool ModularSynthProcessor::disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };
    return internalGraph->removeConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}

std::vector<ModularSynthProcessor::ConnectionInfo> ModularSynthProcessor::getConnectionsInfo() const
{
    std::vector<ConnectionInfo> out;
    for (const auto& c : internalGraph->getConnections())
    {
        ConnectionInfo info;
        info.srcLogicalId = getLogicalIdForNode(c.source.nodeID);
        info.srcChan = c.source.channelIndex;
        info.dstLogicalId = getLogicalIdForNode(c.destination.nodeID);
        info.dstChan = c.destination.channelIndex;
        info.dstIsOutput = (c.destination.nodeID == audioOutputNode->nodeID);
        if (info.srcLogicalId != 0 && (info.dstLogicalId != 0 || info.dstIsOutput))
            out.push_back(info);
    }
    return out;
}


ModuleProcessor* ModularSynthProcessor::getModuleForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return nullptr;
    if (auto* node = internalGraph->getNodeForId(it->second.nodeID))
        return dynamic_cast<ModuleProcessor*>(node->getProcessor());
    return nullptr;
}

juce::String ModularSynthProcessor::getModuleTypeForLogical(juce::uint32 logicalId) const
{
    auto it = logicalIdToModule.find(logicalId);
    if (it != logicalIdToModule.end())
    {
        return it->second.type;
    }
    return {};
}

// === COMPREHENSIVE DIAGNOSTICS SYSTEM ===

juce::String ModularSynthProcessor::getSystemDiagnostics() const
{
    juce::String result = "=== MODULAR SYNTH SYSTEM DIAGNOSTICS ===\n\n";
    
    result += "Total Modules: " + juce::String((int)logicalIdToModule.size()) + "\n";
    result += "Next Logical ID: " + juce::String((int)nextLogicalId) + "\n\n";
    
    result += "=== MODULES ===\n";
    for (const auto& pair : logicalIdToModule)
    {
        result += "Logical ID " + juce::String((int)pair.first) + ": " + pair.second.type + 
                 " (Node ID: " + juce::String((int)pair.second.nodeID.uid) + ")\n";
    }
    result += "\n";
    
    result += getConnectionDiagnostics() + "\n";
    
    result += "=== GRAPH STATE ===\n";
    result += "Total Nodes: " + juce::String(internalGraph->getNumNodes()) + "\n";
    result += "Total Connections: (not available)\n";
    
    return result;
}

juce::String ModularSynthProcessor::getModuleDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (module)
    {
        return module->getAllDiagnostics();
    }
    else
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
}

juce::String ModularSynthProcessor::getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (!module)
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
    
    juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
    result += "Module: " + module->getName() + "\n\n";
    
    auto params = module->getParameters();
    
    for (int i = 0; i < params.size(); ++i)
    {
        auto* param = params[i];
        if (auto* paramWithId = dynamic_cast<juce::AudioProcessorParameterWithID*>(param))
        {
            int busIndex, channelIndex;
            if (module->getParamRouting(paramWithId->paramID, busIndex, channelIndex))
            {
                int absoluteChannel = module->getChannelIndexInProcessBlockBuffer(true, busIndex, channelIndex);
                result += "  \"" + paramWithId->paramID + "\" -> Bus " + juce::String(busIndex) + 
                         ", Channel " + juce::String(channelIndex) + " (Absolute: " + juce::String(absoluteChannel) + ")\n";
            }
            else
            {
                result += "  \"" + paramWithId->paramID + "\" -> NO ROUTING\n";
            }
        }
    }
    
    return result;
}

juce::String ModularSynthProcessor::getConnectionDiagnostics() const
{
    juce::String result = "=== CONNECTIONS ===\n";
    
    auto connections = getConnectionsInfo();
    for (const auto& conn : connections)
    {
        result += "Logical " + juce::String((int)conn.srcLogicalId) + ":" + juce::String(conn.srcChan) + 
                 " -> ";
        
        if (conn.dstIsOutput)
        {
            result += "OUTPUT:" + juce::String(conn.dstChan);
        }
        else
        {
            result += "Logical " + juce::String((int)conn.dstLogicalId) + ":" + juce::String(conn.dstChan);
        }
        result += "\n";
    }
    
    if (connections.empty())
    {
        result += "No connections found.\n";
    }
    
    return result;
}

bool ModularSynthProcessor::isAnyModuleRecording() const
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            if (recorder->getIsRecording())
                return true;
        }
    }
    return false;
}

void ModularSynthProcessor::pauseAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->pauseRecording();
        }
    }
}

void ModularSynthProcessor::resumeAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->resumeRecording();
        }
    }
}

void ModularSynthProcessor::startAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStartRecording();
        }
    }
}

void ModularSynthProcessor::stopAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStopRecording();
        }
    }
}

// === VOICE MANAGEMENT IMPLEMENTATION ===

int ModularSynthProcessor::findFreeVoice()
{
    for (int i = 0; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (!m_voices[i].isActive)
            return i;
    }
    return -1;
}

int ModularSynthProcessor::findOldestVoice()
{
    if (m_voices.empty())
        return -1;
    
    int oldestIndex = 0;
    juce::uint32 oldestAge = m_voices[0].age;
    
    for (int i = 1; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (m_voices[i].age < oldestAge)
        {
            oldestAge = m_voices[i].age;
            oldestIndex = i;
        }
    }
    
    return oldestIndex;
}

void ModularSynthProcessor::assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn)
{
    if (voiceIndex < 0 || voiceIndex >= static_cast<int>(m_voices.size()))
        return;
    
    Voice& voice = m_voices[voiceIndex];
    voice.isActive = true;
    voice.noteNumber = noteOn.getNoteNumber();
    voice.velocity = noteOn.getFloatVelocity();
    voice.age = m_globalVoiceAge++;
    
    juce::Logger::writeToLog("[VoiceManager] Assigned note " + juce::String(voice.noteNumber) + 
                            " to voice " + juce::String(voiceIndex));
}

void ModularSynthProcessor::releaseVoice(const juce::MidiMessage& noteOff)
{
    int noteNumber = noteOff.getNoteNumber();
    
    for (auto& voice : m_voices)
    {
        if (voice.isActive && voice.noteNumber == noteNumber)
        {
            voice.isActive = false;
            voice.noteNumber = -1;
            juce::Logger::writeToLog("[VoiceManager] Released note " + juce::String(noteNumber));
            return;
        }
    }
}

// === PROBE TOOL IMPLEMENTATION ===

void ModularSynthProcessor::setProbeConnection(const NodeID& sourceNodeID, int sourceChannel)
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
    {
        juce::Logger::writeToLog("[PROBE] ERROR: Probe scope not initialized!");
        return;
    }
    
    juce::Logger::writeToLog("[PROBE] setProbeConnection called. Source NodeID: " + juce::String(sourceNodeID.uid) + ", Channel: " + juce::String(sourceChannel));
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            juce::Logger::writeToLog("[PROBE] Cleared old probe connection.");
        }
    }
    
    bool success = connect(sourceNodeID, sourceChannel, probeScopeNodeId, 0);
    juce::Logger::writeToLog("[PROBE] New connection attempt " + juce::String(success ? "succeeded." : "FAILED."));
    if (success)
    {
        juce::Logger::writeToLog("[Probe] Successfully connected to probe scope");
    }
    else
    {
        juce::Logger::writeToLog("[Probe] ERROR: Failed to connect to probe scope");
    }
    
    commitChanges();
}

void ModularSynthProcessor::clearProbeConnection()
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
        return;
    
    juce::Logger::writeToLog("[PROBE] clearProbeConnection called.");
    bool cleared = false;
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            cleared = true;
        }
    }
    
    if (cleared) {
        juce::Logger::writeToLog("[PROBE] Cleared active probe connection.");
        commitChanges();
    } else {
        juce::Logger::writeToLog("[PROBE] No active probe connection to clear.");
    }
}

ModuleProcessor* ModularSynthProcessor::getProbeScopeProcessor() const
{
    if (!probeScopeNode)
        return nullptr;
    
    return dynamic_cast<ModuleProcessor*>(probeScopeNode->getProcessor());
}
