
================================================================================
FILE: juce\Source\audio\modules\HarmonicShaperModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include <array>

class HarmonicShaperModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int NUM_OSCILLATORS = 8;

    // --- Parameter IDs ---
    static constexpr auto paramIdMasterFreq   = "masterFrequency";
    static constexpr auto paramIdMasterDrive  = "masterDrive";
    static constexpr auto paramIdOutputGain   = "outputGain";
    static constexpr auto paramIdMix          = "mix";
    static constexpr auto paramIdCharacter    = "character"; // Controls modulation intensity
    static constexpr auto paramIdSmoothness   = "smoothness"; // Carrier smoothing
    // Modulation targets
    static constexpr auto paramIdMasterFreqMod = "masterFrequency_mod";
    static constexpr auto paramIdMasterDriveMod = "masterDrive_mod";
    static constexpr auto paramIdOutputGainMod = "outputGain_mod";
    static constexpr auto paramIdMixMod = "mix_mod";
    static constexpr auto paramIdCharacterMod = "character_mod";
    static constexpr auto paramIdSmoothnessMod = "smoothness_mod";

    HarmonicShaperModuleProcessor();
    ~HarmonicShaperModuleProcessor() override = default;

    const juce::String getName() const override { return "harmonic_shaper"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String&)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
#endif

    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    
    std::vector<DynamicPinInfo> getDynamicInputPins() const override;
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    juce::AudioProcessorValueTreeState apvts;

    std::array<juce::dsp::Oscillator<float>, NUM_OSCILLATORS> oscillators;
    std::array<int, NUM_OSCILLATORS> currentWaveforms;

    // --- Cached Parameter Pointers ---
    std::atomic<float>* masterFreqParam { nullptr };
    std::atomic<float>* masterDriveParam { nullptr };
    std::atomic<float>* outputGainParam { nullptr };
    std::atomic<float>* mixParam { nullptr };
    std::atomic<float>* characterParam { nullptr };
    std::atomic<float>* smoothnessParam { nullptr };
    std::array<std::atomic<float>*, NUM_OSCILLATORS> ratioParams;
    std::array<std::atomic<float>*, NUM_OSCILLATORS> detuneParams;
    std::array<std::atomic<float>*, NUM_OSCILLATORS> waveformParams;
    std::array<std::atomic<float>*, NUM_OSCILLATORS> driveParams;
    std::array<std::atomic<float>*, NUM_OSCILLATORS> levelParams;

    // --- Smoothed Values for Zipper-Free Modulation ---
    juce::SmoothedValue<float> smoothedMasterFreq;
    juce::SmoothedValue<float> smoothedMasterDrive;
    juce::SmoothedValue<float> smoothedCarrier; // Smooth carrier to reduce harshness
    
    // Relative modulation parameters
    std::atomic<float>* relativeFreqModParam { nullptr };
    std::atomic<float>* relativeDriveModParam { nullptr };
    std::atomic<float>* relativeGainModParam { nullptr };
    std::atomic<float>* relativeMixModParam { nullptr };
    std::atomic<float>* relativeCharacterModParam { nullptr };
    std::atomic<float>* relativeSmoothnessModParam { nullptr };

    // --- Visualization Data (thread-safe, updated from audio thread) ---
    struct VizData
    {
        static constexpr int waveformPoints = 128;
        std::array<std::atomic<float>, NUM_OSCILLATORS> oscillatorLevels; // Current level (0-1)
        std::array<std::atomic<float>, NUM_OSCILLATORS> oscillatorFrequencies; // Current frequency in Hz
        std::array<std::atomic<int>, NUM_OSCILLATORS> oscillatorWaveforms; // Current waveform (0-3)
        std::array<std::atomic<float>, waveformPoints> combinedWaveform; // Combined carrier waveform
        std::atomic<float> masterFrequency { 440.0f };
        std::atomic<float> masterDrive { 0.5f };
    };
    VizData vizData;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(HarmonicShaperModuleProcessor);
};



================================================================================
FILE: juce\Source\audio\modules\HarmonicShaperModuleProcessor.cpp
================================================================================


#include "HarmonicShaperModuleProcessor.h"
#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/theme/ThemeManager.h"
#endif

juce::AudioProcessorValueTreeState::ParameterLayout HarmonicShaperModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    // --- Global Parameters ---
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdMasterFreq, "Master Frequency",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 440.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdMasterDrive, "Master Drive", 0.0f, 1.0f, 0.2f)); // Lower default
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdOutputGain, "Output Gain",
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.001f, 0.5f), 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdMix, "Mix", 0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdCharacter, "Character",
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.001f, 0.5f), 0.3f)); // Controls modulation intensity
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSmoothness, "Smoothness",
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.001f, 0.5f), 0.5f)); // Carrier smoothing

    // --- Per-Oscillator Parameters ---
    for (int i = 0; i < NUM_OSCILLATORS; ++i)
    {
        auto idx = juce::String(i + 1);
        params.push_back(std::make_unique<juce::AudioParameterFloat>("ratio_" + idx, "Ratio " + idx,
            juce::NormalisableRange<float>(0.125f, 16.0f, 0.001f, 0.25f), (float)(i + 1)));
        params.push_back(std::make_unique<juce::AudioParameterFloat>("detune_" + idx, "Detune " + idx, -100.0f, 100.0f, 0.0f));
        params.push_back(std::make_unique<juce::AudioParameterChoice>("waveform_" + idx, "Waveform " + idx,
            juce::StringArray{ "Sine", "Saw", "Square", "Triangle" }, 0));
        params.push_back(std::make_unique<juce::AudioParameterFloat>("drive_" + idx, "Drive " + idx, 0.0f, 1.0f, 0.5f));
        params.push_back(std::make_unique<juce::AudioParameterFloat>("level_" + idx, "Level " + idx, 0.0f, 1.0f, i == 0 ? 1.0f : 0.0f));
    }
    
    // Relative modulation parameters
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeFreqMod", "Relative Freq Mod", true));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeDriveMod", "Relative Drive Mod", true));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeGainMod", "Relative Gain Mod", true));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeMixMod", "Relative Mix Mod", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeCharacterMod", "Relative Character Mod", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeSmoothnessMod", "Relative Smoothness Mod", false));

    return { params.begin(), params.end() };
}

HarmonicShaperModuleProcessor::HarmonicShaperModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(8), true) // Audio L/R, Freq Mod, Drive Mod, Gain Mod, Mix Mod, Character Mod, Smoothness Mod
        .withOutput("Audio Out", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "HarmonicShaperParams", createParameterLayout())
{
    // Cache global parameter pointers
    masterFreqParam = apvts.getRawParameterValue(paramIdMasterFreq);
    masterDriveParam = apvts.getRawParameterValue(paramIdMasterDrive);
    outputGainParam = apvts.getRawParameterValue(paramIdOutputGain);
    mixParam = apvts.getRawParameterValue(paramIdMix);
    characterParam = apvts.getRawParameterValue(paramIdCharacter);
    smoothnessParam = apvts.getRawParameterValue(paramIdSmoothness);

    // Initialize oscillators and cache per-oscillator parameter pointers
    for (int i = 0; i < NUM_OSCILLATORS; ++i)
    {
        oscillators[i].initialise([](float x) { return std::sin(x); }, 128);
        currentWaveforms[i] = -1; // Force initial waveform setup

        auto idx = juce::String(i + 1);
        ratioParams[i] = apvts.getRawParameterValue("ratio_" + idx);
        detuneParams[i] = apvts.getRawParameterValue("detune_" + idx);
        waveformParams[i] = apvts.getRawParameterValue("waveform_" + idx);
        driveParams[i] = apvts.getRawParameterValue("drive_" + idx);
        levelParams[i] = apvts.getRawParameterValue("level_" + idx);
    }
    
    relativeFreqModParam = apvts.getRawParameterValue("relativeFreqMod");
    relativeDriveModParam = apvts.getRawParameterValue("relativeDriveMod");
    relativeGainModParam = apvts.getRawParameterValue("relativeGainMod");
    relativeMixModParam = apvts.getRawParameterValue("relativeMixMod");
    relativeCharacterModParam = apvts.getRawParameterValue("relativeCharacterMod");
    relativeSmoothnessModParam = apvts.getRawParameterValue("relativeSmoothnessMod");

    // Initialize visualization data
    for (auto& level : vizData.oscillatorLevels) level.store(0.0f);
    for (auto& freq : vizData.oscillatorFrequencies) freq.store(0.0f);
    for (auto& wave : vizData.oscillatorWaveforms) wave.store(0);
    for (auto& wf : vizData.combinedWaveform) wf.store(0.0f);
}

void HarmonicShaperModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec{ sampleRate, (juce::uint32)samplesPerBlock, 1 };
    for (auto& osc : oscillators)
    {
        osc.prepare(spec);
    }
    smoothedMasterFreq.reset(sampleRate, 0.02);
    smoothedMasterDrive.reset(sampleRate, 0.02);
    smoothedCarrier.reset(sampleRate, 0.01); // Fast smoothing for carrier
}

void HarmonicShaperModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);

    auto inBus = getBusBuffer(buffer, true, 0);
    auto outBus = getBusBuffer(buffer, false, 0);

    const int numSamples = buffer.getNumSamples();

    // Get modulation CVs
    // IMPORTANT: Acquire input pointers BEFORE any output operations (aliasing-safe)
    const bool isFreqMod = isParamInputConnected(paramIdMasterFreqMod);
    const bool isDriveMod = isParamInputConnected(paramIdMasterDriveMod);
    const bool isGainMod = isParamInputConnected(paramIdOutputGainMod);
    const bool isMixMod = isParamInputConnected(paramIdMixMod);
    const bool isCharacterMod = isParamInputConnected(paramIdCharacterMod);
    const bool isSmoothnessMod = isParamInputConnected(paramIdSmoothnessMod);

    const float* freqCVPtr = (isFreqMod && inBus.getNumChannels() > 2) ? inBus.getReadPointer(2) : nullptr;
    const float* driveCVPtr = (isDriveMod && inBus.getNumChannels() > 3) ? inBus.getReadPointer(3) : nullptr;
    const float* gainCVPtr = (isGainMod && inBus.getNumChannels() > 4) ? inBus.getReadPointer(4) : nullptr;
    const float* mixCVPtr = (isMixMod && inBus.getNumChannels() > 5) ? inBus.getReadPointer(5) : nullptr;
    const float* characterCVPtr = (isCharacterMod && inBus.getNumChannels() > 6) ? inBus.getReadPointer(6) : nullptr;
    const float* smoothnessCVPtr = (isSmoothnessMod && inBus.getNumChannels() > 7) ? inBus.getReadPointer(7) : nullptr;

    // Debug: Always log first call to see what's happening
    {
        static bool firstCall = true;
        if (firstCall) {
            firstCall = false;
            auto ptrToHex = [](const void* ptr) -> juce::String {
                if (!ptr) return "NULL";
                char buf[32];
                snprintf(buf, sizeof(buf), "%p", ptr);
                return juce::String(buf);
            };
            
            juce::Logger::writeToLog("[HarmonicShaper][FIRST CALL] inBusChannels=" + juce::String(inBus.getNumChannels()));
            
            juce::String ptrMsg = "[HarmonicShaper][POINTERS] ";
            ptrMsg += "freqPtr=" + ptrToHex(freqCVPtr) + " ";
            ptrMsg += "drivePtr=" + ptrToHex(driveCVPtr) + " ";
            ptrMsg += "gainPtr=" + ptrToHex(gainCVPtr) + " ";
            ptrMsg += "mixPtr=" + ptrToHex(mixCVPtr) + " ";
            ptrMsg += "charPtr=" + ptrToHex(characterCVPtr) + " ";
            ptrMsg += "smoothPtr=" + ptrToHex(smoothnessCVPtr);
            juce::Logger::writeToLog(ptrMsg);
            
            // Check raw channel pointers and values
            juce::String rawMsg = "[HarmonicShaper][RAW CH] ";
            for (int ch = 2; ch < inBus.getNumChannels() && ch < 8; ++ch) {
                const float* rawPtr = inBus.getReadPointer(ch);
                rawMsg += "ch" + juce::String(ch) + ":ptr=" + ptrToHex(rawPtr);
                if (rawPtr) rawMsg += ":val=" + juce::String(rawPtr[0], 3);
                rawMsg += " ";
            }
            juce::Logger::writeToLog(rawMsg);
        }
    }

    // EXTRA SAFETY: Copy CV channels we use into local buffers BEFORE any output writes,
    // so later writes cannot affect reads even if buffers alias (see DEBUG_INPUT_IMPORTANT.md).
    juce::HeapBlock<float> freqCV, driveCV, gainCV, mixCV, characterCV, smoothnessCV;
    if (freqCVPtr)      { freqCV.malloc(numSamples);      std::memcpy(freqCV.get(),      freqCVPtr,      sizeof(float) * (size_t)numSamples); }
    if (driveCVPtr)     { driveCV.malloc(numSamples);     std::memcpy(driveCV.get(),     driveCVPtr,     sizeof(float) * (size_t)numSamples); }
    if (gainCVPtr)      { gainCV.malloc(numSamples);       std::memcpy(gainCV.get(),      gainCVPtr,      sizeof(float) * (size_t)numSamples); }
    if (mixCVPtr)       { mixCV.malloc(numSamples);        std::memcpy(mixCV.get(),       mixCVPtr,       sizeof(float) * (size_t)numSamples); }
    if (characterCVPtr) { characterCV.malloc(numSamples);  std::memcpy(characterCV.get(), characterCVPtr,  sizeof(float) * (size_t)numSamples); }
    if (smoothnessCVPtr){ smoothnessCV.malloc(numSamples); std::memcpy(smoothnessCV.get(), smoothnessCVPtr, sizeof(float) * (size_t)numSamples); }

    // Debug: Log copied values to verify they're different
    {
        static bool firstCopy = true;
        if (firstCopy) {
            firstCopy = false;
            juce::String copyMsg = "[HarmonicShaper][COPIED VALUES] ";
            if (freqCV.get())      copyMsg += "freq=" + juce::String(freqCV[0], 3) + " ";
            if (driveCV.get())     copyMsg += "drive=" + juce::String(driveCV[0], 3) + " ";
            if (gainCV.get())      copyMsg += "gain=" + juce::String(gainCV[0], 3) + " ";
            if (mixCV.get())       copyMsg += "mix=" + juce::String(mixCV[0], 3) + " ";
            if (characterCV.get()) copyMsg += "char=" + juce::String(characterCV[0], 3) + " ";
            if (smoothnessCV.get()) copyMsg += "smooth=" + juce::String(smoothnessCV[0], 3) + " ";
            juce::Logger::writeToLog(copyMsg);
        }
    }

    // ✅ NOW safe to get output write pointers (CV data is safely copied)
    auto* outL = outBus.getWritePointer(0);
    auto* outR = outBus.getNumChannels() > 1 ? outBus.getWritePointer(1) : outL;
    
    const float* inL = inBus.getReadPointer(0);
    const float* inR = inBus.getNumChannels() > 1 ? inBus.getReadPointer(1) : inL;

    const float baseFrequency = masterFreqParam->load();
    const float baseMasterDrive = masterDriveParam->load();
    const float baseOutputGain = outputGainParam->load();
    const float baseMix = mixParam->load();
    const float baseCharacter = characterParam->load();
    const float baseSmoothness = smoothnessParam->load();
    
    const bool relativeFreqMode = relativeFreqModParam && relativeFreqModParam->load() > 0.5f;
    const bool relativeDriveMode = relativeDriveModParam && relativeDriveModParam->load() > 0.5f;
    const bool relativeGainMode = relativeGainModParam && relativeGainModParam->load() > 0.5f;
    const bool relativeMixMode = relativeMixModParam && relativeMixModParam->load() > 0.5f;
    const bool relativeCharacterMode = relativeCharacterModParam && relativeCharacterModParam->load() > 0.5f;
    const bool relativeSmoothnessMode = relativeSmoothnessModParam && relativeSmoothnessModParam->load() > 0.5f;

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        // === 1. Calculate Global Modulated Parameters (per-sample) ===
        float currentMasterFreq = baseFrequency;
        if (freqCV.get()) {
            const float cv = juce::jlimit(0.0f, 1.0f, freqCV[i]);
            if (relativeFreqMode) {
                // RELATIVE: ±4 octaves around base frequency
                const float octaveOffset = (cv - 0.5f) * 8.0f;
                currentMasterFreq = baseFrequency * std::pow(2.0f, octaveOffset);
            } else {
                // ABSOLUTE: CV directly sets frequency (20-20000 Hz)
                const float spanOct = std::log2(20000.0f / 20.0f);
                currentMasterFreq = 20.0f * std::pow(2.0f, cv * spanOct);
            }
            currentMasterFreq = juce::jlimit(20.0f, 20000.0f, currentMasterFreq);
        }
        smoothedMasterFreq.setTargetValue(currentMasterFreq);

        float currentMasterDrive = baseMasterDrive;
        if (driveCV.get()) {
            const float cv = juce::jlimit(0.0f, 1.0f, driveCV[i]);
            if (relativeDriveMode) {
                // RELATIVE: ±0.5 offset
                const float offset = (cv - 0.5f) * 1.0f;
                currentMasterDrive = baseMasterDrive + offset;
            } else {
                // ABSOLUTE: CV directly sets drive
                currentMasterDrive = cv;
            }
            currentMasterDrive = juce::jlimit(0.0f, 1.0f, currentMasterDrive);
        }
        smoothedMasterDrive.setTargetValue(currentMasterDrive);
        
        // === 2. Generate and Sum the 8 Oscillators ===
        float carrierSample = 0.0f;
        const float smoothedFreq = smoothedMasterFreq.getNextValue();
        const float smoothedDrive = smoothedMasterDrive.getNextValue();

        for (int osc = 0; osc < NUM_OSCILLATORS; ++osc)
        {
            const float level = levelParams[osc]->load();
            if (level <= 0.001f) continue; // Skip silent oscillators

            const int waveform = (int)waveformParams[osc]->load();
            if (currentWaveforms[osc] != waveform)
            {
                if (waveform == 0)      oscillators[osc].initialise([](float x) { return std::sin(x); });
                else if (waveform == 1) oscillators[osc].initialise([](float x) { return x / juce::MathConstants<float>::pi; });
                else if (waveform == 2) oscillators[osc].initialise([](float x) { return x < 0.0f ? -1.0f : 1.0f; });
                else                    oscillators[osc].initialise([](float x) { return 2.0f / juce::MathConstants<float>::pi * std::asin(std::sin(x)); });
                currentWaveforms[osc] = waveform;
            }

            const float frequency = smoothedFreq * ratioParams[osc]->load() + detuneParams[osc]->load();
            oscillators[osc].setFrequency(juce::jlimit(1.0f, (float)getSampleRate() * 0.5f, frequency), true);

            const float oscSample = oscillators[osc].processSample(0.0f);
            const float drive = driveParams[osc]->load() * smoothedDrive;
            // Gentler drive curve: reduce max amplification from 10x to 4x, use smoother curve
            const float driveAmount = 1.0f + drive * 3.0f; // Max 4x instead of 10x
            // Use a gentler saturation curve
            const float driven = oscSample * driveAmount;
            const float shapedSample = driven / (1.0f + std::abs(driven)); // Softer saturation than tanh
            carrierSample += shapedSample * level;
        }

        // Gentle normalization instead of hard clipping
        const float carrierNorm = carrierSample / (1.0f + std::abs(carrierSample) * 0.5f);
        
        // === 2.5. Calculate Modulated Parameters (per-sample) - Smoothness first as it's needed for carrier smoothing ===
        float currentSmoothness = baseSmoothness;
        if (smoothnessCV.get()) {
            const float cv = juce::jlimit(0.0f, 1.0f, smoothnessCV[i]);
            if (relativeSmoothnessMode) {
                // RELATIVE: ±0.5 around base smoothness
                const float offset = (cv - 0.5f) * 1.0f;
                currentSmoothness = baseSmoothness + offset;
            } else {
                // ABSOLUTE: CV directly sets smoothness (0-1)
                currentSmoothness = cv;
            }
            currentSmoothness = juce::jlimit(0.0f, 1.0f, currentSmoothness);
        }
        
        // Apply smoothing to carrier to reduce harshness
        const float smoothness = currentSmoothness;
        // Update smoothing time only when smoothness changes (not every sample)
        static float lastSmoothness = -1.0f;
        if (std::abs(smoothness - lastSmoothness) > 0.01f)
        {
            const float smoothingTime = 0.001f + smoothness * 0.01f; // 1-11ms based on smoothness
            smoothedCarrier.reset(getSampleRate(), smoothingTime);
            lastSmoothness = smoothness;
        }
        smoothedCarrier.setTargetValue(carrierNorm);
        const float smoothedCarrierValue = smoothedCarrier.getNextValue();
        
        // Calculate other modulated parameters
        float currentOutputGain = baseOutputGain;
        if (gainCV.get()) {
            const float cv = juce::jlimit(0.0f, 1.0f, gainCV[i]);
            if (relativeGainMode) {
                // RELATIVE: ±0.5 around base gain
                const float offset = (cv - 0.5f) * 1.0f;
                currentOutputGain = baseOutputGain + offset;
            } else {
                // ABSOLUTE: CV directly sets gain (0-1)
                currentOutputGain = cv;
            }
            currentOutputGain = juce::jlimit(0.0f, 1.0f, currentOutputGain);
        }

        float currentMix = baseMix;
        if (mixCV.get()) {
            const float cv = juce::jlimit(0.0f, 1.0f, mixCV[i]);
            if (relativeMixMode) {
                // RELATIVE: ±0.5 around base mix
                const float offset = (cv - 0.5f) * 1.0f;
                currentMix = baseMix + offset;
            } else {
                // ABSOLUTE: CV directly sets mix (0-1)
                currentMix = cv;
            }
            currentMix = juce::jlimit(0.0f, 1.0f, currentMix);
        }

        float currentCharacter = baseCharacter;
        if (characterCV.get()) {
            const float cv = juce::jlimit(0.0f, 1.0f, characterCV[i]);
            if (relativeCharacterMode) {
                // RELATIVE: ±0.5 around base character
                const float offset = (cv - 0.5f) * 1.0f;
                currentCharacter = baseCharacter + offset;
            } else {
                // ABSOLUTE: CV directly sets character (0-1)
                currentCharacter = cv;
            }
            currentCharacter = juce::jlimit(0.0f, 1.0f, currentCharacter);
        }

        // === 3. Modulate Input with Carrier and Apply Gain ===
        const float mix = currentMix;
        const float character = currentCharacter;
        
        // Gentler modulation: blend between ring mod and amplitude mod
        // Character=0: pure amplitude modulation (gentler)
        // Character=1: pure ring modulation (more aggressive)
        const float carrierForMod = 0.5f + smoothedCarrierValue * 0.5f; // Center around 0.5 for AM
        const float ringMod = inL[i] * smoothedCarrierValue;
        const float ampMod = inL[i] * carrierForMod;
        const float wetL = (ringMod * character + ampMod * (1.0f - character)) * currentOutputGain;
        
        const float carrierForModR = 0.5f + smoothedCarrierValue * 0.5f;
        const float ringModR = inR[i] * smoothedCarrierValue;
        const float ampModR = inR[i] * carrierForModR;
        const float wetR = (ringModR * character + ampModR * (1.0f - character)) * currentOutputGain;
        const float dryL = inL[i];
        const float dryR = inR[i];
        
        // Apply dry/wet mix
        outL[i] = dryL * (1.0f - mix) + wetL * mix;
        outR[i] = dryR * (1.0f - mix) + wetR * mix;

        // === 4. Update Visualization Data (Throttled - every 64 samples) ===
        if ((i & 63) == 0) {
            setLiveParamValue("masterFrequency_live", smoothedFreq);
            setLiveParamValue("masterDrive_live", smoothedDrive);
            
            // Update oscillator visualization data
            for (int osc = 0; osc < NUM_OSCILLATORS; ++osc)
            {
                const float level = levelParams[osc]->load();
                vizData.oscillatorLevels[osc].store(level);
                
                const float frequency = smoothedFreq * ratioParams[osc]->load() + detuneParams[osc]->load();
                vizData.oscillatorFrequencies[osc].store(frequency);
                
                const int waveform = (int)waveformParams[osc]->load();
                vizData.oscillatorWaveforms[osc].store(waveform);
            }
            
            // Update master parameters
            vizData.masterFrequency.store(smoothedFreq);
            vizData.masterDrive.store(smoothedDrive);
            
            // Update combined waveform preview (generate one cycle)
            if (i == 0) // Only update once per block
            {
                for (int p = 0; p < VizData::waveformPoints; ++p)
                {
                    float combined = 0.0f;
                    const float phase = (float)p / (float)VizData::waveformPoints * 2.0f * juce::MathConstants<float>::pi;
                    
                    for (int osc = 0; osc < NUM_OSCILLATORS; ++osc)
                    {
                        const float level = levelParams[osc]->load();
                        if (level <= 0.001f) continue;
                        
                        const float ratio = ratioParams[osc]->load();
                        const float detune = detuneParams[osc]->load();
                        const float oscFreq = smoothedFreq * ratio + detune;
                        const float oscPhase = phase * (oscFreq / smoothedFreq);
                        
                        const int waveform = (int)waveformParams[osc]->load();
                        float oscSample = 0.0f;
                        if (waveform == 0)      oscSample = std::sin(oscPhase);
                        else if (waveform == 1) oscSample = oscPhase / juce::MathConstants<float>::pi;
                        else if (waveform == 2) oscSample = (oscPhase < 0.0f) ? -1.0f : 1.0f;
                        else                    oscSample = 2.0f / juce::MathConstants<float>::pi * std::asin(std::sin(oscPhase));
                        
                        const float drive = driveParams[osc]->load() * smoothedDrive;
                        const float shaped = std::tanh(oscSample * (1.0f + drive * 9.0f));
                        combined += shaped * level;
                    }
                    combined = std::tanh(combined);
                    vizData.combinedWaveform[p].store(combined);
                }
            }
        }
    }
}

#if defined(PRESET_CREATOR_UI)

void HarmonicShaperModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String&)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    auto& ap = getAPVTS();
    
    auto HelpMarker = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) { ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f); ImGui::TextUnformatted(desc); ImGui::PopTextWrapPos(); ImGui::EndTooltip(); }
    };

    // === HARMONIC SPECTRUM VISUALIZATION ===
    ImGui::Spacing();
    ThemeText("Harmonic Spectrum", theme.text.section_header);
    ImGui::Spacing();

    auto* drawList = ImGui::GetWindowDrawList();
    const ImVec2 specOrigin = ImGui::GetCursorScreenPos();
    const float specWidth = itemWidth;
    const float specHeight = 80.0f;
    const ImVec2 specRectMax = ImVec2(specOrigin.x + specWidth, specOrigin.y + specHeight);
    
    // Get theme colors (with fallbacks like GranulatorModuleProcessor)
    auto& themeMgr = ThemeManager::getInstance();
    auto resolveColor = [&](ImU32 primary, ImU32 secondary, ImU32 tertiary) -> ImU32 {
        if (primary != 0) return primary;
        if (secondary != 0) return secondary;
        return tertiary;
    };
    
    const ImU32 canvasBg = themeMgr.getCanvasBackground();
    const ImVec4 childBgVec4 = ImGui::GetStyle().Colors[ImGuiCol_ChildBg];
    const ImU32 childBg = ImGui::ColorConvertFloat4ToU32(childBgVec4);
    const ImU32 bgColor = resolveColor(theme.modules.scope_plot_bg, canvasBg, childBg);
    
    const ImVec4 frequencyColorVec4 = theme.modulation.frequency;
    const ImU32 barColor = ImGui::ColorConvertFloat4ToU32(frequencyColorVec4);
    const ImVec4 accentVec4 = theme.accent;
    const ImU32 barColorActive = ImGui::ColorConvertFloat4ToU32(accentVec4);
    const ImU32 textColor = ImGui::ColorConvertFloat4ToU32(theme.text.section_header);
    
    drawList->AddRectFilled(specOrigin, specRectMax, bgColor, 4.0f);
    ImGui::PushClipRect(specOrigin, specRectMax, true);
    
    // Read visualization data
    float levels[8];
    int waveforms[8];
    for (int i = 0; i < 8; ++i)
    {
        levels[i] = vizData.oscillatorLevels[i].load();
        waveforms[i] = vizData.oscillatorWaveforms[i].load();
    }
    
    // Draw 8 harmonic bars (clickable)
    const float barWidth = specWidth / 8.0f - 4.0f;
    const float barSpacing = 4.0f;
    const float maxBarHeight = specHeight - 20.0f; // Leave room for labels
    
    for (int i = 0; i < 8; ++i)
    {
        const float barX = specOrigin.x + i * (barWidth + barSpacing) + barSpacing;
        const float barHeight = levels[i] * maxBarHeight;
        const float barY = specOrigin.y + maxBarHeight - barHeight;
        
        // Color based on waveform
        ImU32 barCol = barColor;
        if (levels[i] > 0.001f)
        {
            switch (waveforms[i])
            {
                case 0: barCol = IM_COL32(100, 200, 255, 255); break; // Sine - blue
                case 1: barCol = IM_COL32(255, 150, 100, 255); break; // Saw - orange
                case 2: barCol = IM_COL32(255, 100, 150, 255); break; // Square - pink
                case 3: barCol = IM_COL32(150, 255, 150, 255); break; // Triangle - green
            }
        }
        else
        {
            barCol = IM_COL32(60, 60, 60, 255); // Dimmed
        }
        
        // Draw bar
        drawList->AddRectFilled(ImVec2(barX, barY), ImVec2(barX + barWidth, specOrigin.y + maxBarHeight), barCol, 2.0f);
        
        // Draw label
        const char* labels[] = { "1", "2", "3", "4", "5", "6", "7", "8" };
        const ImVec2 labelPos(barX + barWidth * 0.5f, specOrigin.y + maxBarHeight + 2.0f);
        drawList->AddText(labelPos, textColor, labels[i]);
        
        // Make bar clickable to adjust level, Ctrl+click to change waveform
        ImGui::SetCursorScreenPos(ImVec2(barX, specOrigin.y));
        ImGui::InvisibleButton(("##bar" + juce::String(i)).toRawUTF8(), ImVec2(barWidth, specHeight));
        
        // Ctrl+Click to cycle waveform
        if (ImGui::IsItemClicked(0) && ImGui::GetIO().KeyCtrl)
        {
            auto idx = juce::String(i + 1);
            int currentWave = (int)waveformParams[i]->load();
            int newWave = (currentWave + 1) % 4;
            if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("waveform_" + idx)))
                *p = newWave;
            onModificationEnded();
        }
        // Drag to adjust level
        else if (ImGui::IsItemActive() && ImGui::IsMouseDragging(0))
        {
            const float dragDelta = -ImGui::GetIO().MouseDelta.y / maxBarHeight;
            auto idx = juce::String(i + 1);
            float newLevel = juce::jlimit(0.0f, 1.0f, levels[i] + dragDelta);
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("level_" + idx)))
                *p = newLevel;
            onModificationEnded();
        }
    }
    
    ImGui::PopClipRect();
    ImGui::SetCursorScreenPos(ImVec2(specOrigin.x, specRectMax.y));
    ImGui::Dummy(ImVec2(specWidth, 0));
    ImGui::Spacing();

    // Hint about Ctrl+click
    ImGui::TextDisabled("Drag bars to adjust level | Ctrl+Click to change waveform");
    ImGui::Spacing();

    // === MASTER CONTROLS (COMPACT) ===
    ThemeText("Master Controls", theme.text.section_header);
    ImGui::Spacing();

    const bool freqIsMod = isParamModulated(paramIdMasterFreqMod);
    float freq = freqIsMod ? getLiveParamValueFor(paramIdMasterFreqMod, "masterFrequency_live", masterFreqParam->load()) : masterFreqParam->load();

    const bool driveIsMod = isParamModulated(paramIdMasterDriveMod);
    float drive = driveIsMod ? getLiveParamValueFor(paramIdMasterDriveMod, "masterDrive_live", masterDriveParam->load()) : masterDriveParam->load();

    float gain = outputGainParam->load();

    ImGui::PushItemWidth(itemWidth * 0.32f); // Three controls side by side

    // Master Frequency
    if (freqIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Freq", &freq, 20.0f, 20000.0f, "%.0f Hz", ImGuiSliderFlags_Logarithmic)) {
        if (!freqIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdMasterFreq))) *p = freq;
    }
    if (!freqIsMod) adjustParamOnWheel(ap.getParameter(paramIdMasterFreq), "masterFreqHz", freq);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (freqIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    // Master Drive
    ImGui::SameLine();
    if (driveIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Drive", &drive, 0.0f, 1.0f, "%.2f")) {
        if (!driveIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdMasterDrive))) *p = drive;
    }
    if (!driveIsMod) adjustParamOnWheel(ap.getParameter(paramIdMasterDrive), "masterDrive", drive);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (driveIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    // Output Gain
    ImGui::SameLine();
    if (ImGui::SliderFloat("Gain", &gain, 0.0f, 1.0f, "%.2f")) {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdOutputGain))) *p = gain;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    ImGui::PopItemWidth();

    // Mix (Dry/Wet)
    float mix = mixParam->load();
    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderFloat("Mix", &mix, 0.0f, 1.0f, "%.2f")) {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdMix))) *p = mix;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    ImGui::PopItemWidth();

    // Character (modulation intensity)
    float character = characterParam->load();
    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderFloat("Character", &character, 0.0f, 1.0f, "%.2f")) {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdCharacter))) *p = character;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("0.0 = Gentle (AM), 1.0 = Aggressive (Ring Mod)");
    ImGui::PopItemWidth();

    // Smoothness
    float smoothness = smoothnessParam->load();
    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderFloat("Smoothness", &smoothness, 0.0f, 1.0f, "%.2f")) {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdSmoothness))) *p = smoothness;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Smooths carrier transitions to reduce harshness");
    ImGui::PopItemWidth();

    // Relative modulation checkboxes
    ImGui::Spacing();
    ImGui::Text("CV Modulation Modes:");
    ImGui::Spacing();
    
    bool relativeFreqMod = relativeFreqModParam != nullptr && relativeFreqModParam->load() > 0.5f;
    if (ImGui::Checkbox("Rel Freq", &relativeFreqMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeFreqMod")))
            *p = relativeFreqMod;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("ON: CV modulates around slider (±4 octaves)\nOFF: CV directly sets freq (20-20000 Hz)");
    
    ImGui::SameLine();
    bool relativeDriveMod = relativeDriveModParam != nullptr && relativeDriveModParam->load() > 0.5f;
    if (ImGui::Checkbox("Rel Drive", &relativeDriveMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeDriveMod")))
            *p = relativeDriveMod;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("ON: CV modulates around slider (±0.5)\nOFF: CV directly sets drive (0-1)");
    
    ImGui::SameLine();
    bool relativeGainMod = relativeGainModParam != nullptr && relativeGainModParam->load() > 0.5f;
    if (ImGui::Checkbox("Rel Gain", &relativeGainMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeGainMod")))
            *p = relativeGainMod;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("ON: CV modulates around slider (±0.5)\nOFF: CV directly sets gain (0-1)");
    
    bool relativeMixMod = relativeMixModParam != nullptr && relativeMixModParam->load() > 0.5f;
    if (ImGui::Checkbox("Rel Mix", &relativeMixMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeMixMod")))
            *p = relativeMixMod;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("ON: CV modulates around slider (±0.5)\nOFF: CV directly sets mix (0-1)");
    
    ImGui::SameLine();
    bool relativeCharacterMod = relativeCharacterModParam != nullptr && relativeCharacterModParam->load() > 0.5f;
    if (ImGui::Checkbox("Rel Character", &relativeCharacterMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeCharacterMod")))
            *p = relativeCharacterMod;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("ON: CV modulates around slider (±0.5)\nOFF: CV directly sets character (0-1)");
    
    ImGui::SameLine();
    bool relativeSmoothnessMod = relativeSmoothnessModParam != nullptr && relativeSmoothnessModParam->load() > 0.5f;
    if (ImGui::Checkbox("Rel Smoothness", &relativeSmoothnessMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeSmoothnessMod")))
            *p = relativeSmoothnessMod;
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("ON: CV modulates around slider (±0.5)\nOFF: CV directly sets smoothness (0-1)");

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    // === ADVANCED CONTROLS (COLLAPSIBLE) ===
    static bool showAdvanced = false;
    if (ImGui::CollapsingHeader("Advanced Settings", &showAdvanced))
    {
        ImGui::Spacing();
        
        // Compact oscillator matrix (only when expanded)
        ThemeText("Oscillator Details", theme.text.section_header);
        ImGui::Spacing();
        
        // Table header
        ImGui::Columns(5, "osc_matrix", false);
        ImGui::SetColumnWidth(0, 30.0f);  // Harmonic number
        ImGui::SetColumnWidth(1, (itemWidth - 30.0f) * 0.3f); // Ratio
        ImGui::SetColumnWidth(2, (itemWidth - 30.0f) * 0.2f); // Detune
        ImGui::SetColumnWidth(3, (itemWidth - 30.0f) * 0.25f); // Waveform
        ImGui::SetColumnWidth(4, (itemWidth - 30.0f) * 0.25f);  // Drive
        ImGui::Text("H"); ImGui::NextColumn();
        ImGui::Text("Ratio"); ImGui::NextColumn();
        ImGui::Text("Detune"); ImGui::NextColumn();
        ImGui::Text("Wave"); ImGui::NextColumn();
        ImGui::Text("Drive"); ImGui::NextColumn();
        ImGui::Separator();
        
        for (int i = 0; i < NUM_OSCILLATORS; ++i)
        {
            auto idx = juce::String(i + 1);
            ImGui::PushID(i);
            
            // Harmonic number
            ImGui::Text("%d", i + 1);
            ImGui::NextColumn();
            
            // Ratio
            float ratio = ratioParams[i]->load();
            ImGui::PushItemWidth(-1);
            if (ImGui::DragFloat("##ratio", &ratio, 0.01f, 0.125f, 16.0f, "%.2fx"))
            {
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("ratio_" + idx))) *p = ratio;
                onModificationEnded();
            }
            ImGui::PopItemWidth();
            ImGui::NextColumn();
            
            // Detune
            float detune = detuneParams[i]->load();
            ImGui::PushItemWidth(-1);
            if (ImGui::DragFloat("##detune", &detune, 1.0f, -100.0f, 100.0f, "%.0f"))
            {
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("detune_" + idx))) *p = detune;
                onModificationEnded();
            }
            ImGui::PopItemWidth();
            ImGui::NextColumn();
            
            // Waveform (shows current, but Ctrl+click on bar is primary)
            int wave = (int)waveformParams[i]->load();
            const char* waveLabels[] = { "Sine", "Saw", "Square", "Triangle" };
            if (ImGui::Button(waveLabels[wave], ImVec2(-1, 0)))
            {
                wave = (wave + 1) % 4;
                if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("waveform_" + idx))) *p = wave;
                onModificationEnded();
            }
            ImGui::NextColumn();
            
            // Drive
            float oscDrive = driveParams[i]->load();
            ImGui::PushItemWidth(-1);
            if (ImGui::SliderFloat("##drive", &oscDrive, 0.0f, 1.0f, "%.2f"))
            {
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("drive_" + idx))) *p = oscDrive;
                onModificationEnded();
            }
            ImGui::PopItemWidth();
            ImGui::NextColumn();
            
            ImGui::PopID();
        }
        ImGui::Columns(1);
    }
}

void HarmonicShaperModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In L", 0);
    helpers.drawAudioInputPin("In R", 1);
    helpers.drawAudioInputPin("Freq Mod", 2);
    helpers.drawAudioInputPin("Drive Mod", 3);
    helpers.drawAudioInputPin("Gain Mod", 4);
    helpers.drawAudioInputPin("Mix Mod", 5);
    helpers.drawAudioInputPin("Character Mod", 6);
    helpers.drawAudioInputPin("Smoothness Mod", 7);
    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}

juce::String HarmonicShaperModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel) {
        case 0: return "In L";
        case 1: return "In R";
        case 2: return "Freq Mod";
        case 3: return "Drive Mod";
        case 4: return "Gain Mod";
        case 5: return "Mix Mod";
        case 6: return "Character Mod";
        case 7: return "Smoothness Mod";
        default: return {};
    }
}

juce::String HarmonicShaperModuleProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel) {
        case 0: return "Out L";
        case 1: return "Out R";
        default: return {};
    }
}
#endif

std::vector<DynamicPinInfo> HarmonicShaperModuleProcessor::getDynamicInputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Audio inputs (bus 0, channels 0-1)
    pins.push_back({"In L", 0, PinDataType::Audio});
    pins.push_back({"In R", 1, PinDataType::Audio});
    
    // Modulation inputs (bus 1, channels 0-5)
    pins.push_back({"Freq Mod", 2, PinDataType::CV});
    pins.push_back({"Drive Mod", 3, PinDataType::CV});
    pins.push_back({"Gain Mod", 4, PinDataType::CV});
    pins.push_back({"Mix Mod", 5, PinDataType::CV});
    pins.push_back({"Character Mod", 6, PinDataType::CV});
    pins.push_back({"Smoothness Mod", 7, PinDataType::CV});
    
    return pins;
}

std::vector<DynamicPinInfo> HarmonicShaperModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Audio outputs (channels 0-1)
    pins.push_back({"Out L", 0, PinDataType::Audio});
    pins.push_back({"Out R", 1, PinDataType::Audio});
    
    return pins;
}

bool HarmonicShaperModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    // Debug: Log routing requests to verify parameter IDs are recognized
    static juce::StringArray loggedParams;
    if (!loggedParams.contains(paramId)) {
        loggedParams.add(paramId);
        juce::Logger::writeToLog("[HarmonicShaper][ROUTING REQ] paramId=" + paramId);
    }
    // All modulation is on the single input bus (like Granulator and BestPracticeNodeProcessor)
    outBusIndex = 0;
    if (paramId == paramIdMasterFreqMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdMasterDriveMod) { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdOutputGainMod) { outChannelIndexInBus = 4; return true; }
    if (paramId == paramIdMixMod) { outChannelIndexInBus = 5; return true; }
    if (paramId == paramIdCharacterMod) { outChannelIndexInBus = 6; return true; }
    if (paramId == paramIdSmoothnessMod) { outChannelIndexInBus = 7; return true; }
    return false;
}



================================================================================
FILE: juce\Source\audio\modules\GranulatorModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include <array>

class GranulatorModuleProcessor : public ModuleProcessor
{
public:
    // Parameter IDs for APVTS
    static constexpr auto paramIdDensity      = "density";
    static constexpr auto paramIdSize         = "size";
    static constexpr auto paramIdPosition     = "position";
    static constexpr auto paramIdSpread       = "spread";
    static constexpr auto paramIdPitch        = "pitch";
    static constexpr auto paramIdPitchRandom  = "pitchRandom";
    static constexpr auto paramIdPanRandom    = "panRandom";
    static constexpr auto paramIdGate         = "gate";

    // Virtual IDs for modulation inputs, used for routing
    static constexpr auto paramIdTriggerIn    = "trigger_in_mod";
    static constexpr auto paramIdDensityMod   = "density_mod";
    static constexpr auto paramIdSizeMod      = "size_mod";
    static constexpr auto paramIdPositionMod  = "position_mod";
    static constexpr auto paramIdPitchMod     = "pitch_mod";
    static constexpr auto paramIdGateMod      = "gate_mod";

    // Relative modulation mode parameters
    static constexpr auto paramIdRelativeDensityMod  = "relativeDensityMod";
    static constexpr auto paramIdRelativeSizeMod     = "relativeSizeMod";
    static constexpr auto paramIdRelativePositionMod = "relativePositionMod";
    static constexpr auto paramIdRelativePitchMod    = "relativePitchMod";

    GranulatorModuleProcessor();
    ~GranulatorModuleProcessor() override = default;

    const juce::String getName() const override { return "granulator"; }

    // --- JUCE AudioProcessor Overrides ---
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // --- UI & Routing Overrides ---
#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String&)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    juce::String getAudioInputLabel(int channel) const override;
    
    std::vector<DynamicPinInfo> getDynamicInputPins() const override;
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;

private:
    // --- Internal Implementation ---
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    void launchGrain(int grainIndex, float density, float size, float position, float spread, float pitch, float pitchRandom, float panRandom);

    // --- APVTS & Parameters ---
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* densityParam      { nullptr };
    std::atomic<float>* sizeParam         { nullptr };
    std::atomic<float>* positionParam     { nullptr };
    std::atomic<float>* spreadParam       { nullptr };
    std::atomic<float>* pitchParam        { nullptr };
    std::atomic<float>* pitchRandomParam  { nullptr };
    std::atomic<float>* panRandomParam    { nullptr };
    std::atomic<float>* gateParam         { nullptr };
    
    // Relative modulation mode parameters
    std::atomic<float>* relativeDensityModParam  { nullptr };
    std::atomic<float>* relativeSizeModParam     { nullptr };
    std::atomic<float>* relativePositionModParam { nullptr };
    std::atomic<float>* relativePitchModParam    { nullptr };

    // --- Grain State ---
    struct Grain
    {
        bool isActive { false };
        double readPosition { 0.0 };
        double increment { 1.0 };
        int samplesRemaining { 0 };
        int totalLifetime { 0 };
        float panL { 0.707f };
        float panR { 0.707f };
    };
    std::array<Grain, 64> grainPool;
    juce::Random random;

    // --- Audio Buffering ---
    juce::AudioBuffer<float> sourceBuffer;
    int sourceWritePos { 0 };
    double densityPhase { 0.0 }; // Phase accumulator for density-based grain spawning

    // --- Parameter Smoothing ---
    juce::SmoothedValue<float> smoothedDensity, smoothedSize, smoothedPosition, smoothedPitch, smoothedGate;

    // --- CV De-stepping State (for modules that are block-constant) ---
    float prevDensityCv { std::numeric_limits<float>::quiet_NaN() };
    float prevSizeCv    { std::numeric_limits<float>::quiet_NaN() };
    float prevPositionCv{ std::numeric_limits<float>::quiet_NaN() };
    float prevPitchCv   { std::numeric_limits<float>::quiet_NaN() };
    float prevGateCv    { std::numeric_limits<float>::quiet_NaN() };

    // --- Visualization Data (thread-safe, updated from audio thread) ---
    struct VizData
    {
        static constexpr int waveformPoints = 256;
        std::array<std::atomic<float>, waveformPoints> waveformL;
        std::array<std::atomic<float>, waveformPoints> waveformR;
        std::atomic<float> writePosNormalized { 0.0f }; // 0-1 position in buffer
        std::atomic<float> positionParamNormalized { 0.5f }; // Current position param (0-1)
        std::atomic<int> activeGrainCount { 0 };
        std::array<std::atomic<float>, 64> activeGrainPositions; // Normalized read positions (0-1)
        std::array<std::atomic<float>, 64> activeGrainEnvelopes; // Current envelope values (0-1)
    };
    VizData vizData;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(GranulatorModuleProcessor)
};


================================================================================
FILE: juce\Source\audio\modules\GranulatorModuleProcessor.cpp
================================================================================


#include "GranulatorModuleProcessor.h"
#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/theme/ThemeManager.h"
#endif
#include <cstring> // for std::memcpy

juce::AudioProcessorValueTreeState::ParameterLayout GranulatorModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdDensity, "Density (Hz)", juce::NormalisableRange<float>(0.1f, 100.0f, 0.01f, 0.3f), 10.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSize, "Size (ms)", juce::NormalisableRange<float>(5.0f, 500.0f, 0.01f, 0.4f), 100.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdPosition, "Position", 0.0f, 1.0f, 0.5f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSpread, "Spread", 0.0f, 1.0f, 0.1f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdPitch, "Pitch (st)", -24.0f, 24.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdPitchRandom, "Pitch Rand", 0.0f, 12.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdPanRandom, "Pan Rand", 0.0f, 1.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdGate, "Gate", 0.0f, 1.0f, 1.0f));
    
    // Relative modulation mode parameters (default: true = relative mode)
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdRelativeDensityMod, "Relative Density Mod", true));
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdRelativeSizeMod, "Relative Size Mod", true));
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdRelativePositionMod, "Relative Position Mod", true));
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdRelativePitchMod, "Relative Pitch Mod", true));
    
    return { p.begin(), p.end() };
}

GranulatorModuleProcessor::GranulatorModuleProcessor()
    : ModuleProcessor(BusesProperties()
          .withInput("Inputs", juce::AudioChannelSet::discreteChannels(8), true) // Audio L/R, Trig, Density, Size, Position, Pitch, Gate
          .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "GranulatorParams", createParameterLayout())
{
    densityParam      = apvts.getRawParameterValue(paramIdDensity);
    sizeParam         = apvts.getRawParameterValue(paramIdSize);
    positionParam     = apvts.getRawParameterValue(paramIdPosition);
    spreadParam       = apvts.getRawParameterValue(paramIdSpread);
    pitchParam        = apvts.getRawParameterValue(paramIdPitch);
    pitchRandomParam  = apvts.getRawParameterValue(paramIdPitchRandom);
    panRandomParam    = apvts.getRawParameterValue(paramIdPanRandom);
    gateParam         = apvts.getRawParameterValue(paramIdGate);
    
    relativeDensityModParam  = apvts.getRawParameterValue(paramIdRelativeDensityMod);
    relativeSizeModParam     = apvts.getRawParameterValue(paramIdRelativeSizeMod);
    relativePositionModParam = apvts.getRawParameterValue(paramIdRelativePositionMod);
    relativePitchModParam    = apvts.getRawParameterValue(paramIdRelativePitchMod);

    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));

    // Initialize visualization data
    for (auto& w : vizData.waveformL) w.store(0.0f);
    for (auto& w : vizData.waveformR) w.store(0.0f);
    for (auto& p : vizData.activeGrainPositions) p.store(-1.0f); // -1 = inactive
    for (auto& e : vizData.activeGrainEnvelopes) e.store(0.0f);
}

void GranulatorModuleProcessor::prepareToPlay(double sampleRate, int)
{
    const int bufferSeconds = 2;
    sourceBuffer.setSize(2, (int)(sampleRate * bufferSeconds));
    sourceBuffer.clear();
    sourceWritePos = 0;

    smoothedDensity.reset(sampleRate, 0.05);
    smoothedSize.reset(sampleRate, 0.05);
    smoothedPosition.reset(sampleRate, 0.05);
    smoothedPitch.reset(sampleRate, 0.05);
    smoothedGate.reset(sampleRate, 0.002);

    densityPhase = 0.0;

    for (auto& grain : grainPool)
        grain.isActive = false;

    // Emit a startup log and warn about potential aliasing (enabled in all builds, throttled by prepareToPlay frequency)
    juce::Logger::writeToLog("[Granulator] prepareToPlay; inputs=" + juce::String(getTotalNumInputChannels()) +
                             " outputs=" + juce::String(getTotalNumOutputChannels()));
    if (getTotalNumInputChannels() >= getTotalNumOutputChannels())
        juce::Logger::writeToLog("[Granulator] [WARNING] Potential buffer aliasing: " +
                                 juce::String(getTotalNumInputChannels()) + " inputs, " +
                                 juce::String(getTotalNumOutputChannels()) + " outputs");
}

void GranulatorModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    auto inBus = getBusBuffer(buffer, true, 0);
    auto outBus = getBusBuffer(buffer, false, 0);

    const int numSamples = buffer.getNumSamples();
    const double sr = getSampleRate();

    // Get modulation CVs
    // IMPORTANT: Acquire input pointers BEFORE any output operations (aliasing-safe)
    const bool isTriggerConnected = isParamInputConnected(paramIdTriggerIn);
    const bool hasDensityMod = isParamInputConnected(paramIdDensityMod);
    const bool hasSizeMod = isParamInputConnected(paramIdSizeMod);
    const bool hasPositionMod = isParamInputConnected(paramIdPositionMod);
    const bool hasPitchMod = isParamInputConnected(paramIdPitchMod);
    const bool hasGateMod = isParamInputConnected(paramIdGateMod);

    const float* trigCVPtr   = (isTriggerConnected && inBus.getNumChannels() > 2) ? inBus.getReadPointer(2) : nullptr;
    const float* densityPtr  = (hasDensityMod   && inBus.getNumChannels() > 3) ? inBus.getReadPointer(3) : nullptr;
    const float* sizePtr     = (hasSizeMod      && inBus.getNumChannels() > 4) ? inBus.getReadPointer(4) : nullptr;
    const float* posPtr      = (hasPositionMod  && inBus.getNumChannels() > 5) ? inBus.getReadPointer(5) : nullptr;
    const float* pitchPtr    = (hasPitchMod     && inBus.getNumChannels() > 6) ? inBus.getReadPointer(6) : nullptr;
    const float* gatePtr     = (hasGateMod      && inBus.getNumChannels() > 7) ? inBus.getReadPointer(7) : nullptr;

    // EXTRA SAFETY: Copy CV channels we use into local buffers BEFORE any output writes,
    // so later writes cannot affect reads even if buffers alias (see DEBUG_INPUT_IMPORTANT.md).
    juce::HeapBlock<float> trigCV, densityCV, sizeCV, posCV, pitchCV, gateCV;
    if (trigCVPtr)   { trigCV.malloc(numSamples);   std::memcpy(trigCV.get(),   trigCVPtr,   sizeof(float) * (size_t)numSamples); }
    if (densityPtr)  { densityCV.malloc(numSamples);std::memcpy(densityCV.get(),densityPtr,  sizeof(float) * (size_t)numSamples); }
    if (sizePtr)     { sizeCV.malloc(numSamples);   std::memcpy(sizeCV.get(),   sizePtr,     sizeof(float) * (size_t)numSamples); }
    if (posPtr)      { posCV.malloc(numSamples);    std::memcpy(posCV.get(),    posPtr,      sizeof(float) * (size_t)numSamples); }
    if (pitchPtr)    { pitchCV.malloc(numSamples);  std::memcpy(pitchCV.get(),  pitchPtr,    sizeof(float) * (size_t)numSamples); }
    if (gatePtr)     { gateCV.malloc(numSamples);   std::memcpy(gateCV.get(),   gatePtr,     sizeof(float) * (size_t)numSamples); }

    // Get base parameters
    const float baseDensity = densityParam->load();
    const float baseSize = sizeParam->load();
    const float basePos = positionParam->load();
    const float basePitch = pitchParam->load();
    const float baseGate = gateParam->load();

    // Diagnostic: log CV connection state and first-sample values periodically (enabled in all builds)
    {
        static int dbgCounter = 0;
        if ((++dbgCounter & 0x7F) == 0) // every 128 calls to reduce spam
        {
            juce::String msg = "[Granulator][CV DEBUG] inCh=" + juce::String(inBus.getNumChannels()) +
                                " outCh=" + juce::String(outBus.getNumChannels()) +
                                " N=" + juce::String(numSamples) + " | ";
            msg += "TrigConn=" + juce::String(isTriggerConnected ? 1 : 0) +
                   " DenConn=" + juce::String(hasDensityMod ? 1 : 0) +
                   " SizeConn=" + juce::String(hasSizeMod ? 1 : 0) +
                   " PosConn=" + juce::String(hasPositionMod ? 1 : 0) +
                   " PitchConn=" + juce::String(hasPitchMod ? 1 : 0) +
                   " GateConn=" + juce::String(hasGateMod ? 1 : 0) + " | ";
            auto fmt = [](const juce::HeapBlock<float>& b)->juce::String {
                return b.get() ? juce::String(b[0], 3) : juce::String("---");
            };
            msg += "v0(Trig)=" + fmt(trigCV) + " v3(Den)=" + fmt(densityCV) +
                   " v4(Size)=" + fmt(sizeCV) + " v5(Pos)=" + fmt(posCV) +
                   " v6(Pitch)=" + fmt(pitchCV) + " v7(Gate)=" + fmt(gateCV);
            juce::Logger::writeToLog(msg);

            // Extra: min/max snapshots to see if CVs are changing across the block
            auto rangeFmt = [&](const juce::HeapBlock<float>& b)->juce::String {
                if (!b.get()) return juce::String("---");
                float mn = b[0], mx = b[0];
                const int step = juce::jmax(1, numSamples / 64);
                for (int i = 0; i < numSamples; i += step) { mn = juce::jmin(mn, b[i]); mx = juce::jmax(mx, b[i]); }
                return juce::String(mn, 3) + ".." + juce::String(mx, 3);
            };
            juce::Logger::writeToLog("[Granulator][CV RANGE] Trig=" + rangeFmt(trigCV) +
                                     " Den=" + rangeFmt(densityCV) +
                                     " Size=" + rangeFmt(sizeCV) +
                                     " Pos=" + rangeFmt(posCV) +
                                     " Pitch=" + rangeFmt(pitchCV) +
                                     " Gate=" + rangeFmt(gateCV));

            // Routing check: confirm channels used by getParamRouting
            int busIdx, ch;
            juce::String mapMsg = "[Granulator][ROUTING] ";
            if (getParamRouting(paramIdTriggerIn, busIdx, ch)) mapMsg += "Trig->" + juce::String(ch) + " ";
            if (getParamRouting(paramIdDensityMod, busIdx, ch)) mapMsg += "Den->" + juce::String(ch) + " ";
            if (getParamRouting(paramIdSizeMod, busIdx, ch)) mapMsg += "Size->" + juce::String(ch) + " ";
            if (getParamRouting(paramIdPositionMod, busIdx, ch)) mapMsg += "Pos->" + juce::String(ch) + " ";
            if (getParamRouting(paramIdPitchMod, busIdx, ch)) mapMsg += "Pitch->" + juce::String(ch) + " ";
            if (getParamRouting(paramIdGateMod, busIdx, ch)) mapMsg += "Gate->" + juce::String(ch) + " ";
            juce::Logger::writeToLog(mapMsg);
        }
    }

    // Helper lambdas to fetch possibly block-constant CVs with intra-block interpolation
    auto sampleCvOrRamp = [&](const juce::HeapBlock<float>& buf, float& prev, int i)->float
    {
        if (!buf.get()) return std::numeric_limits<float>::quiet_NaN();
        const float first = buf[0];
        const float last  = buf[numSamples - 1];
        // If block is flat (or nearly), linearly ramp from previous block value to current
        const bool flat = std::abs(last - first) < 1e-6f;
        if (flat)
        {
            const float start = std::isfinite(prev) ? prev : first;
            const float t = (numSamples > 1) ? (float)i / (float)(numSamples - 1) : 1.0f;
            return start + (first - start) * t;
        }
        // Otherwise, use per-sample value
        return buf[i];
    };

    for (int i = 0; i < numSamples; ++i)
    {
        // 1. Record incoming audio to circular buffer
        sourceBuffer.setSample(0, sourceWritePos, inBus.getSample(0, i));
        sourceBuffer.setSample(1, sourceWritePos, inBus.getSample(1, i));

        // 2. Handle triggers
        // Default to ON if the trigger input is not connected.
        bool isGenerating = !isTriggerConnected;
        if (isTriggerConnected && trigCV.get() != nullptr) {
            // If connected, follow the gate signal.
            isGenerating = trigCV[i] > 0.5f;
        }
        
        // 3. Update smoothed parameters (with intra-block ramping if source is block-constant)
        float densityCvSample  = densityCV.get() ? sampleCvOrRamp(densityCV, prevDensityCv, i) : std::numeric_limits<float>::quiet_NaN();
        float sizeCvSample     = sizeCV.get()    ? sampleCvOrRamp(sizeCV,    prevSizeCv,    i) : std::numeric_limits<float>::quiet_NaN();
        float positionCvSample = posCV.get()     ? sampleCvOrRamp(posCV,     prevPositionCv,i) : std::numeric_limits<float>::quiet_NaN();
        float pitchCvSample    = pitchCV.get()   ? sampleCvOrRamp(pitchCV,   prevPitchCv,   i) : std::numeric_limits<float>::quiet_NaN();
        float gateCvSample     = gateCV.get()    ? sampleCvOrRamp(gateCV,    prevGateCv,    i) : std::numeric_limits<float>::quiet_NaN();

        // Normalize CV to [0,1] range (handle both unipolar and bipolar)
        auto normalizeCV = [](float cv) -> float {
            return (cv >= 0.0f && cv <= 1.0f) 
                ? juce::jlimit(0.0f, 1.0f, cv)
                : juce::jlimit(0.0f, 1.0f, (cv + 1.0f) * 0.5f);
        };

        // Apply CV with relative/absolute mode
        float density = baseDensity;
        if (std::isfinite(densityCvSample))
        {
            const float cv01 = normalizeCV(densityCvSample);
            const bool relativeMode = relativeDensityModParam && relativeDensityModParam->load() > 0.5f;
            if (relativeMode)
            {
                // RELATIVE: CV modulates around base (0.5x to 2x range)
                density = baseDensity * juce::jmap(cv01, 0.0f, 1.0f, 0.5f, 2.0f);
            }
            else
            {
                // ABSOLUTE: CV directly sets density (0.1 to 100 Hz)
                density = juce::jmap(cv01, 0.1f, 100.0f);
            }
        }

        float sizeMs = baseSize;
        if (std::isfinite(sizeCvSample))
        {
            const float cv01 = normalizeCV(sizeCvSample);
            const bool relativeMode = relativeSizeModParam && relativeSizeModParam->load() > 0.5f;
            if (relativeMode)
            {
                // RELATIVE: CV modulates around base (0.1x to 2x range)
                sizeMs = baseSize * juce::jmap(cv01, 0.0f, 1.0f, 0.1f, 2.0f);
            }
            else
            {
                // ABSOLUTE: CV directly sets size (5 to 500 ms)
                sizeMs = juce::jmap(cv01, 5.0f, 500.0f);
            }
        }

        float position = basePos;
        if (std::isfinite(positionCvSample))
        {
            const float cv01 = normalizeCV(positionCvSample);
            const bool relativeMode = relativePositionModParam && relativePositionModParam->load() > 0.5f;
            if (relativeMode)
            {
                // RELATIVE: CV adds offset to base position (±0.5 range)
                position = basePos + juce::jlimit(-0.5f, 0.5f, cv01 - 0.5f);
            }
            else
            {
                // ABSOLUTE: CV directly sets position (0 to 1)
                position = cv01;
            }
        }

        float pitch = basePitch;
        if (std::isfinite(pitchCvSample))
        {
            const float cv01 = normalizeCV(pitchCvSample);
            const bool relativeMode = relativePitchModParam && relativePitchModParam->load() > 0.5f;
            if (relativeMode)
            {
                // RELATIVE: CV adds offset to base pitch (±12 semitones)
                pitch = basePitch + juce::jmap(cv01, 0.0f, 1.0f, -12.0f, 12.0f);
            }
            else
            {
                // ABSOLUTE: CV directly sets pitch (-24 to +24 semitones)
                pitch = juce::jmap(cv01, -24.0f, 24.0f);
            }
        }

        float gate = std::isfinite(gateCvSample) ? juce::jlimit(0.0f, 1.0f, normalizeCV(gateCvSample)) : baseGate;
        
        // ✅ CRITICAL FIX: Advance ALL smoothed values every sample (like Gate does)
        // This makes all CV inputs respond continuously, not just when grains spawn
        smoothedDensity.setTargetValue(density);
        smoothedSize.setTargetValue(sizeMs);
        smoothedPosition.setTargetValue(position);
        smoothedPitch.setTargetValue(pitch);
        smoothedGate.setTargetValue(gate);
        
        // Get continuously-updated smoothed values (like Gate does)
        float currentDensity = smoothedDensity.getNextValue();
        float currentSize = smoothedSize.getNextValue();
        float currentPosition = smoothedPosition.getNextValue();
        float currentPitch = smoothedPitch.getNextValue();
        float currentGate = smoothedGate.getNextValue();

        // 4. Spawn new grains using phase accumulator (makes density changes immediate)
        if (isGenerating && currentDensity > 0.1f) {
            // Phase accumulator: density in Hz means grains per second
            densityPhase += currentDensity / sr;
            
            // Spawn grains as phase accumulates
            while (densityPhase >= 1.0) {
                densityPhase -= 1.0;
                
                // Find free grain slot
                for (int j = 0; j < (int)grainPool.size(); ++j) {
                    if (!grainPool[j].isActive) {
                        launchGrain(j, currentDensity, currentSize, currentPosition, 
                                    spreadParam->load(), currentPitch, 
                                    pitchRandomParam->load(), panRandomParam->load());
                        break;
                    }
                }
            }
        } else {
            // If not generating or density too low, reset phase
            densityPhase = 0.0;
        }

        // 5. Process active grains
        float sampleL = 0.0f, sampleR = 0.0f;
        for (auto& grain : grainPool) {
            if (grain.isActive) {
                int readPosInt = (int)grain.readPosition;
                float fraction = (float)(grain.readPosition - readPosInt);
                
                // Linear interpolation
                float sL = sourceBuffer.getSample(0, readPosInt) * (1.0f - fraction) + sourceBuffer.getSample(0, (readPosInt + 1) % sourceBuffer.getNumSamples()) * fraction;
                float sR = sourceBuffer.getSample(1, readPosInt) * (1.0f - fraction) + sourceBuffer.getSample(1, (readPosInt + 1) % sourceBuffer.getNumSamples()) * fraction;

                // Hann window envelope
                float envelope = 0.5f * (1.0f - std::cos(2.0f * juce::MathConstants<float>::pi * (float)(grain.totalLifetime - grain.samplesRemaining) / (float)grain.totalLifetime));
                
                sampleL += sL * envelope * grain.panL;
                sampleR += sR * envelope * grain.panR;

                grain.readPosition += grain.increment;
                if (grain.readPosition >= sourceBuffer.getNumSamples())
                    grain.readPosition -= sourceBuffer.getNumSamples();
                
                if (--grain.samplesRemaining <= 0)
                    grain.isActive = false;
            }
        }
        
        // 6. Apply gate and write to output (using already-computed currentGate)
        outBus.setSample(0, i, sampleL * currentGate);
        outBus.setSample(1, i, sampleR * currentGate);

        sourceWritePos = (sourceWritePos + 1) % sourceBuffer.getNumSamples();

        // Update visualization data (throttled - every 64 samples)
        if ((i & 0x3F) == 0)
        {
            const int bufferSize = sourceBuffer.getNumSamples();
            const float writePosNorm = (float)sourceWritePos / (float)bufferSize;
            vizData.writePosNormalized.store(writePosNorm);
            vizData.positionParamNormalized.store(currentPosition);

            // Update waveform snapshot (downsampled)
            const int step = bufferSize / VizData::waveformPoints;
            for (int j = 0; j < VizData::waveformPoints; ++j)
            {
                int idx = (sourceWritePos - (VizData::waveformPoints - j) * step + bufferSize) % bufferSize;
                vizData.waveformL[j].store(sourceBuffer.getSample(0, idx));
                vizData.waveformR[j].store(sourceBuffer.getSample(1, idx));
            }

            // Update active grain positions
            int activeCount = 0;
            for (int g = 0; g < (int)grainPool.size(); ++g)
            {
                const auto& grain = grainPool[g];
                if (grain.isActive)
                {
                    const float grainPosNorm = (float)grain.readPosition / (float)bufferSize;
                    vizData.activeGrainPositions[activeCount].store(grainPosNorm);
                    
                    // Calculate current envelope value
                    const float env = (grain.totalLifetime > 0) 
                        ? 0.5f * (1.0f - std::cos(2.0f * juce::MathConstants<float>::pi * 
                            (float)(grain.totalLifetime - grain.samplesRemaining) / (float)grain.totalLifetime))
                        : 0.0f;
                    vizData.activeGrainEnvelopes[activeCount].store(env);
                    ++activeCount;
                }
            }
            vizData.activeGrainCount.store(activeCount);
            
            // Clear inactive grain slots
            for (int g = activeCount; g < 64; ++g)
            {
                vizData.activeGrainPositions[g].store(-1.0f);
                vizData.activeGrainEnvelopes[g].store(0.0f);
            }
        }
    }

    // Update previous block CV anchors for de-stepping
    if (densityCV.get())  prevDensityCv  = densityCV[numSamples - 1];
    if (sizeCV.get())     prevSizeCv     = sizeCV[numSamples - 1];
    if (posCV.get())      prevPositionCv = posCV[numSamples - 1];
    if (pitchCV.get())    prevPitchCv    = pitchCV[numSamples - 1];
    if (gateCV.get())     prevGateCv     = gateCV[numSamples - 1];
    
    // Update telemetry (use getCurrentValue since we've already advanced all smoothed values)
    setLiveParamValue("density_live", smoothedDensity.getCurrentValue());
    setLiveParamValue("size_live", smoothedSize.getCurrentValue());
    setLiveParamValue("position_live", smoothedPosition.getCurrentValue());
    setLiveParamValue("pitch_live", smoothedPitch.getCurrentValue());
    setLiveParamValue("gate_live", smoothedGate.getCurrentValue());
    
    if (lastOutputValues[0]) lastOutputValues[0]->store(outBus.getSample(0, numSamples - 1));
    if (lastOutputValues[1]) lastOutputValues[1]->store(outBus.getSample(1, numSamples - 1));
}

void GranulatorModuleProcessor::launchGrain(int grainIndex, float density, float size, float position, float spread, float pitch, float pitchRandom, float panRandom)
{
    auto& grain = grainPool[grainIndex];
    const double sr = getSampleRate();

    grain.totalLifetime = grain.samplesRemaining = (int)((size / 1000.0f) * sr);
    if (grain.samplesRemaining == 0) return;

    float posOffset = (random.nextFloat() - 0.5f) * spread;
    grain.readPosition = (sourceWritePos - (int)(juce::jlimit(0.0f, 1.0f, position + posOffset) * sourceBuffer.getNumSamples()) + sourceBuffer.getNumSamples()) % sourceBuffer.getNumSamples();

    float pitchOffset = (random.nextFloat() - 0.5f) * pitchRandom;
    grain.increment = std::pow(2.0, (pitch + pitchOffset) / 12.0);

    float pan = (random.nextFloat() - 0.5f) * panRandom;
    grain.panL = std::cos((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);
    grain.panR = std::sin((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);

    grain.isActive = true;
}

#if defined(PRESET_CREATOR_UI)
void GranulatorModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String&)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    ImGui::PushItemWidth(itemWidth);

    auto HelpMarker = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    auto drawSlider = [&](const char* label, const juce::String& paramId, const juce::String& modId, float min, float max, const char* format, int flags = 0) {
        bool isMod = isParamModulated(modId);
        float value = isMod ? getLiveParamValueFor(modId, paramId + "_live", ap.getRawParameterValue(paramId)->load())
                            : ap.getRawParameterValue(paramId)->load();
        
        if (isMod) ImGui::BeginDisabled();
        if (ImGui::SliderFloat(label, &value, min, max, format, flags))
            if (!isMod) *dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramId)) = value;
        if (!isMod) adjustParamOnWheel(ap.getParameter(paramId), paramId, value);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    };

    // === GRANULATOR VISUALIZATION ===
    ImGui::Spacing();
    ImGui::Text("Buffer & Grains");
    ImGui::Spacing();

    // Draw waveform visualization with grain markers
    auto* drawList = ImGui::GetWindowDrawList();
    const ImVec2 origin = ImGui::GetCursorScreenPos();
    const float vizWidth = itemWidth;
    const float vizHeight = 100.0f;
    const ImVec2 rectMax = ImVec2(origin.x + vizWidth, origin.y + vizHeight);
    
    // Get theme colors for visualization
    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    auto& themeMgr = ThemeManager::getInstance();
    
    // Helper to resolve color with multiple fallbacks
    auto resolveColor = [&](ImU32 primary, ImU32 secondary, ImU32 tertiary) -> ImU32 {
        if (primary != 0) return primary;
        if (secondary != 0) return secondary;
        return tertiary;
    };
    
    // Background: scope_plot_bg -> canvas_background -> ChildBg -> fallback
    const ImU32 canvasBg = themeMgr.getCanvasBackground();
    const ImVec4 childBgVec4 = ImGui::GetStyle().Colors[ImGuiCol_ChildBg];
    const ImU32 childBg = ImGui::ColorConvertFloat4ToU32(childBgVec4);
    const ImU32 bgColor = resolveColor(theme.modules.scope_plot_bg, canvasBg, childBg);
    
    // Waveform: Use modulation.frequency (cyan) for distinct waveform color
    const ImVec4 accentVec4 = theme.accent;
    const ImU32 accentColor = ImGui::ColorConvertFloat4ToU32(ImVec4(accentVec4.x, accentVec4.y, accentVec4.z, 0.78f));
    const ImVec4 frequencyColorVec4 = theme.modulation.frequency;
    const ImU32 frequencyColor = ImGui::ColorConvertFloat4ToU32(ImVec4(frequencyColorVec4.x, frequencyColorVec4.y, frequencyColorVec4.z, 0.85f));
    const ImU32 waveformColor = resolveColor(theme.modules.scope_plot_fg, frequencyColor, IM_COL32(100, 200, 255, 220));
    
    // Write position: Use modulation.timbre (orange/yellow) for warm write position
    const ImU32 scopeTextMax = ImGui::ColorConvertFloat4ToU32(theme.modules.scope_text_max);
    const ImVec4 timbreColorVec4 = theme.modulation.timbre;
    const ImU32 timbreColor = ImGui::ColorConvertFloat4ToU32(ImVec4(timbreColorVec4.x, timbreColorVec4.y, timbreColorVec4.z, 1.0f));
    const ImU32 writePosColor = resolveColor(theme.modules.scope_plot_max, timbreColor, IM_COL32(255, 200, 100, 255));
    
    // Position marker: Use modulation.amplitude (magenta/pink) for distinct position marker
    const ImU32 scopeTextMin = ImGui::ColorConvertFloat4ToU32(theme.modules.scope_text_min);
    const ImVec4 amplitudeColorVec4 = theme.modulation.amplitude;
    const ImU32 amplitudeColor = ImGui::ColorConvertFloat4ToU32(ImVec4(amplitudeColorVec4.x, amplitudeColorVec4.y, amplitudeColorVec4.z, 0.85f));
    const ImU32 warningColor = ImGui::ColorConvertFloat4ToU32(theme.text.warning);
    const ImU32 positionMarkerColor = resolveColor(theme.modules.scope_plot_min, amplitudeColor, 
                                                   resolveColor(warningColor, IM_COL32(255, 100, 100, 200), IM_COL32(255, 100, 100, 200)));
    
    // Grains: Use modulation.filter (green) or text.success for distinct grain color
    const ImVec4 filterColorVec4 = theme.modulation.filter;
    const ImU32 filterColor = ImGui::ColorConvertFloat4ToU32(ImVec4(filterColorVec4.x, filterColorVec4.y, filterColorVec4.z, 1.0f));
    const ImVec4 successColorVec4 = theme.text.success;
    const ImU32 successColor = ImGui::ColorConvertFloat4ToU32(successColorVec4);
    const ImU32 grainColorBase = (filterColor != 0) ? filterColor : 
                                 (successColor != 0) ? successColor : IM_COL32(100, 255, 100, 255);
    const ImU32 grainColor = grainColorBase;
    
    // Grain envelope: Use a lighter, more transparent version of grain color
    const ImVec4 grainColorVec4 = ImGui::ColorConvertU32ToFloat4(grainColor);
    const ImU32 grainEnvelopeColor = ImGui::ColorConvertFloat4ToU32(ImVec4(
        grainColorVec4.x, grainColorVec4.y, grainColorVec4.z, 0.5f));
    
    drawList->AddRectFilled(origin, rectMax, bgColor, 4.0f);
    ImGui::PushClipRect(origin, rectMax, true);
    
    // Read visualization data (thread-safe)
    float waveformL[VizData::waveformPoints];
    float waveformR[VizData::waveformPoints];
    for (int i = 0; i < VizData::waveformPoints; ++i)
    {
        waveformL[i] = vizData.waveformL[i].load();
        waveformR[i] = vizData.waveformR[i].load();
    }
    const float writePosNorm = vizData.writePosNormalized.load();
    const float positionNorm = vizData.positionParamNormalized.load();
    const int activeGrainCount = vizData.activeGrainCount.load();
    float grainPositions[64];
    float grainEnvelopes[64];
    for (int i = 0; i < 64; ++i)
    {
        grainPositions[i] = vizData.activeGrainPositions[i].load();
        grainEnvelopes[i] = vizData.activeGrainEnvelopes[i].load();
    }
    
    const float midY = origin.y + vizHeight * 0.5f;
    const float scaleY = vizHeight * 0.4f;
    const float stepX = vizWidth / (float)(VizData::waveformPoints - 1);
    
    // Draw waveform (stereo average)
    float prevX = origin.x, prevY = midY;
    for (int i = 0; i < VizData::waveformPoints; ++i)
    {
        const float sample = (waveformL[i] + waveformR[i]) * 0.5f;
        const float x = origin.x + i * stepX;
        const float y = midY - juce::jlimit(-1.0f, 1.0f, sample) * scaleY;
        if (i > 0) drawList->AddLine(ImVec2(prevX, prevY), ImVec2(x, y), waveformColor, 1.5f);
        prevX = x; prevY = y;
    }
    
    // Draw write position indicator (vertical line)
    const float writeX = origin.x + writePosNorm * vizWidth;
    drawList->AddLine(ImVec2(writeX, origin.y), ImVec2(writeX, rectMax.y), writePosColor, 2.0f);
    
    // Draw position parameter marker (vertical line)
    const float posX = origin.x + positionNorm * vizWidth;
    drawList->AddLine(ImVec2(posX, origin.y), ImVec2(posX, rectMax.y), positionMarkerColor, 1.5f);
    
    // Draw active grains as markers with envelope visualization
    for (int i = 0; i < activeGrainCount; ++i)
    {
        const float grainPos = grainPositions[i];
        if (grainPos >= 0.0f && grainPos <= 1.0f)
        {
            const float grainX = origin.x + grainPos * vizWidth;
            const float env = grainEnvelopes[i];
            const float envHeight = env * scaleY * 0.5f;
            
            // Vary grain color based on envelope strength for visual interest
            // Stronger grains are brighter, weaker grains are more transparent
            const float envAlpha = 0.3f + env * 0.5f;  // 0.3 to 0.8 alpha based on envelope
            const ImVec4 grainColorWithEnv = ImVec4(
                grainColorVec4.x,
                grainColorVec4.y,
                grainColorVec4.z,
                envAlpha);
            const ImU32 grainEnvelopeColorVaried = ImGui::ColorConvertFloat4ToU32(grainColorWithEnv);
            
            // Envelope visualization (vertical bar) with varied color
            drawList->AddLine(ImVec2(grainX, midY - envHeight), ImVec2(grainX, midY + envHeight), 
                            grainEnvelopeColorVaried, 2.0f);
            
            // Grain position marker (small circle) - brighter for stronger grains
            const float markerAlpha = 0.6f + env * 0.4f;  // 0.6 to 1.0 alpha
            const ImVec4 grainMarkerColor = ImVec4(
                grainColorVec4.x,
                grainColorVec4.y,
                grainColorVec4.z,
                markerAlpha);
            const ImU32 grainMarkerColorVaried = ImGui::ColorConvertFloat4ToU32(grainMarkerColor);
            drawList->AddCircleFilled(ImVec2(grainX, midY), 3.0f, grainMarkerColorVaried);
        }
    }
    
    ImGui::PopClipRect();
    ImGui::SetCursorScreenPos(ImVec2(origin.x, rectMax.y));
    ImGui::Dummy(ImVec2(vizWidth, 0));
    
    // Active grain count indicator
    ImGui::Text("Active Grains: %d / 64", activeGrainCount);
    float grainMeter = activeGrainCount / 64.0f;
    
    // Theme the progress bar color - use accent color directly
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, accentColor);
    ImGui::ProgressBar(grainMeter, ImVec2(itemWidth * 0.5f, 0), "");
    ImGui::PopStyleColor();
    
    ImGui::SameLine();
    ImGui::Text("%.0f%%", grainMeter * 100.0f);
    
    ImGui::Spacing();
    ImGui::Spacing();

    // === PARAMETERS ===
    drawSlider("Density", paramIdDensity, paramIdDensityMod, 0.1f, 100.0f, "%.1f Hz", ImGuiSliderFlags_Logarithmic);
    bool relDens = relativeDensityModParam && relativeDensityModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Density Mod", &relDens))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdRelativeDensityMod)))
            *p = relDens;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarker("Relative: CV modulates around slider (0.5x-2x). Absolute: CV sets density directly (0.1-100 Hz).");

    drawSlider("Size", paramIdSize, paramIdSizeMod, 5.0f, 500.0f, "%.0f ms", ImGuiSliderFlags_Logarithmic);
    bool relSize = relativeSizeModParam && relativeSizeModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Size Mod", &relSize))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdRelativeSizeMod)))
            *p = relSize;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarker("Relative: CV modulates around slider (0.1x-2x). Absolute: CV sets size directly (5-500 ms).");

    drawSlider("Position", paramIdPosition, paramIdPositionMod, 0.0f, 1.0f, "%.2f");
    bool relPos = relativePositionModParam && relativePositionModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Position Mod", &relPos))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdRelativePositionMod)))
            *p = relPos;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarker("Relative: CV adds offset to slider (±0.5). Absolute: CV sets position directly (0-1).");

    drawSlider("Spread", paramIdSpread, "", 0.0f, 1.0f, "%.2f");
    drawSlider("Pitch", paramIdPitch, paramIdPitchMod, -24.0f, 24.0f, "%.1f st");
    bool relPitch = relativePitchModParam && relativePitchModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Pitch Mod", &relPitch))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdRelativePitchMod)))
            *p = relPitch;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarker("Relative: CV adds offset to slider (±12 st). Absolute: CV sets pitch directly (-24 to +24 st).");

    drawSlider("Pitch Rand", paramIdPitchRandom, "", 0.0f, 12.0f, "%.1f st");
    drawSlider("Pan Rand", paramIdPanRandom, "", 0.0f, 1.0f, "%.2f");
    drawSlider("Gate", paramIdGate, paramIdGateMod, 0.0f, 1.0f, "%.2f");

    ImGui::PopItemWidth();
}

void GranulatorModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In L", 0);
    helpers.drawAudioInputPin("In R", 1);
    helpers.drawAudioInputPin("Trigger In", 2);
    helpers.drawAudioInputPin("Density Mod", 3);
    helpers.drawAudioInputPin("Size Mod", 4);
    helpers.drawAudioInputPin("Position Mod", 5);
    helpers.drawAudioInputPin("Pitch Mod", 6);
    helpers.drawAudioInputPin("Gate Mod", 7);
    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}
#endif

std::vector<DynamicPinInfo> GranulatorModuleProcessor::getDynamicInputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Audio inputs (channels 0-1)
    pins.push_back({"In L", 0, PinDataType::Audio});
    pins.push_back({"In R", 1, PinDataType::Audio});
    
    // Modulation/trigger inputs (channels 2-7)
    pins.push_back({"Trigger In", 2, PinDataType::Gate});
    pins.push_back({"Density Mod", 3, PinDataType::CV});
    pins.push_back({"Size Mod", 4, PinDataType::CV});
    pins.push_back({"Position Mod", 5, PinDataType::CV});
    pins.push_back({"Pitch Mod", 6, PinDataType::CV});
    pins.push_back({"Gate Mod", 7, PinDataType::CV});
    
    return pins;
}

std::vector<DynamicPinInfo> GranulatorModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Audio outputs (channels 0-1)
    pins.push_back({"Out L", 0, PinDataType::Audio});
    pins.push_back({"Out R", 1, PinDataType::Audio});
    
    return pins;
}

bool GranulatorModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0; // All modulation is on the single input bus.
    if (paramId == paramIdTriggerIn)    { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdDensityMod)   { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdSizeMod)      { outChannelIndexInBus = 4; return true; }
    if (paramId == paramIdPositionMod)  { outChannelIndexInBus = 5; return true; }
    if (paramId == paramIdPitchMod)     { outChannelIndexInBus = 6; return true; }
    if (paramId == paramIdGateMod)      { outChannelIndexInBus = 7; return true; }
    return false;
}

juce::String GranulatorModuleProcessor::getAudioInputLabel(int channel) const
{
    switch(channel) {
        case 0: return "In L";
        case 1: return "In R";
        case 2: return "Trigger In";
        case 3: return "Density Mod";
        case 4: return "Size Mod";
        case 5: return "Position Mod";
        case 6: return "Pitch Mod";
        case 7: return "Gate Mod";
        default: return {};
    }
}

================================================================================
FILE: guides\DEBUG_INPUT_IMPORTANT.md
================================================================================


# JUCE Audio Buffer Aliasing Bug - Debug Guide

## 🐛 The Bug

**Symptom:** Input CV values read as **always zero** (or wrong values) even though connections are correct and other inputs work fine.

**Root Cause:** Calling `out.clear()` accidentally clears input buffer channels due to **memory aliasing** between input and output buffers.

---

## 🔍 Why This Happens

### JUCE Buffer Memory Management

JUCE's `AudioBuffer` can **alias** (share memory) between input and output buffers when:
- Both buffers have similar channel counts
- JUCE optimizes by reusing the same memory block
- The buffer layout allows overlapping memory regions

**Example:**
```cpp
// Module has:
// - Input bus: 8 channels
// - Output bus: 7 channels

auto in = getBusBuffer(buffer, true, 0);   // Points to channels 0-7
auto out = getBusBuffer(buffer, false, 0); // May ALIAS channels 0-6!

out.clear();  // ❌ Clears OUTPUT channels 0-6...
              // ❌ But ALSO clears INPUT channels 0-6!
```

### Why Some Channels Work and Others Don't

- **Low channel indices** (0-6): Often aliased, get cleared ❌
- **High channel indices** (7+): Beyond the cleared range, work fine ✅

---

## 🚨 How to Detect This Bug

### Symptom Checklist

✅ **Strong indicators:**
1. Some CV inputs work perfectly (e.g., channel 7)
2. Other CV inputs always read as 0.0 (e.g., channel 0)
3. Connection detection reports "CONNECTED"
4. Pointer is VALID (not NULL)
5. But the value it points to is always 0.0

✅ **Smoking gun evidence:**
```
[DEBUG] Input channel 0 BEFORE clear: 0.9424   ✅ Data exists!
[DEBUG] After getting pointer, value: 0.0000   ❌ Data gone!
```

### Diagnostic Logging Pattern

Add this to your `processBlock` to detect the bug:

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    // 🔍 DIAGNOSTIC: Log buffer state BEFORE clearing
    static int debugCounter = 0;
    if (++debugCounter % 100 == 0) {
        juce::Logger::writeToLog("[BUFFER DEBUG]:");
        juce::Logger::writeToLog("  Input channels: " + juce::String(in.getNumChannels()));
        juce::Logger::writeToLog("  Output channels: " + juce::String(out.getNumChannels()));
        
        // Check channel 0 BEFORE clear
        if (in.getNumChannels() > 0) {
            juce::Logger::writeToLog("  Channel 0 BEFORE clear: " + 
                juce::String(in.getSample(0, 0), 4));
        }
    }
    
    out.clear();  // ⚠️ Suspect line!
    
    // Get CV pointer
    const float* myCV = in.getReadPointer(0);
    
    // Check value AFTER clear
    if (debugCounter % 100 == 0 && myCV) {
        juce::Logger::writeToLog("  Channel 0 AFTER clear (via pointer): " + 
            juce::String(myCV[0], 4));
    }
    
    // ... rest of processing
}
```

### What to Look For

**❌ BUG PRESENT:**
```
[BUFFER DEBUG]:
  Input channels: 8
  Output channels: 7
  Channel 0 BEFORE clear: 0.9424   ✅ Data is there!
  Channel 0 AFTER clear: 0.0000    ❌ Data disappeared!
```

**✅ NO BUG:**
```
[BUFFER DEBUG]:
  Input channels: 8
  Output channels: 7
  Channel 0 BEFORE clear: 0.9424   ✅ Data is there!
  Channel 0 AFTER clear: 0.9424    ✅ Data still there!
```

---

## 🔧 How to Fix

### Solution 1: Don't Clear (Recommended)

**Best approach:** Don't call `out.clear()` if you're writing to all output channels anyway.

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    // ✅ DON'T clear output buffer - we'll write to all channels explicitly
    // out.clear();  // ❌ REMOVED!
    
    // Read inputs FIRST (safe - no clearing yet)
    const float* myCV = in.getReadPointer(0);
    float inputValue = myCV ? myCV[0] : 0.0f;
    
    // Process...
    
    // Write to ALL output channels explicitly
    for (int ch = 0; ch < out.getNumChannels(); ++ch) {
        float* outChannel = out.getWritePointer(ch);
        for (int i = 0; i < numSamples; ++i) {
            outChannel[i] = /* calculated value */;
        }
    }
}
```

**Why this works:**
- If you write to every sample of every output channel, clearing is unnecessary
- No risk of aliasing issues

---

### Solution 2: Read Inputs Before Clearing

If you **must** clear the output buffer:

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    // ✅ STEP 1: Read ALL input values BEFORE clearing
    const float* myCV = in.getReadPointer(0);
    float inputValue = myCV ? myCV[0] : 0.0f;  // Copy the value!
    
    // ✅ STEP 2: Now safe to clear output
    out.clear();
    
    // ✅ STEP 3: Process using the COPIED input values
    // Don't access input buffer after this point!
}
```

**⚠️ Important:** 
- Copy input VALUES, not just pointers
- Don't access input buffer after clearing output

---

### Solution 3: Clear Individual Channels

Only clear the specific output channels you need:

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    // ✅ Clear only specific output channels that won't be fully written
    for (int ch = 0; ch < out.getNumChannels(); ++ch) {
        out.clear(ch, 0, buffer.getNumSamples());
    }
    
    // Or just clear the range you need:
    // out.clear(startChannel, startSample, numSamples);
}
```

---

## 🎯 Best Practices

### 1. **Standard Pattern (Safest)**

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    const int numSamples = buffer.getNumSamples();
    
    // ✅ Get input pointers FIRST
    const float* input0 = in.getNumChannels() > 0 ? in.getReadPointer(0) : nullptr;
    const float* input1 = in.getNumChannels() > 1 ? in.getReadPointer(1) : nullptr;
    
    // ✅ Get output pointers (will write to all of them)
    float* output0 = out.getNumChannels() > 0 ? out.getWritePointer(0) : nullptr;
    float* output1 = out.getNumChannels() > 1 ? out.getWritePointer(1) : nullptr;
    
    // ✅ Process sample-by-sample, writing to ALL output samples
    for (int i = 0; i < numSamples; ++i) {
        // Read inputs
        float in0 = input0 ? input0[i] : 0.0f;
        float in1 = input1 ? input1[i] : 0.0f;
        
        // Process
        float result0 = /* ... */;
        float result1 = /* ... */;
        
        // Write outputs (all samples written = no need to clear!)
        if (output0) output0[i] = result0;
        if (output1) output1[i] = result1;
    }
}
```

### 2. **Check for Aliasing in Testing**

Add this to your module during development:

```cpp
#ifdef _DEBUG
void YourModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Warn about potential aliasing
    if (getTotalNumInputChannels() >= getTotalNumOutputChannels()) {
        juce::Logger::writeToLog("[WARNING] Potential buffer aliasing: " +
            juce::String(getTotalNumInputChannels()) + " inputs, " +
            juce::String(getTotalNumOutputChannels()) + " outputs");
    }
}
#endif
```

### 3. **Document Your Choice**

Always add a comment explaining why you're clearing (or not):

```cpp
// ✅ GOOD: Explains the decision
// Don't clear output buffer - all channels are written explicitly below
// auto out = getBusBuffer(buffer, false, 0);

// OR:

// Must clear channel 7 as it's only conditionally written
out.clear(7, 0, numSamples);
```

---

## 📋 Quick Checklist

When you encounter "CV input always reads 0.0":

1. ✅ Check if you're calling `out.clear()`
2. ✅ Check if input and output channel counts are similar
3. ✅ Add diagnostic logging (BEFORE and AFTER clear)
4. ✅ Look for the pattern: low channels broken, high channels work
5. ✅ Try removing `out.clear()` as a test
6. ✅ If it works without clear, that's your bug!

---

## 🔬 Real-World Example

### Before (Broken)

```cpp
void TempoClockModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);    // 8 channels
    auto out = getBusBuffer(buffer, false, 0);  // 7 channels
    
    out.clear();  // ❌ Clears channels 0-6 of BOTH input and output!
    
    const float* bpmCV = in.getReadPointer(0);       // ❌ Always 0.0
    const float* swingCV = in.getReadPointer(7);     // ✅ Works (channel 7 not cleared)
    
    float bpm = bpmCV ? bpmCV[0] : 120.0f;  // Always gets 0.0!
}
```

**Symptoms:**
- `bpmCV[0]` always 0.0 ❌
- `swingCV[0]` works perfectly ✅
- Connection detection reports both as "CONNECTED" ✅

### After (Fixed)

```cpp
void TempoClockModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    auto in = getBusBuffer(buffer, true, 0);    // 8 channels
    auto out = getBusBuffer(buffer, false, 0);  // 7 channels
    
    // ✅ FIX: Don't clear output buffer - we write to all channels explicitly
    // All 7 output channels are written in the loop below, so no need to clear
    
    const float* bpmCV = in.getReadPointer(0);       // ✅ Now works!
    const float* swingCV = in.getReadPointer(7);     // ✅ Still works!
    
    float bpm = bpmCV ? bpmCV[0] : 120.0f;  // ✅ Gets real value!
    
    // Write to all output channels explicitly
    for (int i = 0; i < numSamples; ++i) {
        if (clockOut) clockOut[i] = /* ... */;
        if (beatTrig) beatTrig[i] = /* ... */;
        if (barTrig) barTrig[i] = /* ... */;
        if (beatGate) beatGate[i] = /* ... */;
        if (phaseOut) phaseOut[i] = /* ... */;
        if (bpmOut) bpmOut[i] = /* ... */;
        if (downbeat) downbeat[i] = /* ... */;
    }
}
```

---

## 🎓 Understanding JUCE Buffer Management

### Why JUCE Does This

JUCE aliases buffers for **performance optimization**:
- Reduces memory allocations
- Improves cache locality
- Allows in-place processing

### When Aliasing Happens

**High risk scenarios:**
- Input channels: 8, Output channels: 7 ⚠️
- Input channels: 10, Output channels: 8 ⚠️
- Input channels: 4, Output channels: 4 ⚠️

**Lower risk:**
- Input channels: 2, Output channels: 16 (less overlap)
- Input channels: 1, Output channels: 2 (less overlap)

### The Safe Approach

**Always assume buffers might alias!**
- Don't modify output until you're done reading input
- Or copy input values before modifying output
- Or don't clear output at all if writing everything

---

## 🛠️ Debugging Tools

### Add to Your Base Module Class

```cpp
#ifdef _DEBUG
void ModuleProcessor::debugBufferAliasing(juce::AudioBuffer<float>& buffer)
{
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    // Check if buffers share memory
    if (in.getNumChannels() > 0 && out.getNumChannels() > 0) {
        const float* inPtr = in.getReadPointer(0);
        const float* outPtr = out.getReadPointer(0);
        
        if (inPtr == outPtr) {
            juce::Logger::writeToLog("[ALIASING DETECTED] Input and output share memory!");
        }
    }
}
#endif
```

---

## 📚 Related Issues

This bug can also manifest as:
- **Crackling/glitching audio**: Output gets corrupted input data
- **Feedback loops**: Output accidentally feeds back to input
- **Intermittent bugs**: Works sometimes, fails others (depends on buffer reuse)

---

## ✅ Summary

| Symptom | Cause | Fix |
|---------|-------|-----|
| CV input always 0.0 | `out.clear()` clears aliased input | Remove `out.clear()` |
| Low channels broken, high OK | Partial buffer overlap | Don't clear or read inputs first |
| Works disconnected, broken connected | Clear happens after connection | Reorder: read → clear → process |

**Golden Rule:** 🌟
> **Read all inputs BEFORE clearing any outputs, or don't clear at all!**

---

*Last Updated: October 2025*
*Based on real debugging session with TempoClockModuleProcessor*



================================================================================
FILE: juce\Source\audio\modules\BestPracticeNodeProcessor.md
================================================================================




## Guide to Creating a "Best Practice" Module

This document outlines the best practices for creating a new `ModuleProcessor` in this modular synthesizer environment. The `BestPracticeNodeProcessor` serves as a live, working example of these principles. Following this guide ensures that new modules are robust, efficient, and integrate correctly with the UI, modulation system, and audio engine.

-----

### **1. Core Functionality of the Example Node**

[cite\_start]The `BestPracticeNodeProcessor` is a shaping oscillator that can also function as a ring modulator[cite: 148].

  * [cite\_start]**As an Oscillator**: It generates a standard waveform (Sine, Saw, or Square)[cite: 144].
  * [cite\_start]**As a Shaper**: It applies a `tanh` distortion function, controlled by a "Drive" parameter, to the generated waveform[cite: 148].
  * **As a Ring Modulator**: It multiplies its output with an incoming audio signal. [cite\_start]If no audio is connected, the input defaults to `1.0`, and it functions as a simple oscillator[cite: 148].

-----

### **2. The Modulation Input System**

This is the most critical pattern to follow. It ensures that UI parameters can be overridden by CV inputs in a thread-safe and predictable way.

#### **Step 1: Define Parameter and Modulation IDs (`.h`)**

For every parameter that can be modulated, you must define two `constexpr` string IDs in the header file: one for the parameter itself and one "virtual" ID for its modulation input.

  * [cite\_start]The **parameter ID** (e.g., `"frequency"`) is used for the `juce::AudioProcessorValueTreeState` (APVTS)[cite: 153].
  * The **virtual modulation ID** (e.g., `"frequency_mod"`) is used *only* for routing and UI checks. [cite\_start]It **must not** have a corresponding parameter in the APVTS[cite: 153].

**Example from `BestPracticeNodeProcessor.h`:**

```cpp
// Parameter IDs for APVTS
static constexpr auto paramIdFrequency    = "frequency"; [cite_start]// [cite: 153]
static constexpr auto paramIdWaveform     = "waveform"; [cite_start]// [cite: 153]
static constexpr auto paramIdDrive        = "drive"; [cite_start]// [cite: 153]

// Virtual modulation target IDs (no APVTS parameters required)
static constexpr auto paramIdFrequencyMod = "frequency_mod"; [cite_start]// [cite: 153]
static constexpr auto paramIdWaveformMod  = "waveform_mod"; [cite_start]// [cite: 153]
static constexpr auto paramIdDriveMod     = "drive_mod"; [cite_start]// [cite: 153]
```

-----

#### **Step 2: Use a Single, Unified Input Bus (`.cpp`)**

All inputs for a module, both audio and CV, should be defined on a single discrete input bus in the constructor. This simplifies the routing logic significantly.

**Example from `BestPracticeNodeProcessor.cpp`:**

```cpp
BestPracticeNodeProcessor::BestPracticeNodeProcessor()
    : ModuleProcessor(BusesProperties()
                        [cite_start].withInput("Inputs", juce::AudioChannelSet::discreteChannels(5), true) // [cite: 143]
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      // ...
```

[cite\_start]Here, the 5 channels are for Audio In L/R, Freq Mod, Wave Mod, and Drive Mod[cite: 143, 150].

-----

#### **Step 3: Implement `getParamRouting()` (`.cpp`)**

[cite\_start]This function is the bridge between the virtual modulation IDs and their physical channel indices on the input bus [cite: 157-158].

**Example from `BestPracticeNodeProcessor.cpp`:**

```cpp
bool BestPracticeNodeProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0; // All modulation is on the single input bus.
    if (paramId == paramIdFrequencyMod) { outChannelIndexInBus = 2; return true; [cite_start]} // [cite: 150]
    if (paramId == paramIdWaveformMod)  { outChannelIndexInBus = 3; return true; [cite_start]} // [cite: 150]
    if (paramId == paramIdDriveMod)     { outChannelIndexInBus = 4; return true; [cite_start]} // [cite: 150]
    return false;
}
```

-----

#### **Step 4: Use Modulation in `processBlock()` (`.cpp`)**

The audio processing logic must follow this pattern:

1.  [cite\_start]Check if a modulation input is connected using `isParamInputConnected()` with the **virtual `_mod` ID**[cite: 143].
2.  [cite\_start]If connected, get a pointer to the CV signal from the correct channel index on the input bus [cite: 143-144].
3.  In the per-sample loop, read the CV value and apply it. [cite\_start]If not connected, use the base value from the APVTS parameter[cite: 144].
4.  Update "live" telemetry values for the UI using `setLiveParamValue()`. [cite\_start]This is crucial for visual feedback[cite: 147].

**Example from `ShapingOscillatorModuleProcessor.cpp`:**

```cpp
// 1. Check for connection
const bool isFreqMod  = isParamInputConnected(paramIdFrequencyMod); [cite_start]// [cite: 708]

// 2. Get CV pointer
const float* freqCV   = isFreqMod  && inBus.getNumChannels() > 2 ? inBus.getReadPointer(2) : nullptr; [cite_start]// [cite: 709]

const float baseFrequency = frequencyParam->load();

for (int i = 0; i < buffer.getNumSamples(); ++i)
{
    // 3. Apply CV if connected
    float currentFreq = baseFrequency;
    if (isFreqMod && freqCV)
    {
        const float cv = juce::jlimit(0.0f, 1.0f, freqCV[i]); [cite_start]// [cite: 710]
        // ... logic to apply CV ...
        currentFreq = fMin * std::pow(2.0f, cv * spanOct); [cite_start]// [cite: 710]
    }

    // ... use 'currentFreq' in DSP ...

    // 4. Update telemetry (throttled)
    [cite_start]if ((i & 0x3F) == 0) // [cite: 712]
    {
        setLiveParamValue("frequency_live", smoothedFrequency.getCurrentValue()); [cite_start]// [cite: 712]
    }
}
```

-----

#### **Step 5: Implement UI Feedback in `drawParametersInNode()` (`.h`)**

The UI code must use the `isParamModulated` lambda (which is passed into the function) with the **virtual `_mod` ID** to determine the UI state.

1.  [cite\_start]Check if the parameter is modulated[cite: 148].
2.  If it is, get the live value from the audio thread using `getLiveParamValueFor()`. [cite\_start]This function takes both the virtual `_mod` ID (to re-verify the connection) and the `_live` telemetry key[cite: 148].
3.  [cite\_start]Disable the slider and show an `(mod)` indicator[cite: 148].
4.  [cite\_start]If not modulated, the slider should be active and control the APVTS parameter directly [cite: 148-149].

**Example from `BestPracticeNodeProcessor.h`:**

```cpp
// 1. Check for modulation
const bool freqIsMod = isParamModulated(paramIdFrequencyMod); [cite_start]// [cite: 148]

// 2. Get live or base value
float freq = freqIsMod ? getLiveParamValueFor(paramIdFrequencyMod, "frequency_live", frequencyParam->load())
                       : frequencyParam->load(); [cite_start]// [cite: 148]

// 3. Disable UI and show indicator
if (freqIsMod) ImGui::BeginDisabled(); [cite_start]// [cite: 148]

if (ImGui::SliderFloat("Frequency", &freq, 20.0f, 20000.0f, "%.1f Hz", ImGuiSliderFlags_Logarithmic))
{
    if (!freqIsMod) // 4. Only update parameter if not modulated
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdFrequency))) *p = freq; [cite_start]// [cite: 148-149]
}

if (freqIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); [cite_start]} // [cite: 149]
```

-----

### **3. Audio Processing Best Practices**

  * [cite\_start]**Prevent Zipper Noise**: For parameters that change rapidly (especially under modulation), use `juce::SmoothedValue` to interpolate values over time and prevent audible clicks[cite: 145]. [cite\_start]Initialize it in `prepareToPlay()` and update its target value inside the `processBlock()` loop[cite: 145].
  * **Safe State Changes**: Avoid expensive operations like memory allocation on the audio thread. [cite\_start]For waveform switching, the `BestPracticeNodeProcessor` uses a clean pattern: it only calls `oscillator.initialise()` when the integer `waveform` choice has actually changed from the previous sample [cite: 145-146].
  * **Avoid In-Place Processing Bugs 🐛**: A common mistake is to clear an output buffer before you have finished reading from the input buffer. In JUCE's `AudioProcessorGraph`, the input and output buffers can be the **same piece of memory**. Clearing the output can instantly wipe out your input signal.
      * **Incorrect Pattern**:
        ```cpp
        auto inBus = getBusBuffer(buffer, true, 0);
        auto outBus = getBusBuffer(buffer, false, 0);
        outBus.clear(); // DANGER: This might have just erased inBus!
        process(inBus); // Now processing silence.
        ```
      * **Correct Pattern**: Always perform your analysis or read your inputs *before* you modify or clear the output buffer.
        ```cpp
        auto inBus = getBusBuffer(buffer, true, 0);
        auto outBus = getBusBuffer(buffer, false, 0);

        // 1. Analyze or process the input first.
        analyze(inBus);

        // 2. Now it's safe to handle the output.
        // For passthrough, copy the original input.
        outBus.copyFrom(0, 0, inBus, 0, 0, numSamples); 
        ```
      * [cite\_start]This exact bug was found and fixed in the `FrequencyGraphModuleProcessor`[cite: 313, 314, 317].
  * [cite\_start]**Clear Pin Definitions**: Provide clear, human-readable labels for all input and output pins by overriding `getAudioInputLabel()` and `getAudioOutputLabel()`[cite: 150]. This information is used by the UI for tooltips and the pin database.

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <functional> // Required for std::function
#include <vector>
#include <map>
#include <unordered_map>
#include <atomic>

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#include <cmath>
#endif

// <<< TRANSPORT STATE FOR GLOBAL CLOCK >>>
// Transport state struct shared by all modules
struct TransportState {
    bool isPlaying = false;
    double bpm = 120.0;
    double songPositionBeats = 0.0;
    double songPositionSeconds = 0.0;
    // Optional global division broadcast from a master tempo/clock (-1 means inactive)
    std::atomic<int> globalDivisionIndex { -1 };
    // Flag to indicate if a Tempo Clock module is controlling the BPM (for UI feedback)
    std::atomic<bool> isTempoControlledByModule { false };
    
    // Custom copy constructor (atomics are not copyable by default)
    TransportState() = default;
    TransportState(const TransportState& other)
        : isPlaying(other.isPlaying)
        , bpm(other.bpm)
        , songPositionBeats(other.songPositionBeats)
        , songPositionSeconds(other.songPositionSeconds)
        , globalDivisionIndex(other.globalDivisionIndex.load())
        , isTempoControlledByModule(other.isTempoControlledByModule.load())
    {}
    
    // Custom copy assignment operator
    TransportState& operator=(const TransportState& other)
    {
        if (this != &other)
        {
            isPlaying = other.isPlaying;
            bpm = other.bpm;
            songPositionBeats = other.songPositionBeats;
            songPositionSeconds = other.songPositionSeconds;
            globalDivisionIndex.store(other.globalDivisionIndex.load());
            isTempoControlledByModule.store(other.isTempoControlledByModule.load());
        }
        return *this;
    }
};

// === RHYTHM REPORTING SYSTEM ===
// Allows modules to report their rhythmic timing for the BPM Monitor node

/**
 * Rhythm information reported by modules that produce rhythmic patterns
 */
struct RhythmInfo
{
    juce::String displayName;    // e.g., "Sequencer #3", "Animation: Walk Cycle"
    float bpm;                    // Current BPM (can be modulated live value)
    bool isActive;                // Is this source currently producing rhythm?
    bool isSynced;                // Is it synced to global transport?
    juce::String sourceType;      // "sequencer", "animation", "physics", etc.
    
    RhythmInfo() : bpm(0.0f), isActive(false), isSynced(false) {}
    RhythmInfo(const juce::String& name, float bpmValue, bool active, bool synced, const juce::String& type = "")
        : displayName(name), bpm(bpmValue), isActive(active), isSynced(synced), sourceType(type) {}
};

/**
 * Beat detection source (from audio input analysis)
 * Used by the BPM Monitor's tap tempo engine
 */
struct DetectedRhythmSource
{
    juce::String name;            // e.g., "Input 1 (Detected)"
    int inputChannel;             // Which input is being analyzed
    float detectedBPM;            // Calculated BPM from beat detection
    float confidence;             // 0.0-1.0 (how stable is the detection)
    bool isActive;                // Currently detecting beats?
    
    DetectedRhythmSource() : inputChannel(-1), detectedBPM(0.0f), confidence(0.0f), isActive(false) {}
};

// <<< MULTI-MIDI DEVICE SUPPORT >>>
// MIDI message with device source information
// This struct allows modules to filter MIDI by device and channel
struct MidiMessageWithDevice {
    juce::MidiMessage message;
    juce::String deviceIdentifier;
    juce::String deviceName;
    int deviceIndex = -1;
};

// <<< ALL PIN-RELATED DEFINITIONS ARE NOW CENTRALIZED HERE >>>

// Defines the data type of a modulation or audio signal
enum class PinDataType { CV, Audio, Gate, Raw, Video };

// Forward declare NodeWidth enum (defined in ImGuiNodeEditorComponent.h)
// This avoids circular dependency while allowing ModulePinInfo to store it
enum class NodeWidth;

// Describes a single audio/CV input or output pin
struct AudioPin
{
    juce::String name;
    int channel;
    PinDataType type;
    
    AudioPin(const juce::String& n, int ch, PinDataType t) : name(n), channel(ch), type(t) {}
};

// Renamed to avoid conflict with ImGuiNodeEditorComponent's PinInfo
struct DynamicPinInfo {
    juce::String name;
    int channel;
    PinDataType type;

    // Constructor to allow brace-initialization
    DynamicPinInfo(const juce::String& n, int c, PinDataType t) : name(n), channel(c), type(t) {}
};

// Describes a single modulation input pin targeting a parameter
struct ModPin
{
    juce::String name;
    juce::String paramId;
    PinDataType type;
    
    ModPin(const juce::String& n, const juce::String& p, PinDataType t) : name(n), paramId(p), type(t) {}
};

// A collection of all pins for a given module type
struct ModulePinInfo
{
    NodeWidth defaultWidth;  // Standardized node width category
    std::vector<AudioPin> audioIns;
    std::vector<AudioPin> audioOuts;
    std::vector<ModPin> modIns;
    
    ModulePinInfo() : defaultWidth(static_cast<NodeWidth>(0)) {}  // Default to Small (0)
    
    ModulePinInfo(NodeWidth width,
                  std::initializer_list<AudioPin> ins,
                  std::initializer_list<AudioPin> outs,
                  std::initializer_list<ModPin> mods)
        : defaultWidth(width), audioIns(ins), audioOuts(outs), modIns(mods) {}
};

// Forward declaration for NodePinHelpers
class ModuleProcessor;

// Helper struct passed to modules for drawing their pins
struct NodePinHelpers
{
    std::function<void(const char* label, int channel)> drawAudioInputPin;
    std::function<void(const char* label, int channel)> drawAudioOutputPin;
    std::function<void(const char* inLabel, int inChannel, const char* outLabel, int outChannel)> drawParallelPins;
    std::function<void(ModuleProcessor* module)> drawIoPins;
};

class ModularSynthProcessor; // forward declaration

/**
    An abstract base class for all modular synthesizer components.

    This class enforces a common interface for modules, ensuring they can be
    managed by the ModularSynthProcessor. The key requirement is providing access
    to the module's own parameter state via getAPVTS().
*/
class ModuleProcessor : public juce::AudioProcessor
{
public:
    ModuleProcessor(const BusesProperties& ioLayouts) : juce::AudioProcessor(ioLayouts) {}
    ~ModuleProcessor() override = default;

    // Parent container link (set by ModularSynthProcessor when node is created)
    void setParent(ModularSynthProcessor* parent) { parentSynth = parent; }
    ModularSynthProcessor* getParent() const { return parentSynth; }

    // Pure virtual method that all concrete modules MUST implement.
    // This is crucial for the parameter proxy system.
    virtual juce::AudioProcessorValueTreeState& getAPVTS() = 0;

    // Optional UI hook for drawing parameters inside nodes (used by Preset Creator)
    virtual void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
    {
        juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded);
    }

    // Optional UI hook for drawing IO pins inside nodes
    virtual void drawIoPins(const NodePinHelpers& /*helpers*/) {}

#if defined(PRESET_CREATOR_UI)
    // Optional UI hook for modules that need custom node dimensions (Exception size category)
    // Return ImVec2(width, height) for custom size, or ImVec2(0, 0) to use default from PinDatabase
    // Height of 0 means auto-size to content (recommended for most cases)
    virtual ImVec2 getCustomNodeSize() const 
    { 
        return ImVec2(0.0f, 0.0f); // Default: use PinDatabase size
    }
#endif


    // Get the current output value for a channel (for visualization)
    virtual float getOutputChannelValue(int channel) const
    {
        if (juce::isPositiveAndBelow(channel, (int)lastOutputValues.size()) && lastOutputValues[channel])
            return lastOutputValues[channel]->load();
        return 0.0f;
    }
    
    // Helper method to update output telemetry with peak magnitude
    // Call this at the end of processBlock to update visualization values
    void updateOutputTelemetry(const juce::AudioBuffer<float>& buffer)
    {
        const int numChannels = juce::jmin(buffer.getNumChannels(), (int)lastOutputValues.size());
        for (int ch = 0; ch < numChannels; ++ch)
        {
            if (lastOutputValues[ch])
            {
                // Use peak magnitude (max absolute value) for better visualization
                const float peak = buffer.getMagnitude(ch, 0, buffer.getNumSamples());
                lastOutputValues[ch]->store(peak, std::memory_order_relaxed);
            }
        }
    }

    // Standardized labels for module audio I/O channels (override per module if needed)
    virtual juce::String getAudioInputLabel(int channel) const
    {
        return juce::String("In ") + juce::String(channel + 1);
    }

    virtual juce::String getAudioOutputLabel(int channel) const
    {
        return juce::String("Out ") + juce::String(channel + 1);
    }

    // Stable logical ID assigned by ModularSynthProcessor upon node creation.
    void setLogicalId(juce::uint32 id) { storedLogicalId = id; }
    juce::uint32 getLogicalId() const { return storedLogicalId; }

    // Secondary logical ID for extra outputs (like cropped video from detector nodes)
    void setSecondaryLogicalId(juce::uint32 id) { storedSecondaryLogicalId = id; }
    juce::uint32 getSecondaryLogicalId() const { return storedSecondaryLogicalId; }

    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get detailed connection information for debugging
    virtual juce::String getConnectionDiagnostics() const
    {
        juce::String result = "=== CONNECTION DIAGNOSTICS ===\n";
        
        // Bus layout info
        result += "Input Buses: " + juce::String(getBusCount(true)) + "\n";
        result += "Output Buses: " + juce::String(getBusCount(false)) + "\n";
        
        for (int bus = 0; bus < getBusCount(true); ++bus)
        {
            auto busName = getBus(true, bus)->getName();
            auto numChannels = getBus(true, bus)->getNumberOfChannels();
            result += "  Input Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        for (int bus = 0; bus < getBusCount(false); ++bus)
        {
            auto busName = getBus(false, bus)->getName();
            auto numChannels = getBus(false, bus)->getNumberOfChannels();
            result += "  Output Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        return result;
    }
    
    // Get parameter routing diagnostics
    virtual juce::String getParameterRoutingDiagnostics() const
    {
        juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
        
        // Note: This method is const, so we can't access getAPVTS() directly
        // We'll return a placeholder for now
        result += "Parameter routing diagnostics require non-const access.\n";
        result += "Use getModuleDiagnostics() from ModularSynthProcessor instead.\n";
        
        return result;
    }
    
    // Get live parameter values for debugging
    virtual juce::String getLiveParameterDiagnostics() const
    {
        juce::String result = "=== LIVE PARAMETER VALUES ===\n";
        
        for (const auto& pair : paramLiveValues)
        {
            result += "  " + pair.first + ": " + juce::String(pair.second.load(), 4) + "\n";
        }
        
        return result;
    }
    
    // Get comprehensive module diagnostics
    virtual juce::String getAllDiagnostics() const
    {
        juce::String result = "=== MODULE DIAGNOSTICS ===\n";
        result += "Module Type: " + getName() + "\n\n";
        result += getConnectionDiagnostics() + "\n";
        result += getParameterRoutingDiagnostics() + "\n";
        result += getLiveParameterDiagnostics();
        return result;
    }


    /**
        Resolves a parameter's string ID to its modulation bus and channel.

        This is a virtual function that each module must override to declare which of its
        parameters can be modulated by an external signal. The function maps parameter IDs
        to their corresponding input bus and channel indices within that bus.

        @param paramId              The string ID of the parameter to query (e.g., "cutoff", "frequency").
        @param outBusIndex          Receives the index of the input bus used for modulation.
        @param outChannelIndexInBus Receives the channel index within that bus.
        @returns                    True if the parameter supports modulation, false otherwise.
        
        @see isParamInputConnected
    */
    virtual bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const;

    /**
        Checks if a parameter's modulation input is connected in the synth graph.

        This is the single, reliable method for a module's audio thread to determine
        if it should use an incoming CV signal instead of its internal parameter value.
        The function internally uses getParamRouting() to resolve the parameter to its
        bus/channel location, then queries the parent synth's connection graph.

        @param paramId The string ID of the parameter to check (e.g., "cutoff", "frequency").
        @returns       True if a cable is connected to this parameter's modulation input.
        
        @see getParamRouting
    */
    bool isParamInputConnected(const juce::String& paramId) const;

    // --- Live telemetry for UI (thread-safe, lock-free) ---
    void setLiveParamValue(const juce::String& paramId, float value)
    {
        auto result = paramLiveValues.try_emplace(paramId, value);
        if (!result.second)
            result.first->second.store(value, std::memory_order_relaxed);
    }

    float getLiveParamValue(const juce::String& paramId, float fallback) const
    {
        // FIX: Only return the "live" (modulated) value if the corresponding
        // modulation input is actually connected. Otherwise, always return the
        // fallback, which is the base parameter's real value.
        if (isParamInputConnected(paramId))
        {
            if (auto it = paramLiveValues.find(paramId); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // New helper: decouple the connectivity check (modParamId) from the live value key (liveKey).
    // This allows UI code to ask "is X_mod connected?" while reading the corresponding
    // live telemetry stored under a different key like "X_live".
    float getLiveParamValueFor(const juce::String& modParamId,
                               const juce::String& liveKey,
                               float fallback) const
    {
        if (isParamInputConnected(modParamId))
        {
            if (auto it = paramLiveValues.find(liveKey); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // Optional extra state hooks for modules that need to persist non-parameter data
    // Default: return invalid tree / ignore.
    virtual juce::ValueTree getExtraStateTree() const { return {}; }
    virtual void setExtraStateTree(const juce::ValueTree&) {}
    
    // Optional timing info hook for modules that need global clock/transport
    // Default: ignore (modules that don't need timing can skip implementing this)
    virtual void setTimingInfo(const TransportState& state) { juce::ignoreUnused(state); }
    
    // Optional rhythm reporting hook for BPM Monitor node
    // Modules that produce rhythmic patterns can implement this to report their BPM
    // Default: return empty (module doesn't produce rhythm)
    virtual std::optional<RhythmInfo> getRhythmInfo() const { return std::nullopt; }
    
    // Optional dynamic pin interface for modules with variable I/O (e.g., polyphonic modules)
    // Default: return empty vector (no dynamic pins)
    virtual std::vector<DynamicPinInfo> getDynamicInputPins() const { return {}; }
    virtual std::vector<DynamicPinInfo> getDynamicOutputPins() const { return {}; }
    
    /**
        Device-aware MIDI processing (MULTI-MIDI CONTROLLER SUPPORT)
        
        This method is called by ModularSynthProcessor BEFORE the standard graph processing
        begins. It provides MIDI modules with device-aware MIDI messages that include the
        source device information (name, identifier, index).
        
        MIDI modules should override this method to:
        - Filter messages by device (e.g., only respond to a specific controller)
        - Filter messages by MIDI channel
        - Update internal state based on filtered MIDI input
        
        The regular processBlock() can then use this updated state to generate CV outputs.
        
        @param midiMessages A vector of MIDI messages with device source information
        
        Default implementation: Does nothing (opt-in for MIDI modules only)
        
        @see MidiMessageWithDevice
    */
    virtual void handleDeviceSpecificMidi(const std::vector<MidiMessageWithDevice>& midiMessages)
    {
        juce::ignoreUnused(midiMessages);
        // Default: do nothing. MIDI-aware modules will override this method.
    }

public:
    // OPTION 9: Make public for TTS debugging
    // Live, modulated parameter values for UI feedback
    std::unordered_map<juce::String, std::atomic<float>> paramLiveValues;

protected:
    // Thread-safe storage for last known output values (for tooltips)
    std::vector<std::unique_ptr<std::atomic<float>>> lastOutputValues;

#if defined(PRESET_CREATOR_UI)

    static void adjustParamOnWheel (juce::RangedAudioParameter* parameter,
                                    const juce::String& idOrName,
                                    float displayedValue)
    {
        if (parameter == nullptr) return;
        if (! ImGui::IsItemHovered()) return;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel == 0.0f) return;

        if (auto* pf = dynamic_cast<juce::AudioParameterFloat*>(parameter))
        {
            // No right-click editing here; modules can add InputFloat next to sliders

            const auto& range = pf->range;
            const float span = range.end - range.start;
            const juce::String id = idOrName.toLowerCase();

            float step = span / 200.0f; // default ~0.5% of range
            if (span <= 1.0f) step = 0.01f;
            // Custom: fine tune for sequencer steps
            if (id.contains ("step"))
            {
                step = 0.05f;
            }
            if (id.contains ("hz") || id.contains ("freq") || id.contains ("cutoff") || id.contains ("rate"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (1.0f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("ms") || id.contains ("time"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (0.1f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("db") || id.contains ("gain"))
            {
                step = 0.5f;
            }
            else if (id.contains ("mix") || id.contains ("depth") || id.contains ("amount") || id.contains ("resonance") || id.contains ("q") || id.contains ("size") || id.contains ("damp") || id.contains ("pan") || id.contains ("threshold"))
            {
                step = 0.01f;
            }

            float newVal = pf->get() + (wheel > 0 ? step : -step);
            newVal = juce::jlimit (range.start, range.end, newVal);
            *pf = newVal;
        }
        else if (auto* pc = dynamic_cast<juce::AudioParameterChoice*>(parameter))
        {
            int idx = pc->getIndex();
            idx += (ImGui::GetIO().MouseWheel > 0 ? 1 : -1);
            idx = juce::jlimit (0, pc->choices.size() - 1, idx);
            *pc = idx;
        }
        else if (auto* pi = dynamic_cast<juce::AudioParameterInt*>(parameter))
        {
            int currentVal = pi->get();
            int newVal = currentVal + (wheel > 0 ? 1 : -1);
            const auto& range = pi->getNormalisableRange();
            newVal = juce::jlimit((int)range.start, (int)range.end, newVal);
            *pi = newVal;
        }
        else if (auto* pb = dynamic_cast<juce::AudioParameterBool*>(parameter))
        {
            // Optional: toggle on strong scroll
            juce::ignoreUnused (pb);
        }
    }

#endif

public:
    //==============================================================================
    // Helper function to convert bus index and channel-in-bus to absolute channel index
    //==============================================================================
    int getChannelIndexInProcessBlockBuffer(bool isInput, int busIndex, int channelIndexInBus) const
    {
        int absoluteChannel = channelIndexInBus;
        if (busIndex > 0)
        {
            int sum = 0;
            const int numBuses = getBusCount(isInput);
            for (int b = 0; b < numBuses && b < busIndex; ++b)
                sum += getChannelCountOfBus(isInput, b);
            absoluteChannel = sum + channelIndexInBus;
        }
        return absoluteChannel;
    }

    //==============================================================================
    // Provide default implementations for the pure virtuals to reduce boilerplate
    // in concrete module classes.
    //==============================================================================
    const juce::String getName() const override { return "Module"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModuleProcessor)

protected:
    ModularSynthProcessor* parentSynth { nullptr };
    juce::uint32 storedLogicalId { 0 };
    juce::uint32 storedSecondaryLogicalId { 0 };
};

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.cpp
================================================================================


#include "ModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <unordered_set>


bool ModuleProcessor::getParamRouting(const juce::String& /*paramId*/, int& /*outBusIndex*/, int& /*outChannelIndexInBus*/) const
{
    return false;
}

bool ModuleProcessor::isParamInputConnected(const juce::String& paramId) const
{
    auto* synth = parentSynth;
    if (synth == nullptr)
        return false;

#if JUCE_DEBUG
    if (synth->isGraphMutationPending())
    {
        juce::Logger::writeToLog("[Graph][WARN] isParamInputConnected invoked during graph mutation for param '"
                                 + paramId + "' on module LID " + juce::String((int)storedLogicalId));
    }
#endif

    juce::uint32 myLogicalId = storedLogicalId;
    if (myLogicalId == 0)
    {
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical (info.first) == this)
            {
                myLogicalId = info.first;
                break;
            }
        }
        if (myLogicalId == 0)
            return false;
    }

    int busIndex = -1;
    int chanInBus = -1;
    if (!getParamRouting(paramId, busIndex, chanInBus))
        return false;

    int absoluteChannel = chanInBus;
    if (busIndex > 0)
    {
        int sum = 0;
        const int numInputBuses = getBusCount(true);
        for (int b = 0; b < numInputBuses && b < busIndex; ++b)
            sum += getChannelCountOfBus(true, b);
        absoluteChannel = sum + chanInBus;
    }

    auto connectionsSnapshot = synth->getConnectionSnapshot();
    if (! connectionsSnapshot)
        return false;

    for (const auto& c : *connectionsSnapshot)
        if (c.dstLogicalId == myLogicalId && c.dstChan == absoluteChannel)
            return true;

    // Fallback: if stored logicalId yields no match, re-resolve by pointer and retry once.
    {
        juce::uint32 ptrResolvedId = 0;
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical(info.first) == this)
            {
                ptrResolvedId = info.first;
                break;
            }
        }
        if (ptrResolvedId != 0 && ptrResolvedId != myLogicalId)
        {
            for (const auto& c : *connectionsSnapshot)
            {
                if (c.dstLogicalId == ptrResolvedId && c.dstChan == absoluteChannel)
                {
                    const_cast<ModuleProcessor*>(this)->setLogicalId(ptrResolvedId);
                    return true;
                }
            }
        }
    }

    return false;
}


================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.cpp
================================================================================


#include "ImGuiNodeEditorComponent.h"
#include "PinDatabase.h"
#include "SavePresetJob.h"
#include "NotificationManager.h"
#include "PresetValidator.h"
#include "PresetAutoHealer.h"

#include <imgui.h>
#include <imgui_internal.h>
#include <imnodes.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <backends/imgui_impl_opengl2.h>
#include <cmath>
#include <cstring>
#include <juce_core/juce_core.h>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <vector>
#include <cstdint>
#include <algorithm>
#include <limits>
#include <optional>
#include "theme/ThemeManager.h"

namespace
{
    using collider::KeyChord;

    [[nodiscard]] bool chordsEqual(const KeyChord& a, const KeyChord& b) noexcept
    {
        return a.key == b.key && a.ctrl == b.ctrl && a.shift == b.shift &&
               a.alt == b.alt && a.superKey == b.superKey;
    }

    [[nodiscard]] juce::String contextDisplayName(const juce::Identifier& contextId)
    {
        if (contextId == collider::ShortcutManager::getGlobalContextIdentifier())
            return "Global";
        if (contextId == ImGuiNodeEditorComponent::nodeEditorContextId)
            return "Node Editor";
        return contextId.toString();
    }
}

#if JUCE_DEBUG
namespace
{
struct ImGuiStackBalanceChecker
{
    ImGuiContext* ctx { ImGui::GetCurrentContext() };
    ImGuiWindow* window { ctx ? ctx->CurrentWindow : nullptr };
    float indent { window ? window->DC.Indent.x : 0.0f };
    float groupOffset { window ? window->DC.GroupOffset.x : 0.0f };
    float columnsOffset { window ? window->DC.ColumnsOffset.x : 0.0f };

    void validate(const juce::String& label)
    {
        if (ctx == nullptr)
            return;

        if (window != nullptr)
        {
            constexpr float epsilon = 1.0e-4f;
            auto approxEqual = [](float a, float b, float eps) noexcept
            {
                return std::abs(a - b) <= eps;
            };

            if (!approxEqual(window->DC.Indent.x, indent, epsilon)
                || !approxEqual(window->DC.GroupOffset.x, groupOffset, epsilon)
                || !approxEqual(window->DC.ColumnsOffset.x, columnsOffset, epsilon))
            {
                juce::Logger::writeToLog("[ImGui][IndentLeak] " + label
                                         + " indent=" + juce::String(window->DC.Indent.x)
                                         + " expected=" + juce::String(indent));
                jassertfalse;
                window->DC.Indent.x = indent;
                window->DC.GroupOffset.x = groupOffset;
                window->DC.ColumnsOffset.x = columnsOffset;
            }
        }
    }
};
}
#else
struct ImGuiStackBalanceChecker
{
    ImGuiStackBalanceChecker() = default;
    void validate(const juce::String&) const {}
};
#endif

// Lightweight theme change toast state
static double s_themeToastEndTime = 0.0;
static juce::String s_themeToastText;

// ============================================================================
// Global GPU/CPU Settings (default: GPU enabled for best performance)
// ============================================================================
bool ImGuiNodeEditorComponent::s_globalGpuEnabled = true;
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/modules/RerouteModuleProcessor.h"
#include "../audio/modules/AudioInputModuleProcessor.h"
#include "../audio/modules/AttenuverterModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/RandomModuleProcessor.h"
#include "../audio/modules/ValueModuleProcessor.h"
#include "../audio/modules/SampleLoaderModuleProcessor.h"
#include "../audio/modules/MIDIPlayerModuleProcessor.h"
#include "../audio/modules/PolyVCOModuleProcessor.h"
#include "../audio/modules/TrackMixerModuleProcessor.h"
#include "../audio/modules/MathModuleProcessor.h"
#include "../audio/modules/StepSequencerModuleProcessor.h"
#include "../audio/modules/MultiSequencerModuleProcessor.h"
#include "../audio/modules/StrokeSequencerModuleProcessor.h"
#include "../audio/modules/AnimationModuleProcessor.h"
#include "../audio/modules/TempoClockModuleProcessor.h"
#include "../audio/modules/WebcamLoaderModule.h"
#include "../audio/modules/VideoFileLoaderModule.h"
#include "../audio/modules/MovementDetectorModule.h"
#include "../audio/modules/PoseEstimatorModule.h"
#include "../audio/modules/ColorTrackerModule.h"
#include "../audio/modules/ContourDetectorModule.h"
#include "../audio/modules/ObjectDetectorModule.h"
#include "../audio/modules/HandTrackerModule.h"
#include "../audio/modules/FaceTrackerModule.h"
#include "../audio/modules/VideoFXModule.h"
#include "../audio/modules/CropVideoModule.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/LagProcessorModuleProcessor.h"
#include "../audio/modules/DeCrackleModuleProcessor.h"
#include "../audio/modules/GraphicEQModuleProcessor.h"
#include "../audio/modules/FrequencyGraphModuleProcessor.h"
#include "../audio/modules/ChorusModuleProcessor.h"
#include "../audio/modules/PhaserModuleProcessor.h"
#include "../audio/modules/CompressorModuleProcessor.h"
#include "../audio/modules/RecordModuleProcessor.h"
#include "../audio/modules/CommentModuleProcessor.h"
#include "../audio/modules/LimiterModuleProcessor.h"
#include "../audio/modules/GateModuleProcessor.h"
#include "../audio/modules/DriveModuleProcessor.h"
#include "../audio/modules/VstHostModuleProcessor.h"
// #include "../audio/modules/SnapshotSequencerModuleProcessor.h"  // Commented out - causing build errors
#include "../audio/modules/MIDICVModuleProcessor.h"
#include "../audio/modules/ScopeModuleProcessor.h"
#include "../audio/modules/MetaModuleProcessor.h"
#include "../audio/modules/InletModuleProcessor.h"
#include "../audio/modules/OutletModuleProcessor.h"
#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include <juce_audio_processors/juce_audio_processors.h>
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>
#include <juce_opengl/juce_opengl.h>

#if JUCE_DEBUG
static int gImNodesNodeDepth = 0;
static int gImNodesInputDepth = 0;
static int gImNodesOutputDepth = 0;
static juce::String gLastRenderedNodeLabel;

struct ImNodesDepthSnapshot
{
    int node;
    int input;
    int output;
    juce::String label;

    ImNodesDepthSnapshot(const juce::String& lbl)
        : node(gImNodesNodeDepth),
          input(gImNodesInputDepth),
          output(gImNodesOutputDepth),
          label(lbl) {}

    ~ImNodesDepthSnapshot()
    {
        if (gImNodesNodeDepth != node || gImNodesInputDepth != input || gImNodesOutputDepth != output)
        {
            juce::Logger::writeToLog("[ImNodes][DepthLeak] " + label
                                     + " node=" + juce::String(gImNodesNodeDepth) + " (expected " + juce::String(node) + ")"
                                     + " input=" + juce::String(gImNodesInputDepth) + " (expected " + juce::String(input) + ")"
                                     + " output=" + juce::String(gImNodesOutputDepth) + " (expected " + juce::String(output) + ")");
            jassertfalse;

            // Reset to avoid cascading logs
            gImNodesNodeDepth = node;
            gImNodesInputDepth = input;
            gImNodesOutputDepth = output;
        }
    }
};
#endif

#define NODE_DEBUG 0

// --- Module Descriptions for Tooltips ---
static const char* toString(PinDataType t)
{
    switch (t)
    {
        case PinDataType::Audio: return "Audio";
        case PinDataType::CV: return "CV";
        case PinDataType::Gate: return "Gate";
        case PinDataType::Raw: return "Raw";
        case PinDataType::Video: return "Video";
        default: return "Unknown";
    }
}

#define LOG_LINK(msg) do { if (NODE_DEBUG) juce::Logger::writeToLog("[LINK] " + juce::String(msg)); } while(0)

struct Range { float min; float max; };

// Forward declarations
class ModularSynthProcessor;
class RandomModuleProcessor;
class ValueModuleProcessor;
class StepSequencerModuleProcessor;
class MapRangeModuleProcessor;

// Helper methods for MapRange configuration
ImGuiNodeEditorComponent::Range getSourceRange(const ImGuiNodeEditorComponent::PinID& srcPin, ModularSynthProcessor* synth)
{
    if (synth == nullptr) return {0.0f, 1.0f};
    
    auto* module = synth->getModuleForLogical(srcPin.logicalId);
    if (auto* random = dynamic_cast<RandomModuleProcessor*>(module))
    {
        auto& ap = random->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* value = dynamic_cast<ValueModuleProcessor*>(module))
    {
        auto& ap = value->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* stepSeq = dynamic_cast<StepSequencerModuleProcessor*>(module))
    {
        // StepSequencer outputs CV range
        return {0.0f, 1.0f};
    }
    // Fallback: estimate from source's lastOutputValues
    // TODO: implement fallback estimation
    return {0.0f, 1.0f};
}

void configureMapRangeFor(PinDataType srcType, PinDataType dstType, MapRangeModuleProcessor& m, ImGuiNodeEditorComponent::Range inRange)
{
    auto& ap = m.getAPVTS();
    
    // Set input range
    if (auto* inMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin")))
        *inMinParam = inRange.min;
    if (auto* inMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax")))
        *inMaxParam = inRange.max;
    
    // Set output range based on destination type
    if (dstType == PinDataType::Audio)
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = -1.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
    else // CV or Gate
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = 0.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
}




ImGuiNodeEditorComponent::ImGuiNodeEditorComponent(juce::AudioDeviceManager& dm)
    : deviceManager(dm)
{
    juce::Logger::writeToLog("ImGuiNodeEditorComponent constructor starting...");
    
    // --- THIS WILL BE THE SMOKING GUN ---
    juce::Logger::writeToLog("About to populate pin database...");
    populatePinDatabase(); // Initialize the pin database for color coding
    populateDragInsertSuggestions();
    juce::Logger::writeToLog("Pin database populated.");
    
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
    registerShortcuts();

    // Wire Theme Editor to use framebuffer-based eyedropper
    themeEditor.setStartPicker([this](std::function<void(ImU32)> onPicked){ this->startColorPicking(std::move(onPicked)); });
    
    // Initialize browser paths (load from saved settings or use defaults)
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        // Load the last used paths, providing defaults if they don't exist
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultPresetPath = appFile.getParentDirectory().getChildFile("Presets");
        juce::File defaultSamplePath = appFile.getParentDirectory().getChildFile("Samples");

        m_presetScanPath = juce::File(props->getValue("presetScanPath", defaultPresetPath.getFullPathName()));
        m_sampleScanPath = juce::File(props->getValue("sampleScanPath", defaultSamplePath.getFullPathName()));
    }
    
    // Create these directories if they don't already exist
    if (!m_presetScanPath.exists())
        m_presetScanPath.createDirectory();
    if (!m_sampleScanPath.exists())
        m_sampleScanPath.createDirectory();
    
    juce::Logger::writeToLog("[UI] Preset path set to: " + m_presetScanPath.getFullPathName());
    juce::Logger::writeToLog("[UI] Sample path set to: " + m_sampleScanPath.getFullPathName());
    
    // --- MIDI BROWSER PATH INITIALIZATION ---
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultMidiPath = appFile.getParentDirectory().getChildFile("audio").getChildFile("MIDI");
        m_midiScanPath = juce::File(props->getValue("midiScanPath", defaultMidiPath.getFullPathName()));
    }
    if (!m_midiScanPath.exists())
        m_midiScanPath.createDirectory();
    juce::Logger::writeToLog("[UI] MIDI path set to: " + m_midiScanPath.getFullPathName());
    // --- END OF MIDI INITIALIZATION ---
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    unregisterShortcuts();
    glContext.detach();
}

void ImGuiNodeEditorComponent::registerShortcuts()
{
    auto registerAction = [this](const juce::Identifier& id,
                                 const char* name,
                                 const char* description,
                                 const char* category,
                                 const collider::KeyChord& chord,
                                 std::atomic<bool>& flag)
    {
        collider::ShortcutAction action { id, juce::String(name), juce::String(description), juce::String(category) };
        shortcutManager.registerAction(action, [this, &flag]()
        {
            flag.store(true, std::memory_order_release);
        });
        shortcutManager.setDefaultBinding(id, nodeEditorContextId, chord);
    };

    registerAction(ShortcutActionIds::fileSave,
                   "Save Preset",
                   "Save the current patch to its file.",
                   "File",
                   { ImGuiKey_S, true, false, false, false },
                   shortcutFileSaveRequested);

    registerAction(ShortcutActionIds::fileSaveAs,
                   "Save Preset As…",
                   "Save the current patch to a new file.",
                   "File",
                   { ImGuiKey_S, true, false, true, false },
                   shortcutFileSaveAsRequested);

    registerAction(ShortcutActionIds::fileOpen,
                   "Load Preset",
                   "Open a preset from disk.",
                   "File",
                   { ImGuiKey_O, true, false, false, false },
                   shortcutFileOpenRequested);

    registerAction(ShortcutActionIds::fileRandomizePatch,
                   "Randomize Patch",
                   "Randomize the entire patch.",
                   "File",
                   { ImGuiKey_P, true, false, false, false },
                   shortcutRandomizePatchRequested);

    registerAction(ShortcutActionIds::fileRandomizeConnections,
                   "Randomize Connections",
                   "Randomize node connections.",
                   "File",
                   { ImGuiKey_M, true, false, false, false },
                   shortcutRandomizeConnectionsRequested);

    registerAction(ShortcutActionIds::fileBeautifyLayout,
                   "Beautify Layout",
                   "Automatically tidy the node layout.",
                   "File",
                   { ImGuiKey_B, true, false, false, false },
                   shortcutBeautifyLayoutRequested);

    registerAction(ShortcutActionIds::editCtrlR,
                   "Record Output / Reset Selection",
                   "Record the output when nothing is selected or reset selected nodes to defaults.",
                   "Edit",
                   { ImGuiKey_R, true, false, false, false },
                   shortcutCtrlRRequested);

    registerAction(ShortcutActionIds::editSelectAll,
                   "Select All",
                   "Select every node in the graph.",
                   "Edit",
                   { ImGuiKey_A, true, false, false, false },
                   shortcutSelectAllRequested);

    registerAction(ShortcutActionIds::editMuteSelection,
                   "Toggle Mute",
                   "Mute or bypass the selected nodes.",
                   "Edit",
                   { ImGuiKey_M, false, false, false, false },
                   shortcutMuteSelectionRequested);

    registerAction(ShortcutActionIds::editConnectOutput,
                   "Connect to Output",
                   "Wire the selected node to the main output.",
                   "Edit",
                   { ImGuiKey_O, false, false, false, false },
                   shortcutConnectOutputRequested);

    registerAction(ShortcutActionIds::editDisconnectSelection,
                   "Disconnect Selection",
                   "Remove all connections from selected nodes.",
                   "Edit",
                   { ImGuiKey_D, false, false, true, false },
                   shortcutDisconnectRequested);

    registerAction(ShortcutActionIds::editDuplicate,
                   "Duplicate Selection",
                   "Duplicate selected nodes.",
                   "Edit",
                   { ImGuiKey_D, true, false, false, false },
                   shortcutDuplicateRequested);

    registerAction(ShortcutActionIds::editDuplicateWithRouting,
                   "Duplicate Selection (With Routing)",
                   "Duplicate selected nodes and replicate their connections.",
                   "Edit",
                   { ImGuiKey_D, false, true, false, false },
                   shortcutDuplicateWithRoutingRequested);

    registerAction(ShortcutActionIds::editDelete,
                   "Delete Selection",
                   "Delete selected nodes or links.",
                   "Edit",
                   { ImGuiKey_Delete, false, false, false, false },
                   shortcutDeleteRequested);

    registerAction(ShortcutActionIds::editBypassDelete,
                   "Bypass Delete",
                   "Delete selected nodes while preserving signal flow.",
                   "Edit",
                   { ImGuiKey_Delete, false, true, false, false },
                   shortcutBypassDeleteRequested);

    registerAction(ShortcutActionIds::viewFrameSelection,
                   "Frame Selection",
                   "Frame the currently selected nodes.",
                   "View",
                   { ImGuiKey_F, false, false, false, false },
                   shortcutFrameSelectionRequested);

    registerAction(ShortcutActionIds::viewFrameAll,
                   "Frame All",
                   "Frame the entire graph.",
                   "View",
                   { ImGuiKey_Home, false, false, false, false },
                   shortcutFrameAllRequested);

    registerAction(ShortcutActionIds::viewResetOrigin,
                   "Reset View Origin",
                   "Reset the editor panning to the origin.",
                   "View",
                   { ImGuiKey_Home, true, false, false, false },
                   shortcutResetOriginRequested);

    registerAction(ShortcutActionIds::viewToggleMinimap,
                   "Toggle Minimap Zoom",
                   "Temporarily enlarge the minimap.",
                   "View",
                   { ImGuiKey_Comma, false, false, false, false },
                   shortcutToggleMinimapRequested);

    // This action now opens the new Help Manager to the Shortcuts tab
    // If a node is selected, opens to that node's dictionary entry instead
    shortcutManager.registerAction(
        { ShortcutActionIds::viewToggleShortcutsWindow, "Help Manager", "Show the Help Manager window.", "Help" },
        [this]() {
            // Check if a node is selected
            int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                // Get the first selected node
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                if (!selectedNodeIds.empty())
                {
                    juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                    if (synth != nullptr)
                    {
                        juce::String moduleType = synth->getModuleTypeForLogical(logicalId);
                        
                        if (moduleType.isNotEmpty())
                        {
                            // Open Help Manager to this node's dictionary entry
                            m_helpManager.openToNode(moduleType);
                            return;
                        }
                    }
                }
            }
            
            // Default behavior: open to Shortcuts tab
            m_helpManager.open();
            m_helpManager.setActiveTab(0); // 0 = Shortcuts tab
        }
    );
    shortcutManager.setDefaultBinding(ShortcutActionIds::viewToggleShortcutsWindow, nodeEditorContextId, { ImGuiKey_F1, false, false, false, false });

    registerAction(ShortcutActionIds::historyUndo,
                   "Undo",
                   "Revert the last action.",
                   "History",
                   { ImGuiKey_Z, true, false, false, false },
                   shortcutUndoRequested);

    registerAction(ShortcutActionIds::historyRedo,
                   "Redo",
                   "Redo the last undone action.",
                   "History",
                   { ImGuiKey_Y, true, false, false, false },
                   shortcutRedoRequested);

    registerAction(ShortcutActionIds::debugToggleOverlay,
                   "Toggle Debug Menu",
                   "Show or hide the diagnostics window.",
                   "Debug",
                   { ImGuiKey_D, true, true, false, false },
                   shortcutToggleDebugRequested);

    registerAction(ShortcutActionIds::graphInsertMixer,
                   "Insert Mixer",
                   "Insert a mixer after the selected node.",
                   "Graph",
                   { ImGuiKey_None, false, false, false, false }, // No default shortcut - user can assign if needed
                   shortcutInsertMixerRequested);

    registerAction(ShortcutActionIds::graphConnectSelectedToTrackMixer,
                   "Connect Selected to Track Mixer",
                   "Connect selected nodes to a new Track Mixer with automatic routing.",
                   "Graph",
                   { ImGuiKey_T, true, false, false, false }, // Ctrl+T default
                   shortcutConnectSelectedToTrackMixerRequested);

    registerAction(ShortcutActionIds::graphShowInsertPopup,
                   "Open Insert Node Popup",
                   "Open the insert node popup for the selected node.",
                   "Graph",
                   { ImGuiKey_I, true, false, false, false },
                   shortcutShowInsertPopupRequested);

    registerAction(ShortcutActionIds::graphInsertOnLink,
                   "Insert Node On Link",
                   "Insert a node on the hovered link.",
                   "Graph",
                   { ImGuiKey_I, false, false, false, false },
                   shortcutInsertOnLinkRequested);

    registerAction(ShortcutActionIds::graphChainSequential,
                   "Chain Selection (Stereo)",
                   "Connect selected nodes sequentially using stereo outputs.",
                   "Graph",
                   { ImGuiKey_C, false, false, false, false },
                   shortcutChainSequentialRequested);

    registerAction(ShortcutActionIds::graphChainAudio,
                   "Chain Audio Pins",
                   "Connect matching audio pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_G, false, false, false, false },
                   shortcutChainAudioRequested);

    registerAction(ShortcutActionIds::graphChainCv,
                   "Chain CV Pins",
                   "Connect matching CV pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_B, false, false, false, false },
                   shortcutChainCvRequested);

    registerAction(ShortcutActionIds::graphChainGate,
                   "Chain Gate Pins",
                   "Connect matching gate pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_Y, false, false, false, false },
                   shortcutChainGateRequested);

    registerAction(ShortcutActionIds::graphChainRaw,
                   "Chain Raw Pins",
                   "Connect matching raw pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_R, false, false, false, false },
                   shortcutChainRawRequested);

    registerAction(ShortcutActionIds::graphChainVideo,
                   "Chain Video Pins",
                   "Connect matching video pins between selected nodes.",
                   "Graph",
                   { ImGuiKey_V, false, false, false, false },
                   shortcutChainVideoRequested);
}

void ImGuiNodeEditorComponent::unregisterShortcuts()
{
    shortcutManager.unregisterAction(ShortcutActionIds::graphInsertOnLink);
    shortcutManager.unregisterAction(ShortcutActionIds::graphShowInsertPopup);
    shortcutManager.unregisterAction(ShortcutActionIds::graphConnectSelectedToTrackMixer);
    shortcutManager.unregisterAction(ShortcutActionIds::graphInsertMixer);
    shortcutManager.unregisterAction(ShortcutActionIds::debugToggleOverlay);
    shortcutManager.unregisterAction(ShortcutActionIds::historyRedo);
    shortcutManager.unregisterAction(ShortcutActionIds::historyUndo);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainVideo);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainRaw);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainGate);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainCv);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainAudio);
    shortcutManager.unregisterAction(ShortcutActionIds::graphChainSequential);
    shortcutManager.unregisterAction(ShortcutActionIds::viewToggleShortcutsWindow);
    shortcutManager.unregisterAction(ShortcutActionIds::viewToggleMinimap);
    shortcutManager.unregisterAction(ShortcutActionIds::viewResetOrigin);
    shortcutManager.unregisterAction(ShortcutActionIds::viewFrameAll);
    shortcutManager.unregisterAction(ShortcutActionIds::viewFrameSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editBypassDelete);
    shortcutManager.unregisterAction(ShortcutActionIds::editDelete);
    shortcutManager.unregisterAction(ShortcutActionIds::editDuplicateWithRouting);
    shortcutManager.unregisterAction(ShortcutActionIds::editDuplicate);
    shortcutManager.unregisterAction(ShortcutActionIds::editDisconnectSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editConnectOutput);
    shortcutManager.unregisterAction(ShortcutActionIds::editMuteSelection);
    shortcutManager.unregisterAction(ShortcutActionIds::editSelectAll);
    shortcutManager.unregisterAction(ShortcutActionIds::editCtrlR);
    shortcutManager.unregisterAction(ShortcutActionIds::fileBeautifyLayout);
    shortcutManager.unregisterAction(ShortcutActionIds::fileRandomizeConnections);
    shortcutManager.unregisterAction(ShortcutActionIds::fileRandomizePatch);
    shortcutManager.unregisterAction(ShortcutActionIds::fileOpen);
    shortcutManager.unregisterAction(ShortcutActionIds::fileSaveAs);
    shortcutManager.unregisterAction(ShortcutActionIds::fileSave);
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}
// Input handled by imgui_juce backend
void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    
    // Try to load user's saved theme preference, otherwise use default
    if (!ThemeManager::getInstance().loadUserThemePreference())
    {
        // No preference found or failed to load, apply default theme
        ThemeManager::getInstance().applyTheme();
    }
    // If preference was loaded successfully, loadUserThemePreference() already called applyTheme()

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    
    // Enable grid snapping
    ImNodes::GetStyle().GridSpacing = 64.0f;
    
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // ======================================================
    // === 💡 FONT REBUILD DEFERRED EXECUTION ===============
    // ======================================================
    if (fontAtlasNeedsRebuild.exchange(false, std::memory_order_acq_rel)
        || ThemeManager::getInstance().consumeFontReloadRequest())
    {
        rebuildFontAtlas();
    }

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    themeEditor.render();  // Render theme editor if open
    m_helpManager.render(); // Render help manager if open
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);

    // --- Eyedropper sampling after rendering (framebuffer has ImGui drawn) ---
    if (m_isPickingColor)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImVec2 mousePos = ImGui::GetMousePos();

        // Convert to framebuffer Y
        const int fbH = (int) io.DisplaySize.y;
        const int px = juce::jlimit(0, (int)io.DisplaySize.x - 1, (int)mousePos.x);
        const int py = juce::jlimit(0, fbH - 1, fbH - (int)mousePos.y - 1);

        unsigned char rgba[4] { 0, 0, 0, 255 };
        juce::gl::glReadPixels(px, py, 1, 1, juce::gl::GL_RGBA, juce::gl::GL_UNSIGNED_BYTE, rgba);
        ImU32 picked = IM_COL32(rgba[0], rgba[1], rgba[2], 255);

        // Draw cursor overlay
        ImDrawList* fg = ImGui::GetForegroundDrawList();
        const float s = 16.0f;
        ImVec2 tl(mousePos.x + 12, mousePos.y + 12);
        ImVec2 br(tl.x + s, tl.y + s);
        fg->AddRectFilled(tl, br, picked, 3.0f);
        fg->AddRect(tl, br, IM_COL32(0,0,0,255), 3.0f, 0, 1.0f);
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            if (m_onColorPicked) m_onColorPicked(picked);
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
        else if (ImGui::IsKeyPressed(ImGuiKey_Escape) || ImGui::IsMouseClicked(ImGuiMouseButton_Right))
        {
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
    }
}
void ImGuiNodeEditorComponent::renderImGui()
{
    // Ensure the synth always has the creation notification hook registered
    if (synth != nullptr)
    {
        synth->setOnModuleCreated([](const juce::String& pretty){
            NotificationManager::post(NotificationManager::Type::Info, "Created " + pretty + " node");
        });
    }
    static int frameCounter = 0;
    frameCounter++;

    // ========================= THE DEFINITIVE FIX =========================
    //
    // Rebuild the audio graph at the START of the frame if a change is pending.
    // This ensures that the synth model is in a consistent state BEFORE we try
    // to draw the UI, eliminating the "lost frame" that caused nodes to jump.
    //
    if (graphNeedsRebuild.load())
    {
        juce::Logger::writeToLog("[GraphSync] Rebuild flag is set. Committing changes now...");
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false; // Reset the flag immediately after committing.
        
        // CRITICAL: Invalidate hover state to prevent cable inspector from accessing
        // modules that were just deleted/recreated during commitChanges()
        lastHoveredLinkId = -1;
        lastHoveredNodeId = -1;
        hoveredLinkSrcId = 0;
        hoveredLinkDstId = 0;
        
        juce::Logger::writeToLog("[GraphSync] Graph rebuild complete.");
    }
    // ========================== END OF FIX ==========================

    // Frame start
    
    // --- Stateless Frame Rendering ---
    // Clear link registries at start of each frame for fully stateless rendering.
    // Pin IDs are now generated directly via bitmasking, no maps needed.
    linkIdToAttrs.clear();
    linkToId.clear();
    nextLinkId = 1000;

    collider::ScopedShortcutContext contextGuard(shortcutManager, nodeEditorContextId);

    if (imguiIO != nullptr)
        shortcutManager.processImGuiIO(*imguiIO);


    // --- ZOOM CONTROL HANDLER (requires imnodes zoom-enabled build) ---
#if defined(IMNODES_ZOOM_ENABLED)
    if (ImNodes::GetCurrentContext())
    {
        const ImGuiIO& io = ImGui::GetIO();
        const float currentZoom = ImNodes::EditorContextGetZoom();
        if (io.KeyCtrl && io.MouseWheel != 0.0f)
        {
            const float zoomFactor = 1.0f + (io.MouseWheel * 0.1f);
            const float newZoom = currentZoom * zoomFactor;
            ImNodes::EditorContextSetZoom(newZoom, ImGui::GetMousePos());
            juce::Logger::writeToLog("[Zoom] New Zoom: " + juce::String(newZoom, 2) + "x");
        }
    }
#endif
    // --- END ZOOM CONTROL HANDLER ---

    // === FIX DOUBLE CANVAS RENDERING ===
    // Make the parent window's background transparent.
    // This ensures that only the ImNodes canvas background (which
    // your theme controls) is the only one visible.
    ImGui::PushStyleColor(ImGuiCol_WindowBg, IM_COL32(0, 0, 0, 0));
    // === END OF FIX ===

    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_MenuBar);

    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    const float sidebarWidth = theme.layout.sidebar_width;
    const float menuBarHeight = ImGui::GetFrameHeight();
    const float padding = theme.layout.window_padding;

    // === PROBE SCOPE OVERLAY ===
    if (synth != nullptr && showProbeScope)
    {
        if (auto* scope = synth->getProbeScopeProcessor())
        {
            const float scopeWidth = theme.windows.probe_scope_width;
            const float scopeHeight = theme.windows.probe_scope_height;
            const float scopePosX = (float)getWidth() - (scopeWidth + padding);
            ImGui::SetNextWindowPos(ImVec2(scopePosX, menuBarHeight + padding), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowSize(ImVec2(scopeWidth, scopeHeight), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowBgAlpha(theme.windows.probe_scope_alpha);
            
            if (ImGui::Begin("🔬 Probe Scope", &showProbeScope, ImGuiWindowFlags_NoFocusOnAppearing))
            {
                ImGui::Text("Signal Probe");
                ImGui::Separator();
                
                // Get scope buffer
                const auto& buffer = scope->getScopeBuffer();
                
                // Get statistics
                float minVal = 0.0f, maxVal = 0.0f;
                scope->getStatistics(minVal, maxVal);
                
                if (buffer.getNumSamples() > 0 && maxVal - minVal > 0.0001f)
                {
                    // Display stats
                    ImGui::Text("Min: %.3f  Max: %.3f", minVal, maxVal);
                    ImGui::Text("Peak: %.3f", juce::jmax(std::abs(minVal), std::abs(maxVal)));
                    
                    // Draw waveform with explicit width to avoid node expansion feedback
                    ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
                    const int numSamples = buffer.getNumSamples();
                    if (buffer.getNumChannels() > 0)
                    {
                        const float* samples = buffer.getReadPointer(0);
                        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
                    }
                    
                    // Button to clear probe connection
                    if (ImGui::Button("Clear Probe"))
                    {
                        synth->clearProbeConnection();
                    }
                }
                else
                {
                    ThemeText("No signal probed", theme.text.disabled);
                    ImGui::Text("Right-click > Probe Signal");
                    ImGui::Text("Then click any output pin");
                }
            }
            ImGui::End();
        }
    }
    // === END OF PROBE SCOPE OVERLAY ===

    // Clean up textures for deleted sample loaders
    if (synth != nullptr)
    {
        auto infos = synth->getModulesInfo();
        std::unordered_set<int> activeSampleLoaderIds;
        for (const auto& info : infos)
        {
            if (info.second.equalsIgnoreCase("sample_loader"))
            {
                activeSampleLoaderIds.insert((int)info.first);
            }
        }

        for (auto it = sampleLoaderTextureIds.begin(); it != sampleLoaderTextureIds.end(); )
        {
            if (activeSampleLoaderIds.find(it->first) == activeSampleLoaderIds.end())
            {
                if (it->second)
                    it->second.reset();
                it = sampleLoaderTextureIds.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }
    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { 
                if (currentPresetFile.existsAsFile()) {
                    savePresetToFile(currentPresetFile);
                } else {
                    startSaveDialog();
                }
            }
            if (ImGui::MenuItem("Save Preset As...", "Ctrl+Alt+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            
            ImGui::Separator();
            
            // Plugin scanning menu item
            if (ImGui::MenuItem("Scan for Plugins..."))
            {
                // Get the application instance to access plugin management
                auto& app = PresetCreatorApplication::getApp();
                auto& formatManager = app.getPluginFormatManager();
                auto& knownPluginList = app.getKnownPluginList();

                // 1. Find the VST3 format
                juce::VST3PluginFormat* vst3Format = nullptr;
                for (int i = 0; i < formatManager.getNumFormats(); ++i)
                {
                    if (auto* format = formatManager.getFormat(i); format->getName() == "VST3")
                    {
                        vst3Format = dynamic_cast<juce::VST3PluginFormat*>(format);
                        break;
                    }
                }

                if (vst3Format != nullptr)
                {
                    // 2. Define the specific folder to scan
                    juce::File vstDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile)
                                            .getParentDirectory().getChildFile("VST");

                    juce::FileSearchPath searchPath;
                    if (vstDir.isDirectory())
                    {
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Starting scan in: " + vstDir.getFullPathName());
                    }
                    else
                    {
                        vstDir.createDirectory();
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Created VST directory at: " + vstDir.getFullPathName());
                    }

                    // 3. Scan for plugins
                    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                        .getChildFile(app.getApplicationName());
                    
                    juce::PluginDirectoryScanner scanner(knownPluginList, *vst3Format, searchPath, true,
                                                         appDataDir.getChildFile("dead_plugins.txt"), true);

                    // 4. Perform the scan
                    juce::String pluginBeingScanned;
                    int numFound = 0;
                    while (scanner.scanNextFile(true, pluginBeingScanned))
                    {
                        juce::Logger::writeToLog("[VST Scan] Scanning: " + pluginBeingScanned);
                        ++numFound;
                    }
                    
                    juce::Logger::writeToLog("[VST Scan] Scan complete. Found " + juce::String(numFound) + " plugin(s).");
                    juce::Logger::writeToLog("[VST Scan] Total plugins in list: " + juce::String(knownPluginList.getNumTypes()));
                    
                    // 5. Save the updated plugin list
                    auto pluginListFile = appDataDir.getChildFile("known_plugins.xml");
                    if (auto pluginListXml = knownPluginList.createXml())
                    {
                        if (pluginListXml->writeTo(pluginListFile))
                        {
                            juce::Logger::writeToLog("[VST Scan] Saved plugin list to: " + pluginListFile.getFullPathName());
                        }
                    }
                }
                else
                {
                    juce::Logger::writeToLog("[VST Scan] ERROR: VST3 format not found in format manager.");
                }
            }
            
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }
        
        // ========================================================================
        // SETTINGS MENU - Global GPU/CPU Configuration, Audio, and MIDI
        // ========================================================================
        if (ImGui::BeginMenu("Settings"))
        {
            // Audio Settings
            if (ImGui::MenuItem("Audio Settings..."))
            {
                if (onShowAudioSettings)
                    onShowAudioSettings();
            }
            
            // MIDI Device Manager
            if (ImGui::MenuItem("MIDI Device Manager..."))
            {
                showMidiDeviceManager = !showMidiDeviceManager;
            }

            if (ImGui::MenuItem("Help Manager...", "F1"))
            {
                m_helpManager.open();
                m_helpManager.setActiveTab(0); // Open to Shortcuts tab
            }
            
            ImGui::Separator();

                if (ImGui::BeginMenu("Theme"))
                {
                    if (ImGui::MenuItem("Edit Current Theme..."))
                    {
                        themeEditor.open();
                    }
                    ImGui::Separator();
                    
                    // Dynamic theme scanning - refreshes each time menu is opened
                    auto loadThemePreset = [&](const char* label, const juce::String& filename)
                    {
                        if (ImGui::MenuItem(label))
                        {
                            juce::File presetFile;
                            auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                            auto exeDir = exeFile.getParentDirectory();
                            auto themesDir = exeDir.getChildFile("themes");
                            auto candidate = themesDir.getChildFile(filename);
                            
                            if (candidate.existsAsFile())
                            {
                                if (ThemeManager::getInstance().loadTheme(candidate))
                                {
                                    // Save user preference
                                    ThemeManager::getInstance().saveUserThemePreference(filename);
                                    themeEditor.refreshThemeFromManager();
                                    juce::Logger::writeToLog("[Theme] Loaded: " + juce::String(label));
                                    s_themeToastText = "Theme Loaded: " + juce::String(label);
                                    s_themeToastEndTime = ImGui::GetTime() + 2.0;
                                }
                            }
                        }
                    };
                    
                    // Helper to convert filename to display name
                    auto filenameToDisplayName = [](const juce::String& filename) -> juce::String
                    {
                        juce::String name = filename;
                        // Remove .json extension
                        if (name.endsWithIgnoreCase(".json"))
                            name = name.substring(0, name.length() - 5);
                        
                        // Special case for MoofyDark
                        if (name.equalsIgnoreCase("MoofyDark"))
                            return "Moofy Dark (Default)";
                        
                        // Convert camelCase/PascalCase to Title Case with spaces
                        // e.g., "AtomOneLight" -> "Atom One Light", "ClassicTheme" -> "Classic Theme"
                        juce::String result;
                        for (int i = 0; i < name.length(); ++i)
                        {
                            juce::juce_wchar c = name[i];
                            // Insert space before uppercase letters (except first character)
                            if (i > 0 && juce::CharacterFunctions::isUpperCase(c))
                                result += " ";
                            result += c;
                        }
                        
                        // Handle special cases
                        result = result.replace("Synthwave 84", "Synthwave '84");
                        result = result.replace("Rosé Pine", "Rosé Pine Moon");
                        result = result.replace("Night Owl", "Night Owl Neo");
                        result = result.replace("Everforest", "Everforest Night");
                        result = result.replace("Dracula Midnight", "Dracula Midnight");
                        
                        return result;
                    };
                    
                    // Scan themes directory for all .json files
                    auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                    auto exeDir = exeFile.getParentDirectory();
                    auto themesDir = exeDir.getChildFile("themes");
                    
                    std::vector<std::pair<juce::String, juce::String>> foundThemes; // {displayName, filename}
                    
                    if (themesDir.exists() && themesDir.isDirectory())
                    {
                        juce::Array<juce::File> themeFiles;
                        themesDir.findChildFiles(themeFiles, juce::File::findFiles, false, "*.json");
                        
                        for (const auto& themeFile : themeFiles)
                        {
                            juce::String filename = themeFile.getFileName();
                            // Skip hidden/system files
                            if (filename.startsWithChar('.'))
                                continue;
                            
                            juce::String displayName = filenameToDisplayName(filename);
                            foundThemes.push_back({displayName, filename});
                        }
                    }
                    
                    // Also check source tree for development (fallback)
                    {
                        auto sourceThemesDir = exeDir.getParentDirectory().getParentDirectory()
                            .getChildFile("Source")
                            .getChildFile("preset_creator")
                            .getChildFile("theme")
                            .getChildFile("presets");
                        
                        if (sourceThemesDir.exists() && sourceThemesDir.isDirectory())
                        {
                            juce::Array<juce::File> sourceThemeFiles;
                            sourceThemesDir.findChildFiles(sourceThemeFiles, juce::File::findFiles, false, "*.json");
                            
                            for (const auto& themeFile : sourceThemeFiles)
                            {
                                juce::String filename = themeFile.getFileName();
                                if (filename.startsWithChar('.'))
                                    continue;
                                
                                // Check if we already have this theme from exe/themes
                                bool alreadyFound = false;
                                for (const auto& existing : foundThemes)
                                {
                                    if (existing.second.equalsIgnoreCase(filename))
                                    {
                                        alreadyFound = true;
                                        break;
                                    }
                                }
                                
                                if (!alreadyFound)
                                {
                                    juce::String displayName = filenameToDisplayName(filename);
                                    foundThemes.push_back({displayName, filename});
                                }
                            }
                        }
                    }
                    
                    // Sort themes alphabetically by display name
                    std::sort(foundThemes.begin(), foundThemes.end(), [](const auto& a, const auto& b)
                    {
                        return a.first.compareIgnoreCase(b.first) < 0;
                    });
                    
                    // Render menu items from dynamically found themes
                    for (const auto& theme : foundThemes)
                    {
                        loadThemePreset(theme.first.toRawUTF8(), theme.second);
                    }
                    
                    // If no themes found, show a message
                    if (foundThemes.empty())
                    {
                        ImGui::TextDisabled("No themes found in themes/ directory");
                    }

                    ImGui::EndMenu();
                }
            
            ImGui::Separator();
            
            #if WITH_CUDA_SUPPORT
                bool gpuEnabled = getGlobalGpuEnabled();
                if (ImGui::Checkbox("Enable GPU Acceleration (CUDA)", &gpuEnabled))
                {
                    setGlobalGpuEnabled(gpuEnabled);
                    juce::Logger::writeToLog("[Settings] Global GPU: " + juce::String(gpuEnabled ? "ENABLED" : "DISABLED"));
                }
                
                ImGui::TextDisabled("This setting controls all vision nodes:");
                ImGui::TextDisabled("  - Pose Estimator");
                ImGui::TextDisabled("  - Hand Tracker");
                ImGui::TextDisabled("  - Face Tracker");
                ImGui::TextDisabled("  - Object Detector");
                ImGui::TextDisabled("  - Human Detector");
                ImGui::TextDisabled("  - Color Tracker");
                ImGui::TextDisabled("  - Contour Detector");
                ImGui::TextDisabled("  - Movement Detector");
                ImGui::TextDisabled("  - Semantic Segmentation");
                
                ImGui::Separator();
                
                // Show CUDA device info
                #if WITH_CUDA_SUPPORT
                    int deviceCount = cv::cuda::getCudaEnabledDeviceCount();
                    if (deviceCount > 0)
                    {
                        ThemeText("CUDA Available", theme.text.success);
                        ImGui::Text("GPU Devices: %d", deviceCount);
                    }
                    else
                    {
                        ThemeText("CUDA compiled but no devices found", theme.text.warning);
                    }
                #endif
            #else
                ImGui::TextDisabled("GPU Acceleration: Not Compiled");
                ImGui::TextDisabled("Rebuild with CUDA support to enable");
            #endif
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Actions"))
        {
            // This item should only be enabled if at least one node is selected
            bool anyNodesSelected = ImNodes::NumSelectedNodes() > 0;
            bool multipleNodesSelected = ImNodes::NumSelectedNodes() > 1;
            
            // Get the shortcut string for "Connect Selected to Track Mixer"
            juce::String shortcutLabel;
            {
                const auto& context = nodeEditorContextId;
                auto userBinding = shortcutManager.getUserBinding(ShortcutActionIds::graphConnectSelectedToTrackMixer, context);
                if (userBinding.hasValue() && userBinding->isValid())
                {
                    shortcutLabel = userBinding->toString();
                }
                else
                {
                    auto defaultBinding = shortcutManager.getDefaultBinding(ShortcutActionIds::graphConnectSelectedToTrackMixer, context);
                    if (defaultBinding.hasValue() && defaultBinding->isValid())
                    {
                        shortcutLabel = defaultBinding->toString();
                    }
                }
            }
            
            if (ImGui::MenuItem("Connect Selected to Track Mixer", shortcutLabel.isEmpty() ? nullptr : shortcutLabel.toRawUTF8(), false, anyNodesSelected))
            {
                handleConnectSelectedToTrackMixer();
            }
            
            // Meta Module: Collapse selected nodes into a reusable sub-patch
            // if (ImGui::MenuItem("Collapse to Meta Module", "Ctrl+Shift+M", false, multipleNodesSelected))
            // {
            //     handleCollapseToMetaModule();
            // }
            
            if (ImGui::MenuItem("Record Output", "Ctrl+R"))
            {
                handleRecordOutput();
            }
            
            if (ImGui::MenuItem("Beautify Layout", "Ctrl+B"))
            {
                handleBeautifyLayout();
            }
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Recording"))
        {
            if (synth != nullptr)
            {
                bool isAnyRecording = synth->isAnyModuleRecording();
                const char* label = isAnyRecording ? "Stop All Recordings" : "Start All Recordings";
                if (ImGui::MenuItem(label))
                {
                    if (isAnyRecording)
                    {
                        synth->stopAllRecorders();
                    }
                    else
                    {
                        synth->startAllRecorders();
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Insert Node"))
        {
            bool isNodeSelected = (selectedLogicalId != 0);
            
            if (ImGui::BeginMenu("Effects", isNodeSelected))
            {
                if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); }
                if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); }
                if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); }
                if (ImGui::MenuItem("Chorus")) { insertNodeBetween("chorus"); }
                if (ImGui::MenuItem("Phaser")) { insertNodeBetween("phaser"); }
                if (ImGui::MenuItem("Compressor")) { insertNodeBetween("compressor"); }
                if (ImGui::MenuItem("Limiter")) { insertNodeBetween("limiter"); }
                if (ImGui::MenuItem("Noise Gate")) { insertNodeBetween("gate"); }
                if (ImGui::MenuItem("Reroute")) { insertNodeBetween("reroute"); }
                if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
                if (ImGui::MenuItem("Bit Crusher")) { insertNodeBetween("bit_crusher"); }
                if (ImGui::MenuItem("Graphic EQ")) { insertNodeBetween("graphic_eq"); }
                if (ImGui::MenuItem("Waveshaper")) { insertNodeBetween("waveshaper"); }
                if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); }
                if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); }
                if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); }
                if (ImGui::MenuItem("Time/Pitch Shifter")) { insertNodeBetween("timepitch"); }
                if (ImGui::MenuItem("De-Crackle")) { insertNodeBetween("de_crackle"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Modulators", isNodeSelected))
            {
                if (ImGui::MenuItem("LFO")) { insertNodeBetween("lfo"); }
                if (ImGui::MenuItem("ADSR")) { insertNodeBetween("adsr"); }
                if (ImGui::MenuItem("Random")) { insertNodeBetween("random"); }
                if (ImGui::MenuItem("S&H")) { insertNodeBetween("s_and_h"); }
                if (ImGui::MenuItem("Function Generator")) { insertNodeBetween("function_generator"); }
                if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Utilities & Logic", isNodeSelected))
            {
                if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); }
                if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); }
                if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); }
                if (ImGui::MenuItem("Track Mixer")) { insertNodeBetween("track_mixer"); }
                if (ImGui::MenuItem("PanVol")) { insertNodeBetween("panvol"); }
                if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); }
                if (ImGui::MenuItem("Lag Processor")) { insertNodeBetween("lag_processor"); }
                if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); }
                if (ImGui::MenuItem("Map Range")) { insertNodeBetween("map_range"); }
                if (ImGui::MenuItem("Quantizer")) { insertNodeBetween("quantizer"); }
                if (ImGui::MenuItem("Rate")) { insertNodeBetween("rate"); }
                if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); }
                if (ImGui::MenuItem("Logic")) { insertNodeBetween("logic"); }
                if (ImGui::MenuItem("Reroute")) { insertNodeBetween("reroute"); }
                if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Computer Vision", isNodeSelected))
            {
                if (ImGui::MenuItem("Video FX")) { insertNodeBetween("video_fx"); }
                if (ImGui::MenuItem("Crop Video")) { insertNodeBetween("crop_video"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("TTS", isNodeSelected))
            {
                if (ImGui::MenuItem("TTS Performer")) { insertNodeBetween("tts_performer"); }
                if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Analysis", isNodeSelected))
            {
                if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); }
                if (ImGui::MenuItem("Frequency Graph")) { insertNodeBetween("frequency_graph"); }
                ImGui::EndMenu();
            }
            
            ImGui::EndMenu();
        }
        // === DEBUG MENU ===
        if (ImGui::BeginMenu("Debug"))
        {
            if (ImGui::MenuItem("Show System Diagnostics", "Ctrl+Shift+D")) 
            {
                showDebugMenu = !showDebugMenu;
            }
            
            
            if (ImGui::MenuItem("Log System State"))
            {
                if (synth != nullptr)
                {
                    juce::Logger::writeToLog("=== SYSTEM DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getSystemDiagnostics());
                }
            }
            
            if (ImGui::MenuItem("Log Selected Module Diagnostics"))
            {
                if (synth != nullptr && selectedLogicalId != 0)
                {
                    juce::Logger::writeToLog("=== MODULE DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getModuleDiagnostics(selectedLogicalId));
                }
            }
            
            ImGui::EndMenu();
        }
        
        // === TRANSPORT CONTROLS ===
        if (synth != nullptr)
        {
            // Get current transport state
            auto transportState = synth->getTransportState();
            
            // Add some spacing before transport controls
            ImGui::Separator();
            ImGui::Spacing();
            
            // Play/Pause button
            if (transportState.isPlaying)
            {
                if (ImGui::Button("Pause"))
                    synth->setPlaying(false);
            }
            else
            {
                if (ImGui::Button("Play"))
                    synth->setPlaying(true);
            }
            
            ImGui::SameLine();
            
            // Stop button (resets position)
            if (ImGui::Button("Stop"))
            {
                synth->setPlaying(false);
                synth->resetTransportPosition();
            }
            
            ImGui::SameLine();
            
            // BPM control (greyed out if controlled by Tempo Clock module)
            float bpm = static_cast<float>(transportState.bpm);
            ImGui::SetNextItemWidth(80.0f);
            
            bool isControlled = transportState.isTempoControlledByModule.load();
            if (isControlled)
                ImGui::BeginDisabled();
                
            if (ImGui::DragFloat("BPM", &bpm, 0.1f, 20.0f, 999.0f, "%.1f"))
                synth->setBPM(static_cast<double>(bpm));
                
            if (isControlled)
            {
                ImGui::EndDisabled();
                if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
                {
                    ImGui::BeginTooltip();
                    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                    ThemeText("Tempo Clock Module Active", theme.text.warning);
                    ImGui::TextUnformatted("A Tempo Clock node with 'Sync to Host' disabled is controlling the global BPM.");
                    ImGui::PopTextWrapPos();
                    ImGui::EndTooltip();
                }
            }
            
            ImGui::SameLine();
            
            // Position display
            ImGui::Text("%.2f beats", transportState.songPositionBeats);
        }
        // === MULTI-MIDI DEVICE ACTIVITY INDICATOR ===
        ImGui::SameLine();
        ImGui::Separator();
        ImGui::SameLine();
        if (synth != nullptr)
        {
            auto activityState = synth->getMidiActivityState();
            
            if (activityState.deviceNames.empty())
            {
                // No MIDI devices connected
                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                ImGui::Text("MIDI: No Devices");
                ImGui::PopStyleColor();
            }
            else
            {
                ImGui::Text("MIDI:");
                ImGui::SameLine();
                
                // Display each device with active channels
                for (const auto& [deviceIndex, deviceName] : activityState.deviceNames)
                {
                    ImGui::SameLine();
                    
                    bool hasActivity = false;
                    if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                    {
                        const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                        for (bool active : channels)
                        {
                            if (active)
                            {
                                hasActivity = true;
                                break;
                            }
                        }
                    }
                    
                    // Abbreviated device name (max 12 chars)
                    juce::String abbrevName = deviceName;
                    if (abbrevName.length() > 12)
                        abbrevName = abbrevName.substring(0, 12) + "...";
                    
                    // Color: bright green if active, dim gray if inactive
                    if (hasActivity)
                        ImGui::PushStyleColor(ImGuiCol_Text, theme.text.active);
                    else
                        ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                    
                    ImGui::Text("[%s]", abbrevName.toRawUTF8());
                    ImGui::PopStyleColor();
                    
                    // Tooltip with full name and active channels
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("%s", deviceName.toRawUTF8());
                        ImGui::Separator();
                        
                        if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                        {
                            const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                            ImGui::Text("Active Channels:");
                            juce::String activeChannels;
                            for (int ch = 0; ch < 16; ++ch)
                            {
                                if (channels[ch])
                                {
                                    if (activeChannels.isNotEmpty())
                                        activeChannels += ", ";
                                    activeChannels += juce::String(ch + 1);
                                }
                            }
                            if (activeChannels.isEmpty())
                                activeChannels = "None";
                            ImGui::Text("%s", activeChannels.toRawUTF8());
                        }
                        
                        ImGui::EndTooltip();
                    }
                }
            }
        }
        else
        {
            ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
            ImGui::Text("MIDI: ---");
            ImGui::PopStyleColor();
        }
        // === END OF MULTI-MIDI INDICATOR ===

        // --- ZOOM DISPLAY (menu bar, right side) ---
#if defined(IMNODES_ZOOM_ENABLED)
        if (ImNodes::GetCurrentContext())
        {
            ImGui::SameLine();
            ImGui::Separator();
            ImGui::SameLine();
            ImGui::Text("Zoom: %.2fx", ImNodes::EditorContextGetZoom());
        }
#endif
        // --- END ZOOM DISPLAY ---

        ImGui::EndMainMenuBar();
    }

    // --- PRESET STATUS OVERLAY ---
    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(ThemeManager::getInstance().getCurrentTheme().windows.preset_status_alpha);
    ImGui::Begin("Preset Status", nullptr, 
                 ImGuiWindowFlags_NoDecoration | 
                 ImGuiWindowFlags_NoMove | 
                 ImGuiWindowFlags_NoFocusOnAppearing | 
                 ImGuiWindowFlags_NoNav | 
                 ImGuiWindowFlags_AlwaysAutoResize);

    if (currentPresetFile.existsAsFile()) {
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    // Get the theme colors
    if (isPatchDirty) {
        ThemeText("Status: EDITED", theme.status.edited);
    } else {
        ThemeText("Status: SAVED", theme.status.saved);
    }
    ImGui::End();
    // --- END OF PRESET STATUS OVERLAY ---
    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, sidebarWidth);
    // Zoom removed
    // ADD THIS BLOCK:
    ImGui::Text("Browser");
    // Create a scrolling child window to contain the entire browser
    ImGui::BeginChild("BrowserScrollRegion", ImVec2(0, 0), true);
    // Helper lambda to recursively draw the directory tree for presets
    std::function<void(const PresetManager::DirectoryNode*)> drawPresetTree = 
        [&](const PresetManager::DirectoryNode* node)
    {
        if (!node || (node->presets.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawPresetTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw presets in this directory with drag-and-drop support
        for (const auto& preset : node->presets)
        {
            if (m_presetSearchTerm.isEmpty() || preset.name.containsIgnoreCase(m_presetSearchTerm))
            {
                // Draw the selectable item and capture its return value
                bool clicked = ImGui::Selectable(preset.name.toRawUTF8());

                // --- THIS IS THE FIX ---
                // Check if this item is the source of a drag operation
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload type and data (the preset's file path)
                    const juce::String path = preset.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_PRESET_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback while dragging
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Merge Preset: %s", preset.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // If a drag did NOT occur, and the item was clicked, load the preset
                else if (clicked)
                {
                    loadPresetFromFile(preset.file);
                }
                // --- END OF FIX ---
                
                // Tooltip (only shown when hovering, not dragging)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0) && preset.description.isNotEmpty())
                {
                    ImGui::BeginTooltip();
                    ImGui::TextUnformatted(preset.description.toRawUTF8());
                    if (!preset.tags.isEmpty())
                        ImGui::Text("Tags: %s", preset.tags.joinIntoString(", ").toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // Helper to push category colors (used for all module category headers)
    auto pushCategoryColor = [&](ModuleCategory cat) {
        ImU32 color = getImU32ForCategory(cat);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        ImGui::PushStyleColor(ImGuiCol_Header, color);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
        
        // Automatically adjust text color based on background contrast for optimal legibility
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(color);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
    };
    auto pushHeaderColors = [&](const TriStateColor& tri)
    {
        const ImGuiStyle& styleRef = ImGui::GetStyle();
        auto toVec4 = [&](ImU32 value, ImGuiCol fallback) -> ImVec4
        {
            if (value != 0)
                return ImGui::ColorConvertU32ToFloat4(value);
            return styleRef.Colors[fallback];
        };
        ImGui::PushStyleColor(ImGuiCol_Header, toVec4(tri.base, ImGuiCol_Header));
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, toVec4(tri.hovered, ImGuiCol_HeaderHovered));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, toVec4(tri.active, ImGuiCol_HeaderActive));
        
        // Automatically adjust text color based on background luminance for optimal legibility
        // Use the base background color to determine text color (Option B: single text color)
        ImU32 baseBgColor = tri.base != 0 ? tri.base : ImGui::ColorConvertFloat4ToU32(styleRef.Colors[ImGuiCol_Header]);
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(baseBgColor);
        ImGui::PushStyleColor(ImGuiCol_Text, optimalTextColor);
    };
    // === PRESET BROWSER ===
    pushHeaderColors(theme.headers.presets);
    bool presetsExpanded = ImGui::CollapsingHeader("Presets");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (presetsExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_presetScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##presetpath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##preset"))
        {
            presetPathChooser = std::make_unique<juce::FileChooser>("Select Preset Directory", m_presetScanPath);
            presetPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_presetScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("presetScanPath", m_presetScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##preset"))
        {
            m_presetManager.clearCache();
            m_presetManager.scanDirectory(m_presetScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_presetSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##preset", searchBuf, sizeof(searchBuf)))
            m_presetSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical preset tree
        drawPresetTree(m_presetManager.getRootNode());
    }
    
    // Helper lambda to recursively draw the directory tree for samples
    std::function<void(const SampleManager::DirectoryNode*)> drawSampleTree = 
        [&](const SampleManager::DirectoryNode* node)
    {
        if (!node || (node->samples.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawSampleTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw samples in this directory with drag-and-drop support
        for (const auto& sample : node->samples)
        {
            if (m_sampleSearchTerm.isEmpty() || sample.name.containsIgnoreCase(m_sampleSearchTerm))
            {
                // --- THIS IS THE HEROIC FIX ---

                // A. Draw the selectable item and capture its return value (which is true on mouse release).
                bool clicked = ImGui::Selectable(sample.name.toRawUTF8());

                // B. Check if this item is the source of a drag operation. This takes priority.
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload (the data we are transferring is the sample's file path).
                    const juce::String path = sample.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_SAMPLE_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback during the drag.
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Dragging: %s", sample.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // C. If a drag did NOT occur, and the item was clicked (mouse released on it), then create the node.
                else if (clicked)
                {
                    if (synth != nullptr)
                    {
                        auto newNodeId = synth->addModule("sample_loader");
                        auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                        pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                        if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                        {
                            sampleLoader->loadSample(sample.file);
                        }
                        snapshotAfterEditor = true;
                    }
                }
                
                // --- END OF FIX ---

                // (Existing tooltip for sample info remains the same)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Duration: %.2f s", sample.durationSeconds);
                    ImGui::Text("Rate: %d Hz", sample.sampleRate);
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // === SAMPLE BROWSER ===
    pushHeaderColors(theme.headers.samples);
    bool samplesExpanded = ImGui::CollapsingHeader("Samples");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (samplesExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_sampleScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##samplepath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##sample"))
        {
            samplePathChooser = std::make_unique<juce::FileChooser>("Select Sample Directory", m_sampleScanPath);
            samplePathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_sampleScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("sampleScanPath", m_sampleScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##sample"))
        {
            m_sampleManager.clearCache();
            m_sampleManager.scanDirectory(m_sampleScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_sampleSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##sample", searchBuf, sizeof(searchBuf)))
            m_sampleSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical sample tree
        drawSampleTree(m_sampleManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MIDI BROWSER ===
    pushHeaderColors(theme.headers.recent);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI Files");
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (midiExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_midiScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##midipath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##midi"))
        {
            midiPathChooser = std::make_unique<juce::FileChooser>("Select MIDI Directory", m_midiScanPath);
            midiPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_midiScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("midiScanPath", m_midiScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##midi"))
        {
            m_midiManager.clearCache();
            m_midiManager.scanDirectory(m_midiScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_midiSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##midi", searchBuf, sizeof(searchBuf)))
            m_midiSearchTerm = juce::String(searchBuf);
        ImGui::Separator();
        // 5. Display hierarchical MIDI tree
        std::function<void(const MidiManager::DirectoryNode*)> drawMidiTree = 
            [&](const MidiManager::DirectoryNode* node)
        {
            if (!node || (node->midiFiles.empty() && node->subdirectories.empty())) return;

            // Draw subdirectories first
            for (const auto& subdir : node->subdirectories)
            {
                if (ImGui::TreeNode(subdir->name.toRawUTF8()))
                {
                    drawMidiTree(subdir.get());
                    ImGui::TreePop();
                }
            }
            
            // Then draw MIDI files in this directory with drag-and-drop support
            for (const auto& midi : node->midiFiles)
            {
                if (m_midiSearchTerm.isEmpty() || midi.name.containsIgnoreCase(m_midiSearchTerm))
                {
                    // Draw the selectable item and capture its return value
                    bool clicked = ImGui::Selectable(midi.name.toRawUTF8());

                    // Check if this item is the source of a drag operation
                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                    {
                        // Set the payload (the MIDI file path)
                        const juce::String path = midi.file.getFullPathName();
                        const std::string pathStr = path.toStdString();
                        ImGui::SetDragDropPayload("DND_MIDI_PATH", pathStr.c_str(), pathStr.length() + 1);
                        
                        // Provide visual feedback during the drag
                        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                        ImGui::Text("Dragging: %s", midi.name.toRawUTF8());
                        
                        ImGui::EndDragDropSource();
                    }
                    // If a drag did NOT occur, and the item was clicked, create a new MIDI Player node
                    else if (clicked)
                    {
                        if (synth != nullptr)
                        {
                            auto newNodeId = synth->addModule("midi_player");
                            auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                            pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                            
                            // Load the MIDI file into the new player
                            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                            {
                                midiPlayer->loadMIDIFile(midi.file);
                            }
                            
                            snapshotAfterEditor = true;
                        }
                    }
                    
                    // Tooltip for MIDI info (only shown when hovering, not dragging)
                    if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("MIDI File: %s", midi.file.getFileName().toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
            }
        };
        
        drawMidiTree(m_midiManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MODULE BROWSER ===
    pushHeaderColors(theme.headers.system);
    bool modulesExpanded = ImGui::CollapsingHeader("Modules", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    
    if (modulesExpanded)
    {
    
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
        
        // --- FIX: Show tooltip with module description on hover ---
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            
            // Find the description in our list using the module's internal 'type'
            bool found = false;
            for (const auto& pair : getModuleDescriptions())
            {
                if (pair.first.equalsIgnoreCase(type))
                {
                    // If found, display it
                    ImGui::TextUnformatted(pair.second);
                    found = true;
                    break;
                }
            }
            if (!found)
            {
                // Fallback text if a description is missing
                ImGui::TextUnformatted("No description available.");
            }
            
            ImGui::EndTooltip();
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // MODULE NAMING CONVENTION:
    // ─────────────────────────────────────────────────────────────────────────────── 
    // ALL module type names MUST follow this strict naming convention:
    //   • Use ONLY lowercase letters (a-z)
    //   • Use ONLY numbers (0-9) where appropriate
    //   • Replace ALL spaces with underscores (_)
    //   • NO capital letters allowed
    //   • NO hyphens or other special characters
    //
    // Examples:
    //   ✓ CORRECT:   "midi_player", "sample_loader", "graphic_eq", "vco"
    //   ✗ INCORRECT: "MIDI Player", "Sample Loader", "Graphic EQ", "VCO"
    //
    // This ensures consistent module identification across the system.
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 1. SOURCES - Signal generators and inputs
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Source);
    bool sourcesExpanded = ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (sourcesExpanded) {
        addModuleButton("VCO", "vco");
        addModuleButton("Polyphonic VCO", "polyvco");
        addModuleButton("Noise", "noise");
        addModuleButton("Audio Input", "audio_input");
        addModuleButton("Sample Loader", "sample_loader");
        addModuleButton("Value", "value");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 2. EFFECTS - Audio processing and tone shaping
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Effect);
    bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (effectsExpanded) {
        addModuleButton("VCF", "vcf");
        addModuleButton("Delay", "delay");
        addModuleButton("Reverb", "reverb");
        addModuleButton("Chorus", "chorus");
        addModuleButton("Phaser", "phaser");
        addModuleButton("Compressor", "compressor");
        addModuleButton("Limiter", "limiter");
        addModuleButton("Noise Gate", "gate");
        addModuleButton("Drive", "drive");
        addModuleButton("Bit Crusher", "bit_crusher");
        addModuleButton("Graphic EQ", "graphic_eq");
        addModuleButton("Waveshaper", "waveshaper");
        addModuleButton("8-Band Shaper", "8bandshaper");
        addModuleButton("Granulator", "granulator");
        addModuleButton("Harmonic Shaper", "harmonic_shaper");
        addModuleButton("Time/Pitch Shifter", "timepitch");
        addModuleButton("De-Crackle", "de_crackle");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 3. MODULATORS - CV generation and modulation sources
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Modulator);
    bool modulatorsExpanded = ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (modulatorsExpanded) {
        addModuleButton("LFO", "lfo");
        addModuleButton("ADSR", "adsr");
        addModuleButton("Random", "random");
        addModuleButton("S&H", "s_and_h");
        addModuleButton("Function Generator", "function_generator");
        addModuleButton("Shaping Oscillator", "shaping_oscillator");
    }
    // ═══════════════════════════════════════════════════════════════════════════════
    // 4. UTILITIES & LOGIC - Signal processing and routing
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Utility);
    bool utilitiesExpanded = ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (utilitiesExpanded) {
        addModuleButton("VCA", "vca");
        addModuleButton("Mixer", "mixer");
        addModuleButton("CV Mixer", "cv_mixer");
        addModuleButton("Track Mixer", "track_mixer");
        addModuleButton("Attenuverter", "attenuverter");
        addModuleButton("Reroute", "reroute");
        addModuleButton("Lag Processor", "lag_processor");
        addModuleButton("Math", "math");
        addModuleButton("Map Range", "map_range");
        addModuleButton("Quantizer", "quantizer");
        addModuleButton("Rate", "rate");
        addModuleButton("Comparator", "comparator");
        addModuleButton("Logic", "logic");
        addModuleButton("Clock Divider", "clock_divider");
        addModuleButton("Sequential Switch", "sequential_switch");
        addModuleButton("PanVol", "panvol");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 5. SEQUENCERS - Pattern and rhythm generation
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Seq);
    bool sequencersExpanded = ImGui::CollapsingHeader("Sequencers", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (sequencersExpanded) {
        addModuleButton("Sequencer", "sequencer");
        addModuleButton("Multi Sequencer", "multi_sequencer");
        addModuleButton("Tempo Clock", "tempo_clock");
        addModuleButton("Snapshot Sequencer", "snapshot_sequencer");
        addModuleButton("Stroke Sequencer", "stroke_sequencer");
        addModuleButton("Timeline", "timeline");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 6. MIDI - MIDI input/output and controllers
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::MIDI);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (midiExpanded) {
        addModuleButton("MIDI CV", "midi_cv");
        addModuleButton("MIDI Player", "midi_player");
        ImGui::Separator();
        addModuleButton("MIDI Faders", "midi_faders");
        addModuleButton("MIDI Knobs", "midi_knobs");
        addModuleButton("MIDI Buttons", "midi_buttons");
        addModuleButton("MIDI Jog Wheel", "midi_jog_wheel");
        addModuleButton("MIDI Pads", "midi_pads");
        ImGui::Separator();
        addModuleButton("MIDI Logger", "midi_logger");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 7. ANALYSIS - Signal visualization and debugging
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Analysis);
    bool analysisExpanded = ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (analysisExpanded) {
        addModuleButton("Scope", "scope");
        addModuleButton("Debug", "debug");
        addModuleButton("Input Debug", "input_debug");
        addModuleButton("Frequency Graph", "frequency_graph");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 8. TTS - Text-to-Speech and vocal synthesis
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::TTS_Voice);
    bool ttsExpanded = ImGui::CollapsingHeader("TTS", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (ttsExpanded) {
        addModuleButton("TTS Performer", "tts_performer");
        addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 9. SPECIAL - Physics, animation, and experimental
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Special_Exp);
    bool specialExpanded = ImGui::CollapsingHeader("Special", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (specialExpanded) {
        addModuleButton("Physics", "physics");
        addModuleButton("Animation", "animation");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 10. COMPUTER VISION - Video processing and analysis
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::OpenCV);
    bool openCVExpanded = ImGui::CollapsingHeader("Computer Vision", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (openCVExpanded) {
        ThemeText("Sources:", theme.text.section_header);
        addModuleButton("Webcam Loader", "webcam_loader");
        addModuleButton("Video File Loader", "video_file_loader");
        ImGui::Spacing();
        ThemeText("Processors:", theme.text.section_header);
        addModuleButton("Video FX", "video_fx");
        addModuleButton("Movement Detector", "movement_detector");
        addModuleButton("Object Detector", "object_detector");
        addModuleButton("Pose Estimator", "pose_estimator");
        addModuleButton("Hand Tracker", "hand_tracker");
        addModuleButton("Face Tracker", "face_tracker");
        addModuleButton("Color Tracker", "color_tracker");
        addModuleButton("Contour Detector", "contour_detector");
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 11. PLUGINS / VST - Third-party audio plugins
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Plugin);
    bool pluginsExpanded = ImGui::CollapsingHeader("Plugins / VST", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (pluginsExpanded) {
        addPluginModules();
    }
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 12. SYSTEM - Patch organization and system utilities
    // ═══════════════════════════════════════════════════════════════════════════════
    pushCategoryColor(ModuleCategory::Sys);
    bool systemExpanded = ImGui::CollapsingHeader("System", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(4); // 3 background colors + 1 text color
    if (systemExpanded) {
        // addModuleButton("Meta", "meta");
        // addModuleButton("Inlet", "inlet");
        // addModuleButton("Outlet", "outlet");
        addModuleButton("Comment", "comment");
        addModuleButton("Recorder", "recorder");
    }
    
    } // End of Modules collapsing header

    // End the scrolling region
    ImGui::EndChild();
    ImGui::NextColumn();
    // --- DEFINITIVE FIX FOR PRESET DRAG-AND-DROP WITH VISUAL FEEDBACK ---
    // Step 1: Define canvas dimensions first (needed for the drop target)
    // Get grid/canvas colors from theme
    auto& themeMgr = ThemeManager::getInstance();
    const ImU32 GRID_COLOR = themeMgr.getGridColor();
    const ImU32 GRID_ORIGIN_COLOR = themeMgr.getGridOriginColor();
    const float GRID_SIZE = themeMgr.getGridSize();
    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Cache canvas dimensions for modal pan logic later
    lastCanvasP0 = canvas_p0;
    lastCanvasSize = canvas_sz;

    // Step 2: Create a full-canvas invisible button to act as our drop area
    ImGui::SetCursorScreenPos(canvas_p0);
    ImGui::InvisibleButton("##canvas_drop_target", canvas_sz);

    const ImGuiStyle& style = ImGui::GetStyle();
    const ImU32 nodeBackground      = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_ChildBg]);
    const ImU32 nodeBackgroundHover = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_FrameBgHovered]);
    const ImU32 nodeBackgroundSel   = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_FrameBgActive]);
    const ImU32 nodeOutline         = ImGui::ColorConvertFloat4ToU32(style.Colors[ImGuiCol_Border]);

    auto& imnodesStyle = ImNodes::GetStyle();
    imnodesStyle.NodeCornerRounding = style.ChildRounding;
    imnodesStyle.NodeBorderThickness = style.FrameBorderSize;

    ImNodes::PushColorStyle(ImNodesCol_NodeBackground, nodeBackground);
    ImNodes::PushColorStyle(ImNodesCol_NodeBackgroundHovered, nodeBackgroundHover);
    ImNodes::PushColorStyle(ImNodesCol_NodeBackgroundSelected, nodeBackgroundSel);
    ImNodes::PushColorStyle(ImNodesCol_NodeOutline, nodeOutline);

    // Step 3: Make this area a drop target with visual feedback
    if (ImGui::BeginDragDropTarget())
    {
        // Check if a preset payload is being hovered over the canvas
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_PRESET_PATH", ImGuiDragDropFlags_AcceptBeforeDelivery))
        {
            // Draw a semi-transparent overlay to show the canvas is a valid drop zone
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            drawList->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getDropTargetOverlay());
            
            // Check if the mouse button was released to complete the drop
            if (payload->IsDelivery())
            {
                const char* path = (const char*)payload->Data;
                ImVec2 dropPos = ImGui::GetMousePos(); // Get the exact drop position
                mergePresetFromFile(juce::File(path), dropPos);
            }
        }
        ImGui::EndDragDropTarget();
    }
    // --- END OF DEFINITIVE FIX ---

    // Reset cursor position for subsequent drawing
    ImGui::SetCursorScreenPos(canvas_p0);

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinId({0, c.dstChan, true}) : 
                encodePinId({c.dstLogicalId, c.dstChan, true});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = themeMgr.getPinDisconnectedColor();
    const ImU32 colPinConnected = themeMgr.getPinConnectedColor();
    // <<< END OF BLOCK >>>

    // Pre-register is no longer needed - stateless encoding generates IDs on-the-fly
    // (Removed the old pre-registration loop)

    // --- BACKGROUND GRID AND COORDINATE DISPLAY ---
    // (Canvas dimensions already defined above in the drop target code)
    // Draw into the window draw list so colors aren't obscured by window bg
    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    // Note: EditorContextGetPanning() can only be called AFTER BeginNodeEditor()
    // Since we draw the grid before BeginNodeEditor, we use zero panning here
    // The grid will be drawn correctly after BeginNodeEditor is called
    ImVec2 panning = lastEditorPanning;

    // Node canvas bound to the underlying model if available
    // Hide ImNodes' own grid so we only render the custom one above.
    ImNodes::PushColorStyle(ImNodesCol_GridBackground, IM_COL32(0, 0, 0, 0));
    ImNodes::PushColorStyle(ImNodesCol_GridLine, IM_COL32(0, 0, 0, 0));
    ImNodes::PushColorStyle(ImNodesCol_GridLinePrimary, IM_COL32(0, 0, 0, 0));

    // Draw canvas background (behind everything)
    draw_list->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getCanvasBackground());

    // Draw grid lines
    for (float x = fmodf(panning.x, GRID_SIZE); x < canvas_sz.x; x += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p0.y + canvas_sz.y), GRID_COLOR);
    for (float y = fmodf(panning.y, GRID_SIZE); y < canvas_sz.y; y += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + y), GRID_SIZE);
    // Draw thicker lines for the origin (0,0)
    ImVec2 origin_on_screen = ImVec2(canvas_p0.x + panning.x, canvas_p0.y + panning.y);
    draw_list->AddLine(ImVec2(origin_on_screen.x, canvas_p0.y), ImVec2(origin_on_screen.x, canvas_p1.y), GRID_ORIGIN_COLOR, 2.0f);
    draw_list->AddLine(ImVec2(canvas_p0.x, origin_on_screen.y), ImVec2(canvas_p1.x, origin_on_screen.y), GRID_ORIGIN_COLOR, 2.0f);
    // Draw scale markers every SCALE_INTERVAL grid units as a grid (not a cross)
    const float SCALE_INTERVAL = themeMgr.getScaleInterval();
    const ImU32 SCALE_TEXT_COLOR = themeMgr.getScaleTextColor();
    ImDrawList* fg_draw_list = ImGui::GetForegroundDrawList();
    // X-axis scale markers - always at the bottom edge
    float gridLeft = -panning.x;
    float gridRight = canvas_sz.x - panning.x;
    int startX = (int)std::floor(gridLeft / SCALE_INTERVAL);
    int endX = (int)std::ceil(gridRight / SCALE_INTERVAL);
    for (int i = startX; i <= endX; ++i)
    {
        float gridX = i * SCALE_INTERVAL;
        float screenX = canvas_p0.x + panning.x + gridX;
        
        // Only draw if visible on screen
        if (screenX >= canvas_p0.x && screenX <= canvas_p1.x)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridX);
            // Always draw at bottom edge
            fg_draw_list->AddText(ImVec2(screenX + 2, canvas_p1.y - 45), SCALE_TEXT_COLOR, label);
        }
    }
    
    // Y-axis scale markers - always at the left edge
    float gridTop = -panning.y;
    float gridBottom = canvas_sz.y - panning.y;
    int startY = (int)std::floor(gridTop / SCALE_INTERVAL);
    int endY = (int)std::ceil(gridBottom / SCALE_INTERVAL);
    
    for (int i = startY; i <= endY; ++i)
    {
        float gridY = i * SCALE_INTERVAL;
        float screenY = canvas_p0.y + panning.y + gridY;
        
        // Only draw if visible on screen
        if (screenY >= canvas_p0.y && screenY <= canvas_p1.y)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridY);
            // Always draw at left edge
            fg_draw_list->AddText(ImVec2(canvas_p0.x + 5, screenY + 2), SCALE_TEXT_COLOR, label);
        }
    }
    // Mouse coordinate display overlay (bottom-left)
    ImVec2 mouseScreenPos = ImGui::GetMousePos();
    ImVec2 mouseGridPos = ImVec2(mouseScreenPos.x - canvas_p0.x - panning.x, mouseScreenPos.y - canvas_p0.y - panning.y);
    char posStr[32];
    snprintf(posStr, sizeof(posStr), "%.0f, %.0f", mouseGridPos.x, mouseGridPos.y);
    // Use the foreground draw list to ensure text is on top of everything
    // Position at bottom-left: canvas_p1.y is bottom edge, subtract text height plus padding
    ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), themeMgr.getMousePositionText(), posStr);

    // --- Cut-by-line gesture (preview) ---
    {
        const bool altDown = ImGui::GetIO().KeyAlt;
        const bool rmbPressed = ImGui::IsMouseClicked(ImGuiMouseButton_Right);
        const bool rmbDown = ImGui::IsMouseDown(ImGuiMouseButton_Right);

        // Contextual helper near cursor
        if (ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows))
        {
            ImGuiWindowFlags hintFlags = ImGuiWindowFlags_NoDecoration
                                       | ImGuiWindowFlags_AlwaysAutoResize
                                       | ImGuiWindowFlags_NoSavedSettings
                                       | ImGuiWindowFlags_NoFocusOnAppearing
                                       | ImGuiWindowFlags_NoNav
                                       | ImGuiWindowFlags_NoInputs;
            // If a link is hovered (probe tooltip likely shown), bias the hint to top-left
            const bool linkLikelyHovered = (lastHoveredLinkId != -1);
            const ImVec2 basePos = ImVec2(mouseScreenPos.x, mouseScreenPos.y);
            const ImVec2 hintOffset = linkLikelyHovered ? ImVec2(-180.0f, -16.0f) : ImVec2(14.0f, 16.0f);
            const ImVec2 hintPos = ImVec2(basePos.x + hintOffset.x, basePos.y + hintOffset.y);
            if (altDown && !rmbDown && !cutModeActive)
            {
                ImGui::SetNextWindowPos(hintPos);
                ImGui::Begin("##CutHintIdle", nullptr, hintFlags);
                ImGui::TextUnformatted("Alt + Right-drag: cut cables");
                ImGui::End();
            }
            else if (cutModeActive && rmbDown)
            {
                ImGui::SetNextWindowPos(hintPos);
                ImGui::Begin("##CutHintActive", nullptr, hintFlags);
                ImGui::TextUnformatted("Release to split with reroutes");
                ImGui::End();
            }
            else if (ImGui::GetIO().KeyCtrl)
            {
                ImGui::SetNextWindowPos(hintPos);
                ImGui::Begin("##CtrlHint", nullptr, hintFlags);
                ImGui::TextUnformatted("Ctrl + Click link: detach\nCtrl + Drag: move cable\nCtrl + Mid-click cable: duplicate");
                ImGui::End();
            }
        }

        if (!cutModeActive && altDown && rmbPressed)
        {
            cutModeActive = true;
            cutStartGrid = mouseGridPos;
            cutEndGrid = mouseGridPos;
        }
        if (cutModeActive && rmbDown)
        {
            cutEndGrid = mouseGridPos;
            // Draw preview in screen space (foreground to guarantee visibility)
            ImDrawList* dl = ImGui::GetForegroundDrawList();
            ImVec2 a = ImVec2(canvas_p0.x + panning.x + cutStartGrid.x,
                              canvas_p0.y + panning.y + cutStartGrid.y);
            ImVec2 b = ImVec2(canvas_p0.x + panning.x + cutEndGrid.x,
                              canvas_p0.y + panning.y + cutEndGrid.y);
            dl->AddLine(a, b, IM_COL32(255, 200, 0, 255), 2.0f);
        }
    }
    // --- END OF BACKGROUND GRID AND COORDINATE DISPLAY ---
    // Node canvas bound to the underlying model if available
    // Keep ImNodes' background/panning grid visible, but colour-match to theme overrides.
    ImNodes::PushColorStyle(ImNodesCol_GridBackground, themeMgr.getCanvasBackground());
    ImNodes::PushColorStyle(ImNodesCol_GridLine, GRID_COLOR);
    ImNodes::PushColorStyle(ImNodesCol_GridLinePrimary, GRID_ORIGIN_COLOR);
    ImNodes::PushColorStyle(ImNodesCol_BoxSelector, themeMgr.getSelectionRect());
    ImNodes::PushColorStyle(ImNodesCol_BoxSelectorOutline, themeMgr.getSelectionRectOutline());
    // === END OF FIX ===
    ImNodes::BeginNodeEditor();
    lastEditorPanning = ImNodes::EditorContextGetPanning();
    // Now we can safely get the actual panning for any future use
    // (Grid is already drawn with zero panning above, which is fine for background)
    // Begin the editor
    // +++ ADD THIS LINE AT THE START OF THE RENDER LOOP +++
    attrPositions.clear(); // Clear the cache at the beginning of each frame.
    auto cancelDragInsert = [this]()
    {
        dragInsertActive = false;
        dragInsertStartAttrId = -1;
        dragInsertStartPin = PinID{};
        shouldOpenDragInsertPopup = false;
    };
    // Rebuild mod attribute mapping from currently drawn nodes only
    // modAttrToParam.clear(); // TODO: Remove when fully migrated
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    // Track duplicates to diagnose disappearing pins
    std::unordered_set<int> seenAttrs;
    auto linkIdOf = [this] (int srcAttr, int dstAttr) -> int
    {
        return getLinkId(srcAttr, dstAttr);
    };
    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                if (!(x == 0.0f && y == 0.0f))
                    pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        // Graph is now always in consistent state since we rebuild at frame start
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;
            juce::String moduleLabel = type + " [lid=" + juce::String((int) lid) + "]";

            // Color-code modules by category (base colors)
            const auto moduleCategory = getModuleCategory(type);
            ImU32 baseTitleBarColor = getImU32ForCategory(moduleCategory);
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, baseTitleBarColor);
            ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));

            // Determine the actual title bar color that will be used (checking overrides in order)
            ImU32 actualTitleBarColor = baseTitleBarColor;
            
            // Highlight nodes participating in the hovered link (overrides category color)
            const bool isHoveredSource = (hoveredLinkSrcId != 0 && hoveredLinkSrcId == (juce::uint32) lid);
            const bool isHoveredDest   = (hoveredLinkDstId != 0 && hoveredLinkDstId == (juce::uint32) lid);
            if (isHoveredSource || isHoveredDest)
            {
                actualTitleBarColor = IM_COL32(255, 220, 0, 255);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, actualTitleBarColor);
            }

            // Visual feedback for muted nodes (overrides category color and hover)
            const bool isMuted = mutedNodeStates.count(lid) > 0;
            if (isMuted) {
                actualTitleBarColor = IM_COL32(80, 80, 80, 255);
                ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, actualTitleBarColor);
            }

#if JUCE_DEBUG
            gLastRenderedNodeLabel = moduleLabel;
#endif
            ImNodes::BeginNode ((int) lid);
#if JUCE_DEBUG
            ++gImNodesNodeDepth;
#endif
            ImNodes::BeginNodeTitleBar();
            
            // Calculate optimal text color based on title bar background color
            ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(actualTitleBarColor);
            ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(optimalTextColor));
            
            // Special handling for reroute nodes: show dynamic type only (no 'Reroute' prefix)
            if (type.equalsIgnoreCase("reroute"))
            {
                if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(lid)))
                {
                    PinDataType passthroughType = reroute->getPassthroughType();
                    juce::String typeName;
                    switch (passthroughType)
                    {
                        case PinDataType::CV:    typeName = "CV"; break;
                        case PinDataType::Audio: typeName = "Audio"; break;
                        case PinDataType::Gate:  typeName = "Gate"; break;
                        case PinDataType::Raw:   typeName = "Raw"; break;
                        case PinDataType::Video: typeName = "Video"; break;
                        default:                 typeName = "Audio"; break;
                    }
                    ImGui::TextUnformatted(typeName.toRawUTF8());
                }
                else
                {
                    ImGui::TextUnformatted(type.toRawUTF8());
                }
            }
            else
            {
                ImGui::TextUnformatted(type.toRawUTF8());
            }
            
            // Pop the text color we pushed
            ImGui::PopStyleColor();
            
            ImNodes::EndNodeTitleBar();

            // Get node content width - check if module has custom size, otherwise use default
            float nodeContentWidth = 240.0f; // Default width
            if (auto* mp = synth->getModuleForLogical(lid))
            {
                ImVec2 customSize = mp->getCustomNodeSize();
                if (customSize.x > 0.0f) // Module specified a custom width
                {
                    nodeContentWidth = customSize.x;
                }
            }

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
if (auto* mp = synth->getModuleForLogical (lid))
{
    ImGui::PushID ((int) lid);
#if JUCE_DEBUG
    ImGuiStackBalanceChecker parameterStackGuard;
    ImNodesDepthSnapshot depthSnapshot(moduleLabel + "::drawParametersInNode");
#endif

    // This new lambda function checks if a parameter is being modulated
    auto isParamModulated = [&](const juce::String& paramId) -> bool {
        if (!synth) return false;
        if (auto* mp = synth->getModuleForLogical(lid))
        {
            int busIdx = -1, chInBus = -1;
            // Use the new standardized routing API on the module itself
            if (!mp->getParamRouting(paramId, busIdx, chInBus)) 
                return false;

            // Calculate the absolute channel index that the graph uses for this bus/channel pair
            const int absoluteChannelIndex = mp->getChannelIndexInProcessBlockBuffer(true, busIdx, chInBus);
            if (absoluteChannelIndex < 0) return false;
            
            // Scan the simple graph connections for a match
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == lid && c.dstChan == absoluteChannelIndex)
                    return true;
            }
        }
        return false;
    };

    // Helper to read a live, modulated value if available (respects _mod alias)
    auto getLiveValueOr = [&](const juce::String& paramId, float fallback) -> float
    {
        if (!synth) return fallback;
        if (auto* mp = synth->getModuleForLogical(lid))
            return mp->getLiveParamValueFor(paramId + "_mod", paramId + "_live", fallback);
        return fallback;
    };
    // Create a new function that calls pushSnapshot
    auto onModificationEnded = [&](){ this->pushSnapshot(); };
    // --- SPECIAL RENDERING FOR SAMPLE LOADER ---
    if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (buttons, sliders, etc.)
        // We pass a modified onModificationEnded to avoid creating undo states while dragging.
        sampleLoader->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);

        // Now, handle the spectrogram texture and drawing
        juce::OpenGLTexture* texturePtr = nullptr;
        if (auto it = sampleLoaderTextureIds.find((int)lid); it != sampleLoaderTextureIds.end())
            texturePtr = it->second.get();

        juce::Image spectrogram = sampleLoader->getSpectrogramImage();
        if (spectrogram.isValid())
        {
            if (texturePtr == nullptr)
            {
                auto tex = std::make_unique<juce::OpenGLTexture>();
                texturePtr = tex.get();
                sampleLoaderTextureIds[(int)lid] = std::move(tex);
            }
            // Upload or update texture from JUCE image (handles format & parameters internally)
            texturePtr->loadImage(spectrogram);

            ImGui::Image((void*)(intptr_t) texturePtr->getTextureID(), ImVec2(nodeContentWidth, 100.0f));

            // Drag state is tracked per Sample Loader node to avoid cross-node interference
            static std::unordered_map<int,int> draggedHandleByNode; // lid -> -1,0,1
            int& draggedHandle = draggedHandleByNode[(int) lid];
            if (draggedHandle != 0 && draggedHandle != 1) draggedHandle = -1;
            ImGui::SetCursorScreenPos(ImGui::GetItemRectMin());
            ImGui::InvisibleButton("##spectrogram_interaction", ImVec2(nodeContentWidth, 100.0f));

            auto* drawList = ImGui::GetWindowDrawList();
            const ImVec2 rectMin = ImGui::GetItemRectMin();
            const ImVec2 rectMax = ImGui::GetItemRectMax();

            float startNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeStart")->load();
            float endNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeEnd")->load();

            // Use live telemetry values when modulated
            startNorm = sampleLoader->getLiveParamValueFor("rangeStart_mod", "rangeStart_live", startNorm);
            endNorm = sampleLoader->getLiveParamValueFor("rangeEnd_mod", "rangeEnd_live", endNorm);

            // Visual guard even when modulated
            const float kMinGap = 0.001f;
            startNorm = juce::jlimit(0.0f, 1.0f, startNorm);
            endNorm   = juce::jlimit(0.0f, 1.0f, endNorm);
            if (startNorm >= endNorm)
            {
                if (startNorm <= 1.0f - kMinGap)
                    endNorm = juce::jmin(1.0f, startNorm + kMinGap);
                else
                    startNorm = juce::jmax(0.0f, endNorm - kMinGap);
            }

            // --- FIX FOR BUG 1: Separate modulation checks for each handle ---
            bool startIsModulated = isParamModulated("rangeStart_mod");
            bool endIsModulated = isParamModulated("rangeEnd_mod");

            const bool itemHovered = ImGui::IsItemHovered();
            const bool itemActive  = ImGui::IsItemActive();
            if (itemHovered)
            {
                ImVec2 mousePos = ImGui::GetMousePos();
                float startHandleX = rectMin.x + startNorm * nodeContentWidth;
                float endHandleX = rectMin.x + endNorm * nodeContentWidth;

                bool canDragStart = !startIsModulated && (std::abs(mousePos.x - startHandleX) < 5);
                bool canDragEnd = !endIsModulated && (std::abs(mousePos.x - endHandleX) < 5);

                if (draggedHandle == -1 && (canDragStart || canDragEnd))
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                }

                if (ImGui::IsItemClicked())
                {
                    // Only allow dragging to start if the corresponding handle is not modulated
                    if (canDragStart && canDragEnd)
                        draggedHandle = (std::abs(mousePos.x - startHandleX) < std::abs(mousePos.x - endHandleX)) ? 0 : 1;
                    else if (canDragStart)
                        draggedHandle = 0;
                    else if (canDragEnd)
                        draggedHandle = 1;
                }
            }

            if (itemActive && ImGui::IsMouseReleased(0))
            {
                if (draggedHandle != -1) onModificationEnded();
                draggedHandle = -1;
            }

            // Handle the drag update, checking the specific modulation flag for the active handle
            if (itemActive && draggedHandle != -1 && ImGui::IsMouseDragging(0))
            {
                float newNormX = juce::jlimit(0.0f, 1.0f, (ImGui::GetMousePos().x - rectMin.x) / nodeContentWidth);
                if (draggedHandle == 0 && !startIsModulated)
                {
                    // Guard: start cannot be >= end
                    startNorm = juce::jmin(newNormX, endNorm - 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeStart")->setValueNotifyingHost(startNorm);
                }
                else if (draggedHandle == 1 && !endIsModulated)
                {
                    // Guard: end cannot be <= start
                    endNorm = juce::jmax(newNormX, startNorm + 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeEnd")->setValueNotifyingHost(endNorm);
                }
            }

            float startX = rectMin.x + startNorm * nodeContentWidth;
            float endX = rectMin.x + endNorm * nodeContentWidth;
            drawList->AddRectFilled(rectMin, ImVec2(startX, rectMax.y), IM_COL32(0, 0, 0, 120));
            drawList->AddRectFilled(ImVec2(endX, rectMin.y), rectMax, IM_COL32(0, 0, 0, 120));
            drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
            drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
        }
    }
    // --- SPECIAL RENDERING FOR AUDIO INPUT (MULTI-CHANNEL) ---
    else if (auto* audioIn = dynamic_cast<AudioInputModuleProcessor*>(mp))
    {
        auto& apvts = audioIn->getAPVTS();

        // --- Device Selectors ---
        juce::AudioDeviceManager::AudioDeviceSetup setup;
        deviceManager.getAudioDeviceSetup(setup);
        
        // Input Device
        juce::StringArray availableInputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableInputDevices = deviceType->getDeviceNames(true);
        }
        std::vector<const char*> inputDeviceItems;
        for (const auto& name : availableInputDevices) inputDeviceItems.push_back(name.toRawUTF8());
        int currentInputDeviceIndex = availableInputDevices.indexOf(setup.inputDeviceName);
        if (currentInputDeviceIndex < 0) currentInputDeviceIndex = 0;

        ImGui::PushItemWidth(nodeContentWidth);
        if (ImGui::Combo("Input Device", &currentInputDeviceIndex, inputDeviceItems.data(), (int)inputDeviceItems.size())) {
            if (currentInputDeviceIndex < availableInputDevices.size()) {
                setup.inputDeviceName = availableInputDevices[currentInputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }

        // Output Device
        juce::StringArray availableOutputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableOutputDevices = deviceType->getDeviceNames(false);
        }
        std::vector<const char*> outputDeviceItems;
        for (const auto& name : availableOutputDevices) outputDeviceItems.push_back(name.toRawUTF8());
        int currentOutputDeviceIndex = availableOutputDevices.indexOf(setup.outputDeviceName);
        if (currentOutputDeviceIndex < 0) currentOutputDeviceIndex = 0;
        
        if (ImGui::Combo("Output Device", &currentOutputDeviceIndex, outputDeviceItems.data(), (int)outputDeviceItems.size())) {
            if (currentOutputDeviceIndex < availableOutputDevices.size()) {
                setup.outputDeviceName = availableOutputDevices[currentOutputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }
        
        // --- Channel Count ---
        auto* numChannelsParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("numChannels"));
        int numChannels = numChannelsParam->get();
        if (ImGui::SliderInt("Channels", &numChannels, 1, AudioInputModuleProcessor::MAX_CHANNELS)) {
            *numChannelsParam = numChannels;
            onModificationEnded();
        }
        
        // --- Threshold Sliders ---
        auto* gateThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"));
        float gateThresh = gateThreshParam->get();
        if (ImGui::SliderFloat("Gate Threshold", &gateThresh, 0.0f, 1.0f, "%.3f")) {
            *gateThreshParam = gateThresh;
            onModificationEnded();
        }
        
        auto* trigThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("triggerThreshold"));
        float trigThresh = trigThreshParam->get();
        if (ImGui::SliderFloat("Trigger Threshold", &trigThresh, 0.0f, 1.0f, "%.3f")) {
            *trigThreshParam = trigThresh;
            onModificationEnded();
        }
        
        ImGui::PopItemWidth();

        // --- Dynamic Channel Selectors & VU Meters ---
        auto hardwareChannels = deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getInputChannelNames() : juce::StringArray{};
        if (!hardwareChannels.isEmpty())
        {
            std::vector<const char*> hwChannelItems;
            for (const auto& name : hardwareChannels) hwChannelItems.push_back(name.toRawUTF8());
            
            for (int i = 0; i < numChannels; ++i) {
                auto* mappingParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(i)));
                int selectedHwChannel = mappingParam->get();
                selectedHwChannel = juce::jlimit(0, (int)hwChannelItems.size() - 1, selectedHwChannel);

                ImGui::PushID(i);
                ImGui::PushItemWidth(nodeContentWidth * 0.6f);
                if (ImGui::Combo(("Input for Out " + juce::String(i + 1)).toRawUTF8(), &selectedHwChannel, hwChannelItems.data(), (int)hwChannelItems.size())) {
                    *mappingParam = selectedHwChannel;
                    std::vector<int> newMapping(numChannels);
                    for (int j = 0; j < numChannels; ++j) {
                        auto* p = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(j)));
                        newMapping[j] = p->get();
                    }
                    synth->setAudioInputChannelMapping(synth->getNodeIdForLogical(lid), newMapping);
                    onModificationEnded();
                }
                ImGui::PopItemWidth();

                ImGui::SameLine();
                
                // --- VU Meter with Threshold Lines ---
                float level = (i < (int)audioIn->channelLevels.size() && audioIn->channelLevels[i]) ? audioIn->channelLevels[i]->load() : 0.0f;
                ImVec2 meterSize(nodeContentWidth * 0.38f, ImGui::GetTextLineHeightWithSpacing() * 0.8f);
                ImGui::ProgressBar(level, meterSize, "");

                // Draw threshold lines on top of the progress bar
                ImVec2 p_min = ImGui::GetItemRectMin();
                ImVec2 p_max = ImGui::GetItemRectMax();
                ImDrawList* draw_list = ImGui::GetWindowDrawList();

                // Gate Threshold (Yellow)
                float gateLineX = p_min.x + gateThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);

                // Trigger Threshold (Orange)
                float trigLineX = p_min.x + trigThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
                
                ImGui::PopID();
            }
        }
    }
    // --- SPECIAL RENDERING FOR OPENCV MODULES (WITH VIDEO FEED) ---
    else if (auto* webcamModule = dynamic_cast<WebcamLoaderModule*>(mp))
    {
        juce::Image frame = webcamModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        webcamModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* videoFileModule = dynamic_cast<VideoFileLoaderModule*>(mp))
    {
        juce::Image frame = videoFileModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        videoFileModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* movementModule = dynamic_cast<MovementDetectorModule*>(mp))
    {
        // MovementDetectorModule handles its own video preview rendering with zone interaction in drawParametersInNode
        movementModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* poseModule = dynamic_cast<PoseEstimatorModule*>(mp))
    {
        // PoseEstimatorModule handles its own video preview rendering with zone interaction in drawParametersInNode
        poseModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* colorModule = dynamic_cast<ColorTrackerModule*>(mp))
    {
        // ColorTrackerModule handles its own video preview rendering with zone interaction in drawParametersInNode
        colorModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* contourModule = dynamic_cast<ContourDetectorModule*>(mp))
    {
        // ContourDetectorModule handles its own video preview rendering with zone interaction in drawParametersInNode
        contourModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* objModule = dynamic_cast<ObjectDetectorModule*>(mp))
    {
        // ObjectDetectorModule handles its own video preview rendering with zone interaction in drawParametersInNode
        objModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (false)  // Keep old code commented below for reference
    {
        juce::Image frame = objModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        objModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* handModule = dynamic_cast<HandTrackerModule*>(mp))
    {
        // HandTrackerModule handles its own video preview rendering with zone interaction in drawParametersInNode
        handModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* faceModule = dynamic_cast<FaceTrackerModule*>(mp))
    {
        // FaceTrackerModule handles its own video preview rendering with zone interaction in drawParametersInNode
        faceModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* fxModule = dynamic_cast<VideoFXModule*>(mp))
    {
        juce::Image frame = fxModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                // Flip Y-coords for correct orientation
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        // Now draw the regular parameters below the video
        fxModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* cropVideoModule = dynamic_cast<CropVideoModule*>(mp))
    {
        // CropVideoModule handles its own preview rendering with interaction in drawParametersInNode
        cropVideoModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else
    {
        mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);
    }
#if JUCE_DEBUG
    parameterStackGuard.validate(moduleLabel + "::drawParametersInNode");
#endif
    ImGui::Spacing();
    ImGui::PopID();
}
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
            
            // Helper to draw right-aligned text within a node's content width
            // From imnodes examples (color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73):
            // Use ImGui::Indent() for right-alignment - this is the CORRECT ImNodes pattern!
            auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
            {
                const ImVec2 textSize = ImGui::CalcTextSize(txt);
                
                // Indent by (nodeWidth - textWidth) to right-align the text
                // CRITICAL: Must call Unindent() to prevent indent from persisting!
                const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
                ImGui::Indent(indentAmount);
                ImGui::TextUnformatted(txt);
                ImGui::Unindent(indentAmount);  // Reset indent!
            };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinId({lid, channel, true});
                seenAttrs.insert(attr);
                availableAttrs.insert(attr);

                // Get pin data type for color coding
                PinID pinId = { lid, channel, true, false, "" };
                PinDataType pinType = this->getPinDataTypeForPin(pinId);
                unsigned int pinColor = this->getImU32ForType(pinType);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                ImNodes::BeginInputAttribute(attr);
#if JUCE_DEBUG
                ++gImNodesInputDepth;
#endif
                ImGui::TextUnformatted(label);
                ImNodes::EndInputAttribute();
#if JUCE_DEBUG
                --gImNodesInputDepth;
                jassert(gImNodesInputDepth >= 0);
#endif

                // --- THIS IS THE DEFINITIVE FIX ---
                // Get the bounding box of the pin circle that was just drawn.
                ImVec2 pinMin = ImGui::GetItemRectMin();
                ImVec2 pinMax = ImGui::GetItemRectMax();
                // Calculate the exact center and cache it.
                float centerX = (pinMin.x + pinMax.x) * 0.5f;
                float centerY = (pinMin.y + pinMax.y) * 0.5f;
                attrPositions[attr] = ImVec2(centerX, centerY);
                // --- END OF FIX ---

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ThemeText("Connected", theme.text.active);
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                // CRASH FIX: Verify module exists before accessing it
                                if (c.srcLogicalId != 0 && synth != nullptr)
                                {
                                    bool moduleExists = false;
                                    for (const auto& modInfo : synth->getModulesInfo())
                                    {
                                        if (modInfo.first == c.srcLogicalId)
                                        {
                                            moduleExists = true;
                                            break;
                                        }
                                    }
                                    
                                    if (moduleExists)
                                    {
                                        if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                        {
                                            float value = srcMod->getOutputChannelValue(c.srcChan);
                                            ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                            ImGui::Text("Value: %.3f", value);
                                        }
                                    }
                                }
                                break; 
                            }
                        }
                    } else {
                        ThemeText("Not Connected", theme.text.disabled);
                    }
                    // Show pin data type
                    ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                    ImGui::EndTooltip();
                }
            };

                // NEW CLEAN OUTPUT PIN TEXT FUNCTION - FIXED SPACING
                helpers.drawAudioOutputPin = [&](const char* label, int channel)
                {
                    const int attr = encodePinId({(juce::uint32)lid, channel, false});
                    seenAttrs.insert(attr);
                    availableAttrs.insert(attr);

                    PinID pinId = {(juce::uint32)lid, channel, false, false, ""};
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(attr) > 0;

                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                    // EXACT OFFICIAL PATTERN: Text right-aligned, pin touches text edge
                    ImNodes::BeginOutputAttribute(attr);
#if JUCE_DEBUG
                    ++gImNodesOutputDepth;
#endif
                    const float label_width = ImGui::CalcTextSize(label).x;
                    ImGui::Indent(nodeContentWidth - label_width);  // Right-align to content width
                    ImGui::TextUnformatted(label);
                    ImGui::Unindent(nodeContentWidth - label_width);
                    ImNodes::EndOutputAttribute();
#if JUCE_DEBUG
                    --gImNodesOutputDepth;
                    jassert(gImNodesOutputDepth >= 0);
#endif

                    // Cache pin center
                    {
                        ImVec2 pinMin = ImGui::GetItemRectMin();
                        ImVec2 pinMax = ImGui::GetItemRectMax();
                        float centerY = (pinMin.y + pinMax.y) * 0.5f;
                        float x_pos   = pinMax.x;
                        attrPositions[attr] = ImVec2(x_pos, centerY);
                    }

                    ImNodes::PopColorStyle();

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                    if (isConnected) {
                        ThemeText("Connected", theme.text.active);
                    } else {
                        ThemeText("Not Connected", theme.text.disabled);
                        }
                        ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                        if (auto* mp = synth->getModuleForLogical(lid))
                        {
                            float value = mp->getOutputChannelValue(channel);
                            ImGui::Text("Value: %.3f", value);
                        }
                        ImGui::EndTooltip();
                    }
                };

            // ADD THE NEW drawParallelPins HELPER
            helpers.drawParallelPins = [&](const char* inLabel, int inChannel, const char* outLabel, int outChannel)
            {
                // 3-column layout: [InputPin] [Right-aligned Output Label] [Output Pin]
                ImGui::PushID((inChannel << 16) ^ outChannel ^ lid);
                ImGui::Columns(3, "parallel_io_layout", false);

                const float pinW = 18.0f;
                const float spacing = ImGui::GetStyle().ItemSpacing.x;
                // CRITICAL FIX: Use stable nodeContentWidth to set ALL column widths explicitly
                // This prevents the feedback loop that causes position-dependent node scaling
                
                // Calculate column widths to fill exactly nodeContentWidth
                float inTextW = inLabel ? ImGui::CalcTextSize(inLabel).x : 0.0f;
                float inColW = inLabel ? (inTextW + pinW + spacing) : 0.0f;  // Input label + pin + spacing
                float outPinColW = 20.0f;  // Output pin column (fixed narrow width)
                float labelColW = nodeContentWidth - inColW - outPinColW - spacing;  // Middle fills remaining space

                ImGui::SetColumnWidth(0, inColW);
                ImGui::SetColumnWidth(1, labelColW);
                ImGui::SetColumnWidth(2, outPinColW);

                // Column 0: Input pin with label
                if (inLabel != nullptr)
                {
                    int inAttr = encodePinId({lid, inChannel, true});
                    seenAttrs.insert(inAttr);
                    availableAttrs.insert(inAttr);
                    PinID pinId = { lid, inChannel, true, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedInputAttrs.count(inAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginInputAttribute(inAttr);
#if JUCE_DEBUG
                    ++gImNodesInputDepth;
#endif
                    ImGui::TextUnformatted(inLabel);
                    ImNodes::EndInputAttribute();
#if JUCE_DEBUG
                    --gImNodesInputDepth;
                    jassert(gImNodesInputDepth >= 0);
#endif
                    ImNodes::PopColorStyle();
                }

                // Column 1: Output label (right-aligned within this column)
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    // EXACT OFFICIAL PATTERN: Same as regular output pins
                    const float textW = ImGui::CalcTextSize(outLabel).x;
                    ImGui::Indent(labelColW - textW);  // Right-align to column width
                    ImGui::TextUnformatted(outLabel);
                    ImGui::Unindent(labelColW - textW);
                }

                // Column 2: Output pin
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    int outAttr = encodePinId({lid, outChannel, false});
                    seenAttrs.insert(outAttr);
                    availableAttrs.insert(outAttr);
                    PinID pinId = { lid, outChannel, false, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(outAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
#if JUCE_DEBUG
                    ++gImNodesOutputDepth;
#endif
                    ImNodes::BeginOutputAttribute(outAttr);
                    ImGui::Dummy(ImVec2(1.0f, ImGui::GetTextLineHeight()));
                    ImNodes::EndOutputAttribute();
#if JUCE_DEBUG
                    --gImNodesOutputDepth;
                    jassert(gImNodesOutputDepth >= 0);
#endif

                    // Cache pin center
                    ImVec2 pinMin = ImGui::GetItemRectMin();
                    ImVec2 pinMax = ImGui::GetItemRectMax();
                    float yCenter = pinMin.y + (pinMax.y - pinMin.y) * 0.5f;
                    float xPos = pinMax.x;
                    attrPositions[outAttr] = ImVec2(xPos, yCenter);
                    ImNodes::PopColorStyle();
                }

                // Restore to single column for the next row
                ImGui::Columns(1);
                ImGui::PopID();
            };

            // --- DYNAMIC PIN FIX ---
            // Add a new helper that uses dynamic pin information from modules
            helpers.drawIoPins = [&](ModuleProcessor* module) {
                if (!module) return;
                const auto logicalId = module->getLogicalId();
                const auto moduleType = synth->getModuleTypeForLogical(logicalId);

                // 1. Get dynamic pins from the module itself.
                auto dynamicInputs = module->getDynamicInputPins();
                auto dynamicOutputs = module->getDynamicOutputPins();

                // 2. Get static pins from the database as a fallback.
                const auto& pinDb = getModulePinDatabase();
                auto pinInfoIt = pinDb.find(moduleType.toLowerCase());
                const bool hasStaticPinInfo = (pinInfoIt != pinDb.end());
                const auto& staticPinInfo = hasStaticPinInfo ? pinInfoIt->second : ModulePinInfo{};

                // 3. If the module has dynamic pins, use the new system
                const bool hasDynamicPins = !dynamicInputs.empty() || !dynamicOutputs.empty();
                
                if (hasDynamicPins)
                {
                    // Draw inputs (dynamic if available, otherwise static)
                    if (!dynamicInputs.empty())
                    {
                        for (const auto& pin : dynamicInputs)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioIns)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    
                    // Draw outputs (dynamic if available, otherwise static)
                    if (!dynamicOutputs.empty())
                    {
                        for (const auto& pin : dynamicOutputs)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioOuts)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                }
                else
                {
                    // 4. Otherwise, fall back to the module's custom drawIoPins implementation
                    module->drawIoPins(helpers);
                }
            };
            // --- END OF DYNAMIC PIN FIX ---

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                {
#if JUCE_DEBUG
                    ImGuiStackBalanceChecker ioStackGuard;
                    ImNodesDepthSnapshot ioDepthSnapshot(moduleLabel + "::drawIoPins");
#endif
                    helpers.drawIoPins(mp);
#if JUCE_DEBUG
                    ioStackGuard.validate(type + " [lid=" + juce::String((int)lid) + "]::drawIoPins");
#endif
                }

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
#if JUCE_DEBUG
            --gImNodesNodeDepth;
            jassert(gImNodesNodeDepth >= 0);
#endif
            
            // Cache position for snapshot safety
            // Graph is always in consistent state since we rebuild at frame start
            lastKnownNodePositions[(int)lid] = ImNodes::GetNodeGridSpacePos((int)lid);
            
            // Pop muted node styles (in reverse order of push)
            if (isMuted) {
                ImNodes::PopColorStyle();      // Mute TitleBar
                ImGui::PopStyleVar();          // Alpha
                ImNodes::PopStyleVar();        // NodePadding
            }
            
            // Pop hover highlight color
            if (isHoveredSource || isHoveredDest)
                ImNodes::PopColorStyle();      // Hover TitleBar
            
            // Pop category colors (in reverse order of push)
            ImNodes::PopColorStyle();          // TitleBarSelected
            ImNodes::PopColorStyle();          // TitleBarHovered
            ImNodes::PopColorStyle();          // TitleBar
            
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
        if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
        {
            // Apply saved position once; do not write (0,0) defaults
            const ImVec2 p = it->second;
            if (!(p.x == 0.0f && p.y == 0.0f))
            {
                ImNodes::SetNodeGridSpacePos((int) lid, p);
                juce::Logger::writeToLog("[PositionRestore] Applied pending position for node " + juce::String((int)lid) + ": (" + juce::String(p.x) + ", " + juce::String(p.y) + ")");
            }
            pendingNodePositions.erase(it);
        }
        else if ((int)lid == 999)
        {
            // BPM Monitor node (999): set default position if not in pending positions
            ImVec2 currentPos = ImNodes::GetNodeGridSpacePos((int)lid);
            if (currentPos.x == 0.0f && currentPos.y == 0.0f)
            {
                ImNodes::SetNodeGridSpacePos((int)lid, ImVec2(450.0f, 300.0f));
                juce::Logger::writeToLog("[PositionRestore] Set default position for BPM monitor node: (450.0, 300.0)");
            }
        }
            // Apply pending size if queued (for Comment nodes to prevent feedback loop)
            if (auto itSize = pendingNodeSizes.find((int) lid); itSize != pendingNodeSizes.end())
            {
                // Store the desired size in the Comment module itself
                if (auto* comment = dynamic_cast<CommentModuleProcessor*>(synth->getModuleForLogical((juce::uint32)lid)))
                {
                    comment->nodeWidth = itSize->second.x;
                    comment->nodeHeight = itSize->second.y;
                }
                pendingNodeSizes.erase(itSize);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        bool triggerInsertMixer = false;
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            const juce::String selectedType = selectedLogicalId != 0 ? getTypeForLogical((juce::uint32)selectedLogicalId) : juce::String();
            const bool selectedIsMeta = selectedType.equalsIgnoreCase("meta_module") || selectedType.equalsIgnoreCase("meta");

            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0 && selectedLogicalId != 999)
            {
                mutedNodeStates.erase((juce::uint32)selectedLogicalId); // Clean up muted state if exists
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                pushSnapshot();
                NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(1) + " node(s)");
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    pushSnapshot();
                }
            }
            if (ImGui::MenuItem("Expand Meta Module", nullptr, false, selectedIsMeta))
            {
                expandMetaModule((juce::uint32)selectedLogicalId);
            }
            if (ImGui::MenuItem("Insert Mixer", "Ctrl+T") && selectedLogicalId != 0) { triggerInsertMixer = true; }
            ImGui::EndPopup();
        }

        // Shortcut: Ctrl+T to insert a Mixer after selected node and reroute
        // Debounced Ctrl+T
        const bool ctrlDown = ImGui::GetIO().KeyCtrl;
        if (!ctrlDown)
        {
            mixerShortcutCooldown = false;
            insertNodeShortcutCooldown = false;
        }

        const bool insertMixerShortcut = consumeShortcutFlag(shortcutInsertMixerRequested);
        const bool connectToTrackMixerShortcut = consumeShortcutFlag(shortcutConnectSelectedToTrackMixerRequested);
        
        // Handle "Connect Selected to Track Mixer" shortcut
        if (connectToTrackMixerShortcut && ImNodes::NumSelectedNodes() > 0)
        {
            handleConnectSelectedToTrackMixer();
        }
        
        if ((triggerInsertMixer || (selectedLogicalId != 0 && insertMixerShortcut)) && !mixerShortcutCooldown)
        {
            mixerShortcutCooldown = true; // Prevent re-triggering in the same frame
            const juce::uint32 srcLid = (juce::uint32) selectedLogicalId;

            juce::Logger::writeToLog("--- [InsertMixer] Start ---");
            juce::Logger::writeToLog("[InsertMixer] Selected Node Logical ID: " + juce::String(srcLid));

            auto srcNodeId = synth->getNodeIdForLogical(srcLid);
            if (srcNodeId.uid == 0) 
            {
                juce::Logger::writeToLog("[InsertMixer] ABORT: Source node with logical ID " + juce::String(srcLid) + " is invalid or could not be found.");
            } 
            else 
            {
                // 1. Collect all outgoing connections from the selected node
                std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
                for (const auto& c : synth->getConnectionsInfo()) {
                    if (c.srcLogicalId == srcLid) {
                        outgoingConnections.push_back(c);
                    }
                }
                juce::Logger::writeToLog("[InsertMixer] Found " + juce::String(outgoingConnections.size()) + " outgoing connections to reroute.");
                for (const auto& c : outgoingConnections) {
                    juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                    juce::Logger::writeToLog("  - Stored connection: [Src: " + juce::String(c.srcLogicalId) + ":" + juce::String(c.srcChan) + "] -> [Dst: " + destStr + ":" + juce::String(c.dstChan) + "]");
                }

                // 2. Create and position the new mixer node intelligently
                auto mixNodeIdGraph = synth->addModule("mixer");
                const juce::uint32 mixLid = synth->getLogicalIdForNode(mixNodeIdGraph);
                
                ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(selectedLogicalId);
                ImVec2 avgDestPos = srcPos; // Default to source pos if no outputs
                
                if (!outgoingConnections.empty())
                {
                    float totalX = 0.0f, totalY = 0.0f;
                    for (const auto& c : outgoingConnections)
                    {
                        int destId = c.dstIsOutput ? 0 : (int)c.dstLogicalId;
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(destId);
                        totalX += pos.x;
                        totalY += pos.y;
                    }
                    avgDestPos = ImVec2(totalX / outgoingConnections.size(), totalY / outgoingConnections.size());
                }
                else
                {
                    // If there are no outgoing connections, place it to the right
                    avgDestPos.x += 600.0f;
                }
                
                // Place the new mixer halfway between the source and the average destination
                pendingNodePositions[(int)mixLid] = ImVec2((srcPos.x + avgDestPos.x) * 0.5f, (srcPos.y + avgDestPos.y) * 0.5f);
                juce::Logger::writeToLog("[InsertMixer] Added new Mixer. Logical ID: " + juce::String(mixLid) + ", Node ID: " + juce::String(mixNodeIdGraph.uid));

                // 3. Disconnect all original outgoing links
                juce::Logger::writeToLog("[InsertMixer] Disconnecting original links...");
                for (const auto& c : outgoingConnections) {
                    auto currentSrcNodeId = synth->getNodeIdForLogical(c.srcLogicalId);
                    auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);

                    if (currentSrcNodeId.uid != 0 && dstNodeId.uid != 0) {
                        bool success = synth->disconnect(currentSrcNodeId, c.srcChan, dstNodeId, c.dstChan);
                        juce::Logger::writeToLog("  - Disconnecting [" + juce::String(currentSrcNodeId.uid) + ":" + juce::String(c.srcChan) + "] -> [" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                    } else {
                        juce::Logger::writeToLog("  - SKIPPING Disconnect due to invalid node ID.");
                    }
                }

                // 4. Connect the source node to the new mixer's first input
                juce::Logger::writeToLog("[InsertMixer] Connecting source node to new mixer...");
                bool c1 = synth->connect(srcNodeId, 0, mixNodeIdGraph, 0); // L to In A L
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":0] -> [" + juce::String(mixNodeIdGraph.uid) + ":0]... " + (c1 ? "SUCCESS" : "FAILED"));
                bool c2 = synth->connect(srcNodeId, 1, mixNodeIdGraph, 1); // R to In A R
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":1] -> [" + juce::String(mixNodeIdGraph.uid) + ":1]... " + (c2 ? "SUCCESS" : "FAILED"));


                // 5. Connect the mixer's output to all the original destinations (maintaining the chain)
                juce::Logger::writeToLog("[InsertMixer] Connecting mixer to original destinations to maintain chain...");
                if (outgoingConnections.empty()) {
                    juce::Logger::writeToLog("  - No original outgoing connections. Connecting mixer to Main Output by default.");
                    auto outNode = synth->getOutputNodeID();
                    if (outNode.uid != 0) {
                        bool o1 = synth->connect(mixNodeIdGraph, 0, outNode, 0);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":0] -> [Output:0]... " + (o1 ? "SUCCESS" : "FAILED"));
                        bool o2 = synth->connect(mixNodeIdGraph, 1, outNode, 1);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":1] -> [Output:1]... " + (o2 ? "SUCCESS" : "FAILED"));
                    }
                } else {
                    for (const auto& c : outgoingConnections) {
                        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                        if (dstNodeId.uid != 0) {
                            // Connect mixer output to the same destination the original node was connected to
                            // This maintains the chain: original -> mixer -> destination
                            bool success = synth->connect(mixNodeIdGraph, c.srcChan, dstNodeId, c.dstChan);
                            juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                            juce::Logger::writeToLog("  - Maintaining chain: Mixer [" + juce::String(mixNodeIdGraph.uid) + ":" + juce::String(c.srcChan) + "] -> " + destStr + "[" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                        } else {
                            juce::Logger::writeToLog("  - SKIPPING Reconnect due to invalid destination node ID for original logical ID " + juce::String(c.dstLogicalId));
                        }
                    }
                }

                graphNeedsRebuild = true;
                pushSnapshot(); // Make the entire operation undoable
                juce::Logger::writeToLog("[InsertMixer] Rerouting complete. Flagging for graph rebuild.");
            }
            juce::Logger::writeToLog("--- [InsertMixer] End ---");
        }

        // Shortcut: Ctrl+I to show Insert Node popup menu
        const bool showInsertPopupShortcut = consumeShortcutFlag(shortcutShowInsertPopupRequested);
        if (selectedLogicalId != 0 && showInsertPopupShortcut && !insertNodeShortcutCooldown)
        {
            insertNodeShortcutCooldown = true;
            showInsertNodePopup = true;
        }

        // Insert Node popup menu
        if (showInsertNodePopup)
        {
            ImGui::OpenPopup("InsertNodePopup");
            showInsertNodePopup = false;
        }

        if (ImGui::BeginPopup("InsertNodePopup"))
        {
            ImGui::Text("Insert Node Between Connections");
            
            // Audio Path
            if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); ImGui::CloseCurrentPopup(); }
            
            ImGui::Separator();
            
            // Modulation Path
            if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); ImGui::CloseCurrentPopup(); }
            
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        const bool isOutputHovered = (hoveredLinkDstId == kOutputHighlightId);
        ImU32 outputTitleBarColor = IM_COL32(80, 80, 80, 255);  // Default output node color (dark grey)
        if (isOutputHovered)
        {
            outputTitleBarColor = IM_COL32(255, 220, 0, 255);  // Yellow when hovered
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, outputTitleBarColor);
        }
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        
        // Calculate optimal text color based on title bar background color
        ImU32 optimalTextColor = ThemeUtils::getOptimalTextColor(outputTitleBarColor);
        ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(optimalTextColor));
        ImGui::TextUnformatted ("Output");
        ImGui::PopStyleColor();
        
        ImNodes::EndNodeTitleBar();
        if (isOutputHovered)
            ImNodes::PopColorStyle();
        
        // In L pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 0, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 0, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
#if JUCE_DEBUG
            ++gImNodesInputDepth;
#endif
            ImGui::Text ("In L");
            ImNodes::EndInputAttribute();
#if JUCE_DEBUG
            --gImNodesInputDepth;
            jassert(gImNodesInputDepth >= 0);
#endif
            ImNodes::PopColorStyle();
        }
        
        // In R pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 1, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 1, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
#if JUCE_DEBUG
            ++gImNodesInputDepth;
#endif
            ImGui::Text ("In R");
            ImNodes::EndInputAttribute();
#if JUCE_DEBUG
            --gImNodesInputDepth;
            jassert(gImNodesInputDepth >= 0);
#endif
            ImNodes::PopColorStyle();
        }
        
        ImNodes::EndNode();
        
        // Cache output node position for snapshot safety
        // Graph is always in consistent state since we rebuild at frame start
        lastKnownNodePositions[0] = ImNodes::GetNodeGridSpacePos(0);
        
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            juce::Logger::writeToLog("[PositionRestore] Applied pending position for output node 0: (" + juce::String(it->second.x) + ", " + juce::String(it->second.y) + ")");
            pendingNodePositions.erase(it);
        }
        else
        {
            // Output node (0): set default position if not in pending positions
            ImVec2 currentPos = ImNodes::GetNodeGridSpacePos(0);
            if (currentPos.x == 0.0f && currentPos.y == 0.0f)
            {
                ImNodes::SetNodeGridSpacePos(0, ImVec2(1200.0f, 500.0f));
                juce::Logger::writeToLog("[PositionRestore] Set default position for output node: (1200.0, 500.0)");
            }
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections (IDs stable via bitmasking)
        int cableIdx = 0;
        for (const auto& c : synth->getConnectionsInfo())
        {
            
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) {
                continue;
            }
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) {
                continue;
            }
            
            const int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            const int dstAttr = c.dstIsOutput ? encodePinId({0, c.dstChan, true}) : encodePinId({c.dstLogicalId, c.dstChan, true});
            
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
            {
                static std::unordered_set<std::string> skipOnce;
                const std::string key = std::to_string((int)c.srcLogicalId) + ":" + std::to_string(c.srcChan) + "->" +
                                         (c.dstIsOutput? std::string("0") : std::to_string((int)c.dstLogicalId)) + ":" + std::to_string(c.dstChan);
                if (skipOnce.insert(key).second)
                {
                    juce::Logger::writeToLog(
                        juce::String("[ImNodes][SKIP] missing attr: srcPresent=") + (availableAttrs.count(srcAttr)?"1":"0") +
                        " dstPresent=" + (availableAttrs.count(dstAttr)?"1":"0") +
                        " srcKey=(lid=" + juce::String((int)c.srcLogicalId) + ",ch=" + juce::String(c.srcChan) + ")" +
                        " dstKey=(lid=" + juce::String(c.dstIsOutput?0:(int)c.dstLogicalId) + ",ch=" + juce::String(c.dstChan) + ",in=1) id(s)=" +
                        juce::String(srcAttr) + "," + juce::String(dstAttr));
                }
                continue;
            }
            
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            
            // --- THIS IS THE DEFINITIVE FIX ---
            // 1. Determine the base color and check for signal activity.
            auto srcPin = decodePinId(srcAttr);
            PinDataType linkDataType = getPinDataTypeForPin(srcPin);
            ImU32 linkColor = getImU32ForType(linkDataType);
            float magnitude = 0.0f;
            bool hasThicknessModification = false;

            // CRASH FIX: Verify module still exists before accessing it.
            // During preset loading, modules may be destroyed while we're iterating connections.
            if (synth != nullptr && srcPin.logicalId != 0)
            {
                // First verify the module exists in the current module list
                bool moduleExists = false;
                for (const auto& modInfo : synth->getModulesInfo())
                {
                    if (modInfo.first == srcPin.logicalId)
                    {
                        moduleExists = true;
                        break;
                    }
                }
                
                // Only access if module still exists
                if (moduleExists)
                {
                    if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                    {
                        magnitude = srcModule->getOutputChannelValue(srcPin.channel);
                    }
                }
            }

            // 2. If the signal is active, calculate a glowing/blinking color.
            if (magnitude > 0.01f)
            {
                const float blinkSpeed = 8.0f;
                float blinkFactor = (std::sin((float)ImGui::GetTime() * blinkSpeed) + 1.0f) * 0.5f;
                float glowIntensity = juce::jlimit(0.0f, 1.0f, blinkFactor * magnitude * 2.0f);

                // Brighten the base color and modulate alpha for glow effect
                ImVec4 colorVec = ImGui::ColorConvertU32ToFloat4(linkColor);
                colorVec.x = juce::jmin(1.0f, colorVec.x + glowIntensity * 0.4f);
                colorVec.y = juce::jmin(1.0f, colorVec.y + glowIntensity * 0.4f);
                colorVec.z = juce::jmin(1.0f, colorVec.z + glowIntensity * 0.4f);
                colorVec.w = juce::jlimit(0.5f, 1.0f, 0.5f + glowIntensity * 0.5f);
                linkColor = ImGui::ColorConvertFloat4ToU32(colorVec);

                // Make active cables slightly thicker (keep constant in screen space under zoom)
                {
                    float currentZoom = 1.0f;
#if defined(IMNODES_ZOOM_ENABLED)
                    if (ImNodes::GetCurrentContext())
                        currentZoom = ImNodes::EditorContextGetZoom();
#endif
                    ImNodes::PushStyleVar(ImNodesStyleVar_LinkThickness, 3.0f / currentZoom);
                }
                hasThicknessModification = true;
            }

            // 3. Push the chosen color (either normal or glowing) to the style stack.
            const auto& theme = ThemeManager::getInstance().getCurrentTheme();
            ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);
            ImNodes::PushColorStyle(ImNodesCol_LinkHovered, theme.links.link_hovered);
            ImNodes::PushColorStyle(ImNodesCol_LinkSelected, theme.links.link_selected);

            // 4. Check for node hover highlight (this should override the glow).
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle(ImNodesCol_Link, theme.links.link_highlighted);
            }
            
            // 5. Tell imnodes to draw the link. It will use the color we just pushed.
            ImNodes::Link(linkId, srcAttr, dstAttr);
            
            // 6. Pop ALL style modifications to restore the defaults for the next link.
            if (hl) ImNodes::PopColorStyle();
            ImNodes::PopColorStyle(); // LinkSelected
            ImNodes::PopColorStyle(); // LinkHovered
            ImNodes::PopColorStyle(); // Link
            if (hasThicknessModification) ImNodes::PopStyleVar(); // LinkThickness
            
            // --- END OF FIX ---
        }

        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    // --- Handle Auto-Connect Requests from MIDI Players ---
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
        {
            // Check for initial button presses
            if (midiPlayer->autoConnectTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Samplers;
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO;
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Hybrid;
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            // --- THIS IS THE NEW LOGIC ---
            // Check if an update was requested after a new file was loaded
            else if (midiPlayer->connectionUpdateRequested.exchange(false))
            {
                // Re-run the correct handler based on the saved state
                switch (midiPlayer->lastAutoConnectState.load())
                {
                    case MIDIPlayerModuleProcessor::AutoConnectState::Samplers:
                        handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO:
                        handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::Hybrid:
                        handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::None:
                    default:
                        // Do nothing if it wasn't auto-connected before
                        break;
                }
            }
            // --- END OF NEW LOGIC ---
        }
    }
    // --- Handle Auto-Connect Requests using new intelligent system ---
    handleAutoConnectionRequests();

    // Capture hover state for drag/drop logic before we leave the node editor scope
    int hoverPinIdForDrop = -1;
    int hoverNodeIdForDrop = -1;
    int hoverLinkIdForDrop = -1;
    bool pinHoveredDuringEditor = false;
    bool nodeHoveredDuringEditor = false;
    bool linkHoveredDuringEditor = false;

    // ======================================================
    // === 💡 MODAL MINIMAP (v13 - Scale-on-Press) ==========
    // ======================================================
    if (isMinimapEnlarged.load())
    {
        ImNodes::MiniMap(modalMinimapScale, ImNodesMiniMapLocation_BottomRight);
    }
    else
    {
        ImNodes::MiniMap(0.2f, ImNodesMiniMapLocation_BottomRight);
    }
    // ======================================================
    // === 💡 END MODAL MINIMAP =============================
    // ======================================================

    ImNodes::EndNodeEditor();

    // --- Cut-by-line gesture (finalize on release) ---
    {
        const bool rmbReleased = ImGui::IsMouseReleased(ImGuiMouseButton_Right);
        if (cutModeActive && rmbReleased)
        {
            cutModeActive = false;
            cutJustPerformed = true;

            struct Hit { int linkId; float t; ImVec2 posGrid; LinkInfo link; };
            std::vector<Hit> hits;
            hits.reserve(linkIdToAttrs.size());

            auto segmentIntersect = [](const ImVec2& p, const ImVec2& p2, const ImVec2& q, const ImVec2& q2, float& tOut, ImVec2& ptOut) -> bool {
                ImVec2 r{ p2.x - p.x, p2.y - p.y };
                ImVec2 s{ q2.x - q.x, q2.y - q.y };
                const float rxs = r.x * s.y - r.y * s.x;
                const float qmpx = q.x - p.x;
                const float qmpy = q.y - p.y;
                const float qmpxr = qmpx * r.y - qmpy * r.x;
                if (std::abs(rxs) < 1e-6f && std::abs(qmpxr) < 1e-6f) return false; // colinear
                if (std::abs(rxs) < 1e-6f) return false; // parallel
                const float t = (qmpx * s.y - qmpy * s.x) / rxs;
                const float u = (qmpx * r.y - qmpy * r.x) / rxs;
                if (t >= 0.0f && t <= 1.0f && u >= 0.0f && u <= 1.0f)
                {
                    tOut = t;
                    ptOut = ImVec2(p.x + t * r.x, p.y + t * r.y);
                    return true;
                }
                return false;
            };

            auto minf = [](float x, float y){ return x < y ? x : y; };
            auto maxf = [](float x, float y){ return x > y ? x : y; };

            // Build hits
            for (const auto& kv : linkIdToAttrs)
            {
                const int linkId = kv.first;
                const int srcAttr = kv.second.first;
                const int dstAttr = kv.second.second;
                if (srcAttr == 0 || dstAttr == 0) continue;

                LinkInfo li;
                li.linkId = linkId;
                li.srcPin = decodePinId(srcAttr);
                li.dstPin = decodePinId(dstAttr);
                li.isMod = li.srcPin.isMod || li.dstPin.isMod;

                // Prefer actual pin attribute positions if available; fallback to node centers
                ImVec2 a, b;
                auto attrToGrid = [this](int attr)->ImVec2 {
                    auto it = attrPositions.find(attr);
                    if (it != attrPositions.end())
                    {
                        // attrPositions stores screen-space; convert to grid-space
                        const ImVec2 scr = it->second;
                        return ImVec2(scr.x - lastCanvasP0.x - lastEditorPanning.x,
                                      scr.y - lastCanvasP0.y - lastEditorPanning.y);
                    }
                    return ImVec2(FLT_MAX, FLT_MAX);
                };
                ImVec2 aGrid = attrToGrid(srcAttr);
                ImVec2 bGrid = attrToGrid(dstAttr);
                if (aGrid.x != FLT_MAX && bGrid.x != FLT_MAX)
                {
                    a = aGrid;
                    b = bGrid;
                }
                else
                {
                    a = ImNodes::GetNodeGridSpacePos((int)li.srcPin.logicalId);
                    b = ImNodes::GetNodeGridSpacePos((int)li.dstPin.logicalId);
                }
                ImVec2 c = cutStartGrid;
                ImVec2 d = cutEndGrid;

                ImVec2 abMin{ minf(a.x,b.x), minf(a.y,b.y) };
                ImVec2 abMax{ maxf(a.x,b.x), maxf(a.y,b.y) };
                ImVec2 cdMin{ minf(c.x,d.x), minf(c.y,d.y) };
                ImVec2 cdMax{ maxf(c.x,d.x), maxf(c.y,d.y) };
                if (abMax.x < cdMin.x || cdMax.x < abMin.x || abMax.y < cdMin.y || cdMax.y < abMin.y)
                    continue;

                float t = 0.0f; ImVec2 pt{};
                if (segmentIntersect(a, b, c, d, t, pt))
                {
                    if (t <= cutEndpointTEpsilon || t >= (1.0f - cutEndpointTEpsilon))
                        continue;
                    hits.push_back(Hit{ linkId, t, pt, li });
                }
            }

            // Merge per-link
            std::sort(hits.begin(), hits.end(), [](const Hit& x, const Hit& y){
                if (x.linkId != y.linkId) return x.linkId < y.linkId;
                return x.t < y.t;
            });
            std::vector<Hit> merged;
            for (size_t i = 0; i < hits.size(); ++i)
            {
                if (merged.empty()) { merged.push_back(hits[i]); continue; }
                const Hit& prev = merged.back();
                if (prev.linkId == hits[i].linkId)
                {
                    const float dx = hits[i].posGrid.x - prev.posGrid.x;
                    const float dy = hits[i].posGrid.y - prev.posGrid.y;
                    const float distSq = dx*dx + dy*dy;
                    if (distSq < (cutMergeEpsilonPx * cutMergeEpsilonPx))
                        continue;
                }
                merged.push_back(hits[i]);
            }

            if (!merged.empty())
            {
                pushSnapshot();
                const ImVec2 dir = ImVec2(cutEndGrid.x - cutStartGrid.x, cutEndGrid.y - cutStartGrid.y);
                float len = std::sqrt(dir.x*dir.x + dir.y*dir.y);
                ImVec2 n = (len > 1e-6f) ? ImVec2(dir.x/len, dir.y/len) : ImVec2(1.0f, 0.0f);
                float stagger = 0.0f;
                for (const auto& h : merged)
                {
                    // Place by cursor intersection: convert grid -> screen for positioning API
                    ImVec2 gridPos = ImVec2(h.posGrid.x + n.x * 12.0f + stagger, h.posGrid.y + n.y * 12.0f + stagger);
                    ImVec2 screenPos = ImVec2(lastCanvasP0.x + lastEditorPanning.x + gridPos.x,
                                              lastCanvasP0.y + lastEditorPanning.y + gridPos.y);
                    insertNodeOnLink("reroute", h.link, screenPos);
                    stagger += 6.0f;
                }
                graphNeedsRebuild = true;
            }
        }
    }
#if JUCE_DEBUG
    if (gImNodesNodeDepth != 0 || gImNodesInputDepth != 0 || gImNodesOutputDepth != 0)
    {
        juce::Logger::writeToLog(
            "[ImNodes][DepthLeak][Frame] nodeDepth=" + juce::String(gImNodesNodeDepth) +
            " inputDepth=" + juce::String(gImNodesInputDepth) +
            " outputDepth=" + juce::String(gImNodesOutputDepth) +
            " lastNode=" + gLastRenderedNodeLabel);
        jassertfalse;
        gImNodesNodeDepth = 0;
        gImNodesInputDepth = 0;
        gImNodesOutputDepth = 0;
    }
#endif
    pinHoveredDuringEditor = ImNodes::IsPinHovered(&hoverPinIdForDrop);
    nodeHoveredDuringEditor = ImNodes::IsNodeHovered(&hoverNodeIdForDrop);
    linkHoveredDuringEditor = ImNodes::IsLinkHovered(&hoverLinkIdForDrop);
    juce::ignoreUnused(hoverPinIdForDrop, hoverNodeIdForDrop, hoverLinkIdForDrop);
    int linkStartAttr = -1;
    if (ImNodes::IsLinkStarted(&linkStartAttr))
    {
        dragInsertActive = true;
        dragInsertStartAttrId = linkStartAttr;
        dragInsertStartPin = decodePinId(linkStartAttr);
        shouldOpenDragInsertPopup = false;
        juce::Logger::writeToLog("[DragInsert] Started drag from attr " + juce::String(linkStartAttr));
    }
    if (dragInsertActive)
    {
        const bool cancelRequested = ImGui::IsKeyPressed(ImGuiKey_Escape, false) ||
                                     ImGui::IsMouseReleased(ImGuiMouseButton_Right);
        if (cancelRequested)
        {
            juce::Logger::writeToLog("[DragInsert] Drag cancelled.");
            cancelDragInsert();
        }
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            const bool editorHovered = ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows |
                                                              ImGuiHoveredFlags_AllowWhenBlockedByPopup);
            if (!pinHoveredDuringEditor && !nodeHoveredDuringEditor && !linkHoveredDuringEditor && editorHovered)
            {
                dragInsertDropPos = ImGui::GetMousePos();
                shouldOpenDragInsertPopup = true;
                juce::Logger::writeToLog("[DragInsert] Drop captured on canvas (logicalId="
                                         + juce::String((int)dragInsertStartPin.logicalId)
                                         + ", channel=" + juce::String(dragInsertStartPin.channel) + ").");
            }
            else
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                shouldOpenDragInsertPopup = false;
            }
            dragInsertActive = false;
        }
    }
    else if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
    {
        shouldOpenDragInsertPopup = false;
    }
    // === POP THE TRANSPARENT GRID BACKGROUND STYLE ===
    ImNodes::PopColorStyle(); // Pop BoxSelectorOutline
    ImNodes::PopColorStyle(); // Pop BoxSelector
    ImNodes::PopColorStyle(); // Pop GridLinePrimary
    ImNodes::PopColorStyle(); // Pop GridLine
    ImNodes::PopColorStyle(); // Pop GridBackground
    ImNodes::PopColorStyle(); // Pop NodeOutline
    ImNodes::PopColorStyle(); // Pop NodeBackgroundSelected
    ImNodes::PopColorStyle(); // Pop NodeBackgroundHovered
    ImNodes::PopColorStyle(); // Pop NodeBackground
    // === END OF FIX ===
    hasRenderedAtLeastOnce = true;
    
    if (shouldOpenDragInsertPopup)
    {
        shouldOpenDragInsertPopup = false;
        ImGui::SetNextWindowPos(dragInsertDropPos, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
        ImGui::OpenPopup("DragInsertPopup");
    }
    if (ImGui::BeginPopup("DragInsertPopup"))
    {
        const PinDataType displayType = dragInsertStartPin.isMod
            ? PinDataType::CV
            : getPinDataTypeForPin(dragInsertStartPin);
        const auto& suggestions = getDragInsertSuggestionsFor(dragInsertStartPin);

        if (suggestions.empty())
        {
            ImGui::TextDisabled("No compatible modules found.");
            if (ImGui::MenuItem("Close"))
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                ImGui::CloseCurrentPopup();
            }
        }
        else
        {
            ImGui::Text("Insert node for %s", pinDataTypeToString(displayType));
            ImGui::Separator();

            for (const auto& moduleType : suggestions)
            {
                if (ImGui::MenuItem(moduleType.toRawUTF8()))
                {
                    insertNodeFromDragSelection(moduleType);
                    ImGui::CloseCurrentPopup();
                    break;
                }
            }

            ImGui::Separator();
            if (ImGui::MenuItem("Cancel"))
            {
                dragInsertStartAttrId = -1;
                dragInsertStartPin = PinID{};
                ImGui::CloseCurrentPopup();
            }
        }

        ImGui::EndPopup();
    }

    // ======================================================
    // === 💡 MODAL MINIMAP LOGIC (v13 - Scale-on-Press) ====
    // ======================================================
    ImGuiIO& io = ImGui::GetIO();
    bool isEditorHovered = ImGui::IsWindowHovered(ImGuiHoveredFlags_ChildWindows |
                                                 ImGuiHoveredFlags_AllowWhenBlockedByPopup);

    if (consumeShortcutFlag(shortcutToggleMinimapRequested) && !isMinimapEnlarged.load() && isEditorHovered)
    {
        isMinimapEnlarged.store(true);

        ImVec2 minimapCorner = ImVec2(lastCanvasP0.x + lastCanvasSize.x,
                                      lastCanvasP0.y + lastCanvasSize.y);
        ImVec2 mousePos = io.MousePos;
        float dist_x = minimapCorner.x - mousePos.x;
        float dist_y = minimapCorner.y - mousePos.y;
        float distance = std::sqrt(dist_x * dist_x + dist_y * dist_y);
        float max_dist = std::sqrt(lastCanvasSize.x * lastCanvasSize.x +
                                   lastCanvasSize.y * lastCanvasSize.y);

        float norm_dist = 0.0f;
        if (max_dist > 0.0f)
            norm_dist = juce::jlimit(0.0f, 1.0f, distance / max_dist);

        modalMinimapScale = 0.2f + (norm_dist * 0.6f);
    }

    if (ImGui::IsKeyReleased(ImGuiKey_Comma))
    {
        isMinimapEnlarged.store(false);
        modalMinimapScale = 0.2f;
    }

    if (isMinimapEnlarged.load() && !ImGui::IsWindowFocused(ImGuiHoveredFlags_RootAndChildWindows))
    {
        isMinimapEnlarged.store(false);
        modalMinimapScale = 0.2f;
    }
    // ======================================================
    // === 💡 END MODAL MINIMAP LOGIC =======================
    // ======================================================
    
    // ================== MIDI PLAYER QUICK CONNECT LOGIC ==================
    // Poll all MIDI Player modules for connection requests
    if (synth != nullptr)
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                int requestType = midiPlayer->getAndClearConnectionRequest();
                if (requestType > 0)
                {
                    handleMIDIPlayerConnectionRequest(modInfo.first, midiPlayer, requestType);
                    break; // Only handle one request per frame
                }
            }
        }
    }
    // ================== END MIDI PLAYER QUICK CONNECT ==================
    // ================== META MODULE EDITING LOGIC ==================
    // Check if any Meta Module has requested to be edited
    if (synth != nullptr && metaModuleToEditLid == 0) // Only check if not already editing one
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                // Atomically check and reset the flag
                if (metaModule->editRequested.exchange(false))
                {
                    metaModuleToEditLid = modInfo.first;
                    juce::Logger::writeToLog("[MetaEdit] Opening editor for Meta Module L-ID " + juce::String((int)metaModuleToEditLid));
                    ImGui::OpenPopup("Edit Meta Module");
                    break; // Only handle one request per frame
                }
            }
        }
    }
    
    // Draw the modal popup for the internal editor if one is selected
    if (metaModuleToEditLid != 0)
    {
        ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
        if (ImGui::BeginPopupModal("Edit Meta Module", nullptr, ImGuiWindowFlags_MenuBar))
        {
            ImGui::PushID((int)metaModuleToEditLid);
            auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaModuleToEditLid));
            if (metaModule && metaModule->getInternalGraph())
            {
                if (!metaEditorSession || metaEditorSession->metaLogicalId != metaModuleToEditLid)
                    openMetaModuleEditor(metaModule, metaModuleToEditLid);

                if (metaEditorSession)
                    renderMetaModuleEditor(*metaEditorSession);

                ImGui::Separator();
                if (ImGui::Button("Apply Changes"))
                {
                    if (metaEditorSession && metaEditorSession->dirty)
                    {
                        metaModule->refreshCachedLayout();
                        graphNeedsRebuild = true;
                        snapshotAfterEditor = true;
                    }
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
                ImGui::SameLine();
                if (ImGui::Button("Close"))
                {
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
            }
            else
            {
                ImGui::Text("Meta module %d has no internal graph to edit.", (int)metaModuleToEditLid);
                if (ImGui::Button("Close"))
                {
                    closeMetaModuleEditor();
                    metaModuleToEditLid = 0;
                    ImGui::CloseCurrentPopup();
                }
            }
            ImGui::PopID();
            ImGui::EndPopup();
        }
        else
        {
            closeMetaModuleEditor();
            metaModuleToEditLid = 0;
        }
    }
    // ======================= END OF META MODULE LOGIC =======================

    // --- CONSOLIDATED HOVERED LINK DETECTION ---
    // Declare these variables ONCE, immediately after the editor has ended.
    // All subsequent features that need to know about hovered links can now
    // safely reuse these results without causing redefinition or scope errors.
    // Graph is always in consistent state since we rebuild at frame start
    int hoveredLinkId = -1;
    bool isLinkHovered = ImNodes::IsLinkHovered(&hoveredLinkId);
    // --- END OF CONSOLIDATED DECLARATION ---
    
    // Smart cable visualization is now integrated directly into the link drawing loop above.
    // No separate overlay needed - cables glow by modifying their own color.
    
    // === PROBE TOOL MODE HANDLING ===
    if (isProbeModeActive)
    {
        // Change cursor to indicate probe mode is active
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        
        // Draw "PROBE ACTIVE" indicator at mouse position
        auto* drawList = ImGui::GetForegroundDrawList();
        ImVec2 mousePos = ImGui::GetMousePos();
        const char* text = "PROBE MODE: Click output pin";
        auto textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImVec2(mousePos.x + 20, mousePos.y - 20);
        const auto& theme = ThemeManager::getInstance().getCurrentTheme();
        drawList->AddRectFilled(
            ImVec2(textPos.x - 5, textPos.y - 2),
            ImVec2(textPos.x + textSize.x + 5, textPos.y + textSize.y + 2),
            theme.links.label_background
        );
        drawList->AddText(textPos, theme.links.label_text, text);
        
        // Check for pin clicks
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                auto pinId = decodePinId(hoveredPinId);
                // Check if it's an output pin (not input, not mod)
                if (!pinId.isInput && !pinId.isMod && pinId.logicalId != 0)
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on valid output pin. LogicalID: " + juce::String(pinId.logicalId) + ", Channel: " + juce::String(pinId.channel));
                    auto nodeId = synth->getNodeIdForLogical(pinId.logicalId);
                    synth->setProbeConnection(nodeId, pinId.channel);
                    isProbeModeActive = false; // Deactivate after probing
                }
                else
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on an invalid pin (input or output node). Cancelling.");
                    isProbeModeActive = false;
                }
            }
            else
            {
                // Clicked on empty space, cancel probe mode
                juce::Logger::writeToLog("[PROBE_UI] Probe clicked on empty space. Cancelling.");
                isProbeModeActive = false;
            }
        }
        
        // Allow ESC to cancel probe mode
        if (ImGui::IsKeyPressed(ImGuiKey_Escape))
        {
            isProbeModeActive = false;
            juce::Logger::writeToLog("[PROBE_UI] Cancelled with ESC");
        }
    }
    // --- CONTEXTUAL RIGHT-CLICK HANDLER ---
    // A cable was right-clicked. Store its info and open the insert popup.
    if (isLinkHovered && hoveredLinkId != -1)
    {
        if (ImGui::GetIO().KeyCtrl && ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            // User initiated a split. Find the source pin of the hovered link.
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                splittingFromAttrId = it->second.first; // The source attribute ID
                juce::Logger::writeToLog("[CableSplit] Starting split from attr ID: " + juce::String(splittingFromAttrId));
            }
        }
    }
    // --- END OF CABLE SPLITTING ---

    // 2. If a split-drag is active, handle drawing and completion.
    if (splittingFromAttrId != -1)
    {
        // Draw a line from the source pin to the mouse cursor for visual feedback.
        if (auto it = attrPositions.find(splittingFromAttrId); it != attrPositions.end())
        {
            ImVec2 sourcePos = it->second;
            ImVec2 mousePos = ImGui::GetMousePos();
            const auto& theme = ThemeManager::getInstance().getCurrentTheme();
            ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, theme.links.preview_color, theme.links.preview_width);
        }

        // 3. Handle completion or cancellation of the drag.
        // We use Left-click to complete the link, matching ImNodes' default behavior.
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                // User dropped the link on a pin.
                auto srcPin = decodePinId(splittingFromAttrId);
                auto dstPin = decodePinId(hoveredPinId);

                // Ensure the connection is valid (Output -> Input).
                if (!srcPin.isInput && dstPin.isInput)
                {
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    graphNeedsRebuild = true;
                    pushSnapshot(); // Make it undoable
                }
            }

            // ALWAYS reset the state, whether the connection was successful or not.
            splittingFromAttrId = -1;
        }
        // Also allow cancellation with a right-click.
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            splittingFromAttrId = -1; // Cancel the operation.
        }
    }
    // --- END OF NEW LOGIC ---

    // Open popup now (outside editor) if requested this frame
    if (showInsertNodePopup)
    {
        showInsertNodePopup = false;
        // Validate the link still exists
        if (pendingInsertLinkId != -1)
        {
            bool stillValid = (/* modLinkIdToRoute.count(pendingInsertLinkId) || */ linkIdToAttrs.count(pendingInsertLinkId));
            if (!stillValid)
            {
                juce::Logger::writeToLog("[InsertNode] Skipping popup: link disappeared this frame");
                pendingInsertLinkId = -1;
            }
        }
        if (pendingInsertLinkId != -1)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            // Consume the mouse release/click so the popup stays open
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode] Opened popup (post-editor)");
        }
        else
        {
            linkToInsertOn = {}; // safety
        }
        pendingInsertLinkId = -1;
    }
    // Fallback: If user right-clicked and a link was hovered this frame, open popup using cached hover
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Right)
        && lastHoveredLinkId != -1
        && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        int id = lastHoveredLinkId;
        linkToInsertOn = {}; linkToInsertOn.linkId = id;
        bool captured = false;
        // TODO: Handle modulation link deletion for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(id); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][RC-Fallback] Mod link captured id=" + juce::String(id));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            // Infer modulation vs audio vs video list from pin data types
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Link captured id=" + juce::String(id));
        }
        if (captured)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Opened popup");
        }
        else
        {
            linkToInsertOn.linkId = -1;
        }
    }
    // This function draws the popup if the popup is open.
    drawInsertNodeOnLinkPopup();

    // --- Cable Inspector: Stateless, rebuild-safe implementation ---
    hoveredLinkSrcId = 0;
    hoveredLinkDstId = 0;

    // Skip inspector if popups are open (graph is always in consistent state now)
    const bool anyPopupOpen = ImGui::IsPopupOpen("InsertNodeOnLinkPopup") || ImGui::IsPopupOpen("AddModulePopup");
    // Do not early-return here; we still need to finish the frame and close any ImGui scopes.

    if (!anyPopupOpen && synth != nullptr)
    {
        if (isLinkHovered && hoveredLinkId != -1)
        {
            // Safety: Re-verify link still exists in our mapping
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                // Set highlight IDs for this frame only
                hoveredLinkSrcId = srcPin.logicalId;
                hoveredLinkDstId = (dstPin.logicalId == 0) ? kOutputHighlightId : dstPin.logicalId;

                if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                {
                    const int numOutputs = srcModule->getTotalNumOutputChannels();
                    if (srcPin.channel >= 0 && srcPin.channel < numOutputs)
                    {
                        if (hoveredLinkId != m_currentlyProbedLinkId)
                        {
                            auto sourceNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
                            synth->setProbeConnection(sourceNodeId, srcPin.channel);
                            m_currentlyProbedLinkId = hoveredLinkId;
                        }

                        // Create link info for the tooltip
                        LinkInfo linkInfo;
                        linkInfo.srcLogicalNodeId = srcPin.logicalId;
                        linkInfo.srcNodeId = srcPin.logicalId;
                        linkInfo.srcChannel = srcPin.channel;
                        linkInfo.sourceNodeName = srcModule->getName();
                        linkInfo.pinName = srcModule->getAudioOutputLabel(srcPin.channel);
                        if (linkInfo.pinName.isEmpty())
                            linkInfo.pinName = "Channel " + juce::String(srcPin.channel);

                        ImGui::BeginTooltip();
                        drawLinkInspectorTooltip(linkInfo);
                        ImGui::EndTooltip();
                    }
                    else if (m_currentlyProbedLinkId != -1 && m_currentlyProbedLinkId != hoveredLinkId)
                    {
                        synth->clearProbeConnection();
                        m_currentlyProbedLinkId = -1;
                    }
                }
            }
        }
        else if (m_currentlyProbedLinkId != -1)
        {
            int hoveredNodeId = -1;
            bool isNodeHovered = ImNodes::IsNodeHovered(&hoveredNodeId);

            int hoveredPinId = -1;
            bool isPinHovered = ImNodes::IsPinHovered(&hoveredPinId);

            if (!isLinkHovered && !isNodeHovered && !isPinHovered)
            {
                synth->clearProbeConnection();
                m_currentlyProbedLinkId = -1;
            }
        }
    }
    else if (m_currentlyProbedLinkId != -1 && synth != nullptr)
    {
        synth->clearProbeConnection();
        m_currentlyProbedLinkId = -1;
    }
    // Update hovered node/link id for next frame (must be called outside editor scope)
    // Graph is always in consistent state since we rebuild at frame start
    int hv = -1;
    if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    int hl = -1;
    if (ImNodes::IsLinkHovered(&hl)) lastHoveredLinkId = hl; else lastHoveredLinkId = -1;
    // Shortcut: press 'I' while hovering a link to open Insert-on-Link popup (bypasses mouse handling)
    if (consumeShortcutFlag(shortcutInsertOnLinkRequested) && lastHoveredLinkId != -1 && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        linkToInsertOn = {}; // reset
        linkToInsertOn.linkId = lastHoveredLinkId;
        bool captured = false;
        // TODO: Handle modulation link hover end for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(lastHoveredLinkId); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][KeyI] Mod link captured id=" + juce::String(lastHoveredLinkId));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(lastHoveredLinkId); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][KeyI] Link captured id=" + juce::String(lastHoveredLinkId));
        }
        if (captured)
        {
            pendingInsertLinkId = lastHoveredLinkId;
            showInsertNodePopup = true; // will open next lines
        }
        else
        {
            linkToInsertOn.linkId = -1;
            juce::Logger::writeToLog("[InsertNode][KeyI] No link data found for id=" + juce::String(lastHoveredLinkId));
        }
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }
    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        // Avoid passing nullptr to ImNodes::IsLinkHovered; some builds may write to the pointer
        int dummyHoveredLinkId = -1;
        const bool anyLinkHovered = ImNodes::IsLinkHovered(&dummyHoveredLinkId);
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered()
            && !anyLinkHovered
            && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup")
            && linkToInsertOn.linkId == -1
            && !ImGui::GetIO().KeyAlt
            && !cutJustPerformed) // suppress when cut gesture used
        {
                ImGui::OpenPopup("AddModulePopup");
        }
        // Reset suppression flag at end of popup decision
        if (!ImGui::IsMouseDown(ImGuiMouseButton_Right))
            cutJustPerformed = false;
        // --- REVISED AND IMPROVED "QUICK ADD" POPUP ---
        if (ImGui::BeginPopup("AddModulePopup"))
        {
            static char searchQuery[128] = "";
            static int selectedIndex = 0;  // Track keyboard navigation

            // Auto-focus the search bar when the popup opens and clear any previous search
            if (ImGui::IsWindowAppearing())
            {
                ImGui::SetWindowFocus();

                if (dragInsertStartAttrId != -1)
                {
                    PinID displayPin = dragInsertStartPin;
                    auto type = displayPin.isMod ? PinDataType::CV : getPinDataTypeForPin(displayPin);

                    juce::String seed = ":" + juce::String(pinDataTypeToString(type));
                    juce::String modules;
                    const auto& suggestions = getDragInsertSuggestionsFor(displayPin);
                    for (size_t i = 0; i < suggestions.size(); ++i)
                        modules += ":" + suggestions[i];

                    juce::String tokenized = seed + modules;
                    auto truncated = tokenized.substring(0, juce::jmin((int)tokenized.length(), (int)sizeof(searchQuery) - 1));
                    std::memset(searchQuery, 0, sizeof(searchQuery));
                    std::memcpy(searchQuery, truncated.toRawUTF8(), (size_t)truncated.getNumBytesAsUTF8());
                }
                else
                {
                    searchQuery[0] = '\0';
                }

                ImGui::SetKeyboardFocusHere(0);
                selectedIndex = 0;
            }
            
            ImGui::Text("Add Module");
            ImGui::PushItemWidth(250.0f);
            
            // Enable Enter key detection for instant module creation
            bool enterPressed = ImGui::InputText("Search##addmodule", searchQuery, sizeof(searchQuery), 
                                                  ImGuiInputTextFlags_EnterReturnsTrue);
            
            ImGui::PopItemWidth();
            ImGui::Separator();
            
            // --- PROBE TOOL ---
            if (ImGui::MenuItem("🔬 Probe Signal (Click any output pin)"))
            {
                isProbeModeActive = true;
                ImGui::CloseCurrentPopup();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Activate probe mode to instantly visualize any signal without manual patching.\nClick on any output pin to route it to the probe scope.");
            }
            ImGui::Separator();

            auto addAtMouse = [this](const char* type) {
                auto nodeId = synth->addModule(type);
                juce::String nodeName = juce::String(type).replaceCharacter('_', ' ');
                // Capitalize first letter of each word
                nodeName = nodeName.toLowerCase();
                bool capitalizeNext = true;
                for (int i = 0; i < nodeName.length(); ++i)
                {
                    if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
                    {
                        nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                        capitalizeNext = false;
                    }
                    else if (nodeName[i] == ' ')
                        capitalizeNext = true;
                }
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                // This places the new node exactly where the user right-clicked
                pendingNodeScreenPositions[logicalId] = ImGui::GetMousePosOnOpeningCurrentPopup();
                
                // Special handling for recorder module
                if (juce::String(type).equalsIgnoreCase("recorder"))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical((juce::uint32)logicalId)))
                    {
                        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
                    }
                }
                
                // Give comment nodes a default size to prevent feedback loop
                if (juce::String(type).equalsIgnoreCase("comment"))
                {
                    pendingNodeSizes[logicalId] = ImVec2(250.f, 150.f);
                }
                
                snapshotAfterEditor = true;
                ImGui::CloseCurrentPopup();
            };
            
            juce::String filter(searchQuery);

            ImGui::BeginChild("ModuleList", ImVec2(280, 350), true);

            if (filter.isEmpty())
            {
                // --- BROWSE MODE (No text in search bar) ---
                // Reorganized to match the new category structure
                
                if (ImGui::BeginMenu("Sources")) {
                    if (ImGui::MenuItem("VCO")) addAtMouse("vco");
                    if (ImGui::MenuItem("Polyphonic VCO")) addAtMouse("polyvco");
                    if (ImGui::MenuItem("Noise")) addAtMouse("noise");
                    if (ImGui::MenuItem("Audio Input")) addAtMouse("audio_input");
                    if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample_loader");
                    if (ImGui::MenuItem("Value")) addAtMouse("value");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Effects")) {
                    if (ImGui::MenuItem("VCF")) addAtMouse("vcf");
                    if (ImGui::MenuItem("Delay")) addAtMouse("delay");
                    if (ImGui::MenuItem("Reverb")) addAtMouse("reverb");
                    if (ImGui::MenuItem("Chorus")) addAtMouse("chorus");
                    if (ImGui::MenuItem("Phaser")) addAtMouse("phaser");
                    if (ImGui::MenuItem("Compressor")) addAtMouse("compressor");
                    if (ImGui::MenuItem("Limiter")) addAtMouse("limiter");
                    if (ImGui::MenuItem("Noise Gate")) addAtMouse("gate");
                    if (ImGui::MenuItem("Reroute")) addAtMouse("reroute");
                    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
                    if (ImGui::MenuItem("Bit Crusher")) addAtMouse("bit_crusher");
                    if (ImGui::MenuItem("Graphic EQ")) addAtMouse("graphic_eq");
                    if (ImGui::MenuItem("Waveshaper")) addAtMouse("waveshaper");
                    if (ImGui::MenuItem("8-Band Shaper")) addAtMouse("8bandshaper");
                    if (ImGui::MenuItem("Granulator")) addAtMouse("granulator");
                    if (ImGui::MenuItem("Harmonic Shaper")) addAtMouse("harmonic_shaper");
                    if (ImGui::MenuItem("Time/Pitch Shifter")) addAtMouse("timepitch");
                    if (ImGui::MenuItem("De-Crackle")) addAtMouse("de_crackle");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Modulators")) {
                    if (ImGui::MenuItem("LFO")) addAtMouse("lfo");
                    if (ImGui::MenuItem("ADSR")) addAtMouse("adsr");
                    if (ImGui::MenuItem("Random")) addAtMouse("random");
                    if (ImGui::MenuItem("S&H")) addAtMouse("s_and_h");
                    if (ImGui::MenuItem("Function Generator")) addAtMouse("function_generator");
                    if (ImGui::MenuItem("Shaping Oscillator")) addAtMouse("shaping_oscillator");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Utilities & Logic")) {
                    if (ImGui::MenuItem("VCA")) addAtMouse("vca");
                    if (ImGui::MenuItem("Mixer")) addAtMouse("mixer");
                    if (ImGui::MenuItem("CV Mixer")) addAtMouse("cv_mixer");
                    if (ImGui::MenuItem("Track Mixer")) addAtMouse("track_mixer");
                    if (ImGui::MenuItem("PanVol")) addAtMouse("panvol");
                    if (ImGui::MenuItem("Attenuverter")) addAtMouse("attenuverter");
                    if (ImGui::MenuItem("Lag Processor")) addAtMouse("lag_processor");
                    if (ImGui::MenuItem("Math")) addAtMouse("math");
                    if (ImGui::MenuItem("Map Range")) addAtMouse("map_range");
                    if (ImGui::MenuItem("Quantizer")) addAtMouse("quantizer");
                    if (ImGui::MenuItem("Rate")) addAtMouse("rate");
                    if (ImGui::MenuItem("Comparator")) addAtMouse("comparator");
                    if (ImGui::MenuItem("Logic")) addAtMouse("logic");
                    if (ImGui::MenuItem("Reroute")) addAtMouse("reroute");
                    if (ImGui::MenuItem("Clock Divider")) addAtMouse("clock_divider");
                    if (ImGui::MenuItem("Sequential Switch")) addAtMouse("sequential_switch");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Sequencers")) {
                    if (ImGui::MenuItem("Sequencer")) addAtMouse("sequencer");
                    if (ImGui::MenuItem("Multi Sequencer")) addAtMouse("multi_sequencer");
                    if (ImGui::MenuItem("Tempo Clock")) addAtMouse("tempo_clock");
                    if (ImGui::MenuItem("Snapshot Sequencer")) addAtMouse("snapshot_sequencer");
                    if (ImGui::MenuItem("Stroke Sequencer")) addAtMouse("stroke_sequencer");
                    if (ImGui::MenuItem("Timeline")) addAtMouse("timeline");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("MIDI")) {
                    if (ImGui::MenuItem("MIDI CV")) addAtMouse("midi_cv");
                    if (ImGui::MenuItem("MIDI Player")) addAtMouse("midi_player");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Faders")) addAtMouse("midi_faders");
                    if (ImGui::MenuItem("MIDI Knobs")) addAtMouse("midi_knobs");
                    if (ImGui::MenuItem("MIDI Buttons")) addAtMouse("midi_buttons");
                    if (ImGui::MenuItem("MIDI Jog Wheel")) addAtMouse("midi_jog_wheel");
                    if (ImGui::MenuItem("MIDI Pads")) addAtMouse("midi_pads");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Logger")) addAtMouse("midi_logger");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Analysis")) {
                    if (ImGui::MenuItem("Scope")) addAtMouse("scope");
                    if (ImGui::MenuItem("Debug")) addAtMouse("debug");
                    if (ImGui::MenuItem("Input Debug")) addAtMouse("input_debug");
                    if (ImGui::MenuItem("Frequency Graph")) addAtMouse("frequency_graph");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("TTS")) {
                    if (ImGui::MenuItem("TTS Performer")) addAtMouse("tts_performer");
                    if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("vocal_tract_filter");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Special")) {
                    if (ImGui::MenuItem("Physics")) addAtMouse("physics");
                    if (ImGui::MenuItem("Animation")) addAtMouse("animation");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Computer Vision")) {
                    if (ImGui::MenuItem("Webcam Loader")) addAtMouse("webcam_loader");
                    if (ImGui::MenuItem("Video File Loader")) addAtMouse("video_file_loader");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Video FX")) addAtMouse("video_fx");
                    if (ImGui::MenuItem("Crop Video")) addAtMouse("crop_video");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Movement Detector")) addAtMouse("movement_detector");
                    if (ImGui::MenuItem("Object Detector")) addAtMouse("object_detector");
                    if (ImGui::MenuItem("Pose Estimator")) addAtMouse("pose_estimator");
                    if (ImGui::MenuItem("Hand Tracker")) addAtMouse("hand_tracker");
                    if (ImGui::MenuItem("Face Tracker")) addAtMouse("face_tracker");
                    if (ImGui::MenuItem("Color Tracker")) addAtMouse("color_tracker");
                    if (ImGui::MenuItem("Contour Detector")) addAtMouse("contour_detector");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Plugins / VST")) {
                    addPluginModules(); // Re-use your existing plugin menu logic
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("System")) {
                    // if (ImGui::MenuItem("Meta")) addAtMouse("meta");
                    // if (ImGui::MenuItem("Inlet")) addAtMouse("inlet");
                    // if (ImGui::MenuItem("Outlet")) addAtMouse("outlet");
                    if (ImGui::MenuItem("Comment")) addAtMouse("comment");
                    if (ImGui::MenuItem("Recorder")) addAtMouse("recorder");
                    ImGui::EndMenu();
                }
            }
            else
            {
                // --- SEARCH MODE (Text has been entered) ---
                struct MatchedModule {
                    juce::String displayName;
                    const char* internalType;
                    const char* description;
                };
                std::vector<MatchedModule> matches;

                auto registry = getModuleRegistry();
                std::unordered_set<juce::String> matchedInternals;

                auto addMatchByInternal = [&](const juce::String& internal)
                {
                    if (!matchedInternals.insert(internal).second)
                        return;
                    for (const auto& entry : registry)
                    {
                        if (juce::String(entry.second.first).equalsIgnoreCase(internal))
                        {
                            matches.push_back({entry.first, entry.second.first, entry.second.second});
                            break;
                        }
                    }
                };

                bool usingTokenFilter = false;
                juce::String tokenType;

                if (filter.startsWithChar(':'))
                {
                    juce::StringArray tokens;
                    tokens.addTokens(filter, ":", "");
                    tokens.removeEmptyStrings();

                    if (!tokens.isEmpty())
                    {
                        usingTokenFilter = true;
                        tokenType = tokens[0];

                        auto parsePinTypeToken = [](const juce::String& token, PinDataType& outType) -> bool
                        {
                            if (token.equalsIgnoreCase("audio")) { outType = PinDataType::Audio; return true; }
                            if (token.equalsIgnoreCase("cv") || token.equalsIgnoreCase("mod")) { outType = PinDataType::CV; return true; }
                            if (token.equalsIgnoreCase("gate") || token.equalsIgnoreCase("trigger")) { outType = PinDataType::Gate; return true; }
                            if (token.equalsIgnoreCase("raw")) { outType = PinDataType::Raw; return true; }
                            if (token.equalsIgnoreCase("video")) { outType = PinDataType::Video; return true; }
                            return false;
                        };

                        PinDataType parsedType = PinDataType::Raw;
                        const bool typeParsed = parsePinTypeToken(tokenType, parsedType);

                        for (int i = 1; i < tokens.size(); ++i)
                        {
                            juce::String internal = tokens[i].trim();
                            if (internal.isNotEmpty())
                                addMatchByInternal(internal);
                        }

                        if (matches.empty() && typeParsed)
                        {
                            auto appendFromMap = [&](const std::map<PinDataType, std::vector<juce::String>>& source)
                            {
                                if (auto it = source.find(parsedType); it != source.end())
                                {
                                    for (const auto& internal : it->second)
                                        addMatchByInternal(internal);
                                }
                            };
                            appendFromMap(dragInsertSuggestionsInputs);
                            appendFromMap(dragInsertSuggestionsOutputs);
                        }

                        if (matches.empty())
                        {
                            usingTokenFilter = false;
                        }
                        else
                        {
                            juce::String label = tokenType.isNotEmpty() ? tokenType : "signal";
                            ImGui::TextDisabled("Suggestions for %s", label.toRawUTF8());
                            ImGui::Separator();
                        }
                    }
                }

                if (!usingTokenFilter)
                {
                    for (const auto& entry : registry)
                    {
                        const juce::String& displayName = entry.first;
                        const char* internalType = entry.second.first;
                        const char* description = entry.second.second;

                        if (displayName.containsIgnoreCase(filter)
                            || juce::String(internalType).containsIgnoreCase(filter))
                        {
                            if (matchedInternals.insert(juce::String(internalType)).second)
                                matches.push_back({displayName, internalType, description});
                        }
                    }
                }

                if (ImGui::IsKeyPressed(ImGuiKey_DownArrow))
                {
                    selectedIndex++;
                    if (selectedIndex >= (int)matches.size())
                        selectedIndex = (int)matches.size() - 1;
                }
                if (ImGui::IsKeyPressed(ImGuiKey_UpArrow))
                {
                    selectedIndex--;
                    if (selectedIndex < 0)
                        selectedIndex = 0;
                }
                if (enterPressed && !matches.empty())
                {
                    if (selectedIndex >= 0 && selectedIndex < (int)matches.size())
                    {
                        addAtMouse(matches[selectedIndex].internalType);
                    }
                }

                for (int i = 0; i < (int)matches.size(); ++i)
                {
                    const auto& match = matches[i];
                    bool isSelected = (i == selectedIndex);

                    if (ImGui::Selectable(match.displayName.toRawUTF8(), isSelected))
                    {
                        addAtMouse(match.internalType);
                    }

                    if (isSelected && !ImGui::IsItemVisible())
                        ImGui::SetScrollHereY(0.5f);

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::TextUnformatted(match.description);
                        ImGui::EndTooltip();
                    }
                }

                if (selectedIndex >= (int)matches.size())
                    selectedIndex = (int)matches.size() - 1;
                if (selectedIndex < 0 && !matches.empty())
                    selectedIndex = 0;
            }

            ImGui::EndChild();
            ImGui::EndPopup();
        }

        // Helper functions are now class methods

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinId(startAttr);
            auto endPin = decodePinId(endAttr);
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // Ensure connection is always Output -> Input
            if (!srcPin.isInput && dstPin.isInput)
            {
                PinDataType srcType = getPinDataTypeForPin(srcPin);
                
                // CRITICAL: Update reroute node type BEFORE checking compatibility
                // This ensures reroute nodes adopt the source type before type checks
                if (dstPin.logicalId != 0 && getTypeForLogical(dstPin.logicalId).equalsIgnoreCase("reroute"))
                {
                    if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(dstPin.logicalId)))
                    {
                        reroute->setPassthroughType(srcType);
                    }
                }
                
                // Re-query dstType after potential reroute update
                PinDataType dstType = getPinDataTypeForPin(dstPin);

                bool conversionHandled = false;

                // Determine if a converter is needed based on pin types
                if (srcType == PinDataType::Audio && dstType == PinDataType::CV)
                {
                    insertNodeBetween("attenuverter", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::CV && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Audio && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Raw && dstType != PinDataType::Raw)
                {
                    insertNodeBetween("map_range", srcPin, dstPin);
                    conversionHandled = true;
                }

                if (conversionHandled)
                {
                    pushSnapshot();
                }
                else
                {
                    // All other combinations are considered directly compatible.
                    if (!dstPin.isMod && dstPin.isInput && dstPin.logicalId != 0)
                    {
                        if (getTypeForLogical(dstPin.logicalId).equalsIgnoreCase("reroute"))
                            updateRerouteTypeFromConnections(dstPin.logicalId);
                    }

                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    // Immediate commit for RecordModuleProcessor filename update
                    synth->commitChanges();

                    if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId)) {
                        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule)) {
                            juce::String sourceName;
                            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId)) {
                                sourceName = srcModule->getName();
                            }
                            recorder->updateSuggestedFilename(sourceName);
                        }
                    }

                    auto updateRerouteForPin = [&](const PinID& pin)
                    {
                        if (pin.logicalId != 0 && getTypeForLogical(pin.logicalId).equalsIgnoreCase("reroute"))
                            updateRerouteTypeFromConnections(pin.logicalId);
                    };
                    updateRerouteForPin(srcPin);
                    updateRerouteForPin(dstPin);

                    pushSnapshot();
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                // Debug log disconnect intent
                juce::Logger::writeToLog(
                    juce::String("[LinkDelete] src(lid=") + juce::String((int)srcPin.logicalId) + ",ch=" + juce::String(srcPin.channel) +
                    ") -> dst(lid=" + juce::String((int)dstPin.logicalId) + ",ch=" + juce::String(dstPin.channel) + ")");

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                
                // Immediate commit for RecordModuleProcessor filename update
                synth->commitChanges();
                
                auto updateRerouteForPin = [&](const PinID& pin)
                {
                    if (pin.logicalId != 0 && getTypeForLogical(pin.logicalId).equalsIgnoreCase("reroute"))
                        updateRerouteTypeFromConnections(pin.logicalId);
                };
                updateRerouteForPin(srcPin);
                updateRerouteForPin(dstPin);
                
                // After disconnecting, tell the recorder to update (pass empty string for unconnected)
                if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule))
                    {
                        recorder->updateSuggestedFilename(""); // Empty = unconnected
                    }
                }
                
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)
        // Keyboard shortcuts
        // Only process global keyboard shortcuts if no ImGui widget wants the keyboard
        if (!ImGui::GetIO().WantCaptureKeyboard)
        {
            if (consumeShortcutFlag(shortcutFileSaveAsRequested))
            {
                startSaveDialog();
            }
            if (consumeShortcutFlag(shortcutFileSaveRequested))
            {
                if (currentPresetFile.existsAsFile())
                    savePresetToFile(currentPresetFile);
                else
                    startSaveDialog();
            }
            if (consumeShortcutFlag(shortcutFileOpenRequested))
            {
                startLoadDialog();
            }
            if (consumeShortcutFlag(shortcutRandomizePatchRequested))
            {
                handleRandomizePatch();
            }
            if (consumeShortcutFlag(shortcutRandomizeConnectionsRequested))
            {
                handleRandomizeConnections();
            }
            if (consumeShortcutFlag(shortcutBeautifyLayoutRequested))
            {
                handleBeautifyLayout();
            }
        
            if (consumeShortcutFlag(shortcutMuteSelectionRequested) && ImNodes::NumSelectedNodes() > 0)
            {
                handleMuteToggle();
            }

            if (consumeShortcutFlag(shortcutSelectAllRequested))
            {
                if (synth != nullptr)
                {
                    const auto& modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0);
                    for (const auto& mod : modules)
                        allNodeIds.push_back((int)mod.first);

                    ImNodes::ClearNodeSelection();
                    for (int id : allNodeIds)
                        ImNodes::SelectNode(id);
                }
            }

            if (consumeShortcutFlag(shortcutChainSequentialRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleNodeChaining();
            }

            if (consumeShortcutFlag(shortcutChainAudioRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Audio);
            }

            if (consumeShortcutFlag(shortcutChainCvRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::CV);
            }

            if (consumeShortcutFlag(shortcutChainGateRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Gate);
            }

            if (consumeShortcutFlag(shortcutChainRawRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Raw);
            }

            if (consumeShortcutFlag(shortcutChainVideoRequested) && ImNodes::NumSelectedNodes() > 1)
            {
                handleColorCodedChaining(PinDataType::Video);
            }
        
            if (consumeShortcutFlag(shortcutCtrlRRequested))
            {
                const int numSelected = ImNodes::NumSelectedNodes();
                if (numSelected > 0 && synth != nullptr)
                {
                    pushSnapshot();

                    std::vector<int> selectedNodeIds(numSelected);
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());

                    for (int lid : selectedNodeIds)
                    {
                        if (auto* module = synth->getModuleForLogical((juce::uint32)lid))
                        {
                            auto& params = module->getParameters();
                            for (auto* paramBase : params)
                            {
                                if (auto* param = dynamic_cast<juce::RangedAudioParameter*>(paramBase))
                                    param->setValueNotifyingHost(param->getDefaultValue());
                            }
                            juce::Logger::writeToLog("[Reset] Reset parameters for node " + juce::String(lid));
                        }
                    }
                }
                else
                {
                    handleRecordOutput();
                }
            }
            if (consumeShortcutFlag(shortcutConnectOutputRequested) && ImNodes::NumSelectedNodes() == 1)
            {
                if (synth != nullptr)
                {
                    int selectedId = 0;
                    ImNodes::GetSelectedNodes(&selectedId);
                    if (selectedId != 0)
                    {
                        synth->connect(synth->getNodeIdForLogical(selectedId), 0, synth->getOutputNodeID(), 0);
                        synth->connect(synth->getNodeIdForLogical(selectedId), 1, synth->getOutputNodeID(), 1);
                        graphNeedsRebuild = true;
                        pushSnapshot();
                    }
                }
            }

            if (consumeShortcutFlag(shortcutDisconnectRequested) && ImNodes::NumSelectedNodes() > 0)
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    for (int id : selectedNodeIds)
                        synth->clearConnectionsForNode(synth->getNodeIdForLogical(id));

                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
            }
            auto frameNodes = [&](const std::vector<int>& nodeIds)
            {
                if (nodeIds.empty() || synth == nullptr)
                    return;

                juce::Rectangle<float> bounds;
                bool foundAny = false;

                std::unordered_set<int> validNodes;
                validNodes.insert(0);
                for (const auto& mod : synth->getModulesInfo())
                    validNodes.insert((int)mod.first);

                for (int nodeId : nodeIds)
                {
                    if (validNodes.find(nodeId) != validNodes.end())
                    {
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
                        if (!foundAny)
                        {
                            bounds = juce::Rectangle<float>(pos.x, pos.y, 1, 1);
                            foundAny = true;
                        }
                        else
                        {
                            bounds = bounds.getUnion(juce::Rectangle<float>(pos.x, pos.y, 1, 1));
                        }
                    }
                }

                if (!foundAny)
                    return;

                if (!nodeIds.empty() && validNodes.find(nodeIds[0]) != validNodes.end())
                    bounds = bounds.expanded(ImNodes::GetNodeDimensions(nodeIds[0]).x, ImNodes::GetNodeDimensions(nodeIds[0]).y);

                ImVec2 center((bounds.getX() + bounds.getRight()) * 0.5f,
                              (bounds.getY() + bounds.getBottom()) * 0.5f);
                ImNodes::EditorContextResetPanning(center);
            };

            if (consumeShortcutFlag(shortcutFrameSelectionRequested))
            {
                const int numSelected = ImNodes::NumSelectedNodes();
                if (numSelected > 0)
                {
                    std::vector<int> selectedNodeIds(numSelected);
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    frameNodes(selectedNodeIds);
                }
            }

            if (consumeShortcutFlag(shortcutFrameAllRequested))
            {
                if (synth != nullptr)
                {
                    auto modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0);
                    for (const auto& mod : modules)
                        allNodeIds.push_back((int)mod.first);
                    frameNodes(allNodeIds);
                }
            }

            if (consumeShortcutFlag(shortcutResetOriginRequested))
            {
                ImNodes::EditorContextResetPanning(ImVec2(0, 0));
            }

            if (consumeShortcutFlag(shortcutToggleDebugRequested))
            {
                showDebugMenu = !showDebugMenu;
            }

            if (consumeShortcutFlag(shortcutUndoRequested))
            {
                if (undoStack.size() > 1)
                {
                    Snapshot current = undoStack.back();
                    redoStack.push_back(current);
                    undoStack.pop_back();
                    restoreSnapshot(undoStack.back());
                    linkIdToAttrs.clear();
                    NotificationManager::post(NotificationManager::Type::Info, "Undo");
                }
            }

            if (consumeShortcutFlag(shortcutRedoRequested))
            {
                if (!redoStack.empty())
                {
                    Snapshot s = redoStack.back();
                    redoStack.pop_back();
                    restoreSnapshot(s);
                    undoStack.push_back(s);
                    linkIdToAttrs.clear();
                    NotificationManager::post(NotificationManager::Type::Info, "Redo");
                }
            }

            const bool duplicateRequested = consumeShortcutFlag(shortcutDuplicateRequested);
            const bool duplicateWithRoutingRequested = consumeShortcutFlag(shortcutDuplicateWithRoutingRequested);
            if (duplicateRequested || duplicateWithRoutingRequested)
            {
                const bool copyConnections = duplicateWithRoutingRequested;
                const int n = ImNodes::NumSelectedNodes();
                if (n > 0)
                {
                    std::vector<int> sel((size_t)n);
                    ImNodes::GetSelectedNodes(sel.data());
                    for (int oldId : sel)
                    {
                        if (oldId == 0)
                            continue;

                        const juce::String type = getTypeForLogical((juce::uint32)oldId);
                        if (type.isEmpty())
                            continue;

                        auto newNodeId = synth->addModule(type);
                        graphNeedsRebuild = true;
                        const juce::uint32 newLogical = synth->getLogicalIdForNode(newNodeId);
                        if (newLogical != 0)
                        {
                            if (auto* src = synth->getModuleForLogical((juce::uint32)oldId))
                                if (auto* dst = synth->getModuleForLogical(newLogical))
                                    dst->getAPVTS().replaceState(src->getAPVTS().copyState());

                            ImVec2 pos = ImNodes::GetNodeGridSpacePos(oldId);
                            pendingNodePositions[(int)newLogical] = ImVec2(pos.x + 40.0f, pos.y + 40.0f);

                            if (copyConnections)
                            {
                                const auto oldNode = synth->getNodeIdForLogical((juce::uint32)oldId);
                                const auto newNode = newNodeId;
                                for (const auto& c : synth->getConnectionsInfo())
                                {
                                    if ((int)c.srcLogicalId == oldId)
                                    {
                                        auto dstNode = (c.dstLogicalId == 0)
                                                            ? synth->getOutputNodeID()
                                                            : synth->getNodeIdForLogical(c.dstLogicalId);
                                        synth->connect(newNode, c.srcChan, dstNode, c.dstChan);
                                    }
                                    if ((int)c.dstLogicalId == oldId)
                                    {
                                        auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                                        synth->connect(srcNode, c.srcChan, newNode, c.dstChan);
                                    }
                                }
                                // TODO: Implement modulation route duplication for new bus-based system
                            }
                        }
                    }

                    pushSnapshot();
                    NotificationManager::post(NotificationManager::Type::Info, "Duplicated " + juce::String(n) + " node(s)");
                }
            }
        
        } // End of keyboard shortcuts (WantCaptureKeyboard check)

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }
    // === MIDI DEVICE MANAGER WINDOW ===
    if (showMidiDeviceManager)
    {
        if (ImGui::Begin("MIDI Device Manager", &showMidiDeviceManager, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ThemeText("MIDI Input Devices", theme.text.section_header);
            ImGui::Separator();
            
            // Access MidiDeviceManager from PresetCreatorComponent
            auto* presetCreator = dynamic_cast<PresetCreatorComponent*>(getParentComponent());
            if (presetCreator && presetCreator->midiDeviceManager)
            {
                auto& midiMgr = *presetCreator->midiDeviceManager;
                const auto& devices = midiMgr.getDevices();
                
                if (devices.empty())
                {
                    ImGui::TextDisabled("No MIDI devices found");
                }
                else
                {
                    ImGui::Text("Found %d device(s):", (int)devices.size());
                    ImGui::Spacing();
                    
                    // Display each device
                    for (const auto& device : devices)
                    {
                        ImGui::PushID(device.identifier.toRawUTF8());
                        
                        // Checkbox to enable/disable device
                        bool enabled = device.enabled;
                        if (ImGui::Checkbox("##enabled", &enabled))
                        {
                            if (enabled)
                                midiMgr.enableDevice(device.identifier);
                            else
                                midiMgr.disableDevice(device.identifier);
                        }
                        
                        ImGui::SameLine();
                        
                        // Device name
                        ImGui::Text("%s", device.name.toRawUTF8());
                        
                        // Activity indicator
                        auto activity = midiMgr.getDeviceActivity(device.identifier);
                        if (activity.lastMessageTime > 0)
                        {
                            ImGui::SameLine();
                            float timeSinceMessage = (juce::Time::getMillisecondCounter() - activity.lastMessageTime) / 1000.0f;
                            if (timeSinceMessage < 1.0f)
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.active);
                                ImGui::Text("ACTIVE");
                                ImGui::PopStyleColor();
                            }
                            else
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, theme.text.disabled);
                                ImGui::Text("idle");
                                ImGui::PopStyleColor();
                            }
                        }
                        
                        ImGui::PopID();
                    }
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                // Rescan button
                if (ImGui::Button("Rescan Devices"))
                {
                    midiMgr.scanDevices();
                }
                
                ImGui::SameLine();
                
                // Enable/Disable all buttons
                if (ImGui::Button("Enable All"))
                {
                    midiMgr.enableAllDevices();
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Disable All"))
                {
                    midiMgr.disableAllDevices();
                }
            }
            else
            {
                ImGui::TextDisabled("MIDI Manager not available");
            }
        }
        ImGui::End();
    }

    // === DEBUG WINDOW ===
    if (showDebugMenu)
    {
        if (ImGui::Begin("System Diagnostics", &showDebugMenu))
        {
            if (synth != nullptr)
            {
                ImGui::Text("=== SYSTEM OVERVIEW ===");
                if (ImGui::Button("Refresh"))
                {
                    // Force refresh of diagnostics
                }
                
                
                // System diagnostics
                ImGui::Text("System State:");
                juce::String systemDiag = synth->getSystemDiagnostics();
                ImGui::TextWrapped("%s", systemDiag.toUTF8());
                
                
                // Module selector
                ImGui::Text("Module Diagnostics:");
                auto modules = synth->getModulesInfo();
                if (!modules.empty())
                {
                    static int selectedModuleIndex = 0;
                    if (selectedModuleIndex >= (int)modules.size()) selectedModuleIndex = 0;
                    
                    juce::String moduleList = "";
                    for (size_t i = 0; i < modules.size(); ++i)
                    {
                        if (i > 0) moduleList += "\0";
                        moduleList += "Logical " + juce::String((int)modules[i].first) + ": " + modules[i].second;
                    }
                    moduleList += "\0";
                    
                    if (ImGui::Combo("Select Module", &selectedModuleIndex, moduleList.toUTF8()))
                    {
                        if (selectedModuleIndex < (int)modules.size())
                        {
                            juce::String moduleDiag = synth->getModuleDiagnostics(modules[selectedModuleIndex].first);
                            ImGui::TextWrapped("%s", moduleDiag.toUTF8());
                        }
                    }
                }
                else
                {
                    ImGui::Text("No modules found.");
                }
            }
            else
            {
                ImGui::Text("No synth processor available.");
            }
        }
        ImGui::End();
    }

    ImGui::End();
    
    // === POP THE TRANSPARENT BACKGROUND STYLE ===
    ImGui::PopStyleColor();
    // === END OF FIX ===

    // Render notification system (must be called at the end to appear on top)
    NotificationManager::render();
    // --- Phase 5: Periodic Stale History Cleanup ---
    static double lastCleanupTime = 0.0;
    const double currentTimeSec = juce::Time::getMillisecondCounterHiRes() / 1000.0;
    if (currentTimeSec - lastCleanupTime > 10.0) // Run every 10 seconds
    {
        lastCleanupTime = currentTimeSec;
        // Set cutoff for "stale" entries (2x the max window size = 40 seconds)
        const double staleCutoffTime = currentTimeSec - (20.0 * 2.0);
        
        for (auto it = inspectorHistory.begin(); it != inspectorHistory.end(); /* no increment */)
        {
            if (it->second.lastAccessTime < staleCutoffTime)
            {
                it = inspectorHistory.erase(it); // Erase stale entry
            }
            else
            {
                ++it;
            }
        }
    }

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::rebuildFontAtlas()
{
    ImGuiIO& io = ImGui::GetIO();
    ThemeManager::getInstance().applyFonts(io);
    ImGui_ImplOpenGL2_DestroyDeviceObjects();
    ImGui_ImplOpenGL2_CreateDeviceObjects();
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        // Temporarily mask rebuild flag to avoid ImNodes queries during capture
        const bool rebuilding = graphNeedsRebuild.load();
        if (rebuilding) {
            // getUiValueTree will still avoid ImNodes now, but assert safety
        }
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        // Do not commit pending positions of (0,0) which are placeholders
        for (int i = 0; i < applied.getNumChildren(); ++i)
        {
            auto n = applied.getChild(i);
            if (! n.hasType("node")) continue;
            const float x = (float) n.getProperty("x", 0.0f);
            const float y = (float) n.getProperty("y", 0.0f);
            if (x == 0.0f && y == 0.0f) {
                // Try to recover from last-known or pending
                const int nid = (int) n.getProperty("id", -1);
                auto itL = lastKnownNodePositions.find(nid);
                if (itL != lastKnownNodePositions.end()) { n.setProperty("x", itL->second.x, nullptr); n.setProperty("y", itL->second.y, nullptr); }
                else if (auto itP = pendingNodePositions.find(nid); itP != pendingNodePositions.end()) { n.setProperty("x", itP->second.x, nullptr); n.setProperty("y", itP->second.y, nullptr); }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        isPatchDirty = true; // Mark patch as dirty
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
    
    // Mark patch as dirty whenever a change is made
    isPatchDirty = true;
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed


juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        
        // Prefer cached position if available; never query ImNodes while rebuilding
        ImVec2 pos;
        if (lastKnownNodePositions.count(nid) > 0)
        {
            pos = lastKnownNodePositions.at(nid);
        }
        else if (auto it = pendingNodePositions.find(nid); it != pendingNodePositions.end())
        {
            pos = it->second;
        }
        else if (!graphNeedsRebuild.load() && hasRenderedAtLeastOnce)
        {
            pos = ImNodes::GetNodeGridSpacePos(nid);
        }
        else
        {
            pos = ImVec2(0.0f, 0.0f);
        }
        
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        
        // --- FIX: Save muted/bypassed state ---
        // If this node's ID is in our map of muted nodes, add the property to the XML
        if (mutedNodeStates.count(nid) > 0)
        {
            n.setProperty("muted", true, nullptr);
        }
        
        ui.addChild (n, -1, nullptr);
    }
    
    // --- FIX: Explicitly save the output node position (ID 0) ---
    // The main output node is not part of getModulesInfo(), so we need to save it separately
    
    // Prefer cached output position; avoid ImNodes when rebuilding
    ImVec2 outputPos;
    if (lastKnownNodePositions.count(0) > 0)
    {
        outputPos = lastKnownNodePositions.at(0);
    }
    else if (auto it0 = pendingNodePositions.find(0); it0 != pendingNodePositions.end())
    {
        outputPos = it0->second;
    }
    else if (!graphNeedsRebuild.load() && hasRenderedAtLeastOnce)
    {
        outputPos = ImNodes::GetNodeGridSpacePos(0);
    }
    else
    {
        outputPos = ImVec2(0.0f, 0.0f);
    }
    
    juce::ValueTree outputNode("node");
    outputNode.setProperty("id", 0, nullptr);
    outputNode.setProperty("x", outputPos.x, nullptr);
    outputNode.setProperty("y", outputPos.y, nullptr);
    ui.addChild(outputNode, -1, nullptr);
    // --- END OF FIX ---
    
    return ui;
}
void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid() || synth == nullptr) return;
    
    juce::Logger::writeToLog("[UI_RESTORE] Applying UI ValueTree now...");

    // This is the core of the crash: the synth graph has already been rebuilt by setStateInformation.
    // We must clear our stale UI data (like muted nodes) before applying the new state from the preset.
    mutedNodeStates.clear();
    
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);

        // ========================= THE FIX STARTS HERE =========================
        //
        // Before applying any property, VERIFY that this node ID actually exists
        // in the synth. This prevents crashes when loading presets that contain
        // modules which are not available in the current build.
        //
        bool nodeExistsInSynth = (nid == 0); // Node 0 is always the output node.
        if (!nodeExistsInSynth) {
            for (const auto& modInfo : synth->getModulesInfo()) {
                if ((int)modInfo.first == nid) {
                    nodeExistsInSynth = true;
                    break;
                }
            }
        }

        if (!nodeExistsInSynth)
        {
            juce::Logger::writeToLog("[UI_RESTORE] WARNING: Skipping UI properties for non-existent node ID " + juce::String(nid) + ". The module may be missing or failed to load.");
            continue; // Skip to the next node in the preset.
        }
        // ========================== END OF FIX ==========================

        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        if (!(x == 0.0f && y == 0.0f))
        {
            pendingNodePositions[nid] = ImVec2(x, y);
            juce::Logger::writeToLog("[UI_RESTORE] Queued position for node " + juce::String(nid) + ": (" + juce::String(x) + ", " + juce::String(y) + ")");
        }
        
        // Read and apply muted state from preset for existing nodes.
        if ((bool) n.getProperty("muted", false))
        {
            // Use muteNodeSilent to store the original connections first,
            // then apply the mute (which creates bypass connections)
            muteNodeSilent(nid);
            muteNode(nid);
        }
    }
    
    // Set default positions for output node and BPM monitor node if they weren't loaded from preset
    // Output node (ID 0): right of center
    auto outputIt = pendingNodePositions.find(0);
    if (outputIt == pendingNodePositions.end())
    {
        // Position output node on right side but closer to center for better first-time UX
        pendingNodePositions[0] = ImVec2(1200.0f, 500.0f);
        juce::Logger::writeToLog("[UI_RESTORE] Set default position for output node: (1200.0, 500.0)");
    }
    
    // BPM Monitor node (ID 999): left of center
    auto bpmMonitorIt = pendingNodePositions.find(999);
    if (bpmMonitorIt == pendingNodePositions.end())
    {
        // Position BPM monitor node on left side, higher up to match screenshot layout
        pendingNodePositions[999] = ImVec2(450.0f, 300.0f);
        juce::Logger::writeToLog("[UI_RESTORE] Set default position for BPM monitor node: (450.0, 300.0)");
    }
    
    // Muting/unmuting modifies graph connections, so we must tell the
    // synth to rebuild its processing order.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[UI_RESTORE] UI state applied. Flagging for graph rebuild.");
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    const bool bypassRequested = consumeShortcutFlag(shortcutBypassDeleteRequested);
    const bool deleteRequested = consumeShortcutFlag(shortcutDeleteRequested);

    if (!bypassRequested && !deleteRequested)
        return;

    if (bypassRequested)
    {
        bypassDeleteSelectedNodes();
        return;
    }

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            // TODO: Handle modulation link deletion for new bus-based system
            // if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
            // {
            //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
            //     // TODO: Handle modulation route removal
            //     // if (paramId.isNotEmpty())
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL, paramId);
            //     // else
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            // }
            // else 
            if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            
            // Clean up vision module textures if exists
            if (visionModuleTextures.count(nid))
            {
                visionModuleTextures.erase(nid);
            }
            
            // Clean up sample loader textures if exists
            if (sampleLoaderTextureIds.count(nid))
            {
                sampleLoaderTextureIds.erase(nid);
            }
            
            mutedNodeStates.erase((juce::uint32)nid); // Clean up muted state if exists
            lastKnownNodePositions.erase(nid); // Clean up position cache
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}
void ImGuiNodeEditorComponent::bypassDeleteSelectedNodes()
{
    const int numSelNodes = ImNodes::NumSelectedNodes();
    if (numSelNodes <= 0 || synth == nullptr)
        return;

    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    std::vector<int> nodeIds((size_t) numSelNodes);
    ImNodes::GetSelectedNodes(nodeIds.data());

    for (int nid : nodeIds)
    {
        if (nid == 0)
            continue;

        bypassDeleteNode((juce::uint32) nid);
    }

    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}

void ImGuiNodeEditorComponent::bypassDeleteNode(juce::uint32 logicalId)
{
    // Collect all incoming/outgoing audio links for this node
    std::vector<decltype(synth->getConnectionsInfo())::value_type> inputs, outputs;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) inputs.push_back(c);
        if (c.srcLogicalId == logicalId) outputs.push_back(c);
    }

    // For each output channel, find matching input channel to splice
    for (const auto& out : outputs)
    {
        // Try to find input with same channel index, else fallback to first input
        const auto* inPtr = (const decltype(inputs)::value_type*) nullptr;
        for (const auto& in : inputs) { if (in.dstChan == out.srcChan) { inPtr = &in; break; } }
        if (inPtr == nullptr && !inputs.empty()) inPtr = &inputs.front();

        // Disconnect out link first
        auto srcNode = synth->getNodeIdForLogical(out.srcLogicalId);
        auto dstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
        synth->disconnect(srcNode, out.srcChan, dstNode, out.dstChan);

        if (inPtr != nullptr)
        {
            // Disconnect incoming link from the node
            auto inSrcNode = synth->getNodeIdForLogical(inPtr->srcLogicalId);
            auto inDstNode = synth->getNodeIdForLogical(inPtr->dstLogicalId);
            synth->disconnect(inSrcNode, inPtr->srcChan, inDstNode, inPtr->dstChan);

            // Connect source of incoming directly to destination of outgoing
            auto finalDstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
            synth->connect(inSrcNode, inPtr->srcChan, finalDstNode, out.dstChan);
        }
    }

    // TODO: Remove modulation routes targeting or originating this node using new bus-based system

    // Finally remove the node itself
    mutedNodeStates.erase(logicalId); // Clean up muted state if exists
    synth->removeModule(synth->getNodeIdForLogical(logicalId));
}

// === Non-Destructive Mute/Bypass Implementation ===

void ImGuiNodeEditorComponent::muteNodeSilent(juce::uint32 logicalId)
{
    // This function is used when loading presets. It records the connections that were
    // loaded from the XML without modifying the graph or creating bypass connections.
    // This preserves the original "unmuted" connections for later use.
    
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // Store all connections attached to this node
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // Store the state, but DON'T modify the graph or create bypass connections
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[MuteSilent] Node " + juce::String(logicalId) + 
                            " marked as muted, stored " + juce::String(state.incomingConnections.size()) + 
                            " incoming and " + juce::String(state.outgoingConnections.size()) + 
                            " outgoing connections.");
}
void ImGuiNodeEditorComponent::muteNode(juce::uint32 logicalId)
{
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // 1. Find and store all connections attached to this node.
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // 2. Disconnect all of them.
    for (const auto& c : state.incomingConnections) {
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }
    
    // --- FIX: More robust bypass splicing logic ---
    // 3. Splice the connections to bypass the node.
    // Connect the FIRST input source to ALL output destinations.
    // This correctly handles cases where input channel != output channel (e.g., Mixer input 3 → output 0).
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Connect the primary input's source directly to the original output's destination
            synth->connect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Mute] Splicing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 4. Store the original state.
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " muted and bypassed.");
}

void ImGuiNodeEditorComponent::unmuteNode(juce::uint32 logicalId)
{
    if (!synth || mutedNodeStates.find(logicalId) == mutedNodeStates.end()) return;

    MutedNodeState state = mutedNodeStates[logicalId];

    // --- FIX: Remove bypass connections matching the new mute logic ---
    // 1. Find and remove the bypass connections.
    // The bypass connected the first input source to all output destinations.
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Disconnect the bypass connection
            synth->disconnect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Unmute] Removing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 2. Restore the original connections.
    for (const auto& c : state.incomingConnections) {
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }

    // 3. Remove from muted state.
    mutedNodeStates.erase(logicalId);
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " unmuted.");
}
void ImGuiNodeEditorComponent::handleMuteToggle()
{
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected == 0) return;

    pushSnapshot(); // Create a single undo state for the whole operation.

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    for (int lid : selectedNodeIds) {
        if (mutedNodeStates.count(lid)) {
            unmuteNode(lid);
        } else {
            muteNode(lid);
        }
    }

    graphNeedsRebuild = true;
}
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    bool wasAlreadyInProgress = isSaveInProgress.exchange(true); // Atomically check and set
    if (wasAlreadyInProgress)
    {
        juce::Logger::writeToLog("[SaveWorkflow] Save action ignored (already in progress). Current flag state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Flag set to TRUE. Starting save workflow for: " + file.getFullPathName());

    if (synth == nullptr) {
        juce::Logger::writeToLog("[SaveWorkflow] ERROR: Synth is null! Resetting flag and aborting.");
        NotificationManager::post(NotificationManager::Type::Error, "ERROR: Synth not ready!");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after synth null check.");
        return;
    }

    juce::Logger::writeToLog("--- [Save Workflow] Initiated for: " + file.getFullPathName() + " ---");
    
    // Post status notification (long duration since it will be replaced by Success/Error when complete)
    NotificationManager::post(NotificationManager::Type::Status, "Saving: " + file.getFileNameWithoutExtension(), 1000.0f);
    
    // --- All fast operations now happen on the UI thread BEFORE the job is launched ---
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Capturing state...");
    auto mutedNodeIDs = getMutedNodeIds();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Found " + juce::String((int)mutedNodeIDs.size()) + " muted nodes.");

    // Temporarily unmute to get correct connections
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Temporarily unmuting nodes for state capture...");
    for (auto lid : mutedNodeIDs) unmuteNode(lid);
    synth->commitChanges();

    // Capture state while unmuted
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling synth->getStateInformation()...");
    juce::MemoryBlock synthState;
    try {
        synth->getStateInformation(synthState);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Synth state captured (" + juce::String(synthState.getSize()) + " bytes).");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION in getStateInformation: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION in getStateInformation");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    }
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling editor->getUiValueTree()...");
    juce::ValueTree uiState = getUiValueTree();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UI state captured (valid: " + juce::String(uiState.isValid() ? 1 : 0) + ").");

    // Immediately re-mute to restore visual state
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Re-muting nodes to restore visual state...");
    for (auto lid : mutedNodeIDs) muteNode(lid);
    synth->commitChanges();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] State captured. Offloading to background thread.");

    // Launch the background job with the captured data
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Creating SavePresetJob...");
    auto* job = new SavePresetJob(synthState, uiState, file);

    job->onSaveComplete = [this, filePath = file.getFullPathName()](const juce::File& savedFile, bool success) {
        juce::Logger::writeToLog("[SaveWorkflow] onSaveComplete callback called (success: " + juce::String(success ? 1 : 0) + ") for: " + savedFile.getFullPathName());
        
        if (success) {
            NotificationManager::post(NotificationManager::Type::Success, "Saved: " + savedFile.getFileNameWithoutExtension());
            isPatchDirty = false;
            currentPresetFile = savedFile;
            juce::Logger::writeToLog("[SaveWorkflow] Save completed successfully. Flag will be reset.");
        } else {
            juce::Logger::writeToLog("[SaveWorkflow] Save FAILED. Flag will be reset.");
            NotificationManager::post(NotificationManager::Type::Error, "Failed to save preset!");
        }
        
        juce::Logger::writeToLog("[SaveWorkflow] Resetting isSaveInProgress flag to FALSE.");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset complete. Current state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    };

    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Adding job to thread pool...");
    try {
        threadPool.addJob(job, true);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Job added to thread pool successfully.");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION adding job to thread pool: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION adding job to thread pool");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    }
}
void ImGuiNodeEditorComponent::startSaveDialog()
{
    juce::Logger::writeToLog("[SaveWorkflow] startSaveDialog() called. isSaveInProgress: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    
    // Check if a save is already in progress to avoid opening multiple dialogs
    if (isSaveInProgress.load()) {
        juce::Logger::writeToLog("[SaveWorkflow] 'Save As' action ignored (a save is already in progress).");
        NotificationManager::post(NotificationManager::Type::Warning, "A save operation is already in progress. Please wait...", 3.0f);
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Opening file chooser dialog...");
    auto presetsDir = findPresetsDirectory();
    juce::Logger::writeToLog("[SaveWorkflow] Presets directory: " + presetsDir.getFullPathName());
    
    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      presetsDir, 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        juce::Logger::writeToLog("[SaveWorkflow] File chooser callback invoked.");
        auto fileToSave = fc.getResult();
        
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            juce::Logger::writeToLog("[SaveWorkflow] User selected file: " + fileToSave.getFullPathName());
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
        else
        {
            juce::Logger::writeToLog("[SaveWorkflow] User cancelled file chooser dialog.");
        }
    });
    juce::Logger::writeToLog("[SaveWorkflow] File chooser launched (async).");
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::getMutedNodeIds() const
{
    std::vector<juce::uint32> ids;
    // MutedNodeState is a map, so we don't need a lock if we're just reading keys
    for (const auto& pair : mutedNodeStates)
    {
        ids.push_back(pair.first);
    }
    return ids;
}


void ImGuiNodeEditorComponent::startLoadDialog()
{
    NotificationManager::post(NotificationManager::Type::Info, "Opening Load Preset dialog...", 3.0f);
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", findPresetsDirectory(), "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (!file.existsAsFile()) return;
        NotificationManager::post(NotificationManager::Type::Info, "Loading: " + file.getFileName(), 5.0f);

        auto xml = juce::XmlDocument::parse(file);
        if (!xml)
        {
            NotificationManager::post(NotificationManager::Type::Error, "Preset failed to load: Not a valid XML file.");
            return;
        }
        juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);

        // === STAGE 1 & 2: HEAL THE PRESET (RULE-BASED) ===
        PresetAutoHealer healer;
        auto healingMessages = healer.heal(presetVT);

        // === STAGE 3: VALIDATE THE (NOW HEALED) PRESET ===
        PresetValidator validator;
        auto issues = validator.validate(presetVT);
        int errorCount = 0;
        int warningCount = 0;
        for (const auto& issue : issues)
        {
            if (issue.severity == PresetValidator::Issue::Error) errorCount++; else warningCount++;
        }

        // Report errors/warnings but proceed to load to match built-in loader behavior
        if (errorCount > 0)
        {
            juce::String summary = "Validation found " + juce::String(errorCount) + " error(s). Attempting load anyway.";
            if (!healingMessages.empty()) summary += " (" + juce::String((int)healingMessages.size()) + " issue(s) auto-healed).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 12.0f);
            for (const auto& issue : issues)
            {
                if (issue.severity == PresetValidator::Issue::Error)
                    NotificationManager::post(NotificationManager::Type::Warning, issue.message, 12.0f);
            }
        }

        // === STAGE 4: LOAD THE HEALED DATA ===
        juce::MemoryBlock mb;
        juce::MemoryOutputStream mos(mb, false);
        if (auto healedXml = presetVT.createXml()) healedXml->writeTo(mos);
        synth->setStateInformation(mb.getData(), (int)mb.getSize());
        auto uiState = presetVT.getChildWithName("NodeEditorUI");
        if (uiState.isValid()) applyUiValueTree(uiState);
        isPatchDirty = false;
        currentPresetFile = file;
        pushSnapshot();

        // === STAGE 5: NOTIFY ===
        if (!healingMessages.empty() || warningCount > 0 || errorCount > 0)
        {
            juce::String summary = "Loaded with " + juce::String(warningCount + errorCount) + " issue(s).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 8.0f);
            for (const auto& msg : healingMessages)
                NotificationManager::post(NotificationManager::Type::Info, msg, 8.0f);
            for (const auto& issue : issues)
                NotificationManager::post(
                    issue.severity == PresetValidator::Issue::Warning ? NotificationManager::Type::Warning
                                                                       : NotificationManager::Type::Warning,
                    issue.message, 8.0f);
        }
        else
        {
            NotificationManager::post(NotificationManager::Type::Success, "Loaded: " + file.getFileNameWithoutExtension());
        }
    });
}
void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "vco", "noise", "sequencer", "vcf", "delay", "reverb", "waveshaper",
        "lfo", "adsr", "random", "s_and_h", "math", "map_range", "quantizer", "clock_divider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    addedModules.push_back({mixerId, "mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));
    addedModules.push_back({scopeId, "scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "mixer") finalMixerId = mod.first;
        if (mod.second == "scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "mixer") mixerId = mod.first;
        if (mod.second == "scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}
void ImGuiNodeEditorComponent::handleBeautifyLayout()
{
    if (synth == nullptr) return;

    // Graph is always in consistent state since we rebuild at frame start
    // Create an undo state so the action can be reversed
    pushSnapshot();
    juce::Logger::writeToLog("--- [Beautify Layout] Starting ---");

    // --- STEP 1: Build Graph Representation ---
    // Adjacency list: map<source_lid, vector<destination_lid>>
    std::map<juce::uint32, std::vector<juce::uint32>> adjacencyList;
    std::map<juce::uint32, int> inDegree; // Counts incoming connections for each node
    std::vector<juce::uint32> sourceNodes;

    auto modules = synth->getModulesInfo();
    for (const auto& mod : modules)
    {
        inDegree[mod.first] = 0;
        adjacencyList[mod.first] = {};
    }
    // Include the output node in the graph
    inDegree[0] = 0; // Output node ID is 0
    adjacencyList[0] = {}; // Output node has no outgoing connections

    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput)
        {
            adjacencyList[conn.srcLogicalId].push_back(0); // Connect to output node
            inDegree[0]++;
        }
        else
        {
            adjacencyList[conn.srcLogicalId].push_back(conn.dstLogicalId);
            inDegree[conn.dstLogicalId]++;
        }
    }

    for (const auto& mod : modules)
    {
        if (inDegree[mod.first] == 0)
        {
            sourceNodes.push_back(mod.first);
        }
    }

    juce::Logger::writeToLog("[Beautify] Found " + juce::String(sourceNodes.size()) + " source nodes");

    // --- STEP 2: Assign Nodes to Columns (Topological Sort) ---
    std::map<juce::uint32, int> nodeColumn;
    std::vector<std::vector<juce::uint32>> columns;
    int maxColumn = 0;

    // Initialize source nodes in column 0
    for (juce::uint32 nodeId : sourceNodes)
    {
        nodeColumn[nodeId] = 0;
    }
    columns.push_back(sourceNodes);

    // Process each column and assign children to appropriate columns
    std::queue<juce::uint32> processQueue;
    for (juce::uint32 srcNode : sourceNodes)
        processQueue.push(srcNode);

    while (!processQueue.empty())
    {
        juce::uint32 u = processQueue.front();
        processQueue.pop();

        for (juce::uint32 v : adjacencyList[u])
        {
            // The column for node 'v' is the maximum of its predecessors' columns + 1
            int newColumn = nodeColumn[u] + 1;
            if (nodeColumn.count(v) == 0 || newColumn > nodeColumn[v])
            {
                nodeColumn[v] = newColumn;
                maxColumn = std::max(maxColumn, newColumn);
                processQueue.push(v);
            }
        }
    }

    // Re-populate columns based on assignments
    columns.assign(maxColumn + 1, {});
    for (const auto& pair : nodeColumn)
    {
        columns[pair.second].push_back(pair.first);
    }

    juce::Logger::writeToLog("[Beautify] Arranged nodes into " + juce::String(maxColumn + 1) + " columns");

    // --- STEP 3: Optimize Node Ordering Within Columns ---
    // Sort nodes in each column based on median position of their parents
    for (int c = 1; c <= maxColumn; ++c)
    {
        std::map<juce::uint32, float> medianPositions;
        
        for (juce::uint32 nodeId : columns[c])
        {
            std::vector<float> parentPositions;
            
            // Find all parents in previous columns
            for (const auto& pair : adjacencyList)
            {
                for (juce::uint32 dest : pair.second)
                {
                    if (dest == nodeId)
                    {
                        // Find the vertical index of the parent node
                        int parentColumn = nodeColumn[pair.first];
                        auto& parentColVec = columns[parentColumn];
                        auto it = std::find(parentColVec.begin(), parentColVec.end(), pair.first);
                        if (it != parentColVec.end())
                        {
                            parentPositions.push_back((float)std::distance(parentColVec.begin(), it));
                        }
                    }
                }
            }
            
            if (!parentPositions.empty())
            {
                std::sort(parentPositions.begin(), parentPositions.end());
                medianPositions[nodeId] = parentPositions[parentPositions.size() / 2];
            }
            else
            {
                medianPositions[nodeId] = 0.0f;
            }
        }
        
        // Sort the column based on median positions
        std::sort(columns[c].begin(), columns[c].end(), [&](juce::uint32 a, juce::uint32 b) {
            return medianPositions[a] < medianPositions[b];
        });
    }

    // --- STEP 4: Calculate Final Coordinates ---
    const float COLUMN_WIDTH = 400.0f;
    const float NODE_VERTICAL_PADDING = 50.0f;

    // Find the tallest column to center shorter ones
    float tallestColumnHeight = 0.0f;
    for (const auto& col : columns)
    {
        float height = 0.0f;
        for (juce::uint32 lid : col)
        {
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            height += nodeSize.y + NODE_VERTICAL_PADDING;
        }
        tallestColumnHeight = std::max(tallestColumnHeight, height);
    }

    // --- STEP 5: Apply Positions ---
    for (int c = 0; c <= maxColumn; ++c)
    {
        // Calculate column height for centering
        float columnHeight = 0.0f;
        for (juce::uint32 lid : columns[c])
        {
            columnHeight += ImNodes::GetNodeDimensions((int)lid).y + NODE_VERTICAL_PADDING;
        }
        
        // Start Y position (centered vertically)
        float currentY = (tallestColumnHeight - columnHeight) / 2.0f;

        for (juce::uint32 lid : columns[c])
        {
            float x = c * COLUMN_WIDTH;
            pendingNodePositions[(int)lid] = ImVec2(x, currentY);
            
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            currentY += nodeSize.y + NODE_VERTICAL_PADDING;
        }
    }

    // Position the output node to the right of all other modules
    float finalX = (maxColumn + 1) * COLUMN_WIDTH;
    float outputNodeY = (tallestColumnHeight - ImNodes::GetNodeDimensions(0).y) / 2.0f;
    pendingNodePositions[0] = ImVec2(finalX, outputNodeY);
    juce::Logger::writeToLog("[Beautify] Applied position to Output Node");
    
    juce::Logger::writeToLog("[Beautify] Applied positions to " + juce::String(modules.size()) + " nodes");
    juce::Logger::writeToLog("--- [Beautify Layout] Complete ---");
}
void ImGuiNodeEditorComponent::handleConnectSelectedToTrackMixer()
{
    if (synth == nullptr || ImNodes::NumSelectedNodes() <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: No synth or no nodes selected.");
        return;
    }

    // This is a significant action, so create an undo state first.
    pushSnapshot();
    juce::Logger::writeToLog("--- [Connect to Mixer] Starting routine ---");

    // 1. Get all selected node IDs.
    const int numSelectedNodes = ImNodes::NumSelectedNodes();
    std::vector<int> selectedNodeLids(numSelectedNodes);
    ImNodes::GetSelectedNodes(selectedNodeLids.data());

    // 2. Find the geometric center of the selected nodes to position our new modules.
    float totalX = 0.0f, maxX = 0.0f, totalY = 0.0f;
    for (int lid : selectedNodeLids)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(lid);
        totalX += pos.x;
        totalY += pos.y;
        if (pos.x > maxX) {
            maxX = pos.x;
        }
    }
    ImVec2 centerPos = ImVec2(totalX / numSelectedNodes, totalY / numSelectedNodes);
    
    // 3. Compute the TOTAL number of Audio outputs across ALL selected nodes.
    //    This defines how many mixer tracks we need.
    struct NodeAudioOut
    {
        juce::uint32 logicalId;
        int numAudioOuts;
    };
    std::vector<NodeAudioOut> nodesWithAudio;
    nodesWithAudio.reserve(selectedNodeLids.size());
    
    int totalAudioOutputs = 0;
    for (int lid : selectedNodeLids)
    {
        if (auto* mp = synth->getModuleForLogical((juce::uint32) lid))
        {
            // AudioProcessor::getTotalNumOutputChannels() returns AUDIO channel count
            const int audioCh = mp->getTotalNumOutputChannels();
            if (audioCh > 0)
            {
                nodesWithAudio.push_back({ (juce::uint32) lid, audioCh });
                totalAudioOutputs += audioCh;
            }
        }
    }
    
    if (totalAudioOutputs <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] No audio outputs found on selected nodes.");
        return;
    }

    // 4. Create the Value node and set it to the TOTAL number of audio outputs (tracks).
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    if (auto* valueProc = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(valueProc->getAPVTS().getParameter("value")))
        {
            *p = (float) totalAudioOutputs;
            juce::Logger::writeToLog("[AutoConnect] Created Value node " + juce::String(valueLid) + " and set its value to total audio outputs = " + juce::String(totalAudioOutputs));
        }
    }
    // Position it slightly to the right of the center of the selection.
    pendingNodePositions[(int)valueLid] = ImVec2(centerPos.x + 400.0f, centerPos.y);

    // 4. Create the Track Mixer node.
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    // Position it to the right of the right-most selected node for a clean signal flow.
    pendingNodePositions[(int)mixerLid] = ImVec2(maxX + 800.0f, centerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 6. Connect the Value node to the Track Mixer's "Num Tracks Mod" input.
    // The Value module's "Raw" output is channel 0 (provides the exact value entered by the user).
    // The Track Mixer's "Num Tracks Mod" is on Bus 1, Channel 0, which is absolute channel 64.
    synth->connect(valueNodeId, 0, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected Value node 'Raw' output to Track Mixer's Num Tracks Mod input.");

    // 7. Connect ALL audio outputs to sequential mixer inputs in a stable order.
    //    Maintain selection order, and within each node, preserve channel order 0..N-1.
    int mixerInputChannel = 0;
    for (const auto& entry : nodesWithAudio)
    {
        auto sourceNodeId = synth->getNodeIdForLogical(entry.logicalId);
        for (int ch = 0; ch < entry.numAudioOuts; ++ch)
        {
            if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS)
            {
                juce::Logger::writeToLog("[AutoConnect] Reached mixer max tracks while wiring; remaining outputs skipped.");
                break;
            }
            // Skip if this mixer input is already connected (idempotency)
            bool inputAlreadyConnected = false;
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == (juce::uint32) mixerLid && c.dstChan == mixerInputChannel)
                {
                    inputAlreadyConnected = true;
                    break;
                }
            }
            if (!inputAlreadyConnected)
            {
                synth->connect(sourceNodeId, ch, mixerNodeId, mixerInputChannel);
                juce::Logger::writeToLog("[AutoConnect] Connected node " + juce::String((int)entry.logicalId) +
                                         " (Out " + juce::String(ch) + ") -> Mixer In " + juce::String(mixerInputChannel + 1));
            }
            mixerInputChannel++;
            if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;
        }
        if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;
    }

    // 8. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [Connect to Mixer] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: MIDI Player not ready.");
        return;
    }

    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);

    // --- FIX: Create and position the Track Mixer first ---
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 1200.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // --- FIX: Connect MIDI Player "Num Tracks" output to Track Mixer "Num Tracks Mod" input ---
    // This ensures the Track Mixer automatically adjusts its track count based on the MIDI file content
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected MIDI Player Num Tracks to Track Mixer Num Tracks Mod");

    // 2. Create and connect a Sample Loader for each active MIDI track.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnect] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks.");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= MIDIPlayerModuleProcessor::kMaxTracks) break;

        // A. Create and position the new modules.
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y + (i * 350.0f));

        auto mapRangeNodeId = synth->addModule("map_range");
        auto mapRangeLid = synth->getLogicalIdForNode(mapRangeNodeId);
        pendingNodePositions[(int)mapRangeLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y + (i * 350.0f));
        
        // B. Configure the MapRange module for Pitch CV conversion.
        if (auto* mapRangeProc = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(mapRangeLid)))
        {
            auto& ap = mapRangeProc->getAPVTS();
            // MIDI Player Pitch Out (0..1) -> Sample Loader Pitch Mod (-24..+24 semitones)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = 0.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = 1.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = -24.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = 24.0f;
        }

        // C. Connect the outputs for this track.
        const int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        const int gateChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 1;
        const int trigChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 3;

        // Pitch: MIDI Player -> MapRange -> Sample Loader
        synth->connect(midiPlayerNodeId, pitchChan, mapRangeNodeId, 0); // Pitch Out -> MapRange In
        synth->connect(mapRangeNodeId, 1, samplerNodeId, 0);             // MapRange Raw Out -> SampleLoader Pitch Mod In

        // Gate: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, gateChan, samplerNodeId, 2);    // Gate Out -> SampleLoader Gate Mod In

        // Trigger: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, trigChan, samplerNodeId, 3);    // Trigger Out -> SampleLoader Trigger Mod In

        // --- FIX: Connect the Sample Loader's audio output to the Track Mixer ---
        // The Sample Loader's main audio output is channel 0.
        // The Track Mixer's inputs are mono channels 0, 1, 2...
        synth->connect(samplerNodeId, 0, mixerNodeId, i);
    }

    // --- FIX: Connect the mixer to the main output so you can hear it! ---
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R

    // 3. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnectVCO] Aborted: MIDI Player not ready.");
        return;
    }
    
    juce::Logger::writeToLog("--- [AutoConnectVCO] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear all existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);
    
    // 2. Create and position the PolyVCO and Track Mixer.
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created PolyVCO with logical ID " + juce::String(polyVcoLid));

    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 3. Connect the track count outputs to control both new modules.
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, polyVcoNodeId, 0); // Raw Num Tracks -> PolyVCO Num Voices Mod
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS); // Raw Num Tracks -> Mixer Num Tracks Mod
    juce::Logger::writeToLog("[AutoConnectVCO] Connected MIDI Player raw track counts to PolyVCO and Track Mixer modulation inputs.");
    
    // 4. Loop through active MIDI tracks to connect CV routes and audio.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnectVCO] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks. Patching voices...");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= PolyVCOModuleProcessor::MAX_VOICES) break; // Don't try to connect more voices than the PolyVCO has

        int sourceTrackIndex = activeTrackIndices[i];

        // A. Connect CV modulation routes from MIDI Player to the corresponding PolyVCO voice.
        int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        int velChan   = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 2;
        
        // Connect MIDI CV to the corresponding PolyVCO voice inputs
        synth->connect(midiPlayerNodeId, pitchChan, polyVcoNodeId, 1 + i); // Pitch -> Freq Mod
        synth->connect(midiPlayerNodeId, velChan,   polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Velocity -> Gate Mod

        // B. Connect the PolyVCO voice's audio output to the Track Mixer's input.
        synth->connect(polyVcoNodeId, i, mixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, mixerNodeId, i * 2 + 1);
    }
    
    // 5. Connect the Track Mixer to the main audio output.
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R
    
    // 6. Flag the graph for a rebuild.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnectVCO] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer) return;

    pushSnapshot();

    const int numTracks = midiPlayer->getNumTracks();
    if (numTracks == 0) return;

    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);

    // --- THIS IS THE NEW "FIND-BY-TRACING" LOGIC ---

    juce::uint32 polyVcoLid = 0;
    juce::uint32 trackMixerLid = 0;

    // 1. Scan existing connections to find modules to reuse by tracing backwards.
    // First, find a TrackMixer connected to the output.
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("track_mixer"))
        {
            trackMixerLid = conn.srcLogicalId; // Found a TrackMixer to reuse!
            break;
        }
    }
    // If we found a TrackMixer, now find a PolyVCO connected to it.
    if (trackMixerLid != 0)
    {
        for (const auto& conn : synth->getConnectionsInfo())
        {
            if (conn.dstLogicalId == trackMixerLid && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("polyvco"))
            {
                polyVcoLid = conn.srcLogicalId; // Found a PolyVCO to reuse!
                break;
            }
        }
    }

    // 2. Clear all old Pitch/Gate/Velocity connections from the MIDI Player.
    std::vector<ModularSynthProcessor::ConnectionInfo> oldConnections;
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.srcLogicalId == midiPlayerLid && conn.srcChan < 16 * 3)
            oldConnections.push_back(conn);
    }
    for (const auto& conn : oldConnections)
    {
        synth->disconnect(synth->getNodeIdForLogical(conn.srcLogicalId), conn.srcChan,
                          synth->getNodeIdForLogical(conn.dstLogicalId), conn.dstChan);
    }

    // 3. If we didn't find a PolyVCO to reuse after tracing, create a new one.
    if (polyVcoLid == 0)
    {
        auto polyVcoNodeId = synth->addModule("polyvco", false);
        polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
        pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPos.x + 400.0f, midiPos.y);
    }

    // 4. If we didn't find a TrackMixer to reuse after tracing, create a new one.
    if (trackMixerLid == 0)
    {
        auto trackMixerNodeId = synth->addModule("track_mixer", false);
        trackMixerLid = synth->getLogicalIdForNode(trackMixerNodeId);
        pendingNodePositions[(int)trackMixerLid] = ImVec2(midiPos.x + 800.0f, midiPos.y);
    }
    // --- END OF NEW LOGIC ---

    auto polyVcoNodeId = synth->getNodeIdForLogical(polyVcoLid);
    auto trackMixerNodeId = synth->getNodeIdForLogical(trackMixerLid);

    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numTracks;
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(trackMixerLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numTracks;

    int voicesToConnect = std::min({numTracks, PolyVCOModuleProcessor::MAX_VOICES, 64});
    for (int i = 0; i < voicesToConnect; ++i)
    {
        synth->connect(midiPlayerNodeId, i, polyVcoNodeId, 1 + i);
        synth->connect(midiPlayerNodeId, i + 16, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2 + 1);
    }
    
    synth->connect(trackMixerNodeId, 0, synth->getOutputNodeID(), 0);
    synth->connect(trackMixerNodeId, 1, synth->getOutputNodeID(), 1);

    synth->commitChanges();
}

void ImGuiNodeEditorComponent::handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid)
{
    if (!synth || !strokeSeq) return;

    juce::Logger::writeToLog("🥁 BUILD DRUM KIT handler called! Creating modules...");

    // 1. Get Stroke Sequencer position
    auto seqNodeId = synth->getNodeIdForLogical(strokeSeqLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)strokeSeqLid);

    // 2. Create 3 Sample Loaders (for Floor, Mid, Ceiling triggers)
    auto sampler1NodeId = synth->addModule("sample_loader");
    auto sampler2NodeId = synth->addModule("sample_loader");
    auto sampler3NodeId = synth->addModule("sample_loader");
    
    auto sampler1Lid = synth->getLogicalIdForNode(sampler1NodeId);
    auto sampler2Lid = synth->getLogicalIdForNode(sampler2NodeId);
    auto sampler3Lid = synth->getLogicalIdForNode(sampler3NodeId);
    
    // Position samplers in a vertical stack to the right
    pendingNodePositions[(int)sampler1Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    pendingNodePositions[(int)sampler2Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 220.0f);
    pendingNodePositions[(int)sampler3Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 440.0f);

    // 3. Create Track Mixer (will be set to 6 tracks by Value node)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 200.0f);

    // 4. Create Value node set to 6.0 (for 3 stereo tracks = 6 channels)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(seqPos.x + 600.0f, seqPos.y + 550.0f);
    
    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = 6.0f;
    }

    // 5. Connect Stroke Sequencer TRIGGERS to Sample Loader TRIGGER MOD inputs (channel 3)
    synth->connect(seqNodeId, 0, sampler1NodeId, 3); // Floor Trig   -> Sampler 1 Trigger Mod
    synth->connect(seqNodeId, 1, sampler2NodeId, 3); // Mid Trig     -> Sampler 2 Trigger Mod
    synth->connect(seqNodeId, 2, sampler3NodeId, 3); // Ceiling Trig -> Sampler 3 Trigger Mod

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    // Sampler 1 (L+R) -> Mixer Audio 1+2
    synth->connect(sampler1NodeId, 0, mixerNodeId, 0); // Sampler 1 L -> Mixer Audio 1
    synth->connect(sampler1NodeId, 1, mixerNodeId, 1); // Sampler 1 R -> Mixer Audio 2
    
    // Sampler 2 (L+R) -> Mixer Audio 3+4
    synth->connect(sampler2NodeId, 0, mixerNodeId, 2); // Sampler 2 L -> Mixer Audio 3
    synth->connect(sampler2NodeId, 1, mixerNodeId, 3); // Sampler 2 R -> Mixer Audio 4
    
    // Sampler 3 (L+R) -> Mixer Audio 5+6
    synth->connect(sampler3NodeId, 0, mixerNodeId, 4); // Sampler 3 L -> Mixer Audio 5
    synth->connect(sampler3NodeId, 1, mixerNodeId, 5); // Sampler 3 R -> Mixer Audio 6

    // 7. Connect Value node (6.0) to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value (6) -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid)
{
    if (!synth || !animModule) return;

    // Query the dynamic output pins to determine how many bones are tracked
    auto dynamicPins = animModule->getDynamicOutputPins();
    
    // Each bone has 3 outputs: Vel X, Vel Y, Hit
    // So number of bones = number of pins / 3
    int numTrackedBones = (int)dynamicPins.size() / 3;
    
    if (numTrackedBones == 0)
    {
        juce::Logger::writeToLog("🦶 BUILD TRIGGERS AUDIO: No tracked bones! Add bones first.");
        return;
    }

    juce::Logger::writeToLog("🦶 BUILD TRIGGERS AUDIO handler called! Creating modules for " + 
                             juce::String(numTrackedBones) + " tracked bones...");

    // 1. Get Animation Module position
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    ImVec2 animPos = ImNodes::GetNodeGridSpacePos((int)animModuleLid);

    // 2. Create one Sample Loader per tracked bone
    std::vector<juce::AudioProcessorGraph::NodeID> samplerNodeIds;
    std::vector<juce::uint32> samplerLids;
    
    for (int i = 0; i < numTrackedBones; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        samplerNodeIds.push_back(samplerNodeId);
        samplerLids.push_back(synth->getLogicalIdForNode(samplerNodeId));
        
        // Position samplers in a vertical stack to the right
        pendingNodePositions[(int)samplerLids[i]] = ImVec2(animPos.x + 400.0f, animPos.y + i * 220.0f);
    }

    // 3. Create Track Mixer (num_bones * 2 for stereo pairs)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(animPos.x + 800.0f, animPos.y + (numTrackedBones * 110.0f));

    // 4. Create Value node for mixer track count
    int numMixerTracks = numTrackedBones * 2; // 2 channels per sampler (stereo)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(animPos.x + 600.0f, animPos.y + (numTrackedBones * 220.0f));

    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = (float)numMixerTracks;
    }

    // 5. Connect Animation Module TRIGGERS to Sample Loader TRIGGER MOD inputs
    // Animation Module Output Channels (per bone):
    //   i*3 + 0: Bone Vel X
    //   i*3 + 1: Bone Vel Y
    //   i*3 + 2: Bone Hit (trigger) ← Connect this to sampler
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int triggerChannel = i * 3 + 2; // Every 3rd channel starting at 2 (2, 5, 8, 11, ...)
        synth->connect(animNodeId, triggerChannel, samplerNodeIds[i], 3); // Bone Hit -> Sampler Trigger Mod
    }

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int mixerChannelL = i * 2;       // 0, 2, 4, 6, ...
        int mixerChannelR = i * 2 + 1;   // 1, 3, 5, 7, ...
        
        synth->connect(samplerNodeIds[i], 0, mixerNodeId, mixerChannelL); // Sampler L -> Mixer Audio L
        synth->connect(samplerNodeIds[i], 1, mixerNodeId, mixerChannelR); // Sampler R -> Mixer Audio R
    }

    // 7. Connect Value node to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
    
    juce::Logger::writeToLog("🦶 BUILD TRIGGERS AUDIO complete! " + juce::String(numTrackedBones) + 
                             " samplers + mixer + wiring created.");
}
void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. Create the necessary Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 100.0f);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        *dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")) = numSteps;
    }

    // 3. CREATE a Sample Loader for each step and connect its audio to the mixer
    for (int i = 0; i < numSteps; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(seqPos.x + 400.0f, seqPos.y + (i * 220.0f));

        // Connect this sampler's audio output to the mixer's input
        synth->connect(samplerNodeId, 0 /*Audio Output*/, mixerNodeId, i);
        
        // Connect the Sequencer's CV/Trig for this step directly to the new sampler
        synth->connect(seqNodeId, 7 + i * 3 + 0, samplerNodeId, 0); // Pitch N -> Pitch Mod
        synth->connect(seqNodeId, 1, samplerNodeId, 2); // Main Gate -> Gate Mod
        synth->connect(seqNodeId, 7 + i * 3 + 2, samplerNodeId, 3); // Trig N  -> Trigger Mod
    }
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod

    // 4. Connect the mixer to the main output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. CREATE the PolyVCO and Track Mixer
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numSteps;
    }
    
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numSteps;
    }

    // 3. Connect CV, Audio, and Main Output
    for (int i = 0; i < numSteps; ++i)
    {
        // Connect CV: Sequencer -> PolyVCO
        synth->connect(seqNodeId, 7 + i * 3 + 0, polyVcoNodeId, 1 + i);                                  // Pitch N -> Freq N Mod
        synth->connect(seqNodeId, 1, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Main Gate -> Gate N Mod

        // Connect Audio: PolyVCO -> Mixer
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // Connect Num Steps output (channel 6) to PolyVCO's Num Voices Mod input (channel 0)
    synth->connect(seqNodeId, 6, polyVcoNodeId, 0); // Num Steps -> Num Voices Mod
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod
    
    // Connect Mixer -> Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::openMetaModuleEditor(MetaModuleProcessor* metaModule, juce::uint32 metaLogicalId)
{
    closeMetaModuleEditor();

    if (metaModule == nullptr)
        return;

    auto session = std::make_unique<MetaModuleEditorSession>();
    session->context.reset(ImNodes::CreateContext());
    if (session->context == nullptr)
        return;

    ImNodes::SetCurrentContext(session->context.get());
    ImNodes::StyleColorsDark();
    ImNodesIO& io = ImNodes::GetIO();
    io.LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyAlt;

    session->meta = metaModule;
    session->metaLogicalId = metaLogicalId;
    session->graph = metaModule->getInternalGraph();

    if (session->graph != nullptr)
    {
        auto modules = session->graph->getModulesInfo();
        int index = 0;
        for (const auto& mod : modules)
        {
            const int logicalId = (int)mod.first;
            const int row = index / 5;
            const int col = index % 5;
            session->nodePositions.emplace(logicalId, ImVec2(220.0f * col, 140.0f * row));
            ++index;
        }
    }

    ImNodes::SetCurrentContext(editorContext);
    metaEditorSession = std::move(session);
}

void ImGuiNodeEditorComponent::closeMetaModuleEditor()
{
    if (metaEditorSession)
    {
        if (metaEditorSession->context)
        {
            ImNodes::SetCurrentContext(metaEditorSession->context.get());
            ImNodes::DestroyContext(metaEditorSession->context.release());
        }
        metaEditorSession.reset();
    }
    if (editorContext != nullptr)
        ImNodes::SetCurrentContext(editorContext);
}

void ImGuiNodeEditorComponent::renderMetaModuleEditor(MetaModuleEditorSession& session)
{
    if (session.context == nullptr || session.meta == nullptr || session.graph == nullptr)
    {
        ImGui::TextUnformatted("Internal graph is unavailable.");
        return;
    }

    ImNodes::SetCurrentContext(session.context.get());

    auto modules = session.graph->getModulesInfo();

    if (session.nodePositions.empty())
    {
        int index = 0;
        for (const auto& mod : modules)
        {
            const int logicalId = (int)mod.first;
            const int row = index / 5;
            const int col = index % 5;
            session.nodePositions.emplace(logicalId, ImVec2(220.0f * col, 140.0f * row));
            ++index;
        }
    }

    ImVec2 canvasSize = ImGui::GetContentRegionAvail();
    canvasSize.x = juce::jmax(canvasSize.x, 640.0f);
    canvasSize.y = juce::jmax(canvasSize.y, 360.0f);

    ImGui::BeginChild("MetaEditorCanvas", canvasSize, true, ImGuiWindowFlags_NoScrollWithMouse);
    ImNodes::BeginNodeEditor();

    const auto& pinDb = getModulePinDatabase();

    auto drawPinsForModule = [&](ModuleProcessor* module, const ModulePinInfo* info)
    {
        std::vector<AudioPin> audioIns;
        std::vector<AudioPin> audioOuts;
        std::vector<ModPin> modIns;

        if (info != nullptr)
        {
            audioIns.assign(info->audioIns.begin(), info->audioIns.end());
            audioOuts.assign(info->audioOuts.begin(), info->audioOuts.end());
            modIns.assign(info->modIns.begin(), info->modIns.end());
        }

        if (module != nullptr)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            auto dynamicOutputs = module->getDynamicOutputPins();

            for (const auto& dyn : dynamicInputs)
                audioIns.emplace_back(dyn.name, dyn.channel, dyn.type);
            for (const auto& dyn : dynamicOutputs)
                audioOuts.emplace_back(dyn.name, dyn.channel, dyn.type);
        }

        for (const auto& pin : audioIns)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = pin.channel;
            pinId.isInput = true;
            pinId.isMod = (pin.type != PinDataType::Audio);

            ImNodes::BeginInputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndInputAttribute();
        }

        for (const auto& pin : modIns)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = (int)pin.paramId.hashCode();
            pinId.isInput = true;
            pinId.isMod = true;

            ImNodes::BeginInputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndInputAttribute();
        }

        for (const auto& pin : audioOuts)
        {
            PinID pinId;
            pinId.logicalId = module != nullptr ? module->getLogicalId() : 0;
            pinId.channel = pin.channel;
            pinId.isInput = false;
            pinId.isMod = (pin.type != PinDataType::Audio);

            ImNodes::BeginOutputAttribute(encodePinId(pinId));
            ImGui::Text("%s", pin.name.toRawUTF8());
            ImNodes::EndOutputAttribute();
        }
    };

    for (const auto& mod : modules)
    {
        const int logicalId = (int)mod.first;
        const juce::String type = mod.second;
        ModuleProcessor* module = session.graph->getModuleForLogical(mod.first);

        ImNodes::BeginNode(logicalId);
        ImGui::Text("%s", type.toRawUTF8());

        const ModulePinInfo* info = nullptr;
        auto it = pinDb.find(type);
        if (it != pinDb.end())
            info = &it->second;

        drawPinsForModule(module, info);

        ImNodes::EndNode();

        const auto posIt = session.nodePositions.find(logicalId);
        if (posIt != session.nodePositions.end())
            ImNodes::SetNodeGridSpacePos(logicalId, posIt->second);
    }

    session.linkIdToAttrs.clear();
    const auto connections = session.graph->getConnectionsInfo();
    for (const auto& conn : connections)
    {
        PinID srcPin;
        srcPin.logicalId = conn.srcLogicalId;
        srcPin.channel = conn.srcChan;
        srcPin.isInput = false;
        srcPin.isMod = false;

        PinID dstPin;
        if (conn.dstIsOutput)
        {
            dstPin.logicalId = 0;
        }
        else
        {
            dstPin.logicalId = conn.dstLogicalId;
        }
        dstPin.channel = conn.dstChan;
        dstPin.isInput = true;
        dstPin.isMod = false;

        const int srcAttr = encodePinId(srcPin);
        const int dstAttr = encodePinId(dstPin);

        const int linkId = (int)(((conn.srcLogicalId & 0xFFFF) << 16)
                            ^ ((conn.dstLogicalId & 0xFFFF) << 1)
                            ^ ((conn.srcChan & 0xFF) << 8)
                            ^ (conn.dstChan & 0xFF)
                            ^ (conn.dstIsOutput ? 0x4000 : 0x0));

        session.linkIdToAttrs[linkId] = { srcAttr, dstAttr };
        ImNodes::Link(linkId, srcAttr, dstAttr);
    }

    if (ImGui::BeginPopupContextWindow("MetaNodeEditorContext", ImGuiPopupFlags_MouseButtonRight))
    {
        if (ImGui::MenuItem("Delete Selected"))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                std::vector<int> selected(numSelected);
                ImNodes::GetSelectedNodes(selected.data());
                for (int nodeId : selected)
                {
                    auto node = session.graph->getNodeIdForLogical((juce::uint32)nodeId);
                    if (node.uid != 0)
                        session.graph->removeModule(node);
                }
                session.graph->commitChanges();
                session.meta->refreshCachedLayout();
                session.dirty = true;
                ImNodes::ClearNodeSelection();
            }
        }
        ImGui::EndPopup();
    }

    ImNodes::MiniMap(0.2f);
    ImNodes::EndNodeEditor();

    int startAttr = 0;
    int endAttr = 0;
    if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
    {
        PinID a = decodePinId(startAttr);
        PinID b = decodePinId(endAttr);

        PinID src = a;
        PinID dst = b;
        if (src.isInput && !dst.isInput)
            std::swap(src, dst);

        if (!src.isInput && dst.isInput)
        {
            auto srcNodeId = session.graph->getNodeIdForLogical(src.logicalId);
            juce::AudioProcessorGraph::NodeID dstNodeId;
            if (dst.logicalId == 0)
                dstNodeId = session.graph->getOutputNodeID();
            else
                dstNodeId = session.graph->getNodeIdForLogical(dst.logicalId);

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                if (session.graph->connect(srcNodeId, src.channel, dstNodeId, dst.channel))
                {
                    session.graph->commitChanges();
                    session.meta->refreshCachedLayout();
                    session.dirty = true;
                }
            }
        }
    }

    int destroyedLink = 0;
    if (ImNodes::IsLinkDestroyed(&destroyedLink))
    {
        auto linkIt = session.linkIdToAttrs.find(destroyedLink);
        if (linkIt != session.linkIdToAttrs.end())
        {
            PinID src = decodePinId(linkIt->second.first);
            PinID dst = decodePinId(linkIt->second.second);

            auto srcNodeId = session.graph->getNodeIdForLogical(src.logicalId);
            juce::AudioProcessorGraph::NodeID dstNodeId;
            if (dst.logicalId == 0)
                dstNodeId = session.graph->getOutputNodeID();
            else
                dstNodeId = session.graph->getNodeIdForLogical(dst.logicalId);

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                if (session.graph->disconnect(srcNodeId, src.channel, dstNodeId, dst.channel))
                {
                    session.graph->commitChanges();
                    session.meta->refreshCachedLayout();
                    session.dirty = true;
                }
            }
        }
    }

    for (const auto& mod : modules)
    {
        const int logicalId = (int)mod.first;
        session.nodePositions[logicalId] = ImNodes::GetNodeGridSpacePos(logicalId);
    }

    ImGui::EndChild();

    char searchBuffer[128];
    std::memset(searchBuffer, 0, sizeof(searchBuffer));
    std::strncpy(searchBuffer, session.moduleSearchTerm.toRawUTF8(), sizeof(searchBuffer) - 1);
    if (ImGui::InputTextWithHint("##MetaModuleSearch", "Module type (e.g. vco)", searchBuffer, sizeof(searchBuffer)))
    {
        session.moduleSearchTerm = juce::String(searchBuffer);
    }

    if (ImGui::Button("Create Module"))
    {
        juce::String moduleType = session.moduleSearchTerm.trim();
        if (moduleType.isNotEmpty())
        {
            auto nodeId = session.graph->addModule(moduleType);
            if (nodeId.uid != 0)
            {
                auto logicalId = session.graph->getLogicalIdForNode(nodeId);
                session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
                session.graph->commitChanges();
                session.meta->refreshCachedLayout();
                session.dirty = true;
            }
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Add Inlet"))
    {
        auto nodeId = session.graph->addModule("inlet");
        if (nodeId.uid != 0)
        {
            auto logicalId = session.graph->getLogicalIdForNode(nodeId);
            session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
            session.graph->commitChanges();
            session.meta->refreshCachedLayout();
            session.dirty = true;
        }
    }
    ImGui::SameLine();
    if (ImGui::Button("Add Outlet"))
    {
        auto nodeId = session.graph->addModule("outlet");
        if (nodeId.uid != 0)
        {
            auto logicalId = session.graph->getLogicalIdForNode(nodeId);
            session.nodePositions[(int)logicalId] = ImVec2(40.0f * (float)session.nodePositions.size(), 40.0f);
            session.graph->commitChanges();
            session.meta->refreshCachedLayout();
            session.dirty = true;
        }
    }

    ImNodes::SetCurrentContext(editorContext);
}
void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info and get number of tracked colors
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count using the new helper method
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create PolyVCO with matching number of voices
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y);
    
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices")))
            *p = numColors;
    }
    
    // 3. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 4. Connect Num Colors output to PolyVCO's NumVoices Mod and TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, polyVcoNodeId, 0); // Num Colors -> NumVoices Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64);  // Num Colors -> Num Tracks Mod
    
    // 5. Connect ColorTracker outputs to PolyVCO inputs
    for (int i = 0; i < numColors; ++i)
    {
        // Map X position to pitch/frequency for voice i
        synth->connect(colorTrackerNodeId, i * 3 + 0, polyVcoNodeId, 1 + i); // X -> Freq Mod
        
        // Map Area to gate level for voice i
        const int gateModChannel = 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i;
        synth->connect(colorTrackerNodeId, i * 3 + 2, polyVcoNodeId, gateModChannel); // Area -> Gate Mod
    }
    
    // 6. Connect PolyVCO audio outputs to Track Mixer inputs
    for (int i = 0; i < numColors; ++i)
    {
        synth->connect(polyVcoNodeId, i, mixerNodeId, i); // Voice i -> Mixer Track i
    }
    
    // 7. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to PolyVCO.");
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y + 100.0f);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 3. Connect Num Colors output to TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64); // Num Colors -> Num Tracks Mod

    // 4. Create a Sample Loader for each tracked color
    for (int i = 0; i < numColors; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y + (i * 220.0f));

        // Connect Sample Loader audio output to mixer
        synth->connect(samplerNodeId, 0, mixerNodeId, i); // Audio -> Mixer Track i
        
        // Connect ColorTracker CV outputs to Sample Loader modulation inputs
        synth->connect(colorTrackerNodeId, i * 3 + 0, samplerNodeId, 0); // X -> Pitch Mod
        synth->connect(colorTrackerNodeId, i * 3 + 2, samplerNodeId, 2); // Area -> Gate Mod
    }
    
    // 5. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to Sample Loaders.");
}

// Add this exact helper function to the class
void ImGuiNodeEditorComponent::parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex)
{
    outIndex = -1; // Default to no index
    outType = fullName;

    if (fullName.contains(" "))
    {
        const juce::String lastWord = fullName.substring(fullName.lastIndexOfChar(' ') + 1);
        if (lastWord.containsOnly("0123456789"))
        {
            outIndex = lastWord.getIntValue();
            outType = fullName.substring(0, fullName.lastIndexOfChar(' '));
        }
    }
}

void ImGuiNodeEditorComponent::updateRerouteTypeFromConnections(juce::uint32 rerouteLogicalId)
{
    if (synth == nullptr)
        return;

    auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(rerouteLogicalId));
    if (reroute == nullptr)
        return;

    std::optional<PinDataType> resolvedType;
    const auto connections = synth->getConnectionsInfo();

    for (const auto& conn : connections)
    {
        if (!conn.dstIsOutput && conn.dstLogicalId == rerouteLogicalId)
        {
            PinID srcPin { conn.srcLogicalId, conn.srcChan, false, false, {} };
            resolvedType = getPinDataTypeForPin(srcPin);
            break;
        }
    }

    if (!resolvedType.has_value())
    {
        for (const auto& conn : connections)
        {
            if (conn.srcLogicalId == rerouteLogicalId && !conn.dstIsOutput)
            {
                PinID dstPin { conn.dstLogicalId, conn.dstChan, true, false, {} };
                resolvedType = getPinDataTypeForPin(dstPin);
                break;
            }
        }
    }

    if (resolvedType.has_value())
        reroute->setPassthroughType(*resolvedType);
    else
        reroute->setPassthroughType(PinDataType::Audio);
}

// Helper functions to get pins from modules
std::vector<AudioPin> ImGuiNodeEditorComponent::getOutputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioOuts;
    return {};
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getInputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioIns;
    return {};
}

AudioPin* ImGuiNodeEditorComponent::findInputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getInputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

AudioPin* ImGuiNodeEditorComponent::findOutputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getOutputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::findNodesOfType(const juce::String& moduleType)
{
    std::vector<juce::uint32> result;
    if (!synth) return result;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleTypeForLogical(modInfo.first) == moduleType)
        {
            result.push_back(modInfo.first);
        }
    }
    return result;
}

// New dynamic pin-fetching helper
std::vector<PinInfo> ImGuiNodeEditorComponent::getDynamicOutputPins(ModuleProcessor* module)
{
    std::vector<PinInfo> pins;
    if (!module) return pins;

    const int numOutputChannels = module->getBus(false, 0)->getNumberOfChannels();
    for (int i = 0; i < numOutputChannels; ++i)
    {
        juce::String pinName = module->getAudioOutputLabel(i);
        if (pinName.isNotEmpty())
        {
            pins.push_back({(uint32_t)i, pinName}); // Store the full pin name in the type field
        }
    }
    return pins;
}
// Template function implementations
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToMonophonicTargets(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping,
    const std::vector<juce::uint32>& targetLids)
{
    if (!synth || !sourceNode || targetLids.empty()) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToMonophonicTargets called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    // Use provided target logical IDs explicitly
    auto targetNodes = targetLids;

    int currentTargetIndex = 0;

    // First, group all of the source node's output pins by their index number.
    // For example, "Pitch 1" and "Trig 1" will both be in the group for index 1.
    std::map<int, std::vector<PinInfo>> pinsByIndex;
    
    // THE FIX: Get pins directly from the module instance.
    auto outputPins = getDynamicOutputPins(sourceNode);
    
    for (const auto& pin : outputPins)
    {
        juce::String type;
        int index = -1;
        parsePinName(pin.type, type, index); // Use pin.type instead of pin.name
        if (index != -1) {
            // Store channel ID as the pin's ID
            pinsByIndex[index].push_back({(uint32_t)pin.id, type}); 
        }
    }

    // Now, loop through each group of pins (each voice).
    for (auto const& [index, pinsInGroup] : pinsByIndex)
    {
        if (currentTargetIndex >= (int)targetNodes.size()) break; // Stop if we run out of targets
        auto targetNodeId = targetNodes[currentTargetIndex];

        // For each pin in the group (e.g., for "Pitch 1" and "Trig 1")...
        for (const auto& pinInfo : pinsInGroup)
        {
            // Check if we have a connection rule for this pin type (e.g., "Pitch").
            if (pinNameMapping.count(pinInfo.type))
            {
                juce::String targetPinName = pinNameMapping.at(pinInfo.type);
                auto* targetPin = findInputPin("sample_loader", targetPinName);

                // If the target pin exists, create the connection.
                if (targetPin)
                {
                    juce::uint32 sourceLogicalId = 0;
                    for (const auto& modInfo : synth->getModulesInfo())
                    {
                        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
                        {
                            sourceLogicalId = modInfo.first;
                            break;
                        }
                    }
                    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);
                    synth->connect(sourceNodeId, pinInfo.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
                }
            }
        }
        // IMPORTANT: Move to the next target module for the next voice.
        currentTargetIndex++;
    }
}
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToPolyphonicTarget(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping)
{
    if (!synth || !sourceNode) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToPolyphonicTarget called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    juce::uint32 sourceLogicalId = 0;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            sourceLogicalId = modInfo.first;
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    auto targetNodes = findNodesOfType("polyvco");
    if (targetNodes.empty()) return;
    auto targetNodeId = targetNodes[0]; // Use the first available PolyVCO

    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);

    // THE FIX: Get pins directly from the module instance, not the database.
    auto outputPins = getDynamicOutputPins(sourceNode);

    // Loop through every output pin on the source module.
    for (const auto& sourcePin : outputPins)
    {
        // Parse the source pin's name to get its type and index.
        juce::String sourceType;
        int sourceIndex = -1;
        parsePinName(sourcePin.type, sourceType, sourceIndex); // Use pin.type instead of pin.name

        if (sourceIndex == -1) continue; // Skip pins that aren't numbered.

        // Check if we have a rule for this pin type (e.g., "Pitch" maps to "Freq").
        if (pinNameMapping.count(sourceType))
        {
            juce::String targetType = pinNameMapping.at(sourceType);
            // PolyVCO inputs use the format "Freq 1 Mod", "Gate 1 Mod", etc.
            juce::String targetPinName = targetType + " " + juce::String(sourceIndex) + " Mod";

            // Find that pin on the target and connect it if available.
            auto* targetPin = findInputPin("polyvco", targetPinName);
            if (targetPin)
            {
                synth->connect(sourceNodeId, sourcePin.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleAutoConnectionRequests()
{
    if (!synth) return;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* module = synth->getModuleForLogical(modInfo.first);
        if (!module) continue;

        // --- Check MultiSequencer Flags ---
        if (auto* multiSeq = dynamic_cast<MultiSequencerModuleProcessor*>(module))
        {
            if (multiSeq->autoConnectSamplersTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectSamplers(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
            if (multiSeq->autoConnectVCOTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectVCO(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
        }
        
        // --- Check ColorTracker Flags ---
        if (auto* colorTracker = dynamic_cast<ColorTrackerModule*>(module))
        {
            if (colorTracker->autoConnectPolyVCOTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectPolyVCO(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
            if (colorTracker->autoConnectSamplersTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectSamplers(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check StrokeSequencer Flags ---
        if (auto* strokeSeq = dynamic_cast<StrokeSequencerModuleProcessor*>(module))
        {
            if (strokeSeq->autoBuildDrumKitTriggered.exchange(false))
            {
                handleStrokeSeqBuildDrumKit(strokeSeq, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check AnimationModule Flags ---
        if (auto* animModule = dynamic_cast<AnimationModuleProcessor*>(module))
        {
            if (animModule->autoBuildTriggersAudioTriggered.exchange(false))
            {
                handleAnimationBuildTriggersAudio(animModule, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check MIDIPlayer Flags ---
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(module))
        {
            if (midiPlayer->autoConnectTriggered.exchange(false)) // Samplers
            {
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType)
{
    if (!synth || !midiPlayer) return;
    
    juce::Logger::writeToLog("[MIDI Player Quick Connect] Request type: " + juce::String(requestType));
    
    // Get ALL tracks (don't filter by whether they have notes)
    const auto& notesByTrack = midiPlayer->getNotesByTrack();
    int numTracks = (int)notesByTrack.size();
    
    if (numTracks == 0)
    {
        juce::Logger::writeToLog("[MIDI Player Quick Connect] No tracks in MIDI file");
        return;
    }
    
    // Get MIDI Player position for positioning new nodes
    ImVec2 playerPos = ImNodes::GetNodeEditorSpacePos(static_cast<int>(midiPlayerLid));
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    
    // Request Type: 1=PolyVCO, 2=Samplers, 3=Both
    juce::uint32 polyVCOLid = 0;
    juce::uint32 mixerLid = 0;
    
    if (requestType == 1 || requestType == 3) // PolyVCO or Both
    {
        // 1. Create PolyVCO
        auto polyVCONodeId = synth->addModule("polyvco");
        polyVCOLid = synth->getLogicalIdForNode(polyVCONodeId);
        pendingNodeScreenPositions[(int)polyVCOLid] = ImVec2(playerPos.x + 400.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created PolyVCO at LID " + juce::String((int)polyVCOLid));
        
        // 2. Create Track Mixer
        auto mixerNodeId = synth->addModule("track_mixer");
        mixerLid = synth->getLogicalIdForNode(mixerNodeId);
        pendingNodeScreenPositions[(int)mixerLid] = ImVec2(playerPos.x + 700.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        
        // 3. Connect MIDI Player tracks to PolyVCO
        // Connect ALL tracks, regardless of whether they have notes
        int trackIdx = 0;
        for (size_t i = 0; i < notesByTrack.size() && trackIdx < 32; ++i)
        {
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiVeloPin = trackIdx * 4 + 2;
            
            const int vcoFreqPin = trackIdx + 1;
            const int vcoWavePin = 32 + trackIdx + 1;
            const int vcoGatePin = 64 + trackIdx + 1;
            
            synth->connect(midiPlayerNodeId, midiPitchPin, polyVCONodeId, vcoFreqPin);
            synth->connect(midiPlayerNodeId, midiGatePin, polyVCONodeId, vcoGatePin);
            synth->connect(midiPlayerNodeId, midiVeloPin, polyVCONodeId, vcoWavePin);
            trackIdx++;
        }
        
        // 4. Connect Num Tracks to PolyVCO (Num Voices Mod on channel 0)
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       polyVCONodeId, 0);
        
        // 5. Connect PolyVCO outputs to Track Mixer inputs
        for (int i = 0; i < trackIdx; ++i)
        {
            synth->connect(polyVCONodeId, i, mixerNodeId, i);
        }
        
        // 6. Connect Num Tracks output to mixer's Num Tracks Mod input
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
        
        // 7. Connect Track Mixer to main output
        auto outputNodeId = synth->getOutputNodeID();
        synth->connect(mixerNodeId, 0, outputNodeId, 0); // L
        synth->connect(mixerNodeId, 1, outputNodeId, 1); // R
        
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                " tracks: MIDI Player → PolyVCO → Track Mixer → Output");
    }
    if (requestType == 2 || requestType == 3) // Samplers or Both
    {
        float samplerX = playerPos.x + 400.0f;
        float mixerX = playerPos.x + 700.0f;
        
        // If PolyVCO mode (Both), offset samplers and use same mixer
        if (requestType == 3)
        {
            samplerX += 300.0f; // Offset samplers if PolyVCO exists
            // Reuse existing mixer created in PolyVCO section
        }
        else
        {
            // 1. Create Track Mixer for Samplers-only mode
            auto mixerNodeId = synth->addModule("track_mixer");
            mixerLid = synth->getLogicalIdForNode(mixerNodeId);
            pendingNodeScreenPositions[(int)mixerLid] = ImVec2(mixerX, playerPos.y);
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        }
        
        // 2. Create samplers and connect
        // Connect ALL tracks, regardless of whether they have notes
        auto mixerNodeId = synth->getNodeIdForLogical(mixerLid);
        int trackIdx = 0;
        int totalTracks = (int)notesByTrack.size();
        int mixerStartChannel = (requestType == 3) ? totalTracks : 0; // Offset for "Both" mode
        
        for (size_t i = 0; i < notesByTrack.size(); ++i)
        {
            // Create SampleLoader
            float samplerY = playerPos.y + (trackIdx * 150.0f);
            auto samplerNodeId = synth->addModule("sample_loader");
            juce::uint32 samplerLid = synth->getLogicalIdForNode(samplerNodeId);
            pendingNodeScreenPositions[(int)samplerLid] = ImVec2(samplerX, samplerY);
            
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiTrigPin = trackIdx * 4 + 3;
            
            // Connect MIDI Player to Sampler
            synth->connect(midiPlayerNodeId, midiPitchPin, samplerNodeId, 0);
            synth->connect(midiPlayerNodeId, midiGatePin, samplerNodeId, 2);
            synth->connect(midiPlayerNodeId, midiTrigPin, samplerNodeId, 3);
            
            // Connect Sampler output to Track Mixer input
            synth->connect(samplerNodeId, 0, mixerNodeId, mixerStartChannel + trackIdx);
            
            trackIdx++;
        }
        
        // 3. Connect Num Tracks to mixer and route to output (only if not already done in PolyVCO mode)
        if (requestType != 3)
        {
            synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                           mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
            
            // 4. Connect Track Mixer to output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(mixerNodeId, 0, outputNodeId, 0);
            synth->connect(mixerNodeId, 1, outputNodeId, 1);
            
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Complete chain: " + juce::String(trackIdx) + 
                                    " SampleLoaders → Track Mixer (with Num Tracks) → Stereo Output");
        }
        else
        {
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                    " SampleLoaders → Track Mixer (channels " + juce::String(mixerStartChannel) + 
                                    "-" + juce::String(mixerStartChannel + trackIdx - 1) + 
                                    ") [Mixer already connected in PolyVCO section]");
        }
    }
    
    // Commit changes
    if (synth)
    {
        synth->commitChanges();
        graphNeedsRebuild = true;
    }
    
    pushSnapshot();
}

void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        const int numSelected = ImNodes::NumSelectedLinks();
        const bool isMultiInsert = numSelected > 1;

        // --- Module Insertion on Cables (Organized by Category) ---
        // Map format: {Display Name, Internal Type}
        // Internal types use lowercase with underscores for spaces
        const std::map<const char*, const char*> audioInsertable = {
            // Effects
            {"VCF", "vcf"}, {"Delay", "delay"}, {"Reverb", "reverb"},
            {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
            {"Limiter", "limiter"}, {"Noise Gate", "gate"}, {"Drive", "drive"},
            {"Bit Crusher", "bit_crusher"}, {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"}, 
            {"8-Band Shaper", "8bandshaper"}, {"Granulator", "granulator"}, 
            {"Harmonic Shaper", "harmonic_shaper"}, {"Time/Pitch Shifter", "timepitch"},
            {"De-Crackle", "de_crackle"},
            // Utilities
            {"VCA", "vca"}, {"Mixer", "mixer"}, {"Attenuverter", "attenuverter"},
            {"Reroute", "reroute"},
            // Modulators
            {"Function Generator", "function_generator"}, {"Shaping Oscillator", "shaping_oscillator"},
            // TTS
            {"Vocal Tract Filter", "vocal_tract_filter"},
            // Analysis
            {"Scope", "scope"}, {"Frequency Graph", "frequency_graph"}
        };
        const std::map<const char*, const char*> modInsertable = {
            // Utilities
            {"Attenuverter", "attenuverter"}, {"Lag Processor", "lag_processor"}, 
            {"Math", "math"}, {"Map Range", "map_range"}, {"Quantizer", "quantizer"},
            {"Rate", "rate"}, {"Comparator", "comparator"}, {"Logic", "logic"},
            {"Reroute", "reroute"},
            {"CV Mixer", "cv_mixer"}, {"PanVol", "panvol"}, {"Sequential Switch", "sequential_switch"},
            // Modulators
            {"S&H", "s_and_h"}, {"Function Generator", "function_generator"},
            // Sequencers
            {"Timeline", "timeline"}
        };
        const std::map<const char*, const char*> videoInsertable = {
            // Computer Vision (Video processing)
            // Passthrough nodes (Video In → Video Out)
            {"Video FX", "video_fx"}, {"Crop Video", "crop_video"},
            {"Reroute", "reroute"},
            {"Movement Detector", "movement_detector"},
            {"Object Detector", "object_detector"},
            {"Pose Estimator", "pose_estimator"}, {"Hand Tracker", "hand_tracker"},
            {"Face Tracker", "face_tracker"}, {"Color Tracker", "color_tracker"},
            {"Contour Detector", "contour_detector"}
        };
        
        // Determine which list to show based on cable type
        const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
        const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
        const bool isVideoCable = (srcType == PinDataType::Video && dstType == PinDataType::Video);
        const auto& listToShow = isVideoCable ? videoInsertable : (linkToInsertOn.isMod ? modInsertable : audioInsertable);

        if (isMultiInsert)
            ImGui::Text("Insert Node on %d Cables", numSelected);
        else
            ImGui::Text("Insert Node on Cable");

        // --- FIX: Iterate over map pairs instead of simple strings ---
        for (const auto& pair : listToShow)
        {
            // pair.first = display label, pair.second = internal type
            if (ImGui::MenuItem(pair.first))
            {
                if (isMultiInsert)
                {
                    handleInsertNodeOnSelectedLinks(pair.second);
                }
                else
                {
                    insertNodeBetween(pair.second);
                }
                ImGui::CloseCurrentPopup();
            }
        }
        
        // VST Plugins submenu (only for audio cables, not video cables)
        if (!linkToInsertOn.isMod && !isVideoCable)
        {
            ImGui::Separator();
            if (ImGui::BeginMenu("VST"))
            {
                auto& app = PresetCreatorApplication::getApp();
                auto& knownPluginList = app.getKnownPluginList();
                auto& formatManager = app.getPluginFormatManager();
                
                // Get the VST folder at exe position
                juce::File exeDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
                juce::File vstFolder = exeDir.getChildFile("VST");
                
                // Get all plugins and filter/deduplicate
                const auto& allPlugins = knownPluginList.getTypes();
                
                // Filter to only plugins in the VST folder and deduplicate
                std::vector<juce::PluginDescription> filteredPlugins;
                std::set<juce::String> seenPlugins; // Use name + manufacturer as unique key
                
                for (const auto& desc : allPlugins)
                {
                    // Check if plugin is in the VST folder at exe position
                    juce::File pluginFile(desc.fileOrIdentifier);
                    if (!pluginFile.existsAsFile())
                        continue;
                        
                    juce::File pluginDir = pluginFile.getParentDirectory();
                    if (!pluginDir.isAChildOf(vstFolder) && pluginDir != vstFolder)
                        continue;
                    
                    // Create unique key for deduplication (name + manufacturer)
                    juce::String uniqueKey = desc.name + "|" + desc.manufacturerName;
                    if (seenPlugins.find(uniqueKey) != seenPlugins.end())
                        continue; // Skip duplicate
                    
                    seenPlugins.insert(uniqueKey);
                    filteredPlugins.push_back(desc);
                }
                
                // Use PushID to create unique IDs for each plugin
                ImGui::PushID("InsertVSTList");
                int pluginIndex = 0;
                for (const auto& desc : filteredPlugins)
                {
                    ImGui::PushID(pluginIndex++);
                    juce::String menuLabel = desc.name;
                    if (desc.manufacturerName.isNotEmpty())
                    {
                        menuLabel += " (" + desc.manufacturerName + ")";
                    }
                    
                    if (ImGui::MenuItem(menuLabel.toRawUTF8()))
                    {
                        if (isMultiInsert)
                        {
                            handleInsertNodeOnSelectedLinks(desc.name);
                        }
                        else
                        {
                            insertNodeBetween(desc.name);
                        }
                        ImGui::CloseCurrentPopup();
                    }
                    
                    // Show tooltip with plugin info
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
                        ImGui::Text("Version: %s", desc.version.toRawUTF8());
                        ImGui::EndTooltip();
                    }
                    
                    ImGui::PopID(); // Pop plugin index ID
                }
                ImGui::PopID(); // Pop InsertVSTList ID
                
                if (filteredPlugins.empty())
                {
                    ImGui::TextDisabled("No plugins in VST folder");
                }
                
                ImGui::EndMenu();
            }
        }
        
        ImGui::EndPopup();
    }
    else
    {
        // --- FIX: Reset state when popup is closed ---
        // If the popup is not open (i.e., it was closed or the user clicked away),
        // we must reset the state variable. This ensures that the application
        // is no longer "stuck" in the insert-on-link mode and right-click on
        // empty canvas will work again.
        linkToInsertOn.linkId = -1;
    }
}
void ImGuiNodeEditorComponent::drawLinkInspectorTooltip(const LinkInfo& link)
{
    if (synth == nullptr) return;
    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    
    // Get the probe scope processor
    auto* scope = synth->getProbeScopeProcessor();
    if (scope == nullptr) return;

    // Get the statistics from the scope module
    float minVal, maxVal;
    scope->getStatistics(minVal, maxVal);

    // Get the scope buffer for waveform
    const auto& scopeBuffer = scope->getScopeBuffer();

    // Draw the text info
    ImGui::Text("Inspecting: %s", link.pinName.toRawUTF8());
    ImGui::Text("From: %s (ID %d)", link.sourceNodeName.toRawUTF8(), (int)link.srcNodeId);
    ImGui::Text("Pin: %s", link.pinName.toRawUTF8());
    
    ImGui::Separator();
    
    juce::String peakMaxText = juce::String::formatted("Peak Max: %.3f", maxVal);
    juce::String peakMinText = juce::String::formatted("Peak Min: %.3f", minVal);
    ThemeText(peakMaxText.toRawUTF8(), theme.modules.scope_text_max);
    ThemeText(peakMinText.toRawUTF8(), theme.modules.scope_text_min);
    
    float peakToPeak = maxVal - minVal;
    ImGui::Text("P-P: %.3f", peakToPeak);
    
    float dBMax = maxVal > 0.0001f ? 20.0f * std::log10(maxVal) : -100.0f;
    ImGui::Text("Max dBFS: %.1f", dBMax);

    ImGui::Separator();

    // Draw the waveform using ImGui PlotLines
    const int numSamples = scopeBuffer.getNumSamples();
    if (scopeBuffer.getNumChannels() > 0 && numSamples > 0)
    {
        const float* samples = scopeBuffer.getReadPointer(0);
        ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 80.0f);
        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
    }
}
// --- NEW HELPER FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position)
{
    if (synth == nullptr) return;

    PinDataType srcType = getPinDataTypeForPin(linkInfo.srcPin);
    PinDataType dstType = getPinDataTypeForPin(linkInfo.dstPin);

    // 1. Create and Position the New Node
    // Check if this is a VST plugin by checking against known plugins
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    // Get the VST folder at exe position for filtering
    juce::File exeDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File vstFolder = exeDir.getChildFile("VST");
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // Check if plugin is in the VST folder at exe position
            juce::File pluginFile(desc.fileOrIdentifier);
            if (pluginFile.existsAsFile())
            {
                juce::File pluginDir = pluginFile.getParentDirectory();
                if (pluginDir.isAChildOf(vstFolder) || pluginDir == vstFolder)
                {
                    // This is a VST plugin - use addVstModule
                    newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
                    if (newNodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[InsertNode] ERROR: Failed to create VST module: " + desc.name);
                        return; // Don't disconnect if node creation failed
                    }
                    isVst = true;
                    break;
                }
            }
        }
    }
    
    if (!isVst)
    {
        // Regular module - use addModule
        newNodeId = synth->addModule(nodeType);
        if (newNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[InsertNode] ERROR: Failed to create module: " + nodeType);
            return; // Don't disconnect if node creation failed
        }
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    if (newNodeLid == 0)
    {
        juce::Logger::writeToLog("[InsertNode] ERROR: Failed to get logical ID for new node");
        return; // Don't disconnect if we can't get logical ID
    }
    
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    if (!linkInfo.srcPin.isMod)
    {
        if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
            reroute->setPassthroughType(srcType);
    }

    // 2. Get Original Connection Points
    auto originalSrcNodeId = synth->getNodeIdForLogical(linkInfo.srcPin.logicalId);
    auto originalDstNodeId = (linkInfo.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkInfo.dstPin.logicalId);

    // 3. Disconnect the Original Link (only after node is confirmed created)
    synth->disconnect(originalSrcNodeId, linkInfo.srcPin.channel, originalDstNodeId, linkInfo.dstPin.channel);

    // 4. Configure newly inserted node if necessary (e.g., MapRange)
    int newNodeOutputChannel = 0;
    if (nodeType == "map_range")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(linkInfo.srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    // 5. Reconnect through the New Node
    synth->connect(originalSrcNodeId, linkInfo.srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, linkInfo.dstPin.channel);

    if (getTypeForLogical(newNodeLid).equalsIgnoreCase("reroute"))
        updateRerouteTypeFromConnections((juce::uint32)newNodeLid);
}
void ImGuiNodeEditorComponent::insertNodeOnLinkStereo(const juce::String& nodeType, 
                                                       const LinkInfo& linkLeft, 
                                                       const LinkInfo& linkRight, 
                                                       const ImVec2& position)
{
    if (synth == nullptr) return;

    juce::Logger::writeToLog("[InsertStereo] Inserting stereo node: " + nodeType);
    juce::Logger::writeToLog("[InsertStereo] Left cable: " + juce::String(linkLeft.srcPin.logicalId) + 
                            " ch" + juce::String(linkLeft.srcPin.channel) + " -> " + 
                            juce::String(linkLeft.dstPin.logicalId) + " ch" + juce::String(linkLeft.dstPin.channel));
    juce::Logger::writeToLog("[InsertStereo] Right cable: " + juce::String(linkRight.srcPin.logicalId) + 
                            " ch" + juce::String(linkRight.srcPin.channel) + " -> " + 
                            juce::String(linkRight.dstPin.logicalId) + " ch" + juce::String(linkRight.dstPin.channel));

    // 1. Create ONE node for both channels
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    // Get the VST folder at exe position for filtering
    juce::File exeDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File vstFolder = exeDir.getChildFile("VST");
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // Check if plugin is in the VST folder at exe position
            juce::File pluginFile(desc.fileOrIdentifier);
            if (pluginFile.existsAsFile())
            {
                juce::File pluginDir = pluginFile.getParentDirectory();
                if (pluginDir.isAChildOf(vstFolder) || pluginDir == vstFolder)
                {
                    newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
                    if (newNodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[InsertNode] ERROR: Failed to create VST module: " + desc.name);
                        return; // Don't disconnect if node creation failed
                    }
                    isVst = true;
                    break;
                }
            }
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
        if (newNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[InsertNode] ERROR: Failed to create module: " + nodeType);
            return; // Don't disconnect if node creation failed
        }
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    if (newNodeLid == 0)
    {
        juce::Logger::writeToLog("[InsertNode] ERROR: Failed to get logical ID for new stereo node");
        return; // Don't disconnect if we can't get logical ID
    }
    
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points for LEFT cable (first cable)
    auto leftSrcNodeId = synth->getNodeIdForLogical(linkLeft.srcPin.logicalId);
    auto leftDstNodeId = (linkLeft.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkLeft.dstPin.logicalId);

    // 3. Get Original Connection Points for RIGHT cable (second cable)
    auto rightSrcNodeId = synth->getNodeIdForLogical(linkRight.srcPin.logicalId);
    auto rightDstNodeId = (linkRight.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkRight.dstPin.logicalId);

    // 4. Disconnect BOTH Original Links (only after node is confirmed created)
    synth->disconnect(leftSrcNodeId, linkLeft.srcPin.channel, leftDstNodeId, linkLeft.dstPin.channel);
    synth->disconnect(rightSrcNodeId, linkRight.srcPin.channel, rightDstNodeId, linkRight.dstPin.channel);

    // 5. Reconnect Through the New Node
    // Left cable -> new node's LEFT input (ch0)
    bool leftInConnected = synth->connect(leftSrcNodeId, linkLeft.srcPin.channel, newNodeId, 0);
    
    // Right cable -> new node's RIGHT input (ch1)
    bool rightInConnected = synth->connect(rightSrcNodeId, linkRight.srcPin.channel, newNodeId, 1);
    
    // New node's outputs -> original destinations
    // Note: We'll connect both outputs to their respective destinations
    bool leftOutConnected = synth->connect(newNodeId, 0, leftDstNodeId, linkLeft.dstPin.channel);
    bool rightOutConnected = synth->connect(newNodeId, 1, rightDstNodeId, linkRight.dstPin.channel);

    if (leftInConnected && rightInConnected && leftOutConnected && rightOutConnected)
    {
        juce::Logger::writeToLog("[InsertStereo] Successfully inserted stereo node: both channels connected");
    }
    else
    {
        juce::Logger::writeToLog("[InsertStereo] WARNING: Some connections failed - leftIn=" + juce::String(leftInConnected ? 1 : 0) +
                                ", rightIn=" + juce::String(rightInConnected ? 1 : 0) +
                                ", leftOut=" + juce::String(leftOutConnected ? 1 : 0) +
                                ", rightOut=" + juce::String(rightOutConnected ? 1 : 0));
    }
}
void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin, bool createUndoSnapshot)
{
    if (synth == nullptr)
        return;

    PinDataType srcType = getPinDataTypeForPin(srcPin);
    PinDataType dstType = getPinDataTypeForPin(dstPin);

    ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(srcPin.logicalId);
    ImVec2 dstPos = ImNodes::GetNodeGridSpacePos(dstPin.logicalId == 0 ? 0 : dstPin.logicalId);
    ImVec2 newNodePos = ImVec2((srcPos.x + dstPos.x) * 0.5f, (srcPos.y + dstPos.y) * 0.5f);

    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;

    // Get the VST folder at exe position for filtering
    juce::File exeDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File vstFolder = exeDir.getChildFile("VST");

    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // Check if plugin is in the VST folder at exe position
            juce::File pluginFile(desc.fileOrIdentifier);
            if (pluginFile.existsAsFile())
            {
                juce::File pluginDir = pluginFile.getParentDirectory();
                if (pluginDir.isAChildOf(vstFolder) || pluginDir == vstFolder)
                {
                    newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
                    if (newNodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[InsertNode] ERROR: Failed to create VST module: " + desc.name);
                        return; // Don't disconnect if node creation failed
                    }
                    isVst = true;
                    break;
                }
            }
        }
    }

    if (! isVst)
    {
        newNodeId = synth->addModule(nodeType);
        if (newNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[InsertNode] ERROR: Failed to create module: " + nodeType);
            return; // Don't disconnect if node creation failed
        }
    }

    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    if (newNodeLid == 0)
    {
        juce::Logger::writeToLog("[InsertNode] ERROR: Failed to get logical ID for new node");
        return; // Don't disconnect if we can't get logical ID
    }
    
    pendingNodePositions[(int)newNodeLid] = newNodePos;

    if (!srcPin.isMod)
    {
        if (auto* reroute = dynamic_cast<RerouteModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
            reroute->setPassthroughType(srcType);
    }

    auto originalSrcNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
    auto originalDstNodeId = (dstPin.logicalId == 0)
        ? synth->getOutputNodeID()
        : synth->getNodeIdForLogical(dstPin.logicalId);

    int newNodeOutputChannel = 0;
    if (nodeType == "map_range")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    synth->connect(originalSrcNodeId, srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, dstPin.channel);

    if (getTypeForLogical(newNodeLid).equalsIgnoreCase("reroute"))
        updateRerouteTypeFromConnections((juce::uint32)newNodeLid);

    juce::Logger::writeToLog("[AutoConvert] Inserted '" + nodeType + "' between "
                             + juce::String(srcPin.logicalId) + " and " + juce::String(dstPin.logicalId));

    if (createUndoSnapshot)
    {
        pushSnapshot();
        graphNeedsRebuild = true;
    }
}

void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType)
{
    if (linkToInsertOn.linkId != -1)
    {
        insertNodeOnLink(nodeType, linkToInsertOn, ImGui::GetMousePos());
        graphNeedsRebuild = true;
        pushSnapshot();
        linkToInsertOn.linkId = -1;
    }
}
void ImGuiNodeEditorComponent::handleInsertNodeOnSelectedLinks(const juce::String& nodeType)
{
    if (synth == nullptr || ImNodes::NumSelectedLinks() == 0)
        return;

    pushSnapshot();

    const int numSelectedLinks = ImNodes::NumSelectedLinks();
    std::vector<int> selectedLinkIds(numSelectedLinks);
    ImNodes::GetSelectedLinks(selectedLinkIds.data());

    ImVec2 basePosition = ImGui::GetMousePos();
    float xOffset = 0.0f;

    if (numSelectedLinks == 2)
    {
        auto it0 = linkIdToAttrs.find(selectedLinkIds[0]);
        auto it1 = linkIdToAttrs.find(selectedLinkIds[1]);

        if (it0 != linkIdToAttrs.end() && it1 != linkIdToAttrs.end())
        {
            LinkInfo firstLink;
            firstLink.linkId = selectedLinkIds[0];
            firstLink.srcPin = decodePinId(it0->second.first);
            firstLink.dstPin = decodePinId(it0->second.second);
            firstLink.isMod = firstLink.srcPin.isMod || firstLink.dstPin.isMod;

            LinkInfo secondLink;
            secondLink.linkId = selectedLinkIds[1];
            secondLink.srcPin = decodePinId(it1->second.first);
            secondLink.dstPin = decodePinId(it1->second.second);
            secondLink.isMod = secondLink.srcPin.isMod || secondLink.dstPin.isMod;

            if (!firstLink.isMod && !secondLink.isMod)
            {
                auto isStereoCandidate = [&]() -> bool
                {
                    // Both links must be from the same source node
                    if (firstLink.srcPin.logicalId != secondLink.srcPin.logicalId)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: different source nodes");
                        return false;
                    }

                    // Both links must go to the same destination (or both to main output)
                    const bool bothToMainOutput = (firstLink.dstPin.logicalId == 0 && secondLink.dstPin.logicalId == 0);
                    if (!bothToMainOutput && firstLink.dstPin.logicalId != secondLink.dstPin.logicalId)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: different destination nodes");
                        return false;
                    }

                    // Source channels should be consecutive (0-1, 1-2, etc.) for stereo
                    const int srcDelta = std::abs(firstLink.srcPin.channel - secondLink.srcPin.channel);
                    const int dstDelta = std::abs(firstLink.dstPin.channel - secondLink.dstPin.channel);
                    
                    // For stereo, we expect channels 0 and 1, but allow other consecutive pairs
                    if (srcDelta != 1)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: source channels not consecutive (delta=" + juce::String(srcDelta) + ")");
                        return false;
                    }
                    
                    // Destination channels should also be consecutive
                    if (dstDelta != 1)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: destination channels not consecutive (delta=" + juce::String(dstDelta) + ")");
                        return false;
                    }

                    // All pins must be audio type
                    const auto srcTypeA = getPinDataTypeForPin(firstLink.srcPin);
                    const auto srcTypeB = getPinDataTypeForPin(secondLink.srcPin);
                    const auto dstTypeA = getPinDataTypeForPin(firstLink.dstPin);
                    const auto dstTypeB = getPinDataTypeForPin(secondLink.dstPin);
                    const bool allAudio = srcTypeA == PinDataType::Audio && srcTypeB == PinDataType::Audio
                                          && dstTypeA == PinDataType::Audio && dstTypeB == PinDataType::Audio;
                    
                    if (!allAudio)
                    {
                        juce::Logger::writeToLog("[InsertNode] Not stereo: not all audio pins");
                        return false;
                    }

                    juce::Logger::writeToLog("[InsertNode] Detected stereo pair: ch" + juce::String(firstLink.srcPin.channel) + 
                                            " and ch" + juce::String(secondLink.srcPin.channel));
                    return true;
                };

                if (isStereoCandidate())
                {
                    LinkInfo leftLink = firstLink;
                    LinkInfo rightLink = secondLink;
                    
                    // Ensure left link has the lower channel number
                    if (rightLink.srcPin.channel < leftLink.srcPin.channel)
                        std::swap(leftLink, rightLink);

                    juce::Logger::writeToLog("[InsertNode] Inserting STEREO node: left=ch" + juce::String(leftLink.srcPin.channel) + 
                                            ", right=ch" + juce::String(rightLink.srcPin.channel));
                    insertNodeOnLinkStereo(nodeType, leftLink, rightLink, basePosition);
                    juce::Logger::writeToLog("[InsertNode] Successfully inserted STEREO node for 2 selected audio cables");
                    graphNeedsRebuild = true;
                    return;
                }
            }
        }
    }

    std::set<int> processedLinks;

    for (int linkId : selectedLinkIds)
    {
        if (processedLinks.count(linkId) != 0)
            continue;

        auto it = linkIdToAttrs.find(linkId);
        if (it == linkIdToAttrs.end())
            continue;

        LinkInfo link;
        link.linkId = linkId;
        link.srcPin = decodePinId(it->second.first);
        link.dstPin = decodePinId(it->second.second);
        link.isMod = link.srcPin.isMod || link.dstPin.isMod;

        ImVec2 newPosition(basePosition.x + xOffset, basePosition.y);
        insertNodeOnLink(nodeType, link, newPosition);
        processedLinks.insert(linkId);
        juce::Logger::writeToLog("[InsertNode] Inserted MONO node for link " + juce::String(linkId));

        xOffset += 40.0f;
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::expandMetaModule(juce::uint32 metaLogicalId)
{
    if (!synth)
        return;

    const auto metaNodeId = synth->getNodeIdForLogical(metaLogicalId);
    if (metaNodeId.uid == 0)
        return;

    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule == nullptr)
        return;

    const auto metaState = metaModule->getExtraStateTree();
    const juce::String encoded = metaState.getProperty("internalGraphState").toString();
    if (encoded.isEmpty())
    {
        NotificationManager::post(NotificationManager::Type::Warning, "Meta module has no internal patch to expand.");
        return;
    }

    juce::MemoryOutputStream decoded;
    if (!juce::Base64::convertFromBase64(decoded, encoded))
    {
        NotificationManager::post(NotificationManager::Type::Warning, "Failed to decode meta module state.");
        return;
    }

    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(decoded.toString()));
    if (xml == nullptr)
        return;

    juce::ValueTree internalRoot = juce::ValueTree::fromXml(*xml);
    auto modulesVT = internalRoot.getChildWithName("modules");
    auto connsVT = internalRoot.getChildWithName("connections");
    if (!modulesVT.isValid() || !connsVT.isValid())
        return;

    pushSnapshot();

    struct CollapsedInlet { int oldId{}; int pinIndex{}; int channelCount{1}; juce::uint32 externalLogicalId{}; int externalChannel{}; int metaChannel{}; };
    struct CollapsedOutlet { int oldId{}; int pinIndex{}; int channelCount{1}; juce::uint32 externalLogicalId{}; int externalChannel{}; bool externalIsOutput{}; int metaChannel{}; };
    struct InternalConnection { int srcId; int srcChan; int dstId; int dstChan; };
    struct InboundConnection { int inletOldId; int dstId; int dstChan; };
    struct OutboundConnection { int srcId; int srcChan; int outletOldId; };

    std::vector<CollapsedInlet> collapsedInlets;
    std::vector<CollapsedOutlet> collapsedOutlets;
    std::vector<InternalConnection> internalConnections;
    std::vector<InboundConnection> inboundConnections;
    std::vector<OutboundConnection> outboundConnections;
    std::map<int, juce::uint32> oldToNew;
    std::vector<juce::uint32> createdLogicalIds;

    auto readChannelCount = [](const juce::ValueTree& moduleVT, const juce::Identifier& paramId) -> int
    {
        if (auto paramsWrapper = moduleVT.getChildWithName("params"); paramsWrapper.isValid())
        {
            if (paramsWrapper.getNumChildren() > 0)
            {
                auto params = paramsWrapper.getChild(0);
                for (int i = 0; i < params.getNumChildren(); ++i)
                {
                    auto paramNode = params.getChild(i);
                    if (paramNode.getProperty("id").toString().equalsIgnoreCase(paramId.toString()))
                        return (int)paramNode.getProperty("value", 1.0);
                }
            }
        }
        return 1;
    };

    std::unordered_set<int> inletIds;
    std::unordered_set<int> outletIds;

    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleVT = modulesVT.getChild(i);
        if (!moduleVT.hasType("module"))
            continue;

        const int oldId = (int)moduleVT.getProperty("logicalId", 0);
        const juce::String type = moduleVT.getProperty("type").toString();

        auto extraWrapper = moduleVT.getChildWithName("extra");
        auto extraState = (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0) ? extraWrapper.getChild(0) : juce::ValueTree();

        if (type.equalsIgnoreCase("inlet"))
        {
            CollapsedInlet inlet;
            inlet.oldId = oldId;
            inlet.pinIndex = (int)extraState.getProperty("pinIndex", (int)collapsedInlets.size());
            inlet.channelCount = readChannelCount(moduleVT, InletModuleProcessor::paramIdChannelCount);
            inlet.externalLogicalId = (juce::uint32)(int)extraState.getProperty("externalLogicalId", 0);
            inlet.externalChannel = (int)extraState.getProperty("externalChannel", 0);
            collapsedInlets.push_back(inlet);
            inletIds.insert(oldId);
            continue;
        }

        if (type.equalsIgnoreCase("outlet"))
        {
            CollapsedOutlet outlet;
            outlet.oldId = oldId;
            outlet.pinIndex = (int)extraState.getProperty("pinIndex", (int)collapsedOutlets.size());
            outlet.channelCount = readChannelCount(moduleVT, OutletModuleProcessor::paramIdChannelCount);
            outlet.externalLogicalId = (juce::uint32)(int)extraState.getProperty("externalLogicalId", 0);
            outlet.externalChannel = (int)extraState.getProperty("externalChannel", 0);
            outlet.externalIsOutput = (bool)(int)extraState.getProperty("externalIsOutput", outlet.externalLogicalId == 0 ? 1 : 0);
            collapsedOutlets.push_back(outlet);
            outletIds.insert(oldId);
            continue;
        }

        const auto nodeId = synth->addModule(type);
        const juce::uint32 newLogical = synth->getLogicalIdForNode(nodeId);
        oldToNew[oldId] = newLogical;
        createdLogicalIds.push_back(newLogical);

        if (auto* module = synth->getModuleForLogical(newLogical))
        {
            if (auto paramsWrapper = moduleVT.getChildWithName("params"); paramsWrapper.isValid())
                if (paramsWrapper.getNumChildren() > 0)
                    module->getAPVTS().replaceState(paramsWrapper.getChild(0));
            if (extraState.isValid())
                module->setExtraStateTree(extraState);
        }
    }

    for (int i = 0; i < connsVT.getNumChildren(); ++i)
    {
        auto cv = connsVT.getChild(i);
        if (!cv.hasType("connection"))
            continue;

        const int srcId = (int)cv.getProperty("srcId", 0);
        const int dstId = (int)cv.getProperty("dstId", 0);
        const int srcChan = (int)cv.getProperty("srcChan", 0);
        const int dstChan = (int)cv.getProperty("dstChan", 0);

        const bool srcIsInlet = inletIds.count(srcId) > 0;
        const bool dstIsOutlet = outletIds.count(dstId) > 0;

        if (srcIsInlet && !dstIsOutlet)
            inboundConnections.push_back({ srcId, dstId, dstChan });
        else if (!srcIsInlet && dstIsOutlet)
            outboundConnections.push_back({ srcId, srcChan, dstId });
        else if (!srcIsInlet && !dstIsOutlet)
            internalConnections.push_back({ srcId, srcChan, dstId, dstChan });
    }

    std::sort(collapsedInlets.begin(), collapsedInlets.end(), [](const CollapsedInlet& a, const CollapsedInlet& b)
    {
        if (a.pinIndex != b.pinIndex)
            return a.pinIndex < b.pinIndex;
        return a.oldId < b.oldId;
    });

    int runningChannel = 0;
    for (auto& inlet : collapsedInlets)
    {
        inlet.metaChannel = runningChannel;
        runningChannel += inlet.channelCount;
    }

    std::sort(collapsedOutlets.begin(), collapsedOutlets.end(), [](const CollapsedOutlet& a, const CollapsedOutlet& b)
    {
        if (a.pinIndex != b.pinIndex)
            return a.pinIndex < b.pinIndex;
        return a.oldId < b.oldId;
    });

    runningChannel = 0;
    for (auto& outlet : collapsedOutlets)
    {
        outlet.metaChannel = runningChannel;
        runningChannel += outlet.channelCount;
    }

    std::unordered_map<int, std::pair<juce::uint32, int>> metaInputs;
    std::unordered_map<int, std::tuple<juce::uint32, int, bool>> metaOutputs;

    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstLogicalId == metaLogicalId && !c.dstIsOutput)
            metaInputs.emplace(c.dstChan, std::make_pair(c.srcLogicalId, c.srcChan));
        if (c.srcLogicalId == metaLogicalId)
            metaOutputs.emplace(c.srcChan, std::make_tuple(c.dstLogicalId, c.dstChan, c.dstIsOutput));
    }

    for (auto& inlet : collapsedInlets)
    {
        if (inlet.externalLogicalId == 0 && metaInputs.count(inlet.metaChannel) > 0)
        {
            auto external = metaInputs[inlet.metaChannel];
            inlet.externalLogicalId = external.first;
            inlet.externalChannel = external.second;
        }
    }

    for (auto& outlet : collapsedOutlets)
    {
        if (metaOutputs.count(outlet.metaChannel) > 0)
        {
            auto external = metaOutputs[outlet.metaChannel];
            if ((outlet.externalLogicalId == 0 || std::get<0>(external) != 0))
                outlet.externalLogicalId = std::get<0>(external);
            outlet.externalChannel = std::get<1>(external);
            outlet.externalIsOutput = std::get<2>(external) || outlet.externalLogicalId == 0;
        }
    }

    std::unordered_map<int, CollapsedInlet> inletLookup;
    for (const auto& inlet : collapsedInlets)
        inletLookup.emplace(inlet.oldId, inlet);

    std::unordered_map<int, CollapsedOutlet> outletLookup;
    for (const auto& outlet : collapsedOutlets)
        outletLookup.emplace(outlet.oldId, outlet);

    for (const auto& conn : internalConnections)
    {
        auto srcIt = oldToNew.find(conn.srcId);
        auto dstIt = oldToNew.find(conn.dstId);
        if (srcIt == oldToNew.end() || dstIt == oldToNew.end())
            continue;

        auto srcNode = synth->getNodeIdForLogical(srcIt->second);
        auto dstNode = synth->getNodeIdForLogical(dstIt->second);
        if (srcNode.uid == 0 || dstNode.uid == 0)
            continue;

        synth->connect(srcNode, conn.srcChan, dstNode, conn.dstChan);
    }

    for (const auto& inbound : inboundConnections)
    {
        auto inletIt = inletLookup.find(inbound.inletOldId);
        auto dstIt = oldToNew.find(inbound.dstId);
        if (inletIt == inletLookup.end() || dstIt == oldToNew.end())
            continue;

        const auto& inlet = inletIt->second;
        if (inlet.externalLogicalId == 0)
            continue;

        auto srcNode = synth->getNodeIdForLogical(inlet.externalLogicalId);
        auto dstNode = synth->getNodeIdForLogical(dstIt->second);
        if (srcNode.uid == 0 || dstNode.uid == 0)
            continue;

        synth->connect(srcNode, inlet.externalChannel, dstNode, inbound.dstChan);
    }

    for (const auto& outbound : outboundConnections)
    {
        auto outletIt = outletLookup.find(outbound.outletOldId);
        auto srcIt = oldToNew.find(outbound.srcId);
        if (outletIt == outletLookup.end() || srcIt == oldToNew.end())
            continue;

        const auto& outlet = outletIt->second;
        auto srcNode = synth->getNodeIdForLogical(srcIt->second);
        if (srcNode.uid == 0)
            continue;

        juce::AudioProcessorGraph::NodeID dstNode;
        if (outlet.externalIsOutput || outlet.externalLogicalId == 0)
            dstNode = synth->getOutputNodeID();
        else
            dstNode = synth->getNodeIdForLogical(outlet.externalLogicalId);

        if (dstNode.uid == 0)
            continue;

        synth->connect(srcNode, outbound.srcChan, dstNode, outlet.externalChannel);
    }

    const ImVec2 metaPos = ImNodes::GetNodeGridSpacePos((int)metaLogicalId);
    synth->removeModule(metaNodeId);

    const float spacing = 160.0f;
    for (std::size_t idx = 0; idx < createdLogicalIds.size(); ++idx)
    {
        const auto lid = createdLogicalIds[idx];
        const int ix = (int)(idx % 4);
        const int iy = (int)(idx / 4);
        pendingNodePositions[(int)lid] = ImVec2(metaPos.x + ix * spacing, metaPos.y + iy * spacing);
    }

    selectedLogicalId = 0;
    graphNeedsRebuild = true;
    synth->commitChanges();

    NotificationManager::post(NotificationManager::Type::Info, "Expanded Meta Module");
}

juce::File ImGuiNodeEditorComponent::findPresetsDirectory()
{
    // Search upwards from the executable's location for a sibling directory
    // named "Synth_presets". This is robust to different build configurations.
    juce::File dir = juce::File::getSpecialLocation(juce::File::currentExecutableFile);

    for (int i = 0; i < 8; ++i) // Limit search depth to 8 levels
    {
        dir = dir.getParentDirectory();
        if (!dir.exists()) break;

        juce::File candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.isDirectory())
        {
            return candidate;
        }
    }
    
    // Fallback to an empty file (system default) if not found
    return {};
}
// Helper function implementations
PinDataType ImGuiNodeEditorComponent::getPinDataTypeForPin(const PinID& pin)
{
    if (synth == nullptr) return PinDataType::Raw;

    // Handle the main output node as a special case
    if (pin.logicalId == 0)
    {
        return PinDataType::Audio;
    }

    juce::String moduleType = getTypeForLogical(pin.logicalId);
    if (moduleType.isEmpty()) return PinDataType::Raw;

    // *** NEW: Check dynamic pins FIRST ***
    if (auto* module = synth->getModuleForLogical(pin.logicalId))
    {
        // Check dynamic input pins
        if (pin.isInput && !pin.isMod)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            for (const auto& dynPin : dynamicInputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
        // Check dynamic output pins
        else if (!pin.isInput && !pin.isMod)
        {
            auto dynamicOutputs = module->getDynamicOutputPins();
            for (const auto& dynPin : dynamicOutputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
    }
    // *** END NEW CODE ***

    auto it = getModulePinDatabase().find(moduleType);
    if (it == getModulePinDatabase().end())
    {
        // Fallback: case-insensitive lookup (module registry may use different casing)
        juce::String moduleTypeLower = moduleType.toLowerCase();
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0 || kv.first.toLowerCase() == moduleTypeLower)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
        if (it == getModulePinDatabase().end())
        {
            // If the module type is not in our static database, it's likely a VST plugin.
            // A safe assumption is that its pins are for audio.
            if (auto* module = synth->getModuleForLogical(pin.logicalId))
            {
                if (dynamic_cast<VstHostModuleProcessor*>(module))
                {
                    return PinDataType::Audio; // Green for VST pins
                }
            }
            return PinDataType::Raw;
        }
    }

    const auto& pinInfo = it->second;

    if (pin.isMod)
    {
        for (const auto& modPin : pinInfo.modIns)
        {
            if (modPin.paramId == pin.paramId)
            {
                return modPin.type;
            }
        }
    }
    else // It's an audio pin
    {
        const auto& pins = pin.isInput ? pinInfo.audioIns : pinInfo.audioOuts;
        for (const auto& audioPin : pins)
        {
            if (audioPin.channel == pin.channel)
            {
                return audioPin.type;
            }
        }
    }
    return PinDataType::Raw; // Fallback
}

unsigned int ImGuiNodeEditorComponent::getImU32ForType(PinDataType type)
{
	const ImU32 themedColor = ThemeManager::getInstance().getPinColor(type);
	if (themedColor != 0)
		return themedColor;

	switch (type)
	{
		case PinDataType::CV:    return IM_COL32(100, 150, 255, 255); // Blue
		case PinDataType::Audio: return IM_COL32(100, 255, 150, 255); // Green
		case PinDataType::Gate:  return IM_COL32(255, 220, 100, 255); // Yellow
		case PinDataType::Raw:   return IM_COL32(255, 100, 100, 255); // Red
		case PinDataType::Video: return IM_COL32(0, 200, 255, 255);   // Cyan
		default:                 return IM_COL32(150, 150, 150, 255); // Grey
	}
}

const char* ImGuiNodeEditorComponent::pinDataTypeToString(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return "CV (0 to 1)";
        case PinDataType::Audio: return "Audio (-1 to 1)";
        case PinDataType::Gate:  return "Gate/Trigger";
        case PinDataType::Raw:   return "Raw";
        case PinDataType::Video: return "Video Source";
        default:                 return "Unknown";
    }
}
std::vector<AudioPin> ImGuiNodeEditorComponent::getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType)
{
    std::vector<AudioPin> matchingPins;
    juce::String moduleType = getTypeForLogical(logicalId);

    if (moduleType.isEmpty())
    {
        return matchingPins;
    }

    // *** PRIORITIZE DYNAMIC PINS OVER STATIC PINS ***
    // Dynamic pins are more accurate and up-to-date for modules that provide them
    if (auto* module = synth->getModuleForLogical(logicalId))
    {
        // --- DYNAMIC PATH FOR MODULES WITH getDynamicInputPins/getDynamicOutputPins ---
        auto dynamicPins = isInput ? module->getDynamicInputPins() : module->getDynamicOutputPins();
        
        if (!dynamicPins.empty())
        {
            // Module provides dynamic pins - filter by type
            for (const auto& pin : dynamicPins)
            {
                if (pin.type == targetType)
                {
                    matchingPins.emplace_back(pin.name, pin.channel, pin.type);
                }
            }
        }
        else if (auto* vst = dynamic_cast<VstHostModuleProcessor*>(module))
        {
            // For VSTs without dynamic pins, assume all pins are 'Audio' type for chaining.
            if (targetType == PinDataType::Audio)
            {
                const int numChannels = isInput ? vst->getTotalNumInputChannels() : vst->getTotalNumOutputChannels();
                for (int i = 0; i < numChannels; ++i)
                {
                    juce::String pinName = isInput ? vst->getAudioInputLabel(i) : vst->getAudioOutputLabel(i);
                    if (pinName.isNotEmpty())
                    {
                        matchingPins.emplace_back(pinName, i, PinDataType::Audio);
                    }
                }
            }
        }
    }

    // If no dynamic pins matched, fall back to static pins from the database
    if (matchingPins.empty())
    {
        auto it = getModulePinDatabase().find(moduleType);

        // --- CASE-INSENSITIVE LOOKUP ---
        if (it == getModulePinDatabase().end())
        {
            for (const auto& kv : getModulePinDatabase())
            {
                if (kv.first.compareIgnoreCase(moduleType) == 0)
                {
                    it = getModulePinDatabase().find(kv.first);
                    break;
                }
            }
        }

        if (it != getModulePinDatabase().end())
        {
            // --- Standard path for built-in modules ---
            const auto& pins = isInput ? it->second.audioIns : it->second.audioOuts;
            for (const auto& pin : pins)
            {
                if (pin.type == targetType)
                {
                    matchingPins.push_back(pin);
                }
            }
        }
    }

    return matchingPins;
}

void ImGuiNodeEditorComponent::handleNodeChaining()
{
    if (synth == nullptr)
        return;

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
        return;

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    sortedNodes.reserve(selectedNodeIds.size());

    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0)
            continue;
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.emplace_back(pos.x, nodeId);
    }

    if (sortedNodes.size() <= 1)
        return;

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    pushSnapshot();

    for (size_t i = 0; i + 1 < sortedNodes.size(); ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
            continue;

        synth->connect(sourceNodeId, 0, destNodeId, 0);
        synth->connect(sourceNodeId, 1, destNodeId, 1);

        if (auto* destModule = synth->getModuleForLogical(destLid))
        {
            if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
            {
                if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                    recorder->updateSuggestedFilename(sourceModule->getName());
            }
        }
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleRecordOutput()
{
    if (!synth) return;

    pushSnapshot();
    juce::Logger::writeToLog("[Record Output] Initiated.");

    // 1. Find connections going to the main output node.
    std::vector<ModularSynthProcessor::ConnectionInfo> outputFeeds;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstIsOutput)
        {
            outputFeeds.push_back(c);
        }
    }

    if (outputFeeds.empty())
    {
        juce::Logger::writeToLog("[Record Output] No connections to main output found.");
        return;
    }

    // 2. Create and position the recorder.
    auto recorderNodeId = synth->addModule("recorder");
    auto recorderLid = synth->getLogicalIdForNode(recorderNodeId);
    ImVec2 outPos = ImNodes::GetNodeGridSpacePos(0);
    pendingNodePositions[(int)recorderLid] = ImVec2(outPos.x - 400.0f, outPos.y);
    
    auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical(recorderLid));
    if (recorder)
    {
        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
    }

    // 3. "Tap" the signals by connecting the original sources to the recorder.
    juce::String sourceName;
    for (const auto& feed : outputFeeds)
    {
        auto srcNodeId = synth->getNodeIdForLogical(feed.srcLogicalId);
        synth->connect(srcNodeId, feed.srcChan, recorderNodeId, feed.dstChan); // dstChan will be 0 or 1
        
        // Get the name of the first source for the filename prefix
        if (sourceName.isEmpty())
        {
            if (auto* srcModule = synth->getModuleForLogical(feed.srcLogicalId))
            {
                sourceName = srcModule->getName();
            }
        }
    }
    
    if (recorder)
    {
        recorder->updateSuggestedFilename(sourceName);
    }

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[Record Output] Recorder added and connected.");
}
void ImGuiNodeEditorComponent::handleColorCodedChaining(PinDataType targetType)
{
    if (synth == nullptr)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: synth is nullptr");
        return;
    }

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: numSelected <= 1 (" + juce::String(numSelected) + ")");
        return;
    }

    juce::Logger::writeToLog("[Color Chaining] Started for " + juce::String(toString(targetType)) + " with " + juce::String(numSelected) + " nodes");

    // 1. Get and sort selected nodes by their horizontal position.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0) continue; // Exclude the output node.
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    if (sortedNodes.empty())
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: No valid nodes after filtering");
        return;
    }

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    int totalConnectionsMade = 0;
    int totalConnectionAttempts = 0;

    // 2. Iterate through sorted nodes and connect matching pins.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[Color Chaining] Skipping invalid node pair: " + juce::String(sourceLid) + " -> " + juce::String(destLid));
            continue;
        }

        // Find all matching output pins on the source and input pins on the destination.
        auto sourcePins = getPinsOfType(sourceLid, false, targetType);
        auto destPins   = getPinsOfType(destLid, true, targetType);

        if (sourcePins.empty() || destPins.empty())
        {
            juce::Logger::writeToLog("[Color Chaining] No matching pins: " + juce::String(sourcePins.size()) + " src, " + juce::String(destPins.size()) + " dst");
            continue;
        }

        // Connect them one-to-one until we run out of available pins on either side.
        int connectionsToMake = std::min((int)sourcePins.size(), (int)destPins.size());

        for (int j = 0; j < connectionsToMake; ++j)
        {
            totalConnectionAttempts++;
            bool connectResult = synth->connect(sourceNodeId, sourcePins[j].channel, destNodeId, destPins[j].channel);
            if (connectResult)
            {
                totalConnectionsMade++;
                juce::Logger::writeToLog("[Color Chaining] Connected " + getTypeForLogical(sourceLid) + " -> " + getTypeForLogical(destLid));

                // Check if the destination is a recorder and update its filename
                if (auto* destModule = synth->getModuleForLogical(destLid))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                    {
                        if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                        {
                            recorder->updateSuggestedFilename(sourceModule->getName());
                        }
                    }
                }
            }
        }
    }

    juce::Logger::writeToLog("[Color Chaining] Completed: " + juce::String(totalConnectionsMade) + "/" + juce::String(totalConnectionAttempts) + " connections made");

    // 3. Apply all new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Module Category Color Coding
ImGuiNodeEditorComponent::ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleType)
{
    juce::String lower = moduleType.toLowerCase();
    
    // === CATEGORY CLASSIFICATION (Following Dictionary Structure) ===
    
    // --- 1. SOURCES (Green) ---
    if (lower.contains("vco") || lower.contains("polyvco") ||
        lower.contains("noise") || lower == "audio_input" || 
        lower.contains("sample") || lower == "value")
        return ModuleCategory::Source;
    
    // --- 2. EFFECTS (Red) ---
    // Note: Recorder moved to System, Vocal Tract Filter moved to TTS
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("reverb") || lower.contains("chorus") || 
        lower.contains("phaser") || lower.contains("compressor") || 
        lower.contains("limiter") || lower == "gate" ||
        lower.contains("drive") || lower.contains("bit_crusher") || lower.contains("crusher") || lower.contains("eq") ||
        lower.contains("waveshaper") || lower.contains("8bandshaper") ||
        lower.contains("granulator") || lower.contains("harmonic_shaper") ||
        lower.contains("timepitch") || lower.contains("crackle"))
        return ModuleCategory::Effect;
    
    // --- 3. MODULATORS (Blue) ---
    if (lower.contains("lfo") || lower.contains("adsr") || 
        lower.contains("random") || lower.contains("s&h") || 
        lower.contains("function_generator") || lower.contains("shaping_oscillator"))
        return ModuleCategory::Modulator;
    
    // --- 4. UTILITIES & LOGIC (Orange) ---
    if (lower.contains("vca") || lower.contains("mixer") || 
        lower.contains("attenuverter") || lower.contains("lag_processor") ||
        lower.contains("math") || lower.contains("map_range") ||
        lower.contains("quantizer") || lower.contains("rate") ||
        lower.contains("comparator") || lower.contains("logic") ||
        lower.contains("reroute") || lower.contains("panvol") ||
        lower.contains("clock_divider") || lower.contains("sequential_switch"))
        return ModuleCategory::Utility;
    
    // --- 5. SEQUENCERS (Light Green) ---
    if (lower.contains("sequencer") || lower.contains("tempo_clock") || lower == "timeline")
        return ModuleCategory::Seq;
    
    // --- 6. MIDI (Vibrant Purple) ---
    if (lower.contains("midi"))
        return ModuleCategory::MIDI;
    
    // --- 7. ANALYSIS (Purple) ---
    if (lower.contains("scope") || lower.contains("debug") || 
        lower.contains("frequency_graph"))
        return ModuleCategory::Analysis;
    
    // --- 8. TTS (Peach/Coral) ---
    if (lower.contains("tts") || lower.contains("vocal_tract"))
        return ModuleCategory::TTS_Voice;
    
    // --- 9. SPECIAL (Cyan) - Physics & Animation ---
    if (lower.contains("physics") || lower.contains("animation"))
        return ModuleCategory::Special_Exp;
    
    // --- 10. COMPUTER VISION (Bright Orange) ---
    if (lower.contains("webcam") || lower.contains("video_file") ||
        lower == "video_fx" || lower == "crop_video" ||
        lower.contains("movement") || lower.contains("detector") || 
        lower.contains("opencv") || lower.contains("vision") ||
        lower.contains("tracker") || lower.contains("segmentation") ||
        lower.contains("pose_estimator"))
        return ModuleCategory::OpenCV;
    
    // --- 11. SYSTEM (Lavender) ---
    if (lower.contains("meta") || lower.contains("inlet") || 
        lower.contains("outlet") || lower.contains("comment") ||
        lower.contains("recorder") || lower.contains("vst_host") ||
        lower == "bpm_monitor" || lower.contains("bpm monitor"))
        return ModuleCategory::Sys;
    
    // --- 12. PLUGINS (Teal) ---
    if (lower.contains("vst") || lower.contains("plugin"))
        return ModuleCategory::Plugin;
    
    // --- Default: Utility ---
    return ModuleCategory::Utility;
}

unsigned int ImGuiNodeEditorComponent::getImU32ForCategory(ModuleCategory category, bool hovered)
{
    ImU32 color = ThemeManager::getInstance().getCategoryColor(static_cast<::ModuleCategory>(category));
    
    if (hovered) 
    { 
        // Brighten on hover
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        c.x = juce::jmin(c.x * 1.3f, 1.0f);
        c.y = juce::jmin(c.y * 1.3f, 1.0f);
        c.z = juce::jmin(c.z * 1.3f, 1.0f);
        return ImGui::ColorConvertFloat4ToU32(c);
    }
    return color;
}

// Quick Add Menu - Module Registry - Dictionary
// Maps Display Name -> { Internal Type, Description }
std::map<juce::String, std::pair<const char*, const char*>> ImGuiNodeEditorComponent::getModuleRegistry()
{
    return {
        // Sources
        {"Audio Input", {"audio_input", "Records audio from your audio interface"}},
        {"VCO", {"vco", "Voltage Controlled Oscillator - generates waveforms"}},
        {"Polyphonic VCO", {"polyvco", "Polyphonic VCO with multiple voices"}},
        {"Noise", {"noise", "White, pink, or brown noise generator"}},
        {"Sequencer", {"sequencer", "Step sequencer for creating patterns"}},
        {"Multi Sequencer", {"multi_sequencer", "Multi-track step sequencer"}},
        {"Stroke Sequencer", {"stroke_sequencer", "Freeform visual rhythmic and CV generator"}},
        {"MIDI Player", {"midi_player", "Plays MIDI files"}},
        {"MIDI CV", {"midi_cv", "Converts MIDI Note/CC messages to CV signals. (Monophonic)"}},
        {"MIDI Faders", {"midi_faders", "Up to 16 MIDI faders with CC learning"}},
        {"MIDI Knobs", {"midi_knobs", "Up to 16 MIDI knobs/rotary encoders with CC learning"}},
        {"MIDI Buttons", {"midi_buttons", "Up to 32 MIDI buttons with Gate/Toggle/Trigger modes"}},
        {"MIDI Jog Wheel", {"midi_jog_wheel", "Single MIDI jog wheel/rotary encoder"}},
        {"MIDI Pads", {"midi_pads", "16-pad MIDI controller with polyphonic triggers and velocity outputs"}},
        {"MIDI Logger", {"midi_logger", "Records CV/Gate to MIDI events with piano roll editor and .mid export"}},
        {"Value", {"value", "Constant CV value output"}},
        {"Sample Loader", {"sample_loader", "Loads and plays audio samples"}},
        
        // TTS
        {"TTS Performer", {"tts_performer", "Text-to-speech synthesizer"}},
        {"Vocal Tract Filter", {"vocal_tract_filter", "Physical model vocal tract filter"}},
        
        // Physics & Animation
        {"Physics", {"physics", "2D physics simulation for audio modulation"}},
        {"Animation", {"animation", "Skeletal animation system with glTF file support"}},
        
        // OpenCV (Computer Vision)
        {"Webcam Loader", {"webcam_loader", "Captures video from a webcam and publishes it as a source for vision processing modules"}},
        {"Video File Loader", {"video_file_loader", "Loads and plays a video file, publishes it as a source for vision processing modules"}},
        {"Video FX", {"video_fx", "Applies real-time video effects (brightness, contrast, saturation, blur, sharpen, etc.) to video sources, chainable"}},
        {"Crop Video", {"crop_video", "Crops and resizes video frames to a specified region, chainable video processor"}},
        {"Movement Detector", {"movement_detector", "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV"}},
        {"Object Detector", {"object_detector", "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV"}},
        {"Pose Estimator", {"pose_estimator", "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals"}},
        {"Hand Tracker", {"hand_tracker", "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels)"}},
        {"Face Tracker", {"face_tracker", "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels)"}},
        {"Color Tracker", {"color_tracker", "Tracks multiple colors in video and outputs their positions and sizes as CV"}},
        {"Contour Detector", {"contour_detector", "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV"}},
        {"Semantic Segmentation", {"semantic_segmentmentation", "Uses deep learning to segment video into semantic regions and outputs detected areas as CV"}},
        
        // Effects
        {"VCF", {"vcf", "Voltage Controlled Filter"}},
        {"Delay", {"delay", "Echo/delay effect"}},
        {"Reverb", {"reverb", "Reverb effect"}},
        {"Chorus", {"chorus", "Chorus effect for thickening sound"}},
        {"Phaser", {"phaser", "Phaser modulation effect"}},
        {"Compressor", {"compressor", "Dynamic range compressor"}},
        {"Recorder", {"recorder", "Records audio to disk"}},
        {"Limiter", {"limiter", "Peak limiter"}},
        {"Noise Gate", {"gate", "Noise gate"}},
        {"Drive", {"drive", "Distortion/overdrive"}},
        {"Bit Crusher", {"bit_crusher", "Bit depth and sample rate reduction"}},
        {"PanVol", {"panvol", "2D control surface for volume and panning"}},
        {"Graphic EQ", {"graphic_eq", "Graphic equalizer"}},
        {"Waveshaper", {"waveshaper", "Waveshaping distortion"}},
        {"8-Band Shaper", {"8bandshaper", "8-band spectral shaper"}},
        {"Granulator", {"granulator", "Granular synthesis effect"}},
        {"Harmonic Shaper", {"harmonic_shaper", "Harmonic content shaper"}},
        {"Time/Pitch Shifter", {"timepitch", "Time stretching and pitch shifting"}},
        {"De-Crackle", {"de_crackle", "Removes clicks and pops"}},
        
        // Modulators
        {"LFO", {"lfo", "Low Frequency Oscillator for modulation"}},
        {"ADSR", {"adsr", "Attack Decay Sustain Release envelope"}},
        {"Random", {"random", "Random value generator"}},
        {"S&H", {"s_and_h", "Sample and Hold"}},
        {"Tempo Clock", {"tempo_clock", "Global clock with BPM control, transport (play/stop/reset), division, swing, and clock/gate outputs. Use External Takeover to drive the master transport."}},
        {"Function Generator", {"function_generator", "Custom function curves"}},
        {"Shaping Oscillator", {"shaping_oscillator", "Oscillator with waveshaping"}},
        
        // Utilities
        {"VCA", {"vca", "Voltage Controlled Amplifier"}},
        {"Mixer", {"mixer", "Audio/CV mixer"}},
        {"CV Mixer", {"cv_mixer", "CV signal mixer"}},
        {"Track Mixer", {"track_mixer", "Multi-track mixer with panning"}},
        {"Attenuverter", {"attenuverter", "Attenuate and invert signals"}},
        {"Reroute", {"reroute", "A polymorphic passthrough node. Pin color adapts to the input signal."}},
        {"Lag Processor", {"lag_processor", "Slew rate limiter/smoother"}},
        {"Math", {"math", "Mathematical operations"}},
        {"Map Range", {"map_range", "Map values from one range to another"}},
        {"Quantizer", {"quantizer", "Quantize CV to scales"}},
        {"Rate", {"rate", "Rate/frequency divider"}},
        {"Comparator", {"comparator", "Compare and threshold signals"}},
        {"Logic", {"logic", "Boolean logic operations"}},
        {"Clock Divider", {"clock_divider", "Clock division and multiplication"}},
        {"Sequential Switch", {"sequential_switch", "Sequential signal router"}},
        {"Comment", {"comment", "Text comment box"}},
        {"Snapshot Sequencer", {"snapshot_sequencer", "Snapshot sequencer for parameter automation"}},
        {"Timeline", {"timeline", "Transport-synchronized automation recorder for CV, Gate, Trigger, and Raw signals"}},
        {"BPM Monitor", {"bpm_monitor", "Hybrid rhythm detection and BPM reporting from sequencers and audio inputs"}},
        
        // Analysis
        {"Scope", {"scope", "Oscilloscope display"}},
        {"Debug", {"debug", "Debug value display"}},
        {"Input Debug", {"input_debug", "Input signal debugger"}},
        {"Frequency Graph", {"frequency_graph", "Spectrum analyzer display"}}
    };
}

// Legacy function for backwards compatibility with tooltip display
std::vector<std::pair<juce::String, const char*>> ImGuiNodeEditorComponent::getModuleDescriptions()
{
    std::vector<std::pair<juce::String, const char*>> result;
    for (const auto& entry : getModuleRegistry())
    {
        // Return {internal type, description} for compatibility
        result.push_back({entry.second.first, entry.second.second});
    }
    return result;
}

// VST Plugin Support
void ImGuiNodeEditorComponent::addPluginModules()
{
    if (synth == nullptr)
        return;
    
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    auto& formatManager = app.getPluginFormatManager();
    
    // Set the plugin format manager and known plugin list on the synth if not already set
    synth->setPluginFormatManager(&formatManager);
    synth->setKnownPluginList(&knownPluginList);
    
    // Get the VST folder at exe position
    juce::File exeDir = juce::File::getSpecialLocation(juce::File::currentApplicationFile).getParentDirectory();
    juce::File vstFolder = exeDir.getChildFile("VST");
    
    // Get all plugins and filter/deduplicate
    const auto& allPlugins = knownPluginList.getTypes();
    
    if (allPlugins.isEmpty())
    {
        ImGui::TextDisabled("No plugins found.");
        ImGui::TextDisabled("Use 'Scan for Plugins...' in the File menu.");
        return;
    }
    
    // Filter to only plugins in the VST folder and deduplicate
    std::vector<juce::PluginDescription> filteredPlugins;
    std::set<juce::String> seenPlugins; // Use name + manufacturer as unique key
    
    for (const auto& desc : allPlugins)
    {
        // Check if plugin is in the VST folder at exe position
        juce::File pluginFile(desc.fileOrIdentifier);
        if (!pluginFile.existsAsFile())
            continue;
            
        juce::File pluginDir = pluginFile.getParentDirectory();
        if (!pluginDir.isAChildOf(vstFolder) && pluginDir != vstFolder)
            continue;
        
        // Create unique key for deduplication (name + manufacturer)
        juce::String uniqueKey = desc.name + "|" + desc.manufacturerName;
        if (seenPlugins.find(uniqueKey) != seenPlugins.end())
            continue; // Skip duplicate
        
        seenPlugins.insert(uniqueKey);
        filteredPlugins.push_back(desc);
    }
    
    if (filteredPlugins.empty())
    {
        ImGui::TextDisabled("No plugins found in VST folder.");
        ImGui::TextDisabled(("Place VST plugins in: " + vstFolder.getFullPathName()).toRawUTF8());
        return;
    }
    
    // Use PushID to create unique IDs for each plugin to avoid conflicts when called from multiple menus
    ImGui::PushID("PluginList");
    int pluginIndex = 0;
    for (const auto& desc : filteredPlugins)
    {
        ImGui::PushID(pluginIndex++);
        juce::String buttonLabel = desc.name;
        if (desc.manufacturerName.isNotEmpty())
        {
            buttonLabel += " (" + desc.manufacturerName + ")";
        }
        
        if (ImGui::Selectable(buttonLabel.toRawUTF8()))
        {
            auto nodeId = synth->addVstModule(formatManager, desc);
            if (nodeId.uid != 0)
            {
                const ImVec2 mouse = ImGui::GetMousePos();
                const auto logicalId = synth->getLogicalIdForNode(nodeId);
                pendingNodeScreenPositions[(int)logicalId] = mouse;
                snapshotAfterEditor = true;
                juce::Logger::writeToLog("[VST] Added plugin: " + desc.name);
                // Close popup if we're in a popup context (safe to call even if not in popup)
                ImGui::CloseCurrentPopup();
            }
            else
            {
                juce::Logger::writeToLog("[VST] ERROR: Failed to add plugin: " + desc.name);
            }
        }
        
        // Show tooltip with plugin info on hover
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("Name: %s", desc.name.toRawUTF8());
            ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
            ImGui::Text("Version: %s", desc.version.toRawUTF8());
            ImGui::Text("Format: %s", desc.pluginFormatName.toRawUTF8());
            ImGui::Text("Type: %s", desc.isInstrument ? "Instrument" : "Effect");
            ImGui::Text("Inputs: %d", desc.numInputChannels);
            ImGui::Text("Outputs: %d", desc.numOutputChannels);
            ImGui::EndTooltip();
        }
        
        ImGui::PopID(); // Pop plugin index ID
    }
    ImGui::PopID(); // Pop PluginList ID
}
void ImGuiNodeEditorComponent::handleCollapseToMetaModule()
{
    if (!synth)
        return;
    
    juce::Logger::writeToLog("[Meta Module] Starting collapse operation...");
    
    // 1. Get selected nodes
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected < 2)
    {
        juce::Logger::writeToLog("[Meta Module] ERROR: Need at least 2 nodes selected");
        return;
    }
    
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());
    
    // Convert to logical IDs
    std::set<juce::uint32> selectedLogicalIds;
    for (int nodeId : selectedNodeIds)
    {
        selectedLogicalIds.insert((juce::uint32)nodeId);
    }
    
    juce::Logger::writeToLog("[Meta Module] Selected " + juce::String(numSelected) + " nodes");
    
    // 2. Analyze boundary connections
    struct BoundaryConnection
    {
        juce::uint32 externalLogicalId;
        int externalChannel;
        juce::uint32 internalLogicalId;
        int internalChannel;
        bool isInput; // true = external -> internal, false = internal -> external
    };
    std::vector<BoundaryConnection> boundaries;
    using InletKey = std::pair<juce::uint32, int>;
    using OutletKey = std::pair<juce::uint32, int>;
    struct InletInfo { juce::uint32 logicalId; int pinIndex; int channelCount; juce::uint32 externalLogicalId; int externalChannel; };
    struct OutletInfo { juce::uint32 logicalId; int pinIndex; int channelCount; juce::uint32 externalLogicalId; int externalChannel; bool externalIsOutput; };
    std::map<InletKey, InletInfo> inletInfoMap;
    std::map<OutletKey, OutletInfo> outletInfoMap;
    std::unordered_map<juce::uint32, InletInfo> inletInfoByLogical;
    std::unordered_map<juce::uint32, OutletInfo> outletInfoByLogical;
    int inletPinIndexCounter = 0;
    int outletPinIndexCounter = 0;
    auto allConnections = synth->getConnectionsInfo();
    for (const auto& conn : allConnections)
    {
        bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
        bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0 && !conn.dstIsOutput;
        bool dstIsOutput = conn.dstIsOutput;
        
        // Inlet: external -> selected
        if (!srcIsSelected && dstIsSelected)
        {
            BoundaryConnection bc;
            bc.externalLogicalId = conn.srcLogicalId;
            bc.externalChannel = conn.srcChan;
            bc.internalLogicalId = conn.dstLogicalId;
            bc.internalChannel = conn.dstChan;
            bc.isInput = true;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found inlet: " + juce::String(bc.externalLogicalId) + 
                                    " -> " + juce::String(bc.internalLogicalId));
        }
        // Outlet: selected -> external or output
        else if (srcIsSelected && (!dstIsSelected || dstIsOutput))
        {
            BoundaryConnection bc;
            bc.externalLogicalId = dstIsOutput ? 0 : conn.dstLogicalId;
            bc.externalChannel = conn.dstChan;
            bc.internalLogicalId = conn.srcLogicalId;
            bc.internalChannel = conn.srcChan;
            bc.isInput = false;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found outlet: " + juce::String(bc.internalLogicalId) + 
                                    " -> " + (dstIsOutput ? "OUTPUT" : juce::String(bc.externalLogicalId)));
        }
    }
    
    // Count inlets and outlets
    int numInlets = 0;
    int numOutlets = 0;
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            numInlets++;
        else
            numOutlets++;
    }
    
    juce::Logger::writeToLog("[META] Boundary Detection: Found " + juce::String(numInlets) + " inlets and " + juce::String(numOutlets) + " outlets.");
    juce::Logger::writeToLog("[META] Found " + juce::String(boundaries.size()) + " boundary connections");
    
    if (boundaries.empty())
    {
        juce::Logger::writeToLog("[META] WARNING: No boundary connections - creating isolated meta module");
    }
    
    // 3. Create the internal graph state
    pushSnapshot(); // Make undoable
    
    // Save the state of selected nodes
    juce::MemoryBlock internalState;
    {
        // Create a temporary state containing only selected nodes
        juce::ValueTree internalRoot("ModularSynthPreset");
        internalRoot.setProperty("version", 1, nullptr);
        
        juce::ValueTree modsVT("modules");
        juce::ValueTree connsVT("connections");
        
        // Add selected modules
        std::map<juce::uint32, juce::uint32> oldToNewLogicalId;
        juce::uint32 newLogicalId = 1;
        
        for (juce::uint32 oldId : selectedLogicalIds)
        {
            oldToNewLogicalId[oldId] = newLogicalId++;
            
            auto* module = synth->getModuleForLogical(oldId);
            if (!module)
                continue;
            
            juce::String moduleType = synth->getModuleTypeForLogical(oldId);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)oldToNewLogicalId[oldId], nullptr);
            mv.setProperty("type", moduleType, nullptr);
            
            // Save parameters
            juce::ValueTree params = module->getAPVTS().copyState();
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(params, -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            // Save extra state
            if (auto extra = module->getExtraStateTree(); extra.isValid())
            {
                juce::ValueTree extraWrapper("extra");
                extraWrapper.addChild(extra, -1, nullptr);
                mv.addChild(extraWrapper, -1, nullptr);
            }
            
            modsVT.addChild(mv, -1, nullptr);
        }
        
        auto createParameterState = [](const juce::String& paramId, int value)
        {
            juce::ValueTree params("Parameters");
            juce::ValueTree paramNode("Parameter");
            paramNode.setProperty("id", paramId, nullptr);
            paramNode.setProperty("value", (double)value, nullptr);
            params.addChild(paramNode, -1, nullptr);
            return params;
        };
        
        // Add inlet modules for each unique input
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
                continue;
            
            InletKey key { bc.externalLogicalId, bc.externalChannel };
            if (inletInfoMap.find(key) != inletInfoMap.end())
                continue;
            
            const juce::uint32 inletId = newLogicalId++;
            const int pinIndex = inletPinIndexCounter++;
            const int channelCount = 1;
            
            InletInfo info { inletId, pinIndex, channelCount, bc.externalLogicalId, bc.externalChannel };
            inletInfoMap[key] = info;
            inletInfoByLogical.emplace(inletId, info);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)inletId, nullptr);
            mv.setProperty("type", "inlet", nullptr);
            
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(createParameterState(InletModuleProcessor::paramIdChannelCount, channelCount), -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            juce::ValueTree extra("InletState");
            juce::String inletLabel;
            if (auto* srcModule = synth->getModuleForLogical(bc.externalLogicalId))
            {
                inletLabel = srcModule->getName();
                const juce::String channelLabel = srcModule->getAudioOutputLabel(bc.externalChannel);
                if (channelLabel.isNotEmpty())
                    inletLabel += " :: " + channelLabel;
                else
                    inletLabel += " :: Out " + juce::String(bc.externalChannel + 1);
            }
            else
            {
                inletLabel = "In " + juce::String(pinIndex + 1);
            }
            extra.setProperty("customLabel", inletLabel, nullptr);
            extra.setProperty("pinIndex", pinIndex, nullptr);
            extra.setProperty("externalLogicalId", (int)bc.externalLogicalId, nullptr);
            extra.setProperty("externalChannel", bc.externalChannel, nullptr);
            juce::ValueTree extraWrapper("extra");
            extraWrapper.addChild(extra, -1, nullptr);
            mv.addChild(extraWrapper, -1, nullptr);
            
            modsVT.addChild(mv, -1, nullptr);
            juce::Logger::writeToLog("[Meta Module] Created inlet node ID=" + juce::String(inletId));
        }
        
        // Add outlet modules for each unique output
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
                continue;
            
            OutletKey key { bc.internalLogicalId, bc.internalChannel };
            if (outletInfoMap.find(key) != outletInfoMap.end())
                continue;
            
            const juce::uint32 outletId = newLogicalId++;
            const int pinIndex = outletPinIndexCounter++;
            const int channelCount = 1;
            
            OutletInfo info { outletId, pinIndex, channelCount, bc.externalLogicalId, bc.externalChannel, bc.externalLogicalId == 0 };
            outletInfoMap[key] = info;
            outletInfoByLogical.emplace(outletId, info);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)outletId, nullptr);
            mv.setProperty("type", "outlet", nullptr);
            
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(createParameterState(OutletModuleProcessor::paramIdChannelCount, channelCount), -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            juce::ValueTree extra("OutletState");
            juce::String outletLabel;
            if (bc.externalLogicalId == 0)
            {
                outletLabel = "Main Output :: Ch " + juce::String(bc.externalChannel + 1);
            }
            else if (auto* dstModule = synth->getModuleForLogical(bc.externalLogicalId))
            {
                outletLabel = dstModule->getName();
                const juce::String channelLabel = dstModule->getAudioInputLabel(bc.externalChannel);
                if (channelLabel.isNotEmpty())
                    outletLabel += " :: " + channelLabel;
                else
                    outletLabel += " :: In " + juce::String(bc.externalChannel + 1);
            }
            else
            {
                outletLabel = "Out " + juce::String(pinIndex + 1);
            }
            extra.setProperty("customLabel", outletLabel, nullptr);
            extra.setProperty("pinIndex", pinIndex, nullptr);
            extra.setProperty("externalLogicalId", (int)bc.externalLogicalId, nullptr);
            extra.setProperty("externalChannel", bc.externalChannel, nullptr);
            extra.setProperty("externalIsOutput", bc.externalLogicalId == 0, nullptr);
            juce::ValueTree extraWrapper("extra");
            extraWrapper.addChild(extra, -1, nullptr);
            mv.addChild(extraWrapper, -1, nullptr);
            
            modsVT.addChild(mv, -1, nullptr);
            juce::Logger::writeToLog("[Meta Module] Created outlet node ID=" + juce::String(outletId));
        }
        
        // Add internal connections (between selected nodes)
        for (const auto& conn : allConnections)
        {
            bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
            bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0;
            
            if (srcIsSelected && dstIsSelected)
            {
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[conn.srcLogicalId], nullptr);
                cv.setProperty("srcChan", conn.srcChan, nullptr);
                cv.setProperty("dstId", (int)oldToNewLogicalId[conn.dstLogicalId], nullptr);
                cv.setProperty("dstChan", conn.dstChan, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from inlets to internal nodes
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                InletKey key { bc.externalLogicalId, bc.externalChannel };
                auto it = inletInfoMap.find(key);
                if (it == inletInfoMap.end())
                    continue;
                juce::uint32 inletId = it->second.logicalId;
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)inletId, nullptr);
                cv.setProperty("srcChan", 0, nullptr); // Inlets output on channel 0
                cv.setProperty("dstId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("dstChan", bc.internalChannel, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from internal nodes to outlets
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                OutletKey key { bc.internalLogicalId, bc.internalChannel };
                auto it = outletInfoMap.find(key);
                if (it == outletInfoMap.end())
                    continue;
                juce::uint32 outletId = it->second.logicalId;
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("srcChan", bc.internalChannel, nullptr);
                cv.setProperty("dstId", (int)outletId, nullptr);
                cv.setProperty("dstChan", 0, nullptr); // Outlets input on channel 0
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        internalRoot.addChild(modsVT, -1, nullptr);
        internalRoot.addChild(connsVT, -1, nullptr);
        
        // Serialize to memory block
        if (auto xml = internalRoot.createXml())
        {
            juce::MemoryOutputStream mos(internalState, false);
            xml->writeTo(mos);
            juce::Logger::writeToLog("[META] Generated state for sub-patch.");
        }
    }
    
    // 4. Calculate average position for the meta module
    ImVec2 avgPos(0.0f, 0.0f);
    int posCount = 0;
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos((int)logicalId);
        avgPos.x += pos.x;
        avgPos.y += pos.y;
        posCount++;
    }
    if (posCount > 0)
    {
        avgPos.x /= posCount;
        avgPos.y /= posCount;
    }
    
    // 5. Delete selected nodes
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        auto nodeId = synth->getNodeIdForLogical(logicalId);
        synth->removeModule(nodeId);
    }
    
    // 6. Create meta module
    auto metaNodeId = synth->addModule("meta_module");
    auto metaLogicalId = synth->getLogicalIdForNode(metaNodeId);
    pendingNodePositions[(int)metaLogicalId] = avgPos;
    
    juce::Logger::writeToLog("[META] Created new MetaModule with logical ID: " + juce::String((int)metaLogicalId));
    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule)
    {
        juce::ValueTree metaState("MetaModuleState");
        metaState.setProperty("label", "Meta Module", nullptr);

        if (internalState.getSize() > 0)
        {
            juce::MemoryOutputStream base64Stream;
            juce::Base64::convertToBase64(base64Stream, internalState.getData(), internalState.getSize());
            metaState.setProperty("internalGraphState", base64Stream.toString(), nullptr);
        }

        metaModule->setExtraStateTree(metaState);
        juce::Logger::writeToLog("[META] Loaded internal state into meta module");
    }
    else
    {
        juce::Logger::writeToLog("[META] ERROR: Failed to create meta module");
        return;
    }
    // 7. Reconnect external connections
    auto sortedInlets = metaModule->getInletNodes();
    std::sort(sortedInlets.begin(), sortedInlets.end(), [](auto* a, auto* b)
    {
        if (a->getPinIndex() != b->getPinIndex())
            return a->getPinIndex() < b->getPinIndex();
        return a->getLogicalId() < b->getLogicalId();
    });
    std::unordered_map<int, int> inletBaseChannels;
    std::unordered_map<int, int> inletChannelCounts;
    int runningInputChannel = 0;
    for (auto* inlet : sortedInlets)
    {
        const int pinIndex = inlet->getPinIndex();
        int channelCount = 1;
        if (auto* param = dynamic_cast<juce::AudioParameterInt*>(
                inlet->getAPVTS().getParameter(InletModuleProcessor::paramIdChannelCount)))
        {
            channelCount = juce::jmax(1, param->get());
        }
        if (auto logicalIt = inletInfoByLogical.find(inlet->getLogicalId()); logicalIt != inletInfoByLogical.end())
        {
            inlet->setExternalMapping(logicalIt->second.externalLogicalId, logicalIt->second.externalChannel);
        }
        inletBaseChannels[pinIndex] = runningInputChannel;
        inletChannelCounts[pinIndex] = channelCount;
        runningInputChannel += channelCount;
    }

    auto sortedOutlets = metaModule->getOutletNodes();
    std::sort(sortedOutlets.begin(), sortedOutlets.end(), [](auto* a, auto* b)
    {
        if (a->getPinIndex() != b->getPinIndex())
            return a->getPinIndex() < b->getPinIndex();
        return a->getLogicalId() < b->getLogicalId();
    });

    std::unordered_map<int, int> outletBaseChannels;
    std::unordered_map<int, int> outletChannelCounts;
    int runningOutputChannel = 0;
    for (auto* outlet : sortedOutlets)
    {
        const int pinIndex = outlet->getPinIndex();
        int channelCount = 1;
        if (auto* param = dynamic_cast<juce::AudioParameterInt*>(
                outlet->getAPVTS().getParameter(OutletModuleProcessor::paramIdChannelCount)))
        {
            channelCount = juce::jmax(1, param->get());
        }
        if (auto logicalIt = outletInfoByLogical.find(outlet->getLogicalId()); logicalIt != outletInfoByLogical.end())
        {
            outlet->setExternalMapping(logicalIt->second.externalLogicalId,
                                       logicalIt->second.externalChannel,
                                       logicalIt->second.externalIsOutput);
        }
        outletBaseChannels[pinIndex] = runningOutputChannel;
        outletChannelCounts[pinIndex] = channelCount;
        runningOutputChannel += channelCount;
    }

    // Connect unique external sources to meta inputs
    for (const auto& entry : inletInfoMap)
    {
        const InletKey& key = entry.first;
        const InletInfo& info = entry.second;

        auto extNodeId = synth->getNodeIdForLogical(key.first);
        if (extNodeId.uid == 0)
            continue;

        auto baseIt = inletBaseChannels.find(info.pinIndex);
        auto countIt = inletChannelCounts.find(info.pinIndex);
        if (baseIt == inletBaseChannels.end() || countIt == inletChannelCounts.end())
            continue;

        const int baseChannel = baseIt->second;
        const int channelCount = countIt->second;

        for (int ch = 0; ch < channelCount; ++ch)
        {
            synth->connect(extNodeId, key.second + ch, metaNodeId, baseChannel + ch);
        }
    }

    const auto outputNodeId = synth->getOutputNodeID();

    // Reconnect meta outputs to their original destinations
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            continue;

        OutletKey key { bc.internalLogicalId, bc.internalChannel };
        auto infoIt = outletInfoMap.find(key);
        if (infoIt == outletInfoMap.end())
            continue;

        const OutletInfo& info = infoIt->second;
        auto destNodeId = (bc.externalLogicalId == 0)
            ? outputNodeId
            : synth->getNodeIdForLogical(bc.externalLogicalId);

        if (destNodeId.uid == 0)
            continue;

        auto baseIt = outletBaseChannels.find(info.pinIndex);
        auto countIt = outletChannelCounts.find(info.pinIndex);
        if (baseIt == outletBaseChannels.end() || countIt == outletChannelCounts.end())
            continue;

        const int baseChannel = baseIt->second;
        const int channelCount = countIt->second;

        for (int ch = 0; ch < channelCount; ++ch)
        {
            synth->connect(metaNodeId, baseChannel + ch, destNodeId, bc.externalChannel + ch);
        }
    }
    
    graphNeedsRebuild = true;
    synth->commitChanges();
    
    juce::Logger::writeToLog("[META] Reconnected external cables. Collapse complete!");
    NotificationManager::post(NotificationManager::Type::Info, "Collapsed to Meta Module");
}

void ImGuiNodeEditorComponent::populateDragInsertSuggestions()
{
    dragInsertSuggestionsInputs.clear();
    dragInsertSuggestionsOutputs.clear();

    const auto& pinDb = getModulePinDatabase();

    auto addUnique = [](auto& mapRef, PinDataType type, const juce::String& moduleType)
    {
        auto& modules = mapRef[type];
        if (std::find(modules.begin(), modules.end(), moduleType) == modules.end())
            modules.push_back(moduleType);
    };

    auto addInputModule = [&](PinDataType type, const juce::String& moduleType)
    {
        addUnique(dragInsertSuggestionsInputs, type, moduleType);
    };

    auto addOutputModule = [&](PinDataType type, const juce::String& moduleType)
    {
        addUnique(dragInsertSuggestionsOutputs, type, moduleType);
    };

    // Seed curated utilities for fast access when connecting FROM outputs (needs inputs).
    addInputModule(PinDataType::Audio, "attenuverter");
    addInputModule(PinDataType::Audio, "comparator");
    addInputModule(PinDataType::Audio, "mixer");

    addInputModule(PinDataType::CV, "attenuverter");
    addInputModule(PinDataType::CV, "lag_processor");
    addInputModule(PinDataType::CV, "math");

    addInputModule(PinDataType::Gate, "comparator");
    addInputModule(PinDataType::Gate, "logic");
    addInputModule(PinDataType::Gate, "sequential_switch");

    addInputModule(PinDataType::Raw, "map_range");
    addInputModule(PinDataType::Raw, "scope");

    addInputModule(PinDataType::Video, "video_fx");
    addInputModule(PinDataType::Video, "crop_video");

    // Seed curated sources for fast access when connecting INTO inputs (needs outputs).
    addOutputModule(PinDataType::Audio, "vco");
    addOutputModule(PinDataType::Audio, "polyvco");
    addOutputModule(PinDataType::Audio, "noise");
    addOutputModule(PinDataType::Audio, "sample_loader");
    addOutputModule(PinDataType::Audio, "midi_player");

    addOutputModule(PinDataType::CV, "lfo");
    addOutputModule(PinDataType::CV, "adsr");
    addOutputModule(PinDataType::CV, "function_generator");
    addOutputModule(PinDataType::CV, "value");

    addOutputModule(PinDataType::Gate, "adsr");
    addOutputModule(PinDataType::Gate, "random");

    addOutputModule(PinDataType::Raw, "value");

    addOutputModule(PinDataType::Video, "webcam_loader");
    addOutputModule(PinDataType::Video, "video_file_loader");

    for (auto type : { PinDataType::Audio, PinDataType::CV, PinDataType::Gate, PinDataType::Raw, PinDataType::Video })
    {
        addInputModule(type, "reroute");
        addOutputModule(type, "reroute");
    }

    for (const auto& entry : pinDb)
    {
        const juce::String& moduleType = entry.first;
        const auto& info = entry.second;

        for (const auto& pin : info.audioIns)
            addInputModule(pin.type, moduleType);

        for (const auto& pin : info.modIns)
            addInputModule(pin.type, moduleType);

        for (const auto& pin : info.audioOuts)
            addOutputModule(pin.type, moduleType);
    }

    auto sortMapVectors = [](auto& mapRef)
    {
        for (auto& entry : mapRef)
        {
            auto& modules = entry.second;
            std::sort(modules.begin(), modules.end(),
                      [](const juce::String& a, const juce::String& b)
                      {
                          return a.compareIgnoreCase(b) < 0;
                      });
        }
    };

    sortMapVectors(dragInsertSuggestionsInputs);
    sortMapVectors(dragInsertSuggestionsOutputs);
}

const std::vector<juce::String>& ImGuiNodeEditorComponent::getDragInsertSuggestionsFor(const PinID& pin) const
{
    PinID localPin = pin;
    PinDataType type = localPin.isMod ? PinDataType::CV
                                      : const_cast<ImGuiNodeEditorComponent*>(this)->getPinDataTypeForPin(localPin);

    const auto& sourceMap = localPin.isInput ? dragInsertSuggestionsOutputs
                                             : dragInsertSuggestionsInputs;
    if (auto it = sourceMap.find(type); it != sourceMap.end())
        return it->second;

    static const std::vector<juce::String> empty;
    return empty;
}
void ImGuiNodeEditorComponent::insertNodeFromDragSelection(const juce::String& moduleType)
{
    if (synth == nullptr || dragInsertStartAttrId == -1)
        return;

    auto newNodeId = synth->addModule(moduleType);
    auto newLogicalId = synth->getLogicalIdForNode(newNodeId);

    pendingNodeScreenPositions[(int)newLogicalId] = dragInsertDropPos;

    const PinDataType primaryType = dragInsertStartPin.isMod
        ? PinDataType::CV
        : getPinDataTypeForPin(dragInsertStartPin);

    juce::Logger::writeToLog("[DragInsert] primaryType=" + juce::String(toString(primaryType))
                             + ", startPin: lid=" + juce::String((int)dragInsertStartPin.logicalId)
                             + ", channel=" + juce::String(dragInsertStartPin.channel)
                             + ", isInput=" + juce::String(dragInsertStartPin.isInput ? 1 : 0)
                             + ", isMod=" + juce::String(dragInsertStartPin.isMod ? 1 : 0));

    auto getSortedPinsForType = [&](juce::uint32 logicalId, bool isInput) -> std::vector<AudioPin>
    {
        std::vector<AudioPin> pins;

        if (logicalId == 0)
        {
            if (primaryType == PinDataType::Audio)
            {
                pins.emplace_back("Main L", 0, PinDataType::Audio);
                pins.emplace_back("Main R", 1, PinDataType::Audio);
            }
            return pins;
        }

        pins = getPinsOfType(logicalId, isInput, primaryType);
        std::sort(pins.begin(), pins.end(),
                  [](const AudioPin& a, const AudioPin& b)
                  {
                      return a.channel < b.channel;
                  });
        return pins;
    };

    auto findChannelIndex = [](const std::vector<AudioPin>& pins, int channel) -> int
    {
        for (int i = 0; i < (int)pins.size(); ++i)
        {
            if (pins[(size_t)i].channel == channel)
                return i;
        }
        return -1;
    };

    auto logNoCompatiblePins = [&](const char* role)
    {
        juce::Logger::writeToLog("[DragInsert] No compatible "
                                 + juce::String(toString(primaryType))
                                 + " " + juce::String(role)
                                 + " found for '" + moduleType + "', skipping auto-wire.");
    };

    bool connected = false;
    if (!dragInsertStartPin.isMod)
    {
        if (!dragInsertStartPin.isInput)
        {
            auto srcNodeId = synth->getNodeIdForLogical(dragInsertStartPin.logicalId);
            if (srcNodeId.uid != 0)
            {
                const auto sourcePins = getSortedPinsForType(dragInsertStartPin.logicalId, false);
                const auto targetPins = getSortedPinsForType((juce::uint32)newLogicalId, true);

                juce::Logger::writeToLog("[DragInsert] sourcePins count=" + juce::String(sourcePins.size()));
                for (const auto& pin : sourcePins)
                {
                    juce::Logger::writeToLog("  source: " + pin.name + " ch=" + juce::String(pin.channel) + " type=" + juce::String(toString(pin.type)));
                }
                juce::Logger::writeToLog("[DragInsert] targetPins count=" + juce::String(targetPins.size()));
                for (const auto& pin : targetPins)
                {
                    juce::Logger::writeToLog("  target: " + pin.name + " ch=" + juce::String(pin.channel) + " type=" + juce::String(toString(pin.type)));
                }

        if (!sourcePins.empty() && !targetPins.empty())
        {
            if (primaryType == PinDataType::Audio)
            {
                std::vector<int> sourceChannels;
                sourceChannels.reserve(sourcePins.size());
                for (const auto& pin : sourcePins)
                    sourceChannels.push_back(pin.channel);
                if (sourceChannels.empty())
                    sourceChannels.push_back(dragInsertStartPin.channel);
                if (sourceChannels.size() > 2)
                    sourceChannels.resize(2);

                std::vector<int> targetChannels;
                targetChannels.reserve(targetPins.size());
                for (const auto& pin : targetPins)
                    targetChannels.push_back(pin.channel);
                if (targetChannels.size() > 2)
                    targetChannels.resize(2);

                std::set<std::pair<int,int>> madeConnections;
                auto connectAudioPair = [&](int srcChan, int dstChan)
                {
                    if (srcChan < 0 || dstChan < 0)
                        return;
                    std::pair<int,int> key{srcChan, dstChan};
                    if (madeConnections.insert(key).second)
                    {
                        synth->connect(srcNodeId, srcChan, newNodeId, dstChan);
                        connected = true;
                    }
                };

                if (!sourceChannels.empty() && !targetChannels.empty())
                {
                    const bool sourceStereo = sourceChannels.size() >= 2;
                    const bool targetStereo = targetChannels.size() >= 2;

                    if (!sourceStereo && targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                        connectAudioPair(sourceChannels[0], targetChannels[1]);
                    }
                    else if (sourceStereo && !targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                    }
                    else if (sourceStereo && targetStereo)
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                        connectAudioPair(sourceChannels[1], targetChannels[1]);
                    }
                    else
                    {
                        connectAudioPair(sourceChannels[0], targetChannels[0]);
                    }
                }
                if (!connected)
                    logNoCompatiblePins("input");
            }
            else
            {
                // For non-Audio types (Video, CV, Gate, etc.), match by actual channel number
                // First, find the source pin that matches the drag start channel
                int sourceChannel = dragInsertStartPin.channel;
                const int sourceIndex = findChannelIndex(sourcePins, sourceChannel);
                
                if (sourceIndex >= 0 && sourceIndex < (int)sourcePins.size())
                {
                    sourceChannel = sourcePins[(size_t)sourceIndex].channel;
                    
                    // Try to find a target pin at the same channel number
                    int targetChannel = -1;
                    const int targetIndexByChannel = findChannelIndex(targetPins, sourceChannel);
                    
                    if (targetIndexByChannel >= 0 && targetIndexByChannel < (int)targetPins.size())
                    {
                        // Found exact channel match
                        targetChannel = targetPins[(size_t)targetIndexByChannel].channel;
                    }
                    else if (!targetPins.empty())
                    {
                        // No exact match, use first available pin of the matching type
                        targetChannel = targetPins[0].channel;
                    }
                    
                    if (targetChannel >= 0)
                    {
                        juce::Logger::writeToLog("[DragInsert] Connecting: srcNodeId=" + juce::String((int)srcNodeId.uid)
                                                 + " srcChannel=" + juce::String(sourceChannel)
                                                 + " -> newNodeId=" + juce::String((int)newNodeId.uid)
                                                 + " targetChannel=" + juce::String(targetChannel));
                        synth->connect(srcNodeId, sourceChannel, newNodeId, targetChannel);
                        connected = true;
                    }
                    else
                    {
                        juce::Logger::writeToLog("[DragInsert] ERROR: targetChannel < 0, cannot connect");
                    }
                }
                else if (!sourcePins.empty() && !targetPins.empty())
                {
                    // Fallback: use first available pins if channel lookup failed
                    synth->connect(srcNodeId,
                                   sourcePins[0].channel,
                                   newNodeId,
                                   targetPins[0].channel);
                    connected = true;
                }
            }
        }
        else
        {
            logNoCompatiblePins("input");
        }
            }
        }
        else
        {
            auto dstNodeId = dragInsertStartPin.logicalId == 0
                             ? synth->getOutputNodeID()
                             : synth->getNodeIdForLogical(dragInsertStartPin.logicalId);
            if (dstNodeId.uid != 0)
            {
                const auto sourcePins = getSortedPinsForType((juce::uint32)newLogicalId, false);
                const auto destinationPins = getSortedPinsForType(dragInsertStartPin.logicalId, true);

                if (!sourcePins.empty() && !destinationPins.empty())
                {
                    const int destinationIndex = findChannelIndex(destinationPins, dragInsertStartPin.channel);
                    if (destinationIndex >= 0 && destinationIndex < (int)destinationPins.size())
                    {
                        const int destinationChannel = destinationPins[(size_t)destinationIndex].channel;
                        
                        if (primaryType == PinDataType::Audio)
                        {
                            // Audio path: use array indices for stereo pairs
                            const int sourceIndex = juce::jlimit(0, (int)sourcePins.size() - 1, destinationIndex);

                            synth->connect(newNodeId,
                                           sourcePins[(size_t)sourceIndex].channel,
                                           dstNodeId,
                                           destinationChannel);
                            connected = true;

                            const int stereoSourceIndex = sourceIndex + 1;
                            const int stereoDestinationIndex = destinationIndex + 1;

                            if (stereoSourceIndex < (int)sourcePins.size() &&
                                stereoDestinationIndex < (int)destinationPins.size())
                            {
                                synth->connect(newNodeId,
                                               sourcePins[(size_t)stereoSourceIndex].channel,
                                               dstNodeId,
                                               destinationPins[(size_t)stereoDestinationIndex].channel);
                            }
                        }
                        else
                        {
                            // Non-Audio path: match by actual channel number
                            int sourceChannel = -1;
                            const int sourceIndexByChannel = findChannelIndex(sourcePins, destinationChannel);
                            
                            if (sourceIndexByChannel >= 0 && sourceIndexByChannel < (int)sourcePins.size())
                            {
                                // Found exact channel match
                                sourceChannel = sourcePins[(size_t)sourceIndexByChannel].channel;
                            }
                            else if (!sourcePins.empty())
                            {
                                // No exact match, use first available pin of the matching type
                                sourceChannel = sourcePins[0].channel;
                            }
                            
                            if (sourceChannel >= 0)
                            {
                                synth->connect(newNodeId, sourceChannel, dstNodeId, destinationChannel);
                                connected = true;
                            }
                        }
                    }
                }
                else
                {
                    logNoCompatiblePins("output");
                }
            }
        }
    }

    synth->commitChanges();

    graphNeedsRebuild = true;
    pushSnapshot();

    juce::Logger::writeToLog("[DragInsert] Added '" + moduleType + "' (LID "
                             + juce::String((int)newLogicalId) + ")"
                             + (connected ? " and auto-wired input." : "."));

    dragInsertStartAttrId = -1;
    dragInsertStartPin = PinID{};
    shouldOpenDragInsertPopup = false;
}

void ImGuiNodeEditorComponent::loadPresetFromFile(const juce::File& file)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    // 1. Load the file content.
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);

    // 2. Set the synthesizer's state. This rebuilds the audio graph.
    synth->setStateInformation(mb.getData(), (int)mb.getSize());

    // 3. Parse the XML to find the UI state.
    juce::ValueTree uiState;
    if (auto xml = juce::XmlDocument::parse(mb.toString()))
    {
        auto vt = juce::ValueTree::fromXml(*xml);
        uiState = vt.getChildWithName("NodeEditorUI");
        if (uiState.isValid())
        {
            // 4. Apply the UI state (node positions, muted status, etc.).
            // This queues the changes to be applied on the next frame.
            applyUiValueTree(uiState);
        }
    }

    // 5. Create an undo snapshot for this action.
    Snapshot s;
    synth->getStateInformation(s.synthState);
    s.uiState = uiState.isValid() ? uiState : getUiValueTree();
    undoStack.push_back(std::move(s));
    redoStack.clear();

    // 5. Update the UI status trackers.
    isPatchDirty = false;
    currentPresetFile = file; // Store full file path
    
    // No notification here; the calling function will handle it.
}
void ImGuiNodeEditorComponent::mergePresetFromFile(const juce::File& file, ImVec2 dropPosition)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    auto xml = juce::XmlDocument::parse(file);
    if (xml == nullptr) return;

    juce::ValueTree preset = juce::ValueTree::fromXml(*xml);
    auto modulesVT = preset.getChildWithName("modules");
    auto connectionsVT = preset.getChildWithName("connections");
    auto uiVT = preset.getChildWithName("NodeEditorUI");

    if (!modulesVT.isValid()) return;

    pushSnapshot(); // Create an undo state before we start merging.

    // --- THIS IS THE NEW LOGIC ---
    // 1. Find the top-most Y coordinate of all existing nodes on the canvas.
    float topMostY = FLT_MAX;
    auto currentUiState = getUiValueTree();
    bool canvasHasNodes = false;
    for (int i = 0; i < currentUiState.getNumChildren(); ++i)
    {
        auto nodePosVT = currentUiState.getChild(i);
        if (nodePosVT.hasType("node"))
        {
            canvasHasNodes = true;
            float y = (float)nodePosVT.getProperty("y");
            if (y < topMostY)
            {
                topMostY = y;
            }
        }
    }
    // If the canvas is empty, use the drop position as the reference.
    if (!canvasHasNodes)
    {
        topMostY = dropPosition.y;
    }

    // 2. Find the bounding box of the nodes within the preset we are dropping.
    float presetMinX = FLT_MAX;
    float presetMaxY = -FLT_MAX;
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                float x = (float)nodePosVT.getProperty("x");
                float y = (float)nodePosVT.getProperty("y");
                if (x < presetMinX) presetMinX = x;
                if (y > presetMaxY) presetMaxY = y; // We need the lowest point (max Y) of the preset group.
            }
        }
    }
    
    // 3. Calculate the necessary offsets.
    const float verticalPadding = 100.0f;
    const float yOffset = topMostY - presetMaxY - verticalPadding;
    const float xOffset = dropPosition.x - presetMinX;
    // --- END OF NEW LOGIC ---

    // This map will track how we remap old IDs from the file to new, unique IDs on the canvas.
    std::map<juce::uint32, juce::uint32> oldIdToNewId;

    // First pass: create all the new modules from the preset.
    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleNode = modulesVT.getChild(i);
        if (moduleNode.hasType("module"))
        {
            juce::uint32 oldLogicalId = (juce::uint32)(int)moduleNode.getProperty("logicalId");
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Add the module without committing the graph changes yet.
            auto newNodeId = synth->addModule(type, false);
            juce::uint32 newLogicalId = synth->getLogicalIdForNode(newNodeId);

            oldIdToNewId[oldLogicalId] = newLogicalId; // Store the mapping

            // Restore the new module's parameters and extra state.
            if (auto* proc = synth->getModuleForLogical(newLogicalId))
            {
                auto paramsWrapper = moduleNode.getChildWithName("params");
                if (paramsWrapper.isValid()) proc->getAPVTS().replaceState(paramsWrapper.getChild(0));
                
                auto extraWrapper = moduleNode.getChildWithName("extra");
                if (extraWrapper.isValid()) proc->setExtraStateTree(extraWrapper.getChild(0));
            }
        }
    }

    // Second pass: recreate the internal connections between the new modules.
    if (connectionsVT.isValid())
    {
        for (int i = 0; i < connectionsVT.getNumChildren(); ++i)
        {
            auto connNode = connectionsVT.getChild(i);
            if (connNode.hasType("connection"))
            {
                juce::uint32 oldSrcId = (juce::uint32)(int)connNode.getProperty("srcId");
                int srcChan = (int)connNode.getProperty("srcChan");
                juce::uint32 oldDstId = (juce::uint32)(int)connNode.getProperty("dstId");
                int dstChan = (int)connNode.getProperty("dstChan");

                // Only connect if both source and destination are part of the preset we're merging.
                if (oldIdToNewId.count(oldSrcId) && oldIdToNewId.count(oldDstId))
                {
                    auto newSrcNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldSrcId]);
                    auto newDstNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldDstId]);
                    synth->connect(newSrcNodeId, srcChan, newDstNodeId, dstChan);
                }
            }
        }
    }
    
    // Third pass: Apply UI positions using our new calculated offsets.
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                juce::uint32 oldId = (juce::uint32)(int)nodePosVT.getProperty("id");
                if (oldIdToNewId.count(oldId)) // Check if it's one of our new nodes
                {
                    ImVec2 pos = ImVec2((float)nodePosVT.getProperty("x"), (float)nodePosVT.getProperty("y"));
                    
                    // Apply the smart offsets
                    ImVec2 newPos = ImVec2(pos.x + xOffset, pos.y + yOffset);
                    
                    pendingNodeScreenPositions[(int)oldIdToNewId[oldId]] = newPos;
                }
            }
        }
    }

    // Finally, commit all the changes to the audio graph at once.
    synth->commitChanges();
    isPatchDirty = true; // Mark the patch as edited.
    
    juce::Logger::writeToLog("[Preset] Successfully merged preset: " + file.getFullPathName() + 
                             " above existing nodes with offsets (" + juce::String(xOffset) + ", " + juce::String(yOffset) + ")");
}

================================================================================
FILE: juce\Source\audio\modules\BitCrusherModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include <array>

class BitCrusherModuleProcessor : public ModuleProcessor
{
public:
    // Parameter IDs for APVTS
    static constexpr auto paramIdBitDepth = "bit_depth";
    static constexpr auto paramIdSampleRate = "sample_rate";
    static constexpr auto paramIdMix = "mix";
    static constexpr auto paramIdAntiAlias = "antiAlias";
    static constexpr auto paramIdQuantMode = "quant_mode";
    
    // Virtual modulation target IDs (no APVTS parameters required)
    static constexpr auto paramIdBitDepthMod = "bit_depth_mod";
    static constexpr auto paramIdSampleRateMod = "sample_rate_mod";
    static constexpr auto paramIdMixMod = "mix_mod";
    static constexpr auto paramIdAntiAliasMod = "antiAlias_mod";
    static constexpr auto paramIdQuantModeMod = "quant_mode_mod";

    BitCrusherModuleProcessor();
    ~BitCrusherModuleProcessor() override = default;

    const juce::String getName() const override { return "bit_crusher"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;

    // A temporary buffer is needed to properly implement the dry/wet mix
    juce::AudioBuffer<float> tempBuffer;

    // Cached atomic pointers to parameters
    std::atomic<float>* bitDepthParam { nullptr };
    std::atomic<float>* sampleRateParam { nullptr };
    std::atomic<float>* mixParam { nullptr };
    std::atomic<float>* antiAliasParam { nullptr };
    std::atomic<float>* quantModeParam { nullptr };
    std::atomic<float>* relativeBitDepthModParam { nullptr };
    std::atomic<float>* relativeSampleRateModParam { nullptr };
    std::atomic<float>* relativeMixModParam { nullptr };

    // Smoothed values to prevent zipper noise
    juce::SmoothedValue<float> mBitDepthSm;
    juce::SmoothedValue<float> mSampleRateSm;

    // Anti-aliasing filters (stereo)
    juce::dsp::StateVariableTPTFilter<float> mAntiAliasFilterL;
    juce::dsp::StateVariableTPTFilter<float> mAntiAliasFilterR;

    // Sample-and-hold decimator state
    float mSrCounterL = 0.0f;
    float mLastSampleL = 0.0f;
    float mSrCounterR = 0.0f;
    float mLastSampleR = 0.0f;
    
    // Random number generator for dithering
    juce::Random mRandom;
    
    // Noise shaping state (one per channel)
    float mQuantErrorL = 0.0f;
    float mQuantErrorR = 0.0f;
    
    // --- Visualization Data (thread-safe, updated from audio thread) ---
    struct VizData
    {
        static constexpr int waveformPoints = 256;
        std::array<std::atomic<float>, waveformPoints> inputWaveformL;
        std::array<std::atomic<float>, waveformPoints> inputWaveformR;
        std::array<std::atomic<float>, waveformPoints> outputWaveformL;
        std::array<std::atomic<float>, waveformPoints> outputWaveformR;
        
        // Sample-and-hold regions (normalized positions 0-1, -1 = inactive)
        // Track actual hold positions from decimator state
        std::array<std::atomic<float>, 64> holdStartPositions; // Where holds begin (in waveform snapshot index)
        std::array<std::atomic<float>, 64> holdEndPositions;   // Where holds end (in waveform snapshot index)
        std::array<std::atomic<float>, 64> holdValues;         // The held sample value
        std::atomic<int> activeHoldCount { 0 };
        
        // Current quantization state
        std::atomic<float> currentBitDepth { 16.0f };
        std::atomic<float> currentSampleRate { 1.0f };
        std::atomic<int> currentQuantMode { 0 }; // 0=Linear, 1=Dither, 2=NoiseShape
        std::atomic<bool> currentAntiAlias { true };
    };
    VizData vizData;
    
    // Circular buffer for waveform snapshots
    juce::AudioBuffer<float> vizInputBuffer;
    juce::AudioBuffer<float> vizOutputBuffer;
    juce::AudioBuffer<float> vizDecimatedBuffer; // Store decimated (before quantization) samples
    int vizWritePos { 0 };
    static constexpr int vizBufferSize = 2048; // ~43ms at 48kHz
    
    // Track hold regions for visualization (from decimator state)
    struct HoldRegion
    {
        int startIdx { -1 }; // Start index in waveform snapshot
        int endIdx { -1 };   // End index in waveform snapshot
        float value { 0.0f }; // The held sample value
    };
    std::array<HoldRegion, 64> trackedHolds;
    int trackedHoldCount { 0 };
    float lastHoldStartPos { -1.0f }; // Last position where we started a hold (for tracking)
};



================================================================================
FILE: juce\Source\audio\modules\BitCrusherModuleProcessor.cpp
================================================================================


#include "BitCrusherModuleProcessor.h"
#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/theme/ThemeManager.h"
#endif
#include <cmath> // For std::exp2, std::floor

juce::AudioProcessorValueTreeState::ParameterLayout BitCrusherModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    // Bit Depth: 1.0f to 24.0f with logarithmic scaling (skew factor 0.3 like Waveshaper's drive)
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdBitDepth, "Bit Depth", 
        juce::NormalisableRange<float>(1.0f, 24.0f, 0.01f, 0.3f), 16.0f));
    
    // Sample Rate: 0.1f to 1.0f with logarithmic scaling (skew factor 0.3)
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSampleRate, "Sample Rate", 
        juce::NormalisableRange<float>(0.1f, 1.0f, 0.001f, 0.3f), 1.0f));
    
    // Mix: 0.0f to 1.0f (linear, like DriveModuleProcessor)
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdMix, "Mix", 0.0f, 1.0f, 1.0f));
    
    // Anti-aliasing filter
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdAntiAlias, "Anti-Aliasing", true));
    
    // Quantization mode
    params.push_back(std::make_unique<juce::AudioParameterChoice>(paramIdQuantMode, "Quant Mode", 
        juce::StringArray{"Linear", "Dither (TPDF)", "Noise Shaping"}, 0));
    
    // Relative modulation parameters
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeBitDepthMod", "Relative Bit Depth Mod", true));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeSampleRateMod", "Relative Sample Rate Mod", true));
    params.push_back(std::make_unique<juce::AudioParameterBool>("relativeMixMod", "Relative Mix Mod", false));
    
    return { params.begin(), params.end() };
}

BitCrusherModuleProcessor::BitCrusherModuleProcessor()
    : ModuleProcessor(BusesProperties()
          .withInput("Audio In", juce::AudioChannelSet::discreteChannels(7), true) // 0-1: Audio, 2: BitDepth Mod, 3: SampleRate Mod, 4: Mix Mod, 5: AntiAlias Mod, 6: QuantMode Mod
          .withOutput("Audio Out", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "BitCrusherParams", createParameterLayout())
{
    bitDepthParam = apvts.getRawParameterValue(paramIdBitDepth);
    sampleRateParam = apvts.getRawParameterValue(paramIdSampleRate);
    mixParam = apvts.getRawParameterValue(paramIdMix);
    antiAliasParam = apvts.getRawParameterValue(paramIdAntiAlias);
    quantModeParam = apvts.getRawParameterValue(paramIdQuantMode);
    relativeBitDepthModParam = apvts.getRawParameterValue("relativeBitDepthMod");
    relativeSampleRateModParam = apvts.getRawParameterValue("relativeSampleRateMod");
    relativeMixModParam = apvts.getRawParameterValue("relativeMixMod");

    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Out R
    
    // Initialize smoothed values
    mBitDepthSm.reset(16.0f);
    mSampleRateSm.reset(1.0f);
    
    // Initialize visualization data
    for (auto& w : vizData.inputWaveformL) w.store(0.0f);
    for (auto& w : vizData.inputWaveformR) w.store(0.0f);
    for (auto& w : vizData.outputWaveformL) w.store(0.0f);
    for (auto& w : vizData.outputWaveformR) w.store(0.0f);
    for (auto& p : vizData.holdStartPositions) p.store(-1.0f); // -1 = inactive
    for (auto& p : vizData.holdEndPositions) p.store(-1.0f);
}

void BitCrusherModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    tempBuffer.setSize(2, samplesPerBlock);
    
    // Initialize visualization buffers
    vizInputBuffer.setSize(2, vizBufferSize);
    vizOutputBuffer.setSize(2, vizBufferSize);
    vizDecimatedBuffer.setSize(2, vizBufferSize);
    vizInputBuffer.clear();
    vizOutputBuffer.clear();
    vizDecimatedBuffer.clear();
    vizWritePos = 0;
    
    // Reset hold tracking
    trackedHoldCount = 0;
    lastHoldStartPos = -1.0f;
    for (auto& hold : trackedHolds)
    {
        hold.startIdx = -1;
        hold.endIdx = -1;
        hold.value = 0.0f;
    }
    
    // Set smoothing time for parameters (10ms)
    mBitDepthSm.reset(sampleRate, 0.01);
    mSampleRateSm.reset(sampleRate, 0.01);
    
    // Prepare anti-aliasing filters
    juce::dsp::ProcessSpec specL { sampleRate, (juce::uint32)samplesPerBlock, 1 };
    juce::dsp::ProcessSpec specR { sampleRate, (juce::uint32)samplesPerBlock, 1 };
    mAntiAliasFilterL.prepare(specL);
    mAntiAliasFilterR.prepare(specR);
    mAntiAliasFilterL.setType(juce::dsp::StateVariableTPTFilterType::lowpass);
    mAntiAliasFilterR.setType(juce::dsp::StateVariableTPTFilterType::lowpass);
    
    // Reset quantization errors
    mQuantErrorL = 0.0f;
    mQuantErrorR = 0.0f;
}

void BitCrusherModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    
    auto inBus = getBusBuffer(buffer, true, 0);
    auto outBus = getBusBuffer(buffer, false, 0);
    
    const float baseBitDepth = bitDepthParam != nullptr ? bitDepthParam->load() : 16.0f;
    const float baseSampleRate = sampleRateParam != nullptr ? sampleRateParam->load() : 1.0f;
    const float mixAmount = mixParam != nullptr ? mixParam->load() : 1.0f;

    const int numInputChannels = inBus.getNumChannels();
    const int numOutputChannels = outBus.getNumChannels();
    const int numSamples = buffer.getNumSamples();
    const int numChannels = juce::jmin(numInputChannels, numOutputChannels);

    // ✅ CRITICAL FIX: Read CV inputs BEFORE any output operations to avoid buffer aliasing issues
    // According to DEBUG_INPUT_IMPORTANT.md: "Read all inputs BEFORE clearing any outputs"
    // Get pointers to modulation CV inputs from unified input bus FIRST
    // Use virtual _mod IDs as per BestPracticeNodeProcessor.md
    const bool isBitDepthMod = isParamInputConnected(paramIdBitDepthMod);
    const bool isSampleRateMod = isParamInputConnected(paramIdSampleRateMod);
    const bool isMixMod = isParamInputConnected(paramIdMixMod);
    const bool isAntiAliasMod = isParamInputConnected(paramIdAntiAliasMod);
    const bool isQuantModeMod = isParamInputConnected(paramIdQuantModeMod);
    const float* bitDepthCV = isBitDepthMod && inBus.getNumChannels() > 2 ? inBus.getReadPointer(2) : nullptr;
    const float* sampleRateCV = isSampleRateMod && inBus.getNumChannels() > 3 ? inBus.getReadPointer(3) : nullptr;
    const float* mixCV = isMixMod && inBus.getNumChannels() > 4 ? inBus.getReadPointer(4) : nullptr;
    const float* antiAliasCV = isAntiAliasMod && inBus.getNumChannels() > 5 ? inBus.getReadPointer(5) : nullptr;
    const float* quantModeCV = isQuantModeMod && inBus.getNumChannels() > 6 ? inBus.getReadPointer(6) : nullptr;
    
    const bool baseAntiAlias = antiAliasParam != nullptr && antiAliasParam->load() > 0.5f;
    const int baseQuantMode = quantModeParam != nullptr ? static_cast<int>(quantModeParam->load()) : 0;
    const bool relativeBitDepthMode = relativeBitDepthModParam != nullptr && relativeBitDepthModParam->load() > 0.5f;
    const bool relativeSampleRateMode = relativeSampleRateModParam != nullptr && relativeSampleRateModParam->load() > 0.5f;
    const bool relativeMixMode = relativeMixModParam != nullptr && relativeMixModParam->load() > 0.5f;

    // ✅ Now safe to copy input to output (CV pointers already obtained)
    if (numInputChannels > 0)
    {
        // If input is mono, copy it to both left and right outputs.
        if (numInputChannels == 1 && numOutputChannels > 1)
        {
            outBus.copyFrom(0, 0, inBus, 0, 0, numSamples);
            outBus.copyFrom(1, 0, inBus, 0, 0, numSamples);
        }
        // Otherwise, perform a standard stereo copy.
        else
        {
            const int channelsToCopy = juce::jmin(numInputChannels, numOutputChannels);
            for (int ch = 0; ch < channelsToCopy; ++ch)
            {
                outBus.copyFrom(ch, 0, inBus, ch, 0, numSamples);
            }
        }
    }
    else
    {
        // If no input is connected, ensure the output is silent.
        // ✅ Safe to clear here - we've already read CV inputs above
        outBus.clear();
    }

    // If bit depth is at maximum and sample rate is at maximum and mix is fully dry, we can skip processing entirely.
    if (baseBitDepth >= 23.99f && baseSampleRate >= 0.999f && mixAmount <= 0.001f)
    {
        // Update output values for tooltips
        if (lastOutputValues.size() >= 2)
        {
            if (lastOutputValues[0]) lastOutputValues[0]->store(outBus.getSample(0, buffer.getNumSamples() - 1));
            if (lastOutputValues[1] && numChannels > 1) lastOutputValues[1]->store(outBus.getSample(1, buffer.getNumSamples() - 1));
        }
        return;
    }

    // --- Dry/Wet Mix Implementation (inspired by DriveModuleProcessor) ---
    // 1. Make a copy of the original (dry) signal.
    tempBuffer.makeCopyOf(outBus);

    // Create temporary single-sample buffers for anti-aliasing filter processing (per channel)
    juce::AudioBuffer<float> sampleBufferL(1, 1);
    juce::AudioBuffer<float> sampleBufferR(1, 1);
    juce::dsp::AudioBlock<float> blockL(sampleBufferL);
    juce::dsp::AudioBlock<float> blockR(sampleBufferR);
    juce::dsp::ProcessContextReplacing<float> contextL(blockL);
    juce::dsp::ProcessContextReplacing<float> contextR(blockR);

    // Process each channel
    for (int ch = 0; ch < numChannels; ++ch)
    {
        float* data = outBus.getWritePointer(ch);
        const float* dryData = tempBuffer.getReadPointer(ch);
        
        // Per-channel decimator state
        float& srCounter = (ch == 0) ? mSrCounterL : mSrCounterR;
        float& lastSample = (ch == 0) ? mLastSampleL : mLastSampleR;
        
        // Per-channel quantization error state
        float& quantError = (ch == 0) ? mQuantErrorL : mQuantErrorR;
        
        // Select the correct anti-aliasing filter and context for this channel
        auto& antiAliasFilter = (ch == 0) ? mAntiAliasFilterL : mAntiAliasFilterR;
        auto& sampleBuffer = (ch == 0) ? sampleBufferL : sampleBufferR;
        auto& context = (ch == 0) ? contextL : contextR;
        
        for (int i = 0; i < numSamples; ++i)
        {
            // PER-SAMPLE FIX: Calculate effective bit depth FOR THIS SAMPLE
            float bitDepth = baseBitDepth;
            if (isBitDepthMod && bitDepthCV != nullptr) {
                const float cv = juce::jlimit(0.0f, 1.0f, bitDepthCV[i]);
                if (relativeBitDepthMode) {
                    // RELATIVE: ±12 bits around base (e.g., base 16 -> range 4-28, clamped to 1-24)
                    const float bitRange = 12.0f;
                    const float bitOffset = (cv - 0.5f) * (bitRange * 2.0f);
                    bitDepth = baseBitDepth + bitOffset;
                } else {
                    // ABSOLUTE: CV directly sets bit depth (1-24)
                    bitDepth = juce::jmap(cv, 1.0f, 24.0f);
                }
                bitDepth = juce::jlimit(1.0f, 24.0f, bitDepth);
            }
            
            // Apply smoothing to bit depth to prevent zipper noise
            mBitDepthSm.setTargetValue(bitDepth);
            bitDepth = mBitDepthSm.getNextValue();
            
            // PER-SAMPLE FIX: Calculate effective sample rate FOR THIS SAMPLE
            float sampleRate = baseSampleRate;
            if (isSampleRateMod && sampleRateCV != nullptr) {
                const float cv = juce::jlimit(0.0f, 1.0f, sampleRateCV[i]);
                if (relativeSampleRateMode) {
                    // RELATIVE: ±3 octaves (0.125x to 8x, clamped to 0.1x-1.0x)
                    const float octaveRange = 3.0f;
                    const float octaveOffset = (cv - 0.5f) * (octaveRange * 2.0f);
                    sampleRate = baseSampleRate * std::pow(2.0f, octaveOffset);
                } else {
                    // ABSOLUTE: CV directly sets sample rate (0.1-1.0)
                    sampleRate = juce::jmap(cv, 0.1f, 1.0f);
                }
                sampleRate = juce::jlimit(0.1f, 1.0f, sampleRate);
            }
            
            // Apply smoothing to sample rate to prevent clicks
            mSampleRateSm.setTargetValue(sampleRate);
            sampleRate = mSampleRateSm.getNextValue();
            
            // Determine effective anti-aliasing state for this sample
            bool isAntiAliasOn = baseAntiAlias;
            if (isAntiAliasMod && antiAliasCV != nullptr) {
                isAntiAliasOn = (antiAliasCV[i] > 0.5f);
            }
            
            // Determine effective quantization mode for this sample
            int quantMode = baseQuantMode;
            if (isQuantModeMod && quantModeCV != nullptr) {
                quantMode = static_cast<int>(juce::jmap(juce::jlimit(0.0f, 1.0f, quantModeCV[i]), 0.0f, 2.99f));
            }
            
            // PER-SAMPLE FIX: Calculate effective mix FOR THIS SAMPLE
            float mixAmountPerSample = mixAmount;
            if (isMixMod && mixCV != nullptr) {
                const float cv = juce::jlimit(0.0f, 1.0f, mixCV[i]);
                if (relativeMixMode) {
                    // RELATIVE: ±0.5 around base mix (e.g., base 0.5 -> range 0.0-1.0, clamped to 0-1)
                    const float mixRange = 0.5f;
                    const float mixOffset = (cv - 0.5f) * (mixRange * 2.0f);
                    mixAmountPerSample = mixAmount + mixOffset;
                } else {
                    // ABSOLUTE: CV directly sets mix (0-1)
                    mixAmountPerSample = cv;
                }
                mixAmountPerSample = juce::jlimit(0.0f, 1.0f, mixAmountPerSample);
            }
            
            // Get the sample *before* decimation
            float sampleToDecimate = data[i];
            
            // Update the anti-aliasing filter cutoff based on the *current* smoothed sample rate
            antiAliasFilter.setCutoffFrequency(sampleRate * (getSampleRate() * 0.45f));
            
            // Conditionally filter the sample using ProcessContextReplacing (like VCFModuleProcessor)
            if (isAntiAliasOn) {
                sampleBuffer.setSample(0, 0, sampleToDecimate);
                antiAliasFilter.process(context);
                sampleToDecimate = sampleBuffer.getSample(0, 0);
            }
            
            // Now, perform the sample-and-hold on the (potentially filtered) sample
            // Track hold regions for visualization
            const bool wasHolding = (srCounter > 0.0f && srCounter < 1.0f);
            srCounter += sampleRate;
            const bool holdJustStarted = (srCounter >= 1.0f) && wasHolding;
            
            if (srCounter >= 1.0f)
            {
                srCounter -= 1.0f;
                lastSample = sampleToDecimate;
                
                // Track hold start for visualization (throttled, every 64 samples)
                if (ch == 0 && (i & 0x3F) == 0) // Only track left channel, throttled
                {
                    // Calculate normalized position in waveform snapshot
                    const float posInBuffer = (float)vizWritePos / (float)vizBufferSize;
                    const int snapshotIdx = (int)(posInBuffer * (float)VizData::waveformPoints) % VizData::waveformPoints;
                    
                    // Record that a new hold started here
                    lastHoldStartPos = snapshotIdx;
                }
            }
            float decimatedSample = lastSample;
            
            // Record decimated sample (before quantization) for visualization
            if (ch == 0) // Only record once per sample (left channel)
            {
                vizDecimatedBuffer.setSample(0, vizWritePos, decimatedSample);
            }
            
            // --- New Quantization Logic ---
            float numLevels = std::exp2(bitDepth);
            float step = 2.0f / (numLevels - 1.0f); // Step size for [-1, 1] range
            
            float dither = 0.0f;
            float sampleToQuantize = decimatedSample;
            
            switch (quantMode)
            {
                case 1: // Dither (TPDF)
                    dither = (mRandom.nextFloat() - mRandom.nextFloat()) * 0.5f * step;
                    quantError = 0.0f; // Reset error if switching
                    break;
                case 2: // Noise Shaping
                    dither = (mRandom.nextFloat() - mRandom.nextFloat()) * 0.5f * step;
                    sampleToQuantize += quantError; // Add previous sample's error
                    break;
                case 0: // Linear
                default:
                    quantError = 0.0f; // Reset error
                    break;
            }
            
            // Quantize using floor-rounding
            float quantizedSample = std::floor((sampleToQuantize + dither) / step + 0.5f) * step;
            quantizedSample = juce::jlimit(-1.0f, 1.0f, quantizedSample);
            
            // If noise shaping, calculate and store the error for the *next* sample
            if (quantMode == 2)
            {
                float error = sampleToQuantize - quantizedSample;
                quantError = error * 0.95f; // Simple 1-pole high-pass on error
            }
            // --- End of New Quantization Logic ---
            
            // Apply dry/wet mix (using per-sample modulated mix amount)
            const float dryLevel = 1.0f - mixAmountPerSample;
            const float wetLevel = mixAmountPerSample;
            data[i] = dryData[i] * dryLevel + quantizedSample * wetLevel;
            
            // Record to visualization buffers (circular)
            if (ch == 0) // Only record once per sample (left channel)
            {
                vizInputBuffer.setSample(0, vizWritePos, dryData[i]);
                vizOutputBuffer.setSample(0, vizWritePos, data[i]);
                if (vizInputBuffer.getNumChannels() > 1 && vizOutputBuffer.getNumChannels() > 1)
                {
                    vizInputBuffer.setSample(1, vizWritePos, tempBuffer.getSample(1, i));
                    vizOutputBuffer.setSample(1, vizWritePos, outBus.getSample(1, i));
                }
                vizWritePos = (vizWritePos + 1) % vizBufferSize;
                
                // Update visualization data (throttled - every 64 samples, like Granulator)
                if ((i & 0x3F) == 0)
                {
                    // Update current quantization state
                    vizData.currentBitDepth.store(mBitDepthSm.getCurrentValue());
                    vizData.currentSampleRate.store(mSampleRateSm.getCurrentValue());
                    vizData.currentQuantMode.store(baseQuantMode);
                    vizData.currentAntiAlias.store(baseAntiAlias);
                    
                    // Update waveform snapshots (downsampled from circular buffer)
                    const int step = vizBufferSize / VizData::waveformPoints;
                    for (int j = 0; j < VizData::waveformPoints; ++j)
                    {
                        int idx = (vizWritePos - (VizData::waveformPoints - j) * step + vizBufferSize) % vizBufferSize;
                        vizData.inputWaveformL[j].store(vizInputBuffer.getSample(0, idx));
                        vizData.outputWaveformL[j].store(vizOutputBuffer.getSample(0, idx));
                        if (vizInputBuffer.getNumChannels() > 1 && vizOutputBuffer.getNumChannels() > 1)
                        {
                            vizData.inputWaveformR[j].store(vizInputBuffer.getSample(1, idx));
                            vizData.outputWaveformR[j].store(vizOutputBuffer.getSample(1, idx));
                        }
                    }
                    
                    // Track sample-and-hold regions from actual decimator state
                    // Find holds by looking for flat regions in the decimated buffer
                    int activeHoldIdx = 0;
                    const float sampleRateValue = mSampleRateSm.getCurrentValue();
                    const float tolerance = 0.01f; // Samples within this range are considered "held"
                    
                    if (sampleRateValue < 0.999f && VizData::waveformPoints > 1) // Only track holds if sample rate is reduced
                    {
                        // Scan the decimated waveform for flat regions (holds)
                        // A hold is a region where consecutive samples are approximately equal
                        float currentHoldStart = -1.0f;
                        float currentHoldValue = 0.0f;
                        
                        for (int k = 0; k < VizData::waveformPoints && activeHoldIdx < 64; ++k)
                        {
                            const float decimatedVal = vizDecimatedBuffer.getSample(0, (vizWritePos - (VizData::waveformPoints - k) + vizBufferSize) % vizBufferSize);
                            const float normalizedPos = (float)k / (float)(VizData::waveformPoints - 1);
                            
                            if (currentHoldStart < 0.0f)
                            {
                                // Not currently in a hold - check if we should start one
                                // Look ahead to see if next samples are similar
                                if (k < VizData::waveformPoints - 1)
                                {
                                    const int nextIdx = (vizWritePos - (VizData::waveformPoints - (k + 1)) + vizBufferSize) % vizBufferSize;
                                    const float nextVal = vizDecimatedBuffer.getSample(0, nextIdx);
                                    if (std::abs(decimatedVal - nextVal) < tolerance)
                                    {
                                        // Start a hold
                                        currentHoldStart = normalizedPos;
                                        currentHoldValue = decimatedVal;
                                    }
                                }
                            }
                            else
                            {
                                // Currently in a hold - check if it continues
                                if (k == VizData::waveformPoints - 1 || 
                                    std::abs(decimatedVal - currentHoldValue) > tolerance)
                                {
                                    // End the hold
                                    const float holdEnd = (k == VizData::waveformPoints - 1) 
                                        ? 1.0f 
                                        : ((float)k - 1.0f) / (float)(VizData::waveformPoints - 1);
                                    
                                    // Only record holds that are long enough (at least 2% of waveform width)
                                    if (holdEnd - currentHoldStart > 0.02f)
                                    {
                                        vizData.holdStartPositions[activeHoldIdx].store(currentHoldStart);
                                        vizData.holdEndPositions[activeHoldIdx].store(holdEnd);
                                        vizData.holdValues[activeHoldIdx].store(currentHoldValue);
                                        activeHoldIdx++;
                                    }
                                    
                                    // Check if we should start a new hold
                                    currentHoldStart = -1.0f;
                                    if (k < VizData::waveformPoints - 1)
                                    {
                                        const int nextIdx = (vizWritePos - (VizData::waveformPoints - (k + 1)) + vizBufferSize) % vizBufferSize;
                                        const float nextVal = vizDecimatedBuffer.getSample(0, nextIdx);
                                        if (std::abs(decimatedVal - nextVal) < tolerance)
                                        {
                                            currentHoldStart = normalizedPos;
                                            currentHoldValue = decimatedVal;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Close any remaining hold
                        if (currentHoldStart >= 0.0f && activeHoldIdx < 64)
                        {
                            const float holdEnd = 1.0f;
                            if (holdEnd - currentHoldStart > 0.02f)
                            {
                                vizData.holdStartPositions[activeHoldIdx].store(currentHoldStart);
                                vizData.holdEndPositions[activeHoldIdx].store(holdEnd);
                                vizData.holdValues[activeHoldIdx].store(currentHoldValue);
                                activeHoldIdx++;
                            }
                        }
                    }
                    
                    vizData.activeHoldCount.store(activeHoldIdx);
                    
                    // Clear inactive hold slots
                    for (int j = activeHoldIdx; j < 64; ++j)
                    {
                        vizData.holdStartPositions[j].store(-1.0f);
                        vizData.holdEndPositions[j].store(-1.0f);
                        vizData.holdValues[j].store(0.0f);
                    }
                }
                
                // Update telemetry (throttled - every 64 samples as per BestPracticeNodeProcessor.md)
                // Only update once per sample (on left channel) to avoid redundant updates
                if (ch == 0 && (i & 0x3F) == 0) {
                    setLiveParamValue("bit_depth_live", bitDepth);
                    setLiveParamValue("sample_rate_live", sampleRate);
                    setLiveParamValue("mix_live", mixAmountPerSample);
                    setLiveParamValue("antiAlias_live", isAntiAliasOn ? 1.0f : 0.0f);
                    setLiveParamValue("quant_mode_live", static_cast<float>(quantMode));
                }
            }
        }
    }
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(outBus.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1] && numChannels > 1) lastOutputValues[1]->store(outBus.getSample(1, buffer.getNumSamples() - 1));
    }
}

bool BitCrusherModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0; // All modulation is on the single input bus
    
    // Use virtual _mod IDs as per BestPracticeNodeProcessor.md
    if (paramId == paramIdBitDepthMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdSampleRateMod) { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdMixMod) { outChannelIndexInBus = 4; return true; }
    if (paramId == paramIdAntiAliasMod) { outChannelIndexInBus = 5; return true; }
    if (paramId == paramIdQuantModeMod) { outChannelIndexInBus = 6; return true; }
    return false;
}

juce::String BitCrusherModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "In L";
        case 1: return "In R";
        case 2: return "Bit Depth Mod";
        case 3: return "Sample Rate Mod";
        case 4: return "Mix Mod";
        case 5: return "Anti-Alias Mod";
        case 6: return "Quant Mode Mod";
        default: return juce::String("In ") + juce::String(channel + 1);
    }
}

juce::String BitCrusherModuleProcessor::getAudioOutputLabel(int channel) const
{
    if (channel == 0) return "Out L";
    if (channel == 1) return "Out R";
    return {};
}

#if defined(PRESET_CREATOR_UI)
void BitCrusherModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    const auto& theme = ThemeManager::getInstance().getCurrentTheme();
    auto& ap = getAPVTS();
    ImGui::PushItemWidth(itemWidth);

    auto HelpMarker = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) { ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f); ImGui::TextUnformatted(desc); ImGui::PopTextWrapPos(); ImGui::EndTooltip(); }
    };

    ThemeText("Bit Crusher Parameters", theme.text.section_header);
    ImGui::Spacing();

    // === BIT CRUSHER VISUALIZATION ===
    ImGui::Spacing();
    ImGui::Text("Waveform Visualization");
    ImGui::Spacing();

    // Draw waveform visualization with pixelated output
    auto* drawList = ImGui::GetWindowDrawList();
    const ImVec2 origin = ImGui::GetCursorScreenPos();
    const float vizWidth = itemWidth;
    const float vizHeight = 120.0f;
    const ImVec2 rectMax = ImVec2(origin.x + vizWidth, origin.y + vizHeight);
    
    // Get theme colors for visualization with nice variation
    auto& themeMgr = ThemeManager::getInstance();
    auto resolveColor = [](ImU32 primary, ImU32 secondary, ImU32 tertiary) -> ImU32 {
        if (primary != 0) return primary;
        if (secondary != 0) return secondary;
        return tertiary;
    };
    
    // Background: scope_plot_bg -> canvas_background -> ChildBg -> fallback
    const ImU32 canvasBg = themeMgr.getCanvasBackground();
    const ImVec4 childBgVec4 = ImGui::GetStyle().Colors[ImGuiCol_ChildBg];
    const ImU32 childBg = ImGui::ColorConvertFloat4ToU32(childBgVec4);
    const ImU32 bgColor = resolveColor(theme.modules.scope_plot_bg, canvasBg, childBg);
    
    // Input waveform: Use modulation.frequency (cyan) for distinct input color
    const ImVec4 frequencyColorVec4 = theme.modulation.frequency;
    const ImU32 frequencyColor = ImGui::ColorConvertFloat4ToU32(ImVec4(frequencyColorVec4.x, frequencyColorVec4.y, frequencyColorVec4.z, 0.6f));
    const ImU32 inputWaveformColor = resolveColor(theme.modules.scope_plot_fg, frequencyColor, IM_COL32(100, 200, 255, 150));
    
    // Output waveform: Use modulation.timbre (orange/yellow) for distinct output color
    const ImVec4 timbreColorVec4 = theme.modulation.timbre;
    const ImU32 timbreColor = ImGui::ColorConvertFloat4ToU32(ImVec4(timbreColorVec4.x, timbreColorVec4.y, timbreColorVec4.z, 1.0f));
    const ImVec4 accentVec4 = theme.accent;
    const ImU32 accentColor = ImGui::ColorConvertFloat4ToU32(ImVec4(accentVec4.x, accentVec4.y, accentVec4.z, 1.0f));
    const ImU32 outputWaveformColor = (timbreColor != 0) ? timbreColor : IM_COL32(255, 150, 100, 255);
    
    // Quant grid: Use muted scope_plot_fg or frequency color
    const ImU32 scopePlotFg = theme.modules.scope_plot_fg;
    const ImU32 quantGridColorBase = resolveColor(scopePlotFg, frequencyColor, IM_COL32(150, 150, 150, 80));
    const ImVec4 quantGridVec4 = ImGui::ColorConvertU32ToFloat4(quantGridColorBase);
    const ImU32 quantGridColor = ImGui::ColorConvertFloat4ToU32(ImVec4(quantGridVec4.x, quantGridVec4.y, quantGridVec4.z, 0.3f));
    
    // Hold regions: Use modulation.amplitude (magenta/pink) for distinct hold color
    const ImVec4 amplitudeColorVec4 = theme.modulation.amplitude;
    const ImU32 amplitudeColor = ImGui::ColorConvertFloat4ToU32(ImVec4(amplitudeColorVec4.x, amplitudeColorVec4.y, amplitudeColorVec4.z, 0.4f));
    const ImU32 holdRegionColor = (amplitudeColor != 0) ? amplitudeColor : IM_COL32(255, 200, 100, 100);
    
    // Hold region background: Same color but more transparent
    const ImVec4 holdRegionVec4 = ImGui::ColorConvertU32ToFloat4(holdRegionColor);
    const ImU32 holdRegionBgColor = ImGui::ColorConvertFloat4ToU32(ImVec4(holdRegionVec4.x, holdRegionVec4.y, holdRegionVec4.z, 0.12f));
    
    drawList->AddRectFilled(origin, rectMax, bgColor, 4.0f);
    ImGui::PushClipRect(origin, rectMax, true);
    
    // Read visualization data (thread-safe)
    float inputWaveform[VizData::waveformPoints];
    float outputWaveform[VizData::waveformPoints];
    for (int i = 0; i < VizData::waveformPoints; ++i)
    {
        inputWaveform[i] = vizData.inputWaveformL[i].load();
        outputWaveform[i] = vizData.outputWaveformL[i].load();
    }
    const float currentBitDepth = vizData.currentBitDepth.load();
    const float currentSampleRate = vizData.currentSampleRate.load();
    const int currentQuantMode = vizData.currentQuantMode.load();
    const bool currentAntiAlias = vizData.currentAntiAlias.load();
    const int activeHoldCount = vizData.activeHoldCount.load();
    float holdStarts[64], holdEnds[64], holdVals[64];
    for (int i = 0; i < 64; ++i)
    {
        holdStarts[i] = vizData.holdStartPositions[i].load();
        holdEnds[i] = vizData.holdEndPositions[i].load();
        holdVals[i] = vizData.holdValues[i].load();
    }
    
    const float midY = origin.y + vizHeight * 0.5f;
    const float scaleY = vizHeight * 0.4f;
    const float stepX = vizWidth / (float)(VizData::waveformPoints - 1);
    
    // Calculate quantization grid (horizontal lines)
    const float numLevels = std::exp2(currentBitDepth);
    const int maxGridLines = 32; // Limit grid lines for visibility
    const int numGridLines = juce::jmin(static_cast<int>(numLevels), maxGridLines);
    const float gridStep = 2.0f / (numLevels - 1.0f);
    
    // Draw quantization grid (horizontal lines) - behind everything
    if (currentBitDepth < 16.0f) // Only show grid for lower bit depths
    {
        for (int i = 0; i <= numGridLines; ++i)
        {
            const float level = -1.0f + (float)i * gridStep * (numLevels - 1.0f) / (float)numGridLines;
            const float y = midY - juce::jlimit(-1.0f, 1.0f, level) * scaleY;
            drawList->AddLine(ImVec2(origin.x, y), ImVec2(rectMax.x, y), quantGridColor, 
                            currentBitDepth < 8.0f ? 1.5f : 0.5f);
        }
    }
    
    // Draw sample-and-hold background regions (subtle highlight, behind waveforms)
    for (int i = 0; i < activeHoldCount; ++i)
    {
        const float startNorm = holdStarts[i];
        const float endNorm = holdEnds[i];
        
        if (startNorm >= 0.0f && endNorm >= 0.0f && startNorm <= 1.0f && endNorm <= 1.0f && endNorm > startNorm)
        {
            const float startX = origin.x + startNorm * vizWidth;
            const float endX = origin.x + endNorm * vizWidth;
            
            // Draw subtle background region to highlight hold area (behind waveforms)
            drawList->AddRectFilled(ImVec2(startX, origin.y), ImVec2(endX, rectMax.y), 
                                   holdRegionBgColor, 0.0f);
        }
    }
    
    // Calculate pixel size based on bit depth (fewer bits = larger pixels)
    float pixelHeight = 1.0f;
    if (currentBitDepth <= 4.0f) pixelHeight = 8.0f;
    else if (currentBitDepth <= 8.0f) pixelHeight = 4.0f;
    else if (currentBitDepth <= 12.0f) pixelHeight = 2.0f;
    else if (currentBitDepth <= 16.0f) pixelHeight = 1.0f;
    else pixelHeight = 0.5f;
    
    // Draw input waveform (smooth, faded)
    float prevX = origin.x, prevY = midY;
    for (int i = 0; i < VizData::waveformPoints; ++i)
    {
        const float sample = juce::jlimit(-1.0f, 1.0f, inputWaveform[i]);
        const float x = origin.x + i * stepX;
        const float y = midY - sample * scaleY;
        if (i > 0) drawList->AddLine(ImVec2(prevX, prevY), ImVec2(x, y), inputWaveformColor, 1.5f);
        prevX = x; prevY = y;
    }
    
    // Draw output waveform (pixelated based on bit depth only, NOT sample rate)
    // Pixelation represents quantization (vertical steps), not decimation (horizontal holds)
    // Sample rate is already shown as horizontal flat segments above
    
    // Group samples into small segments for pixelation effect (based on visualization resolution)
    const int samplesPerSegment = juce::jmax(1, VizData::waveformPoints / 128); // ~2 samples per pixel
    
    for (int i = 0; i < VizData::waveformPoints; i += samplesPerSegment)
    {
        // Average samples in this segment
        float sum = 0.0f;
        int count = 0;
        for (int j = 0; j < samplesPerSegment && (i + j) < VizData::waveformPoints; ++j)
        {
            sum += outputWaveform[i + j];
            count++;
        }
        if (count > 0)
        {
            float avgSample = juce::jlimit(-1.0f, 1.0f, sum / (float)count);
            
            // Quantize to pixel height (bit depth dependent only)
            const float quantizedLevel = std::floor(avgSample / gridStep + 0.5f) * gridStep;
            const float quantizedY = midY - juce::jlimit(-1.0f, 1.0f, quantizedLevel) * scaleY;
            
            const float x1 = origin.x + i * stepX;
            const float x2 = origin.x + juce::jmin((float)VizData::waveformPoints - 1, (float)(i + samplesPerSegment)) * stepX;
            
            // Draw pixel rectangle (height represents quantization, width is just for smoothness)
            const float y1 = quantizedY - pixelHeight * 0.5f * scaleY / 16.0f;
            const float y2 = quantizedY + pixelHeight * 0.5f * scaleY / 16.0f;
            
            // Mode-specific styling with theme color variations
            ImU32 pixelColor = outputWaveformColor;
            if (currentQuantMode == 1) // Dither - slightly lighter/more transparent
            {
                const ImVec4 timbreVec4 = ImGui::ColorConvertU32ToFloat4(timbreColor);
                pixelColor = ImGui::ColorConvertFloat4ToU32(ImVec4(timbreVec4.x, timbreVec4.y, timbreVec4.z, 0.85f));
            }
            else if (currentQuantMode == 2) // Noise Shaping - slightly brighter
            {
                const ImVec4 timbreVec4 = ImGui::ColorConvertU32ToFloat4(timbreColor);
                // Brighten slightly for noise shaping
                pixelColor = ImGui::ColorConvertFloat4ToU32(ImVec4(
                    juce::jmin(1.0f, timbreVec4.x * 1.1f),
                    juce::jmin(1.0f, timbreVec4.y * 1.1f),
                    juce::jmin(1.0f, timbreVec4.z * 1.1f),
                    0.95f));
            }
            
            drawList->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), pixelColor, 0.0f);
        }
    }
    
    // Draw sample-and-hold regions as horizontal flat segments ON TOP (shows sample rate reduction)
    // These appear AFTER quantization pixelation so they're clearly visible
    for (int i = 0; i < activeHoldCount; ++i)
    {
        const float startNorm = holdStarts[i];
        const float endNorm = holdEnds[i];
        const float holdValue = holdVals[i];
        
        if (startNorm >= 0.0f && endNorm >= 0.0f && startNorm <= 1.0f && endNorm <= 1.0f && endNorm > startNorm)
        {
            const float startX = origin.x + startNorm * vizWidth;
            const float endX = origin.x + endNorm * vizWidth;
            const float holdY = midY - juce::jlimit(-1.0f, 1.0f, holdValue) * scaleY;
            
            // Draw horizontal flat line for the hold (thick, on top for visibility)
            drawList->AddLine(ImVec2(startX, holdY), ImVec2(endX, holdY), 
                            holdRegionColor, 3.0f); // Thick line to clearly show hold
            
            // Draw subtle outline around hold for extra visibility
            const ImVec4 holdOutlineVec4 = ImGui::ColorConvertU32ToFloat4(holdRegionColor);
            const ImU32 holdOutlineColor = ImGui::ColorConvertFloat4ToU32(ImVec4(
                holdOutlineVec4.x, holdOutlineVec4.y, holdOutlineVec4.z, 0.6f));
            drawList->AddLine(ImVec2(startX, holdY - 1.0f), ImVec2(endX, holdY - 1.0f), holdOutlineColor, 1.0f);
            drawList->AddLine(ImVec2(startX, holdY + 1.0f), ImVec2(endX, holdY + 1.0f), holdOutlineColor, 1.0f);
        }
    }
    
    // Draw center line - use muted quant grid color
    const ImVec4 centerLineVec4 = ImGui::ColorConvertU32ToFloat4(quantGridColorBase);
    const ImU32 centerLineColor = ImGui::ColorConvertFloat4ToU32(ImVec4(centerLineVec4.x, centerLineVec4.y, centerLineVec4.z, 0.4f));
    drawList->AddLine(ImVec2(origin.x, midY), ImVec2(rectMax.x, midY), 
                     centerLineColor, 1.0f);
    
    ImGui::PopClipRect();
    ImGui::SetCursorScreenPos(ImVec2(origin.x, rectMax.y));
    ImGui::Dummy(ImVec2(vizWidth, 0));
    
    // Parameter meters - use accent color for progress bars
    ImGui::Text("Bit Depth: %.1f bits", currentBitDepth);
    float bitDepthMeter = (currentBitDepth - 1.0f) / 23.0f;
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, accentColor);
    ImGui::ProgressBar(bitDepthMeter, ImVec2(itemWidth * 0.5f, 0), "");
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::Text("%.0f%%", bitDepthMeter * 100.0f);
    
    ImGui::Text("Sample Rate: %.3fx", currentSampleRate);
    float sampleRateMeter = (currentSampleRate - 0.1f) / 0.9f;
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, accentColor);
    ImGui::ProgressBar(sampleRateMeter, ImVec2(itemWidth * 0.5f, 0), "");
    ImGui::PopStyleColor();
    ImGui::SameLine();
    ImGui::Text("%.0f%%", sampleRateMeter * 100.0f);
    
    // Quantization info
    const char* modeNames[] = { "Linear", "Dither (TPDF)", "Noise Shaping" };
    ImGui::Text("Quant Mode: %s | AA: %s", 
                modeNames[currentQuantMode], 
                currentAntiAlias ? "ON" : "OFF");
    
    ImGui::Spacing();
    ImGui::Spacing();

    // Bit Depth
    // Use virtual _mod ID to check for modulation as per BestPracticeNodeProcessor.md
    bool isBitDepthModulated = isParamModulated(paramIdBitDepthMod);
    // Get live value if modulated, otherwise use base parameter value
    float bitDepth = isBitDepthModulated 
        ? getLiveParamValueFor(paramIdBitDepthMod, "bit_depth_live", bitDepthParam != nullptr ? bitDepthParam->load() : 16.0f)
        : (bitDepthParam != nullptr ? bitDepthParam->load() : 16.0f);
    if (isBitDepthModulated) {
        ImGui::BeginDisabled();
    }
    if (ImGui::SliderFloat("Bit Depth", &bitDepth, 1.0f, 24.0f, "%.2f bits", ImGuiSliderFlags_Logarithmic)) {
        if (!isBitDepthModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdBitDepth))) *p = bitDepth;
        }
    }
    if (!isBitDepthModulated) adjustParamOnWheel(ap.getParameter(paramIdBitDepth), paramIdBitDepth, bitDepth);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isBitDepthModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarker("Bit depth reduction (1-24 bits)\nLower values create more quantization artifacts\nLogarithmic scale for fine control");

    // Sample Rate
    // Use virtual _mod ID to check for modulation as per BestPracticeNodeProcessor.md
    bool isSampleRateModulated = isParamModulated(paramIdSampleRateMod);
    // Get live value if modulated, otherwise use base parameter value
    float sampleRate = isSampleRateModulated
        ? getLiveParamValueFor(paramIdSampleRateMod, "sample_rate_live", sampleRateParam != nullptr ? sampleRateParam->load() : 1.0f)
        : (sampleRateParam != nullptr ? sampleRateParam->load() : 1.0f);
    if (isSampleRateModulated) {
        ImGui::BeginDisabled();
    }
    if (ImGui::SliderFloat("Sample Rate", &sampleRate, 0.1f, 1.0f, "%.3fx", ImGuiSliderFlags_Logarithmic)) {
        if (!isSampleRateModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdSampleRate))) *p = sampleRate;
        }
    }
    if (!isSampleRateModulated) adjustParamOnWheel(ap.getParameter(paramIdSampleRate), paramIdSampleRate, sampleRate);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isSampleRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarker("Sample rate reduction (0.1x-1.0x)\nLower values create more aliasing and stuttering\n1.0x = full rate, 0.1x = 10% of original rate");

    // Mix
    // Use virtual _mod ID to check for modulation as per BestPracticeNodeProcessor.md
    bool isMixModulated = isParamModulated(paramIdMixMod);
    // Get live value if modulated, otherwise use base parameter value
    float mix = isMixModulated
        ? getLiveParamValueFor(paramIdMixMod, "mix_live", mixParam != nullptr ? mixParam->load() : 1.0f)
        : (mixParam != nullptr ? mixParam->load() : 1.0f);
    if (isMixModulated) {
        ImGui::BeginDisabled();
    }
    if (ImGui::SliderFloat("Mix", &mix, 0.0f, 1.0f, "%.2f")) {
        if (!isMixModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdMix))) *p = mix;
        }
    }
    if (!isMixModulated) adjustParamOnWheel(ap.getParameter(paramIdMix), paramIdMix, mix);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isMixModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarker("Dry/wet mix (0-1)\n0 = clean, 1 = fully crushed");

    ImGui::Spacing();

    // Anti-Aliasing
    // Use virtual _mod ID to check for modulation as per BestPracticeNodeProcessor.md
    bool isAntiAliasModulated = isParamModulated(paramIdAntiAliasMod);
    // Get live value if modulated, otherwise use base parameter value
    bool antiAlias = isAntiAliasModulated
        ? (getLiveParamValueFor(paramIdAntiAliasMod, "antiAlias_live", antiAliasParam != nullptr && antiAliasParam->load() > 0.5f ? 1.0f : 0.0f) > 0.5f)
        : (antiAliasParam != nullptr && antiAliasParam->load() > 0.5f);
    if (isAntiAliasModulated) {
        ImGui::BeginDisabled();
    }
    if (ImGui::Checkbox("Anti-Aliasing", &antiAlias)) {
        if (!isAntiAliasModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdAntiAlias))) *p = antiAlias;
        }
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isAntiAliasModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarker("ON: Applies a low-pass filter before decimation to reduce aliasing.\nOFF: Disables the filter for a harsher, classic aliased sound.");

    // Quant Mode
    // Use virtual _mod ID to check for modulation as per BestPracticeNodeProcessor.md
    bool isQuantModeModulated = isParamModulated(paramIdQuantModeMod);
    // Get live value if modulated, otherwise use base parameter value
    int quantMode = isQuantModeModulated
        ? static_cast<int>(getLiveParamValueFor(paramIdQuantModeMod, "quant_mode_live", quantModeParam != nullptr ? quantModeParam->load() : 0.0f))
        : (quantModeParam != nullptr ? static_cast<int>(quantModeParam->load()) : 0);
    if (isQuantModeModulated) {
        ImGui::BeginDisabled();
    }
    if (ImGui::Combo("Quant Mode", &quantMode, "Linear\0Dither (TPDF)\0Noise Shaping\0\0")) {
        if (!isQuantModeModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdQuantMode))) *p = quantMode;
        }
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isQuantModeModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarker("Quantization Algorithm:\nLinear: Basic, harsh quantization.\nDither: Adds noise to reduce artifacts.\nNoise Shaping: Pushes quantization noise into higher, less audible frequencies.");

    ImGui::Spacing();
    ImGui::Spacing();

    // === RELATIVE MODULATION SECTION ===
    ThemeText("CV Input Modes", theme.modulation.frequency);
    ImGui::Spacing();
    
    // Relative Bit Depth Mod checkbox
    bool relativeBitDepthMod = relativeBitDepthModParam != nullptr && relativeBitDepthModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Bit Depth Mod", &relativeBitDepthMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeBitDepthMod")))
            *p = relativeBitDepthMod;
    }
    if (ImGui::IsItemHovered())
    {
        ImGui::SetTooltip("ON: CV modulates around slider (±12 bits)\nOFF: CV directly sets bit depth (1-24)");
    }

    // Relative Sample Rate Mod checkbox
    bool relativeSampleRateMod = relativeSampleRateModParam != nullptr && relativeSampleRateModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Sample Rate Mod", &relativeSampleRateMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeSampleRateMod")))
            *p = relativeSampleRateMod;
    }
    if (ImGui::IsItemHovered())
    {
        ImGui::SetTooltip("ON: CV modulates around slider (±3 octaves)\nOFF: CV directly sets sample rate (0.1x-1.0x)");
    }

    // Relative Mix Mod checkbox
    bool relativeMixMod = relativeMixModParam != nullptr && relativeMixModParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Mix Mod", &relativeMixMod))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("relativeMixMod")))
            *p = relativeMixMod;
    }
    if (ImGui::IsItemHovered())
    {
        ImGui::SetTooltip("ON: CV modulates around slider (±0.5)\nOFF: CV directly sets mix (0-1)");
    }

    ImGui::PopItemWidth();
}

void BitCrusherModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In L", 0);
    helpers.drawAudioInputPin("In R", 1);
    
    // Modulation pins - use virtual _mod IDs as per BestPracticeNodeProcessor.md
    int busIdx, chanInBus;
    if (getParamRouting(paramIdBitDepthMod, busIdx, chanInBus))
        helpers.drawAudioInputPin("Bit Depth Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    if (getParamRouting(paramIdSampleRateMod, busIdx, chanInBus))
        helpers.drawAudioInputPin("Sample Rate Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    if (getParamRouting(paramIdMixMod, busIdx, chanInBus))
        helpers.drawAudioInputPin("Mix Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    if (getParamRouting(paramIdAntiAliasMod, busIdx, chanInBus))
        helpers.drawAudioInputPin("Anti-Alias Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    if (getParamRouting(paramIdQuantModeMod, busIdx, chanInBus))
        helpers.drawAudioInputPin("Quant Mode Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    
    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}
#endif


