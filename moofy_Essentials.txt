
================================================================================
FILE: architecture\00_PROJECT_OVERVIEW.md
================================================================================


# Collider PYO - Project Architecture

## Overview
This is a 2D physics simulation game built with **Pyglet** and **Pymunk**, featuring interactive tools, real-time physics, and audio integration using the **PYO** library. The project combines physics simulation with audio synthesis and effects.

## Project Structure

### Core Game Engine (`pyglet_physics_game/`)
The main game engine built with Pyglet for rendering and Pymunk for physics simulation.

### Audio System (`audio/`)
Audio generation and synthesis system using PYO library with frequency generators, noise generators, and sample libraries.

### Testing Framework (`tests/`)
Comprehensive test suite covering physics, audio, and rendering components.

### Documentation (`guide/`)
Technical guides and documentation for various components.

### Backup System (`BACKUPS/`)
Version control and backup system with timestamped snapshots of the project.

## Key Technologies

- **Pyglet**: 2D graphics and window management
- **Pymunk**: 2D physics simulation
- **SignalFlow**: Audio synthesis and processing
- **PyCairo**: Vector graphics rendering
- **NumPy**: Numerical computations

## Architecture Principles

1. **Modular Design**: Each system is self-contained with clear interfaces
2. **Performance First**: Optimized for high FPS and real-time physics
3. **Audio Integration**: Seamless integration between physics and audio
4. **Extensible Tools**: Easy to add new physics tools and audio effects
5. **Cross-Platform**: Designed to work on Windows, macOS, and Linux

## Entry Points

- `run_game.py`: Main entry point for the game
- `pyglet_physics_game/main.py`: Core game engine entry point
- `test_gemini.py`: Testing entry point

## Dependencies

See `requirements.txt` for complete dependency list including:
- Pyglet 2.1.8+
- Pymunk 8.0.0+
- SignalFlow (latest)
- PyCairo 1.25.0+
- NumPy 1.24.0+

## Development Workflow

1. **Core Development**: Work in `pyglet_physics_game/` directory
2. **Audio Development**: Work in `audio/` directory
3. **Testing**: Use `tests/` directory for comprehensive testing
4. **Backup**: Automatic backups in `BACKUPS/` directory
5. **Documentation**: Update relevant `.md` files in each directory

## Performance Targets

- **Physics**: 60 FPS physics simulation
- **Rendering**: 1200+ FPS target rendering
- **Audio**: Real-time audio synthesis with minimal latency
- **Memory**: Efficient object pooling and cleanup

## Future Enhancements

- 3D rendering capabilities
- Advanced audio effects
- Multiplayer support
- Scene save/load system
- Plugin architecture for custom tools


================================================================================
FILE: architecture\01_CORE_GAME_ENGINE.md
================================================================================


# Pyglet Physics Game - Architecture Documentation

## Overview
The main game engine built with Pyglet for rendering and Pymunk for physics simulation. This is the core of the Collider PYO project, featuring real-time physics, interactive tools, and audio integration.

## Core Architecture

### Main Entry Point
- **`main.py`**: Entry point that initializes and runs the PhysicsGame
- **`game/game_core.py`**: Core game class that orchestrates all systems

### System Architecture
The game follows a modular architecture with clear separation of concerns:

```
PhysicsGame (game_core.py)
├── Physics Engine (Pymunk)
├── Rendering System (Pyglet)
├── Input Handling
├── Audio Integration (PYO)
├── UI Systems
└── Performance Monitoring
```

## Directory Structure

### `/game/` - Core Game Logic
- **`game_core.py`**: Main PhysicsGame class
  - Initializes all subsystems
  - Manages game loop and timing
  - Handles physics simulation (60 FPS)
  - Coordinates rendering and input
  - Manages audio bullet system

### `/physics/` - Physics Engine
- **`physics_manager.py`**: Physics space management
  - Screen wrapping for objects
  - Tool effect application
  - Collision shape management
  - Gravity control
- **`physics_objects.py`**: Physics object definitions
- **`physics_tools.py`**: Interactive physics tools
  - Collision Tool (C)
  - Wind Tool (W)
  - Magnet Tool (M)
  - Teleporter Tool (T)
  - FreeDraw Tool (F)
- **`stroke_optimizer.py`**: Stroke optimization for performance

### `/rendering/` - Graphics System
- **`renderer.py`**: Main rendering engine
  - Pyglet batch rendering for performance
  - Layered rendering system
  - Background and grid rendering
  - Physics object rendering
  - UI overlay rendering

### `/input/` - Input Handling
- **`input_handler.py`**: Input event processing
  - Keyboard input (tool switching, physics control)
  - Mouse input (tool usage, object spawning)
  - Event delegation to tools and systems

### `/systems/` - Game Systems
- **`particle_system.py`**: Particle effects and visual feedback
- **`collision_system.py`**: Collision detection and response
- **`wind_system.py`**: Wind physics simulation
- **`trail_system.py`**: Object trail rendering
- **`bullet_manager.py`**: Bullet system management
- **`sound_bullet.py`**: Audio-integrated bullets
- **`bullet_data.py`**: Bullet data structures

### `/ui/` - User Interface
- **`manager.py`**: UI system manager
- **`modular_hud.py`**: Modular HUD system
- **`theme.py`**: UI theming system
- **`color_manager.py`**: Color management
- **`coordinate_system.py`**: Coordinate system management
- **`grid_system.py`**: Grid system for snapping
- **`mouse_system.py`**: Mouse interaction system
- **`visual_feedback.py`**: Visual feedback system
- **`debug_window.py`**: Debug information display

### `/tools/` - Audio and Physics Tools
- **`audio_effects/`**: Audio effect processors
- **`melody/`**: Melody generation tools
- **`physics_effects/`**: Physics effect tools

### `/shapes/` - Shape Management
- **`shape_manager.py`**: Shape creation and management
- **`shapes.json`**: Shape definitions

### `/utils/` - Utilities
- **`performance_monitor.py`**: Performance monitoring
- **`debug_utils.py`**: Debug utilities

## Key Features

### Physics System
- **Pymunk Integration**: 2D physics simulation
- **60 FPS Physics**: Fixed timestep for stability
- **Screen Wrapping**: Classic arcade-style object wrapping
- **Tool Integration**: Physics tools affect simulation

### Rendering System
- **Pyglet Graphics**: Hardware-accelerated rendering
- **Batch Rendering**: Single batch for maximum performance
- **Layered Rendering**: Proper depth ordering
- **Performance Optimization**: 1200+ FPS target

### Audio Integration
- **PYO Library**: Real-time audio synthesis
- **Sound Bullets**: Audio-integrated physics objects
- **Audio Presets**: Configurable audio properties
- **Real-time Processing**: Low-latency audio

### UI System
- **Modular Design**: Extensible UI components
- **Theme System**: Dynamic theming
- **Grid System**: Precise positioning and snapping
- **Debug Tools**: Comprehensive debugging interface

## Performance Characteristics

### Target Performance
- **Physics**: 60 FPS simulation
- **Rendering**: 1200+ FPS
- **Audio**: Real-time with minimal latency
- **Memory**: Efficient object pooling

### Optimization Strategies
- **Batch Rendering**: Single draw call for most elements
- **Object Pooling**: Reuse of physics objects
- **LOD System**: Level of detail for distant objects
- **Spatial Partitioning**: Efficient collision detection

## Integration Points

### Audio System
- Sound bullets integrate with physics
- Audio properties affect visual appearance
- Real-time audio synthesis based on physics

### UI System
- Grid system provides precise positioning
- Theme system affects all visual elements
- Debug system provides comprehensive monitoring

### Physics Tools
- Tools modify physics space
- Visual feedback for tool usage
- Real-time physics manipulation

## Development Guidelines

### Adding New Features
1. **Physics**: Add to `/physics/` directory
2. **Rendering**: Add to `/rendering/` directory
3. **UI**: Add to `/ui/` directory
4. **Systems**: Add to `/systems/` directory

### Performance Considerations
- Use batch rendering for multiple objects
- Implement object pooling for frequently created objects
- Minimize per-frame allocations
- Use efficient data structures

### Testing
- Test with high object counts
- Verify performance targets
- Test audio integration
- Validate physics accuracy

## Dependencies

### Core Dependencies
- **Pyglet 2.1.8+**: Graphics and window management
- **Pymunk 8.0.0+**: Physics simulation
- **SignalFlow**: Audio synthesis

### Additional Dependencies
- **NumPy**: Numerical computations
- **PyCairo**: Vector graphics

## Future Enhancements

### Planned Features
- 3D rendering capabilities
- Advanced audio effects
- Multiplayer support
- Scene save/load system
- Plugin architecture

### Performance Improvements
- GPU-accelerated physics
- Advanced culling techniques
- Memory optimization
- Multi-threading support


================================================================================
FILE: architecture\02_AUDIO_SYSTEM.md
================================================================================


# Audio System - Architecture Documentation

## Overview
The audio system provides real-time audio synthesis and processing using the SignalFlow library. It integrates with the physics simulation to create audio-visual experiences where physics objects generate sound based on their properties and interactions.

## System Architecture

### Core Components
- **Frequency Generators**: Pure tone generation (sine, square, triangle waves)
- **Noise Generators**: Various noise types (white, pink, brown)
- **Sample Library**: Pre-recorded audio samples for effects and instruments
- **Audio Integration**: Real-time audio synthesis based on physics

### Directory Structure

#### `/frequencies/` - Pure Tone Generation
- **`sine.py` & `sine.json`**: Sine wave generator
  - Frequency range: 20Hz - 20kHz
  - Gain control: -24dB to +12dB
- **`square.py` & `square.json`**: Square wave generator
  - Same parameter structure as sine
- **`triangle.py` & `triangle.json`**: Triangle wave generator
  - Same parameter structure as sine

#### `/noise/` - Noise Generation
- **`white_noise.py` & `white_noise.json`**: White noise generator
  - Gain control: -24dB to +12dB
  - Fade control: 0-2000ms
- **`pink_noise.py` & `pink_noise.json`**: Pink noise generator
- **`brown_noise.py` & `brown_noise.json`**: Brown noise generator

#### `/samples/` - Sample Library
- **`ambient/`**: Atmospheric and ambient sounds
  - Bass slides, duduk, joombush samples
  - Various musical keys and scales
- **`effects/`**: Sound effects and transitions
  - Animal sounds, psy FX
  - Various tempos and keys
- **`melodic/`**: Melodic instruments and fills
  - Saxophone, kemenche, bansuri, koto
  - Steel drums, orchestra, synth fills
- **`percussion/`**: Rhythmic elements
  - Acoustic crashes, kicks, rides, toms
  - Various timbres and dynamics
- **`new/`**: New sample additions

## Audio Integration

### Physics-Audio Connection
- **Sound Bullets**: Physics objects that generate audio
- **Material Properties**: Different materials produce different sounds
- **Real-time Synthesis**: Audio parameters change based on physics
- **Spatial Audio**: Position-based audio effects

### Audio Properties
Each audio generator has configurable parameters:
- **Frequency**: Pitch control for tone generators
- **Gain**: Volume control (-24dB to +12dB)
- **Fade**: Envelope control for noise generators
- **Material Type**: Affects audio characteristics

## Technical Implementation

### SignalFlow Integration
- **Real-time Processing**: Low-latency audio synthesis
- **Parameter Control**: Dynamic parameter adjustment
- **Audio Threading**: Separate audio processing thread
- **Buffer Management**: Efficient audio buffer handling

### Parameter System
- **JSON Configuration**: Human-readable parameter files
- **Type Safety**: Strongly typed parameters
- **Range Validation**: Min/max value constraints
- **Step Control**: Precise parameter adjustment

### Sample Management
- **WAV Format**: High-quality audio samples
- **Memory Management**: Efficient sample loading
- **Caching**: Sample preloading for performance
- **Streaming**: Large sample streaming support

## Audio Categories

### Frequency Generators
- **Pure Tones**: Sine, square, triangle waves
- **Harmonic Content**: Different wave shapes
- **Frequency Range**: Full audible spectrum
- **Real-time Control**: Dynamic frequency adjustment

### Noise Generators
- **White Noise**: Equal energy across all frequencies
- **Pink Noise**: Equal energy per octave
- **Brown Noise**: More energy in lower frequencies
- **Fade Control**: Envelope shaping

### Sample Library
- **Ambient**: Atmospheric and background sounds
- **Effects**: Transitions and special effects
- **Melodic**: Musical instruments and melodies
- **Percussion**: Rhythmic and percussive elements

## Performance Characteristics

### Audio Quality
- **Sample Rate**: 44.1kHz standard
- **Bit Depth**: 16-bit minimum, 24-bit preferred
- **Latency**: <10ms target
- **Dynamic Range**: 96dB theoretical

### Memory Usage
- **Sample Caching**: Efficient memory management
- **Streaming**: Large sample support
- **Compression**: Lossless compression where possible
- **Garbage Collection**: Automatic cleanup

## Integration with Physics

### Sound Bullet System
- **Physics Objects**: Generate audio based on properties
- **Material Types**: Different materials, different sounds
- **Collision Audio**: Sound on impact
- **Movement Audio**: Continuous sound based on motion

### Real-time Parameters
- **Frequency**: Based on object velocity
- **Gain**: Based on object mass
- **Effects**: Based on object material
- **Spatial**: Based on object position

## Development Guidelines

### Adding New Generators
1. Create `.py` file with generator class
2. Create `.json` file with parameters
3. Implement PYO integration
4. Add to audio system registry

### Adding New Samples
1. Place WAV files in appropriate category
2. Use descriptive naming convention
3. Ensure proper audio quality
4. Update sample index

### Performance Optimization
- Use efficient audio processing
- Minimize memory allocations
- Implement proper caching
- Use appropriate sample rates

## Future Enhancements

### Planned Features
- **Advanced Effects**: Reverb, delay, distortion
- **Synthesis**: More complex synthesis methods
- **Spatial Audio**: 3D audio positioning
- **MIDI Integration**: MIDI input/output support

### Audio Quality Improvements
- **Higher Sample Rates**: 48kHz, 96kHz support
- **Better Compression**: Advanced audio compression
- **Real-time Effects**: More audio effects
- **Audio Analysis**: FFT analysis and visualization

## Dependencies

### Core Dependencies
- **SignalFlow**: Audio synthesis library
- **NumPy**: Numerical computations
- **Pydub**: Audio file processing
- **Librosa**: Audio analysis

### Additional Dependencies
- **Mido**: MIDI file handling
- **Midiutil**: MIDI creation
- **Midi2audio**: MIDI to audio conversion
- **Espeakng**: Text-to-speech

## Troubleshooting

### Common Issues
- **Audio Latency**: Check buffer size settings
- **Memory Usage**: Monitor sample caching
- **Audio Quality**: Verify sample rate settings
- **Performance**: Check CPU usage

### Debug Tools
- **Audio Monitor**: Real-time audio level monitoring
- **Parameter Display**: Current parameter values
- **Performance Metrics**: Audio processing statistics
- **Error Logging**: Detailed error information


================================================================================
FILE: architecture\README.md
================================================================================


# Architecture Documentation - Master Index

## 🗺️ Navigation Guide

This directory contains all architecture documentation for the **Collider PYO** project. Each file is numbered for easy navigation and covers a specific aspect of the system architecture.

## 📋 Architecture Files

### **00_PROJECT_OVERVIEW.md**
- **Purpose**: Complete project overview and high-level architecture
- **Contents**: Technology stack, project structure, development workflow
- **Start Here**: If you're new to the project or need a high-level understanding

### **01_CORE_GAME_ENGINE.md**
- **Purpose**: Main game engine architecture (Pyglet + Pymunk)
- **Contents**: Physics simulation, rendering system, game loop, performance optimization
- **Use When**: Working on core game functionality

### **02_AUDIO_SYSTEM.md**
- **Purpose**: Audio synthesis and processing (SignalFlow)
- **Contents**: Frequency generators, noise generators, sample library, real-time audio
- **Use When**: Working on audio features or sound integration

### **03_TESTING_FRAMEWORK.md**
- **Purpose**: Comprehensive testing system
- **Contents**: Audio testing, physics testing, rendering testing, integration testing
- **Use When**: Writing tests or debugging issues

### **04_DOCUMENTATION_SYSTEM.md**
- **Purpose**: Documentation and guide system
- **Contents**: Technical guides, tutorials, library documentation
- **Use When**: Looking for implementation guides or tutorials

### **05_BACKUP_SYSTEM.md**
- **Purpose**: Version control and backup system
- **Contents**: Backup strategy, development history, recovery procedures
- **Use When**: Managing project versions or recovering from issues

### **06_VIRTUAL_ENVIRONMENT.md**
- **Purpose**: Python virtual environment management
- **Contents**: Dependencies, package management, development workflow
- **Use When**: Setting up development environment or managing dependencies

### **07_DESIGN_SYSTEM.md**
- **Purpose**: Design assets and UI/UX system
- **Contents**: Design workflow, asset management, UI/UX guidelines
- **Use When**: Working on visual design or UI/UX

### **08_GAME_SYSTEMS.md**
- **Purpose**: Core game systems (physics, audio, effects)
- **Contents**: Bullet system, particle system, collision system, trail system
- **Use When**: Working on game mechanics or system integration

### **09_TOOLS_SYSTEM.md**
- **Purpose**: Audio and physics tools
- **Contents**: Audio effects, melody generation, physics effects
- **Use When**: Working on tools or effects

### **10_TYPOGRAPHY_SYSTEM.md**
- **Purpose**: Font and typography management
- **Contents**: Font system, text rendering, UI typography
- **Use When**: Working on text rendering or UI typography

### **11_UI_SYSTEM.md**
- **Purpose**: User interface system
- **Contents**: UI components, theming, grid system, interaction systems
- **Use When**: Working on user interface or UI components

### **12_UTILITIES_SYSTEM.md**
- **Purpose**: Utility functions and helper classes
- **Contents**: Performance monitoring, debug utilities, common functions
- **Use When**: Working on utilities or debugging

## 🚀 Quick Start Guide

### **New to the Project?**
1. Start with **00_PROJECT_OVERVIEW.md** for high-level understanding
2. Read **01_CORE_GAME_ENGINE.md** for core architecture
3. Check **06_VIRTUAL_ENVIRONMENT.md** for setup instructions

### **Working on Audio?**
1. Read **02_AUDIO_SYSTEM.md** for audio architecture
2. Check **09_TOOLS_SYSTEM.md** for audio tools
3. Review **08_GAME_SYSTEMS.md** for audio integration

### **Working on UI?**
1. Read **11_UI_SYSTEM.md** for UI architecture
2. Check **10_TYPOGRAPHY_SYSTEM.md** for text rendering
3. Review **07_DESIGN_SYSTEM.md** for design guidelines

### **Working on Physics?**
1. Read **01_CORE_GAME_ENGINE.md** for physics engine
2. Check **08_GAME_SYSTEMS.md** for physics systems
3. Review **09_TOOLS_SYSTEM.md** for physics tools

### **Debugging Issues?**
1. Check **12_UTILITIES_SYSTEM.md** for debug tools
2. Review **03_TESTING_FRAMEWORK.md** for testing approaches
3. Look at **05_BACKUP_SYSTEM.md** for version recovery

## 🔧 Technology Stack

- **Graphics**: Pyglet (OpenGL-based rendering)
- **Physics**: Pymunk (2D physics simulation)
- **Audio**: SignalFlow (Real-time audio synthesis)
- **Vector Graphics**: PyCairo
- **Numerical**: NumPy

## 📊 Key Architecture Principles

1. **Modular Design**: Each system is self-contained with clear interfaces
2. **Performance First**: Optimized for high FPS and real-time physics
3. **Audio Integration**: Seamless integration between physics and audio
4. **Extensible Tools**: Easy to add new physics tools and audio effects
5. **Cross-Platform**: Designed to work on Windows, macOS, and Linux

## 🎯 Performance Targets

- **Physics**: 60 FPS physics simulation
- **Rendering**: 1200+ FPS target rendering
- **Audio**: Real-time audio synthesis with minimal latency
- **Memory**: Efficient object pooling and cleanup

## 📝 Maintenance

This architecture documentation is maintained alongside the codebase. When making significant changes to any system, please update the corresponding architecture file to keep the documentation current and accurate.

---

**Last Updated**: September 2025  
**Project**: Collider PYO - Physics-Audio Integration Platform


================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <atomic>
#include <vector>
#include <memory>
#include "../modules/ModuleProcessor.h"
#include "../modules/InputDebugModuleProcessor.h"

class ModularSynthProcessor : public juce::AudioProcessor
{
public:
    ModularSynthProcessor();
    ~ModularSynthProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    const juce::String getName() const override { return "Modular Synth"; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return true; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    // Public API (initial)
public:
    using Node = juce::AudioProcessorGraph::Node;
    using NodeID = juce::AudioProcessorGraph::NodeID;

    NodeID addModule(const juce::String& moduleType, bool commit = true);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc, juce::uint32 logicalIdToAssign);
    void removeModule(const NodeID& nodeID);
    void clearAll(); // Add this line
    void clearAllConnections(); // Add this line
    void clearOutputConnections(); // <<< ADD THIS LINE
    void clearConnectionsForNode(const NodeID& nodeID); // <<< ADD THIS LINE
    bool connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    
    // Set the hardware input channel mapping for an Audio Input module
    void setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap);
    
    void commitChanges();
    NodeID getOutputNodeID() const { return audioOutputNode ? audioOutputNode->nodeID : NodeID{}; }
    // Introspection for editor
    std::vector<std::pair<juce::uint32, juce::String>> getModulesInfo() const;
    juce::AudioProcessorGraph::NodeID getNodeIdForLogical (juce::uint32 logicalId) const;
    juce::uint32 getLogicalIdForNode (const NodeID& nodeId) const;
    juce::String getModuleTypeForLogical(juce::uint32 logicalId) const;
    bool disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    struct ConnectionInfo
    {
        juce::uint32 srcLogicalId { 0 };
        int srcChan { 0 };
        juce::uint32 dstLogicalId { 0 }; // 0 means audio output
        int dstChan { 0 };
        bool dstIsOutput { false };
    };
    std::vector<ConnectionInfo> getConnectionsInfo() const;
    // Access a module processor for UI parameter editing
    ModuleProcessor* getModuleForLogical (juce::uint32 logicalId) const;
    
    // === GLOBAL TRANSPORT & TIMING ===
    // (TransportState struct is defined in ModuleProcessor.h)
    
    TransportState getTransportState() const { return m_transportState; }
    void setPlaying(bool playing) { m_transportState.isPlaying = playing; }
    void setBPM(double bpm) { m_transportState.bpm = juce::jlimit(20.0, 999.0, bpm); }
    void setGlobalDivisionIndex(int idx) { m_transportState.globalDivisionIndex.store(idx); }
    void setTempoControlledByModule(bool controlled) { m_transportState.isTempoControlledByModule.store(controlled); }
    
    // MIDI activity indicator
    bool hasMidiActivity() const { return m_midiActivityFlag.exchange(false); }
    void resetTransportPosition() { m_samplePosition = 0; m_transportState.songPositionBeats = 0.0; m_transportState.songPositionSeconds = 0.0; }
    
    // === MULTI-MIDI DEVICE SUPPORT ===
    
    /**
     * @brief Process device-aware MIDI messages
     * 
     * This method receives MIDI messages with device source information and
     * distributes them to all modules via handleDeviceSpecificMidi().
     * Should be called from the message thread (timer callback in PresetCreatorComponent).
     * 
     * @param messages Vector of MIDI messages with device information
     */
    void processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages);
    
    /**
     * @brief MIDI activity state per device and channel
     */
    struct MidiActivityState {
        std::map<int, std::array<bool, 16>> deviceChannelActivity;  // deviceIndex -> channels[16]
        std::map<int, juce::String> deviceNames;                    // deviceIndex -> name
    };
    
    /**
     * @brief Get snapshot of current MIDI activity
     * 
     * Used by UI for visualization (top bar indicator).
     * Thread-safe.
     * 
     * @return MidiActivityState structure
     */
    MidiActivityState getMidiActivityState() const;
    
    // === VOICE MANAGEMENT FOR POLYPHONY ===
    struct Voice {
        bool isActive = false;
        int noteNumber = -1;
        float velocity = 0.0f;
        juce::uint32 age = 0;  // Used for note stealing (oldest voice)
        juce::uint32 targetModuleLogicalId = 0;  // Which PolyVCO this voice is assigned to
    };
    
    void setVoiceManagerEnabled(bool enabled) { m_voiceManagerEnabled = enabled; }
    bool isVoiceManagerEnabled() const { return m_voiceManagerEnabled; }
    void setMaxVoices(int numVoices) { m_voices.resize(numVoices); }
    int getMaxVoices() const { return static_cast<int>(m_voices.size()); }
    const std::vector<Voice>& getVoices() const { return m_voices; }
    
    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get system-wide diagnostics
    juce::String getSystemDiagnostics() const;
    
    // Get diagnostics for a specific module
    juce::String getModuleDiagnostics(juce::uint32 logicalId) const;
    
    // Get parameter routing diagnostics for a specific module
    juce::String getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const;
    
    // Get all connection diagnostics
    juce::String getConnectionDiagnostics() const;
    
    // Check if any recorder module is currently recording (prevents spacebar from stopping audio)
    bool isAnyModuleRecording() const;
    
    // Pause/Resume all active recorders (used by spacebar during audition)
    void pauseAllRecorders();
    void resumeAllRecorders();
    
    // Global start/stop all recorders (used by menu bar)
    void startAllRecorders();
    void stopAllRecorders();
    
    // Plugin format manager for VST support (optional, set by application)
    void setPluginFormatManager(juce::AudioPluginFormatManager* manager) { pluginFormatManager = manager; }
    void setKnownPluginList(juce::KnownPluginList* list) { knownPluginList = list; }
    
    // === PROBE TOOL API ===
    // Probe system for instant signal debugging without manual patching
    void setProbeConnection(const NodeID& sourceNodeID, int sourceChannel);
    void clearProbeConnection();
    ModuleProcessor* getProbeScopeProcessor() const;

private:
    // The internal graph that represents the modular patch
    std::unique_ptr<juce::AudioProcessorGraph> internalGraph;

    // Special nodes for handling I/O within the internal graph
    Node::Ptr audioInputNode;
    Node::Ptr audioOutputNode;
    Node::Ptr midiInputNode;
    
    // MIDI activity indicator (mutable because hasMidiActivity() is const)
    mutable std::atomic<bool> m_midiActivityFlag{false};
    
    // Multi-MIDI device support
    std::vector<MidiMessageWithDevice> currentBlockMidiMessages;
    mutable juce::CriticalSection midiActivityLock;
    MidiActivityState currentActivity;

    // The APVTS that will expose proxy parameters to the host/AudioEngine
    juce::AudioProcessorValueTreeState apvts;

    // Thread-safe module access for audio thread
    mutable juce::CriticalSection moduleLock;
    std::atomic<std::shared_ptr<const std::vector<std::shared_ptr<ModuleProcessor>>>> activeAudioProcessors;

    // Manage module nodes (legacy map by NodeID.uid)
    std::map<juce::uint32, Node::Ptr> modules; // keyed by NodeID.uid
    // Logical ID mapping for preset save/load
    struct LogicalModule
    {
        juce::AudioProcessorGraph::NodeID nodeID;
        juce::String type;
    };
    std::map<juce::uint32, LogicalModule> logicalIdToModule; // logicalId -> module
    juce::uint32 nextLogicalId { 1 };
    
    // Optional pointers for VST support
    juce::AudioPluginFormatManager* pluginFormatManager { nullptr };
    juce::KnownPluginList* knownPluginList { nullptr };
    
    // Probe scope for instant signal debugging (hidden from user, not saved in presets)
    Node::Ptr probeScopeNode;
    NodeID probeScopeNodeId;
    
    // Transport state
    TransportState m_transportState;
    juce::uint64 m_samplePosition { 0 };
    
    // Voice management state
    std::vector<Voice> m_voices;
    bool m_voiceManagerEnabled { false };
    juce::uint32 m_globalVoiceAge { 0 };  // Incremented for each note-on
    
    // Voice management helper methods
    int findFreeVoice();
    int findOldestVoice();
    void assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn);
    void releaseVoice(const juce::MidiMessage& noteOff);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModularSynthProcessor)
};

================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.cpp
================================================================================


#include "ModularSynthProcessor.h"
#include "../modules/AudioInputModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/VCOModuleProcessor.h"
#include "../modules/VCFModuleProcessor.h"
#include "../modules/VCAModuleProcessor.h"
#include "../modules/NoiseModuleProcessor.h"
#include "../modules/LFOModuleProcessor.h"
#include "../modules/ADSRModuleProcessor.h"
#include "../modules/MixerModuleProcessor.h"
#include "../modules/DelayModuleProcessor.h"
#include "../modules/ReverbModuleProcessor.h"
#include "../modules/AttenuverterModuleProcessor.h"
#include "../modules/ScopeModuleProcessor.h"
#include "../modules/SAndHModuleProcessor.h"
#include "../modules/StepSequencerModuleProcessor.h"
#include "../modules/MathModuleProcessor.h"
#include "../modules/MapRangeModuleProcessor.h"
#include "../modules/RandomModuleProcessor.h"
#include "../modules/RateModuleProcessor.h"
#include "../modules/QuantizerModuleProcessor.h"
#include "../modules/SequentialSwitchModuleProcessor.h"
#include "../modules/LogicModuleProcessor.h"
#include "../modules/ValueModuleProcessor.h"
#include "../modules/ClockDividerModuleProcessor.h"
#include "../modules/WaveshaperModuleProcessor.h"
#include "../modules/MultiBandShaperModuleProcessor.h"
#include "../modules/GranulatorModuleProcessor.h"
#include "../modules/HarmonicShaperModuleProcessor.h"
#include "../modules/TrackMixerModuleProcessor.h"
#include "../modules/TTSPerformerModuleProcessor.h"
#include "../modules/ComparatorModuleProcessor.h"
#include "../modules/VocalTractFilterModuleProcessor.h"
#include "../modules/VstHostModuleProcessor.h"
#include "../modules/SampleLoaderModuleProcessor.h"
#include "../modules/FunctionGeneratorModuleProcessor.h"
#include "../modules/TimePitchModuleProcessor.h"
#include "../modules/DebugModuleProcessor.h"
#include "../modules/CommentModuleProcessor.h"
#include "../modules/MIDIPlayerModuleProcessor.h"
#include "../modules/PolyVCOModuleProcessor.h"
#include "../modules/BestPracticeNodeProcessor.h"
#include "../modules/ShapingOscillatorModuleProcessor.h"
#include "../modules/MultiSequencerModuleProcessor.h"
#include "../modules/LagProcessorModuleProcessor.h"
#include "../modules/DeCrackleModuleProcessor.h"
#include "../modules/CVMixerModuleProcessor.h"
#include "../modules/GraphicEQModuleProcessor.h"
#include "../modules/FrequencyGraphModuleProcessor.h"
#include "../modules/ChorusModuleProcessor.h"
#include "../modules/PhaserModuleProcessor.h"
#include "../modules/CompressorModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/LimiterModuleProcessor.h"
#include "../modules/GateModuleProcessor.h"
#include "../modules/DriveModuleProcessor.h"
#include "../modules/SnapshotSequencerModuleProcessor.h"
#include "../modules/MIDICVModuleProcessor.h"
#include "../modules/MIDIFadersModuleProcessor.h"
#include "../modules/MIDIKnobsModuleProcessor.h"
#include "../modules/MIDIButtonsModuleProcessor.h"
#include "../modules/MIDIJogWheelModuleProcessor.h"
#include "../modules/MIDIPadModuleProcessor.h"
#include "../modules/MidiLoggerModuleProcessor.h"
#include "../modules/TempoClockModuleProcessor.h"
#include "../modules/PhysicsModuleProcessor.h"
#include "../modules/StrokeSequencerModuleProcessor.h"
#include "../modules/AnimationModuleProcessor.h"
#include "../modules/InletModuleProcessor.h"
#include "../modules/OutletModuleProcessor.h"
#include "../modules/MetaModuleProcessor.h"

ModularSynthProcessor::ModularSynthProcessor()
    : juce::AudioProcessor(BusesProperties()
                            .withInput("Input", juce::AudioChannelSet::stereo(), true)
                            .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "ModularSynthParams", {})
{
    internalGraph = std::make_unique<juce::AudioProcessorGraph>();

    using IOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor;
    audioInputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioInputNode));
    audioOutputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioOutputNode));
    midiInputNode  = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::midiInputNode));

    internalGraph->addConnection({ { midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex },
                                   { audioOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex } });
    
    probeScopeNode = internalGraph->addNode(std::make_unique<ScopeModuleProcessor>());
    probeScopeNodeId = probeScopeNode->nodeID;
    juce::Logger::writeToLog("[ModularSynth] Initialized probe scope with nodeID: " + juce::String(probeScopeNodeId.uid));
    
    activeAudioProcessors.store(std::make_shared<const std::vector<std::shared_ptr<ModuleProcessor>>>());
    
    m_voices.resize(8);
    for (auto& voice : m_voices)
    {
        voice.isActive = false;
        voice.noteNumber = -1;
        voice.velocity = 0.0f;
        voice.age = 0;
        voice.targetModuleLogicalId = 0;
    }
}

ModularSynthProcessor::~ModularSynthProcessor() {}

void ModularSynthProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    internalGraph->setPlayConfigDetails(getTotalNumInputChannels(), getTotalNumOutputChannels(), sampleRate, samplesPerBlock);
    internalGraph->prepareToPlay(sampleRate, samplesPerBlock);
}

void ModularSynthProcessor::releaseResources()
{
    internalGraph->releaseResources();
}

//==============================================================================
// Multi-MIDI Device Support
//==============================================================================

void ModularSynthProcessor::processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages)
{
    const juce::ScopedLock lock(midiActivityLock);
    currentBlockMidiMessages = messages;
    
    // DEBUG LOGGING
    if (!messages.empty())
    {
        juce::Logger::writeToLog("[ModularSynth] processMidiWithDeviceInfo received " + 
                                juce::String(messages.size()) + " MIDI messages");
    }
    
    // Update activity tracking
    currentActivity.deviceChannelActivity.clear();
    currentActivity.deviceNames.clear();
    
    for (const auto& msg : messages)
    {
        // Skip system realtime messages
        if (msg.message.isMidiClock() || msg.message.isActiveSense())
            continue;
        
        int channel = msg.message.getChannel();
        if (channel >= 1 && channel <= 16)
        {
            int channelIndex = channel - 1;  // 0-15
            currentActivity.deviceChannelActivity[msg.deviceIndex][channelIndex] = true;
            currentActivity.deviceNames[msg.deviceIndex] = msg.deviceName;
        }
    }
}

ModularSynthProcessor::MidiActivityState ModularSynthProcessor::getMidiActivityState() const
{
    const juce::ScopedLock lock(midiActivityLock);
    return currentActivity;
}

//==============================================================================
// Audio Processing
//==============================================================================

void ModularSynthProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    try {
        // NOTE: Both tempo and division control flags are managed by Tempo Clock modules directly
        // No resets here to avoid flickering in UI
        
        // --- ADD THIS LOGGING BLOCK ---
        if (!midiMessages.isEmpty())
        {
            // If we get this message, it means MIDI is successfully reaching the synth.
            juce::Logger::writeToLog("[SynthCore] Received " + juce::String(midiMessages.getNumEvents()) + " MIDI events this block.");
            m_midiActivityFlag.store(true);
        }
        // --- END OF BLOCK ---
        
        if (m_transportState.isPlaying)
        {
            m_samplePosition += buffer.getNumSamples();
            m_transportState.songPositionSeconds = m_samplePosition / getSampleRate();
            m_transportState.songPositionBeats = (m_transportState.songPositionSeconds / 60.0) * m_transportState.bpm;
        }

        // --- FINAL THREAD-SAFE FIX ---
        auto currentProcessors = activeAudioProcessors.load();
        if (currentProcessors)
        {
            // Iterate over the safe, shared list.
            for (const auto& modulePtr : *currentProcessors)
            {
                // SAFETY NET + GRANULAR LOGGING
                if (modulePtr != nullptr)
                {
                    // Log the memory address before calling the function
                    // juce::Logger::writeToLog("[AudioThread] Ticking module at 0x" + juce::String::toHexString((juce::pointer_sized_int)modulePtr.get()));
                    modulePtr->setTimingInfo(m_transportState);
                }
                else
                {
                    // This should never happen with the shared_ptr fix, but if it does, it's critical info.
                    juce::Logger::writeToLog("[AudioThread] CRITICAL WARNING: Encountered nullptr in active processor list!");
                }
            }
        }
        // --- END OF FIX ---
        
        // === MULTI-MIDI DEVICE SUPPORT: Distribute device-aware MIDI to modules ===
        // This happens BEFORE voice management and graph processing
        // Modules receive device info and can filter by device/channel
        {
            const juce::ScopedLock lock(midiActivityLock);
            
            // DEBUG: Log every processBlock attempt to check the buffer
            static int checkCount = 0;
            static int distributionCount = 0;
            checkCount++;
            
            if (!currentBlockMidiMessages.empty())
            {
                distributionCount++;
                
                // Log only first few times to avoid spam
                if (distributionCount <= 5)
                {
                    juce::Logger::writeToLog("[ModularSynth processBlock] CHECK #" + juce::String(checkCount) + 
                                            " - Found " + juce::String(currentBlockMidiMessages.size()) + " messages to distribute");
                }
                
                if (internalGraph)
                {
                    int nodeCount = internalGraph->getNodes().size();
                    int moduleCount = 0;
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Distributing to " + juce::String(nodeCount) + " nodes");
                    }
                    
                    for (auto* node : internalGraph->getNodes())
                    {
                        if (auto* module = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                        {
                            moduleCount++;
                            module->handleDeviceSpecificMidi(currentBlockMidiMessages);
                        }
                    }
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Called handleDeviceSpecificMidi on " + 
                                                juce::String(moduleCount) + " modules");
                    }
                    
                    // Merge device-aware MIDI into standard MidiBuffer for backward compatibility
                    for (const auto& msg : currentBlockMidiMessages)
                    {
                        midiMessages.addEvent(msg.message, 0);
                    }
                    
                    // Clear for next block
                    currentBlockMidiMessages.clear();
                }
                else
                {
                    juce::Logger::writeToLog("[ModularSynth] WARNING: Have MIDI messages but internalGraph is null!");
                }
            }
        }
        // === END MULTI-MIDI DISTRIBUTION ===
        
        if (m_voiceManagerEnabled && !m_voices.empty())
        {
            juce::MidiBuffer processedMidi;
            for (const auto metadata : midiMessages)
            {
                const auto msg = metadata.getMessage();
                if (msg.isNoteOn())
                {
                    int voiceIndex = findFreeVoice();
                    if (voiceIndex < 0) voiceIndex = findOldestVoice();
                    if (voiceIndex >= 0)
                    {
                        assignNoteToVoice(voiceIndex, msg);
                        processedMidi.addEvent(msg, metadata.samplePosition);
                    }
                }
                else if (msg.isNoteOff())
                {
                    releaseVoice(msg);
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
                else
                {
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
            }
            midiMessages.swapWith(processedMidi);
        }
        
        internalGraph->processBlock(buffer, midiMessages);
        static int silentCtr = 0;
        if (buffer.getMagnitude(0, buffer.getNumSamples()) < 1.0e-6f)
        {
            if ((++silentCtr % 600) == 0)
                juce::Logger::writeToLog("[ModularSynthProcessor] silent block from internal graph");
        }
        else
        {
            silentCtr = 0;
        }
    } catch (const std::exception& e) {
        juce::Logger::writeToLog(juce::String("[ModSynth][FATAL] Exception in processBlock: ") + e.what());
        buffer.clear();
        return;
    } catch (...) {
        juce::Logger::writeToLog("[ModSynth][FATAL] Unknown exception in processBlock");
        buffer.clear();
        return;
    }
}

void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock (moduleLock);
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32) kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int) logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32) c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32) c.destination.nodeID.uid;
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int) dstIt->second, nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else
        {
            continue;
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}

void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes)));
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML or wrong root tag. Aborting restore.");
        return;
    }

    clearAll();
    juce::Logger::writeToLog("[STATE] Cleared existing state.");

    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // Restore global transport settings
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    juce::Logger::writeToLog("[STATE] Restored BPM to " + juce::String(m_transportState.bpm));
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found in preset.");
        return;
    }
    
    juce::Logger::writeToLog("[STATE] Found <modules> block with " + juce::String(modsVT.getNumChildren()) + " children.");
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    std::map<juce::uint32, NodeID> logicalToNodeId;
    juce::Logger::writeToLog("[STATE] Starting module recreation pass...");
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module"))
        {
            juce::Logger::writeToLog("[STATE] Skipping non-module child at index " + juce::String(i));
            continue;
        }

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module " + juce::String(i) + ": logicalId=" + juce::String(logicalId) + " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::Logger::writeToLog("[STATE]   Loading VST module...");
                    
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr && knownPluginList != nullptr)
                    {
                        bool found = false;
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE]   Found VST to load: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found)
                        {
                            juce::Logger::writeToLog("[STATE]   ERROR: VST plugin not found: " + identifier);
                        }
                    }
                    else
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: No plugin identifier or format manager/list not available");
                    }
                    
                    if (nodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: Failed to create VST module, skipping...");
                        continue;
                    }
                }
            }
            
            if (!isVstModule)
            {
                juce::Logger::writeToLog("[STATE]   Calling addModule('" + type + "')...");
                nodeId = addModule(type, false);
                juce::Logger::writeToLog("[STATE]   addModule returned nodeId.uid=" + juce::String(nodeId.uid));
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                juce::Logger::writeToLog("[STATE]   Node created successfully.");
                
                if (!isVstModule)
                {
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;
                juce::Logger::writeToLog("[STATE]   Mapped logicalId " + juce::String(logicalId) + " to nodeId.uid " + juce::String(nodeId.uid));

                // --- FIX: Restore extra state FIRST ---
                // This will load the clip and reset trim sliders to defaults.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE]   Restored extra state.");
                    }
                }

                // Now restore parameters SECOND.
                // This will overwrite the temporary default trim values with the correct saved values.
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE]   Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   ERROR: Node creation failed! nodeId.uid was " + juce::String(nodeId.uid) + " but getNodeForId returned nullptr.");
            }
        }
        else
        {
            juce::Logger::writeToLog("[STATE]   Skipping module: logicalId=" + juce::String(logicalId) + " (valid=" + juce::String(logicalId > 0 ? "yes" : "no") + ") type='" + type + "' (empty=" + juce::String(type.isEmpty() ? "yes" : "no") + ")");
        }
    }
    
    juce::Logger::writeToLog("[STATE] Module recreation complete. Created " + juce::String(logicalToNodeId.size()) + " modules.");

    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        int skippedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   WARNING: Skipping connection " + juce::String(i) + 
                                        ": srcId=" + juce::String(srcId) + " (uid=" + juce::String(srcNodeId.uid) + 
                                        ") → dstId=" + (dstIsOutput ? "output" : juce::String(dstId)) + 
                                        " (uid=" + juce::String(dstNodeId.uid) + ")");
                skippedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connection restore complete: " + juce::String(connectedCount) + 
                                " connected, " + juce::String(skippedCount) + " skipped.");
    }
    else
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <connections> block found in preset.");
    }


    juce::Logger::writeToLog("[STATE] Calling commitChanges()...");
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}

namespace {
    static juce::String toLowerId (const juce::String& s)
    {
        return s.toLowerCase();
    }

    using Creator = std::function<std::unique_ptr<juce::AudioProcessor>()>;

    static std::map<juce::String, Creator>& getModuleFactory()
    {
        static std::map<juce::String, Creator> factory;
        static bool initialised = false;
        if (!initialised)
        {
            auto reg = [&](const juce::String& key, Creator c) { factory.emplace(toLowerId(key), std::move(c)); };

            reg("vco", []{ return std::make_unique<VCOModuleProcessor>(); });
            reg("audio_input", []{ return std::make_unique<AudioInputModuleProcessor>(); });
            reg("vcf", []{ return std::make_unique<VCFModuleProcessor>(); });
            reg("vca", []{ return std::make_unique<VCAModuleProcessor>(); });
            reg("noise", []{ return std::make_unique<NoiseModuleProcessor>(); });
            reg("lfo", []{ return std::make_unique<LFOModuleProcessor>(); });
            reg("adsr", []{ return std::make_unique<ADSRModuleProcessor>(); });
            reg("mixer", []{ return std::make_unique<MixerModuleProcessor>(); });
            reg("cv_mixer", []{ return std::make_unique<CVMixerModuleProcessor>(); });
            reg("track_mixer", []{ return std::make_unique<TrackMixerModuleProcessor>(); });
            reg("delay", []{ return std::make_unique<DelayModuleProcessor>(); });
            reg("reverb", []{ return std::make_unique<ReverbModuleProcessor>(); });
            reg("attenuverter", []{ return std::make_unique<AttenuverterModuleProcessor>(); });
            reg("scope", []{ return std::make_unique<ScopeModuleProcessor>(); });
            reg("frequency_graph", []{ return std::make_unique<FrequencyGraphModuleProcessor>(); });
            reg("s_and_h", []{ return std::make_unique<SAndHModuleProcessor>(); });
            reg("sequencer", []{ return std::make_unique<StepSequencerModuleProcessor>(); });
            reg("math", []{ return std::make_unique<MathModuleProcessor>(); });
            reg("map_range", []{ return std::make_unique<MapRangeModuleProcessor>(); });
            reg("comparator", []{ return std::make_unique<ComparatorModuleProcessor>(); });
            reg("random", []{ return std::make_unique<RandomModuleProcessor>(); });
            reg("rate", []{ return std::make_unique<RateModuleProcessor>(); });
            reg("quantizer", []{ return std::make_unique<QuantizerModuleProcessor>(); });
            reg("sequential_switch", []{ return std::make_unique<SequentialSwitchModuleProcessor>(); });
            reg("logic", []{ return std::make_unique<LogicModuleProcessor>(); });
            reg("clock_divider", []{ return std::make_unique<ClockDividerModuleProcessor>(); });
            reg("waveshaper", []{ return std::make_unique<WaveshaperModuleProcessor>(); });
            reg("8bandshaper", []{ return std::make_unique<MultiBandShaperModuleProcessor>(); });
            reg("granulator", []{ return std::make_unique<GranulatorModuleProcessor>(); });
            reg("harmonic_shaper", []{ return std::make_unique<HarmonicShaperModuleProcessor>(); });
            reg("debug", []{ return std::make_unique<DebugModuleProcessor>(); });
            reg("input_debug", []{ return std::make_unique<InputDebugModuleProcessor>(); });
            reg("vocal_tract_filter", []{ return std::make_unique<VocalTractFilterModuleProcessor>(); });
            reg("value", []{ return std::make_unique<ValueModuleProcessor>(); });
            reg("tts_performer", []{ return std::make_unique<TTSPerformerModuleProcessor>(); });
            reg("sample_loader", []{ return std::make_unique<SampleLoaderModuleProcessor>(); });
            reg("function_generator", []{ return std::make_unique<FunctionGeneratorModuleProcessor>(); });
            reg("timepitch", []{ return std::make_unique<TimePitchModuleProcessor>(); });
            reg("midi_player", []{ return std::make_unique<MIDIPlayerModuleProcessor>(); });
            reg("polyvco", []{ return std::make_unique<PolyVCOModuleProcessor>(); });
            reg("best_practice", []{ return std::make_unique<BestPracticeNodeProcessor>(); });
            reg("shaping_oscillator", []{ return std::make_unique<ShapingOscillatorModuleProcessor>(); });
            reg("multi_sequencer", []{ return std::make_unique<MultiSequencerModuleProcessor>(); });
            reg("lag_processor", []{ return std::make_unique<LagProcessorModuleProcessor>(); });
            reg("de_crackle", []{ return std::make_unique<DeCrackleModuleProcessor>(); });
            reg("graphic_eq", []{ return std::make_unique<GraphicEQModuleProcessor>(); });
            reg("chorus", []{ return std::make_unique<ChorusModuleProcessor>(); });
            reg("phaser", []{ return std::make_unique<PhaserModuleProcessor>(); });
            reg("compressor", []{ return std::make_unique<CompressorModuleProcessor>(); });
            reg("recorder", []{ return std::make_unique<RecordModuleProcessor>(); });
            reg("limiter", []{ return std::make_unique<LimiterModuleProcessor>(); });
            reg("gate", []{ return std::make_unique<GateModuleProcessor>(); });
            reg("drive", []{ return std::make_unique<DriveModuleProcessor>(); });
            reg("comment", []{ return std::make_unique<CommentModuleProcessor>(); });
            reg("snapshot_sequencer", []{ return std::make_unique<SnapshotSequencerModuleProcessor>(); });
            reg("midi_cv", []{ return std::make_unique<MIDICVModuleProcessor>(); });
            reg("midi_faders", []{ return std::make_unique<MIDIFadersModuleProcessor>(); });
            reg("midi_knobs", []{ return std::make_unique<MIDIKnobsModuleProcessor>(); });
            reg("midi_buttons", []{ return std::make_unique<MIDIButtonsModuleProcessor>(); });
            reg("midi_jog_wheel", []{ return std::make_unique<MIDIJogWheelModuleProcessor>(); });
            reg("midi_pads", []{ return std::make_unique<MIDIPadModuleProcessor>(); });
            reg("midi_logger", []{ return std::make_unique<MidiLoggerModuleProcessor>(); });
            reg("tempo_clock", []{ return std::make_unique<TempoClockModuleProcessor>(); });
            reg("physics", []{ return std::make_unique<PhysicsModuleProcessor>(); });
            reg("animation", []{ return std::make_unique<AnimationModuleProcessor>(); });
            reg("stroke_sequencer", []{ return std::make_unique<StrokeSequencerModuleProcessor>(); });
            
            reg("meta module", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("metamodule", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("inlet", []{ return std::make_unique<InletModuleProcessor>(); });
            reg("outlet", []{ return std::make_unique<OutletModuleProcessor>(); });

            initialised = true;
        }
        return factory;
    }
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addModule(const juce::String& moduleType, bool commit)
{
    const juce::ScopedLock lock (moduleLock);
    auto& factory = getModuleFactory();
    const juce::String key = moduleType.toLowerCase();
    std::unique_ptr<juce::AudioProcessor> processor;

    if (auto it = factory.find(key); it != factory.end())
        processor = it->second();

    if (! processor)
    {
        for (const auto& kv : factory)
            if (moduleType.equalsIgnoreCase(kv.first)) { processor = kv.second(); break; }
    }

    if (processor)
    {
        auto node = internalGraph->addNode(std::move(processor), {}, juce::AudioProcessorGraph::UpdateKind::none);
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setParent(this);
        modules[(juce::uint32) node->nodeID.uid] = node;
        const juce::uint32 logicalId = nextLogicalId++;
        logicalIdToModule[logicalId] = LogicalModule{ node->nodeID, moduleType };
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setLogicalId(logicalId);
        
        if (moduleType.equalsIgnoreCase("audio_input"))
        {
            std::vector<int> defaultMapping = {0, 1};
            setAudioInputChannelMapping(node->nodeID, defaultMapping);
        }
        
        if (commit)
        {
            // Ensure the new module is immediately active
            commitChanges();
        }
        
        return node->nodeID;
    }

    juce::Logger::writeToLog("[ModSynth][WARN] Unknown module type: " + moduleType);
    return {};
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc,
    juce::uint32 logicalIdToAssign)
{
    juce::String errorMessage;
    std::unique_ptr<juce::AudioPluginInstance> instance = 
        formatManager.createPluginInstance(vstDesc, getSampleRate(), getBlockSize(), errorMessage);

    if (instance == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] Could not create VST instance: " + errorMessage);
        return {};
    }

    auto wrapper = std::make_unique<VstHostModuleProcessor>(std::move(instance), vstDesc);
    
    auto node = internalGraph->addNode(std::move(wrapper), {}, juce::AudioProcessorGraph::UpdateKind::none);

    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setParent(this);
    
    modules[(juce::uint32) node->nodeID.uid] = node;
    
    logicalIdToModule[logicalIdToAssign] = LogicalModule{ node->nodeID, vstDesc.name };
    
    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setLogicalId(logicalIdToAssign);
    
    juce::Logger::writeToLog("[ModSynth] Added VST module: " + vstDesc.name + " with logical ID " + juce::String(logicalIdToAssign));
    return node->nodeID;
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc)
{
    const juce::uint32 logicalId = nextLogicalId++;
    auto nodeId = addVstModule(formatManager, vstDesc, logicalId);
    
    if (nodeId.uid != 0)
        commitChanges();
    
    return nodeId;
}

void ModularSynthProcessor::removeModule(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;
    const juce::ScopedLock lock(moduleLock); // Ensure thread-safe access

    // --- LOGGING ---
    if (auto* node = internalGraph->getNodeForId(nodeID))
    {
        if (auto* proc = node->getProcessor())
        {
            juce::Logger::writeToLog("[GraphSync] Deleting module L-ID " + juce::String(getLogicalIdForNode(nodeID)) + 
                                   " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
        }
    }
    // --- END LOGGING ---

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    internalGraph->removeNode(nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    
    modules.erase((juce::uint32) nodeID.uid);
    if (logicalId != 0)
    {
        logicalIdToModule.erase(logicalId);
    }
}

bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            juce::Logger::writeToLog("[ModSynth][INFO] Skipping duplicate connection [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                     + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
            return true;
        }
    }

    const bool ok = internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
    if (! ok)
    {
        juce::Logger::writeToLog("[ModSynth][WARN] Failed to connect [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                 + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
    }
    return ok;
}

void ModularSynthProcessor::commitChanges()
{
    internalGraph->rebuild();
    
    if (getSampleRate() > 0 && getBlockSize() > 0)
    {
        internalGraph->prepareToPlay(getSampleRate(), getBlockSize());
    }

    juce::Logger::writeToLog("--- Modular Synth Internal Patch State ---");
    juce::Logger::writeToLog("Num Nodes: " + juce::String(internalGraph->getNodes().size()));
    juce::Logger::writeToLog("Num Connections: " + juce::String(internalGraph->getConnections().size()));
    for (const auto& node : internalGraph->getNodes())
    {
        auto* p = node->getProcessor();
        juce::String name = p ? p->getName() : juce::String("<null>");
        const int ins  = p ? p->getTotalNumInputChannels()  : -1;
        const int outs = p ? p->getTotalNumOutputChannels() : -1;
        juce::Logger::writeToLog("  Node: id=" + juce::String(node->nodeID.uid) + " name='" + name + "' ins=" + juce::String(ins) + " outs=" + juce::String(outs));
    }
    for (const auto& conn : internalGraph->getConnections())
    {
        juce::Logger::writeToLog("  Connection: [" + juce::String(conn.source.nodeID.uid) + ":" + juce::String(conn.source.channelIndex)
            + "] -> [" + juce::String(conn.destination.nodeID.uid) + ":" + juce::String(conn.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog("-----------------------------------------");
    
    for (const auto& kv : logicalIdToModule)
    {
        if (ModuleProcessor* mp = getModuleForLogical(kv.first))
        {
            mp->setLogicalId(kv.first);
        }
    }
    
    // --- FINAL THREAD-SAFE FIX: Rebuild the list of active processors for the audio thread ---
    auto newProcessors = std::make_shared<std::vector<std::shared_ptr<ModuleProcessor>>>();
    {
        const juce::ScopedLock lock(moduleLock);
        newProcessors->reserve(logicalIdToModule.size());
        juce::Logger::writeToLog("[GraphSync] Building new processor list...");
        for (const auto& pair : logicalIdToModule)
        {
            // Find the Node::Ptr from the modules map
            auto modIt = modules.find((juce::uint32)pair.second.nodeID.uid);
            if (modIt != modules.end())
            {
                auto nodePtr = modIt->second; // This is a Node::Ptr (shared_ptr<Node>)
                if (auto* proc = dynamic_cast<ModuleProcessor*>(nodePtr->getProcessor()))
                {
                    // Create a shared_ptr to the processor with a custom deleter that keeps the Node alive
                    auto processor = std::shared_ptr<ModuleProcessor>(proc, [nodePtr](ModuleProcessor*) {
                        // Custom deleter: just hold the nodePtr, don't actually delete the processor
                        // When this shared_ptr is destroyed, the nodePtr will be released
                    });
                    newProcessors->push_back(processor);
                    juce::Logger::writeToLog("  [+] Adding module L-ID " + juce::String(pair.first) + 
                                           " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
                }
            }
        }
    }
    activeAudioProcessors.store(newProcessors);
    juce::Logger::writeToLog("[GraphSync] Updated active processor list for audio thread with " + juce::String(newProcessors->size()) + " modules.");
}

void ModularSynthProcessor::clearAll()
{
    const juce::ScopedLock lock (moduleLock);
    
    // --- LOGGING ---
    juce::Logger::writeToLog("[GraphSync] clearAll() initiated - removing " + juce::String(logicalIdToModule.size()) + " modules");
    // --- END LOGGING ---
    
    for (const auto& kv : logicalIdToModule)
    {
        internalGraph->removeNode(kv.second.nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    }

    modules.clear();
    logicalIdToModule.clear();
    nextLogicalId = 1;

    commitChanges();
}

void ModularSynthProcessor::clearAllConnections()
{
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex && 
            conn.destination.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearOutputConnections()
{
    if (audioOutputNode == nullptr)
        return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == audioOutputNode->nodeID)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearConnectionsForNode(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == nodeID || conn.destination.nodeID == nodeID)
        {
            if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
            {
                internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            }
        }
    }

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    commitChanges();
}

void ModularSynthProcessor::setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap)
{
    if (audioInputNode == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] setAudioInputChannelMapping called but main audioInputNode is null.");
        return;
    }

    juce::String mapStr;
    for (int i = 0; i < (int)channelMap.size(); ++i)
    {
        if (i > 0) mapStr += ", ";
        mapStr += juce::String(channelMap[i]);
    }
    juce::Logger::writeToLog("[ModSynth] Remapping Audio Input Module " + juce::String(audioInputNodeId.uid) +
                             " to channels: [" + mapStr + "]");

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == audioInputNode->nodeID && conn.destination.nodeID == audioInputNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }

    for (int moduleChannel = 0; moduleChannel < (int)channelMap.size(); ++moduleChannel)
    {
        int hardwareChannel = channelMap[moduleChannel];
        internalGraph->addConnection({ { audioInputNode->nodeID, hardwareChannel }, { audioInputNodeId, moduleChannel } }, 
                                     juce::AudioProcessorGraph::UpdateKind::none);
    }

    commitChanges();
}

std::vector<std::pair<juce::uint32, juce::String>> ModularSynthProcessor::getModulesInfo() const
{
    const juce::ScopedLock lock (moduleLock);
    std::vector<std::pair<juce::uint32, juce::String>> out;
    out.reserve(logicalIdToModule.size());
    for (const auto& kv : logicalIdToModule)
        out.emplace_back(kv.first, kv.second.type);
    return out;
}

juce::AudioProcessorGraph::NodeID ModularSynthProcessor::getNodeIdForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return {};
    return it->second.nodeID;
}

juce::uint32 ModularSynthProcessor::getLogicalIdForNode (const NodeID& nodeId) const
{
    const juce::ScopedLock lock (moduleLock);
    for (const auto& kv : logicalIdToModule)
        if (kv.second.nodeID == nodeId)
            return kv.first;
    return 0;
}

bool ModularSynthProcessor::disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };
    return internalGraph->removeConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}

std::vector<ModularSynthProcessor::ConnectionInfo> ModularSynthProcessor::getConnectionsInfo() const
{
    std::vector<ConnectionInfo> out;
    for (const auto& c : internalGraph->getConnections())
    {
        ConnectionInfo info;
        info.srcLogicalId = getLogicalIdForNode(c.source.nodeID);
        info.srcChan = c.source.channelIndex;
        info.dstLogicalId = getLogicalIdForNode(c.destination.nodeID);
        info.dstChan = c.destination.channelIndex;
        info.dstIsOutput = (c.destination.nodeID == audioOutputNode->nodeID);
        if (info.srcLogicalId != 0 && (info.dstLogicalId != 0 || info.dstIsOutput))
            out.push_back(info);
    }
    return out;
}


ModuleProcessor* ModularSynthProcessor::getModuleForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return nullptr;
    if (auto* node = internalGraph->getNodeForId(it->second.nodeID))
        return dynamic_cast<ModuleProcessor*>(node->getProcessor());
    return nullptr;
}

juce::String ModularSynthProcessor::getModuleTypeForLogical(juce::uint32 logicalId) const
{
    auto it = logicalIdToModule.find(logicalId);
    if (it != logicalIdToModule.end())
    {
        return it->second.type;
    }
    return {};
}

// === COMPREHENSIVE DIAGNOSTICS SYSTEM ===

juce::String ModularSynthProcessor::getSystemDiagnostics() const
{
    juce::String result = "=== MODULAR SYNTH SYSTEM DIAGNOSTICS ===\n\n";
    
    result += "Total Modules: " + juce::String((int)logicalIdToModule.size()) + "\n";
    result += "Next Logical ID: " + juce::String((int)nextLogicalId) + "\n\n";
    
    result += "=== MODULES ===\n";
    for (const auto& pair : logicalIdToModule)
    {
        result += "Logical ID " + juce::String((int)pair.first) + ": " + pair.second.type + 
                 " (Node ID: " + juce::String((int)pair.second.nodeID.uid) + ")\n";
    }
    result += "\n";
    
    result += getConnectionDiagnostics() + "\n";
    
    result += "=== GRAPH STATE ===\n";
    result += "Total Nodes: " + juce::String(internalGraph->getNumNodes()) + "\n";
    result += "Total Connections: (not available)\n";
    
    return result;
}

juce::String ModularSynthProcessor::getModuleDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (module)
    {
        return module->getAllDiagnostics();
    }
    else
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
}

juce::String ModularSynthProcessor::getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (!module)
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
    
    juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
    result += "Module: " + module->getName() + "\n\n";
    
    auto params = module->getParameters();
    
    for (int i = 0; i < params.size(); ++i)
    {
        auto* param = params[i];
        if (auto* paramWithId = dynamic_cast<juce::AudioProcessorParameterWithID*>(param))
        {
            int busIndex, channelIndex;
            if (module->getParamRouting(paramWithId->paramID, busIndex, channelIndex))
            {
                int absoluteChannel = module->getChannelIndexInProcessBlockBuffer(true, busIndex, channelIndex);
                result += "  \"" + paramWithId->paramID + "\" -> Bus " + juce::String(busIndex) + 
                         ", Channel " + juce::String(channelIndex) + " (Absolute: " + juce::String(absoluteChannel) + ")\n";
            }
            else
            {
                result += "  \"" + paramWithId->paramID + "\" -> NO ROUTING\n";
            }
        }
    }
    
    return result;
}

juce::String ModularSynthProcessor::getConnectionDiagnostics() const
{
    juce::String result = "=== CONNECTIONS ===\n";
    
    auto connections = getConnectionsInfo();
    for (const auto& conn : connections)
    {
        result += "Logical " + juce::String((int)conn.srcLogicalId) + ":" + juce::String(conn.srcChan) + 
                 " -> ";
        
        if (conn.dstIsOutput)
        {
            result += "OUTPUT:" + juce::String(conn.dstChan);
        }
        else
        {
            result += "Logical " + juce::String((int)conn.dstLogicalId) + ":" + juce::String(conn.dstChan);
        }
        result += "\n";
    }
    
    if (connections.empty())
    {
        result += "No connections found.\n";
    }
    
    return result;
}

bool ModularSynthProcessor::isAnyModuleRecording() const
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            if (recorder->getIsRecording())
                return true;
        }
    }
    return false;
}

void ModularSynthProcessor::pauseAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->pauseRecording();
        }
    }
}

void ModularSynthProcessor::resumeAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->resumeRecording();
        }
    }
}

void ModularSynthProcessor::startAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStartRecording();
        }
    }
}

void ModularSynthProcessor::stopAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStopRecording();
        }
    }
}

// === VOICE MANAGEMENT IMPLEMENTATION ===

int ModularSynthProcessor::findFreeVoice()
{
    for (int i = 0; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (!m_voices[i].isActive)
            return i;
    }
    return -1;
}

int ModularSynthProcessor::findOldestVoice()
{
    if (m_voices.empty())
        return -1;
    
    int oldestIndex = 0;
    juce::uint32 oldestAge = m_voices[0].age;
    
    for (int i = 1; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (m_voices[i].age < oldestAge)
        {
            oldestAge = m_voices[i].age;
            oldestIndex = i;
        }
    }
    
    return oldestIndex;
}

void ModularSynthProcessor::assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn)
{
    if (voiceIndex < 0 || voiceIndex >= static_cast<int>(m_voices.size()))
        return;
    
    Voice& voice = m_voices[voiceIndex];
    voice.isActive = true;
    voice.noteNumber = noteOn.getNoteNumber();
    voice.velocity = noteOn.getFloatVelocity();
    voice.age = m_globalVoiceAge++;
    
    juce::Logger::writeToLog("[VoiceManager] Assigned note " + juce::String(voice.noteNumber) + 
                            " to voice " + juce::String(voiceIndex));
}

void ModularSynthProcessor::releaseVoice(const juce::MidiMessage& noteOff)
{
    int noteNumber = noteOff.getNoteNumber();
    
    for (auto& voice : m_voices)
    {
        if (voice.isActive && voice.noteNumber == noteNumber)
        {
            voice.isActive = false;
            voice.noteNumber = -1;
            juce::Logger::writeToLog("[VoiceManager] Released note " + juce::String(noteNumber));
            return;
        }
    }
}

// === PROBE TOOL IMPLEMENTATION ===

void ModularSynthProcessor::setProbeConnection(const NodeID& sourceNodeID, int sourceChannel)
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
    {
        juce::Logger::writeToLog("[PROBE] ERROR: Probe scope not initialized!");
        return;
    }
    
    juce::Logger::writeToLog("[PROBE] setProbeConnection called. Source NodeID: " + juce::String(sourceNodeID.uid) + ", Channel: " + juce::String(sourceChannel));
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            juce::Logger::writeToLog("[PROBE] Cleared old probe connection.");
        }
    }
    
    bool success = connect(sourceNodeID, sourceChannel, probeScopeNodeId, 0);
    juce::Logger::writeToLog("[PROBE] New connection attempt " + juce::String(success ? "succeeded." : "FAILED."));
    if (success)
    {
        juce::Logger::writeToLog("[Probe] Successfully connected to probe scope");
    }
    else
    {
        juce::Logger::writeToLog("[Probe] ERROR: Failed to connect to probe scope");
    }
    
    commitChanges();
}

void ModularSynthProcessor::clearProbeConnection()
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
        return;
    
    juce::Logger::writeToLog("[PROBE] clearProbeConnection called.");
    bool cleared = false;
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            cleared = true;
        }
    }
    
    if (cleared) {
        juce::Logger::writeToLog("[PROBE] Cleared active probe connection.");
        commitChanges();
    } else {
        juce::Logger::writeToLog("[PROBE] No active probe connection to clear.");
    }
}

ModuleProcessor* ModularSynthProcessor::getProbeScopeProcessor() const
{
    if (!probeScopeNode)
        return nullptr;
    
    return dynamic_cast<ModuleProcessor*>(probeScopeNode->getProcessor());
}

================================================================================
FILE: juce\Source\audio\graph\VoiceProcessor.h
================================================================================


#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_dsp/juce_dsp.h>

class VoiceProcessor : public juce::AudioProcessor
{
public:
    VoiceProcessor();
    ~VoiceProcessor() override = default;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override final; // Final - cannot be overridden
    void releaseResources() override {}

    // Pure virtual method for subclasses to implement sound generation
    virtual void renderBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) = 0;

    const juce::String getName() const override { return "VoiceProcessor"; }
    bool isBusesLayoutSupported (const BusesLayout& layouts) const override
    {
        // Allow layouts where the input and output channel sets match (common for effects)
        // or where there is no input (for pure generators).
        if (layouts.getMainInputChannelSet() == layouts.getMainOutputChannelSet())
            return true;
            
        if (layouts.getMainInputChannelSet().isDisabled() && (layouts.getMainOutputChannelSet().size() == 1 || layouts.getMainOutputChannelSet().size() == 2))
            return true;
            
        return false;
    }
    // Implement all other necessary pure virtuals with empty bodies
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return ""; }
    void changeProgramName(int, const juce::String&) override {}
    void getStateInformation(juce::MemoryBlock&) override {}
    void setStateInformation(const void*, int) override {}

    juce::AudioProcessorValueTreeState& getAPVTS() { return apvts; }
    juce::uint64 uniqueId { 0 };

protected:
    juce::AudioProcessorValueTreeState apvts;

private:
    juce::dsp::StateVariableTPTFilter<float> filter;
    juce::dsp::Chorus<float>                 chorus;
    juce::dsp::Phaser<float>                 phaser;
    juce::dsp::Reverb                        reverb;
    juce::dsp::Compressor<float>             compressor;
    juce::dsp::Limiter<float>                limiter;
    juce::dsp::WaveShaper<float>             waveshaper;

    using DelayLine = juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear>;
    DelayLine                                   delayL { 192000 }, delayR { 192000 }; // up to ~2s @96k

    float gateEnvL { 1.0f }, gateEnvR { 1.0f };
    double currentSampleRate { 48000.0 };
    bool fxPrepared { false };
    juce::uint32 preparedChannels { 0 };
    juce::AudioBuffer<float>                 tempBuffer;
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VoiceProcessor)
};


================================================================================
FILE: juce\Source\audio\graph\VoiceProcessor.cpp
================================================================================


#include "VoiceProcessor.h"

VoiceProcessor::VoiceProcessor()
    : AudioProcessor(BusesProperties()
        .withInput("Input", juce::AudioChannelSet::stereo(), true)
        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "Parameters", createParameterLayout())
{}

void VoiceProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 2 };
    currentSampleRate = sampleRate;
    filter.reset();
    filter.prepare (spec);
    filter.setType (juce::dsp::StateVariableTPTFilterType::lowpass);
    chorus.reset();
    chorus.prepare (spec);
    phaser.reset();
    phaser.prepare (spec);
    reverb.reset();
    reverb.prepare (spec);
    compressor.reset();
    compressor.prepare (spec);
    limiter.reset();
    limiter.prepare (spec);
    waveshaper.reset();
    delayL.reset(); delayR.reset();
    {
        juce::dsp::ProcessSpec specMono { sampleRate, (juce::uint32) samplesPerBlock, 1 };
        delayL.prepare (specMono);
        delayR.prepare (specMono);
    }
    fxPrepared = true;
    preparedChannels = spec.numChannels;
}

void VoiceProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    // Generate raw sound directly into the provided buffer.
    buffer.clear();
    renderBlock(buffer, midi);

    // No logging on audio thread

    // Load all parameters at the top
    const float cutoff        = apvts.getRawParameterValue("filterCutoff")    ? apvts.getRawParameterValue("filterCutoff")->load()    : 20000.0f;
    const float resonance     = apvts.getRawParameterValue("filterResonance") ? apvts.getRawParameterValue("filterResonance")->load() : 1.0f;
    const float chorusRate    = apvts.getRawParameterValue("chorusRate")      ? apvts.getRawParameterValue("chorusRate")->load()      : 1.0f;
    const float chorusDepth   = apvts.getRawParameterValue("chorusDepth")     ? apvts.getRawParameterValue("chorusDepth")->load()     : 0.25f;
    const float chorusMix     = apvts.getRawParameterValue("chorusMix")       ? apvts.getRawParameterValue("chorusMix")->load()       : 0.5f;
    const float phaserRate    = apvts.getRawParameterValue("phaserRate")      ? apvts.getRawParameterValue("phaserRate")->load()      : 0.5f;
    const float phaserDepth   = apvts.getRawParameterValue("phaserDepth")     ? apvts.getRawParameterValue("phaserDepth")->load()     : 0.5f;
    const float phaserCentre  = apvts.getRawParameterValue("phaserCentre")    ? apvts.getRawParameterValue("phaserCentre")->load()    : 1000.0f;
    const float phaserFB      = apvts.getRawParameterValue("phaserFeedback")  ? apvts.getRawParameterValue("phaserFeedback")->load()  : 0.0f;
    const float phaserMix     = apvts.getRawParameterValue("phaserMix")       ? apvts.getRawParameterValue("phaserMix")->load()       : 0.0f;
    const float revRoom       = apvts.getRawParameterValue("reverbRoom")      ? apvts.getRawParameterValue("reverbRoom")->load()      : 0.0f;
    const float revDamp       = apvts.getRawParameterValue("reverbDamp")      ? apvts.getRawParameterValue("reverbDamp")->load()      : 0.5f;
    const float revWidth      = apvts.getRawParameterValue("reverbWidth")     ? apvts.getRawParameterValue("reverbWidth")->load()     : 1.0f;
    const float revMix        = apvts.getRawParameterValue("reverbMix")       ? apvts.getRawParameterValue("reverbMix")->load()       : 0.0f;
    const float delayMs       = apvts.getRawParameterValue("delayTimeMs")     ? apvts.getRawParameterValue("delayTimeMs")->load()     : 0.0f;
    const float delayFB       = apvts.getRawParameterValue("delayFeedback")   ? apvts.getRawParameterValue("delayFeedback")->load()   : 0.0f;
    const float delayMix      = apvts.getRawParameterValue("delayMix")        ? apvts.getRawParameterValue("delayMix")->load()        : 0.0f;
    const float compThresh    = apvts.getRawParameterValue("compThreshold")   ? apvts.getRawParameterValue("compThreshold")->load()   : 0.0f;
    const float compRatio     = apvts.getRawParameterValue("compRatio")       ? apvts.getRawParameterValue("compRatio")->load()       : 1.0f;
    const float compAttack    = apvts.getRawParameterValue("compAttackMs")    ? apvts.getRawParameterValue("compAttackMs")->load()    : 10.0f;
    const float compRelease   = apvts.getRawParameterValue("compReleaseMs")   ? apvts.getRawParameterValue("compReleaseMs")->load()   : 100.0f;
    const float compMakeup    = apvts.getRawParameterValue("compMakeup")      ? apvts.getRawParameterValue("compMakeup")->load()      : 0.0f;
    const float limitThresh   = apvts.getRawParameterValue("limitThreshold")  ? apvts.getRawParameterValue("limitThreshold")->load()  : 0.0f;
    const float limitRelease  = apvts.getRawParameterValue("limitReleaseMs")  ? apvts.getRawParameterValue("limitReleaseMs")->load()  : 10.0f;
    const float drive         = apvts.getRawParameterValue("driveAmount")     ? apvts.getRawParameterValue("driveAmount")->load()     : 0.0f;
    const float driveMix      = apvts.getRawParameterValue("driveMix")        ? apvts.getRawParameterValue("driveMix")->load()        : 0.0f;
    const float gateThresh    = apvts.getRawParameterValue("gateThreshold")   ? apvts.getRawParameterValue("gateThreshold")->load()   : -100.0f;
    const float gateAttack    = apvts.getRawParameterValue("gateAttackMs")    ? apvts.getRawParameterValue("gateAttackMs")->load()    : 1.0f;
    const float gateRelease   = apvts.getRawParameterValue("gateReleaseMs")   ? apvts.getRawParameterValue("gateReleaseMs")->load()   : 50.0f;

    // --- 2. Process FX: Filter then Chorus ---
    // Guard against unprepared FX or channel mismatch
    juce::dsp::AudioBlock<float> block (buffer);
    if (fxPrepared && preparedChannels > 0 && block.getNumChannels() > 0 && block.getNumChannels() == preparedChannels)
    {
        juce::dsp::ProcessContextReplacing<float> context (block);

        // Apply Filter only if non-neutral
        if (cutoff < 19900.0f || resonance > 1.0f)
        {
            filter.setCutoffFrequency (juce::jlimit (20.0f, 20000.0f, cutoff));
            filter.setResonance       (juce::jlimit (0.1f, 20.0f,   resonance));
            filter.process (context);
        }

        // Apply Chorus only if it has depth
        if (chorusDepth > 0.001f)
        {
            chorus.setRate  (juce::jlimit (0.05f, 5.0f, chorusRate));
            chorus.setDepth (juce::jlimit (0.0f, 1.0f,  chorusDepth));
            chorus.setMix   (juce::jlimit (0.0f, 1.0f,  chorusMix));
            chorus.process (context);
        }

        // Phaser
        if (phaserDepth > 0.001f || std::abs (phaserFB) > 0.001f)
        {
            phaser.setRate (juce::jlimit (0.01f, 10.0f, phaserRate));
            phaser.setDepth (juce::jlimit (0.0f, 1.0f, phaserDepth));
            phaser.setCentreFrequency (juce::jlimit (20.0f, 20000.0f, phaserCentre));
            phaser.setFeedback (juce::jlimit (-0.99f, 0.99f, phaserFB));
            if (phaserMix > 0.0f)
            {
                tempBuffer.makeCopyOf (buffer, true);
                juce::dsp::AudioBlock<float> tmp (tempBuffer);
                juce::dsp::ProcessContextReplacing<float> ctx (tmp);
                phaser.process (ctx);
                const float dry = 1.0f - phaserMix;
                const float wet = phaserMix;
                for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
                    buffer.addFrom (ch, 0, tempBuffer, ch, 0, buffer.getNumSamples(), wet - dry);
                buffer.applyGain (dry);
            }
            else
            {
                phaser.process (context);
            }
        }

        // Delay (simple stereo): process using dsp::DelayLine processSample to avoid state issues
        if (delayMix > 0.0f && delayMs > 0.0f)
        {
            const float maxDelaySamples = 4.0f * (float) currentSampleRate; // 4s safety
            const float delaySamples = juce::jlimit (1.0f, maxDelaySamples, delayMs * (float) currentSampleRate * 0.001f);
            const float fb = juce::jlimit (0.0f, 0.95f, delayFB);

            delayL.setDelay (delaySamples);
            delayR.setDelay (delaySamples);
            auto* l = buffer.getWritePointer (0);
            auto* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : l;

            const float dry = 1.0f - delayMix;
            const float wet = delayMix;
            for (int i = 0; i < buffer.getNumSamples(); ++i)
            {
                const float yl = delayL.popSample (0);
                const float yr = delayR.popSample (0);
                const float dlIn = juce::jlimit (-1.0f, 1.0f, l[i] + yl * fb);
                const float drIn = juce::jlimit (-1.0f, 1.0f, r[i] + yr * fb);
                delayL.pushSample (0, dlIn);
                delayR.pushSample (0, drIn);
                l[i] = l[i] * dry + yl * wet;
                r[i] = r[i] * dry + yr * wet;
            }
        }

        // Reverb
        if (revMix > 0.0f)
        {
            juce::dsp::Reverb::Parameters rp;
            rp.roomSize = juce::jlimit (0.0f, 1.0f, revRoom);
            rp.damping  = juce::jlimit (0.0f, 1.0f, revDamp);
            rp.width    = juce::jlimit (0.0f, 1.0f, revWidth);
            rp.wetLevel = juce::jlimit (0.0f, 1.0f, revMix);
            rp.dryLevel = 1.0f - rp.wetLevel;
            reverb.setParameters (rp);
            reverb.process (context);
        }

        // Drive (tanh) with dry/wet
        if (drive > 0.001f)
        {
            const float k = juce::jlimit (0.0f, 10.0f, drive) * 5.0f;
            tempBuffer.makeCopyOf (buffer, true);
            for (int ch = 0; ch < tempBuffer.getNumChannels(); ++ch)
            {
                auto* d = tempBuffer.getWritePointer (ch);
                for (int i = 0; i < tempBuffer.getNumSamples(); ++i)
                    d[i] = std::tanh (k * d[i]);
            }
            const float dry = juce::jlimit (0.0f, 1.0f, 1.0f - driveMix);
            const float wet = juce::jlimit (0.0f, 1.0f, driveMix);
            buffer.applyGain (dry);
            for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
                buffer.addFrom (ch, 0, tempBuffer, ch, 0, buffer.getNumSamples(), wet);
        }

        // Compressor
        if (compRatio > 1.0f)
        {
            compressor.setThreshold (juce::jlimit (-60.0f, 0.0f, compThresh));
            compressor.setRatio (juce::jmax (1.0f, compRatio));
            compressor.setAttack (juce::jlimit (0.1f, 200.0f, compAttack));
            compressor.setRelease (juce::jlimit (5.0f, 1000.0f, compRelease));
            juce::dsp::AudioBlock<float> b (buffer);
            juce::dsp::ProcessContextReplacing<float> c (b);
            compressor.process (c);
            if (std::abs (compMakeup) > 0.001f)
                buffer.applyGain (juce::Decibels::decibelsToGain (compMakeup));
        }

        // Limiter
        if (limitThresh < 0.0f)
        {
            limiter.setThreshold (juce::jlimit (-20.0f, 0.0f, limitThresh));
            limiter.setRelease (juce::jlimit (1.0f, 200.0f, limitRelease));
            juce::dsp::AudioBlock<float> b (buffer);
            juce::dsp::ProcessContextReplacing<float> c (b);
            limiter.process (c);
        }

        // Simple noise gate (post FX, pre gain) using envelope follower against dB threshold
        if (gateThresh > -90.0f)
        {
            const float thrLin = juce::Decibels::decibelsToGain (gateThresh);
            const float atk = juce::jlimit (0.001f, 0.5f, gateAttack * 0.001f);
            const float rel = juce::jlimit (0.001f, 2.0f, gateRelease * 0.001f);
            auto* l = buffer.getWritePointer (0);
            auto* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : l;
            for (int i = 0; i < buffer.getNumSamples(); ++i)
            {
                const float mag = std::max (std::abs (l[i]), std::abs (r[i]));
                const float target = (mag >= thrLin) ? 1.0f : 0.0f;
                gateEnvL += (target - gateEnvL) * (target > gateEnvL ? atk : rel);
                gateEnvR = gateEnvL;
                l[i] *= gateEnvL;
                r[i] *= gateEnvR;
            }
        }
    }

    // --- Apply final Gain and Pan. ---
    const float gain = apvts.getRawParameterValue("gain") ? apvts.getRawParameterValue("gain")->load() : 0.7f;
    const float pan  = apvts.getRawParameterValue("pan")  ? apvts.getRawParameterValue("pan")->load()  : 0.0f;

    // Calculate left and right channel multipliers based on pan law
    const float panL = std::cos((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);
    const float panR = std::sin((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);

    // Apply the master gain and the pan law separately for clarity and correctness.
    // First, apply the overall gain to all channels.
    buffer.applyGain(gain);

    // Then, apply the panning multipliers to their respective channels.
    buffer.applyGain(0, 0, buffer.getNumSamples(), panL);
    if (buffer.getNumChannels() > 1)
        buffer.applyGain(1, 0, buffer.getNumSamples(), panR);

    // Release diagnostics: append once in a while when silent
    {
        static int diagCounter = 0;
        if ((++diagCounter % 600) == 0)
        {
            const float mag = buffer.getMagnitude (0, buffer.getNumSamples());
            if (mag < 1.0e-6f)
            {
                juce::Logger::writeToLog ("[VoiceProcessor] silent block, gain=" + juce::String (gain) +
                                          " pan=" + juce::String (pan) +
                                          " ch=" + juce::String (buffer.getNumChannels()));
            }
        }
    }
}

juce::AudioProcessorValueTreeState::ParameterLayout VoiceProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    // Core Voice Params
    params.push_back(std::make_unique<juce::AudioParameterFloat>("gain", "Gain", 0.0f, 1.0f, 0.7f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("pan", "Pan", -1.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("frequency", "Frequency", 20.0f, 20000.0f, 440.0f));

    // --- FX PARAMS ---
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "filterCutoff", "Filter Cutoff",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 20000.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "filterResonance", "Filter Resonance",
        1.0f, 20.0f, 1.0f));

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusRate", "Chorus Rate",
        0.1f, 10.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusDepth", "Chorus Depth",
        0.0f, 1.0f, 0.25f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusMix", "Chorus Mix",
        0.0f, 1.0f, 0.5f));

    // Phaser
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserRate", "Phaser Rate",
        0.01f, 10.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserDepth", "Phaser Depth",
        0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserCentre", "Phaser Centre",
        20.0f, 20000.0f, 1000.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserFeedback", "Phaser Feedback",
        -0.99f, 0.99f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserMix", "Phaser Mix",
        0.0f, 1.0f, 0.0f));

    // Reverb
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbRoom", "Reverb Room",
        0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbDamp", "Reverb Damping",
        0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbWidth", "Reverb Width",
        0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbMix", "Reverb Mix",
        0.0f, 1.0f, 0.0f));

    // Delay
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayTimeMs", "Delay Time (ms)",
        1.0f, 2000.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayFeedback", "Delay Feedback",
        0.0f, 0.95f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayMix", "Delay Mix",
        0.0f, 1.0f, 0.0f));

    // Compressor
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compThreshold", "Comp Threshold (dB)",
        -60.0f, 0.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compRatio", "Comp Ratio",
        1.0f, 20.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compAttackMs", "Comp Attack (ms)",
        0.1f, 200.0f, 10.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compReleaseMs", "Comp Release (ms)",
        5.0f, 1000.0f, 100.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compMakeup", "Comp Makeup (dB)",
        -12.0f, 12.0f, 0.0f));

    // Limiter
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "limitThreshold", "Limiter Threshold (dB)",
        -20.0f, 0.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "limitReleaseMs", "Limiter Release (ms)",
        1.0f, 200.0f, 10.0f));

    // Distortion / Drive
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "driveAmount", "Drive Amount",
        0.0f, 2.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "driveMix", "Drive Mix",
        0.0f, 1.0f, 0.0f));

    // Time/Pitch
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "timeStretchRatio", "Time Stretch Ratio",
        0.25f, 6.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitchSemitones", "Pitch Shift (Semitones)",
        -24.0f, 24.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitchRatio", "Pitch Ratio",
        0.5f, 2.0f, 1.0f));

    // Noise Gate
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateThreshold", "Gate Threshold (dB)",
        -80.0f, -20.0f, -100.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateAttackMs", "Gate Attack (ms)",
        0.1f, 50.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateReleaseMs", "Gate Release (ms)",
        5.0f, 500.0f, 50.0f));

    return { params.begin(), params.end() };
}

================================================================================
FILE: juce\Source\audio\AudioEngine.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_core/juce_core.h>
#include "assets/SampleBank.h"
#include "graph/VoiceProcessor.h"
#include "fx/GainProcessor.h"
#include "voices/SampleVoiceProcessor.h"
#include "../ipc/CommandBus.h"
#include "../ipc/IpcServer.h"
#include "../ipc/OscClient.h"
#include "../ui/DebugInfo.h"

class AudioEngine : public juce::AudioSource, private juce::Timer
{
public:
    AudioEngine(juce::AudioDeviceManager& adm);
    ~AudioEngine() override;

    void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override;
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override;
    void releaseResources() override;

    VisualiserState getVisualiserState() const;
    void setMasterGain (float newGain);
    void dumpCurrentStateToLog();
    
    // Access to command bus for UI communication
    CommandBus& getCommandBus() { return commandBus; }
    
    // Get active voices info for UI
    struct VoiceInfo {
        juce::uint64 voiceId;
        juce::String voiceType;
        juce::String displayName;
    };
    juce::Array<VoiceInfo> getActiveVoicesInfo() const;
    float getVoiceParameterValue(juce::uint64 voiceId, const juce::String& paramName) const;
    
    // Get available audio input channel names from the current device
    juce::StringArray getAvailableInputChannelNames() const;
    
    // Get the name of the current input device
    juce::String getCurrentInputDeviceName() const;
    
    // Get list of all available input devices
    juce::StringArray getAvailableInputDeviceNames() const;
    
    // Change the global input device for the application
    void setInputDevice(const juce::String& deviceName);

    // --- Test-harness direct control API (bypasses OSC/CommandBus) ---
    // Create a voice directly and wire it to the master gain node. Returns new voiceId (or 0 on failure).
    juce::uint64 test_createVoice (const juce::String& voiceType);
    // Update an APVTS-mapped parameter on a specific voice (e.g., "gain", "pan").
    void test_updateVoiceParameter (juce::uint64 voiceId, const juce::String& paramId, float value);
    // Destroy a voice immediately.
    void test_destroyVoice (juce::uint64 voiceId);

private:
    void timerCallback() override;

    void handleCreateVoice (const Command& cmd);
    void handleDestroyVoice (juce::uint64 voiceId);
    void handleUpdateParam (const Command& cmd);
    void handleListenerUpdate (float x, float y, float radius, float nearRatio);
    void sendFullInfoSnapshot();
    void resetVoiceParamsToDefaults (VoiceProcessor* v);

    juce::AudioProcessorGraph::Node::Ptr connectAndAddVoice (std::unique_ptr<juce::AudioProcessor> processor);

    juce::AudioDeviceManager& deviceManager;
    CommandBus commandBus;
    IpcServer oscServer;
    OscClient oscClient;
    SampleBank sampleBank;

    using Node = juce::AudioProcessorGraph::Node;
    std::unique_ptr<juce::AudioProcessorGraph> mainGraph;
    Node::Ptr audioOutputNode;
    Node::Ptr masterGainNode;
    std::map<juce::uint64, Node::Ptr> activeVoices;
    std::map<juce::uint64, std::shared_ptr<SampleBank::Sample>> activeSampleRefs;

    // Runtime format
    double lastSampleRate { 0.0 };
    int lastBlockSize { 0 };
    bool chaosModeEnabled { false };

    // Lightweight logger and stats for the harness UI
    mutable juce::CriticalSection logLock;
    juce::StringArray logQueue;
    std::atomic<float> lastOutputPeak { 0.0f };

    // Reusable realtime scratch buffers to avoid per-callback allocations
    juce::AudioBuffer<float> tmpGraphBuffer;
    juce::AudioBuffer<float> tmpVoiceBuffer;

public:
    void appendLog (const juce::String& msg)
    {
        const juce::ScopedLock sl (logLock);
        logQueue.add ("[" + juce::Time::getCurrentTime().toString (true, true) + "] " + msg);
    }

    juce::StringArray drainLogs()
    {
        const juce::ScopedLock sl (logLock);
        juce::StringArray out;
        out.swapWith (logQueue);
        return out;
    }

    struct RuntimeStats { double sampleRate; int blockSize; int nodeCount; float masterGain; float lastPeak; int voiceCount; };
    RuntimeStats getRuntimeStats() const
    {
        RuntimeStats rs{};
        rs.sampleRate = lastSampleRate;
        rs.blockSize = lastBlockSize;
        rs.nodeCount = (int) (mainGraph ? mainGraph->getNodes().size() : 0);
        rs.lastPeak = lastOutputPeak.load();
        rs.voiceCount = (int) activeVoices.size();
        float g = 1.0f;
        if (masterGainNode != nullptr)
        {
            if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
            {
                if (auto* p = gp->getAPVTS().getRawParameterValue ("gain"))
                    g = p->load();
            }
        }
        rs.masterGain = g;
        return rs;
    }

    float listenerX { 0.0f }, listenerY { 0.0f }, listenerRadius { 300.0f }, listenerNear { 0.12f };
    double clockOffsetMs { 0.0 };
    bool clockSynced { false };

    mutable juce::CriticalSection visualiserLock;
    VisualiserState visualiserState;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioEngine)
}; 


================================================================================
FILE: juce\Source\audio\AudioEngine.cpp
================================================================================


#include "AudioEngine.h"
#include "voices/SampleVoiceProcessor.h"
#include "voices/SynthVoiceProcessor.h"
#include "voices/NoiseVoiceProcessor.h"
#include "graph/ModularSynthProcessor.h"
#include "voices/ModularVoice.h"
#include "fx/GainProcessor.h"
#include "../ipc/OscConfig.h"

AudioEngine::AudioEngine(juce::AudioDeviceManager& adm)
    : deviceManager(adm), oscServer(commandBus)
{
    mainGraph = std::make_unique<juce::AudioProcessorGraph>();

    // Ensure the main graph is configured for stereo in/out
    {
        juce::AudioProcessor::BusesLayout layout {
            juce::AudioChannelSet::stereo(),
            juce::AudioChannelSet::stereo()
        };
        if (! mainGraph->setBusesLayout (layout))
        {
            // Fallback to play-config details if layout setting is rejected
            mainGraph->setPlayConfigDetails (2, 2, 48000.0, 512);
        }
    }
    audioOutputNode = mainGraph->addNode (std::make_unique<juce::AudioProcessorGraph::AudioGraphIOProcessor>(juce::AudioProcessorGraph::AudioGraphIOProcessor::audioOutputNode));
    
    // Insert master gain node and route graph: Voices -> MasterGain -> Output
    auto master = std::make_unique<GainProcessor>();
    masterGainNode = mainGraph->addNode (std::move (master));
    {
        using NodeAndChannel = juce::AudioProcessorGraph::NodeAndChannel;
        juce::AudioProcessorGraph::Connection cL { NodeAndChannel{ masterGainNode->nodeID, 0 }, NodeAndChannel{ audioOutputNode->nodeID, 0 } };
        juce::AudioProcessorGraph::Connection cR { NodeAndChannel{ masterGainNode->nodeID, 1 }, NodeAndChannel{ audioOutputNode->nodeID, 1 } };
        mainGraph->addConnection (cL);
        mainGraph->addConnection (cR);

        // Constant tone removed
    }

    // Bind OSC server (Python -> JUCE)
    oscServer.bind (OscConfig::kJuceServerPort);
    // Connect OSC client (JUCE -> Python)
    oscClient.connect (OscConfig::kPythonHost, OscConfig::kPythonPort);

    // Kick main logic loop
    startTimerHz (120);
}
static void logGraphTopology (juce::AudioProcessorGraph* g)
{
    if (g == nullptr) return;
    juce::Logger::writeToLog ("--- MAIN GRAPH TOPOLOGY ---");
    auto nodes = g->getNodes();
    for (auto* n : nodes)
    {
        if (n == nullptr) continue;
        auto* p = n->getProcessor();
        const int ins  = p ? p->getTotalNumInputChannels()  : 0;
        const int outs = p ? p->getTotalNumOutputChannels() : 0;
        juce::Logger::writeToLog ("  Node: id=" + juce::String ((int) n->nodeID.uid)
            + " name='" + (p ? p->getName() : juce::String("<null>")) + "' ins=" + juce::String (ins)
            + " outs=" + juce::String (outs));
    }
    auto conns = g->getConnections();
    for (auto& c : conns)
    {
        juce::Logger::writeToLog ("  Conn: [" + juce::String ((int)c.source.nodeID.uid) + ":" + juce::String (c.source.channelIndex)
            + "] -> [" + juce::String ((int)c.destination.nodeID.uid) + ":" + juce::String (c.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog ("---------------------------");
}

AudioEngine::~AudioEngine()
{
    stopTimer();
}

void AudioEngine::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    lastSampleRate = sampleRate;
    lastBlockSize = samplesPerBlockExpected;
    // Ensure the graph I/O configuration matches the device: 2 inputs, 2 outputs
    if (mainGraph)
    {
        mainGraph->setPlayConfigDetails (2, 2, sampleRate, samplesPerBlockExpected);
        // Do NOT override individual node play configs here; the graph manages node formats.
    }
    mainGraph->prepareToPlay (sampleRate, samplesPerBlockExpected);
    appendLog ("Engine prepared: sr=" + juce::String (sampleRate) + " block=" + juce::String (samplesPerBlockExpected));

    // DIAGNOSTIC: dump current output device and master gain
    auto* dev = deviceManager.getCurrentAudioDevice();
    appendLog ("Device: out='" + (dev ? dev->getName() : juce::String("<none>")) + "' sr="
               + juce::String (dev ? dev->getCurrentSampleRate() : 0.0)
               + " bs=" + juce::String (dev ? dev->getCurrentBufferSizeSamples() : 0));
}

void AudioEngine::sendFullInfoSnapshot()
{
    // Enumerate devices and send info to Python
    juce::AudioDeviceManager::AudioDeviceSetup setup;
    deviceManager.getAudioDeviceSetup(setup);
    juce::StringArray ins, outs;
    if (auto* t = deviceManager.getAvailableDeviceTypes().getFirst())
    {
        t->scanForDevices();
        ins = t->getDeviceNames(true);
        outs = t->getDeviceNames(false);
    }
    DBG ("AudioEngine::sendFullInfoSnapshot - sending devices and settings");
    oscClient.sendDeviceList ("input", ins);
    oscClient.sendDeviceList ("output", outs);
    // MIDI inputs
    {
        juce::StringArray midiIns;
        auto midiDevs = juce::MidiInput::getAvailableDevices();
        for (auto& d : midiDevs) midiIns.add (d.name);
        oscClient.sendMidiDeviceList (midiIns);
    }
    const float sr = (float) (deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getCurrentSampleRate() : 0.0f);
    const int bs  = (deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getCurrentBufferSizeSamples() : 0);
    oscClient.sendCurrentSettings (setup.inputDeviceName, setup.outputDeviceName, sr, bs);
    // Send latest master gain if available
    if (masterGainNode != nullptr)
    {
        float g = 1.0f;
        if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
        {
            if (auto* p = gp->getAPVTS().getRawParameterValue ("gain"))
                g = p->load();
        }
        oscClient.sendMasterGain (g);
    }
}

void AudioEngine::releaseResources()
{
    if (mainGraph) mainGraph->releaseResources();
}

juce::AudioProcessorGraph::Node::Ptr AudioEngine::connectAndAddVoice (std::unique_ptr<juce::AudioProcessor> processor)
{
    if (! mainGraph)
        return {};

    auto node = mainGraph->addNode (std::move (processor));
    using NodeAndChannel = juce::AudioProcessorGraph::NodeAndChannel;
    
    // Ensure bus layout on the voice processor is active and matches the graph's 0-in/2-out
    if (auto* vp = node->getProcessor())
    {
        const double sr = lastSampleRate > 0.0 ? lastSampleRate : 48000.0;
        const int    bs = lastBlockSize  > 0   ? lastBlockSize  : 512;
        vp->enableAllBuses();
        vp->setPlayConfigDetails (0, 2, sr, bs);
        vp->prepareToPlay (sr, bs);
    }

    // Connect the voice's audio output to the master gain, with diagnostics on failure
    juce::AudioProcessorGraph::Connection cL { NodeAndChannel{ node->nodeID, 0 }, NodeAndChannel{ masterGainNode->nodeID, 0 } };
    juce::AudioProcessorGraph::Connection cR { NodeAndChannel{ node->nodeID, 1 }, NodeAndChannel{ masterGainNode->nodeID, 1 } };
    const bool okL = mainGraph->addConnection (cL);
    const bool okR = mainGraph->addConnection (cR);
    if (!okL || !okR)
    {
        auto* src = node->getProcessor();
        auto* dst = masterGainNode ? masterGainNode->getProcessor() : nullptr;
        appendLog ("[ERR] Failed to connect voice->master: okL=" + juce::String (okL ? 1 : 0) +
                   " okR=" + juce::String (okR ? 1 : 0) +
                   " srcOutCh=" + juce::String (src ? src->getTotalNumOutputChannels() : -1) +
                   " dstInCh=" + juce::String (dst ? dst->getTotalNumInputChannels() : -1));
    }

    // Ensure the processing topology is updated after adding a node and connections
    mainGraph->rebuild();

    // Dump and also append summary for diagnostics
    logGraphTopology (mainGraph.get());
    appendLog ("Graph after add: nodes=" + juce::String ((int) mainGraph->getNodes().size()) +
               " conns=" + juce::String ((int) mainGraph->getConnections().size()));
    
    return node;
}

void AudioEngine::getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill)
{
    if (bufferToFill.buffer == nullptr)
        return;

    const int numCh = bufferToFill.buffer->getNumChannels();
    const int start = bufferToFill.startSample;
    const int num   = bufferToFill.numSamples;
    if (numCh <= 0 || num <= 0)
        return;

    // Clear just the region we're responsible for and process
    bufferToFill.buffer->clear (start, num);
    // Render graph into scratch buffer and copy back into the requested region
    // Build a zero-copy view into the requested region and process directly
    juce::HeapBlock<float*> chans (numCh);
    for (int ch = 0; ch < numCh; ++ch)
        chans[ch] = bufferToFill.buffer->getWritePointer (ch) + start;
    juce::AudioBuffer<float> view (chans.getData(), numCh, num);
    juce::MidiBuffer midi;
    mainGraph->processBlock (view, midi);
    // Per-callback quick peek at level before master output
    if (masterGainNode)
    {
        auto* proc = masterGainNode->getProcessor();
        juce::ignoreUnused (proc); // reserved for future deeper probes
    }

    // DIAGNOSTIC: if silent, log once per second-ish (no safety tone injection)
    const float pk = bufferToFill.buffer->getMagnitude (start, num);
    lastOutputPeak.store (pk);
    static int silentCounter = 0;
    if (pk < 1.0e-6f && (++silentCounter % 120) == 0)
        appendLog ("WARN: Output magnitude near zero for recent callbacks");
}

void AudioEngine::timerCallback()
{
    // Drain commands
    for (int i = 0; i < 4096; ++i)
    {
        Command c; if (! commandBus.tryDequeue (c)) break;
        if (c.type == Command::Type::Create)          handleCreateVoice (c);
        else if (c.type == Command::Type::Destroy)    handleDestroyVoice (c.voiceId);
        else if (c.type == Command::Type::Update)     handleUpdateParam (c);
        else if (c.type == Command::Type::DebugDump)  dumpCurrentStateToLog();
        // ADD THIS ENTIRE NEW BLOCK:
        else if (c.type == Command::Type::LoadPreset)
        {
            // a. Find the target voice by its unique ID
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                // b. Safely check if this voice is a ModularVoice wrapper
                if (auto* mv = dynamic_cast<ModularVoice*>(it->second->getProcessor()))
                {
                    if (auto* msp = mv->getModularSynth()) // Get the internal synth
                    {
                        // c. Convert the XML string to a MemoryBlock and load the state
                        juce::MemoryBlock mb(c.presetData.toRawUTF8(), c.presetData.getNumBytesAsUTF8());
                        msp->setStateInformation(mb.getData(), (int)mb.getSize());
                        appendLog("Loaded preset onto Modular Synth voice ID: " + juce::String((juce::int64)c.voiceId));
                    }
                }
            }
        }
        else if (c.type == Command::Type::LoadPatchState)
        {
            // Load a snapshot from the Snapshot Sequencer
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* mv = dynamic_cast<ModularVoice*>(it->second->getProcessor()))
                {
                    if (auto* msp = mv->getModularSynth())
                    {
                        // The patchState is already a MemoryBlock, ready to load
                        msp->setStateInformation(c.patchState.getData(), (int)c.patchState.getSize());
                        appendLog("[SnapshotSeq] Loaded patch state for voice ID: " + juce::String((juce::int64)c.voiceId) +
                                " (size: " + juce::String((int)c.patchState.getSize()) + " bytes)");
                    }
                }
            }
        }
        else if (c.type == Command::Type::ResetFx)
        {
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
                {
                    resetVoiceParamsToDefaults(vp);
                    appendLog("Reset FX for voice ID: " + juce::String((juce::int64)c.voiceId));
                }
            }
        }
        else if (c.type == Command::Type::RandomizePitch)
        {
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
                {
                    if (auto* p = vp->getAPVTS().getParameter("pitchSemitones"))
                    {
                        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                        {
                            float randomPitch = juce::Random::getSystemRandom().nextFloat() * 24.0f - 12.0f; // -12 to +12 semitones
                            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(randomPitch));
                            appendLog("Randomized pitch for voice ID: " + juce::String((juce::int64)c.voiceId) + " to " + juce::String(randomPitch) + " semitones");
                        }
                    }
                }
            }
        }
        else if (c.type == Command::Type::RandomizeTime)
        {
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
                {
                    if (auto* p = vp->getAPVTS().getParameter("timeStretchRatio"))
                    {
                        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                        {
                            float randomRatio = juce::Random::getSystemRandom().nextFloat() * 4.0f + 0.25f; // 0.25 to 4.25 ratio
                            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(randomRatio));
                            appendLog("Randomized time stretch for voice ID: " + juce::String((juce::int64)c.voiceId) + " to " + juce::String(randomRatio) + " ratio");
                        }
                    }
                }
            }
        }
        else if (c.type == Command::Type::SetChaosMode)
        {
            chaosModeEnabled = c.chaosModeEnabled;
            appendLog("Chaos mode " + juce::String(chaosModeEnabled ? "enabled" : "disabled"));
        }
    }

    // Chaos Mode: Periodically randomize parameters if enabled
    static int chaosCounter = 0;
    if (chaosModeEnabled && ++chaosCounter % 100 == 0) // Every 100 timer calls
    {
        if (!activeVoices.empty())
        {
            auto& rng = juce::Random::getSystemRandom();
            auto it = activeVoices.begin();
            std::advance(it, rng.nextInt((int)activeVoices.size()));
            
            if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
            {
                // Random parameter list
                juce::StringArray params = {"filterCutoff", "filterResonance", "chorusRate", "chorusDepth", 
                                           "phaserRate", "phaserDepth", "reverbRoom", "reverbDamp", 
                                           "delayTimeMs", "delayFeedback", "driveAmount"};
                
                juce::String paramName = params[rng.nextInt(params.size())];
                if (auto* p = vp->getAPVTS().getParameter(paramName))
                {
                    if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                    {
                        float randomValue = rng.nextFloat(); // 0.0 to 1.0
                        r->setValueNotifyingHost(randomValue);
                    }
                }
            }
        }
    }

    // Bridge diagnostics to UI (minimal: just listener; voices left empty)
    {
        const juce::ScopedLock sl (visualiserLock);
        visualiserState.voices.clearQuick();
        visualiserState.listenerPosition = { listenerX, listenerY };
    }

    // CPU load reporting disabled to avoid repeated device manager init cost.
}

void AudioEngine::dumpCurrentStateToLog()
{
    juce::Logger::writeToLog ("--- JUCE STATE DUMP TRIGGERED ---");
    // Current audio device settings
    juce::AudioDeviceManager::AudioDeviceSetup setup;
    deviceManager.getAudioDeviceSetup(setup);
    auto* dev = deviceManager.getCurrentAudioDevice();
    const juce::String inName = setup.inputDeviceName;
    const juce::String outName = setup.outputDeviceName;
    const double sr = dev ? dev->getCurrentSampleRate() : 0.0;
    const int bs = dev ? dev->getCurrentBufferSizeSamples() : 0;
    juce::Logger::writeToLog ("[AUDIO] input='" + inName + "' output='" + outName + "' sr=" + juce::String (sr) + " bs=" + juce::String (bs));

    // Graph stats
    const int numNodes = (int) (mainGraph ? mainGraph->getNodes().size() : 0);
    juce::Logger::writeToLog ("[GRAPH] nodes=" + juce::String (numNodes));

    // Master gain param
    float masterGain = -1.0f;
    if (masterGainNode != nullptr)
    {
        if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
        {
            if (auto* p = gp->getAPVTS().getRawParameterValue ("gain"))
                masterGain = p->load();
        }
    }
    juce::Logger::writeToLog ("[GRAPH] masterGainParam=" + juce::String (masterGain));

    // Voices (log minimal APVTS values)
    juce::Logger::writeToLog ("[VOICES] count=" + juce::String ((int) activeVoices.size()));
    for (auto& kv : activeVoices)
    {
        const juce::uint64 vid = kv.first;
        auto* proc = kv.second ? kv.second->getProcessor() : nullptr;
        float apGain = -1.0f, apPan = 0.0f, apFreq = 0.0f;
        if (auto* vp = dynamic_cast<VoiceProcessor*> (proc))
        {
            if (auto* pG = vp->getAPVTS().getRawParameterValue ("gain")) apGain = pG->load();
            if (auto* pP = vp->getAPVTS().getRawParameterValue ("pan"))  apPan  = pP->load();
            if (auto* pF = vp->getAPVTS().getRawParameterValue ("frequency")) apFreq = pF->load();
        }
        juce::Logger::writeToLog ("[VOICE] id=" + juce::String ((juce::int64) vid) +
                                   " gain=" + juce::String (apGain) +
                                   " pan=" + juce::String (apPan) +
                                   " freq=" + juce::String (apFreq));
    }
}

juce::Array<AudioEngine::VoiceInfo> AudioEngine::getActiveVoicesInfo() const
{
    juce::Array<VoiceInfo> result;
    
    for (auto& kv : activeVoices)
    {
        const juce::uint64 voiceId = kv.first;
        auto node = kv.second;
        if (!node) continue;
        
        auto* proc = node->getProcessor();
        if (!proc) continue;
        
        VoiceInfo info;
        info.voiceId = voiceId;
        
        // Determine voice type and display name
        if (dynamic_cast<SynthVoiceProcessor*>(proc))
        {
            info.voiceType = "Synth";
            info.displayName = "Synth Voice " + juce::String((juce::int64)voiceId);
        }
        else if (dynamic_cast<NoiseVoiceProcessor*>(proc))
        {
            info.voiceType = "Noise";
            info.displayName = "Noise Voice " + juce::String((juce::int64)voiceId);
        }
        else if (auto* sampleProc = dynamic_cast<SampleVoiceProcessor*>(proc))
        {
            info.voiceType = "Sample";
            info.displayName = "Sample: " + sampleProc->getSourceName();
        }
        else if (dynamic_cast<ModularVoice*>(proc))
        {
            info.voiceType = "Modular";
            info.displayName = "Modular Synth " + juce::String((juce::int64)voiceId);
        }
        else
        {
            info.voiceType = "Unknown";
            info.displayName = "Unknown Voice " + juce::String((juce::int64)voiceId);
        }
        
        result.add(info);
    }
    
    return result;
}

float AudioEngine::getVoiceParameterValue(juce::uint64 voiceId, const juce::String& paramName) const
{
    auto it = activeVoices.find(voiceId);
    if (it != activeVoices.end())
    {
        if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
        {
            if (auto* p = vp->getAPVTS().getParameter(paramName))
            {
                if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                {
                    return r->getNormalisableRange().convertFrom0to1(p->getValue());
                }
            }
        }
    }
    return 0.0f; // Default value if parameter not found
}

juce::StringArray AudioEngine::getAvailableInputChannelNames() const
{
    if (auto* currentDevice = deviceManager.getCurrentAudioDevice())
    {
        return currentDevice->getInputChannelNames();
    }

    return {}; // Return empty array if no device
}

juce::String AudioEngine::getCurrentInputDeviceName() const
{
    if (auto* currentDevice = deviceManager.getCurrentAudioDevice())
    {
        return currentDevice->getName();
    }
    return "No Device";
}

juce::StringArray AudioEngine::getAvailableInputDeviceNames() const
{
    juce::StringArray names;
    // Get the first available device type (e.g., ASIO, CoreAudio, WASAPI)
    if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst())
    {
        deviceType->scanForDevices(); // Rescan to get the most up-to-date list
        names = deviceType->getDeviceNames(true); // 'true' for input devices
    }

    return names;
}

void AudioEngine::setInputDevice(const juce::String& deviceName)
{
    juce::AudioDeviceManager::AudioDeviceSetup setup;
    deviceManager.getAudioDeviceSetup(setup);

    if (setup.inputDeviceName != deviceName)
    {
        setup.inputDeviceName = deviceName;
        // This will restart the audio device with the new settings
        deviceManager.setAudioDeviceSetup(setup, true);
        appendLog("[AudioEngine] Changed input device to: " + deviceName);
    }
}

void AudioEngine::handleCreateVoice (const Command& cmd)
{
    if (!mainGraph) return;

    std::unique_ptr<VoiceProcessor> proc;
    // --- 1. Create the processor based on type ---
    if (cmd.voiceType.equalsIgnoreCase("synth")) {
        proc = std::make_unique<SynthVoiceProcessor>();
    } else if (cmd.voiceType.equalsIgnoreCase("noise")) {
        proc = std::make_unique<NoiseVoiceProcessor>();
    } else if (cmd.voiceType.equalsIgnoreCase("modular")) {
        proc = std::make_unique<ModularVoice>();
    } else if (cmd.voiceType.equalsIgnoreCase("sample")) {
        juce::File f(cmd.resourceName);
        auto smp = sampleBank.getOrLoad(f);
        if (!smp) {
            // FAILSAFE: Generate a 1-second sine wave if sample not found
            appendLog("WARNING: Sample not found: " + cmd.resourceName + " - generating sine wave failsafe");
            smp = sampleBank.generateSineWaveFailsafe(44100, 1.0); // 1 second at 44.1kHz
            if (!smp) {
                appendLog("ERROR: Failed to generate failsafe sample");
                return;
            }
        }
        auto sampleProc = std::make_unique<SampleVoiceProcessor>(smp);
        sampleProc->setSourceName(f.getFileName());
        sampleProc->setLooping(true); // Set looping by default
        activeSampleRefs[cmd.voiceId] = smp;
        proc = std::move(sampleProc);
    }

    if (proc == nullptr) {
        appendLog("ERROR: Unknown voice type for create command: " + cmd.voiceType);
        return;
    }

    // --- 2. Perform ALL necessary initialization steps BEFORE adding to the graph ---
    proc->uniqueId = cmd.voiceId;
    resetVoiceParamsToDefaults(proc.get());

    // CRITICAL FIX for "no sound": Set a non-zero default gain and centered pan.
    if (auto* p = proc->getAPVTS().getParameter("gain"))
        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(0.7f));
    
    if (auto* p = proc->getAPVTS().getParameter("pan"))
        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(0.0f));
    
    // --- 3. Add the fully prepared processor to the graph and connect it ---
    auto node = connectAndAddVoice(std::move(proc));
    // After the node is in the graph, prepare it with current runtime format
    if (node && node->getProcessor())
    {
        const double sr = lastSampleRate > 0.0 ? lastSampleRate : 48000.0;
        const int    bs = lastBlockSize  > 0   ? lastBlockSize  : 512;
        node->getProcessor()->setPlayConfigDetails (0, 2, sr, bs);
        node->getProcessor()->prepareToPlay (sr, bs);
    }
    activeVoices[cmd.voiceId] = node;

    // --- 4. MIDI connection is handled automatically in connectAndAddVoice ---
    
    // --- 5. Perform type-specific post-creation setup ---
    if (auto* mv = dynamic_cast<ModularVoice*>(node->getProcessor())) {
        if (auto* msp = mv->getModularSynth()) {
            auto vco = msp->addModule("VCO");
            auto out = msp->getOutputNodeID();
            
            // SIMPLER, BETTER DEFAULT PATCH: VCO directly to output (no VCA needed for basic sound)
            msp->connect(vco, 0, out, 0); // VCO -> Left Out
            msp->connect(vco, 0, out, 1); // VCO -> Right Out
            msp->commitChanges();
            
            appendLog("Created default modular patch: VCO -> Output (stereo)");
        }
    }

    appendLog("Successfully created voice '" + cmd.voiceType + "' with ID: " + juce::String((juce::int64)cmd.voiceId));
}

void AudioEngine::handleDestroyVoice (juce::uint64 voiceId)
{
    if (! mainGraph) return;
    auto it = activeVoices.find (voiceId);
    if (it == activeVoices.end()) return;
    auto node = it->second;
    mainGraph->removeNode (node->nodeID);
    activeVoices.erase (it);
    activeSampleRefs.erase (voiceId);
}

void AudioEngine::handleUpdateParam (const Command& cmd)
{
    // ADD THIS LINE:
    appendLog("[ENGINE LOG] Received UPDATE command for '" + cmd.paramName + "'.");
    
    if (cmd.voiceId == 0)
    {
        if (cmd.paramName == "listener.posX") listenerX = cmd.paramValue;
        else if (cmd.paramName == "listener.posY") listenerY = cmd.paramValue;
        else if (cmd.paramName == "listener.radius") listenerRadius = juce::jmax (0.0f, cmd.paramValue);
        else if (cmd.paramName == "listener.near") listenerNear = juce::jlimit (0.0f, 1.0f, cmd.paramValue);
        else if (cmd.paramName == "master.gain") setMasterGain (cmd.paramValue);
        else if (cmd.paramName == "device.set")
        {
            // cmd.voiceType packed as "type\nname"
            auto parts = juce::StringArray::fromLines (cmd.voiceType);
            if (parts.size() >= 2)
            {
                const juce::String kind = parts[0];
                const juce::String name = parts[1];
                juce::AudioDeviceManager::AudioDeviceSetup setup;
                deviceManager.getAudioDeviceSetup(setup);
                if (kind.equalsIgnoreCase ("input")) setup.inputDeviceName = name; else setup.outputDeviceName = name;
                deviceManager.setAudioDeviceSetup(setup, true);
                static OscClient client; client.connect ("127.0.0.1", 9002);
                const float sr = (float) (deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getCurrentSampleRate() : 0.0);
                const int bs = (deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getCurrentBufferSizeSamples() : 0);
                client.sendCurrentSettings (setup.inputDeviceName, setup.outputDeviceName, sr, bs);
            }
        }
        else if (cmd.paramName == "device.bufferSize")
        {
            const int newBS = juce::jmax (16, (int) std::round (cmd.paramValue));
            juce::AudioDeviceManager::AudioDeviceSetup setup;
            deviceManager.getAudioDeviceSetup(setup);
            setup.bufferSize = newBS;
            deviceManager.setAudioDeviceSetup(setup, true);
            static OscClient client; client.connect ("127.0.0.1", 9002);
            const float sr = (float) (deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getCurrentSampleRate() : 0.0);
            const int bs  = (deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getCurrentBufferSizeSamples() : 0);
            client.sendCurrentSettings (setup.inputDeviceName, setup.outputDeviceName, sr, bs);
        }
        else if (cmd.paramName == "engine.requestInfo")
        {
            sendFullInfoSnapshot();
        }
        return;
    }

    auto it = activeVoices.find (cmd.voiceId);
    if (it == activeVoices.end()) return;
    if (auto* vp = dynamic_cast<VoiceProcessor*> (it->second->getProcessor()))
    {
        // Fast-path engine switches for SampleVoiceProcessor (bypass APVTS latency)
        if (auto* svp = dynamic_cast<SampleVoiceProcessor*>(vp))
        {
            if (cmd.paramName == "engine")
            {
                const bool useNaive = (cmd.paramValue >= 0.5f);
                svp->setEngine(useNaive ? SampleVoiceProcessor::Engine::Naive
                                        : SampleVoiceProcessor::Engine::RubberBand);
                return;
            }
        }
        // APVTS-based updates only
        auto setParam = [vp] (const juce::String& id, float val)
        {
            if (auto* p = vp->getAPVTS().getParameter (id))
                if (auto* r = dynamic_cast<juce::RangedAudioParameter*> (p))
                    r->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, r->getNormalisableRange().convertTo0to1 (val)));
        };
        // Generic parameter update - handle any valid parameter ID
        setParam (cmd.paramName, cmd.paramValue);
    }
}

void AudioEngine::handleListenerUpdate (float x, float y, float radius, float nearRatio)
{
    listenerX = x; listenerY = y; listenerRadius = radius; listenerNear = nearRatio;
}

VisualiserState AudioEngine::getVisualiserState() const
{
    const juce::ScopedLock sl (visualiserLock);
    return visualiserState;
}

void AudioEngine::setMasterGain (float newGain)
{
    if (masterGainNode != nullptr)
    {
        if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
            gp->setLinearGain (newGain);
    }
}

juce::uint64 AudioEngine::test_createVoice (const juce::String& voiceType)
{
    if (! mainGraph)
        return 0;

    juce::uint64 newId = (juce::uint64) juce::Time::getMillisecondCounterHiRes();

    std::unique_ptr<juce::AudioProcessor> proc;
    if (voiceType.equalsIgnoreCase ("sample"))
    {
        // Try to load any available audio file from ./audio/samples or ./assets
        std::shared_ptr<SampleBank::Sample> smp;
        {
            juce::File cwd = juce::File::getCurrentWorkingDirectory();
            juce::File candidates[] = {
                cwd.getChildFile ("audio").getChildFile ("samples").getChildFile ("test.wav"),
                cwd.getChildFile ("assets").getChildFile ("test.wav")
            };
            for (auto& f : candidates)
            {
                if (f.existsAsFile()) { smp = sampleBank.getOrLoad (f); break; }
            }
        }
        if (! smp)
        {
            // Failsafe: synthesize a 1s sine tone into a temp buffer
            auto sample = std::make_shared<SampleBank::Sample>();
            const double sr = lastSampleRate > 0.0 ? lastSampleRate : 48000.0;
            const int n = (int) (sr);
            sample->stereo.setSize (2, n);
            for (int i = 0; i < n; ++i)
            {
                const float s = std::sin (2.0 * juce::MathConstants<double>::pi * 440.0 * (double) i / sr);
                sample->stereo.setSample (0, i, s);
                sample->stereo.setSample (1, i, s);
            }
            sample->buffer.makeCopyOf (sample->stereo, true);
            sample->sampleRate = sr;
            smp = sample;
        }
        auto p = std::make_unique<SampleVoiceProcessor> (smp);
        proc = std::move (p);
        activeSampleRefs[newId] = smp;
    }
    else if (voiceType.equalsIgnoreCase ("synth"))
    {
        auto p = std::make_unique<SynthVoiceProcessor>();
        proc = std::move (p);
    }
    else if (voiceType.equalsIgnoreCase ("noise"))
    {
        proc = std::make_unique<NoiseVoiceProcessor>();
    }
    else
    {
        return 0;
    }

    auto node = mainGraph->addNode (std::move (proc));
    using NodeAndChannel = juce::AudioProcessorGraph::NodeAndChannel;
    juce::AudioProcessorGraph::Connection cL { NodeAndChannel{ node->nodeID, 0 }, NodeAndChannel{ masterGainNode->nodeID, 0 } };
    juce::AudioProcessorGraph::Connection cR { NodeAndChannel{ node->nodeID, 1 }, NodeAndChannel{ masterGainNode->nodeID, 1 } };
    mainGraph->addConnection (cL);
    mainGraph->addConnection (cR);

    // Prepare the processor with current runtime format, then mark prepared
    if (auto* ap = node->getProcessor())
        ap->prepareToPlay (lastSampleRate > 0.0 ? lastSampleRate : 48000.0, lastBlockSize > 0 ? lastBlockSize : 512);
    if (auto* vp = dynamic_cast<VoiceProcessor*> (node->getProcessor()))
    {
        // Reasonable defaults via APVTS
        if (auto* p = vp->getAPVTS().getParameter ("gain"))
            if (auto* r = dynamic_cast<juce::RangedAudioParameter*> (p)) r->setValueNotifyingHost (r->getNormalisableRange().convertTo0to1 (0.7f));
        if (auto* p2 = vp->getAPVTS().getParameter ("pan"))
            if (auto* r2 = dynamic_cast<juce::RangedAudioParameter*> (p2)) r2->setValueNotifyingHost (r2->getNormalisableRange().convertTo0to1 (0.0f));
    }

    activeVoices[newId] = node;
    appendLog ("Created voice '" + voiceType + "' id=" + juce::String ((juce::int64) newId));
    return newId;
}

void AudioEngine::test_updateVoiceParameter (juce::uint64 voiceId, const juce::String& paramId, float value)
{
    auto it = activeVoices.find (voiceId);
    if (it == activeVoices.end()) return;
    auto* proc = it->second->getProcessor();
    if (! proc) return;
    // Update APVTS parameter by ID
    const int numParams = proc->getNumParameters();
    for (int i = 0; i < numParams; ++i)
    {
        if (auto* p = dynamic_cast<juce::AudioProcessorParameterWithID*> (proc->getParameters()[i]))
        {
            if (p->paramID.equalsIgnoreCase (paramId))
            {
                // Map linear value to normalized
                auto* ranged = dynamic_cast<juce::RangedAudioParameter*> (p);
                if (ranged != nullptr)
                {
                    const float norm = ranged->getNormalisableRange().convertTo0to1 (value);
                    ranged->beginChangeGesture();
                    ranged->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, norm));
                    ranged->endChangeGesture();
                    appendLog ("Set param '" + paramId + "'=" + juce::String (value) + " on voiceId=" + juce::String ((juce::int64) voiceId));
                }
                return;
            }
        }
    }
}

void AudioEngine::test_destroyVoice (juce::uint64 voiceId)
{
    handleDestroyVoice (voiceId);
}

void AudioEngine::resetVoiceParamsToDefaults (VoiceProcessor* v)
{
    if (v == nullptr) return;
    auto set = [v] (const char* id, float val)
    {
        if (auto* p = v->getAPVTS().getParameter (id))
            if (auto* r = dynamic_cast<juce::RangedAudioParameter*> (p))
                r->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, r->getNormalisableRange().convertTo0to1 (val)));
    };
    set ("filterCutoff", 20000.0f);
    set ("filterResonance", 1.0f);
    set ("chorusRate", 1.0f);
    set ("chorusDepth", 0.0f);
    set ("chorusMix", 0.0f);
    set ("phaserRate", 0.5f);
    set ("phaserDepth", 0.0f);
    set ("phaserCentre", 1000.0f);
    set ("phaserFeedback", 0.0f);
    set ("phaserMix", 0.0f);
    set ("reverbRoom", 0.0f);
    set ("reverbDamp", 0.5f);
    set ("reverbWidth", 1.0f);
    set ("reverbMix", 0.0f);
    set ("delayTimeMs", 0.0f);
    set ("delayFeedback", 0.0f);
    set ("delayMix", 0.0f);
    set ("compThreshold", 0.0f);
    set ("compRatio", 1.0f);
    set ("compAttackMs", 10.0f);
    set ("compReleaseMs", 100.0f);
    set ("compMakeup", 0.0f);
    set ("limitThreshold", 0.0f);
    set ("limitReleaseMs", 10.0f);
    set ("driveAmount", 0.0f);
    set ("driveMix", 0.0f);
    set ("gateThreshold", -100.0f);
    set ("gateAttackMs", 1.0f);
    set ("gateReleaseMs", 50.0f);
    set ("timeStretchRatio", 1.0f);
    set ("pitchSemitones", 0.0f);
    set ("pitchRatio", 1.0f);
}


================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <functional> // Required for std::function
#include <vector>
#include <map>
#include <unordered_map>
#include <atomic>

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#include <cmath>
#endif

// <<< TRANSPORT STATE FOR GLOBAL CLOCK >>>
// Transport state struct shared by all modules
struct TransportState {
    bool isPlaying = false;
    double bpm = 120.0;
    double songPositionBeats = 0.0;
    double songPositionSeconds = 0.0;
    // Optional global division broadcast from a master tempo/clock (-1 means inactive)
    std::atomic<int> globalDivisionIndex { -1 };
    // Flag to indicate if a Tempo Clock module is controlling the BPM (for UI feedback)
    std::atomic<bool> isTempoControlledByModule { false };
    
    // Custom copy constructor (atomics are not copyable by default)
    TransportState() = default;
    TransportState(const TransportState& other)
        : isPlaying(other.isPlaying)
        , bpm(other.bpm)
        , songPositionBeats(other.songPositionBeats)
        , songPositionSeconds(other.songPositionSeconds)
        , globalDivisionIndex(other.globalDivisionIndex.load())
        , isTempoControlledByModule(other.isTempoControlledByModule.load())
    {}
    
    // Custom copy assignment operator
    TransportState& operator=(const TransportState& other)
    {
        if (this != &other)
        {
            isPlaying = other.isPlaying;
            bpm = other.bpm;
            songPositionBeats = other.songPositionBeats;
            songPositionSeconds = other.songPositionSeconds;
            globalDivisionIndex.store(other.globalDivisionIndex.load());
            isTempoControlledByModule.store(other.isTempoControlledByModule.load());
        }
        return *this;
    }
};

// <<< MULTI-MIDI DEVICE SUPPORT >>>
// MIDI message with device source information
// This struct allows modules to filter MIDI by device and channel
struct MidiMessageWithDevice {
    juce::MidiMessage message;
    juce::String deviceIdentifier;
    juce::String deviceName;
    int deviceIndex = -1;
};

// <<< ALL PIN-RELATED DEFINITIONS ARE NOW CENTRALIZED HERE >>>

// Defines the data type of a modulation or audio signal
enum class PinDataType { CV, Audio, Gate, Raw };

// Forward declare NodeWidth enum (defined in ImGuiNodeEditorComponent.h)
// This avoids circular dependency while allowing ModulePinInfo to store it
enum class NodeWidth;

// Describes a single audio/CV input or output pin
struct AudioPin
{
    juce::String name;
    int channel;
    PinDataType type;
    
    AudioPin(const juce::String& n, int ch, PinDataType t) : name(n), channel(ch), type(t) {}
};

// Renamed to avoid conflict with ImGuiNodeEditorComponent's PinInfo
struct DynamicPinInfo {
    juce::String name;
    int channel;
    PinDataType type;

    // Constructor to allow brace-initialization
    DynamicPinInfo(const juce::String& n, int c, PinDataType t) : name(n), channel(c), type(t) {}
};

// Describes a single modulation input pin targeting a parameter
struct ModPin
{
    juce::String name;
    juce::String paramId;
    PinDataType type;
    
    ModPin(const juce::String& n, const juce::String& p, PinDataType t) : name(n), paramId(p), type(t) {}
};

// A collection of all pins for a given module type
struct ModulePinInfo
{
    NodeWidth defaultWidth;  // Standardized node width category
    std::vector<AudioPin> audioIns;
    std::vector<AudioPin> audioOuts;
    std::vector<ModPin> modIns;
    
    ModulePinInfo() : defaultWidth(static_cast<NodeWidth>(0)) {}  // Default to Small (0)
    
    ModulePinInfo(NodeWidth width,
                  std::initializer_list<AudioPin> ins,
                  std::initializer_list<AudioPin> outs,
                  std::initializer_list<ModPin> mods)
        : defaultWidth(width), audioIns(ins), audioOuts(outs), modIns(mods) {}
};

// Forward declaration for NodePinHelpers
class ModuleProcessor;

// Helper struct passed to modules for drawing their pins
struct NodePinHelpers
{
    std::function<void(const char* label, int channel)> drawAudioInputPin;
    std::function<void(const char* label, int channel)> drawAudioOutputPin;
    std::function<void(const char* inLabel, int inChannel, const char* outLabel, int outChannel)> drawParallelPins;
    std::function<void(ModuleProcessor* module)> drawIoPins;
};

class ModularSynthProcessor; // forward declaration

/**
    An abstract base class for all modular synthesizer components.

    This class enforces a common interface for modules, ensuring they can be
    managed by the ModularSynthProcessor. The key requirement is providing access
    to the module's own parameter state via getAPVTS().
*/
class ModuleProcessor : public juce::AudioProcessor
{
public:
    ModuleProcessor(const BusesProperties& ioLayouts) : juce::AudioProcessor(ioLayouts) {}
    ~ModuleProcessor() override = default;

    // Parent container link (set by ModularSynthProcessor when node is created)
    void setParent(ModularSynthProcessor* parent) { parentSynth = parent; }
    ModularSynthProcessor* getParent() const { return parentSynth; }

    // Pure virtual method that all concrete modules MUST implement.
    // This is crucial for the parameter proxy system.
    virtual juce::AudioProcessorValueTreeState& getAPVTS() = 0;

    // Optional UI hook for drawing parameters inside nodes (used by Preset Creator)
    virtual void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
    {
        juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded);
    }

    // Optional UI hook for drawing IO pins inside nodes
    virtual void drawIoPins(const NodePinHelpers& /*helpers*/) {}

#if defined(PRESET_CREATOR_UI)
    // Optional UI hook for modules that need custom node dimensions (Exception size category)
    // Return ImVec2(width, height) for custom size, or ImVec2(0, 0) to use default from PinDatabase
    // Height of 0 means auto-size to content (recommended for most cases)
    virtual ImVec2 getCustomNodeSize() const 
    { 
        return ImVec2(0.0f, 0.0f); // Default: use PinDatabase size
    }
#endif


    // Get the current output value for a channel (for visualization)
    virtual float getOutputChannelValue(int channel) const
    {
        if (juce::isPositiveAndBelow(channel, (int)lastOutputValues.size()) && lastOutputValues[channel])
            return lastOutputValues[channel]->load();
        return 0.0f;
    }
    
    // Helper method to update output telemetry with peak magnitude
    // Call this at the end of processBlock to update visualization values
    void updateOutputTelemetry(const juce::AudioBuffer<float>& buffer)
    {
        const int numChannels = juce::jmin(buffer.getNumChannels(), (int)lastOutputValues.size());
        for (int ch = 0; ch < numChannels; ++ch)
        {
            if (lastOutputValues[ch])
            {
                // Use peak magnitude (max absolute value) for better visualization
                const float peak = buffer.getMagnitude(ch, 0, buffer.getNumSamples());
                lastOutputValues[ch]->store(peak, std::memory_order_relaxed);
            }
        }
    }

    // Standardized labels for module audio I/O channels (override per module if needed)
    virtual juce::String getAudioInputLabel(int channel) const
    {
        return juce::String("In ") + juce::String(channel + 1);
    }

    virtual juce::String getAudioOutputLabel(int channel) const
    {
        return juce::String("Out ") + juce::String(channel + 1);
    }

    // Stable logical ID assigned by ModularSynthProcessor upon node creation.
    void setLogicalId(juce::uint32 id) { storedLogicalId = id; }
    juce::uint32 getLogicalId() const { return storedLogicalId; }

    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get detailed connection information for debugging
    virtual juce::String getConnectionDiagnostics() const
    {
        juce::String result = "=== CONNECTION DIAGNOSTICS ===\n";
        
        // Bus layout info
        result += "Input Buses: " + juce::String(getBusCount(true)) + "\n";
        result += "Output Buses: " + juce::String(getBusCount(false)) + "\n";
        
        for (int bus = 0; bus < getBusCount(true); ++bus)
        {
            auto busName = getBus(true, bus)->getName();
            auto numChannels = getBus(true, bus)->getNumberOfChannels();
            result += "  Input Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        for (int bus = 0; bus < getBusCount(false); ++bus)
        {
            auto busName = getBus(false, bus)->getName();
            auto numChannels = getBus(false, bus)->getNumberOfChannels();
            result += "  Output Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        return result;
    }
    
    // Get parameter routing diagnostics
    virtual juce::String getParameterRoutingDiagnostics() const
    {
        juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
        
        // Note: This method is const, so we can't access getAPVTS() directly
        // We'll return a placeholder for now
        result += "Parameter routing diagnostics require non-const access.\n";
        result += "Use getModuleDiagnostics() from ModularSynthProcessor instead.\n";
        
        return result;
    }
    
    // Get live parameter values for debugging
    virtual juce::String getLiveParameterDiagnostics() const
    {
        juce::String result = "=== LIVE PARAMETER VALUES ===\n";
        
        for (const auto& pair : paramLiveValues)
        {
            result += "  " + pair.first + ": " + juce::String(pair.second.load(), 4) + "\n";
        }
        
        return result;
    }
    
    // Get comprehensive module diagnostics
    virtual juce::String getAllDiagnostics() const
    {
        juce::String result = "=== MODULE DIAGNOSTICS ===\n";
        result += "Module Type: " + getName() + "\n\n";
        result += getConnectionDiagnostics() + "\n";
        result += getParameterRoutingDiagnostics() + "\n";
        result += getLiveParameterDiagnostics();
        return result;
    }


    /**
        Resolves a parameter's string ID to its modulation bus and channel.

        This is a virtual function that each module must override to declare which of its
        parameters can be modulated by an external signal. The function maps parameter IDs
        to their corresponding input bus and channel indices within that bus.

        @param paramId              The string ID of the parameter to query (e.g., "cutoff", "frequency").
        @param outBusIndex          Receives the index of the input bus used for modulation.
        @param outChannelIndexInBus Receives the channel index within that bus.
        @returns                    True if the parameter supports modulation, false otherwise.
        
        @see isParamInputConnected
    */
    virtual bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const;

    /**
        Checks if a parameter's modulation input is connected in the synth graph.

        This is the single, reliable method for a module's audio thread to determine
        if it should use an incoming CV signal instead of its internal parameter value.
        The function internally uses getParamRouting() to resolve the parameter to its
        bus/channel location, then queries the parent synth's connection graph.

        @param paramId The string ID of the parameter to check (e.g., "cutoff", "frequency").
        @returns       True if a cable is connected to this parameter's modulation input.
        
        @see getParamRouting
    */
    bool isParamInputConnected(const juce::String& paramId) const;

    // --- Live telemetry for UI (thread-safe, lock-free) ---
    void setLiveParamValue(const juce::String& paramId, float value)
    {
        auto result = paramLiveValues.try_emplace(paramId, value);
        if (!result.second)
            result.first->second.store(value, std::memory_order_relaxed);
    }

    float getLiveParamValue(const juce::String& paramId, float fallback) const
    {
        // FIX: Only return the "live" (modulated) value if the corresponding
        // modulation input is actually connected. Otherwise, always return the
        // fallback, which is the base parameter's real value.
        if (isParamInputConnected(paramId))
        {
            if (auto it = paramLiveValues.find(paramId); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // New helper: decouple the connectivity check (modParamId) from the live value key (liveKey).
    // This allows UI code to ask "is X_mod connected?" while reading the corresponding
    // live telemetry stored under a different key like "X_live".
    float getLiveParamValueFor(const juce::String& modParamId,
                               const juce::String& liveKey,
                               float fallback) const
    {
        if (isParamInputConnected(modParamId))
        {
            if (auto it = paramLiveValues.find(liveKey); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // Optional extra state hooks for modules that need to persist non-parameter data
    // Default: return invalid tree / ignore.
    virtual juce::ValueTree getExtraStateTree() const { return {}; }
    virtual void setExtraStateTree(const juce::ValueTree&) {}
    
    // Optional timing info hook for modules that need global clock/transport
    // Default: ignore (modules that don't need timing can skip implementing this)
    virtual void setTimingInfo(const TransportState& state) { juce::ignoreUnused(state); }
    
    // Optional dynamic pin interface for modules with variable I/O (e.g., polyphonic modules)
    // Default: return empty vector (no dynamic pins)
    virtual std::vector<DynamicPinInfo> getDynamicInputPins() const { return {}; }
    virtual std::vector<DynamicPinInfo> getDynamicOutputPins() const { return {}; }
    
    /**
        Device-aware MIDI processing (MULTI-MIDI CONTROLLER SUPPORT)
        
        This method is called by ModularSynthProcessor BEFORE the standard graph processing
        begins. It provides MIDI modules with device-aware MIDI messages that include the
        source device information (name, identifier, index).
        
        MIDI modules should override this method to:
        - Filter messages by device (e.g., only respond to a specific controller)
        - Filter messages by MIDI channel
        - Update internal state based on filtered MIDI input
        
        The regular processBlock() can then use this updated state to generate CV outputs.
        
        @param midiMessages A vector of MIDI messages with device source information
        
        Default implementation: Does nothing (opt-in for MIDI modules only)
        
        @see MidiMessageWithDevice
    */
    virtual void handleDeviceSpecificMidi(const std::vector<MidiMessageWithDevice>& midiMessages)
    {
        juce::ignoreUnused(midiMessages);
        // Default: do nothing. MIDI-aware modules will override this method.
    }

public:
    // OPTION 9: Make public for TTS debugging
    // Live, modulated parameter values for UI feedback
    std::unordered_map<juce::String, std::atomic<float>> paramLiveValues;

protected:
    // Thread-safe storage for last known output values (for tooltips)
    std::vector<std::unique_ptr<std::atomic<float>>> lastOutputValues;

#if defined(PRESET_CREATOR_UI)

    static void adjustParamOnWheel (juce::RangedAudioParameter* parameter,
                                    const juce::String& idOrName,
                                    float displayedValue)
    {
        if (parameter == nullptr) return;
        if (! ImGui::IsItemHovered()) return;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel == 0.0f) return;

        if (auto* pf = dynamic_cast<juce::AudioParameterFloat*>(parameter))
        {
            // No right-click editing here; modules can add InputFloat next to sliders

            const auto& range = pf->range;
            const float span = range.end - range.start;
            const juce::String id = idOrName.toLowerCase();

            float step = span / 200.0f; // default ~0.5% of range
            if (span <= 1.0f) step = 0.01f;
            // Custom: fine tune for sequencer steps
            if (id.contains ("step"))
            {
                step = 0.05f;
            }
            if (id.contains ("hz") || id.contains ("freq") || id.contains ("cutoff") || id.contains ("rate"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (1.0f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("ms") || id.contains ("time"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (0.1f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("db") || id.contains ("gain"))
            {
                step = 0.5f;
            }
            else if (id.contains ("mix") || id.contains ("depth") || id.contains ("amount") || id.contains ("resonance") || id.contains ("q") || id.contains ("size") || id.contains ("damp") || id.contains ("pan") || id.contains ("threshold"))
            {
                step = 0.01f;
            }

            float newVal = pf->get() + (wheel > 0 ? step : -step);
            newVal = juce::jlimit (range.start, range.end, newVal);
            *pf = newVal;
        }
        else if (auto* pc = dynamic_cast<juce::AudioParameterChoice*>(parameter))
        {
            int idx = pc->getIndex();
            idx += (ImGui::GetIO().MouseWheel > 0 ? 1 : -1);
            idx = juce::jlimit (0, pc->choices.size() - 1, idx);
            *pc = idx;
        }
        else if (auto* pi = dynamic_cast<juce::AudioParameterInt*>(parameter))
        {
            int currentVal = pi->get();
            int newVal = currentVal + (wheel > 0 ? 1 : -1);
            const auto& range = pi->getNormalisableRange();
            newVal = juce::jlimit((int)range.start, (int)range.end, newVal);
            *pi = newVal;
        }
        else if (auto* pb = dynamic_cast<juce::AudioParameterBool*>(parameter))
        {
            // Optional: toggle on strong scroll
            juce::ignoreUnused (pb);
        }
    }

#endif

public:
    //==============================================================================
    // Helper function to convert bus index and channel-in-bus to absolute channel index
    //==============================================================================
    int getChannelIndexInProcessBlockBuffer(bool isInput, int busIndex, int channelIndexInBus) const
    {
        int absoluteChannel = channelIndexInBus;
        if (busIndex > 0)
        {
            int sum = 0;
            const int numBuses = getBusCount(isInput);
            for (int b = 0; b < numBuses && b < busIndex; ++b)
                sum += getChannelCountOfBus(isInput, b);
            absoluteChannel = sum + channelIndexInBus;
        }
        return absoluteChannel;
    }

    //==============================================================================
    // Provide default implementations for the pure virtuals to reduce boilerplate
    // in concrete module classes.
    //==============================================================================
    const juce::String getName() const override { return "Module"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModuleProcessor)

protected:
    ModularSynthProcessor* parentSynth { nullptr };
    juce::uint32 storedLogicalId { 0 };
};

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.cpp
================================================================================


#include "ModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <unordered_set>


bool ModuleProcessor::getParamRouting(const juce::String& /*paramId*/, int& /*outBusIndex*/, int& /*outChannelIndexInBus*/) const
{
    return false;
}

bool ModuleProcessor::isParamInputConnected(const juce::String& paramId) const
{
    auto* synth = parentSynth;
    if (synth == nullptr)
        return false;

    juce::uint32 myLogicalId = storedLogicalId;
    if (myLogicalId == 0)
    {
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical (info.first) == this)
            {
                myLogicalId = info.first;
                break;
            }
        }
        if (myLogicalId == 0)
            return false;
    }

    int busIndex = -1;
    int chanInBus = -1;
    if (!getParamRouting(paramId, busIndex, chanInBus))
        return false;

    int absoluteChannel = chanInBus;
    if (busIndex > 0)
    {
        int sum = 0;
        const int numInputBuses = getBusCount(true);
        for (int b = 0; b < numInputBuses && b < busIndex; ++b)
            sum += getChannelCountOfBus(true, b);
        absoluteChannel = sum + chanInBus;
    }

    for (const auto& c : synth->getConnectionsInfo())
        if (c.dstLogicalId == myLogicalId && c.dstChan == absoluteChannel)
            return true;

    // Fallback: if stored logicalId yields no match, re-resolve by pointer and retry once.
    {
        juce::uint32 ptrResolvedId = 0;
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical(info.first) == this)
            {
                ptrResolvedId = info.first;
                break;
            }
        }
        if (ptrResolvedId != 0 && ptrResolvedId != myLogicalId)
        {
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == ptrResolvedId && c.dstChan == absoluteChannel)
                {
                    const_cast<ModuleProcessor*>(this)->setLogicalId(ptrResolvedId);
                    return true;
                }
            }
        }
    }

    return false;
}


================================================================================
FILE: juce\Source\audio\modules\BestPracticeNodeProcessor.h
================================================================================


#pragma once

/**
 * @file BestPracticeNodeProcessor.h
 * @brief Reference implementation demonstrating proper module naming conventions
 *
 * ## IMPORTANT: Module Naming Convention Standard
 *
 * This file serves as the definitive reference for the correct module naming convention
 * used throughout the Collider modular synthesizer system.
 *
 * ### The Problem We Solved
 * Previously, the system had inconsistent naming conventions:
 * - Module factory registered modules with lowercase names (e.g., "polyvco", "compressor")
 * - Module getName() methods returned PascalCase names (e.g., "PolyVCO", "Compressor")
 * - Module pin database used a mix of lowercase and PascalCase keys
 *
 * This caused pin color-coding failures because the UI couldn't find modules in the database.
 *
 * ### The Solution: Unified Lowercase Convention
 * We standardized on a **lowercase with spaces** naming convention:
 *
 * 1. **Module Factory Registration**: All modules registered as lowercase (e.g., "polyvco")
 * 2. **getName() Return Values**: All modules return lowercase names (e.g., "polyvco")
 * 3. **Pin Database Keys**: All keys are lowercase (e.g., "polyvco")
 * 4. **No Aliases Needed**: Single source of truth eliminates ambiguity
 *
 * ### Pattern for New Modules
 * When creating new modules, follow this exact pattern:
 *
 * ```cpp
 * class NewModuleProcessor : public ModuleProcessor
 * {
 * public:
 *     const juce::String getName() const override { return "new module"; }
 *     // ... rest of implementation
 * };
 * ```
 *
 * Register in ModularSynthProcessor.cpp:
 * ```cpp
 * reg("new module", []{ return std::make_unique<NewModuleProcessor>(); });
 * ```
 *
 * Add to pin database in ImGuiNodeEditorComponent.cpp:
 * ```cpp
 * modulePinDatabase["new module"] = ModulePinInfo(...);
 * ```
 *
 * ### Why This Works
 * - Module factory uses lowercase names as the canonical "type"
 * - getName() returns the same lowercase name for consistency
 * - UI looks up modules by their lowercase type in the pin database
 * - All lookups succeed because keys are standardized
 * - Pin colors display correctly (green for audio, blue for CV, yellow for gate)
 *
 * This pattern ensures robust, maintainable code and eliminates naming-related bugs.
 */

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include <cmath>

class BestPracticeNodeProcessor : public ModuleProcessor
{
public:
    // Parameter IDs
    static constexpr auto paramIdFrequency    = "frequency";
    static constexpr auto paramIdWaveform     = "waveform";
    static constexpr auto paramIdDrive        = "drive";
    // Virtual modulation target IDs (no APVTS parameters required)
    static constexpr auto paramIdFrequencyMod = "frequency_mod";
    static constexpr auto paramIdWaveformMod  = "waveform_mod";
    static constexpr auto paramIdDriveMod     = "drive_mod";

    BestPracticeNodeProcessor();
    ~BestPracticeNodeProcessor() override = default;

    const juce::String getName() const override { return "best_practice"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth,
                               const std::function<bool(const juce::String& paramId)>& isParamModulated,
                               const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
#endif

    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Oscillator<float> oscillator;

    // Cached parameter pointers
    std::atomic<float>* frequencyParam { nullptr };
    std::atomic<float>* waveformParam  { nullptr };
    std::atomic<float>* driveParam     { nullptr };

    // Smoothed values to prevent zipper noise
    juce::SmoothedValue<float> smoothedFrequency;
    juce::SmoothedValue<float> smoothedDrive;

    int currentWaveform = -1;
};




================================================================================
FILE: juce\Source\audio\modules\BestPracticeNodeProcessor.cpp
================================================================================


#include "BestPracticeNodeProcessor.h"

juce::AudioProcessorValueTreeState::ParameterLayout BestPracticeNodeProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdFrequency, "Frequency",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 440.0f));

    params.push_back(std::make_unique<juce::AudioParameterChoice>(
        paramIdWaveform, "Waveform",
        juce::StringArray { "Sine", "Saw", "Square" }, 0));

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdDrive, "Drive",
        juce::NormalisableRange<float>(1.0f, 50.0f, 0.01f, 0.5f), 1.0f));

    return { params.begin(), params.end() };
}

BestPracticeNodeProcessor::BestPracticeNodeProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(5), true)
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "BestPracticeParams", createParameterLayout())
{
    frequencyParam = apvts.getRawParameterValue(paramIdFrequency);
    waveformParam  = apvts.getRawParameterValue(paramIdWaveform);
    driveParam     = apvts.getRawParameterValue(paramIdDrive);

    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));

    oscillator.initialise([](float x){ return std::sin(x); }, 128);
}

void BestPracticeNodeProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 1 };
    oscillator.prepare(spec);

    smoothedFrequency.reset(sampleRate, 0.01);
    smoothedDrive.reset(sampleRate, 0.01);
}

void BestPracticeNodeProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);

    auto inBus  = getBusBuffer(buffer, true, 0);
    auto outBus = getBusBuffer(buffer, false, 0);

    const bool isFreqMod  = isParamInputConnected(paramIdFrequencyMod);
    const bool isWaveMod  = isParamInputConnected(paramIdWaveformMod);
    const bool isDriveMod = isParamInputConnected(paramIdDriveMod);

    const float* audioInL = inBus.getNumChannels() > 0 ? inBus.getReadPointer(0) : nullptr;
    const float* audioInR = inBus.getNumChannels() > 1 ? inBus.getReadPointer(1) : nullptr;
    const float* freqCV   = isFreqMod  && inBus.getNumChannels() > 2 ? inBus.getReadPointer(2) : nullptr;
    const float* waveCV   = isWaveMod  && inBus.getNumChannels() > 3 ? inBus.getReadPointer(3) : nullptr;
    const float* driveCV  = isDriveMod && inBus.getNumChannels() > 4 ? inBus.getReadPointer(4) : nullptr;

    auto* outL = outBus.getNumChannels() > 0 ? outBus.getWritePointer(0) : nullptr;
    auto* outR = outBus.getNumChannels() > 1 ? outBus.getWritePointer(1) : outL;

    const float baseFrequency = frequencyParam != nullptr ? frequencyParam->load() : 440.0f;
    const int   baseWaveform  = waveformParam  != nullptr ? (int) waveformParam->load()  : 0;
    const float baseDrive     = driveParam     != nullptr ? driveParam->load()     : 1.0f;

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        float currentFreq = baseFrequency;
        if (isFreqMod && freqCV)
        {
            const float cv = juce::jlimit(0.0f, 1.0f, freqCV[i]);
            constexpr float fMin = 20.0f;
            constexpr float fMax = 20000.0f;
            const float spanOct = std::log2(fMax / fMin);
            currentFreq = fMin * std::pow(2.0f, cv * spanOct);
        }

        int currentWave = baseWaveform;
        if (isWaveMod && waveCV)
        {
            const float cv = juce::jlimit(0.0f, 1.0f, waveCV[i]);
            currentWave = (int) (cv * 2.99f);
        }

        float currentDrive = baseDrive;
        if (isDriveMod && driveCV)
        {
            const float cv = juce::jlimit(0.0f, 1.0f, driveCV[i]);
            currentDrive = juce::jmap(cv, 1.0f, 50.0f);
        }

        smoothedFrequency.setTargetValue(currentFreq);
        smoothedDrive.setTargetValue(currentDrive);

        if (currentWaveform != currentWave)
        {
            if (currentWave == 0)      oscillator.initialise([](float x){ return std::sin(x); }, 128);
            else if (currentWave == 1) oscillator.initialise([](float x){ return (x / juce::MathConstants<float>::pi); }, 128);
            else                       oscillator.initialise([](float x){ return x < 0.0f ? -1.0f : 1.0f; }, 128);
            currentWaveform = currentWave;
        }

        oscillator.setFrequency(smoothedFrequency.getNextValue(), false);
        const float osc = oscillator.processSample(0.0f);
        const float shaped = std::tanh(osc * smoothedDrive.getNextValue());

        const float inL = audioInL ? audioInL[i] : 1.0f;
        const float inR = audioInR ? audioInR[i] : inL;

        const float outSampleL = shaped * inL;
        const float outSampleR = shaped * inR;

        if (outL) outL[i] = outSampleL;
        if (outR) outR[i] = outSampleR;

        if ((i & 0x3F) == 0)
        {
            setLiveParamValue("frequency_live", smoothedFrequency.getCurrentValue());
            setLiveParamValue("waveform_live", (float) currentWave);
            setLiveParamValue("drive_live", smoothedDrive.getCurrentValue());
        }
    }

    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(outBus.getNumChannels() > 0 ? outBus.getSample(0, buffer.getNumSamples() - 1) : 0.0f);
        if (lastOutputValues[1]) lastOutputValues[1]->store(outBus.getNumChannels() > 1 ? outBus.getSample(1, buffer.getNumSamples() - 1) : 0.0f);
    }
}

#if defined(PRESET_CREATOR_UI)
void BestPracticeNodeProcessor::drawParametersInNode (float itemWidth,
                                                      const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                                      const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();

    const bool freqIsMod = isParamModulated(paramIdFrequencyMod);
    float freq = freqIsMod ? getLiveParamValueFor(paramIdFrequencyMod, "frequency_live", frequencyParam ? frequencyParam->load() : 440.0f)
                           : (frequencyParam ? frequencyParam->load() : 440.0f);

    int wave = (int) (waveformParam ? waveformParam->load() : 0.0f);
    if (isParamModulated(paramIdWaveformMod))
        wave = (int) getLiveParamValueFor(paramIdWaveformMod, "waveform_live", (float) wave);

    const bool driveIsMod = isParamModulated(paramIdDriveMod);
    float drive = driveIsMod ? getLiveParamValueFor(paramIdDriveMod, "drive_live", driveParam ? driveParam->load() : 1.0f)
                             : (driveParam ? driveParam->load() : 1.0f);

    ImGui::PushItemWidth(itemWidth);

    if (freqIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Frequency", &freq, 20.0f, 20000.0f, "%.1f Hz", ImGuiSliderFlags_Logarithmic))
    {
        if (!freqIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdFrequency))) *p = freq;
    }
    if (!freqIsMod) adjustParamOnWheel(ap.getParameter(paramIdFrequency), "frequencyHz", freq);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (freqIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    const bool waveIsMod = isParamModulated(paramIdWaveformMod);
    if (waveIsMod) ImGui::BeginDisabled();
    if (ImGui::Combo("Waveform", &wave, "Sine\0Saw\0Square\0\0"))
    {
        if (!waveIsMod) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWaveform))) *p = wave;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (waveIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    if (driveIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Drive", &drive, 1.0f, 50.0f, "%.2f", ImGuiSliderFlags_Logarithmic))
    {
        if (!driveIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdDrive))) *p = drive;
    }
    if (!driveIsMod) adjustParamOnWheel(ap.getParameter(paramIdDrive), "drive", drive);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (driveIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    ImGui::PopItemWidth();
}

void BestPracticeNodeProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In L", 0);
    helpers.drawAudioInputPin("In R", 1);
    helpers.drawAudioInputPin("Freq Mod", 2);
    helpers.drawAudioInputPin("Wave Mod", 3);
    helpers.drawAudioInputPin("Drive Mod", 4);

    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}

juce::String BestPracticeNodeProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "In L";
        case 1: return "In R";
        case 2: return "Freq Mod";
        case 3: return "Wave Mod";
        case 4: return "Drive Mod";
        default: return {};
    }
}

juce::String BestPracticeNodeProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Out L";
        case 1: return "Out R";
        default: return {};
    }
}
#endif

bool BestPracticeNodeProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0;
    if (paramId == paramIdFrequencyMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdWaveformMod)  { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdDriveMod)     { outChannelIndexInBus = 4; return true; }
    return false;
}




================================================================================
FILE: juce\Source\audio\modules\ValueModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class ValueModuleProcessor : public ModuleProcessor
{
public:
    ValueModuleProcessor();
    ~ValueModuleProcessor() override = default;

    const juce::String getName() const override { return "value"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override {}
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // Override to explicitly state this module has no modulatable inputs
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override
    {
        // This module has no modulatable inputs - it's a source-only module.
        // Always return false to prevent undefined behavior in the modulation system.
        juce::ignoreUnused(paramId, outBusIndex, outChannelIndexInBus);
        return false;
    }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("value"));
        if (!p) return;

        float currentValue = *p;

        ImGui::PushItemWidth(itemWidth);
        // Compact draggable number field without visible label
        if (ImGui::DragFloat("##value_drag", &currentValue, 0.01f, p->range.start, p->range.end, "%.4f"))
        {
            *p = currentValue;
        }
        if (ImGui::IsItemDeactivatedAfterEdit())
        {
            onModificationEnded();
        }
        ImGui::PopItemWidth();

        // New Time-Based, Exponential Mouse Wheel Logic
        if (ImGui::IsItemHovered())
        {
            const float wheel = ImGui::GetIO().MouseWheel;
            if (wheel != 0.0f)
            {
                const double currentTime = ImGui::GetTime();
                const double timeDelta = currentTime - lastScrollTime;

                // 1. If user paused for > 0.2s, reset momentum
                if (timeDelta > 0.2)
                {
                    scrollMomentum = 1.0f;
                }

                // 2. Define the smallest step for precision
                const float baseStep = 0.01f;
                
                // 3. Calculate the final step using the momentum
                float finalStep = baseStep * scrollMomentum;

                // 4. Update the value
                float newValue = currentValue + (wheel > 0.0f ? finalStep : -finalStep);
                
                // Snap to the baseStep to keep numbers clean
                newValue = std::round(newValue / baseStep) * baseStep;

                // 5. Increase momentum for the *next* scroll event (exponential)
                // This makes continuous scrolling accelerate.
                scrollMomentum *= 1.08f;
                scrollMomentum = std::min(scrollMomentum, 2000.0f); // Cap momentum to prevent runaway

                // 6. Update the parameter and timestamp
                *p = juce::jlimit(p->range.start, p->range.end, newValue);
                lastScrollTime = currentTime;
            }
        }
        
        // CV Output Range Controls (compact layout)
        ImGui::Text("CV Out Range (0-1)");
        
        float cvMin = cvMinParam->load();
        float cvMax = cvMaxParam->load();
        
        ImGui::PushItemWidth(itemWidth * 0.45f); // Make sliders take up half the width each
        if (ImGui::SliderFloat("##cv_min", &cvMin, 0.0f, 1.0f, "Min: %.2f"))
        {
            *dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("cvMin")) = cvMin;
            onModificationEnded();
        }
        ImGui::SameLine();
        if (ImGui::SliderFloat("##cv_max", &cvMax, 0.0f, 1.0f, "Max: %.2f"))
        {
            *dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("cvMax")) = cvMax;
            onModificationEnded();
        }
        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        // Draw the five output pins for the Value module
        helpers.drawAudioOutputPin("Raw", 0);
        helpers.drawAudioOutputPin("Normalized", 1);
        helpers.drawAudioOutputPin("Inverted", 2);
        helpers.drawAudioOutputPin("Integer", 3);
        helpers.drawAudioOutputPin("CV Out", 4);
    }

    juce::String getAudioInputLabel(int channel) const override
    {
        // Value has no audio inputs
        return juce::String("In ") + juce::String(channel + 1);
    }

    juce::String getAudioOutputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "Raw";
            case 1: return "Normalized";
            case 2: return "Inverted";
            case 3: return "Integer";
            case 4: return "CV Out";
            default: return juce::String("Out ") + juce::String(channel + 1);
        }
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* valueParam { nullptr };
    std::atomic<float>* cvMinParam { nullptr };
    std::atomic<float>* cvMaxParam { nullptr };

    // Add these two state variables for the new scroll logic
    double lastScrollTime { 0.0 };
    float scrollMomentum { 1.0f };
};


================================================================================
FILE: juce\Source\audio\modules\ValueModuleProcessor.cpp
================================================================================


#include "ValueModuleProcessor.h"

ValueModuleProcessor::ValueModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withOutput("Out", juce::AudioChannelSet::discreteChannels(5), true)), // 5 outputs now (added CV Out)
      apvts(*this, nullptr, "ValueParams", createParameterLayout())
{
    valueParam = apvts.getRawParameterValue("value");
    cvMinParam = apvts.getRawParameterValue("cvMin");
    cvMaxParam = apvts.getRawParameterValue("cvMax");

    // Initialize value tooltips for all five outputs
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For the new CV Out
}

juce::AudioProcessorValueTreeState::ParameterLayout ValueModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>("value", "Value", -20000.0f, 20000.0f, 1.0f));
    
    // Add new CV range parameters
    params.push_back(std::make_unique<juce::AudioParameterFloat>("cvMin", "CV Min", 0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("cvMax", "CV Max", 0.0f, 1.0f, 1.0f));
    
    return { params.begin(), params.end() };
}

void ValueModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    buffer.clear();

    const float rawValue = valueParam->load();
    auto* param = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("value"));
    const float normalizedValue = param->getNormalisableRange().convertTo0to1(rawValue);
    
    // Calculate CV output value
    const float cvMin = cvMinParam->load();
    const float cvMax = cvMaxParam->load();
    const float cvOutputValue = juce::jmap(normalizedValue, cvMin, cvMax);

    auto* outRaw = buffer.getWritePointer(0);
    auto* outNorm = buffer.getWritePointer(1);
    auto* outInv = buffer.getWritePointer(2);
    auto* outInt = buffer.getWritePointer(3);
    auto* outCV = buffer.getWritePointer(4); // Get pointer for new output

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        outRaw[i] = rawValue;
        outNorm[i] = normalizedValue;
        outInv[i] = -rawValue;
        outInt[i] = std::round(rawValue);
        outCV[i] = cvOutputValue; // Write to the new output
    }

    // Update tooltips
    if (lastOutputValues.size() >= 5)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(outRaw[buffer.getNumSamples() - 1]);
        if (lastOutputValues[1]) lastOutputValues[1]->store(outNorm[buffer.getNumSamples() - 1]);
        if (lastOutputValues[2]) lastOutputValues[2]->store(outInv[buffer.getNumSamples() - 1]);
        if (lastOutputValues[3]) lastOutputValues[3]->store(outInt[buffer.getNumSamples() - 1]);
        if (lastOutputValues[4]) lastOutputValues[4]->store(outCV[buffer.getNumSamples() - 1]); // Update new tooltip
    }
}


================================================================================
FILE: juce\Source\audio\modules\LFOModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class LFOModuleProcessor : public ModuleProcessor
{
public:
    // Parameter ID constants
    static constexpr auto paramIdRate = "rate";
    static constexpr auto paramIdDepth = "depth";
    static constexpr auto paramIdWave = "wave";
    static constexpr auto paramIdBipolar = "bipolar";
    static constexpr auto paramIdRateMod = "rate_mod";
    static constexpr auto paramIdDepthMod = "depth_mod";
    static constexpr auto paramIdWaveMod = "wave_mod";
    static constexpr auto paramIdSync = "sync";
    static constexpr auto paramIdRateDivision = "rate_division";
    static constexpr auto paramIdRelativeMode = "relative_mode";

    LFOModuleProcessor();
    ~LFOModuleProcessor() override = default;

    const juce::String getName() const override { return "lfo"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    // Transport sync support
    void setTimingInfo(const TransportState& state) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;

    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Oscillator<float> osc;
    
    // Cached parameter pointers
    std::atomic<float>* rateParam{ nullptr };
    std::atomic<float>* depthParam{ nullptr };
    std::atomic<float>* bipolarParam{ nullptr };
    std::atomic<float>* waveParam{ nullptr };
    std::atomic<float>* syncParam{ nullptr };
    std::atomic<float>* rateDivisionParam{ nullptr };
    std::atomic<float>* relativeModeParam{ nullptr };
    
    int currentWaveform = -1;
    TransportState m_currentTransport;
};

================================================================================
FILE: juce\Source\audio\modules\LFOModuleProcessor.cpp
================================================================================


#include "LFOModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"

LFOModuleProcessor::LFOModuleProcessor()
    // CORRECTED: Use a single input bus with 3 discrete channels
    : ModuleProcessor(BusesProperties()
                        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(3), true) // ch0:Rate, ch1:Depth, ch2:Wave
                        .withOutput("Output", juce::AudioChannelSet::mono(), true)),
      apvts(*this, nullptr, "LFOParams", createParameterLayout())
{
    rateParam = apvts.getRawParameterValue(paramIdRate);
    depthParam = apvts.getRawParameterValue(paramIdDepth);
    bipolarParam = apvts.getRawParameterValue(paramIdBipolar);
    waveParam = apvts.getRawParameterValue(paramIdWave);
    syncParam = apvts.getRawParameterValue(paramIdSync);
    rateDivisionParam = apvts.getRawParameterValue(paramIdRateDivision);
    relativeModeParam = apvts.getRawParameterValue(paramIdRelativeMode);
    
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    
    osc.initialise([](float x) { return std::sin(x); }, 128);
}

juce::AudioProcessorValueTreeState::ParameterLayout LFOModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdRate, "Rate", juce::NormalisableRange<float>(0.05f, 20.0f, 0.01f, 0.3f), 1.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdDepth, "Depth", juce::NormalisableRange<float>(0.0f, 1.0f), 0.5f));
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdBipolar, "Bipolar", true));
    p.push_back(std::make_unique<juce::AudioParameterChoice>(paramIdWave, "Wave", juce::StringArray{ "Sine", "Tri", "Saw" }, 0));
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdSync, "Sync", false));
    p.push_back(std::make_unique<juce::AudioParameterChoice>(paramIdRateDivision, "Division", 
        juce::StringArray{ "1/32", "1/16", "1/8", "1/4", "1/2", "1", "2", "4", "8" }, 3)); // Default: 1/4 note
    p.push_back(std::make_unique<juce::AudioParameterBool>(paramIdRelativeMode, "Relative Mod", true)); // Default: Relative (additive) mode
    return { p.begin(), p.end() };
}

void LFOModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec{ sampleRate, (juce::uint32)samplesPerBlock, 2 };
    osc.prepare(spec);
}

void LFOModuleProcessor::setTimingInfo(const TransportState& state)
{
    m_currentTransport = state;
}

void LFOModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto out = getBusBuffer(buffer, false, 0);

    // CORRECTED: All inputs are on a single bus at index 0
    auto inBus = getBusBuffer(buffer, true, 0);
    
    // CORRECTED: Use the _mod IDs to check for connections
    const bool isRateMod = isParamInputConnected(paramIdRateMod);
    const bool isDepthMod = isParamInputConnected(paramIdDepthMod);
    const bool isWaveMod = isParamInputConnected(paramIdWaveMod);

    // CORRECTED: Read CVs from the correct channels on the single input bus
    const float* rateCV = isRateMod && inBus.getNumChannels() > 0 ? inBus.getReadPointer(0) : nullptr;
    const float* depthCV = isDepthMod && inBus.getNumChannels() > 1 ? inBus.getReadPointer(1) : nullptr;
    const float* waveCV = isWaveMod && inBus.getNumChannels() > 2 ? inBus.getReadPointer(2) : nullptr;

    const float baseRate = rateParam->load();
    const float baseDepth = depthParam->load();
    const int baseWave = static_cast<int>(waveParam->load());
    const bool bipolar = bipolarParam->load() > 0.5f;
    const bool syncEnabled = syncParam->load() > 0.5f;
    const bool relativeMode = relativeModeParam->load() > 0.5f; // NEW: Read relative mode setting
    int rateDivisionIndex = static_cast<int>(rateDivisionParam->load());
    
    // DEBUG: Log relative mode status (once per buffer)
    static int logCounter = 0;
    if (++logCounter % 100 == 0) // Log every 100th buffer to avoid spam
    {
        juce::Logger::writeToLog("[LFO] Relative Mode = " + juce::String(relativeMode ? "TRUE (additive)" : "FALSE (absolute)"));
        juce::Logger::writeToLog("[LFO] Base Rate = " + juce::String(baseRate) + " Hz, Base Depth = " + juce::String(baseDepth));
        juce::Logger::writeToLog("[LFO] Rate CV connected = " + juce::String(isRateMod ? "YES" : "NO") + 
                   ", Depth CV connected = " + juce::String(isDepthMod ? "YES" : "NO"));
    }
    // If a global division is broadcast by a master clock, adopt it when sync is enabled
    // IMPORTANT: Read from parent's LIVE transport state, not cached copy (which is stale)
    if (syncEnabled && getParent())
    {
        int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
        if (globalDiv >= 0)
            rateDivisionIndex = globalDiv;
    }

    // Rate division map: 1/32, 1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8
    static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
    const double beatDivision = divisions[juce::jlimit(0, 8, rateDivisionIndex)];

    float lastRate = baseRate, lastDepth = baseDepth;
    int lastWave = baseWave;

    for (int i = 0; i < out.getNumSamples(); ++i)
    {
        float finalRate = baseRate;
        if (isRateMod && rateCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, rateCV[i]);
            if (relativeMode) {
                // RELATIVE MODE: Modulate around the base value
                finalRate = baseRate * std::pow(4.0f, cv - 0.5f); // +/- 2 octaves from base
                
                // DEBUG: Log first sample calculation
                if (i == 0 && logCounter % 100 == 0) {
                    juce::Logger::writeToLog("[LFO Rate] RELATIVE mode: CV=" + juce::String(cv, 3) + 
                               ", baseRate=" + juce::String(baseRate, 3) + 
                               " Hz, finalRate=" + juce::String(finalRate, 3) + " Hz");
                }
            } else {
                // ABSOLUTE MODE: CV directly controls the parameter
                finalRate = juce::jmap(cv, 0.05f, 20.0f); // Full range 0.05Hz to 20Hz
                
                // DEBUG: Log first sample calculation
                if (i == 0 && logCounter % 100 == 0) {
                    juce::Logger::writeToLog("[LFO Rate] ABSOLUTE mode: CV=" + juce::String(cv, 3) + 
                               ", finalRate=" + juce::String(finalRate, 3) + " Hz (ignores slider)");
                }
            }
        }
        
        float depth = baseDepth;
        if (isDepthMod && depthCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, depthCV[i]);
            if (relativeMode) {
                // RELATIVE MODE: Add CV offset to base value
                depth = juce::jlimit(0.0f, 1.0f, baseDepth + (cv - 0.5f)); // +/- 0.5 from base
                
                // DEBUG: Log first sample calculation
                if (i == 0 && logCounter % 100 == 0) {
                    juce::Logger::writeToLog("[LFO Depth] RELATIVE mode: CV=" + juce::String(cv, 3) + 
                               ", baseDepth=" + juce::String(baseDepth, 3) + 
                               ", finalDepth=" + juce::String(depth, 3));
                }
            } else {
                // ABSOLUTE MODE: CV directly sets depth
                depth = cv;
                
                // DEBUG: Log first sample calculation
                if (i == 0 && logCounter % 100 == 0) {
                    juce::Logger::writeToLog("[LFO Depth] ABSOLUTE mode: CV=" + juce::String(cv, 3) + 
                               ", finalDepth=" + juce::String(depth, 3) + " (ignores slider)");
                }
            }
        }
        
        int w = baseWave;
        if (isWaveMod && waveCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, waveCV[i]);
            // Waveform is always absolute (discrete selection)
            w = static_cast<int>(cv * 2.99f);
        }

        lastRate = finalRate;
        lastDepth = depth;
        lastWave = w;
        
        if (currentWaveform != w) {
            if (w == 0)      osc.initialise ([](float x){ return std::sin(x); }, 128);
            else if (w == 1) osc.initialise ([](float x){ return 2.0f / juce::MathConstants<float>::pi * std::asin(std::sin(x)); }, 128);
            else             osc.initialise ([](float x){ return (x / juce::MathConstants<float>::pi); }, 128);
            currentWaveform = w;
        }
        
        float lfoSample = 0.0f;
        
        if (syncEnabled && m_currentTransport.isPlaying)
        {
            // Transport-synced mode: calculate phase directly from song position
            double phase = std::fmod(m_currentTransport.songPositionBeats * beatDivision, 1.0);
            double phaseRadians = phase * juce::MathConstants<double>::twoPi;
            
            // Generate waveform based on phase
            if (w == 0) // Sine
                lfoSample = std::sin(phaseRadians);
            else if (w == 1) // Triangle
                lfoSample = 2.0f / juce::MathConstants<float>::pi * std::asin(std::sin(phaseRadians));
            else // Saw
                lfoSample = (phaseRadians / juce::MathConstants<float>::pi);
        }
        else
        {
            // Free-running mode: use internal oscillator
            osc.setFrequency(finalRate);
            lfoSample = osc.processSample(0.0f);
        }
        
        const float finalSample = (bipolar ? lfoSample : (lfoSample * 0.5f + 0.5f)) * depth;

        out.setSample(0, i, finalSample);
    }
    
    // Update inspector values
    updateOutputTelemetry(out);

    // Store live modulated values for UI display
    setLiveParamValue("rate_live", lastRate);
    setLiveParamValue("depth_live", lastDepth);
    setLiveParamValue("wave_live", (float)lastWave);
}

// CORRECTED: Clean, unambiguous routing for a single multi-channel input bus
bool LFOModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0; // All modulation is on the single input bus.
    if (paramId == paramIdRateMod) { outChannelIndexInBus = 0; return true; }
    if (paramId == paramIdDepthMod) { outChannelIndexInBus = 1; return true; }
    if (paramId == paramIdWaveMod) { outChannelIndexInBus = 2; return true; }
    return false;
}

#if defined(PRESET_CREATOR_UI)

// Helper function for tooltip with help marker
static void HelpMarkerLFO(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

void LFOModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    
    bool isRateModulated = isParamInputConnected(paramIdRateMod);
    bool isDepthModulated = isParamInputConnected(paramIdDepthMod);
    bool isWaveModulated = isParamInputConnected(paramIdWaveMod);
    
    float rate = isRateModulated ? getLiveParamValueFor(paramIdRateMod, "rate_live", rateParam->load()) : rateParam->load();
    float depth = isDepthModulated ? getLiveParamValueFor(paramIdDepthMod, "depth_live", depthParam->load()) : depthParam->load();
    int wave = isWaveModulated ? (int)getLiveParamValueFor(paramIdWaveMod, "wave_live", (float)static_cast<int>(waveParam->load())) : static_cast<int>(waveParam->load());
    bool bipolar = bipolarParam->load() > 0.5f;
    
    ImGui::PushItemWidth(itemWidth);

    // === LFO PARAMETERS SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "LFO Parameters");
    ImGui::Spacing();

    // Rate slider with tooltip
    if (isRateModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Rate", &rate, 0.05f, 20.0f, "%.2f Hz", ImGuiSliderFlags_Logarithmic)) if (!isRateModulated) *dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdRate)) = rate;
    if (ImGui::IsItemDeactivatedAfterEdit() && !isRateModulated) onModificationEnded();
    if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerLFO("LFO rate in Hz\nLogarithmic scale from 0.05 Hz to 20 Hz");
    
    // Depth slider with tooltip
    if (isDepthModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Depth", &depth, 0.0f, 1.0f)) if (!isDepthModulated) *dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdDepth)) = depth;
    if (ImGui::IsItemDeactivatedAfterEdit() && !isDepthModulated) onModificationEnded();
    if (isDepthModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerLFO("LFO depth/amplitude (0-1)\nControls output signal strength");

    // Wave combo with tooltip
    if (isWaveModulated) ImGui::BeginDisabled();
    if (ImGui::Combo("Wave", &wave, "Sine\0Tri\0Saw\0\0")) if (!isWaveModulated) *dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWave)) = wave;
    if (ImGui::IsItemDeactivatedAfterEdit() && !isWaveModulated) onModificationEnded();
    if (isWaveModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerLFO("Waveform shape:\nSine = smooth\nTri = linear\nSaw = ramp");

    // Bipolar checkbox
    if (ImGui::Checkbox("Bipolar", &bipolar)) *dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdBipolar)) = bipolar;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    ImGui::SameLine();
    HelpMarkerLFO("Bipolar: -1 to +1\nUnipolar: 0 to +1");

    ImGui::Spacing();
    ImGui::Spacing();

    // === MODULATION MODE SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Modulation Mode");
    ImGui::Spacing();

    // Relative Mode checkbox
    bool relativeMode = relativeModeParam->load() > 0.5f;
    if (ImGui::Checkbox("Relative Modulation", &relativeMode)) 
    {
        *dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdRelativeMode)) = relativeMode;
        juce::Logger::writeToLog("[LFO UI] Relative Modulation checkbox changed to: " + juce::String(relativeMode ? "TRUE" : "FALSE"));
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    ImGui::SameLine();
    HelpMarkerLFO("Relative: CV modulates around slider position\nAbsolute: CV completely replaces slider value\n\nExample:\n- Relative: Slider at 5Hz, CV adds ±2 octaves\n- Absolute: CV directly sets 0.05-20Hz range");

    ImGui::Spacing();
    ImGui::Spacing();

    // === TRANSPORT SYNC SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Transport Sync");
    ImGui::Spacing();

    // Sync checkbox
    bool sync = syncParam->load() > 0.5f;
    if (ImGui::Checkbox("Sync to Transport", &sync)) *dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdSync)) = sync;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    ImGui::SameLine();
    HelpMarkerLFO("Sync LFO rate to host transport tempo");
    
    if (sync)
    {
        // Check if global division is active (Tempo Clock override)
        // IMPORTANT: Read from parent's LIVE transport state, not cached copy
        int globalDiv = getParent() ? getParent()->getTransportState().globalDivisionIndex.load() : -1;
        bool isGlobalDivisionActive = globalDiv >= 0;
        int division = isGlobalDivisionActive ? globalDiv : static_cast<int>(rateDivisionParam->load());
        
        const char* items[] = { "1/32", "1/16", "1/8", "1/4", "1/2", "1", "2", "4", "8" };
        
        // Grey out if controlled by Tempo Clock
        if (isGlobalDivisionActive) ImGui::BeginDisabled();
        
        if (ImGui::Combo("Division", &division, items, (int)(sizeof(items)/sizeof(items[0]))))
            if (!isGlobalDivisionActive)
                *dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdRateDivision)) = division;
        if (ImGui::IsItemDeactivatedAfterEdit() && !isGlobalDivisionActive) onModificationEnded();
        
        if (isGlobalDivisionActive)
        {
            ImGui::EndDisabled();
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
            {
                ImGui::BeginTooltip();
                ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Division Override Active");
                ImGui::TextUnformatted("A Tempo Clock node with 'Division Override' enabled is controlling the global division.");
                ImGui::PopTextWrapPos();
                ImGui::EndTooltip();
            }
        }
        else
        {
            ImGui::SameLine();
            HelpMarkerLFO("Note division for tempo sync\n1/16 = sixteenth notes, 1 = whole notes, etc.");
        }
    }

    ImGui::Spacing();
    ImGui::Spacing();

    // === LIVE OUTPUT SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Live Output");
    ImGui::Spacing();

    // Visual LFO output indicator
    float currentValue = lastOutputValues.size() > 0 ? lastOutputValues[0]->load() : 0.0f;
    ImGui::Text("Output: %.3f", currentValue);

    // Progress bar showing current LFO position
    float normalizedValue = bipolar ? (currentValue + 1.0f) / 2.0f : currentValue;
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, ImColor::HSV(0.55f, 0.7f, 0.8f).Value);
    ImGui::ProgressBar(normalizedValue, ImVec2(itemWidth, 0), "");
    ImGui::PopStyleColor();

    ImGui::PopItemWidth();
}

void LFOModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Rate Mod", 0);
    helpers.drawAudioInputPin("Depth Mod", 1);
    helpers.drawAudioInputPin("Wave Mod", 2);
    helpers.drawAudioOutputPin("Out", 0);
}

juce::String LFOModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Rate Mod";
        case 1: return "Depth Mod";
        case 2: return "Wave Mod";
        default: return {};
    }
}

juce::String LFOModuleProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Out";
        default: return {};
    }
}
#endif

================================================================================
FILE: juce\Source\audio\modules\MixerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class MixerModuleProcessor : public ModuleProcessor
{
public:
    MixerModuleProcessor();
    ~MixerModuleProcessor() override = default;

    const juce::String getName() const override { return "mixer"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    void drawIoPins(const NodePinHelpers& helpers) override;
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
#endif

    juce::String getAudioInputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "In A L";
            case 1: return "In A R";
            case 2: return "In B L";
            case 3: return "In B R";
            case 4: return "Gain Mod";
            case 5: return "Pan Mod";
            case 6: return "X-Fade Mod";
            default: return juce::String("In ") + juce::String(channel + 1);
        }
    }

    juce::String getAudioOutputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "Out L";
            case 1: return "Out R";
            default: return juce::String("Out ") + juce::String(channel + 1);
        }
    }
    
    // Parameter bus contract implementation

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* gainParam { nullptr };       // dB
    std::atomic<float>* panParam { nullptr };        // -1..1
    std::atomic<float>* crossfadeParam { nullptr };  // <<< ADD THIS LINE
};

================================================================================
FILE: juce\Source\audio\modules\MixerModuleProcessor.cpp
================================================================================


#include "MixerModuleProcessor.h"

// Corrected constructor with two separate stereo inputs
MixerModuleProcessor::MixerModuleProcessor()
    : ModuleProcessor (BusesProperties()
        .withInput ("In A", juce::AudioChannelSet::stereo(), true)  // Bus 0
        .withInput ("In B", juce::AudioChannelSet::stereo(), true)  // Bus 1
        .withInput ("Gain Mod", juce::AudioChannelSet::mono(), true)
        .withInput ("Pan Mod", juce::AudioChannelSet::mono(), true)
        .withInput ("X-Fade Mod", juce::AudioChannelSet::mono(), true)
        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "MixerParams", createParameterLayout())
{
    gainParam      = apvts.getRawParameterValue ("gain");
    panParam       = apvts.getRawParameterValue ("pan");
    crossfadeParam = apvts.getRawParameterValue ("crossfade"); // Get the new parameter

    // Initialize value tooltips for the stereo output
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

// Updated parameter layout with the new crossfade slider
juce::AudioProcessorValueTreeState::ParameterLayout MixerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("gain", "Gain", juce::NormalisableRange<float> (-60.0f, 6.0f, 0.01f), 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("pan",  "Pan",  juce::NormalisableRange<float> (-1.0f, 1.0f), 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("crossfade",  "Crossfade",  juce::NormalisableRange<float> (-1.0f, 1.0f), 0.0f)); // A <-> B
    return { p.begin(), p.end() };
}

void MixerModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

// Completely rewritten processBlock for crossfading
void MixerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    
    auto inA = getBusBuffer(buffer, true, 0);
    auto inB = getBusBuffer(buffer, true, 1);
    auto out = getBusBuffer(buffer, false, 0);

    const int numSamples = buffer.getNumSamples();
    const int numChannels = out.getNumChannels();

    // Read CV from input buses (if connected)
    float gainModCV = 0.0f;
    float panModCV = 0.0f;
    float crossfadeModCV = 0.0f;
    
    // Check if gain mod bus is connected and read CV
    if (isParamInputConnected("gain"))
    {
        const auto& gainModBus = getBusBuffer(buffer, true, 2);
        if (gainModBus.getNumChannels() > 0)
            gainModCV = gainModBus.getReadPointer(0)[0]; // Read first sample
    }
    
    // Check if pan mod bus is connected and read CV
    if (isParamInputConnected("pan"))
    {
        const auto& panModBus = getBusBuffer(buffer, true, 3);
        if (panModBus.getNumChannels() > 0)
            panModCV = panModBus.getReadPointer(0)[0]; // Read first sample
    }
    
    // Check if crossfade mod bus is connected and read CV
    if (isParamInputConnected("x-fade"))
    {
        const auto& crossfadeModBus = getBusBuffer(buffer, true, 4);
        if (crossfadeModBus.getNumChannels() > 0)
            crossfadeModCV = crossfadeModBus.getReadPointer(0)[0]; // Read first sample
    }

    // Apply modulation or use parameter values
    float crossfade = 0.0f;
    if (isParamInputConnected("x-fade"))
    {
        // Map CV [0,1] to crossfade [-1, 1]
        crossfade = -1.0f + crossfadeModCV * (1.0f - (-1.0f));
    }
    else
    {
        crossfade = crossfadeParam != nullptr ? crossfadeParam->load() : 0.0f;
    }

    // Use a constant power law for a smooth crossfade without volume dips
    const float mixAngle = (crossfade * 0.5f + 0.5f) * juce::MathConstants<float>::halfPi;
    const float gainA = std::cos(mixAngle);
    const float gainB = std::sin(mixAngle);

    // Perform the crossfade into the output buffer
    for (int ch = 0; ch < numChannels; ++ch)
    {
        const float* srcA = (ch < inA.getNumChannels()) ? inA.getReadPointer(ch) : nullptr;
        const float* srcB = (ch < inB.getNumChannels()) ? inB.getReadPointer(ch) : nullptr;
        float* dst = out.getWritePointer(ch);
        
        for (int i = 0; i < numSamples; ++i)
        {
            const float a = srcA ? srcA[i] : 0.0f;
            const float b = srcB ? srcB[i] : 0.0f;
            dst[i] = a * gainA + b * gainB;
        }
    }

    // Now, apply the master gain and pan to the mixed signal in the output buffer
    float masterGain = 0.0f;
    if (isParamInputConnected("gain"))
    {
        // Map CV [0,1] to gain [-60, 6] dB
        float gainDb = -60.0f + gainModCV * (6.0f - (-60.0f));
        masterGain = juce::Decibels::decibelsToGain(gainDb);
    }
    else
    {
        masterGain = juce::Decibels::decibelsToGain(gainParam != nullptr ? gainParam->load() : 0.0f);
    }
    
    float pan = 0.0f;
    if (isParamInputConnected("pan"))
    {
        // Map CV [0,1] to pan [-1, 1]
        pan = -1.0f + panModCV * (1.0f - (-1.0f));
    }
    else
    {
        pan = panParam != nullptr ? panParam->load() : 0.0f;
    }
    const float panAngleMaster = (pan * 0.5f + 0.5f) * juce::MathConstants<float>::halfPi;
    const float lGain = masterGain * std::cos(panAngleMaster);
    const float rGain = masterGain * std::sin(panAngleMaster);

    out.applyGain(0, 0, numSamples, lGain);
    if (numChannels > 1)
        out.applyGain(1, 0, numSamples, rGain);

    // Store live modulated values for UI display
    setLiveParamValue("crossfade_live", crossfade);
    setLiveParamValue("gain_live", isParamInputConnected("gain") ? (-60.0f + gainModCV * 66.0f) : (gainParam != nullptr ? gainParam->load() : 0.0f));
    setLiveParamValue("pan_live", pan);

    // Update tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(out.getSample(0, numSamples - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(out.getSample(1, numSamples - 1));
    }
}

// Updated UI drawing code
#if defined(PRESET_CREATOR_UI)
void MixerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    
    // Helper for tooltips
    auto HelpMarkerMixer = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };
    
    float gainDb = gainParam != nullptr ? gainParam->load() : 0.0f;
    float pan = panParam != nullptr ? panParam->load() : 0.0f;
    float crossfade = crossfadeParam != nullptr ? crossfadeParam->load() : 0.0f;

    ImGui::PushItemWidth(itemWidth);

    // === CROSSFADE SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Crossfade");
    ImGui::Spacing();

    // Crossfade Slider
    bool isXfModulated = isParamModulated("x-fade");
    if (isXfModulated) {
        crossfade = getLiveParamValueFor("x-fade", "crossfade_live", crossfade);
        ImGui::BeginDisabled();
    }
    if (ImGui::SliderFloat("A <-> B", &crossfade, -1.0f, 1.0f)) if (!isXfModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("crossfade"))) *p = crossfade;
    if (!isXfModulated) adjustParamOnWheel(ap.getParameter("crossfade"), "crossfade", crossfade);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isXfModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerMixer("Crossfade between inputs A and B\n-1 = A only, 0 = equal mix, +1 = B only");

    // Visual crossfade indicator
    float aLevel = (1.0f - crossfade) / 2.0f;
    float bLevel = (1.0f + crossfade) / 2.0f;
    ImGui::Text("A: %.1f%%", aLevel * 100.0f);
    ImGui::SameLine(itemWidth * 0.5f);
    ImGui::Text("B: %.1f%%", bLevel * 100.0f);

    ImGui::Spacing();
    ImGui::Spacing();

    // === MASTER CONTROLS SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Master Controls");
    ImGui::Spacing();

    // Gain Slider
    bool isGainModulated = isParamModulated("gain");
    if (isGainModulated) {
        gainDb = getLiveParamValueFor("gain", "gain_live", gainDb);
        ImGui::BeginDisabled();
    }
    if (ImGui::SliderFloat("Gain dB", &gainDb, -60.0f, 6.0f)) if (!isGainModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("gain"))) *p = gainDb;
    if (!isGainModulated) adjustParamOnWheel(ap.getParameter("gain"), "gainDb", gainDb);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isGainModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerMixer("Master output gain (-60 to +6 dB)");

    // Pan Slider
    bool isPanModulated = isParamModulated("pan");
    if (isPanModulated) {
        pan = getLiveParamValueFor("pan", "pan_live", pan);
        ImGui::BeginDisabled();
    }
    if (ImGui::SliderFloat("Pan", &pan, -1.0f, 1.0f)) if (!isPanModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("pan"))) *p = pan;
    if (!isPanModulated) adjustParamOnWheel(ap.getParameter("pan"), "pan", pan);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isPanModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerMixer("Stereo panning\n-1 = full left, 0 = center, +1 = full right");

    // Visual pan indicator
    const char* panLabel = (pan < -0.3f) ? "L" : (pan > 0.3f) ? "R" : "C";
    ImGui::Text("Position: %s (%.2f)", panLabel, pan);

    ImGui::PopItemWidth();
}
#endif

void MixerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In A L", 0);
    helpers.drawAudioInputPin("In A R", 1);
    helpers.drawAudioInputPin("In B L", 2);
    helpers.drawAudioInputPin("In B R", 3);

    int busIdx, chanInBus;
    if (getParamRouting("gain", busIdx, chanInBus))
        helpers.drawAudioInputPin("Gain Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    if (getParamRouting("pan", busIdx, chanInBus))
        helpers.drawAudioInputPin("Pan Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));
    if (getParamRouting("crossfade", busIdx, chanInBus))
        helpers.drawAudioInputPin("X-Fade Mod", getChannelIndexInProcessBlockBuffer(true, busIdx, chanInBus));

    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}

bool MixerModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outChannelIndexInBus = 0;
    if (paramId == "gain")      { outBusIndex = 2; return true; }
    if (paramId == "pan")       { outBusIndex = 3; return true; }
    if (paramId == "crossfade" || paramId == "x-fade") { outBusIndex = 4; return true; }
    return false;
}

================================================================================
FILE: juce\Source\audio\modules\TimePitchModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_core/juce_core.h>
#include <juce_dsp/juce_dsp.h>
#include "../dsp/TimePitchProcessor.h"

class TimePitchModuleProcessor : public ModuleProcessor
{
public:
    // Parameter IDs
    static constexpr const char* paramIdSpeed     = "speed";
    static constexpr const char* paramIdPitch     = "pitch";
    static constexpr const char* paramIdEngine    = "engine";
    static constexpr const char* paramIdSpeedMod  = "speed_mod";
    static constexpr const char* paramIdPitchMod  = "pitch_mod";

    TimePitchModuleProcessor();
    ~TimePitchModuleProcessor() override = default;

    const juce::String getName() const override { return "timepitch"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    juce::String getAudioInputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "In L";
            case 1: return "In R";
            case 2: return "Speed Mod";
            case 3: return "Pitch Mod";
            default: return juce::String("In ") + juce::String(channel + 1);
        }
    }
    
    // Parameter bus contract implementation
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    
    std::vector<DynamicPinInfo> getDynamicInputPins() const override;
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth,
                               const std::function<bool(const juce::String& paramId)>& isParamModulated,
                               const std::function<void()>& onModificationEnded) override;
    void drawIoPins (const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;

    TimePitchProcessor timePitch;
    juce::HeapBlock<float> interleavedInput;
    juce::HeapBlock<float> interleavedOutput;
    int interleavedCapacityFrames { 0 };

    // Parameter pointers
    std::atomic<float>* speedParam { nullptr };
    std::atomic<float>* pitchParam { nullptr };
    std::atomic<float>* speedModParam { nullptr };
    std::atomic<float>* pitchModParam { nullptr };
    juce::AudioParameterChoice* engineParam { nullptr };
    double sr { 48000.0 };

    // --- Streaming FIFO for live input buffering ---
    juce::AudioBuffer<float> inputFifo; // stereo FIFO storage
    juce::AbstractFifo abstractFifo { 0 }; // manages read/write indices
    int fifoSize { 0 };
    
    // Smoothed parameters for zipper-free modulation
    juce::SmoothedValue<float> speedSm;
    juce::SmoothedValue<float> pitchSm;
};




================================================================================
FILE: juce\Source\audio\modules\TimePitchModuleProcessor.cpp
================================================================================


#include "TimePitchModuleProcessor.h"

static inline void ensureCapacity (juce::HeapBlock<float>& block, int frames, int channels, int& capacityFrames)
{
    if (frames > capacityFrames)
    {
        capacityFrames = juce::jmax (frames, capacityFrames * 2 + 128);
        block.allocate ((size_t) (capacityFrames * channels), true);
    }
}

juce::AudioProcessorValueTreeState::ParameterLayout TimePitchModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdSpeed, "Speed", juce::NormalisableRange<float> (0.25f, 4.0f, 0.0001f, 0.5f), 1.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdPitch, "Pitch (st)", juce::NormalisableRange<float> (-24.0f, 24.0f, 0.01f), 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterChoice> (paramIdEngine, "Engine", juce::StringArray { "RubberBand", "Naive" }, 0));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdSpeedMod, "Speed Mod", juce::NormalisableRange<float> (0.25f, 4.0f, 0.0001f, 0.5f), 1.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdPitchMod, "Pitch Mod", juce::NormalisableRange<float> (-24.0f, 24.0f, 0.01f), 0.0f));
    return { p.begin(), p.end() };
}

TimePitchModuleProcessor::TimePitchModuleProcessor()
    : ModuleProcessor (BusesProperties()
        .withInput ("Inputs", juce::AudioChannelSet::discreteChannels(4), true) // ch0 L in, ch1 R in, ch2 Speed Mod, ch3 Pitch Mod
        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "TimePitchParams", createParameterLayout())
{
    speedParam     = apvts.getRawParameterValue (paramIdSpeed);
    pitchParam     = apvts.getRawParameterValue (paramIdPitch);
    speedModParam  = apvts.getRawParameterValue (paramIdSpeedMod);
    pitchModParam  = apvts.getRawParameterValue (paramIdPitchMod);
    engineParam    = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter (paramIdEngine));

    lastOutputValues.clear();
    lastOutputValues.push_back (std::make_unique<std::atomic<float>> (0.0f));
    lastOutputValues.push_back (std::make_unique<std::atomic<float>> (0.0f));
    
    // Initialize smoothed values
    speedSm.reset(1.0f);
    pitchSm.reset(0.0f);
}

void TimePitchModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    sr = sampleRate;
    timePitch.prepare (sampleRate, 2, samplesPerBlock);

    // Initialize FIFO to ~2 seconds of audio
    fifoSize = (int) (sampleRate * 2.0);
    if (fifoSize < samplesPerBlock * 4) fifoSize = samplesPerBlock * 4; // safety minimum
    inputFifo.setSize (2, fifoSize);
    abstractFifo.setTotalSize (fifoSize);

    interleavedCapacityFrames = 0;
    ensureCapacity (interleavedInput, samplesPerBlock, 2, interleavedCapacityFrames);
    ensureCapacity (interleavedOutput, samplesPerBlock * 2, 2, interleavedCapacityFrames); // some headroom
    timePitch.reset();
}

void TimePitchModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    auto inBus = getBusBuffer(buffer, true, 0);  // Single bus
    auto outBus = getBusBuffer(buffer, false, 0);
    
    const int numSamples = buffer.getNumSamples();
    if (numSamples <= 0) return;

    // 1) Write incoming audio into FIFO (use inBus explicitly)
    int start1=0,size1=0,start2=0,size2=0;
    abstractFifo.prepareToWrite (numSamples, start1, size1, start2, size2);
    if (size1 > 0)
    {
        inputFifo.copyFrom (0, start1, inBus, 0, 0, size1);
        inputFifo.copyFrom (1, start1, inBus, 1, 0, size1);
    }
    if (size2 > 0)
    {
        inputFifo.copyFrom (0, start2, inBus, 0, size1, size2);
        inputFifo.copyFrom (1, start2, inBus, 1, size1, size2);
    }
    const int written = size1 + size2;
    abstractFifo.finishedWrite (written);

    // 2) Read params and configure engine
    const int engineIdx = engineParam != nullptr ? engineParam->getIndex() : 0;
    {
        static int currentMode = -1;
        const int requestedMode = (engineIdx == 0 ? (int) TimePitchProcessor::Mode::RubberBand : (int) TimePitchProcessor::Mode::Fifo);
        if (requestedMode != currentMode)
        {
            timePitch.reset();
            currentMode = requestedMode;
        }
        timePitch.setMode ((TimePitchProcessor::Mode) requestedMode);
    }

    // Get pointers to modulation CV inputs
    const bool isSpeedMod = isParamInputConnected("speed");
    const bool isPitchMod = isParamInputConnected("pitch");
    
    const float* speedCV = isSpeedMod && inBus.getNumChannels() > 2 ? inBus.getReadPointer(2) : nullptr;
    const float* pitchCV = isPitchMod && inBus.getNumChannels() > 3 ? inBus.getReadPointer(3) : nullptr;
    
    // Process in slices to reduce engine reconfig cost
    const int sliceSize = 32;
    for (int sliceStart = 0; sliceStart < numSamples; sliceStart += sliceSize)
    {
        const int sliceEnd = juce::jmin(sliceStart + sliceSize, numSamples);
        const int sliceSamples = sliceEnd - sliceStart;
        
        // Calculate target values from CV (use middle of slice)
        const int midSample = sliceStart + sliceSamples / 2;
        
        float targetSpeed = speedParam->load();
        if (isSpeedMod && speedCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, speedCV[midSample]);
            const float minSpeed = 0.25f;
            const float maxSpeed = 4.0f;
            targetSpeed = minSpeed * std::pow(maxSpeed / minSpeed, cv);
        }
        
        float targetPitch = pitchParam->load();
        if (isPitchMod && pitchCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, pitchCV[midSample]);
            targetPitch = -24.0f + cv * 48.0f; // -24 to +24 semitones
        }
        
        // Set targets and advance smoothing
        speedSm.setTargetValue(juce::jlimit(0.1f, 4.0f, targetSpeed));
        pitchSm.setTargetValue(juce::jlimit(-24.0f, 24.0f, targetPitch));
        
        // Update telemetry for live UI feedback (once per slice)
        setLiveParamValue("speed_live", speedSm.getCurrentValue());
        setLiveParamValue("pitch_live", pitchSm.getCurrentValue());
        
        // Advance smoothing for this slice
        for (int i = 0; i < sliceSamples; ++i) {
            speedSm.skip(1);
            pitchSm.skip(1);
        }
        
        // Configure engine with current smoothed values
        timePitch.setTimeStretchRatio(speedSm.getCurrentValue());
        timePitch.setPitchSemitones(pitchSm.getCurrentValue());
        
        // Publish telemetry
        setLiveParamValue("speed", speedSm.getCurrentValue());
        setLiveParamValue("pitch", pitchSm.getCurrentValue());
    }

    // 3) Compute frames needed to fill this block
    const double safeSpeed = juce::jlimit (0.1, 4.0, (double) speedSm.getCurrentValue());
    const int framesToFeed = juce::jmax (1, (int) std::ceil ((double) numSamples / safeSpeed));

    outBus.clear();
    if (abstractFifo.getNumReady() >= framesToFeed)
    {
        // 4) Read from FIFO and interleave
        ensureCapacity (interleavedInput, framesToFeed, 2, interleavedCapacityFrames);
        abstractFifo.prepareToRead (framesToFeed, start1, size1, start2, size2);
        auto* inL = inputFifo.getReadPointer (0);
        auto* inR = inputFifo.getReadPointer (1);
        float* inLR = interleavedInput.getData();
        for (int i = 0; i < size1; ++i) { inLR[2*i+0] = inL[start1 + i]; inLR[2*i+1] = inR[start1 + i]; }
        if (size2 > 0)
            for (int i = 0; i < size2; ++i) { inLR[2*(size1+i)+0] = inL[start2 + i]; inLR[2*(size1+i)+1] = inR[start2 + i]; }
        const int readCount = size1 + size2;
        abstractFifo.finishedRead (readCount);

        // 5) Process and copy back
        // Guard against engine internal errors with try/catch (non-RT critical path)
        try { timePitch.putInterleaved (inLR, framesToFeed); }
        catch (...) { /* swallow to avoid crash; output will be silence */ }
        ensureCapacity (interleavedOutput, numSamples, 2, interleavedCapacityFrames);
        int produced = 0;
        try { produced = timePitch.receiveInterleaved (interleavedOutput.getData(), numSamples); }
        catch (...) { produced = 0; }
        if (produced > 0)
        {
            const int outFrames = juce::jmin (numSamples, produced);
            const float* outLR = interleavedOutput.getData();
            float* L = outBus.getNumChannels() > 0 ? outBus.getWritePointer (0) : buffer.getWritePointer(0);
            float* R = outBus.getNumChannels() > 1 ? outBus.getWritePointer (1) : L;
            for (int i = 0; i < outFrames; ++i) { L[i] = outLR[2*i+0]; if (R) R[i] = outLR[2*i+1]; }
        }
    }

    // Update lastOutputValues
    if (lastOutputValues.size() >= 2)
    {
        lastOutputValues[0]->store (buffer.getMagnitude (0, 0, numSamples));
        lastOutputValues[1]->store (buffer.getNumChannels() > 1 ? buffer.getMagnitude (1, 0, numSamples) : 0.0f);
    }
}

// Parameter bus contract implementation
bool TimePitchModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0;
    if (paramId == "speed") { outChannelIndexInBus = 2; return true; }  // Speed Mod
    if (paramId == "pitch") { outChannelIndexInBus = 3; return true; }  // Pitch Mod
    return false;
}

#if defined(PRESET_CREATOR_UI)
void TimePitchModuleProcessor::drawParametersInNode (float itemWidth,
                                                    const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                                    const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth (itemWidth);
    auto& ap = getAPVTS();

    // Speed
    bool spMod = isParamModulated ("speed");
    if (spMod) { 
        ImGui::BeginDisabled(); 
        ImGui::PushStyleColor (ImGuiCol_FrameBg, ImVec4 (1,1,0,0.3f)); 
    }
    float speed = ap.getRawParameterValue (paramIdSpeed)->load();
    if (spMod) {
        speed = getLiveParamValueFor("speed", "speed_live", speed);
    }
    if (ImGui::SliderFloat ("Speed", &speed, 0.25f, 4.0f, "%.2fx")) {
        if (!spMod) {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter (paramIdSpeed))) *p = speed;
        }
    }
    if (!spMod) adjustParamOnWheel (ap.getParameter (paramIdSpeed), paramIdSpeed, speed);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (spMod) { ImGui::PopStyleColor(); ImGui::EndDisabled(); }

    // Pitch
    bool piMod = isParamModulated ("pitch");
    if (piMod) { 
        ImGui::BeginDisabled(); 
        ImGui::PushStyleColor (ImGuiCol_FrameBg, ImVec4 (1,1,0,0.3f)); 
    }
    float pitch = ap.getRawParameterValue (paramIdPitch)->load();
    if (piMod) {
        pitch = getLiveParamValueFor("pitch", "pitch_live", pitch);
    }
    if (ImGui::SliderFloat ("Pitch", &pitch, -24.0f, 24.0f, "%.1f st"))
        if (!piMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter (paramIdPitch))) *p = pitch;
    if (!piMod) adjustParamOnWheel (ap.getParameter (paramIdPitch), paramIdPitch, pitch);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (piMod) { ImGui::PopStyleColor(); ImGui::EndDisabled(); }

    // Engine
    int engineIdx = engineParam != nullptr ? engineParam->getIndex() : 0;
    const char* items[] = { "RubberBand", "Naive" };
    if (ImGui::Combo ("Engine", &engineIdx, items, 2))
        if (engineParam) *engineParam = engineIdx;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();

    ImGui::PopItemWidth();
}

void TimePitchModuleProcessor::drawIoPins (const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin ("In L", 0);
    helpers.drawAudioInputPin ("In R", 1);
    helpers.drawAudioInputPin ("Speed Mod", 2);
    helpers.drawAudioInputPin ("Pitch Mod", 3);

    helpers.drawAudioOutputPin ("Out L", 0);
    helpers.drawAudioOutputPin ("Out R", 1);
}
#endif

std::vector<DynamicPinInfo> TimePitchModuleProcessor::getDynamicInputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Audio inputs (channels 0-1)
    pins.push_back({"In L", 0, PinDataType::Audio});
    pins.push_back({"In R", 1, PinDataType::Audio});
    
    // Modulation inputs (channels 2-3)
    pins.push_back({"Speed Mod", 2, PinDataType::CV});
    pins.push_back({"Pitch Mod", 3, PinDataType::CV});
    
    return pins;
}

std::vector<DynamicPinInfo> TimePitchModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Audio outputs (channels 0-1)
    pins.push_back({"Out L", 0, PinDataType::Audio});
    pins.push_back({"Out R", 1, PinDataType::Audio});
    
    return pins;
}




================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class StepSequencerModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_STEPS = 16;
    StepSequencerModuleProcessor();
    ~StepSequencerModuleProcessor() override = default;

    const juce::String getName() const override { return "sequencer"; }

    void prepareToPlay (double newSampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // State management for transport settings
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree&) override;

    // Pin label overrides
    juce::String getAudioOutputLabel(int channel) const override;
    juce::String getAudioInputLabel(int channel) const override;
    
    // Parameter bus contract implementation
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    void setTimingInfo(const TransportState& state) override;

    juce::AudioProcessorValueTreeState apvts;

    std::atomic<int> currentStep { 0 };
    double phase { 0.0 };
    double sampleRate { 44100.0 };

    TransportState m_currentTransport;
    bool wasPlaying = false;

    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* gateLengthParam { nullptr };
    std::atomic<float>* gateThresholdParam { nullptr };
    std::atomic<float>* rateModParam { nullptr };
    std::atomic<float>* gateLengthModParam { nullptr };
    std::atomic<float>* numStepsModParam { nullptr };
    std::atomic<float>* stepsModMaxParam { nullptr };
    std::vector<std::atomic<float>*> pitchParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepModParams; // size MAX_STEPS
    // Per-step trigger base (checkbox) and modulation
    std::vector<juce::AudioParameterBool*> stepTrigParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepTrigModParams;    // size MAX_STEPS (0..1)
    // Per-step gate level parameters
    std::vector<std::atomic<float>*> stepGateParams;       // size MAX_STEPS (0..1)
    std::atomic<float>* numStepsParam { nullptr };

    // Pulse generator state for Trigger Out
    int pendingTriggerSamples { 0 };
    
    // Gate fade-in state
    bool previousGateOn { false };
    float gateFadeProgress { 0.0f };
    static constexpr float GATE_FADE_TIME_MS = 5.0f; // 5ms fade-in time
};

// Pin label overrides
inline juce::String StepSequencerModuleProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Pitch";
        case 1: return "Gate";
        case 2: return "Gate Nuanced";
        case 3: return "Velocity";
        case 4: return "Mod";
        case 5: return "Trigger";
        default: return juce::String("Out ") + juce::String(channel + 1);
    }
}

inline juce::String StepSequencerModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Mod In L";
        case 1: return "Mod In R";
        case 2: return "Rate Mod";
        case 3: return "Gate Mod";
        case 4: return "Steps Mod";
        default: return juce::String("In ") + juce::String(channel + 1);
    }
}




================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.cpp
================================================================================


#include "StepSequencerModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <iostream>
#include <array>

using APVTS = juce::AudioProcessorValueTreeState;

static juce::NormalisableRange<float> makeRateRange()
{
    // FIX: Change the interval from 0.0f to a small, non-zero value like 0.01f.
    juce::NormalisableRange<float> r (0.1f, 20.0f, 0.01f, 0.5f); // semi-log response
    return r;
}

APVTS::ParameterLayout StepSequencerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps", "Number of Steps", 1, StepSequencerModuleProcessor::MAX_STEPS, 8));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate", "Rate", makeRateRange(), 2.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength", "Gate Length", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    // Threshold to generate gate when step value >= threshold
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateThreshold", "Gate Threshold", juce::NormalisableRange<float> (0.0f, 1.0f, 0.001f), 0.5f));
    
    // Add modulation parameters for rate, gate length and number of steps (absolute 0..1)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate_mod", "Rate Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength_mod", "Gate Length Mod", 0.0f, 1.0f, 0.5f));
    // Neutral default at 0.5 means "no override" (we'll treat values ~0.5 as disconnected)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("numSteps_mod", "Num Steps Mod", 0.0f, 1.0f, 0.5f));
    // Optional maximum steps bound (1..MAX_STEPS), default MAX_STEPS
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps_max", "Num Steps Max", 1, StepSequencerModuleProcessor::MAX_STEPS, StepSequencerModuleProcessor::MAX_STEPS));
    
    // Transport sync parameters
    params.push_back(std::make_unique<juce::AudioParameterBool>("sync", "Sync to Transport", false));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("rate_division", "Division", 
        juce::StringArray{ "1/32", "1/16", "1/8", "1/4", "1/2", "1", "2", "4", "8" }, 3)); // Default: 1/4 note
    
    for (int i = 0; i < StepSequencerModuleProcessor::MAX_STEPS; ++i)
    {
        const juce::String pid = "step" + juce::String (i + 1);
        params.push_back (std::make_unique<juce::AudioParameterFloat> (pid, pid, juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));

        // ADD THIS: A new parameter for this step's modulation input
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        // Default 0.5 => no offset (unipolar 0..1 centered to bipolar -0.5..+0.5)
        params.push_back(std::make_unique<juce::AudioParameterFloat>(modPid, modPid, 0.0f, 1.0f, 0.5f));

        // NEW: per-step Trigger checkbox and its modulation (absolute 0..1)
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        params.push_back(std::make_unique<juce::AudioParameterBool>(trigPid, trigPid, false));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(trigModPid, trigModPid, 0.0f, 1.0f, 0.5f));

        // NEW: per-step Gate Level parameters
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gatePid, gatePid, 0.0f, 1.0f, 0.8f));
        const juce::String gateModPid = "step" + juce::String(i + 1) + "_gate_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gateModPid, gateModPid, 0.0f, 1.0f, 0.5f));
    }
    return { params.begin(), params.end() };
}

StepSequencerModuleProcessor::StepSequencerModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        // ARCHITECTURAL FIX: Single large bus for all inputs:
                        // 2 (Audio) + 4 (Global Mods: rate, gate, steps, stepsMax) + 16 (Step Mods) + 16 (Trig Mods) + 16 (Gate Mods) = 54 channels
                        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(2 + 4 + (MAX_STEPS * 3)), true)
                        // expand to 5 outputs (Pitch, Gate, Velocity, Mod, Trigger)
                        .withOutput ("CV Outputs", juce::AudioChannelSet::discreteChannels(6), true))
    , apvts (*this, nullptr, "SeqParams", createParameterLayout())
{
    // ADD THIS VERIFICATION LOGIC
    std::cout << "--- StepSequencerModuleProcessor Initializing ---" << std::endl;
    
    numStepsParam   = apvts.getRawParameterValue ("numSteps");
    rateParam       = apvts.getRawParameterValue ("rate");
    gateLengthParam = apvts.getRawParameterValue ("gateLength");
    gateThresholdParam = apvts.getRawParameterValue ("gateThreshold");
    rateModParam    = apvts.getRawParameterValue ("rate_mod");
    gateLengthModParam = apvts.getRawParameterValue ("gateLength_mod");
    numStepsModParam = apvts.getRawParameterValue ("numSteps_mod");
    stepsModMaxParam = apvts.getRawParameterValue ("numSteps_max");
    
    if (numStepsParam == nullptr) std::cout << "ERROR: 'numSteps' parameter is NULL!" << std::endl;
    if (rateParam == nullptr) std::cout << "ERROR: 'rate' parameter is NULL!" << std::endl;
    if (gateLengthParam == nullptr) std::cout << "ERROR: 'gateLength' parameter is NULL!" << std::endl;

    pitchParams.resize (MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        pitchParams[i] = apvts.getRawParameterValue ("step" + juce::String (i + 1));
        if (pitchParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "' parameter is NULL!" << std::endl;
        }
    }

    // Initialize stepModParams
    stepModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        stepModParams[i] = apvts.getRawParameterValue(modPid);
        if (stepModParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "_mod' parameter is NULL!" << std::endl;
        }
    }
    std::cout << "--- Initialization Check Complete ---" << std::endl;
    
    // Initialize output value tracking for tooltips (6 outputs: Pitch, Gate, Gate Nuanced, Velocity, Mod, Trigger)
    for (int i = 0; i < 6; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));

    // Cache pointers for per-step trigger params
    stepTrigParams.resize(MAX_STEPS);
    stepTrigModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        stepTrigParams[i] = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(trigPid));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        stepTrigModParams[i] = apvts.getRawParameterValue(trigModPid);
    }

    // Initialize gate parameter pointers
    stepGateParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        stepGateParams[i] = apvts.getRawParameterValue(gatePid);
    }
}

void StepSequencerModuleProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sampleRate = newSampleRate > 0.0 ? newSampleRate : 44100.0;
    phase = 0.0;
}

void StepSequencerModuleProcessor::setTimingInfo(const TransportState& state)
{
    // Check if the transport has just started playing
    if (state.isPlaying && !wasPlaying)
    {
        // Reset to the beginning when play is pressed
        currentStep.store(0);
        phase = 0.0;
    }
    wasPlaying = state.isPlaying;
    
    m_currentTransport = state;
}

juce::ValueTree StepSequencerModuleProcessor::getExtraStateTree() const
{
    juce::ValueTree vt("SequencerState");
    vt.setProperty("sync", apvts.getRawParameterValue("sync")->load(), nullptr);
    vt.setProperty("rate_division", apvts.getRawParameterValue("rate_division")->load(), nullptr);
    return vt;
}

void StepSequencerModuleProcessor::setExtraStateTree(const juce::ValueTree& vt)
{
    if (vt.hasType("SequencerState"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync")))
            *p = (bool)vt.getProperty("sync", false);
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division")))
            *p = (int)vt.getProperty("rate_division", 3);
    }
}

void StepSequencerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    if (rateParam == nullptr || numStepsParam == nullptr || gateLengthParam == nullptr)
    {
        buffer.clear();
        return;
    }

    const int numSamples = buffer.getNumSamples();
    
    // ARCHITECTURAL FIX: Read CV from single input bus
    const auto& inputBus = getBusBuffer(buffer, true, 0); // All inputs are now on bus 0
    
    // Get pointers to global modulation CV inputs, if they are connected
    const bool isRateMod = isParamInputConnected("rate_mod");
    const bool isGateLenMod = isParamInputConnected("gateLength_mod");
    const bool isStepsMod = isParamInputConnected("numSteps_mod");
    
    // Absolute channel map on single input bus:
    // 0=L,1=R, 2=rate, 3=gateLen, 4=steps, 5=stepsMax,
    // 6..21: step1..step16 value mods, 22..37: step1..step16 trig mods, 38..53: step1..step16 gate mods
    const float* rateCV = isRateMod && inputBus.getNumChannels() > 2 ? inputBus.getReadPointer(2) : nullptr;
    const float* gateLenCV = isGateLenMod && inputBus.getNumChannels() > 3 ? inputBus.getReadPointer(3) : nullptr;
    const float* stepsCV = isStepsMod && inputBus.getNumChannels() > 4 ? inputBus.getReadPointer(4) : nullptr;
    
    // Get write pointers for all 6 output channels
    auto* pitchOut       = buffer.getWritePointer(0);
    auto* gateOut        = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : nullptr;
    auto* gateNuancedOut = buffer.getNumChannels() > 2 ? buffer.getWritePointer(2) : nullptr;
    auto* velocityOut    = buffer.getNumChannels() > 3 ? buffer.getWritePointer(3) : nullptr;
    auto* modOut         = buffer.getNumChannels() > 4 ? buffer.getWritePointer(4) : nullptr;
    auto* trigOut        = buffer.getNumChannels() > 5 ? buffer.getWritePointer(5) : nullptr;
    
    // The old, commented-out input logic can now be completely removed.
    
    // Get base parameter values ONCE
    const float baseRate = rateParam->load();
    const float baseGate = gateLengthParam != nullptr ? gateLengthParam->load() : 0.5f;
    const int baseSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMax = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const float gateThreshold = gateThresholdParam != nullptr ? juce::jlimit(0.0f, 1.0f, gateThresholdParam->load()) : 0.5f;
    

    // --- UI Telemetry Bootstrap ---
    // Publish per-step live values for ALL steps this block (use first-sample snapshot)
    {
        const int totalCh = inputBus.getNumChannels();
        for (int si = 0; si < MAX_STEPS; ++si)
        {
            // Absolute channel for per-step value mod: 6..21
            const int ch = 6 + si;
            const bool hasCh = totalCh > ch;
            const float base = (pitchParams.size() > (size_t) si && pitchParams[si] != nullptr) ? pitchParams[si]->load() : 0.0f;
            float live = base;
            if (hasCh)
            {
                const float cv0 = inputBus.getReadPointer(ch)[0];
                live = juce::jlimit(0.0f, 1.0f, base + (cv0 - 0.5f));
            }
            setLiveParamValue("step_live_" + juce::String(si + 1), live);

            // Per-step gate live values: channels 38..53
            const int gateCh = 38 + si;
            const bool hasGateCh = totalCh > gateCh;
            const float baseGate = (stepGateParams.size() > (size_t) si && stepGateParams[si] != nullptr) ? stepGateParams[si]->load() : 0.8f;
            float liveGate = baseGate;
            if (hasGateCh)
            {
                const float cv0 = inputBus.getReadPointer(gateCh)[0];
                liveGate = juce::jlimit(0.0f, 1.0f, baseGate + (cv0 - 0.5f));
            }
            setLiveParamValue("gate_live_" + juce::String(si + 1), liveGate);

            // Per-step trigger live values: channels 22..37
            const int trigCh = 22 + si;
            const bool hasTrigCh = totalCh > trigCh;
            const bool baseTrig = (stepTrigParams.size() > (size_t) si && stepTrigParams[si] != nullptr) ? (bool)(*stepTrigParams[si]) : false;
            bool liveTrig = baseTrig;
            if (hasTrigCh)
            {
                const float cv0 = inputBus.getReadPointer(trigCh)[0];
                liveTrig = cv0 > 0.5f;
            }
            setLiveParamValue("trig_live_" + juce::String(si + 1), liveTrig ? 1.0f : 0.0f);
        }
    }

    bool stepAdvanced = false;
    float lastRateLive = baseRate;
    float lastGateLive = baseGate;
    float lastGateThresholdLive = gateThreshold;
    int   lastStepsLive = baseSteps;
    for (int i = 0; i < numSamples; ++i)
    {
        // PER-SAMPLE FIX: Calculate global modulation parameters FOR THIS SAMPLE
        int activeSteps = baseSteps;
        if (isStepsMod && stepsCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, stepsCV[i]);
            // CV adds/subtracts steps around base (±8 steps)
            const int offset = (int)std::round((cv - 0.5f) * 16.0f);
            activeSteps = baseSteps + offset;
            activeSteps = juce::jlimit(1, boundMax, activeSteps);
        }
        // FIX: clamp playhead immediately when steps shrink
        if (currentStep.load() >= activeSteps)
            currentStep.store(0);
        
        float rate = baseRate;
        if (isRateMod && rateCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, rateCV[i]);
            // CV modulates ±2 octaves (0.25x to 4x)
            const float octaveOffset = (cv - 0.5f) * 4.0f;
            rate = baseRate * std::pow(2.0f, octaveOffset);
            rate = juce::jlimit(0.1f, 20.0f, rate);
        }
        lastRateLive = rate;
        
        float gateLen = baseGate;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            // CV adds offset to base gate length (±0.5)
            const float offset = (cv - 0.5f) * 1.0f;
            gateLen = baseGate + offset;
            gateLen = juce::jlimit(0.0f, 1.0f, gateLen);
        }
        lastGateLive = gateLen;
        
        // Use gateLenCV for gate threshold modulation (reusing the existing "Gate Mod" input)
        float gateThreshold = gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            gateThreshold = juce::jlimit(0.0f, 1.0f, cv);
        }
        lastGateThresholdLive = gateThreshold;
        
        // --- Transport Sync Logic ---
        const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;

        if (syncEnabled && m_currentTransport.isPlaying)
        {
            // SYNC MODE: Use the global beat position
            int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
            // Use global division if a Tempo Clock has override enabled
            // IMPORTANT: Read from parent's LIVE transport state, not cached copy (which is stale)
            if (getParent())
            {
                int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
                if (globalDiv >= 0)
                    divisionIndex = globalDiv;
            }
            static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
            const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
            
            // Calculate which step we should be on based on song position
            const int totalSteps = juce::jlimit(1, MAX_STEPS, activeSteps);
            const int stepForBeat = static_cast<int>(std::fmod(m_currentTransport.songPositionBeats * beatDivision, totalSteps));

            if (stepForBeat != currentStep.load())
            {
                currentStep.store(stepForBeat);
                stepAdvanced = true;
            }
        }
        else
        {
            // FREE-RUNNING MODE: Use the internal phase clock
            const double phaseInc = (sampleRate > 0.0 ? (double) rate / sampleRate : 0.0);
            phase += phaseInc;
            if (phase >= 1.0)
            {
                phase -= 1.0;
                const int next = (currentStep.load() + 1) % juce::jlimit (1, MAX_STEPS, activeSteps);
                currentStep.store(next);
                stepAdvanced = true;
            }
        }
        lastStepsLive = activeSteps;

        const int currentStepIndex = currentStep.load();
        const float sliderValue = pitchParams[currentStepIndex] != nullptr ? pitchParams[currentStepIndex]->load() : 0.0f;
        
        // PER-SAMPLE FIX: Read modulation from CV input bus for THIS SAMPLE
        float rawModValue = 0.5f; // neutral
        {
            const juce::String stepModId = "step" + juce::String(currentStepIndex + 1) + "_mod";
            const bool stepModConnected = isParamInputConnected(stepModId);
            if (stepModConnected)
            {
                // Absolute: step1_mod at 6, step2_mod at 7, ...
                const int modChannel = 6 + currentStepIndex;
                if (inputBus.getNumChannels() > modChannel)
                    rawModValue = inputBus.getReadPointer(modChannel)[i];
            }
        }
        // Center modulation around 0.0 (convert unipolar 0-1 to bipolar -0.5 to +0.5)
        const float modValue = rawModValue - 0.5f;

        const float pitchValue = juce::jlimit (0.0f, 1.0f, sliderValue + modValue);
        
        // --- REWRITTEN GATE LOGIC ---
        // 1. Get the gate level for the current step from its own slider.
        float stepGateLevel = (stepGateParams[currentStepIndex] != nullptr) ? stepGateParams[currentStepIndex]->load() : 0.8f;

        // 2. Apply modulation to the step's gate level if connected.
        const juce::String gateModId = "step" + juce::String(currentStepIndex + 1) + "_gate_mod";
        if (isParamInputConnected(gateModId))
        {
            const int gateModChannel = 38 + currentStepIndex;
            if (inputBus.getNumChannels() > gateModChannel)
            {
                const float cv = inputBus.getReadPointer(gateModChannel)[i];
                stepGateLevel = juce::jlimit(0.0f, 1.0f, stepGateLevel + (cv - 0.5f));
            }
        }

        // --- NEW DUAL GATE LOGIC WITH FADE-IN ---
        // 1. Perform the comparison once.
        const bool isGateOn = (stepGateLevel >= gateThreshold);
        
        // 2. Handle gate fade-in transition
        if (isGateOn && !previousGateOn) {
            // Gate just turned on - start fade-in
            gateFadeProgress = 0.0f;
        } else if (isGateOn && previousGateOn) {
            // Gate is on - continue fade-in
            const float fadeIncrement = sampleRate > 0.0f ? (1000.0f / GATE_FADE_TIME_MS) / sampleRate : 0.0f;
            gateFadeProgress = juce::jmin(1.0f, gateFadeProgress + fadeIncrement);
        } else {
            // Gate is off - reset fade progress
            gateFadeProgress = 0.0f;
        }
        previousGateOn = isGateOn;
        
        // 3. Generate the binary "Gate" output with fade-in.
        const float gateBinaryValue = isGateOn ? gateFadeProgress : 0.0f;
        
        // 4. Generate the analog "Gate Nuanced" output with fade-in.
        const float gateNuancedValue = isGateOn ? (stepGateLevel * gateFadeProgress) : 0.0f;
        // --- END OF NEW LOGIC ---
        
        // Live gate level is already stored in the UI telemetry bootstrap

        // Determine Trigger state for this step (checkbox + mod, but only count mod when connected)
        bool trigBase = false;
        if (stepTrigParams.size() > (size_t) currentStepIndex && stepTrigParams[currentStepIndex] != nullptr)
            trigBase = (bool) (*stepTrigParams[currentStepIndex]);
        bool trigActive = trigBase;
        {
            const juce::String trigModId = "step" + juce::String(currentStepIndex + 1) + "_trig_mod";
            const bool trigModConnected = isParamInputConnected(trigModId);
            if (trigModConnected)
            {
                // Absolute: step1_trig_mod at 22, step2 at 23, ...
                const int trigModChannel = 22 + currentStepIndex;
                if (inputBus.getNumChannels() > trigModChannel)
                {
                    const float trigModNorm = inputBus.getReadPointer(trigModChannel)[i];
                    if (trigModNorm > 0.5f) trigActive = true;
                }
            }
        }

        // If we advanced to this step, only emit a pulse if this step is enabled (checkbox or connected mod>0.5)
        if (stepAdvanced)
        {
            pendingTriggerSamples = trigActive ? (int) std::round (0.001 * sampleRate) : 0;
            stepAdvanced = false;
        }

        pitchOut[i] = pitchValue;
        // Live step value is already stored in the UI telemetry bootstrap
        if (gateOut != nullptr)         gateOut[i] = gateBinaryValue;
        if (gateNuancedOut != nullptr)  gateNuancedOut[i] = gateNuancedValue;
        if (velocityOut != nullptr) velocityOut[i] = 0.85f;
        if (modOut != nullptr)      modOut[i] = 0.0f;
        // Timed gate remains level-based
        // Trigger Out: 1ms pulse after each step advance
        if (trigOut != nullptr)
        {
            float pulse = 0.0f;
            if (pendingTriggerSamples > 0)
            {
                pulse = 1.0f;
                --pendingTriggerSamples;
            }
            trigOut[i] = pulse;
        }
    }
    // Publish block-level live telemetry for UI reflection
    setLiveParamValue("rate_live", lastRateLive);
    setLiveParamValue("gateLength_live", lastGateLive);
    setLiveParamValue("gateThreshold_live", lastGateThresholdLive);
    setLiveParamValue("steps_live", (float) lastStepsLive);
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 6)
    {
        if (lastOutputValues[0] && pitchOut) lastOutputValues[0]->store(pitchOut[numSamples - 1]);
        if (lastOutputValues[1] && gateOut) lastOutputValues[1]->store(gateOut[numSamples - 1]);
        if (lastOutputValues[2] && gateNuancedOut) lastOutputValues[2]->store(gateNuancedOut[numSamples - 1]);
        if (lastOutputValues[3] && velocityOut) lastOutputValues[3]->store(velocityOut[numSamples - 1]);
        if (lastOutputValues[4] && modOut) lastOutputValues[4]->store(modOut[numSamples - 1]);
        if (lastOutputValues[5] && trigOut) lastOutputValues[5]->store(trigOut[numSamples - 1]);
    }

}

#if defined(PRESET_CREATOR_UI)
void StepSequencerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMaxUi = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const bool stepsAreModulated = isParamModulated("numSteps_mod");
    if (stepsAreModulated) {
        // Reflect live steps from audio thread telemetry
        const int liveSteps = (int) std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float) activeSteps));
        activeSteps = juce::jlimit (1, boundMaxUi, liveSteps);
    }

    // Step count controls - now using a slider instead of +/- buttons
    int currentSteps = numStepsParam != nullptr ? (int)numStepsParam->load() : 8;

    // If modulated, the displayed value comes from the modulation input.
    // Otherwise, it comes from the parameter itself.
    int displayedSteps = currentSteps;
    if (stepsAreModulated) {
        const int liveSteps = (int) std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float) currentSteps));
        displayedSteps = juce::jlimit (1, boundMaxUi, liveSteps);
    }

    // Ensure the displayed value never exceeds the max bound
    displayedSteps = juce::jmin(displayedSteps, boundMaxUi);

    // Disable the slider if steps are being modulated
    if (stepsAreModulated) ImGui::BeginDisabled();

    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderInt("Steps", &displayedSteps, 1, boundMaxUi))
    {
        // Only update the parameter if the slider is not disabled
        if (!stepsAreModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numSteps"))) {
                *p = displayedSteps;
            }
        }
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    
    // Add scroll wheel support for the Steps slider
    if (!stepsAreModulated)
    {
        adjustParamOnWheel(apvts.getParameter("numSteps"), "numSteps", (float)displayedSteps);
    }
    
    ImGui::PopItemWidth();

    if (stepsAreModulated) {
        ImGui::EndDisabled();
        ImGui::SameLine(); 
        ImGui::TextUnformatted("(mod)");
    }

    // Use the displayed steps value for the slider strip
    const int shown = juce::jlimit (1, MAX_STEPS, displayedSteps);
    const float sliderW = itemWidth / (float) juce::jmax (8, shown) * 0.8f;

    ImGui::PushItemWidth (sliderW);
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();

        // Build display and interaction state
        float baseValue = (pitchParams[i] != nullptr ? pitchParams[i]->load() : 0.5f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        const bool modConnected = isParamModulated(modPid);

        // Reflect live per-step value for the currently active step when modulated
        float liveValue = getLiveParamValueFor("step" + juce::String(i + 1) + "_mod",
                                              "step_live_" + juce::String(i + 1),
                                              baseValue);
        float sliderValue = modConnected ? liveValue : baseValue; // widget bound to display value

        const bool isActive = (i == currentStep.load());
        if (isActive)
        {
            ImGui::PushStyleColor (ImGuiCol_FrameBg, ImVec4(0.3f, 0.7f, 1.0f, 1.0f));
            ImGui::PushStyleColor (ImGuiCol_SliderGrab, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
        }

        const std::string label = "##s" + std::to_string(i);
        if (modConnected) ImGui::BeginDisabled();
        if (ImGui::VSliderFloat (label.c_str(), ImVec2 (sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected) {
                // Only update if not modulated
                float newBaseValue = juce::jlimit (0.0f, 1.0f, sliderValue);
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                    *p = newBaseValue;
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit (0.0f, 1.0f, baseValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                        *p = newBaseValue;
                }
            }
        }

        if (modConnected) { ImGui::EndDisabled(); }

        if (isActive) ImGui::PopStyleColor(2);
    }
    ImGui::PopItemWidth();


    // Per-step Gate Sliders
    ImGui::PushItemWidth(sliderW);
    
    // Capture the screen position before drawing the gate sliders
    ImVec2 gate_sliders_p0 = ImGui::GetCursorScreenPos();
    
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();
        ImGui::PushID(2000 + i); // Use a new ID base to avoid collisions

        float baseGateValue = (stepGateParams[i] != nullptr ? stepGateParams[i]->load() : 0.8f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_gate_mod";
        const bool modConnected = isParamModulated(modPid);
        
        // Reflect live modulated value for gate level
        float sliderValue = baseGateValue;
        if (modConnected) {
            // Use live gate value from audio thread
            sliderValue = getLiveParamValueFor("step" + juce::String(i + 1) + "_gate_mod",
                                              "gate_live_" + juce::String(i + 1),
                                              baseGateValue);
        }
        const bool isActive = (i == currentStep.load());

        if (isActive) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.7f, 0.3f, 1.0f));
        if (modConnected) ImGui::BeginDisabled();
        
        if (ImGui::VSliderFloat("##g", ImVec2(sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected && stepGateParams[i] != nullptr) {
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("step" + juce::String(i + 1) + "_gate"))) {
                    *p = sliderValue;
                }
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        
        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit(0.0f, 1.0f, sliderValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("step" + juce::String(i + 1) + "_gate"))) {
                        *p = newBaseValue;
                    }
                }
            }
        }
        
        if (modConnected) ImGui::EndDisabled();
        if (isActive) ImGui::PopStyleColor();
        
        ImGui::PopID();
    }
    ImGui::PopItemWidth();

    // Draw the yellow threshold line immediately after the gate sliders
    // Use the same threshold value that will be used by the Gate Threshold slider
    const bool gtIsModulatedForLine = isParamModulated("gateLength_mod");
    const float threshold_value = gtIsModulatedForLine ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f))
                                                          : (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f);
    const float slider_height = 60.0f; // This must match the VSliderFloat height
    const float row_width = (sliderW * shown) + (ImGui::GetStyle().ItemSpacing.x * (shown - 1));

    // Calculate the Y coordinate for the line. 
    // A threshold of 1.0 is at the top (y=0), 0.0 is at the bottom (y=height).
    const float line_y = gate_sliders_p0.y + (1.0f - threshold_value) * slider_height;

    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    draw_list->AddLine(
        ImVec2(gate_sliders_p0.x, line_y),
        ImVec2(gate_sliders_p0.x + row_width, line_y),
        IM_COL32(255, 255, 0, 200), // A bright, slightly transparent yellow
        2.0f
    );

    // Current step indicator
    ImGui::Text("Current Step: %d", currentStep.load() + 1);

    // --- SYNC CONTROLS ---
    bool sync = apvts.getRawParameterValue("sync")->load() > 0.5f;
    if (ImGui::Checkbox("Sync to Transport", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync"))) *p = sync;
        onModificationEnded();
    }

    ImGui::PushItemWidth(itemWidth);
    if (sync)
    {
        // Check if global division is active (Tempo Clock override)
        // IMPORTANT: Read from parent's LIVE transport state, not cached copy
        int globalDiv = getParent() ? getParent()->getTransportState().globalDivisionIndex.load() : -1;
        bool isGlobalDivisionActive = globalDiv >= 0;
        int division = isGlobalDivisionActive ? globalDiv : (int)apvts.getRawParameterValue("rate_division")->load();
        
        // Grey out if controlled by Tempo Clock
        if (isGlobalDivisionActive) ImGui::BeginDisabled();
        
        if (ImGui::Combo("Division", &division, "1/32\0""1/16\0""1/8\0""1/4\0""1/2\0""1\0""2\0""4\0""8\0\0"))
        {
            if (!isGlobalDivisionActive)
            {
                if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division"))) *p = division;
                onModificationEnded();
            }
        }
        
        if (isGlobalDivisionActive)
        {
            ImGui::EndDisabled();
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
            {
                ImGui::BeginTooltip();
                ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Division Override Active");
                ImGui::TextUnformatted("A Tempo Clock node with 'Division Override' enabled is controlling the global division.");
                ImGui::PopTextWrapPos();
                ImGui::EndTooltip();
            }
        }
    }
    else
    {
        // Rate slider (only shown in free-running mode)
        const bool isRateModulated = isParamModulated("rate_mod");
        float rateDisplay = isRateModulated ? getLiveParamValueFor("rate_mod", "rate_live", rateParam->load()) : rateParam->load();
        
        if (isRateModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat("Rate (Hz)", &rateDisplay, 0.1f, 20.0f, "%.2f")) {
            if (!isRateModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("rate"))) *p = rateDisplay;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (!isRateModulated) adjustParamOnWheel(apvts.getParameter("rate"), "rate", rateDisplay);
        if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
    ImGui::PopItemWidth();
    // --- END SYNC CONTROLS ---

    ImGui::PushItemWidth(itemWidth);

    const bool gtIsModulated = isParamModulated("gateLength_mod");
    float gtEff = gtIsModulated ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f))
                                 : (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f);

    if (gtIsModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Gate Threshold", &gtEff, 0.0f, 1.0f))
    {
        if (! gtIsModulated)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"))) *p = gtEff;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (! gtIsModulated)
        adjustParamOnWheel (apvts.getParameter ("gateThreshold"), "gateThreshold", gtEff);
    if (gtIsModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::PopItemWidth();

    // --- Per-step Trigger checkboxes row ---
    // Place checkboxes exactly under each slider, matching widths and exact columns
    {
        const float cbWidth = sliderW; // same width as sliders
        for (int i = 0; i < shown; ++i)
        {
            // Compute the same X layout as sliders
            if (i > 0) ImGui::SameLine();

            bool baseTrig = (stepTrigParams.size() > (size_t) i && stepTrigParams[i] != nullptr) ? (bool) (*stepTrigParams[i]) : false;
            // Only grey out when the TRIGGER mod is connected (not the value mod)
            const juce::String trigModId = "step" + juce::String(i + 1) + "_trig_mod";
            const bool trigIsModulated = isParamModulated(trigModId);

            // Use live value for display when modulated
            bool displayTrig = baseTrig;
            if (trigIsModulated) {
                displayTrig = getLiveParamValueFor("step" + juce::String(i + 1) + "_trig_mod",
                                                  "trig_live_" + juce::String(i + 1),
                                                  baseTrig ? 1.0f : 0.0f) > 0.5f;
            }

            if (trigIsModulated) ImGui::BeginDisabled();
            ImGui::PushID(1000 + i);
            ImGui::SetNextItemWidth(cbWidth);
            ImGui::PushItemWidth(cbWidth);
            bool changed = ImGui::Checkbox("##trig", &displayTrig);
            ImGui::PopItemWidth();
            if (changed && !trigIsModulated && stepTrigParams.size() > (size_t) i && stepTrigParams[i] != nullptr)
            {
                // Only update parameter if not modulated
                *stepTrigParams[i] = displayTrig;
            }
            // Fill remaining width so columns align exactly to sliderW
            {
                float used = ImGui::GetItemRectSize().x;
                if (used < cbWidth) { ImGui::SameLine(0.0f, 0.0f); ImGui::Dummy(ImVec2(cbWidth - used, 0.0f)); }
            }
            if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
            ImGui::PopID();
            if (trigIsModulated) { ImGui::EndDisabled(); }
        }
        // Mod banner if any are modulated
        bool anyTrigMod = false;
        for (int i = 0; i < shown; ++i)
        {
            const juce::String trigModId = "step" + juce::String(i + 1) + "_trig_mod";
            if (isParamInputConnected(trigModId)) { anyTrigMod = true; break; }
        }
        if (anyTrigMod) { ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
}

void StepSequencerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // ARCHITECTURAL FIX: All inputs are now on a single bus, so we can use direct channel indices
    
    // Main stereo audio input pins (Channels 0-1)
    helpers.drawAudioInputPin("Mod In L", 0);
    helpers.drawAudioInputPin("Mod In R", 1);
    
    // Global modulation inputs (Channels 2-4)
    helpers.drawAudioInputPin("Rate Mod", 2);
    helpers.drawAudioInputPin("Gate Mod", 3);
    helpers.drawAudioInputPin("Steps Mod", 4);
    
    // Dynamic per-step modulation inputs
    const int boundMaxPins = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;

    // FIX: reflect live, modulated steps value (from audio thread telemetry)
    if (isParamInputConnected("numSteps_mod"))
    {
        const int liveSteps = (int) std::round (getLiveParamValueFor("numSteps_mod", "steps_live", (float) activeSteps));
        activeSteps = juce::jlimit (1, boundMaxPins, liveSteps);
    }
    else
    {
        activeSteps = juce::jlimit (1, boundMaxPins, activeSteps);
    }
    
    // Interleaved per-step pins: Step n Mod, Step n Trig Mod, Step n Gate Mod (absolute channels match pin DB)
    for (int i = 0; i < activeSteps; ++i)
    {
        const int stepIdx = i + 1;
        const int valChan  = 6 + (stepIdx - 1);           // 6..21
        const int trigChan = 22 + (stepIdx - 1);          // 22..37
        const int gateChan = 38 + (stepIdx - 1);          // 38..53
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Mod").toRawUTF8(), valChan);
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Trig Mod").toRawUTF8(), trigChan);
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Gate Mod").toRawUTF8(), gateChan);
    }

    // Output pins
    helpers.drawAudioOutputPin("Pitch", 0);
    helpers.drawAudioOutputPin("Gate", 1);
    helpers.drawAudioOutputPin("Gate Nuanced", 2);
    helpers.drawAudioOutputPin("Velocity", 3);
    helpers.drawAudioOutputPin("Mod", 4);
    helpers.drawAudioOutputPin("Trigger", 5);

    // Note: helpers API handles pin disappearance when the number of steps shrinks; no manual clear required here.
}
#endif

// Parameter bus contract implementation
bool StepSequencerModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    // ARCHITECTURAL FIX: All modulation is now on the single input bus at index 0
    outBusIndex = 0;

    // Global Audio/Mod Inputs (Absolute Channels)
    // 0-1: Mod In L/R, 2: Rate, 3: GateLen, 4: Steps, 5: Steps Max
    if (paramId == "rate_mod")       { outChannelIndexInBus = 2; return true; }
    if (paramId == "gateLength_mod") { outChannelIndexInBus = 3; return true; }
    if (paramId == "numSteps_mod")   { outChannelIndexInBus = 4; return true; }

    // Per-Step Trigger Modulation (Absolute Channels 22..37) — check TRIGGER first to avoid matching generic "_mod" suffix
    if (paramId.startsWith("step") && paramId.endsWith("_trig_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_trig_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 22 + (stepNum - 1); // e.g., step1_trig_mod is on channel 22
            return true;
        }
    }

    // Per-Step Value Modulation (Absolute Channels 6..21)
    if (paramId.startsWith("step") && paramId.endsWith("_mod") && !paramId.endsWith("_trig_mod") && !paramId.endsWith("_gate_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 6 + (stepNum - 1); // e.g., step1_mod is on channel 6
            return true;
        }
    }

    // Per-Step Gate Level Modulation (Absolute Channels 38..53)
    if (paramId.startsWith("step") && paramId.endsWith("_gate_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_gate_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 38 + (stepNum - 1); // e.g., step1_gate_mod is on channel 38
            return true;
        }
    }
    
    return false;
}




================================================================================
FILE: juce\Source\audio\modules\AnimationModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "../../animation/AnimationFileLoader.h"
#include "../../animation/AnimationBinder.h"
#include "../../animation/Animator.h"
#include "../../animation/AnimationRenderer.h"
#include <memory>
#include <atomic>
#include <algorithm>
#include <glm/glm.hpp>

// Inherit from juce::ChangeListener to receive notifications from the background loader
class AnimationModuleProcessor : public ModuleProcessor,
                                 public juce::ChangeListener
{
public:
    AnimationModuleProcessor();
    ~AnimationModuleProcessor() override;

    // --- Main JUCE Functions ---
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    const juce::String getName() const override { return "Animation Node"; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // --- Force this node to always be processed ---
    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;
    
    // Tell the UI about our output pins
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth,
                              const std::function<bool(const juce::String& paramId)>& isParamModulated,
                              const std::function<void()>& onModificationEnded) override;
    
    // Flag for BPM auto-connect feature
    std::atomic<bool> connectBpmToClockTriggered { false };
#endif

    // --- Custom Functions ---
    
    // Opens a file chooser and loads the selected animation file in the background
    void openAnimationFile();
    
    // Check if an animation file is currently being loaded in the background
    bool isCurrentlyLoading() const;
    
    // Callback executed on the main thread when background loading completes
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;
    
    const std::vector<glm::mat4>& getFinalBoneMatrices() const;
    
    // Dynamic bone tracking
    void addTrackedBone(const std::string& boneName);
    void removeTrackedBone(const std::string& boneName);
    
    // Dynamic ground planes
    void addGroundPlane(float initialY = 0.0f);
    void removeGroundPlane(int index = -1);
    std::vector<float> getGroundPlanes() const;

    // --- State Management (for saving/loading presets) ---
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree& state) override;

#if defined(PRESET_CREATOR_UI)
    // Auto-connection feature flags
    std::atomic<bool> autoBuildTriggersAudioTriggered { false };
#endif

private:
    static constexpr int MAX_TRACKED_BONES = 10; // Maximum number of bones we can track simultaneously
    
    // Update bone IDs for all tracked bones from the currently loaded animation
    void updateTrackedBoneIDs();
    
    // Analyze animation and estimate BPM from foot hits
    void updateBpmEstimate();
    
    // Helper structure for tracking multiple bones
    struct TrackedBone
    {
        std::string name;
        int boneId = -1;

        // UI-thread state for kinematics
        glm::vec2 lastScreenPos { 0.0f, 0.0f };
        bool isFirstFrame = true;
        bool wasBelowGround = false; // Legacy, kept for compatibility
        float previousY = 0.0f; // World-space Y position for hit detection

        // Atomics for audio thread
        std::atomic<float> velX { 0.0f };
        std::atomic<float> velY { 0.0f };
        std::atomic<bool> triggerState { false };
        
        // Copy constructor (atomics can't be copied, so load/store their values)
        TrackedBone(const TrackedBone& other)
            : name(other.name), boneId(other.boneId),
              lastScreenPos(other.lastScreenPos), isFirstFrame(other.isFirstFrame),
              wasBelowGround(other.wasBelowGround), previousY(other.previousY),
              velX(other.velX.load()), velY(other.velY.load()),
              triggerState(other.triggerState.load())
        {}
        
        // Copy assignment operator
        TrackedBone& operator=(const TrackedBone& other)
        {
            if (this != &other)
            {
                name = other.name;
                boneId = other.boneId;
                lastScreenPos = other.lastScreenPos;
                isFirstFrame = other.isFirstFrame;
                wasBelowGround = other.wasBelowGround;
                previousY = other.previousY;
                velX.store(other.velX.load());
                velY.store(other.velY.load());
                triggerState.store(other.triggerState.load());
            }
            return *this;
        }
        
        // Default constructor
        TrackedBone() = default;
    };

    // Called after raw data is loaded to bind and set up the animation
    void setupAnimationFromRawData(std::unique_ptr<RawAnimationData> rawData);
    
    // Parameter state (empty for this module, but required by ModuleProcessor)
    juce::AudioProcessorValueTreeState apvts;

    // Background animation file loader
    AnimationFileLoader m_fileLoader;

    // --- Thread-Safe Animation Data Management ---
    
    // The audio thread reads from this atomic pointer (lock-free).
    // It points to the currently active Animator that's being used for audio processing.
    std::atomic<Animator*> m_activeAnimator { nullptr };
    
    // This owns the AnimationData for the currently active animator.
    // We must keep this alive as long as the active animator might be in use.
    std::unique_ptr<AnimationData> m_activeData;
    
    // When new data is loaded, it's prepared here first, away from the audio thread.
    std::unique_ptr<AnimationData> m_stagedAnimationData;
    std::unique_ptr<Animator> m_stagedAnimator;
    
    // Old animators/data that need to be deleted safely after the audio thread is done with them.
    // We can't delete immediately after swapping because the audio thread might still be using it.
    std::vector<std::unique_ptr<Animator>> m_animatorsToFree;
    std::vector<std::unique_ptr<AnimationData>> m_dataToFree;
    juce::CriticalSection m_freeingLock; // Protects the above arrays
    
    // Tracked bones (dynamic list) for dedicated outputs - preserves insertion order
    std::vector<TrackedBone> m_trackedBones;
    juce::CriticalSection m_trackedBonesLock; // Protects m_trackedBones from concurrent access
    
    // Dynamic ground planes for multi-level trigger detection
    std::vector<float> m_groundPlanes;
    mutable juce::CriticalSection m_groundPlanesLock; // Protects m_groundPlanes from concurrent access
    
    // Rendering
    std::unique_ptr<AnimationRenderer> m_Renderer;

    // File chooser (kept alive during async operation)
    std::unique_ptr<juce::FileChooser> m_FileChooser;

    // Zoom and pan for the animation viewport
    float m_zoom = 10.0f;
    float m_panX = 0.0f;
    float m_panY = 0.0f;

    // View rotation angles (in radians)
    float m_viewRotationX = 0.0f;
    float m_viewRotationY = 0.0f;
    float m_viewRotationZ = 0.0f;

    // Ground line Y position for trigger detection
    float m_groundY = 180.0f;
    
    // UI bone selection (for visualization, not directly tied to outputs anymore)
    int m_selectedBoneIndex = -1;
    std::string m_selectedBoneName = "None";
    int m_selectedBoneID = -1; // Cached bone ID to avoid map lookups
    std::vector<std::string> m_cachedBoneNames; // Thread-safe cache of bone names for UI
    
    // BPM estimation from animation (thread-safe)
    std::atomic<float> m_estimatedBpm { 120.0f };
    
    // Debug logging throttling (for processBlock)
    static constexpr int64_t LOG_INTERVAL_MILLIS = 100;
    int64_t m_lastLogTimeMillis = 0;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AnimationModuleProcessor)
};



================================================================================
FILE: juce\Source\audio\modules\AnimationModuleProcessor.cpp
================================================================================


#include "AnimationModuleProcessor.h"
#include <glm/gtc/matrix_transform.hpp>
#include <algorithm>

AnimationModuleProcessor::AnimationModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withOutput("Output", juce::AudioChannelSet::discreteChannels(MAX_TRACKED_BONES * 3 + 1), true)), // +1 for BPM, then up to 10 bones * 3 outputs each
      apvts(*this, nullptr, "AnimationParams", {})
{
    // Constructor: m_AnimationData and m_Animator are nullptrs initially.
    m_Renderer = std::make_unique<AnimationRenderer>();
    
    // Register this class to listen for changes from our file loader
    m_fileLoader.addChangeListener(this);
    
    // Tracked bones start empty - they will be added when an animation is loaded
    
    // Initialize with one default ground plane at Y=0
    m_groundPlanes.push_back(180.0f);
    
    // DEBUG: Verify output channel count
    juce::Logger::writeToLog("[AnimationModule] Constructor: getTotalNumOutputChannels() = " + 
                             juce::String(getTotalNumOutputChannels()));
}

AnimationModuleProcessor::~AnimationModuleProcessor()
{
    // Remove listener before destruction
    m_fileLoader.removeChangeListener(this);
    
    // Safely clean up the active animator
    Animator* oldAnimator = m_activeAnimator.exchange(nullptr);
    if (oldAnimator)
    {
        // Move to deletion queue to be freed safely
        const juce::ScopedLock lock(m_freeingLock);
        m_animatorsToFree.push_back(std::unique_ptr<Animator>(oldAnimator));
    }
    
    // Clear all pending deletions
    {
        const juce::ScopedLock lock(m_freeingLock);
        m_animatorsToFree.clear();
        m_dataToFree.clear();
    }
}

void AnimationModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // We don't need to do anything special here for this module,
    // but the override is required.
}

void AnimationModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // This is the REAL-TIME AUDIO THREAD - must NOT block!
    
    // === STEP 1: Clean up old data (non-blocking try-lock) ===
    // This is a safe place to delete old animation data that was swapped out.
    {
        const juce::ScopedTryLock tryLock(m_freeingLock);
        if (tryLock.isLocked())
        {
            // We got the lock without blocking - safe to clear old data
            m_animatorsToFree.clear();
            m_dataToFree.clear();
        }
        // If we didn't get the lock, that's fine - we'll try again next block
    }
    
    // === STEP 2: Get current animator (LOCK-FREE atomic load) ===
    // Load the active animator pointer atomically.
    // This is lock-free and safe - even if the main thread swaps in new data,
    // our local pointer remains valid for this entire block.
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    // === STEP 3: Update animation if we have one ===
    if (currentAnimator != nullptr)
    {
        // Calculate the time elapsed for this audio block.
        const float deltaTime = buffer.getNumSamples() / getSampleRate();
        
        // Update the animation - this is now completely lock-free!
        currentAnimator->Update(deltaTime);
    }
    
    // Clear the output buffer first
    buffer.clear();
    
    // --- Write to the static BPM output (Channel 0) ---
    if (buffer.getNumChannels() > 0)
    {
        // Map BPM range (20-300) to a 0.0-1.0 CV signal
        float currentBpm = m_estimatedBpm.load();
        float bpm_cv = juce::jmap(currentBpm, 20.0f, 300.0f, 0.0f, 1.0f);
        
        // Fill the entire buffer for channel 0 with the continuous CV value
        float* bpm_ptr = buffer.getWritePointer(0);
        juce::FloatVectorOperations::fill(bpm_ptr, bpm_cv, buffer.getNumSamples());
        
        // --- Throttled Logging for Debugging (logs ~10 times per second) ---
        auto currentTime = juce::Time::currentTimeMillis();
        if (currentTime > m_lastLogTimeMillis + LOG_INTERVAL_MILLIS)
        {
            juce::Logger::writeToLog("AnimationModule: Outputting BPM CV value: " 
                                    + juce::String(bpm_cv, 3) 
                                    + " (from " + juce::String(currentBpm, 1) + " BPM)");
            m_lastLogTimeMillis = currentTime;
        }
    }

    // --- Write to dynamic bone outputs (starting from Channel 1) ---
    const juce::ScopedTryLock tryLock(m_trackedBonesLock);
    if (tryLock.isLocked() && !m_trackedBones.empty())
    {
        int channel_index = 1; // Start dynamic channels at 1
        for (auto& bone : m_trackedBones)
        {
            // Ensure we don't write past the buffer's channel count
            if (channel_index + 2 >= buffer.getNumChannels())
                break;
                
            if (bone.boneId != -1)
            {
                float velX = bone.velX.load();
                float velY = bone.velY.load();
                bool hit = bone.triggerState.load();

                // Get write pointers for this bone's channels
                float* velX_ptr = buffer.getWritePointer(channel_index);
                float* velY_ptr = buffer.getWritePointer(channel_index + 1);
                float* hit_ptr = buffer.getWritePointer(channel_index + 2);

                // Fill velocity channels with continuous DC signals
                juce::FloatVectorOperations::fill(velX_ptr, velX, buffer.getNumSamples());
                juce::FloatVectorOperations::fill(velY_ptr, velY, buffer.getNumSamples());
                
                // Set hit trigger (a single-sample pulse)
                if (hit)
                {
                    hit_ptr[0] = 1.0f;
                    bone.triggerState.store(false); // Reset atomic flag
                }
            }
            channel_index += 3;
        }
    }
}

bool AnimationModuleProcessor::isCurrentlyLoading() const
{
    return m_fileLoader.isLoading();
}

void AnimationModuleProcessor::openAnimationFile()
{
    // If already loading, ignore the request
    if (isCurrentlyLoading())
    {
        juce::Logger::writeToLog("AnimationModule: Already loading a file. Ignoring new request.");
        return;
    }

    // Create a file chooser to let the user select an animation file
    // Store it as a member to keep it alive during the async operation
    m_FileChooser = std::make_unique<juce::FileChooser>(
        "Select an animation file (glTF/FBX)...",
        juce::File{},
        "*.gltf;*.glb;*.fbx");

    auto flags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

    // Launch the file chooser asynchronously
    m_FileChooser->launchAsync(flags, [this](const juce::FileChooser& chooser)
    {
        if (chooser.getResults().isEmpty())
        {
            juce::Logger::writeToLog("AnimationModule: File selection cancelled.");
            return; // User cancelled
        }

        juce::File file = chooser.getResult();
        
        if (!file.existsAsFile())
        {
            juce::Logger::writeToLog("AnimationModule: Selected file does not exist.");
            return;
        }
        
        juce::Logger::writeToLog("AnimationModule: Starting background load of: " + file.getFullPathName());
        
        // Start the background loading process
        // The UI will remain responsive while this happens!
        m_fileLoader.startLoadingFile(file);
    });
}

void AnimationModuleProcessor::addTrackedBone(const std::string& boneName)
{
    if (boneName == "None" || boneName.empty())
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);

    if (m_trackedBones.size() >= MAX_TRACKED_BONES)
    {
        juce::Logger::writeToLog("AnimationModule: Cannot add more than " + juce::String(MAX_TRACKED_BONES) + " tracked bones.");
        return;
    }

    // Check if the bone is already being tracked
    auto it = std::find_if(m_trackedBones.begin(), m_trackedBones.end(),
                           [&](const TrackedBone& bone) { return bone.name == boneName; });

    if (it != m_trackedBones.end())
        return; // Already exists, do nothing

    // Add the new bone to the END of the list (preserves insertion order)
    TrackedBone newBone;
    newBone.name = boneName;
    
    // Find the bone ID if an animation is already loaded
    if (m_activeData)
    {
        if (m_activeData->boneInfoMap.count(boneName))
        {
            newBone.boneId = m_activeData->boneInfoMap.at(boneName).id;
            juce::Logger::writeToLog("AnimationModule: Added tracked bone '" + juce::String(boneName) + "' with ID " + juce::String(newBone.boneId));
        }
    }
    
    m_trackedBones.push_back(newBone); // This preserves the order!
    
    // Note: Pins will update on next module reload/patch load
}

void AnimationModuleProcessor::removeTrackedBone(const std::string& boneName)
{
    if (boneName == "None" || boneName.empty())
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);

    // Use the erase-remove idiom to find and remove the bone by name
    auto it = std::remove_if(m_trackedBones.begin(), m_trackedBones.end(),
                             [&](const TrackedBone& bone) { return bone.name == boneName; });
    
    if (it != m_trackedBones.end())
    {
        m_trackedBones.erase(it, m_trackedBones.end());
        juce::Logger::writeToLog("AnimationModule: Removed tracked bone '" + juce::String(boneName) + "'");

        // Note: Pins will update on next module reload/patch load
    }
}

void AnimationModuleProcessor::addGroundPlane(float initialY)
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    m_groundPlanes.push_back(initialY);
    juce::Logger::writeToLog("AnimationModule: Added ground plane at Y=" + juce::String(initialY));
}

void AnimationModuleProcessor::removeGroundPlane(int index)
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    if (m_groundPlanes.empty()) return;

    if (index < 0 || index >= (int)m_groundPlanes.size())
    {
        m_groundPlanes.pop_back(); // Default to removing the last one
    }
    else
    {
        m_groundPlanes.erase(m_groundPlanes.begin() + index);
    }
    juce::Logger::writeToLog("AnimationModule: Removed ground plane (count now: " + juce::String((int)m_groundPlanes.size()) + ")");
}

std::vector<float> AnimationModuleProcessor::getGroundPlanes() const
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    return m_groundPlanes;
}

void AnimationModuleProcessor::updateTrackedBoneIDs()
{
    // No animation loaded, nothing to do
    if (m_activeData == nullptr)
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);
    
    // Go through all currently tracked bones and find matching bone IDs in the animation
    for (auto& bone : m_trackedBones)
    {
        const std::string& trackedBoneName = bone.name;
        int foundId = -1;

        // Search for this bone name in the animation's bone info map
        if (m_activeData->boneInfoMap.count(trackedBoneName))
        {
            foundId = m_activeData->boneInfoMap.at(trackedBoneName).id;
            juce::Logger::writeToLog("AnimationModule: Mapped tracked bone '" + juce::String(trackedBoneName) + 
                                     "' to ID " + juce::String(foundId));
        }
        else
        {
            juce::Logger::writeToLog("AnimationModule: WARNING - Tracked bone '" + juce::String(trackedBoneName) + 
                                     "' not found in animation");
        }
        
        bone.boneId = foundId;
    }
}

void AnimationModuleProcessor::updateBpmEstimate()
{
    // Estimate BPM from the animation's tracked bone hit patterns
    // This runs on the UI thread after an animation is loaded
    
    if (m_activeData == nullptr || m_activeAnimator.load() == nullptr)
    {
        m_estimatedBpm.store(120.0f); // Default fallback
        return;
    }
    
    // Get animation duration from the current animation clip
    Animator* currentAnimator = m_activeAnimator.load();
    const AnimationClip* currentClip = currentAnimator->GetCurrentAnimation();
    
    if (currentClip == nullptr || currentClip->ticksPerSecond <= 0.0)
    {
        m_estimatedBpm.store(120.0f);
        juce::Logger::writeToLog("AnimationModule: No animation clip loaded for BPM estimation");
        return;
    }
    
    float animDuration = (float)(currentClip->durationInTicks / currentClip->ticksPerSecond);
    if (animDuration <= 0.0f)
    {
        m_estimatedBpm.store(120.0f);
        return;
    }
    
    juce::Logger::writeToLog("AnimationModule: Analyzing animation for BPM (duration: " + 
                             juce::String(animDuration, 2) + "s)...");
    
    // Simple BPM estimation: analyze ground hits over the animation's duration
    // We'll simulate the animation and collect hit times for all tracked bones
    
    std::vector<double> allHitTimes;
    const float timeStep = 1.0f / 60.0f; // Simulate at 60 FPS
    const auto groundPlanesToAnalyze = getGroundPlanes();
    
    // Create a temporary animator for analysis (we don't want to affect the playing one)
    Animator tempAnimator(m_activeData.get());
    if (!m_activeData->animationClips.empty())
    {
        tempAnimator.PlayAnimation(m_activeData->animationClips[0].name); // Play first animation
    }
    
    // Store previous Y positions for hit detection
    std::map<std::string, float> previousYPositions;
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        for (const auto& bone : m_trackedBones)
        {
            previousYPositions[bone.name] = 0.0f;
        }
    }
    
    // Simulate the animation and detect hits
    for (float time = 0.0f; time < animDuration; time += timeStep)
    {
        tempAnimator.Update(timeStep);
        const auto& worldTransforms = tempAnimator.GetBoneWorldTransforms();
        
        const juce::ScopedLock lock(m_trackedBonesLock);
        for (const auto& bone : m_trackedBones)
        {
            if (bone.boneId >= 0 && bone.boneId < (int)worldTransforms.size())
            {
                // Get bone's 3D world Y position (same as real-time detection)
                glm::vec3 worldPos = worldTransforms[bone.boneId][3];
                float currentY = worldPos.y;
                float prevY = previousYPositions[bone.name];
                
                // Check if bone crossed any ground plane downward (WORLD-SPACE hit detection)
                // This uses the exact same logic as the real-time kinematic calculation
                for (const float groundY : groundPlanesToAnalyze)
                {
                    // Downward crossing: bone was above ground (prevY < groundY) and is now at or below (currentY >= groundY)
                    if (currentY >= groundY && prevY < groundY)
                    {
                        allHitTimes.push_back(time);
                        break; // Only count one hit per bone per frame
                    }
                }
                
                previousYPositions[bone.name] = currentY;
            }
        }
    }
    
    // Analyze hit times to estimate BPM
    if (allHitTimes.size() < 2)
    {
        m_estimatedBpm.store(120.0f);
        juce::Logger::writeToLog("AnimationModule: Not enough hits detected for BPM estimation (found " + 
                                 juce::String((int)allHitTimes.size()) + "), using default 120 BPM");
        return;
    }
    
    // Calculate average time between hits
    std::sort(allHitTimes.begin(), allHitTimes.end());
    double totalDelta = 0.0;
    for (size_t i = 1; i < allHitTimes.size(); ++i)
    {
        totalDelta += (allHitTimes[i] - allHitTimes[i-1]);
    }
    double avgBeatInterval = totalDelta / (allHitTimes.size() - 1);
    
    // Convert to BPM (assuming each hit is a quarter note)
    double estimatedBpm = 60.0 / avgBeatInterval;
    
    // Clamp to reasonable range
    estimatedBpm = juce::jlimit(20.0, 300.0, estimatedBpm);
    
    m_estimatedBpm.store((float)estimatedBpm);
    juce::Logger::writeToLog("AnimationModule: Estimated BPM from animation: " + juce::String(estimatedBpm, 1) + 
                             " (detected " + juce::String((int)allHitTimes.size()) + " hits over " + 
                             juce::String(animDuration, 2) + "s)");
}

// THIS IS THE MOST IMPORTANT PART
// This function will be called on the MESSAGE THREAD when the background thread finishes
void AnimationModuleProcessor::changeListenerCallback(juce::ChangeBroadcaster* source)
{
    // Make sure the notification is coming from our file loader
    if (source == &m_fileLoader)
    {
        juce::Logger::writeToLog("AnimationModule: Background loading complete. Processing data...");
        
        // Get the loaded data from the loader (transfers ownership)
        std::unique_ptr<RawAnimationData> rawData = m_fileLoader.getLoadedData();

        if (rawData != nullptr)
        {
            // Success! The file was loaded and parsed in the background.
            // Now we can do the binding and setup work on the message thread.
            juce::String filePath = m_fileLoader.getLoadedFilePath();
            juce::Logger::writeToLog("AnimationModule: File loaded successfully: " + filePath);
            juce::Logger::writeToLog("   Raw Nodes: " + juce::String(rawData->nodes.size()));
            juce::Logger::writeToLog("   Raw Bones: " + juce::String(rawData->bones.size()));
            juce::Logger::writeToLog("   Raw Clips: " + juce::String(rawData->clips.size()));
            
            setupAnimationFromRawData(std::move(rawData));
        }
        else
        {
            // Failure - the loader returned nullptr
            juce::Logger::writeToLog("AnimationModule ERROR: Failed to load animation file. Check logs for details.");
            
            // Show error message to the user
            juce::AlertWindow::showMessageBoxAsync(
                juce::MessageBoxIconType::WarningIcon,
                "Loading Failed",
                "The selected animation file could not be loaded.\nCheck the console logs for details.",
                "OK");
        }
    }
}

void AnimationModuleProcessor::setupAnimationFromRawData(std::unique_ptr<RawAnimationData> rawData)
{
    // This is called on the MESSAGE THREAD after background loading completes
    
    juce::Logger::writeToLog("AnimationModule: Binding raw data to create AnimationData...");
    auto finalData = AnimationBinder::Bind(*rawData);

    if (!finalData)
    {
        juce::Logger::writeToLog("AnimationModule ERROR: AnimationBinder failed to create final AnimationData.");
        
        juce::AlertWindow::showMessageBoxAsync(
            juce::MessageBoxIconType::WarningIcon,
            "Binding Failed",
            "The animation data could not be processed after loading.",
            "OK");
        return;
    }
    
    juce::Logger::writeToLog("AnimationModule: Binder SUCCESS - Final data created.");
    juce::Logger::writeToLog("   Final Bones: " + juce::String(finalData->boneInfoMap.size()));
    juce::Logger::writeToLog("   Final Clips: " + juce::String(finalData->animationClips.size()));

    // === THREAD-SAFE DATA SWAP ===
    // Prepare the new animator and data in "staging" area (not visible to audio thread yet)
    m_stagedAnimationData = std::move(finalData);
    m_stagedAnimator = std::make_unique<Animator>(m_stagedAnimationData.get());
    
    // Play the first animation clip if available
    if (!m_stagedAnimationData->animationClips.empty())
    {
        juce::Logger::writeToLog("AnimationModule: Playing first animation clip: " + 
                               juce::String(m_stagedAnimationData->animationClips[0].name));
        m_stagedAnimator->PlayAnimation(m_stagedAnimationData->animationClips[0].name);
    }
    
    // Cache bone names for thread-safe UI access (on main thread, before audio thread gets it)
    m_cachedBoneNames.clear();
    for (const auto& pair : m_stagedAnimationData->boneInfoMap)
    {
        m_cachedBoneNames.push_back(pair.first);
    }
    juce::Logger::writeToLog("AnimationModule: Cached " + juce::String((int)m_cachedBoneNames.size()) + " bone names for UI.");
    
    // Update tracked bone IDs for the new animation (NON-DESTRUCTIVE)
    // This does NOT clear the list - it only refreshes the IDs
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        
        // If this is a completely fresh load (no bones tracked yet), add defaults
        if (m_trackedBones.empty())
        {
            TrackedBone leftFoot;
            leftFoot.name = "LeftFoot";
            m_trackedBones.push_back(leftFoot);
            
            TrackedBone rightFoot;
            rightFoot.name = "RightFoot";
            m_trackedBones.push_back(rightFoot);
            
            juce::Logger::writeToLog("AnimationModule: Initialized default tracked bones (LeftFoot, RightFoot)");
        }
        
        // Update bone IDs for ALL currently tracked bones from the new animation
        for (auto& bone : m_trackedBones)
        {
            const std::string& trackedBoneName = bone.name;
            int foundId = -1;

            // Search for a matching bone in the animation
            for (const auto& boneInfoPair : m_stagedAnimationData->boneInfoMap)
            {
                const std::string& boneNameFromFile = boneInfoPair.first;
                
                if (juce::String(boneNameFromFile).endsWithIgnoreCase(trackedBoneName))
                {
                    foundId = boneInfoPair.second.id;
                    juce::Logger::writeToLog("AnimationModule: Refreshed tracked bone '" + juce::String(trackedBoneName) + 
                                             "' with ID " + juce::String(foundId));
                    break;
                }
            }
            
            bone.boneId = foundId;
            
            if (foundId == -1)
            {
                juce::Logger::writeToLog("AnimationModule: WARNING - Tracked bone '" + juce::String(trackedBoneName) + 
                                         "' not found in new animation");
            }
        }
    }
    
    juce::Logger::writeToLog("AnimationModule: Preparing to swap animation data...");
    
    // 1. Release the raw pointer for the new animator from its unique_ptr.
    Animator* newAnimator = m_stagedAnimator.release();
    
    // 2. Atomically swap the new animator into the 'active' slot.
    // The audio thread will pick this up on its next processBlock().
    Animator* oldAnimator = m_activeAnimator.exchange(newAnimator, std::memory_order_release);
    
    // 3. Now, swap the unique_ptr that owns the AnimationData.
    // m_stagedAnimationData (holding the NEW data) is moved into m_activeData.
    // The previous m_activeData (holding the OLD data) is moved into a temporary.
    std::unique_ptr<AnimationData> oldDataToFree = std::move(m_activeData);
    m_activeData = std::move(m_stagedAnimationData);

    juce::Logger::writeToLog("AnimationModule: New animator is now active.");

    // 4. Queue the OLD animator and OLD data for safe deletion.
    // We can't delete them immediately, as the audio thread might still be using them.
    {
        const juce::ScopedLock lock(m_freeingLock);
        if (oldAnimator)
        {
            m_animatorsToFree.push_back(std::unique_ptr<Animator>(oldAnimator));
            juce::Logger::writeToLog("AnimationModule: Old animator queued for safe deletion.");
        }
        if (oldDataToFree)
        {
            m_dataToFree.push_back(std::move(oldDataToFree));
            juce::Logger::writeToLog("AnimationModule: Old animation data queued for safe deletion.");
        }
    }
    
    // Reset UI state now that new data is active
    m_selectedBoneIndex = -1;
    m_selectedBoneName = "None";
    
    juce::Logger::writeToLog("AnimationModule: Animation atomically swapped and ready for audio thread!");
    
    // Note: BPM estimation is deferred until AFTER ground planes are loaded (in setExtraStateTree)
}

const std::vector<glm::mat4>& AnimationModuleProcessor::getFinalBoneMatrices() const
{
    // This is called from the UI/message thread to get bone matrices for rendering.
    // We use the same atomic pointer the audio thread uses - this is safe and lock-free!
    
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);

    if (currentAnimator != nullptr)
    {
        return currentAnimator->GetFinalBoneMatrices();
    }

    // If there's no animator, return a static empty vector to avoid crashes.
    static const std::vector<glm::mat4> empty;
    return empty;
}

#if defined(PRESET_CREATOR_UI)

// Helper function to project a 3D point to 2D screen space
static glm::vec2 worldToScreen(const glm::vec3& worldPos, const glm::mat4& viewMatrix, const glm::mat4& projectionMatrix, ImVec2 viewportPos, ImVec2 viewportSize)
{
    glm::vec4 clipSpacePos = projectionMatrix * viewMatrix * glm::vec4(worldPos, 1.0f);
    if (clipSpacePos.w == 0.0f) return {0,0};
    glm::vec3 ndcSpacePos = glm::vec3(clipSpacePos.x, clipSpacePos.y, clipSpacePos.z) / clipSpacePos.w;
    glm::vec2 screenPos;
    screenPos.x = (ndcSpacePos.x + 1.0f) / 2.0f * viewportSize.x + viewportPos.x;
    screenPos.y = (1.0f - ndcSpacePos.y) / 2.0f * viewportSize.y + viewportPos.y;
    return screenPos;
}

// Helper function for tooltip with help marker
static void HelpMarker(const char* desc)
{
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

void AnimationModuleProcessor::drawParametersInNode(float itemWidth,
                                                     const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                                     const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth(itemWidth);
    
    // File loading section
    ImGui::TextWrapped("glTF File:");
    
    // Show loading status or loaded file info
    // Get current animator atomically (lock-free)
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    if (isCurrentlyLoading())
    {
        // Show a loading indicator while file is being loaded in the background
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Loading...");
        ImGui::SameLine();
        // Simple animated spinner
        static float spinnerAngle = 0.0f;
        spinnerAngle += ImGui::GetIO().DeltaTime * 10.0f;
        ImGui::Text("%.1f", spinnerAngle); // Simple animation placeholder
    }
    else if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "Loaded");
        ImGui::Text("Bones: %zu", animData->boneInfoMap.size());
        ImGui::Text("Clips: %zu", animData->animationClips.size());
    }
    else
    {
        ImGui::TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "No file loaded");
    }
    
    // Disable button while loading
    if (isCurrentlyLoading())
        ImGui::BeginDisabled();
    
    if (ImGui::Button("Load Animation File...", ImVec2(itemWidth, 0)))
    {
        // Use the new async loading method!
        // This will not block the UI - the file chooser and loading happen in the background
        openAnimationFile();
    }
    
    if (isCurrentlyLoading())
        ImGui::EndDisabled();
    
    
    // --- BONE SELECTION ---
    if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        if (!animData->boneInfoMap.empty())
        {
            if (ImGui::BeginCombo("Selected Bone", m_selectedBoneName.c_str()))
            {
                // Add a "None" option
                bool isNoneSelected = (m_selectedBoneIndex == -1);
                if (ImGui::Selectable("None", isNoneSelected))
                {
                    m_selectedBoneIndex = -1;
                    m_selectedBoneName = "None";
                    m_selectedBoneID = -1;
                }

                // Iterate through cached bone names (thread-safe)
                int currentIndex = 0;
                for (const auto& boneName : m_cachedBoneNames)
                {
                    bool isSelected = (m_selectedBoneName == boneName);

                    if (ImGui::Selectable(boneName.c_str(), isSelected))
                    {
                        m_selectedBoneName = boneName;
                        m_selectedBoneIndex = currentIndex;
                        
                        // Cache the bone ID to avoid map lookups every frame
                        if (animData->boneInfoMap.count(boneName))
                        {
                            m_selectedBoneID = animData->boneInfoMap.at(boneName).id;
                        }
                        else
                        {
                            m_selectedBoneID = -1;
                        }
                    }
                    if (isSelected)
                    {
                        ImGui::SetItemDefaultFocus();
                    }
                    currentIndex++;
                }
                ImGui::EndCombo();
            }
            
            // Add/Remove Bone Output Buttons (with Undo/Redo support)
            bool isSelected = (m_selectedBoneName != "None" && !m_selectedBoneName.empty());
            bool isAlreadyTracked = false;
            if (isSelected)
            {
                const juce::ScopedLock lock(m_trackedBonesLock);
                auto it = std::find_if(m_trackedBones.begin(), m_trackedBones.end(),
                                       [this](const TrackedBone& bone) { return bone.name == m_selectedBoneName; });
                isAlreadyTracked = (it != m_trackedBones.end());
            }

            // "Add Bone Output" button
            if (!isSelected || isAlreadyTracked) ImGui::BeginDisabled();
            if (ImGui::Button("Add Bone Output", ImVec2(itemWidth / 2 - 2, 0)))
            {
                addTrackedBone(m_selectedBoneName);
                onModificationEnded(); // Trigger undo/redo snapshot
            }
            if (!isSelected || isAlreadyTracked) ImGui::EndDisabled();

            ImGui::SameLine();

            // "Remove Bone Output" button
            if (!isSelected || !isAlreadyTracked) ImGui::BeginDisabled();
            if (ImGui::Button("Remove Bone Output", ImVec2(itemWidth / 2 - 2, 0)))
            {
                removeTrackedBone(m_selectedBoneName);
                onModificationEnded(); // Trigger undo/redo snapshot
            }
            if (!isSelected || !isAlreadyTracked) ImGui::EndDisabled();
        }
    }
    
    // Build Triggers Audio Quick-Connect Button (80s blue style)
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.15f, 0.6f, 0.85f, 0.8f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.7f, 0.95f, 0.95f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.35f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.0f));
    if (ImGui::Button("BUILD TRIGGERS AUDIO", ImVec2(itemWidth, 0)))
    {
        autoBuildTriggersAudioTriggered = true;
    }
    ImGui::PopStyleColor(4);
    HelpMarker("Auto-create samplers + mixer, wire triggers to pads.");
    
    
    // Animation playback controls
    if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        ImGui::Text("Animation Controls:");
        
        // List available clips
        if (!animData->animationClips.empty())
        {
            ImGui::Text("Available Clips:");
            for (size_t i = 0; i < animData->animationClips.size(); ++i)
            {
                const auto& clip = animData->animationClips[i];
                if (ImGui::Button(clip.name.c_str(), ImVec2(itemWidth, 0)))
                {
                    // Safe to call directly - the animator pointer is valid for this frame
                    currentAnimator->PlayAnimation(clip.name);
                }
            }
        }
        
        
        // Speed control
        static float speed = 1.0f;
        if (ImGui::SliderFloat("Speed", &speed, 0.1f, 3.0f, "%.2f"))
        {
            // Safe to call directly - the animator pointer is valid for this frame
            currentAnimator->SetAnimationSpeed(speed);
        }
        
        // DEBUG: Display basic info (accessing animator state directly is unsafe due to audio thread)
        ImGui::Separator();
        ImGui::Text("Debug Info:");
        ImGui::Text("Bones: %d", (int)animData->boneInfoMap.size());
        ImGui::Text("Clips: %d", (int)animData->animationClips.size());
        ImGui::Separator();
        
        
        // --- RENDERING VIEWPORT ---
        
        ImGui::Text("Animation Viewport:");
        
        // Camera controls
        ImGui::SliderFloat("Zoom", &m_zoom, 1.0f, 50.0f, "%.1f");
        ImGui::SliderFloat("Pan X", &m_panX, -20.0f, 20.0f, "%.1f");
        ImGui::SliderFloat("Pan Y", &m_panY, -20.0f, 20.0f, "%.1f");
        
        // View rotation controls
        ImGui::Text("View Rotation:");
        ImGui::PushItemWidth(itemWidth / 3.0f - 5.0f); // Adjust width for 3 buttons side-by-side
        if (ImGui::Button("Rot X")) { m_viewRotationX += glm::radians(90.0f); }
        ImGui::SameLine();
        if (ImGui::Button("Rot Y")) { m_viewRotationY += glm::radians(90.0f); }
        ImGui::SameLine();
        if (ImGui::Button("Rot Z")) { m_viewRotationZ += glm::radians(90.0f); }
        ImGui::PopItemWidth();

        // Reset view button - resets rotation and frames the animation
        if (ImGui::Button("Reset View", ImVec2(itemWidth, 0)))
        {
            m_viewRotationX = 0.0f;
            m_viewRotationY = 0.0f;
            m_viewRotationZ = 0.0f;
            if (currentAnimator != nullptr)
            {
                glm::vec2 newPan;
                m_Renderer->frameView(currentAnimator->GetBoneWorldTransforms(), m_zoom, newPan);
                m_panX = newPan.x;
                m_panY = newPan.y;
            }
        }
        
        
        // === GROUND PLANE CONTROLS ===
        ImGui::Separator();
        ImGui::Text("Ground Planes:");
        
        // Add/Remove Buttons
        if (ImGui::Button("Add Ground Plane", ImVec2(itemWidth / 2 - 2, 0)))
        {
            addGroundPlane(180.0f);
            onModificationEnded(); // Trigger undo/redo snapshot
        }
        ImGui::SameLine();
        
        bool canRemove = false;
        {
            const juce::ScopedLock lock(m_groundPlanesLock);
            canRemove = m_groundPlanes.size() > 1;
        }
        if (!canRemove) ImGui::BeginDisabled();
        if (ImGui::Button("Remove Ground Plane", ImVec2(itemWidth / 2 - 2, 0)))
        {
            removeGroundPlane();
            onModificationEnded(); // Trigger undo/redo snapshot
        }
        if (!canRemove) ImGui::EndDisabled();

        // Colored Sliders for each ground plane
        {
            const juce::ScopedLock lock(m_groundPlanesLock);
            for (int i = 0; i < (int)m_groundPlanes.size(); ++i)
            {
                ImGui::PushID(i); // Unique ID for each slider
                
                // Generate a distinct color for each slider
                float hue = fmodf((float)i * 0.2f, 1.0f); // 0.2 step for distinct hues
                ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(hue, 0.5f, 0.5f));
                ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));
                ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));
                ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(hue, 0.9f, 0.9f));

                ImGui::SliderFloat("Ground Y", &m_groundPlanes[i], 0.0f, 400.0f, "%.0f");

                // Trigger snapshot only when slider is released (best practice)
                if (ImGui::IsItemDeactivatedAfterEdit())
                {
                    onModificationEnded();
                }

                ImGui::PopStyleColor(4);
                ImGui::PopID();
            }
        }
        ImGui::Separator();
        
        
        // Pass the latest values to the renderer before drawing
        m_Renderer->setZoom(m_zoom);
        m_Renderer->setPan({m_panX, m_panY});
        m_Renderer->setViewRotation({m_viewRotationX, m_viewRotationY, m_viewRotationZ});
        
        // Define the size of our viewport
        const ImVec2 viewportSize(200, 200);
        
        // Setup the renderer (it will only run once internally)
        m_Renderer->setup(static_cast<int>(viewportSize.x), static_cast<int>(viewportSize.y));
        
        // Get world transforms for visualization (NOT skinning matrices!)
        const auto& worldTransforms = currentAnimator->GetBoneWorldTransforms();
        
        // --- DEBUG: Log bone positions to diagnose rendering issues ---
        static int debugFrameCounter = 0;
        if (++debugFrameCounter % 60 == 0 && !worldTransforms.empty()) // Log once per second at 60fps
        {
            juce::Logger::writeToLog("=== Animation Frame Debug ===");
            juce::Logger::writeToLog("Total bones: " + juce::String(worldTransforms.size()));
            
            // Log the first 3 bone positions to see if they're all at origin or varying
            for (size_t i = 0; i < std::min(size_t(3), worldTransforms.size()); ++i)
            {
                glm::vec3 pos = worldTransforms[i][3];
                juce::Logger::writeToLog("Bone[" + juce::String(i) + "] Position: (" + 
                    juce::String(pos.x, 2) + ", " + 
                    juce::String(pos.y, 2) + ", " + 
                    juce::String(pos.z, 2) + ")");
            }
        }
        
        m_Renderer->render(worldTransforms);
        
        // Display the texture from the FBO (flipped vertically)
        ImGui::Image((void*)(intptr_t)m_Renderer->getTextureID(), viewportSize, ImVec2(0, 1), ImVec2(1, 0));
        
        // --- DRAW ALL GROUND LINES (colored) ---
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 p1 = ImGui::GetItemRectMin();
        ImVec2 p2 = ImGui::GetItemRectMax();
        
        // Draw each ground plane with its corresponding color
        std::vector<float> groundPlanesToDraw = getGroundPlanes();
        for (int i = 0; i < (int)groundPlanesToDraw.size(); ++i)
        {
            float groundY = groundPlanesToDraw[i];
            float hue = fmodf((float)i * 0.2f, 1.0f);
            ImVec4 colorVec = (ImVec4)ImColor::HSV(hue, 0.9f, 0.9f);
            ImU32 color = IM_COL32((int)(colorVec.x * 255), (int)(colorVec.y * 255), (int)(colorVec.z * 255), 255);
            drawList->AddLine(ImVec2(p1.x, p1.y + groundY), ImVec2(p2.x, p1.y + groundY), color, 2.0f);
        }
        
        // --- KINEMATIC CALCULATION BLOCK FOR ALL TRACKED BONES ---
        const juce::ScopedLock lock(m_trackedBonesLock);
        for (auto& bone : m_trackedBones)
        {
            if (bone.boneId != -1 && currentAnimator != nullptr)
            {
                const auto& worldTransforms = currentAnimator->GetBoneWorldTransforms();
                if (bone.boneId >= 0 && bone.boneId < worldTransforms.size())
                {
                    glm::mat4 worldMatrix = worldTransforms[bone.boneId];
                    glm::vec3 worldPos = worldMatrix[3];

                    // --- WORLD-SPACE HIT DETECTION ---
                    // Compare the bone's actual 3D Y-position to the ground plane's Y-position.
                    // This is independent of camera zoom, pan, or rotation.
                    bool hitDetected = false;
                    for (const float groundY : groundPlanesToDraw)
                    {
                        // Downward crossing: bone was above ground (previousY < groundY) and is now at or below (worldPos.y >= groundY)
                        if (worldPos.y >= groundY && bone.previousY < groundY)
                        {
                            hitDetected = true;
                            break; // One hit is enough, no need to check other planes
                        }
                    }
                    bone.triggerState.store(hitDetected);
                    bone.previousY = worldPos.y; // Store world Y for next frame's comparison
                    bone.wasBelowGround = false; // Legacy, not used anymore

                    // --- SCREEN-SPACE VISUALIZATION (for velocity calculation) ---
                    // Recreate the projection and view matrices used by the renderer
                    glm::mat4 projection = glm::ortho(-m_zoom + m_panX, m_zoom + m_panX, -m_zoom + m_panY, m_zoom + m_panY, -10.0f, 10.0f);
                    glm::mat4 view = glm::mat4(1.0f);
                    view = glm::rotate(view, m_viewRotationX, glm::vec3(1.0f, 0.0f, 0.0f));
                    view = glm::rotate(view, m_viewRotationY, glm::vec3(0.0f, 1.0f, 0.0f));
                    view = glm::rotate(view, m_viewRotationZ, glm::vec3(0.0f, 0.0f, 1.0f));

                    // Project to screen space for velocity calculation
                    ImVec2 viewportPos = ImGui::GetItemRectMin();
                    glm::vec2 currentScreenPos = worldToScreen(worldPos, view, projection, viewportPos, viewportSize);

                    // Calculate velocity
                    if (bone.isFirstFrame)
                    {
                        bone.lastScreenPos = currentScreenPos;
                        bone.isFirstFrame = false;
                    }
                    float deltaTime = ImGui::GetIO().DeltaTime;
                    glm::vec2 velocity(0.0f);
                    if (deltaTime > 0.0f)
                    {
                        velocity = (currentScreenPos - bone.lastScreenPos) / deltaTime;
                    }
                    bone.lastScreenPos = currentScreenPos;

                    // Store results in this bone's specific atomics
                    bone.velX.store(velocity.x);
                    bone.velY.store(velocity.y);
                }
            }
            else
            {
                // Reset state if this bone isn't found in the current animation
                bone.wasBelowGround = false;
                bone.isFirstFrame = true;
            }
        }
    }
    else
    {
        // Show a placeholder when no animation is loaded to maintain consistent node size
        ImGui::TextDisabled("Load an animation file to see animation");
        ImGui::Dummy(ImVec2(200, 200)); // Reserve space for the viewport
    }
    
    // --- BPM OUTPUT SECTION ---
    ImGui::Separator();
    
    // Display the detected BPM (provides instant visual feedback)
    ImGui::Text("Detected BPM: %.1f", m_estimatedBpm.load());
    
    // Manual recalculate button (useful after changing ground planes or loading presets)
    if (ImGui::Button("Recalculate BPM", ImVec2(itemWidth, 0)))
    {
        updateBpmEstimate();
    }
    
    // Auto-connect button for one-click tempo sync workflow
    if (ImGui::Button("Connect BPM to Tempo Clock", ImVec2(itemWidth, 0)))
    {
        connectBpmToClockTriggered = true;
    }
    
    ImGui::PopItemWidth();
}
#endif

bool AnimationModuleProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    // Support up to our max channels (+1 for BPM, then dynamic bone outputs), and no inputs.
    const int maxChannels = MAX_TRACKED_BONES * 3 + 1; // +1 for BPM output
    return layouts.getMainOutputChannelSet().size() <= maxChannels
           && layouts.getMainInputChannelSet() == juce::AudioChannelSet::disabled();
}

std::vector<DynamicPinInfo> AnimationModuleProcessor::getDynamicOutputPins() const
{
    // Generate output pins: BPM is static (always first), then dynamic bone outputs
    std::vector<DynamicPinInfo> pins;
    
    // +++ STATIC BPM OUTPUT (Channel 0) +++
    pins.push_back({ "BPM", 0, PinDataType::CV });
    
    // +++ DYNAMIC BONE OUTPUTS (Starting from Channel 1) +++
    const juce::ScopedLock lock(m_trackedBonesLock);
    pins.reserve(1 + m_trackedBones.size() * 3);
    
    int channelIndex = 1; // Start dynamic channels at index 1
    // The vector guarantees linear, insertion-order iteration!
    for (const auto& bone : m_trackedBones)
    {
        pins.push_back({ juce::String(bone.name) + " Vel X", channelIndex++, PinDataType::CV });
        pins.push_back({ juce::String(bone.name) + " Vel Y", channelIndex++, PinDataType::CV });
        pins.push_back({ juce::String(bone.name) + " Hit",   channelIndex++, PinDataType::Gate });
    }
    
    return pins;
}

// === State Management (for saving/loading presets) ===

juce::ValueTree AnimationModuleProcessor::getExtraStateTree() const
{
    // This function is called by the synth when saving a preset.
    // We create a ValueTree to hold our module's unique state.
    juce::ValueTree state("AnimationModuleState");

    // 1. Save the absolute path of the currently loaded animation file.
    state.setProperty("animationFilePath", m_fileLoader.getLoadedFilePath(), nullptr);

    // 2. Save the viewport/camera settings.
    state.setProperty("zoom", m_zoom, nullptr);
    state.setProperty("panX", m_panX, nullptr);
    state.setProperty("panY", m_panY, nullptr);
    state.setProperty("viewRotationX", m_viewRotationX, nullptr);
    state.setProperty("viewRotationY", m_viewRotationY, nullptr);
    state.setProperty("viewRotationZ", m_viewRotationZ, nullptr);

    // 3. Save the list of ground planes
    juce::ValueTree groundPlanesNode("GroundPlanes");
    {
        const juce::ScopedLock lock(m_groundPlanesLock);
        for (const float y : m_groundPlanes)
        {
            juce::ValueTree planeNode("Plane");
            planeNode.setProperty("y", y, nullptr);
            groundPlanesNode.addChild(planeNode, -1, nullptr);
        }
    }
    state.addChild(groundPlanesNode, -1, nullptr);

    // 4. Save the list of tracked bones (preserves insertion order)
    juce::ValueTree trackedBonesNode("TrackedBones");
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        for (const auto& bone : m_trackedBones)
        {
            juce::ValueTree boneNode("Bone");
            boneNode.setProperty("name", juce::String(bone.name), nullptr);
            trackedBonesNode.addChild(boneNode, -1, nullptr);
        }
    }
    state.addChild(trackedBonesNode, -1, nullptr);

    // 5. Save the name of the currently selected bone.
    state.setProperty("selectedBoneName", juce::String(m_selectedBoneName), nullptr);

    juce::Logger::writeToLog("[AnimationModule] Saving state: file='" + 
                              m_fileLoader.getLoadedFilePath() + 
                              "', bone='" + juce::String(m_selectedBoneName) + "'");
    
    return state;
}

void AnimationModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    // This function is called by the synth when loading a preset.
    // We restore our state from the provided ValueTree.
    
    if (!state.hasType("AnimationModuleState"))
        return;

    juce::Logger::writeToLog("[AnimationModule] Loading state from preset...");

    // === CRITICAL: ORDER OF OPERATIONS FOR PRESET LOADING ===
    // We must load the animation file FIRST so that bone names can be matched to IDs afterward.
    
    // 1. Restore the viewport/camera settings.
    m_zoom = state.getProperty("zoom", 10.0f);
    m_panX = state.getProperty("panX", 0.0f);
    m_panY = state.getProperty("panY", 0.0f);
    m_viewRotationX = state.getProperty("viewRotationX", 0.0f);
    m_viewRotationY = state.getProperty("viewRotationY", 0.0f);
    m_viewRotationZ = state.getProperty("viewRotationZ", 0.0f);

    // 2. Restore the selected bone name (for UI dropdown).
    m_selectedBoneName = state.getProperty("selectedBoneName", "None").toString().toStdString();

    // 3. IMPORTANT: Load the animation file BEFORE restoring tracked bones.
    juce::String filePath = state.getProperty("animationFilePath", "").toString();
    
    if (filePath.isNotEmpty())
    {
        juce::File fileToLoad(filePath);
        
        if (fileToLoad.existsAsFile())
        {
            juce::Logger::writeToLog("[AnimationModule] Restoring animation from preset: " + fileToLoad.getFullPathName());
            m_fileLoader.startLoadingFile(fileToLoad);
            // Note: This is async, but setupAnimationFromRawData is now non-destructive, so the
            // tracked bones we restore next won't be cleared.
        }
        else
        {
            juce::Logger::writeToLog("[AnimationModule] Warning: Animation file not found at: " + filePath);
        }
    }
    else
    {
        juce::Logger::writeToLog("[AnimationModule] No animation file path in preset.");
    }

    // 4. Restore the list of tracked bones from the preset (preserves saved order).
    // This happens AFTER we've started loading the file (which is async).
    // Since setupAnimationFromRawData is now non-destructive, it won't clear this list.
    if (auto trackedBonesNode = state.getChildWithName("TrackedBones"); trackedBonesNode.isValid())
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        m_trackedBones.clear(); // Clear the current list
        for (const auto& boneNode : trackedBonesNode)
        {
            if (boneNode.hasType("Bone"))
            {
                juce::String boneName = boneNode.getProperty("name").toString();
                if (boneName.isNotEmpty())
                {
                    TrackedBone newBone;
                    newBone.name = boneName.toStdString();
                    m_trackedBones.push_back(newBone); // Preserves order!
                    juce::Logger::writeToLog("[AnimationModule] Restored tracked bone: " + boneName);
                }
            }
        }
    }

    // 5. Restore the list of ground planes.
    if (auto groundPlanesNode = state.getChildWithName("GroundPlanes"); groundPlanesNode.isValid())
    {
        const juce::ScopedLock lock(m_groundPlanesLock);
        m_groundPlanes.clear();
        for (const auto& planeNode : groundPlanesNode)
        {
            if (planeNode.hasType("Plane"))
            {
                m_groundPlanes.push_back(planeNode.getProperty("y", 180.0f));
            }
        }
        // Fallback: if loading results in no ground planes, add one as a safety
        if (m_groundPlanes.empty())
        {
            m_groundPlanes.push_back(180.0f);
        }
    }
    else
    {
        // Legacy support: try to load single groundY value
        float legacyGroundY = state.getProperty("groundY", 180.0f);
        const juce::ScopedLock lock(m_groundPlanesLock);
        m_groundPlanes.clear();
        m_groundPlanes.push_back(legacyGroundY);
    }
    
    // 6. Now that ground planes are restored, run BPM analysis if animation is loaded
    // If the animation file is still loading asynchronously, the user can manually
    // recalculate BPM later using the "Recalculate BPM" button.
    updateBpmEstimate();
    
    juce::Logger::writeToLog("[AnimationModule] Preset loading complete.");
}



================================================================================
FILE: juce\Source\animation\AnimationData.h
================================================================================


#pragma once

#include <string>
#include <vector>
#include <map>

#include <glm/glm.hpp>
#include <glm/gtc/quaternion.hpp>

struct KeyPosition
{
    glm::vec3 position;
    double timeStamp;
};

struct KeyRotation
{
    glm::quat orientation;
    double timeStamp;
};

struct KeyScale
{
    glm::vec3 scale;
    double timeStamp;
};

// Contains all position, rotation, and scale keyframes for a single bone
class BoneAnimation
{
public:
    std::vector<KeyPosition> positions;
    std::vector<KeyRotation> rotations;
    std::vector<KeyScale> scales;
    std::string boneName;
};

// Represents a single, self-contained animation clip (e.g., "walk", "run")
class AnimationClip
{
public:
    std::string name;
    double durationInTicks;
    double ticksPerSecond;
    std::map<std::string, BoneAnimation> boneAnimations;
};

// Contains static information about a single bone that influences the mesh
struct BoneInfo
{
    int id; // Unique ID for the bone, used as an index into the final transform array
    std::string name;
    glm::mat4 offsetMatrix; // Transforms vertices from model space to bone space
};

// Forward declare
class BoneAnimation;

// Represents a node in the skeleton's hierarchy. A node can be a bone or just a transform group.
struct NodeData
{
    glm::mat4 transformation = glm::mat4(1.0f); // The node's local transform relative to its parent
    std::string name;
    std::vector<NodeData> children;
    NodeData* parent = nullptr;
    BoneAnimation* currentBoneAnimation = nullptr; // Pre-linked for current animation (NO string lookup needed!)
    int boneIndex = -1; // Pre-linked bone index (-1 if not a bone)
    glm::mat4 offsetMatrix = glm::mat4(1.0f); // Pre-linked offset matrix (identity if not a bone)
};

// The top-level container for all parsed animation and skeleton data from a single file
class AnimationData
{
public:
    NodeData rootNode;
    std::map<std::string, BoneInfo> boneInfoMap;
    std::vector<AnimationClip> animationClips;
};



================================================================================
FILE: juce\Source\animation\AnimationRenderer.h
================================================================================


#pragma once

#include <juce_opengl/juce_opengl.h>
#include <glm/glm.hpp>
#include <vector>

class AnimationRenderer
{
public:
    AnimationRenderer();
    ~AnimationRenderer();

    // Call once to set up OpenGL resources
    void setup(int width, int height);

    // Call every frame to draw the skeleton
    void render(const std::vector<glm::mat4>& finalBoneMatrices);

    // Get the ID of the final texture to display in ImGui
    GLuint getTextureID() const { return fboTextureID; }
    
    // Set zoom level (affects orthographic projection)
    void setZoom(float zoom) { m_zoom = zoom; }
    
    // Set pan offset (affects orthographic projection)
    void setPan(const glm::vec2& pan) { m_pan = pan; }
    
    // Set the view rotation in radians
    void setViewRotation(const glm::vec3& rotation) { m_viewRotation = rotation; }
    
    // Calculate optimal zoom and pan to frame all bones in view
    void frameView(const std::vector<glm::mat4>& boneMatrices, float& outZoom, glm::vec2& outPan);

private:
    void createFramebuffer(int width, int height);
    void createShaders();

    GLuint fboID = 0;
    GLuint fboTextureID = 0;
    GLuint rboDepthID = 0; // Renderbuffer for depth testing
    GLuint shaderProgramID = 0;

    int textureWidth = 0;
    int textureHeight = 0;
    
    bool m_isInitialized = false; // Track if setup has been called
    float m_zoom = 10.0f; // Zoom level for orthographic projection
    glm::vec2 m_pan = { 0.0f, 0.0f }; // Pan offset for orthographic projection
    glm::vec3 m_viewRotation = { 0.0f, 0.0f, 0.0f }; // View rotation angles in radians
};



================================================================================
FILE: juce\Source\animation\AnimationRenderer.cpp
================================================================================


#include "AnimationRenderer.h"
#include <juce_core/juce_core.h>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <limits>

// Use JUCE's OpenGL extension wrapper - this provides all the modern OpenGL functions
using namespace juce::gl;

// --- GLSL Shader Source Code ---

const char* vertexShaderSource = R"glsl(
    #version 330 core
    layout (location = 0) in vec3 aPos;

    uniform mat4 projection;
    uniform mat4 boneMatrices[100]; // Max 100 bones

    void main()
    {
        // For simplicity, we assume the input position is the bone's position
        // and its index is passed via gl_VertexID.
        mat4 boneTransform = boneMatrices[gl_VertexID];
        gl_Position = projection * boneTransform * vec4(0.0, 0.0, 0.0, 1.0);
        gl_PointSize = 10.0;  // Set point size in shader
    }
)glsl";

const char* fragmentShaderSource = R"glsl(
    #version 330 core
    out vec4 FragColor;

    void main()
    {
        FragColor = vec4(1.0, 1.0, 1.0, 1.0); // White
    }
)glsl";

AnimationRenderer::AnimationRenderer()
{
}

AnimationRenderer::~AnimationRenderer()
{
    if (shaderProgramID != 0)
        glDeleteProgram(shaderProgramID);
    if (fboTextureID != 0)
        glDeleteTextures(1, &fboTextureID);
    if (rboDepthID != 0)
        glDeleteRenderbuffers(1, &rboDepthID);
    if (fboID != 0)
        glDeleteFramebuffers(1, &fboID);
}

void AnimationRenderer::setup(int width, int height)
{
    if (m_isInitialized)
        return;

    createShaders();
    createFramebuffer(width, height);
    m_isInitialized = true;
}

void AnimationRenderer::render(const std::vector<glm::mat4>& finalBoneMatrices)
{
    if (finalBoneMatrices.empty() || shaderProgramID == 0)
        return;

    // --- SAVE IMGUI'S OPENGL STATE ---
    GLint last_program;
    glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);
    GLint last_texture;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    GLint last_array_buffer;
    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    GLint last_viewport[4];
    glGetIntegerv(GL_VIEWPORT, last_viewport);
    GLint last_scissor_box[4];
    glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);

    // --- CONFIGURE OPENGL FOR OUR FBO ---
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);
    glViewport(0, 0, textureWidth, textureHeight);
    glDisable(GL_SCISSOR_TEST); // We want to clear and draw to the whole FBO

    // Clear the framebuffer
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // --- DRAW OUR SCENE ---
    glUseProgram(shaderProgramID);

    // 1. Set up orthographic projection matrix (zoom and pan controlled by m_zoom and m_pan)
    glm::mat4 projection = glm::ortho(
        -m_zoom + m_pan.x, m_zoom + m_pan.x,
        -m_zoom + m_pan.y, m_zoom + m_pan.y,
        -10.0f, 10.0f
    );

    // 2. Create the view matrix from our rotation angles
    glm::mat4 view = glm::mat4(1.0f);
    view = glm::rotate(view, m_viewRotation.x, glm::vec3(1.0f, 0.0f, 0.0f)); // X-axis rotation
    view = glm::rotate(view, m_viewRotation.y, glm::vec3(0.0f, 1.0f, 0.0f)); // Y-axis rotation
    view = glm::rotate(view, m_viewRotation.z, glm::vec3(0.0f, 0.0f, 1.0f)); // Z-axis rotation

    // 3. Combine them into a final projection-view matrix
    glm::mat4 projectionView = projection * view;

    // 4. Send the combined matrix to the shader's 'projection' uniform
    glUniformMatrix4fv(glGetUniformLocation(shaderProgramID, "projection"), 1, GL_FALSE, &projectionView[0][0]);

    // Send the bone matrices to the shader
    glUniformMatrix4fv(glGetUniformLocation(shaderProgramID, "boneMatrices"), 
                      static_cast<GLsizei>(finalBoneMatrices.size()), 
                      GL_FALSE, 
                      &finalBoneMatrices[0][0][0]);

    glDrawArrays(GL_POINTS, 0, static_cast<GLsizei>(finalBoneMatrices.size()));


    // --- RESTORE IMGUI'S OPENGL STATE ---
    glBindFramebuffer(GL_FRAMEBUFFER, 0); // Unbind FBO first
    glUseProgram(last_program);
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
    if (last_enable_scissor_test) {
        glEnable(GL_SCISSOR_TEST);
    }
}

void AnimationRenderer::createFramebuffer(int width, int height)
{
    textureWidth = width;
    textureHeight = height;

    glGenFramebuffers(1, &fboID);
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);

    // Create Color Texture Attachment
    glGenTextures(1, &fboTextureID);
    glBindTexture(GL_TEXTURE_2D, fboTextureID);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fboTextureID, 0);

    // Create Depth Renderbuffer Attachment
    glGenRenderbuffers(1, &rboDepthID);
    glBindRenderbuffer(GL_RENDERBUFFER, rboDepthID);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, width, height);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepthID);

    // Check if framebuffer is complete
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        DBG("ERROR::FRAMEBUFFER:: Framebuffer is not complete!");

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void AnimationRenderer::createShaders()
{
    // Compile Vertex Shader
    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vs, 1, &vertexShaderSource, NULL);
    glCompileShader(vs);
    
    // Check for vertex shader compile errors
    GLint success;
    GLchar infoLog[512];
    glGetShaderiv(vs, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(vs, 512, NULL, infoLog);
        DBG("ERROR::SHADER::VERTEX::COMPILATION_FAILED: " + juce::String(infoLog));
    }

    // Compile Fragment Shader
    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fs, 1, &fragmentShaderSource, NULL);
    glCompileShader(fs);
    
    // Check for fragment shader compile errors
    glGetShaderiv(fs, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(fs, 512, NULL, infoLog);
        DBG("ERROR::SHADER::FRAGMENT::COMPILATION_FAILED: " + juce::String(infoLog));
    }

    // Link Shaders into a Program
    shaderProgramID = glCreateProgram();
    glAttachShader(shaderProgramID, vs);
    glAttachShader(shaderProgramID, fs);
    glLinkProgram(shaderProgramID);
    
    // Check for linking errors
    glGetProgramiv(shaderProgramID, GL_LINK_STATUS, &success);
    if (!success)
    {
        glGetProgramInfoLog(shaderProgramID, 512, NULL, infoLog);
        DBG("ERROR::SHADER::PROGRAM::LINKING_FAILED: " + juce::String(infoLog));
    }

    glDeleteShader(vs);
    glDeleteShader(fs);
}

void AnimationRenderer::frameView(const std::vector<glm::mat4>& boneMatrices, float& outZoom, glm::vec2& outPan)
{
    if (boneMatrices.empty())
        return;

    // Find the bounding box of all bone positions
    glm::vec2 minPoint(std::numeric_limits<float>::max());
    glm::vec2 maxPoint(std::numeric_limits<float>::lowest());

    for (const auto& matrix : boneMatrices)
    {
        glm::vec3 position = matrix[3]; // Position is in the 4th column

        // === START FIX: Ignore bones at or very near the origin ===
        // This prevents non-skeleton helper nodes from ruining the auto-frame.
        if (glm::length(position) < 0.001f)
        {
            continue; // Skip this bone
        }
        // === END FIX ===

        minPoint.x = std::min(minPoint.x, position.x);
        minPoint.y = std::min(minPoint.y, position.y);
        maxPoint.x = std::max(maxPoint.x, position.x);
        maxPoint.y = std::max(maxPoint.y, position.y);
    }

    // Calculate the center of the bounding box
    outPan = (minPoint + maxPoint) * 0.5f;

    // Calculate the size needed to contain the bounding box
    glm::vec2 size = maxPoint - minPoint;
    float requiredZoom = glm::max(size.x, size.y) * 0.5f;

    // Set the zoom with a little padding
    outZoom = requiredZoom * 1.1f;
}



================================================================================
FILE: juce\Source\animation\Animator.h
================================================================================


#pragma once

#include <vector>
#include <string>
#include "AnimationData.h"
#include <glm/glm.hpp>
#include <juce_core/juce_core.h> // For JUCE_ASSERT

class Animator
{
public:
    Animator(AnimationData* animationData);

    void Update(float deltaTime);
    void PlayAnimation(const std::string& animationName);
    void SetAnimationSpeed(float speed) { m_AnimationSpeed = speed; }

    const std::vector<glm::mat4>& GetFinalBoneMatrices() const { return m_FinalBoneMatrices; }
    const std::vector<glm::mat4>& GetBoneWorldTransforms() const { return m_BoneWorldTransforms; }
    const AnimationData* GetAnimationData() const { return m_AnimationData; }
    float GetCurrentTime() const { return m_CurrentTime; }
    const AnimationClip* GetCurrentAnimation() const { return m_CurrentAnimation; }

private:
    glm::vec3 InterpolatePosition(float animationTime, const std::vector<KeyPosition>& keyframes, const glm::vec3& defaultPos);
    glm::quat InterpolateRotation(float animationTime, const std::vector<KeyRotation>& keyframes, const glm::quat& defaultRot);
    glm::vec3 InterpolateScale(float animationTime, const std::vector<KeyScale>& keyframes, const glm::vec3& defaultScale);
    void CalculateBoneTransform(NodeData* node, const glm::mat4& parentTransform);
    void LinkBoneAnimationsToNodes(NodeData* node); // Pre-link animations to nodes (called on main thread)

    std::vector<glm::mat4> m_FinalBoneMatrices; // For skinning (includes offset matrix)
    std::vector<glm::mat4> m_BoneWorldTransforms; // For visualization (world positions only)
    AnimationData* m_AnimationData;
    AnimationClip* m_CurrentAnimation;
    float m_CurrentTime;
    float m_AnimationSpeed;
};


================================================================================
FILE: juce\Source\animation\Animator.cpp
================================================================================


#define GLM_ENABLE_EXPERIMENTAL
#include "Animator.h"
#include <glm/gtx/matrix_decompose.hpp>
#include <glm/gtx/quaternion.hpp>

Animator::Animator(AnimationData* animationData) {
    m_CurrentTime = 0.0;
    m_AnimationData = animationData;
    m_CurrentAnimation = nullptr;
    m_AnimationSpeed = 1.0f;
    if(m_AnimationData && !m_AnimationData->boneInfoMap.empty()) {
        m_FinalBoneMatrices.resize(m_AnimationData->boneInfoMap.size(), glm::mat4(1.0f));
        m_BoneWorldTransforms.resize(m_AnimationData->boneInfoMap.size(), glm::mat4(1.0f));
    }
}

void Animator::PlayAnimation(const std::string& animationName) {
    if(!m_AnimationData) return;
    for (auto& clip : m_AnimationData->animationClips) {
        if (clip.name == animationName) {
            m_CurrentAnimation = &clip;
            m_CurrentTime = 0.0f;
            
            // Pre-link bone animations to nodes (MAIN THREAD ONLY - string operations here!)
            // This eliminates ALL string lookups in the audio thread
            LinkBoneAnimationsToNodes(&m_AnimationData->rootNode);
            return;
        }
    }
}

// Recursively pre-link bone animations to node tree (called on main thread)
void Animator::LinkBoneAnimationsToNodes(NodeData* node) {
    if (!node || !m_CurrentAnimation) return;
    
    // Try to find a bone animation for this node
    if (m_CurrentAnimation->boneAnimations.count(node->name)) {
        node->currentBoneAnimation = &m_CurrentAnimation->boneAnimations[node->name];
    } else {
        node->currentBoneAnimation = nullptr;
    }
    
    // Recurse to children
    for (auto& child : node->children) {
        LinkBoneAnimationsToNodes(&child);
    }
}

void Animator::Update(float deltaTime) {
    // NO LOGGING ALLOWED HERE - called from audio thread!
    if (!m_AnimationData || !m_CurrentAnimation || m_CurrentAnimation->durationInTicks <= 0.0f) 
    {
        return;
    }
    
    m_CurrentTime += m_CurrentAnimation->ticksPerSecond * deltaTime * m_AnimationSpeed;
    m_CurrentTime = fmod(m_CurrentTime, m_CurrentAnimation->durationInTicks);
    
    CalculateBoneTransform(&m_AnimationData->rootNode, glm::mat4(1.0f));
}

void Animator::CalculateBoneTransform(NodeData* node, const glm::mat4& parentTransform) {
    if(!node) return;

    BoneAnimation* boneAnim = node->currentBoneAnimation;
    glm::mat4 nodeTransform; // This will hold the final local transform for this node.

    // === START: THE DEFINITIVE FIX ===
    // If there is an active animation clip affecting this specific bone...
    if (boneAnim)
    {
        // ...then we decompose the bone's base transform, apply the animation keyframes,
        // and recompose a new transform matrix for this frame.
        glm::vec3 scale, translation;
        glm::quat rotation;
        glm::vec3 skew;
        glm::vec4 perspective;
        glm::decompose(node->transformation, scale, rotation, translation, skew, perspective);

        // These calls are safe even if a track (e.g., scale) is missing from the animation
        translation = InterpolatePosition(m_CurrentTime, boneAnim->positions, translation);
        rotation    = InterpolateRotation(m_CurrentTime, boneAnim->rotations, rotation);
        scale       = InterpolateScale(m_CurrentTime, boneAnim->scales, scale);
        
        nodeTransform = glm::translate(glm::mat4(1.0f), translation) * glm::toMat4(rotation) * glm::scale(glm::mat4(1.0f), scale);
    }
    else
    {
        // ...otherwise, if this bone is NOT animated, we use its original, unmodified
        // transformation matrix. This prevents the decompose/recompose cycle that was
        // corrupting the transforms by introducing accumulating floating-point errors.
        nodeTransform = node->transformation;
    }
    // === END: THE DEFINITIVE FIX ===

    glm::mat4 globalTransform = parentTransform * nodeTransform;

    // Use pre-linked bone index and offset matrix (NO string operations!)
    if (node->boneIndex >= 0 && node->boneIndex < m_FinalBoneMatrices.size())
    {
        // Store world transform for visualization (without offset matrix)
        m_BoneWorldTransforms[node->boneIndex] = globalTransform;
        // Apply the offset matrix to get the final skinning transform
        m_FinalBoneMatrices[node->boneIndex] = globalTransform * node->offsetMatrix;
    }

    for (auto& child : node->children) {
        CalculateBoneTransform(&child, globalTransform);
    }
}

// --- Interpolation Helpers ---
glm::vec3 Animator::InterpolatePosition(float animationTime, const std::vector<KeyPosition>& keyframes, const glm::vec3& defaultPos) {
    if (keyframes.empty()) return defaultPos;
    if (keyframes.size() == 1) return keyframes[0].position;
    
    int p0Index = 0;
    if (animationTime >= keyframes.back().timeStamp) return keyframes.back().position;
    for (size_t i = 0; i < keyframes.size() - 1; ++i) {
        if (animationTime < keyframes[i + 1].timeStamp) { p0Index = i; break; }
    }
    int p1Index = p0Index + 1;
    if (p1Index >= keyframes.size()) return keyframes[p0Index].position;

    float p1Time = keyframes[p1Index].timeStamp;
    float p0Time = keyframes[p0Index].timeStamp;
    float scaleFactor = (p1Time - p0Time > 0.0f) ? (animationTime - p0Time) / (p1Time - p0Time) : 0.0f;
    return glm::mix(keyframes[p0Index].position, keyframes[p1Index].position, scaleFactor);
}

glm::quat Animator::InterpolateRotation(float animationTime, const std::vector<KeyRotation>& keyframes, const glm::quat& defaultRot) {
    if (keyframes.empty()) return defaultRot;
    if (keyframes.size() == 1) return glm::normalize(keyframes[0].orientation);

    int p0Index = 0;
    if (animationTime >= keyframes.back().timeStamp) return glm::normalize(keyframes.back().orientation);
    for (size_t i = 0; i < keyframes.size() - 1; ++i) {
        if (animationTime < keyframes[i + 1].timeStamp) { p0Index = i; break; }
    }
    int p1Index = p0Index + 1;
    if (p1Index >= keyframes.size()) return glm::normalize(keyframes[p0Index].orientation);

    float p1Time = keyframes[p1Index].timeStamp;
    float p0Time = keyframes[p0Index].timeStamp;
    float scaleFactor = (p1Time - p0Time > 0.0f) ? (animationTime - p0Time) / (p1Time - p0Time) : 0.0f;
    return glm::normalize(glm::slerp(keyframes[p0Index].orientation, keyframes[p1Index].orientation, scaleFactor));
}

glm::vec3 Animator::InterpolateScale(float animationTime, const std::vector<KeyScale>& keyframes, const glm::vec3& defaultScale) {
    if (keyframes.empty()) return defaultScale;
    if (keyframes.size() == 1) return keyframes[0].scale;

    int p0Index = 0;
    if (animationTime >= keyframes.back().timeStamp) return keyframes.back().scale;
    for (size_t i = 0; i < keyframes.size() - 1; ++i) {
        if (animationTime < keyframes[i + 1].timeStamp) { p0Index = i; break; }
    }
    int p1Index = p0Index + 1;
    if (p1Index >= keyframes.size()) return keyframes[p0Index].scale;

    float p1Time = keyframes[p1Index].timeStamp;
    float p0Time = keyframes[p0Index].timeStamp;
    float scaleFactor = (p1Time - p0Time > 0.0f) ? (animationTime - p0Time) / (p1Time - p0Time) : 0.0f;
    return glm::mix(keyframes[p0Index].scale, keyframes[p1Index].scale, scaleFactor);
}


================================================================================
FILE: juce\Source\animation\GltfLoader.h
================================================================================


#pragma once

#include <string>
#include <memory>
#include "RawAnimationData.h"

class GltfLoader
{
public:
    // The main public function to load raw animation data from a file.
    // Returns simple, pointer-free data that must be processed by AnimationBinder.
    static std::unique_ptr<RawAnimationData> LoadFromFile(const std::string& filePath);
};



================================================================================
FILE: juce\Source\animation\GltfLoader.cpp
================================================================================


#define GLM_ENABLE_EXPERIMENTAL

#include "GltfLoader.h"
#include "tiny_gltf.h"
#include <iostream>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/quaternion.hpp>
#include <juce_core/juce_core.h>

// --- Helper function declarations ---
static void ParseNodes(const tinygltf::Model& model, RawAnimationData& outData);
static void ParseSkins(const tinygltf::Model& model, RawAnimationData& outData);
static void ParseAnimations(const tinygltf::Model& model, RawAnimationData& outData);

template <typename T>
static void ReadDataFromBuffer(const tinygltf::Model& model, int accessorIndex, std::vector<T>& outData);

static glm::mat4 GetMatrix(const tinygltf::Node& node);
static glm::vec3 GetVec3(const std::vector<double>& vec);
static glm::quat GetQuat(const std::vector<double>& vec);
// --- End of helpers ---

std::unique_ptr<RawAnimationData> GltfLoader::LoadFromFile(const std::string& filePath)
{
    juce::Logger::writeToLog("GltfLoader: Starting to load " + juce::String(filePath));
    tinygltf::Model model;
    tinygltf::TinyGLTF loader;
    std::string err;
    std::string warn;

    bool success = false;
    if (filePath.substr(filePath.length() - 4) == ".glb") {
        juce::Logger::writeToLog("GltfLoader: Loading as Binary (.glb)");
        success = loader.LoadBinaryFromFile(&model, &err, &warn, filePath);
    } else {
        juce::Logger::writeToLog("GltfLoader: Loading as ASCII (.gltf)");
        success = loader.LoadASCIIFromFile(&model, &err, &warn, filePath);
    }

    if (!warn.empty()) juce::Logger::writeToLog("GltfLoader WARNING: " + juce::String(warn));
    if (!err.empty()) juce::Logger::writeToLog("GltfLoader ERROR: " + juce::String(err));
    if (!success) {
        juce::Logger::writeToLog("GltfLoader: FAILED to parse file with tinygltf.");
        return nullptr;
    }
    juce::Logger::writeToLog("GltfLoader: Successfully parsed with tinygltf.");

    auto rawData = std::make_unique<RawAnimationData>();

    ParseNodes(model, *rawData);
    ParseSkins(model, *rawData);
    ParseAnimations(model, *rawData);
    
    juce::Logger::writeToLog("GltfLoader: Finished creating RawAnimationData.");
    
    // --- VALIDATION STEP ---
    // Verify the data integrity before returning it
    std::string validationError;
    if (!RawAnimationData::validate(*rawData, validationError))
    {
        // Validation failed - log the specific error and return nullptr
        juce::Logger::writeToLog("GltfLoader ERROR: Raw data validation failed for file: " + juce::String(filePath));
        juce::Logger::writeToLog("Validation message: " + juce::String(validationError));
        
        // Return nullptr to signal that loading has failed
        return nullptr;
    }
    
    juce::Logger::writeToLog("GltfLoader: Raw data validated successfully.");
    // --- END OF VALIDATION STEP ---
    
    return rawData;
}


// --- Implementation of Helper Functions ---

void ParseNodes(const tinygltf::Model& model, RawAnimationData& outData)
{
    outData.nodes.resize(model.nodes.size());

    for (size_t i = 0; i < model.nodes.size(); ++i)
    {
        const auto& inputNode = model.nodes[i];
        auto& outputNode = outData.nodes[i];

        outputNode.name = inputNode.name;
        outputNode.localTransform = GetMatrix(inputNode);

        for (int childIndex : inputNode.children) {
            outputNode.childIndices.push_back(childIndex);
            // Set the parent index for the child node (with bounds checking)
            // childIndex must be valid (>= 0 and < size)
            if(childIndex >= 0 && childIndex < static_cast<int>(outData.nodes.size()))
                outData.nodes[childIndex].parentIndex = i;
        }
    }
}

void ParseSkins(const tinygltf::Model& model, RawAnimationData& outData)
{
    if (!model.skins.empty())
    {
        juce::Logger::writeToLog("GltfLoader: Found explicit skin data. Parsing bones from skin.");
        const auto& skin = model.skins[0];
        outData.bones.resize(skin.joints.size());

        std::vector<glm::mat4> inverseBindMatrices;
        ReadDataFromBuffer(model, skin.inverseBindMatrices, inverseBindMatrices);

        for (size_t i = 0; i < skin.joints.size(); ++i)
        {
            int jointNodeIndex = skin.joints[i];
            const auto& jointNode = model.nodes[jointNodeIndex];
            
            auto& boneInfo = outData.bones[i];
            boneInfo.id = i;
            boneInfo.name = jointNode.name;
            boneInfo.offsetMatrix = inverseBindMatrices[i];
        }
    }
    else
    {
        juce::Logger::writeToLog("GltfLoader: No skin data found. Using fallback: creating bones from animation targets.");
        // FALLBACK: Create bones from any node that is animated.
        std::map<std::string, int> boneNameMap;
        for (const auto& anim : model.animations) {
            for (const auto& channel : anim.channels) {
                // Bounds check the target node index
                if (channel.target_node < 0 || channel.target_node >= static_cast<int>(model.nodes.size()))
                    continue;
                    
                std::string boneName = model.nodes[channel.target_node].name;
                
                // Skip nodes with empty names
                if (boneName.empty()) {
                    boneName = "gltf_bone_" + std::to_string(channel.target_node);
                    juce::Logger::writeToLog("GltfLoader: Animation target node " + juce::String(channel.target_node) + 
                                           " has empty name. Assigning default name '" + juce::String(boneName) + "'.");
                }
                
                // === START FIX: Only add nodes that look like they belong to a rig ===
                // This is a heuristic to filter out cameras, lights, etc.
                // It checks for common rig naming conventions.
                if (!(boneName.rfind("_1:", 0) == 0 || boneName.rfind("mixamorig:", 0) == 0 || boneName.rfind("gltf_bone_", 0) == 0))
                {
                    juce::Logger::writeToLog("GltfLoader: Skipping non-rig animated node: '" + juce::String(boneName) + "'");
                    continue; // Skip this node
                }
                // === END FIX ===
                
                if (boneNameMap.find(boneName) == boneNameMap.end()) {
                    boneNameMap[boneName] = outData.bones.size();
                    RawBoneInfo boneInfo;
                    boneInfo.id = boneNameMap[boneName];
                    boneInfo.name = boneName;
                    boneInfo.offsetMatrix = glm::mat4(1.0f); // Default to identity matrix
                    outData.bones.push_back(boneInfo);
                }
            }
        }
        juce::Logger::writeToLog("GltfLoader: Fallback created " + juce::String(outData.bones.size()) + " bones from animation data.");
    }
}

void ParseAnimations(const tinygltf::Model& model, RawAnimationData& outData)
{
    for (const auto& anim : model.animations)
    {
        RawAnimationClip clip;
        clip.name = anim.name;
        float maxTimestamp = 0.0f;

        for (const auto& channel : anim.channels)
        {
            // Bounds check the target node index
            if (channel.target_node < 0 || channel.target_node >= static_cast<int>(model.nodes.size()))
            {
                juce::Logger::writeToLog("GltfLoader WARNING: Skipping animation channel in clip '" + 
                                       juce::String(clip.name) + "' because target_node index " + 
                                       juce::String(channel.target_node) + " is out of bounds.");
                continue;
            }
            
            const auto& sampler = anim.samplers[channel.sampler];
            std::string boneName = model.nodes[channel.target_node].name;
            
            // Skip nodes with empty names
            if (boneName.empty())
            {
                boneName = "gltf_bone_" + std::to_string(channel.target_node);
                juce::Logger::writeToLog("GltfLoader WARNING: Animation channel in clip '" + 
                                       juce::String(clip.name) + "' targets node " + 
                                       juce::String(channel.target_node) + " with no name. Using default name '" +
                                       juce::String(boneName) + "'.");
            }
            
            RawBoneAnimation& boneAnim = clip.boneAnimations[boneName];
            boneAnim.boneName = boneName;

            std::vector<float> timestampsFloat;
            ReadDataFromBuffer(model, sampler.input, timestampsFloat);

            if (!timestampsFloat.empty()) maxTimestamp = std::max(maxTimestamp, timestampsFloat.back());

            // THIS IS THE FIX: Only assign timestamps and values to the correct track.
            if (channel.target_path == "translation")
            {
                boneAnim.positions.keyframeTimes.assign(timestampsFloat.begin(), timestampsFloat.end());
                std::vector<glm::vec3> values;
                ReadDataFromBuffer(model, sampler.output, values);
                for(const auto& v : values) boneAnim.positions.keyframeValues.emplace_back(v, 0.0f);
            }
            else if (channel.target_path == "rotation")
            {
                boneAnim.rotations.keyframeTimes.assign(timestampsFloat.begin(), timestampsFloat.end());
                std::vector<glm::quat> values;
                ReadDataFromBuffer(model, sampler.output, values);
                for(const auto& v : values) boneAnim.rotations.keyframeValues.emplace_back(v.x, v.y, v.z, v.w);
            }
            else if (channel.target_path == "scale")
            {
                boneAnim.scales.keyframeTimes.assign(timestampsFloat.begin(), timestampsFloat.end());
                std::vector<glm::vec3> values;
                ReadDataFromBuffer(model, sampler.output, values);
                for(const auto& v : values) boneAnim.scales.keyframeValues.emplace_back(v, 0.0f);
            }
        }
        clip.duration = maxTimestamp;
        outData.clips.push_back(clip);
    }
}


template <typename T>
void ReadDataFromBuffer(const tinygltf::Model& model, int accessorIndex, std::vector<T>& outData)
{
    const auto& accessor = model.accessors[accessorIndex];
    const auto& bufferView = model.bufferViews[accessor.bufferView];
    const auto& buffer = model.buffers[bufferView.buffer];
    const unsigned char* dataPtr = buffer.data.data() + bufferView.byteOffset + accessor.byteOffset;
    size_t numElements = accessor.count;
    outData.resize(numElements);
    memcpy(outData.data(), dataPtr, numElements * sizeof(T));
}

glm::mat4 GetMatrix(const tinygltf::Node& node)
{
    if (node.matrix.size() == 16) return glm::make_mat4(node.matrix.data());
    glm::vec3 t = node.translation.empty() ? glm::vec3(0.0f) : GetVec3(node.translation);
    glm::quat r = node.rotation.empty() ? glm::quat(1.0f, 0.0f, 0.0f, 0.0f) : GetQuat(node.rotation);
    glm::vec3 s = node.scale.empty() ? glm::vec3(1.0f) : GetVec3(node.scale);
    return glm::translate(glm::mat4(1.0f), t) * glm::toMat4(r) * glm::scale(glm::mat4(1.0f), s);
}

glm::vec3 GetVec3(const std::vector<double>& vec) { return { (float)vec[0], (float)vec[1], (float)vec[2] }; }
glm::quat GetQuat(const std::vector<double>& vec) { return { (float)vec[3], (float)vec[0], (float)vec[1], (float)vec[2] }; }


================================================================================
FILE: juce\Source\animation\FbxLoader.h
================================================================================


#pragma once

#include "RawAnimationData.h"
#include <string>
#include <memory>

class FbxLoader
{
public:
    // Change the return type from AnimationData to RawAnimationData
    static std::unique_ptr<RawAnimationData> LoadFromFile(const std::string& filePath);
};


================================================================================
FILE: juce\Source\animation\FbxLoader.cpp
================================================================================


#define GLM_ENABLE_EXPERIMENTAL

#include "FbxLoader.h"
#include <ufbx.h>
#include <iostream>
#include <map>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/quaternion.hpp>
#include <juce_core/juce_core.h>

// Helper to convert ufbx transform to glm::mat4
static glm::mat4 ToGlmMat4(const ufbx_transform& t)
{
    glm::vec3 translation(t.translation.x, t.translation.y, t.translation.z);
    // ufbx provides rotation as a quaternion directly. Use it.
    glm::quat rotation(t.rotation.w, t.rotation.x, t.rotation.y, t.rotation.z);
    glm::vec3 scale(t.scale.x, t.scale.y, t.scale.z);

    return glm::translate(glm::mat4(1.0f), translation) *
           glm::toMat4(rotation) *
           glm::scale(glm::mat4(1.0f), scale);
}

std::unique_ptr<RawAnimationData> FbxLoader::LoadFromFile(const std::string& filePath)
{
    juce::Logger::writeToLog("FbxLoader: Starting to load " + juce::String(filePath));
    ufbx_load_opts opts = {};
    opts.target_axes.up = UFBX_COORDINATE_AXIS_POSITIVE_Y;
    opts.target_axes.front = UFBX_COORDINATE_AXIS_POSITIVE_Z;
    opts.target_axes.right = UFBX_COORDINATE_AXIS_POSITIVE_X;
    opts.target_unit_meters = 1.0;

    ufbx_error error;
    ufbx_scene* scene = ufbx_load_file(filePath.c_str(), &opts, &error);

    if (!scene) {
        juce::Logger::writeToLog("FbxLoader ERROR: " + juce::String(error.description.data));
        return nullptr;
    }
    juce::Logger::writeToLog("FbxLoader: Successfully parsed with ufbx.");

    auto rawData = std::make_unique<RawAnimationData>();
    std::map<uint32_t, int> nodeIdToIndexMap;

    // --- 1. Parse All Nodes ---
    juce::Logger::writeToLog("FbxLoader: Parsing " + juce::String(scene->nodes.count) + " nodes...");
    for (size_t i = 0; i < scene->nodes.count; ++i) {
        ufbx_node* ufbNode = scene->nodes.data[i];
        if (!ufbNode) continue;
        
        nodeIdToIndexMap[ufbNode->element_id] = rawData->nodes.size();
        RawNodeData node;
        node.name = ufbNode->name.data;
        
        // If the node's name is empty, give it a default name.
        // This is common for the implicit root node in some FBX files.
        if (node.name.empty())
        {
            node.name = "fbx_node_" + std::to_string(i);
            juce::Logger::writeToLog("FbxLoader: Found node with empty name at index " + juce::String(i) + ". Assigning default name '" + juce::String(node.name) + "'.");
        }
        
        // Use the local transform from the node
        node.localTransform = ToGlmMat4(ufbNode->local_transform);
        
        rawData->nodes.push_back(node);
    }

    // --- 2. Link Node Parents/Children ---
    for (size_t i = 0; i < scene->nodes.count; ++i) {
         ufbx_node* ufbNode = scene->nodes.data[i];
         if (!ufbNode || !ufbNode->parent) continue;

         if (nodeIdToIndexMap.count(ufbNode->parent->element_id)) {
            int parentIndex = nodeIdToIndexMap[ufbNode->parent->element_id];
            // Validate parentIndex before using it to access arrays
            if (parentIndex >= 0 && parentIndex < static_cast<int>(rawData->nodes.size())) {
                rawData->nodes[i].parentIndex = parentIndex;
                rawData->nodes[parentIndex].childIndices.push_back(i);
            }
         }
    }

    // --- 3. Parse Bones (with robust fallback) ---
    std::map<std::string, int> boneNameMap;
    
    juce::Logger::writeToLog("FbxLoader: Checking for skin data... (skin_deformers.count = " + juce::String(scene->skin_deformers.count) + ")");
    
    if (scene->skin_deformers.count > 0) 
    {
        juce::Logger::writeToLog("FbxLoader: Found explicit skin data. Parsing bones from skin deformers.");
        ufbx_skin_deformer* skin = scene->skin_deformers.data[0];
        juce::Logger::writeToLog("FbxLoader: Skin has " + juce::String(skin->clusters.count) + " clusters.");
        
        for (size_t i = 0; i < skin->clusters.count; ++i) {
            ufbx_skin_cluster* cluster = skin->clusters.data[i];
            if (!cluster || !cluster->bone_node) continue;
            
            std::string boneName = cluster->bone_node->name.data;

            if (boneNameMap.find(boneName) == boneNameMap.end()) {
                boneNameMap[boneName] = rawData->bones.size();
                RawBoneInfo boneInfo;
                boneInfo.id = rawData->bones.size();
                boneInfo.name = boneName;
                boneInfo.offsetMatrix = glm::transpose(glm::make_mat4(&cluster->geometry_to_bone.m00));
                rawData->bones.push_back(boneInfo);
                juce::Logger::writeToLog("FbxLoader: Found skin bone #" + juce::String(boneInfo.id) + ": " + juce::String(boneName));
            }
        }
    }
    else 
    {
        juce::Logger::writeToLog("FbxLoader: No skin data found. Using fallback: creating bones from animation targets.");
        juce::Logger::writeToLog("FbxLoader: Animation stacks count: " + juce::String(scene->anim_stacks.count));
        
        for (size_t i = 0; i < scene->anim_stacks.count; ++i) {
            ufbx_anim_stack* stack = scene->anim_stacks.data[i];
            if (!stack || !stack->anim) continue;
            
            ufbx_anim* anim = stack->anim;
            juce::Logger::writeToLog("FbxLoader: Animation stack '" + juce::String(stack->name.data) + "' has " + juce::String(anim->layers.count) + " layers.");
            
            // Use anim->layers approach (more reliable for some FBX files)
            for (size_t j = 0; j < anim->layers.count; ++j) {
                ufbx_anim_layer* layer = anim->layers.data[j];
                if (!layer) continue;
                
                for (size_t k = 0; k < layer->anim_props.count; ++k) {
                    ufbx_anim_prop* prop = &layer->anim_props.data[k];
                    if (!prop->anim_value || !prop->element) continue;
                    
                    ufbx_node* node = ufbx_as_node(prop->element);
                    if (!node) continue;
                    
                    std::string boneName = node->name.data;
                    if (boneName.empty()) continue;

                    // === START FIX: Only add nodes that look like they belong to a rig ===
                    // This is a heuristic to filter out cameras, lights, etc.
                    // It checks for common rig naming conventions.
                    if (!(boneName.rfind("_1:", 0) == 0 || boneName.rfind("mixamorig:", 0) == 0))
                    {
                        juce::Logger::writeToLog("FbxLoader: Skipping non-rig animated node: '" + juce::String(boneName) + "'");
                        continue; // Skip this node
                    }
                    // === END FIX ===

                    if (boneNameMap.find(boneName) == boneNameMap.end()) {
                        boneNameMap[boneName] = rawData->bones.size();
                        RawBoneInfo boneInfo;
                        boneInfo.id = rawData->bones.size();
                        boneInfo.name = boneName;
                        boneInfo.offsetMatrix = glm::mat4(1.0f);
                        rawData->bones.push_back(boneInfo);
                        juce::Logger::writeToLog("FbxLoader: Created fallback bone #" + juce::String(boneInfo.id) + ": " + juce::String(boneName));
                    }
                }
            }
        }
    }
    
    juce::Logger::writeToLog("FbxLoader: Total bones found: " + juce::String(rawData->bones.size()));
    
    // --- DEBUG: Validate node structure ---
    juce::Logger::writeToLog("FbxLoader: Validating node structure...");
    int nodesWithoutParent = 0;
    for (size_t i = 0; i < rawData->nodes.size(); ++i) {
        if (rawData->nodes[i].parentIndex == -1) {
            nodesWithoutParent++;
            juce::Logger::writeToLog("FbxLoader: Root node found: " + juce::String(rawData->nodes[i].name));
        }
    }
    juce::Logger::writeToLog("FbxLoader: Found " + juce::String(nodesWithoutParent) + " root nodes in hierarchy.");

    // --- 4. Parse Animations ---
    juce::Logger::writeToLog("FbxLoader: Parsing animations...");
    for (size_t i = 0; i < scene->anim_stacks.count; ++i) {
        ufbx_anim_stack* stack = scene->anim_stacks.data[i];
        if (!stack || !stack->anim) continue;
        
        ufbx_anim* anim = stack->anim;
        RawAnimationClip clip;
        clip.name = stack->name.data;
        clip.duration = anim->time_end;
        
        juce::Logger::writeToLog("FbxLoader: Processing animation '" + juce::String(clip.name) + "' (duration: " + juce::String(clip.duration) + "s)");

        for (size_t j = 0; j < anim->layers.count; ++j) {
            ufbx_anim_layer* layer = anim->layers.data[j];
            if (!layer) continue;
            
            for (size_t k = 0; k < layer->anim_props.count; ++k) {
                ufbx_anim_prop* prop = &layer->anim_props.data[k];
                if (!prop->anim_value || !prop->element) continue;
                
                ufbx_node* node = ufbx_as_node(prop->element);
                if (!node) continue;
                
                std::string boneName = node->name.data;
                
                // If the bone name is empty, try to look it up from our node map
                if (boneName.empty())
                {
                    // The target node might be a root node we renamed earlier
                    if (nodeIdToIndexMap.count(node->element_id))
                    {
                        int nodeIndex = nodeIdToIndexMap[node->element_id];
                        if (nodeIndex >= 0 && nodeIndex < static_cast<int>(rawData->nodes.size()))
                        {
                            boneName = rawData->nodes[nodeIndex].name;
                            juce::Logger::writeToLog("FbxLoader: Animation property targets unnamed node, resolved to '" + 
                                                   juce::String(boneName) + "' from node map.");
                        }
                    }
                }
                
                // After attempting to resolve, if it's STILL empty, skip this track
                if (boneName.empty())
                {
                    juce::Logger::writeToLog("FbxLoader WARNING: Skipping animation property for node ID " + 
                                           juce::String(node->element_id) + " because its name could not be resolved.");
                    continue; // Safely skip this animation track
                }
                
                RawBoneAnimation& boneAnim = clip.boneAnimations[boneName];
                boneAnim.boneName = boneName; // Explicitly set the bone name
                
                // Translation
                if (strcmp(prop->prop_name.data, "Lcl Translation") == 0) {
                    if (prop->anim_value->curves[0]) {
                        for (size_t m = 0; m < prop->anim_value->curves[0]->keyframes.count; ++m) {
                            double time = prop->anim_value->curves[0]->keyframes.data[m].time;
                            ufbx_vec3 value = ufbx_evaluate_anim_value_vec3(prop->anim_value, time);
                            boneAnim.positions.keyframeTimes.push_back(time);
                            boneAnim.positions.keyframeValues.push_back(glm::vec4(value.x, value.y, value.z, 0.0f));
                        }
                    }
                }
                // Rotation
                else if (strcmp(prop->prop_name.data, "Lcl Rotation") == 0) {
                    if (prop->anim_value->curves[0]) {
                        for (size_t m = 0; m < prop->anim_value->curves[0]->keyframes.count; ++m) {
                            double time = prop->anim_value->curves[0]->keyframes.data[m].time;
                            ufbx_vec3 eulerDeg = ufbx_evaluate_anim_value_vec3(prop->anim_value, time);
                            // === THE FIX: Use the rotation order from the node itself, not a fixed guess ===
                            ufbx_quat q = ufbx_euler_to_quat(eulerDeg, node->rotation_order);
                            // ==============================================================================
                            boneAnim.rotations.keyframeTimes.push_back(time);
                            boneAnim.rotations.keyframeValues.push_back(glm::vec4(q.x, q.y, q.z, q.w));
                        }
                    }
                }
                // Scale
                else if (strcmp(prop->prop_name.data, "Lcl Scaling") == 0) {
                    if (prop->anim_value->curves[0]) {
                        for (size_t m = 0; m < prop->anim_value->curves[0]->keyframes.count; ++m) {
                            double time = prop->anim_value->curves[0]->keyframes.data[m].time;
                            ufbx_vec3 value = ufbx_evaluate_anim_value_vec3(prop->anim_value, time);
                            boneAnim.scales.keyframeTimes.push_back(time);
                            boneAnim.scales.keyframeValues.push_back(glm::vec4(value.x, value.y, value.z, 0.0f));
                        }
                    }
                }
            }
        }
        rawData->clips.push_back(clip);
    }

    juce::Logger::writeToLog("FbxLoader: Finished creating RawAnimationData. Bones: " + juce::String(rawData->bones.size()) + ", Clips: " + juce::String(rawData->clips.size()));
    
    // --- VALIDATION STEP ---
    // Verify the data integrity before returning it
    std::string validationError;
    if (!RawAnimationData::validate(*rawData, validationError))
    {
        // Validation failed - log the specific error and return nullptr
        juce::Logger::writeToLog("FbxLoader ERROR: Raw data validation failed for file: " + juce::String(filePath));
        juce::Logger::writeToLog("Validation message: " + juce::String(validationError));
        
        // Free the ufbx scene before returning
        ufbx_free_scene(scene);
        
        // Return nullptr to signal that loading has failed
        return nullptr;
    }
    
    juce::Logger::writeToLog("FbxLoader: Raw data validated successfully.");
    // --- END OF VALIDATION STEP ---
    
    ufbx_free_scene(scene);
    return rawData;
}


================================================================================
FILE: juce\Source\animation\RawAnimationData.h
================================================================================


#pragma once

#include <string>
#include <vector>
#include <map>
#include <glm/glm.hpp>
#include <glm/gtc/quaternion.hpp>

// A simple, "dumb" container for a single node's raw data.
// It uses an integer index for its parent instead of a raw pointer.
struct RawNodeData
{
    std::string name;
    glm::mat4 localTransform;
    int parentIndex = -1; // -1 means it's a root node
    std::vector<int> childIndices;
};

// A simple container for a single bone's skinning data.
struct RawBoneInfo
{
    std::string name;
    glm::mat4 offsetMatrix;
    int id = 0;
};

// A simple container for a single animation track (e.g., a bone's translation).
struct RawAnimationTrack
{
    std::vector<double> keyframeTimes;
    // We use vec4 to hold either position(x,y,z), scale(x,y,z), or rotation(x,y,z,w).
    std::vector<glm::vec4> keyframeValues;
};

// A container for all the animation tracks for a single bone.
struct RawBoneAnimation
{
    std::string boneName;
    RawAnimationTrack positions;
    RawAnimationTrack rotations;
    RawAnimationTrack scales;
};

// A container for a full animation clip.
struct RawAnimationClip
{
    std::string name;
    double duration = 0.0;
    std::map<std::string, RawBoneAnimation> boneAnimations;
};

// The top-level container that holds all raw data parsed from a file.
// This object is completely self-contained and pointer-free.
struct RawAnimationData
{
    std::vector<RawNodeData> nodes;
    std::vector<RawBoneInfo> bones;
    std::vector<RawAnimationClip> clips;
    
    /**
     * @brief Validates the integrity of the raw animation data.
     * 
     * Checks for common issues that could cause crashes:
     * - Empty or missing data
     * - Invalid parent/child indices
     * - Out-of-bounds node references
     * - Malformed animation tracks
     * 
     * @param data The RawAnimationData object to validate.
     * @param outErrorMessage A string that will be populated with a detailed error message if validation fails.
     * @return True if the data is valid and safe to use, false otherwise.
     */
    static bool validate(const RawAnimationData& data, std::string& outErrorMessage);
};



================================================================================
FILE: juce\Source\animation\AnimationBinder.h
================================================================================


#pragma once

#include "RawAnimationData.h"
#include "AnimationData.h"
#include <memory>

class AnimationBinder
{
public:
    // The main public function. Takes raw data and returns a fully processed,
    // ready-to-use AnimationData object.
    static std::unique_ptr<AnimationData> Bind(const RawAnimationData& rawData);

private:
    // Private helper to recursively build the node hierarchy.
    static void BindNodesRecursive(const RawAnimationData& rawData, NodeData& parentNode, int rawNodeIndex);
};



================================================================================
FILE: juce\Source\animation\AnimationBinder.cpp
================================================================================


#include "AnimationBinder.h"
#include <stdexcept>
#include <glm/gtc/matrix_inverse.hpp>
#include <juce_core/juce_core.h>

// Forward-declarations
static void BuildNodeHierarchyRecursive(const RawAnimationData& rawData, NodeData& parentNode, int rawNodeIndex);
static void SetParentPointersRecursive(NodeData& node);
static void MapNodes(NodeData& node, std::map<std::string, NodeData*>& map);
static void CalculateGlobalInitialTransforms(NodeData& node, const glm::mat4& parentTransform, std::map<std::string, glm::mat4>& globalTransforms);
static void PreLinkBoneInfoToNodes(NodeData* node, const std::map<std::string, BoneInfo>& boneInfoMap);

std::unique_ptr<AnimationData> AnimationBinder::Bind(const RawAnimationData& rawData)
{
    juce::Logger::writeToLog("AnimationBinder: Starting bind process...");
    if (rawData.nodes.empty()) {
        juce::Logger::writeToLog("AnimationBinder ERROR: No nodes in raw data.");
        return nullptr;
    }
    
    auto animData = std::make_unique<AnimationData>();

    // === START: Universal Multi-Root Handling ===
    juce::Logger::writeToLog("AnimationBinder: Step 1 - Unifying hierarchy under a master root...");
    
    // 1. Create our own master root node. This will be the single root of our final hierarchy.
    animData->rootNode.name = "MASTER_ROOT";
    animData->rootNode.transformation = glm::mat4(1.0f);

    // 2. Iterate through ALL raw nodes and find every node that is a root (parentIndex == -1).
    int rootsFound = 0;
    for(size_t i = 0; i < rawData.nodes.size(); ++i) {
        if(rawData.nodes[i].parentIndex == -1) { 
            rootsFound++;
            juce::Logger::writeToLog("  [Binder] Found root node '" + juce::String(rawData.nodes[i].name) + "' from file. Attaching to MASTER_ROOT.");
            
            // 3. For each root found, build its entire child hierarchy and add it as a child of our master root.
            NodeData newChildRoot;
            BuildNodeHierarchyRecursive(rawData, newChildRoot, i);
            animData->rootNode.children.push_back(std::move(newChildRoot));
        }
    }

    if (rootsFound == 0) {
        juce::Logger::writeToLog("AnimationBinder ERROR: No root node found in raw data.");
        return nullptr;
    }
    
    juce::Logger::writeToLog("AnimationBinder: Successfully attached " + juce::String(rootsFound) + " root node(s) to MASTER_ROOT.");
    // === END: Universal Multi-Root Handling ===
    
    juce::Logger::writeToLog("AnimationBinder: Node hierarchy built successfully.");
    
    // CRITICAL: Set parent pointers AFTER the entire hierarchy is built
    // to avoid dangling pointers from vector reallocation
    juce::Logger::writeToLog("AnimationBinder: Setting parent pointers...");
    SetParentPointersRecursive(animData->rootNode);
    juce::Logger::writeToLog("AnimationBinder: Parent pointers set successfully.");

    // Step 2: Create a map of all NodeData pointers by name for easy lookup.
    juce::Logger::writeToLog("AnimationBinder: Step 2 - Creating node map...");
    std::map<std::string, NodeData*> nodeMap;
    MapNodes(animData->rootNode, nodeMap);
    juce::Logger::writeToLog("AnimationBinder: Node map created with " + juce::String(nodeMap.size()) + " entries.");

    // Step 3: Calculate the GLOBAL transform of ALL nodes based on the INITIAL file data.
    // This MUST be done BEFORE we start modifying any bone transforms!
    juce::Logger::writeToLog("AnimationBinder: Step 3 - Calculating global transforms from ORIGINAL file data...");
    std::map<std::string, glm::mat4> globalInitialTransforms;
    CalculateGlobalInitialTransforms(animData->rootNode, glm::mat4(1.0f), globalInitialTransforms);
    juce::Logger::writeToLog("AnimationBinder: Calculated " + juce::String(globalInitialTransforms.size()) + " global transforms.");

    // Step 4: Reconstruct the true LOCAL bind pose for every BONE.
    juce::Logger::writeToLog("AnimationBinder: Step 4 - Reconstructing bone local bind poses...");
    juce::Logger::writeToLog("=== EXECUTING LATEST AnimationBinder CODE WITH DEFENSIVE CHECKS ===");
    int reconstructedCount = 0;
    int rootBoneCount = 0;
    int skippedCount = 0;
    for (const auto& rawBone : rawData.bones) {
        
        // === START: CONDITIONAL RECONSTRUCTION CHECK ===
        // If the offset matrix is identity, it means we're using a loader fallback (no skin data).
        // In this case, we MUST trust the localTransform from the file and NOT try to reconstruct it.
        if (rawBone.offsetMatrix == glm::mat4(1.0f))
        {
            // Log that we are intentionally skipping this bone's reconstruction.
            juce::Logger::writeToLog("AnimationBinder: Skipping reconstruction for bone '" + juce::String(rawBone.name) + "' (using fallback with identity offset matrix).");
            skippedCount++;
            continue; // Skip to the next bone.
        }
        // === END: CONDITIONAL RECONSTRUCTION CHECK ===
        
        if (nodeMap.count(rawBone.name)) {
            NodeData* boneNode = nodeMap.at(rawBone.name);
            glm::mat4 globalBindPose = glm::inverse(rawBone.offsetMatrix);
            glm::mat4 localBindPose = globalBindPose;

            // Check if this is a root bone (no parent)
            if (!boneNode->parent) {
                // This is a root bone - its local pose IS its global pose
                localBindPose = globalBindPose;
                rootBoneCount++;
                juce::Logger::writeToLog("AnimationBinder: " + juce::String(rawBone.name) + " is a ROOT BONE. Using global pose as local pose.");
            } 
            else if (globalInitialTransforms.count(boneNode->parent->name)) {
                // This bone has a valid parent - calculate local pose relative to parent
                glm::mat4 parentGlobalInitial = globalInitialTransforms.at(boneNode->parent->name);
                localBindPose = glm::inverse(parentGlobalInitial) * globalBindPose;
                juce::Logger::writeToLog("AnimationBinder: " + juce::String(rawBone.name) + " local pose calculated relative to parent: " + juce::String(boneNode->parent->name));
            } 
            else {
                // Parent exists but not in global transforms map - this is unexpected
                juce::Logger::writeToLog("AnimationBinder WARNING: " + juce::String(rawBone.name) + " has parent " + juce::String(boneNode->parent->name) + " but parent not in global transforms. Using global pose as fallback.");
            }
            
            boneNode->transformation = localBindPose;
            reconstructedCount++;
        } else {
            juce::Logger::writeToLog("AnimationBinder WARNING: Bone " + juce::String(rawBone.name) + " not found in node map.");
        }
    }
    juce::Logger::writeToLog("AnimationBinder: Reconstructed " + juce::String(reconstructedCount) + " bone local bind poses (" + juce::String(rootBoneCount) + " root bones). Skipped " + juce::String(skippedCount) + " bones with identity offset matrices.");
    
    // Step 5: Copy over the simple bone and animation data.
    juce::Logger::writeToLog("AnimationBinder: Step 5 - Binding bones and clips...");
    for (const auto& rawBone : rawData.bones) {
        animData->boneInfoMap[rawBone.name] = { rawBone.id, rawBone.name, rawBone.offsetMatrix };
    }
    
    for (const auto& rawClip : rawData.clips) {
        AnimationClip clip;
        clip.name = rawClip.name;
        clip.durationInTicks = rawClip.duration;
        clip.ticksPerSecond = 1.0;
        
        for (const auto& pair : rawClip.boneAnimations) {
            const auto& rawBoneAnim = pair.second;
            BoneAnimation boneAnim;
            boneAnim.boneName = rawBoneAnim.boneName;
            
            for (size_t i = 0; i < rawBoneAnim.positions.keyframeTimes.size(); ++i) {
                boneAnim.positions.push_back({ glm::vec3(rawBoneAnim.positions.keyframeValues[i]), rawBoneAnim.positions.keyframeTimes[i] });
            }
            for (size_t i = 0; i < rawBoneAnim.rotations.keyframeTimes.size(); ++i) {
                glm::vec4 v = rawBoneAnim.rotations.keyframeValues[i];
                boneAnim.rotations.push_back({ glm::quat(v.w, v.x, v.y, v.z), rawBoneAnim.rotations.keyframeTimes[i] });
            }
            for (size_t i = 0; i < rawBoneAnim.scales.keyframeTimes.size(); ++i) {
                boneAnim.scales.push_back({ glm::vec3(rawBoneAnim.scales.keyframeValues[i]), rawBoneAnim.scales.keyframeTimes[i] });
            }
            
            clip.boneAnimations[boneAnim.boneName] = boneAnim;
        }
        animData->animationClips.push_back(clip);
    }

    // Step 6: Pre-link bone info to nodes for lock-free audio thread access
    juce::Logger::writeToLog("AnimationBinder: Step 6 - Pre-linking bone info to nodes...");
    PreLinkBoneInfoToNodes(&animData->rootNode, animData->boneInfoMap);
    
    juce::Logger::writeToLog("AnimationBinder: Binding complete. Bones: " + juce::String(animData->boneInfoMap.size()) + ", Clips: " + juce::String(animData->animationClips.size()));
    return animData;
}

// Helper implementations
void BuildNodeHierarchyRecursive(const RawAnimationData& rawData, NodeData& parentNode, int rawNodeIndex) {
    const RawNodeData& rawNode = rawData.nodes[rawNodeIndex];
    parentNode.name = rawNode.name;
    parentNode.transformation = rawNode.localTransform;
    parentNode.parent = nullptr; // Will be set later in SetParentPointersRecursive
    
    // Recursively build child nodes
    for (int childIndex : rawNode.childIndices) {
        // CRITICAL: Validate child index before accessing the nodes array
        // Root nodes and some edges cases may have invalid indices
        if (childIndex >= 0 && childIndex < static_cast<int>(rawData.nodes.size())) {
            // === THE DEFINITIVE FIX: Build child completely before adding to the parent's vector ===
            
            // 1. Create a temporary, stack-allocated child node.
            NodeData newChildNode;
            
            // 2. Recursively build the full hierarchy FOR this new child.
            //    This is safe because newChildNode is a local variable, not a reference into a vector.
            juce::Logger::writeToLog("  [Binder] Building child '" + juce::String(rawData.nodes[childIndex].name) + "' before adding to parent '" + juce::String(parentNode.name) + "'");
            BuildNodeHierarchyRecursive(rawData, newChildNode, childIndex);
            
            // 3. Now that the child is fully built and stable, move it into the parent's vector.
            //    This single push_back may reallocate, but it won't affect other children in this loop.
            parentNode.children.push_back(std::move(newChildNode));
            
            // =====================================================================================
        } else {
            juce::Logger::writeToLog("AnimationBinder WARNING: Invalid child index " + juce::String(childIndex) + " for node " + juce::String(rawNode.name));
        }
    }
}

// Set parent pointers after the hierarchy is fully built
// This prevents dangling pointers from vector reallocations
void SetParentPointersRecursive(NodeData& node) {
    for (auto& child : node.children) {
        child.parent = &node;
        SetParentPointersRecursive(child);
    }
}

void MapNodes(NodeData& node, std::map<std::string, NodeData*>& map) {
    map[node.name] = &node;
    for (auto& child : node.children) {
        MapNodes(child, map);
    }
}

void CalculateGlobalInitialTransforms(NodeData& node, const glm::mat4& parentTransform, std::map<std::string, glm::mat4>& globalTransforms) {
    glm::mat4 globalTransform = parentTransform * node.transformation;
    globalTransforms[node.name] = globalTransform;
    for (auto& child : node.children) {
        CalculateGlobalInitialTransforms(child, globalTransform, globalTransforms);
    }
}

// Pre-link bone info to nodes for lock-free audio thread access
void PreLinkBoneInfoToNodes(NodeData* node, const std::map<std::string, BoneInfo>& boneInfoMap) {
    if (!node) return;
    
    // Check if this node is a bone
    if (boneInfoMap.count(node->name)) {
        const BoneInfo& boneInfo = boneInfoMap.at(node->name);
        node->boneIndex = boneInfo.id;
        node->offsetMatrix = boneInfo.offsetMatrix;
    } else {
        node->boneIndex = -1;
        node->offsetMatrix = glm::mat4(1.0f); // Identity
    }
    
    // Recurse to children
    for (auto& child : node->children) {
        PreLinkBoneInfoToNodes(&child, boneInfoMap);
    }
}


================================================================================
FILE: juce\Source\audio\modules\TimingData.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <vector>

struct PhonemeTiming
{
	juce::String phoneme;
	double startTimeSeconds{};
	double endTimeSeconds{};
	double durationSeconds{};

	PhonemeTiming() = default;
	PhonemeTiming(const juce::String& p, double start, double end)
		: phoneme(p), startTimeSeconds(start), endTimeSeconds(end), durationSeconds(end - start) {}
};

struct WordTiming
{
	juce::String word;
	double startTimeSeconds{};
	double endTimeSeconds{};
	double durationSeconds{};
	std::vector<PhonemeTiming> phonemes;

	WordTiming() = default;
	WordTiming(const juce::String& w, double start, double end)
		: word(w), startTimeSeconds(start), endTimeSeconds(end), durationSeconds(end - start) {}
};


================================================================================
FILE: juce\Source\audio\modules\TempoClockModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class TempoClockModuleProcessor : public ModuleProcessor
{
public:
    TempoClockModuleProcessor();
    ~TempoClockModuleProcessor() override = default;

    // Parameter IDs for APVTS
    static constexpr auto paramIdBpm              = "bpm";
    static constexpr auto paramIdSwing            = "swing";
    static constexpr auto paramIdDivision         = "division";
    static constexpr auto paramIdGateWidth        = "gateWidth";
    static constexpr auto paramIdSyncToHost       = "syncToHost";
    static constexpr auto paramIdDivisionOverride = "divisionOverride";

    // Virtual modulation/control input IDs (no APVTS parameters required)
    static constexpr auto paramIdBpmMod       = "bpm_mod";
    static constexpr auto paramIdTapMod       = "tap_mod";
    static constexpr auto paramIdNudgeUpMod   = "nudge_up_mod";
    static constexpr auto paramIdNudgeDownMod = "nudge_down_mod";
    static constexpr auto paramIdPlayMod      = "play_mod";
    static constexpr auto paramIdStopMod      = "stop_mod";
    static constexpr auto paramIdResetMod     = "reset_mod";
    static constexpr auto paramIdSwingMod     = "swing_mod";

    const juce::String getName() const override { return "tempo_clock"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void setTimingInfo(const TransportState& state) override { m_currentTransport = state; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

    // Parameter bus contract (virtual modulation IDs)
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

    juce::String getAudioInputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "BPM Mod";
            case 1: return "Tap";
            case 2: return "Nudge+";
            case 3: return "Nudge-";
            case 4: return "Play";
            case 5: return "Stop";
            case 6: return "Reset";
            case 7: return "Swing Mod";
            default: return juce::String("In ") + juce::String(channel + 1);
        }
    }

    juce::String getAudioOutputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "Clock";
            case 1: return "Beat Trig";
            case 2: return "Bar Trig";
            case 3: return "Beat Gate";
            case 4: return "Phase";
            case 5: return "BPM CV";
            case 6: return "Downbeat";
            default: return juce::String("Out ") + juce::String(channel + 1);
        }
    }

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    // Parameters
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* bpmParam { nullptr };
    std::atomic<float>* swingParam { nullptr };
    std::atomic<float>* divisionParam { nullptr };
    std::atomic<float>* gateWidthParam { nullptr };
    std::atomic<float>* syncToHostParam { nullptr };
    std::atomic<float>* divisionOverrideParam { nullptr };

    // Transport cache for per-block start
    TransportState m_currentTransport;

    // Internal state for tap/nudge and trigger edge detection
    double sampleRateHz { 0.0 };
    int lastBeatIndex { 0 };
    int lastBarIndex { 0 };
    double lastScaledBeats { 0.0 };
    bool lastPlayHigh { false };
    bool lastStopHigh { false };
    bool lastResetHigh { false };
    bool lastTapHigh { false };
    bool lastNudgeUpHigh { false };
    bool lastNudgeDownHigh { false };
    double samplesSinceLastTap { 0.0 };
    bool hasPreviousTap { false };  // Track if we have a valid previous tap for BPM calculation
    
    // UI tap button state (for GUI thread to trigger taps)
    std::atomic<double> uiTapTimestamp { 0.0 };  // Timestamp of last UI tap (in seconds)
    double lastProcessedUiTap { 0.0 };  // Last tap timestamp we've processed (audio thread)
};




================================================================================
FILE: juce\Source\audio\modules\TempoClockModuleProcessor.cpp
================================================================================


#include "TempoClockModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"

TempoClockModuleProcessor::TempoClockModuleProcessor()
    : ModuleProcessor(BusesProperties()
          .withInput("Mods", juce::AudioChannelSet::discreteChannels(8), true)    // bpm,tap,nudge+,nudge-,play,stop,reset,swing
          .withOutput("Clock", juce::AudioChannelSet::discreteChannels(7), true)), // clock, beatTrig, barTrig, beatGate, phase, bpmCv, downbeat
      apvts(*this, nullptr, "TempoClockParams", createParameterLayout())
{
    bpmParam = apvts.getRawParameterValue(paramIdBpm);
    swingParam = apvts.getRawParameterValue(paramIdSwing);
    divisionParam = apvts.getRawParameterValue(paramIdDivision);
    gateWidthParam = apvts.getRawParameterValue(paramIdGateWidth);
    syncToHostParam = apvts.getRawParameterValue(paramIdSyncToHost);
    divisionOverrideParam = apvts.getRawParameterValue(paramIdDivisionOverride);
}

juce::AudioProcessorValueTreeState::ParameterLayout TempoClockModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdBpm, "BPM", juce::NormalisableRange<float>(20.0f, 300.0f, 0.01f, 0.3f), 120.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSwing, "Swing", juce::NormalisableRange<float>(0.0f, 0.75f, 0.0f, 1.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterChoice>(paramIdDivision, "Division", juce::StringArray{"1/32","1/16","1/8","1/4","1/2","1","2","4"}, 3));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdGateWidth, "Gate Width", juce::NormalisableRange<float>(0.01f, 0.99f, 0.0f, 1.0f), 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdSyncToHost, "Sync to Host", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdDivisionOverride, "Division Override", false));
    return { params.begin(), params.end() };
}

void TempoClockModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    sampleRateHz = sampleRate;
}

void TempoClockModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    const int numSamples = buffer.getNumSamples();
    if (numSamples <= 0 || sampleRateHz <= 0.0)
        return;
    
    // DEBUG: Log buffer state BEFORE clearing
    static int bufferLogCounter = 0;
    if (++bufferLogCounter % 100 == 0) {
        juce::Logger::writeToLog("[TempoClock BUFFER DEBUG]:");
        juce::Logger::writeToLog("  - Input buffer channels: " + juce::String(in.getNumChannels()));
        juce::Logger::writeToLog("  - Output buffer channels: " + juce::String(out.getNumChannels()));
        if (in.getNumChannels() > 0) {
            juce::Logger::writeToLog("  - Input channel 0 first sample BEFORE clear: " + juce::String(in.getSample(0, 0), 4));
        }
        if (in.getNumChannels() > 7) {
            juce::Logger::writeToLog("  - Input channel 7 first sample BEFORE clear: " + juce::String(in.getSample(7, 0), 4));
        }
    }
    
    // FIX: Only clear OUTPUT channels, not the entire buffer!
    out.clear();

    // Read CV inputs ONLY if connected (BestPractice/TTS pattern)
    const bool bpmMod = isParamInputConnected(paramIdBpmMod);
    const bool tapMod = isParamInputConnected(paramIdTapMod);
    const bool nudgeUpMod = isParamInputConnected(paramIdNudgeUpMod);
    const bool nudgeDownMod = isParamInputConnected(paramIdNudgeDownMod);
    const bool playMod = isParamInputConnected(paramIdPlayMod);
    const bool stopMod = isParamInputConnected(paramIdStopMod);
    const bool resetMod = isParamInputConnected(paramIdResetMod);
    const bool swingMod = isParamInputConnected(paramIdSwingMod);
    
    // DEBUG: Log connection detection every 100 blocks
    static int connectionLogCounter = 0;
    if (++connectionLogCounter % 100 == 0) {
        juce::Logger::writeToLog("[TempoClock TRACE] Connection detection:");
        juce::Logger::writeToLog("  - bpmMod: " + juce::String(bpmMod ? "CONNECTED" : "disconnected"));
        juce::Logger::writeToLog("  - swingMod: " + juce::String(swingMod ? "CONNECTED" : "disconnected"));
        juce::Logger::writeToLog("  - Input bus channels: " + juce::String(in.getNumChannels()));
    }

    const float* bpmCV       = (bpmMod       && in.getNumChannels() > 0) ? in.getReadPointer(0) : nullptr;
    const float* tapCV       = (tapMod       && in.getNumChannels() > 1) ? in.getReadPointer(1) : nullptr;
    const float* nudgeUpCV   = (nudgeUpMod   && in.getNumChannels() > 2) ? in.getReadPointer(2) : nullptr;
    const float* nudgeDownCV = (nudgeDownMod && in.getNumChannels() > 3) ? in.getReadPointer(3) : nullptr;
    const float* playCV      = (playMod      && in.getNumChannels() > 4) ? in.getReadPointer(4) : nullptr;
    const float* stopCV      = (stopMod      && in.getNumChannels() > 5) ? in.getReadPointer(5) : nullptr;
    const float* resetCV     = (resetMod     && in.getNumChannels() > 6) ? in.getReadPointer(6) : nullptr;
    const float* swingCV     = (swingMod     && in.getNumChannels() > 7) ? in.getReadPointer(7) : nullptr;
    
    // DEBUG: Log pointer validity AND actual values they point to
    if (bufferLogCounter % 100 == 0) {
        juce::Logger::writeToLog("  - bpmCV pointer: " + juce::String(bpmCV ? "VALID" : "NULL"));
        if (bpmCV) {
            juce::Logger::writeToLog("    * bpmCV[0] = " + juce::String(bpmCV[0], 4));
        }
        juce::Logger::writeToLog("  - swingCV pointer: " + juce::String(swingCV ? "VALID" : "NULL"));
        if (swingCV) {
            juce::Logger::writeToLog("    * swingCV[0] = " + juce::String(swingCV[0], 4));
        }
    }

    float bpm = bpmParam->load();
    
    // DEBUG: Log base parameter value
    if (connectionLogCounter % 100 == 0) {
        juce::Logger::writeToLog("  - BPM base parameter: " + juce::String(bpm, 2));
    }
    
    // FIX: Set flag when BPM comes from CV so other sources won't override it (MultiBandShaper pattern)
    bool bpmFromCV = false;
    if (bpmCV)
    {
        const float cvRaw = bpmCV[0];
        const float cv = juce::jlimit(0.0f, 1.0f, cvRaw);
        // Map 0..1 -> 20..300 with perceptual curve
        bpm = juce::jmap(std::pow(cv, 0.3f), 0.0f, 1.0f, 20.0f, 300.0f);
        bpmFromCV = true;
        
        // DEBUG: Log BPM CV processing
        if (connectionLogCounter % 100 == 0) {
            juce::Logger::writeToLog("  - BPM CV raw: " + juce::String(cvRaw, 4));
            juce::Logger::writeToLog("  - BPM CV clamped: " + juce::String(cv, 4));
            juce::Logger::writeToLog("  - BPM final calculated: " + juce::String(bpm, 2));
        }
    } else if (connectionLogCounter % 100 == 0) {
        juce::Logger::writeToLog("  - BPM CV: NOT PROCESSING (bpmCV is null)");
    }

    float swing = swingParam ? swingParam->load() : 0.0f;
    if (swingCV) {
        swing = juce::jlimit(0.0f, 0.75f, swingCV[0]);
        
        // DEBUG: Log Swing CV processing
        if (connectionLogCounter % 100 == 0) {
            juce::Logger::writeToLog("  - Swing CV raw: " + juce::String(swingCV[0], 4));
            juce::Logger::writeToLog("  - Swing final: " + juce::String(swing, 4));
        }
    }

    // Increment tap counter each block (if we're waiting for a second tap)
    if (hasPreviousTap)
    {
        samplesSinceLastTap += numSamples;
    }

    // Handle edge controls (play/stop/reset/tap/nudge)
    // FIX: Only allow these to modify BPM if CV is NOT connected
    auto edge = [&](const float* cv, bool& last){ bool now = (cv && cv[0] > 0.5f); bool rising = now && !last; last = now; return rising; };
    if (edge(playCV, lastPlayHigh))   if (auto* p = getParent()) p->setPlaying(true);
    if (edge(stopCV, lastStopHigh))   if (auto* p = getParent()) p->setPlaying(false);
    if (edge(resetCV, lastResetHigh)) if (auto* p = getParent()) p->resetTransportPosition();
    
    // TAP TEMPO (CV Input): Calculate BPM from interval between taps (ONLY if BPM CV not connected)
    bool tapDetected = false;
    if (!bpmFromCV && edge(tapCV, lastTapHigh))
    {
        tapDetected = true;
    }
    
    // TAP TEMPO (UI Button): Detect if UI button was pressed
    if (!bpmFromCV)
    {
        const double currentUiTap = uiTapTimestamp.load();
        if (currentUiTap != lastProcessedUiTap && currentUiTap > 0.0)
        {
            tapDetected = true;
            lastProcessedUiTap = currentUiTap;
        }
    }
    
    // Process tap (from CV or UI button)
    if (tapDetected)
    {
        if (hasPreviousTap && samplesSinceLastTap > 0.0)
        {
            // Calculate BPM from time between taps
            const double secondsBetweenTaps = samplesSinceLastTap / sampleRateHz;
            
            // Sanity check: prevent extreme values (20-300 BPM range)
            // Min interval: 0.2 seconds (300 BPM), Max interval: 3.0 seconds (20 BPM)
            if (secondsBetweenTaps >= 0.2 && secondsBetweenTaps <= 3.0)
            {
                float newBPM = 60.0f / static_cast<float>(secondsBetweenTaps);
                bpm = juce::jlimit(20.0f, 300.0f, newBPM);
                
                // Update the parameter so it persists
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdBpm)))
                    *p = bpm;
                
                juce::Logger::writeToLog("[TempoClock] Tap tempo: " + 
                    juce::String(secondsBetweenTaps, 3) + "s interval = " + 
                    juce::String(bpm, 1) + " BPM");
            }
        }
        
        // Reset counter and mark that we have a valid tap
        samplesSinceLastTap = 0.0;
        hasPreviousTap = true;
    }
    
    // TAP TIMEOUT: Reset if no tap for 4 seconds
    if (hasPreviousTap && samplesSinceLastTap > sampleRateHz * 4.0)
    {
        hasPreviousTap = false;
        samplesSinceLastTap = 0.0;
    }
    
    // NUDGE: Only allow if BPM CV not connected
    if (!bpmFromCV)
    {
        if (edge(nudgeUpCV, lastNudgeUpHigh))   { bpm = juce::jlimit(20.0f, 300.0f, bpm + 0.5f); }
        if (edge(nudgeDownCV, lastNudgeDownHigh)) { bpm = juce::jlimit(20.0f, 300.0f, bpm - 0.5f); }
    }

    // Sync to Host: Use host transport tempo OR control it
    // FIX: BPM CV always takes priority over sync-to-host
    bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;
    
    // DEBUG: Log sync state
    if (connectionLogCounter % 100 == 0) {
        juce::Logger::writeToLog("  - syncToHost: " + juce::String(syncToHost ? "YES" : "NO"));
        juce::Logger::writeToLog("  - bpmFromCV: " + juce::String(bpmFromCV ? "YES" : "NO"));
    }
    
    if (auto* parent = getParent())
    {
        if (syncToHost && !bpmFromCV)  // FIX: Only sync from host if BPM CV is NOT connected
        {
            // Pull tempo FROM host transport (Tempo Clock follows)
            float hostBpm = (float)m_currentTransport.bpm;
            
            if (connectionLogCounter % 100 == 0) {
                juce::Logger::writeToLog("  - SYNC MODE: Overriding BPM from " + juce::String(bpm, 2) + 
                                       " to host BPM " + juce::String(hostBpm, 2));
            }
            
            bpm = hostBpm;
            parent->setTempoControlledByModule(false);  // Not controlling
        }
        else
        {
            // Push tempo TO host transport (Tempo Clock controls the global BPM)
            // This includes: manual BPM, BPM CV, tap tempo, and nudge
            parent->setBPM(bpm);
            parent->setTempoControlledByModule(true);  // Controlling - UI should be greyed
            
            if (connectionLogCounter % 100 == 0) {
                juce::Logger::writeToLog("  - CONTROL MODE: Setting global BPM to " + juce::String(bpm, 2));
            }
        }
    }
    
    // Publish live telemetry AFTER all BPM sources resolved (including sync)
    setLiveParamValue("bpm_live", bpm);
    setLiveParamValue("swing_live", swing);
    
    // DEBUG: Log telemetry publishing
    if (connectionLogCounter % 100 == 0) {
        juce::Logger::writeToLog("  - TELEMETRY PUBLISHED:");
        juce::Logger::writeToLog("    * bpm_live = " + juce::String(bpm, 2));
        juce::Logger::writeToLog("    * swing_live = " + juce::String(swing, 4));
    }

    // Compute outputs
    float* clockOut = out.getNumChannels() > 0 ? out.getWritePointer(0) : nullptr;
    float* beatTrig = out.getNumChannels() > 1 ? out.getWritePointer(1) : nullptr;
    float* barTrig  = out.getNumChannels() > 2 ? out.getWritePointer(2) : nullptr;
    float* beatGate = out.getNumChannels() > 3 ? out.getWritePointer(3) : nullptr;
    float* phaseOut = out.getNumChannels() > 4 ? out.getWritePointer(4) : nullptr;
    float* bpmOut   = out.getNumChannels() > 5 ? out.getWritePointer(5) : nullptr;
    float* downbeat = out.getNumChannels() > 6 ? out.getWritePointer(6) : nullptr;

    int divisionIdx = divisionParam ? (int)divisionParam->load() : 3; // default 1/4
    
    // Division Override: Broadcast local division to global transport OR clear it
    bool divisionOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
    if (auto* parent = getParent())
    {
        if (divisionOverride)
        {
            // This clock becomes the master division source
            parent->setGlobalDivisionIndex(divisionIdx);
        }
        else
        {
            // Not overriding - clear the global division
            parent->setGlobalDivisionIndex(-1);
        }
    }
    static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0 };
    const double div = divisions[juce::jlimit(0, 7, divisionIdx)];

    // Use transport position + per-sample advancement to produce stable clock
    double sr = juce::jmax(1.0, sampleRateHz);
    double localBeatsStart = m_currentTransport.songPositionBeats;
    double phaseBeats = localBeatsStart;

    for (int i = 0; i < numSamples; ++i)
    {
        // Advance beats using current bpm
        phaseBeats += (1.0 / sr) * (bpm / 60.0);

        // Subdivision phase
        const double scaled = phaseBeats * div;
        const double frac = scaled - std::floor(scaled);

        if (phaseOut) phaseOut[i] = (float) frac;
        if (clockOut) clockOut[i] = frac < 0.01 ? 1.0f : 0.0f;
        if (bpmOut) bpmOut[i] = juce::jmap(bpm, 20.0f, 300.0f, 0.0f, 1.0f);

        // Beat/bar triggers from integer boundaries
        const int beatIndex = (int) std::floor(phaseBeats);
        const int barIndex = beatIndex / 4;
        if (beatTrig) beatTrig[i] = (beatIndex > lastBeatIndex) ? 1.0f : 0.0f;
        if (barTrig)  barTrig[i]  = (barIndex > lastBarIndex)   ? 1.0f : 0.0f;
        if (downbeat) downbeat[i] = (beatIndex > lastBeatIndex && (beatIndex % 4) == 0) ? 1.0f : 0.0f;

        // Gate width within subdivision
        const float gw = gateWidthParam ? gateWidthParam->load() : 0.5f;
        if (beatGate) beatGate[i] = (float)(frac < gw ? 1.0 : 0.0);

        lastBeatIndex = beatIndex;
        lastBarIndex = barIndex;
    }

    // Telemetry and meter
    setLiveParamValue("phase_live", (float)(phaseBeats - std::floor(phaseBeats)));
    if (!lastOutputValues.empty())
    {
        if (!lastOutputValues[0]) lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
        if (lastOutputValues[0]) lastOutputValues[0]->store(out.getNumChannels() > 0 ? out.getSample(0, numSamples - 1) : 0.0f);
    }
}

// Parameter routing: virtual IDs on single input bus
bool TempoClockModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0;
    if (paramId == paramIdBpmMod) { outChannelIndexInBus = 0; return true; }
    if (paramId == paramIdTapMod) { outChannelIndexInBus = 1; return true; }
    if (paramId == paramIdNudgeUpMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdNudgeDownMod) { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdPlayMod) { outChannelIndexInBus = 4; return true; }
    if (paramId == paramIdStopMod) { outChannelIndexInBus = 5; return true; }
    if (paramId == paramIdResetMod) { outChannelIndexInBus = 6; return true; }
    if (paramId == paramIdSwingMod) { outChannelIndexInBus = 7; return true; }
    return false;
}

#if defined(PRESET_CREATOR_UI)
void TempoClockModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth(itemWidth);
    
    // Helper for tooltips
    auto HelpMarkerClock = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    // === TEMPO CONTROLS SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Tempo");
    ImGui::Spacing();

    // BPM slider with live display
    bool bpmMod = isParamInputConnected(paramIdBpmMod);  // FIX: Use isParamInputConnected, not isParamModulated
    float bpmParamValue = bpmParam->load();
    float bpmLiveTelemetry = getLiveParamValueFor(paramIdBpmMod, "bpm_live", bpmParamValue);
    float bpm = bpmMod ? bpmLiveTelemetry : bpmParamValue;
    bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;
    
    // DEBUG: Log UI state every 60 frames (~1 second at 60fps)
    static int uiLogCounter = 0;
    if (++uiLogCounter % 60 == 0) {
        juce::Logger::writeToLog("[TempoClock UI TRACE]:");
        juce::Logger::writeToLog("  - isParamInputConnected(bpm): " + juce::String(bpmMod ? "YES" : "NO"));
        juce::Logger::writeToLog("  - bpmParam->load(): " + juce::String(bpmParamValue, 2));
        juce::Logger::writeToLog("  - getLiveParamValueFor('bpm_live'): " + juce::String(bpmLiveTelemetry, 2));
        juce::Logger::writeToLog("  - Final bpm display value: " + juce::String(bpm, 2));
        juce::Logger::writeToLog("  - syncToHost: " + juce::String(syncToHost ? "YES" : "NO"));
    }
    
    // Disable BPM control if synced to host
    if (bpmMod || syncToHost) { ImGui::BeginDisabled(); }
    if (ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f, "%.1f"))
    {
        if (!bpmMod && !syncToHost)
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdBpm))) *p = bpm;
        }
        onModificationEnded();
    }
    if (!bpmMod && !syncToHost) adjustParamOnWheel(apvts.getParameter(paramIdBpm), paramIdBpm, bpm);
    if (bpmMod) { ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    if (syncToHost) { ImGui::SameLine(); ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.8f, 1.0f), "(synced)"); }
    if (bpmMod || syncToHost) { ImGui::EndDisabled(); }
    ImGui::SameLine();
    HelpMarkerClock("Beats per minute (20-300 BPM)\nDisabled when synced to host");
    
    // TAP TEMPO BUTTON
    if (bpmMod || syncToHost) { ImGui::BeginDisabled(); }
    if (ImGui::Button("TAP", ImVec2(itemWidth * 0.3f, 30)))
    {
        // Record tap timestamp (audio thread will detect the change)
        uiTapTimestamp.store(juce::Time::getMillisecondCounterHiRes() / 1000.0);
    }
    if (bpmMod || syncToHost) { ImGui::EndDisabled(); }
    ImGui::SameLine();
    HelpMarkerClock("Click repeatedly to set tempo by tapping\nTap at least twice to calculate BPM");

    // Swing
    bool swingM = isParamInputConnected(paramIdSwingMod);  // FIX: Use isParamInputConnected, not isParamModulated
    float swing = swingM ? getLiveParamValueFor(paramIdSwingMod, "swing_live", swingParam->load()) : swingParam->load();
    if (swingM) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Swing", &swing, 0.0f, 0.75f, "%.2f"))
    {
        if (!swingM)
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdSwing))) *p = swing;
        }
        onModificationEnded();
    }
    if (!swingM) adjustParamOnWheel(apvts.getParameter(paramIdSwing), paramIdSwing, swing);
    if (swingM) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerClock("Swing amount (0-75%)\nDelays every other beat for shuffle feel");

    ImGui::Spacing();
    ImGui::Spacing();

    // === CLOCK OUTPUT SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Clock Output");
    ImGui::Spacing();

    // Division + Gate width in-line
    int div = divisionParam ? (int)divisionParam->load() : 3;
    const char* items[] = { "1/32","1/16","1/8","1/4","1/2","1","2","4" };
    ImGui::SetNextItemWidth(itemWidth * 0.5f);
    if (ImGui::Combo("Division", &div, items, 8))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter(paramIdDivision))) *p = div;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Clock output division\n1/4 = quarter notes, 1/16 = sixteenth notes");

    float gw = gateWidthParam ? gateWidthParam->load() : 0.5f;
    ImGui::SetNextItemWidth(itemWidth);
    if (ImGui::SliderFloat("Gate Width", &gw, 0.01f, 0.99f, "%.2f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdGateWidth))) *p = gw;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Gate/trigger pulse width (1-99%)");

    ImGui::Spacing();
    ImGui::Spacing();

    // === LIVE CLOCK DISPLAY SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Clock Status");
    ImGui::Spacing();

    // Animated beat indicator (4 boxes for 4/4 time)
    float phase = getLiveParamValue("phase_live", 0.0f);
    int currentBeat = (int)(phase * 4.0f) % 4;
    
    for (int i = 0; i < 4; ++i)
    {
        if (i > 0) ImGui::SameLine();
        
        bool isCurrentBeat = (currentBeat == i);
        ImVec4 color = isCurrentBeat ? ImVec4(1.0f, 0.3f, 0.3f, 1.0f) : ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        
        ImGui::PushStyleColor(ImGuiCol_Button, color);
        ImGui::Button(juce::String(i + 1).toRawUTF8(), ImVec2(itemWidth * 0.23f, 30));
        ImGui::PopStyleColor();
    }

    // Current BPM display (large, colored)
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.0f, 0.7f, 1.0f));
    ImGui::Text("♩ = %.1f BPM", getLiveParamValue("bpm_live", bpm));
    ImGui::PopStyleColor();

    // Bar:Beat display
    int bar = (int)(phase / 4.0f) + 1;
    int beat = currentBeat + 1;
    ImGui::Text("Bar %d | Beat %d", bar, beat);

    ImGui::Spacing();
    ImGui::Spacing();

    // === TRANSPORT SYNC SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Transport Sync");
    ImGui::Spacing();

    // Sync to Host checkbox
    bool sync = syncToHost;
    if (ImGui::Checkbox("Sync to Host", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(paramIdSyncToHost))) *p = sync;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Follow host transport tempo\nDisables manual BPM control when enabled");
    
    if (sync)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 1.0f, 0.8f, 1.0f));
        ImGui::Text("⚡ SYNCED TO HOST TRANSPORT");
        ImGui::PopStyleColor();
    }
    
    ImGui::Spacing();
    
    // Division Override checkbox
    bool divOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
    if (ImGui::Checkbox("Division Override", &divOverride))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(paramIdDivisionOverride))) *p = divOverride;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Broadcast this clock's division globally\nForces all synced modules to follow this clock's subdivision");
    
    if (divOverride)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.2f, 1.0f));
        ImGui::Text("⚡ MASTER DIVISION SOURCE");
        ImGui::PopStyleColor();
    }

    ImGui::PopItemWidth();
}

void TempoClockModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("BPM Mod", 0);
    helpers.drawAudioInputPin("Tap", 1);
    helpers.drawAudioInputPin("Nudge+", 2);
    helpers.drawAudioInputPin("Nudge-", 3);
    helpers.drawAudioInputPin("Play", 4);
    helpers.drawAudioInputPin("Stop", 5);
    helpers.drawAudioInputPin("Reset", 6);
    helpers.drawAudioInputPin("Swing Mod", 7);

    helpers.drawAudioOutputPin("Clock", 0);
    helpers.drawAudioOutputPin("Beat Trig", 1);
    helpers.drawAudioOutputPin("Bar Trig", 2);
    helpers.drawAudioOutputPin("Beat Gate", 3);
    helpers.drawAudioOutputPin("Phase", 4);
    helpers.drawAudioOutputPin("BPM CV", 5);
    helpers.drawAudioOutputPin("Downbeat", 6);
}
#endif




================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_opengl/juce_opengl.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <unordered_map>
#include <tuple>
#include <deque>
#include <imgui.h>
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/graph/ModularSynthProcessor.h"
#include "PresetManager.h"
#include "SampleManager.h"
#include "MidiManager.h"
#include "ControllerPresetManager.h"

// Forward declarations from Dear ImGui / imnodes
struct ImGuiContext; struct ImGuiIO; struct ImNodesContext;
class MIDIPlayerModuleProcessor;
class MultiSequencerModuleProcessor;
class StrokeSequencerModuleProcessor;
class AnimationModuleProcessor;

// === NODE SIZING SYSTEM ===
// Standardized node width categories for consistent visual layout
enum class NodeWidth 
{ 
    Small,      // 240px - Basic modules (VCO, VCA, simple utilities)
    Medium,     // 360px - Effects with visualizations (Reverb, Chorus, Phaser)
    Big,        // 480px - Complex modules (PolyVCO, advanced effects)
    ExtraWide,  // 840px - Timeline/grid modules (MultiSequencer, MIDI Player)
    Exception   // Custom size - Module defines its own dimensions via getCustomNodeSize()
};

// Helper function to convert NodeWidth category to pixel width
inline float getWidthForCategory(NodeWidth width)
{
    switch (width)
    {
        case NodeWidth::Medium:    return 360.0f;
        case NodeWidth::Big:       return 480.0f;
        case NodeWidth::ExtraWide: return 840.0f;
        case NodeWidth::Exception: return 0.0f;  // Signals that module provides custom size
        case NodeWidth::Small:
        default:                   return 360.0f;
    }
}

// Pin information struct for node editor
struct PinInfo {
    uint32_t id;      // The unique ID of the pin
    juce::String type; // The parsed type ("Pitch", "Gate", "Trig", etc.)
};

class ImGuiNodeEditorComponent : public juce::Component,
                                 private juce::OpenGLRenderer
{
public:
    ImGuiNodeEditorComponent(juce::AudioDeviceManager& deviceManager);
    ~ImGuiNodeEditorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    // Input is handled by imgui_juce backend; no JUCE overrides needed
    
    void setMidiActivityFrames(int frames) { midiActivityFrames = frames; }

    void setModel (ModularSynthProcessor* model) 
    { 
        synth = model; 
        undoStack.clear(); 
        redoStack.clear(); 
    }
    
    // ADD: Callback for showing audio settings dialog
    std::function<void()> onShowAudioSettings;
    
    // UI state roundtrip
    juce::ValueTree getUiValueTree();
    // Thread-safe: queues UI state to be applied on next render frame
    void applyUiValueTree (const juce::ValueTree& uiState);
    void applyUiValueTreeNow (const juce::ValueTree& uiState);

    // --- Helper structs ---
    struct Range { float min; float max; };
    
    // --- Pin ID System Struct (declare before any usage) ---
    struct PinID
    {
        juce::uint32 logicalId = 0;
        int channel = 0;
        bool isInput = false;
        bool isMod = false;
        juce::String paramId; // used for mod pins
    };

    // OpenGLRenderer
    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;

    // Helper functions for pin type checking and UI
    PinDataType getPinDataTypeForPin(const PinID& pin);
    unsigned int getImU32ForType(PinDataType type);
    const char* pinDataTypeToString(PinDataType type);
    
    void handleRandomizePatch();
    void handleRandomizeConnections();
    void handleConnectSelectedToTrackMixer();
    void handleBeautifyLayout();
    void handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleInsertNodeOnSelectedLinks(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin);
    void drawInsertNodeOnLinkPopup();

    // New intelligent auto-connection system
    void parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex);
    
    // Helper functions to get pins from modules
    std::vector<AudioPin> getOutputPins(const juce::String& moduleType);
    std::vector<AudioPin> getInputPins(const juce::String& moduleType);
    AudioPin* findInputPin(const juce::String& moduleType, const juce::String& pinName);
    AudioPin* findOutputPin(const juce::String& moduleType, const juce::String& pinName);
    std::vector<juce::uint32> findNodesOfType(const juce::String& moduleType);
    
    // New dynamic pin-fetching helper
    std::vector<PinInfo> getDynamicOutputPins(ModuleProcessor* module);
    
    template<typename TargetProcessorType>
    void connectToMonophonicTargets(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping, const std::vector<juce::uint32>& targetLids);
    template<typename TargetProcessorType>
    void connectToPolyphonicTarget(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping);
    void handleAutoConnectionRequests();
    
    // MIDI Player Quick Connect handler
    void handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType);
    
    // StrokeSequencer specific handler
    void handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid);
    
    // AnimationModule specific handlers
    void handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid);
    void handleAnimationConnectBpmToClock(juce::uint32 animModuleLid);
    
    // MultiSequencer specific handlers
    void handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    void handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);

    void renderImGui();
    void handleDeletion();
    void bypassDeleteSelectedNodes();
    void bypassDeleteNode(juce::uint32 logicalId);
    void startSaveDialog();
    void startLoadDialog();
    juce::String getTypeForLogical (juce::uint32 logicalId) const;

    // --- Collision-Proof Pin ID System ---
    // 32-bit ID with guaranteed separation from node IDs:
    // Bit 31: PIN_ID_FLAG (always 1 for pins, 0 for nodes)
    // Bit 30: IS_INPUT_FLAG (1 for input, 0 for output)
    // Bits 16-29: Channel Index (14 bits, up to 16384 channels)
    // Bits 0-15: Node Logical ID (16 bits, up to 65535 nodes)
    // This ensures pin IDs can never collide with node IDs
    
    static int encodePinId(const PinID& pinId)
    {
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);
        
        juce::uint32 encoded = PIN_ID_FLAG |
                               (pinId.isInput ? IS_INPUT_FLAG : 0) |
                               (((juce::uint32)pinId.channel & 0x3FFF) << 16) |
                               (pinId.logicalId & 0xFFFF);
        
        return (int)encoded;
    }

    static PinID decodePinId(int id)
    {
        PinID pinId;
        const juce::uint32 uid = (juce::uint32)id;
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);

        // Only decode if this is actually a pin ID (has the flag set)
        if ((uid & PIN_ID_FLAG) == 0)
        {
            // This is not a pin ID! Return invalid pin
            juce::Logger::writeToLog("[ERROR] decodePinId called with non-pin ID: " + juce::String((int)id));
            pinId.logicalId = 0;
            pinId.channel = 0;
            pinId.isInput = false;
            pinId.isMod = false;
            return pinId;
        }

        pinId.logicalId = uid & 0xFFFF;
        pinId.channel   = (int)((uid >> 16) & 0x3FFF); // 14-bit mask
        pinId.isInput   = (uid & IS_INPUT_FLAG) != 0;
        pinId.isMod     = false; // handled contextually, not in the bitmask
        return pinId;
    }


    juce::OpenGLContext glContext;
    ImGuiContext* imguiContext { nullptr };
    ImGuiIO* imguiIO { nullptr };
    ImNodesContext* editorContext { nullptr };
    double lastTime { 0.0 };

    juce::AudioDeviceManager& deviceManager;
    ModularSynthProcessor* synth { nullptr };
    juce::ValueTree uiPending; // applied at next render before drawing nodes
    std::atomic<bool> graphNeedsRebuild { false };
    int midiActivityFrames = 0; // For MIDI activity indicator
    
    // Preset and sample management
    PresetManager m_presetManager;
    SampleManager m_sampleManager;
    juce::String m_presetSearchTerm;
    juce::String m_sampleSearchTerm;
    juce::File m_presetScanPath;
    juce::File m_sampleScanPath;
    std::unique_ptr<juce::FileChooser> presetPathChooser;
    std::unique_ptr<juce::FileChooser> samplePathChooser;
    
    // MIDI file management
    MidiManager m_midiManager;
    juce::File m_midiScanPath;
    juce::String m_midiSearchTerm;
    std::unique_ptr<juce::FileChooser> midiPathChooser;
    
    // Meta module editing state
    juce::uint32 metaModuleToEditLid = 0;
    
    // Cache of last-known valid node positions (used when graphNeedsRebuild prevents rendering)
    std::unordered_map<int, ImVec2> lastKnownNodePositions;

    // Selection state
    int selectedLogicalId { 0 };

    std::unique_ptr<juce::FileChooser> saveChooser, loadChooser;

    // Map of linkId -> (srcAttr, dstAttr) populated each frame
    std::unordered_map<int, std::pair<int,int>> linkIdToAttrs;
    
    // Link ID registry (cleared each frame for stateless rendering)
    struct LinkKey { int srcAttr; int dstAttr; };
    struct LinkKeyHash { size_t operator()(const LinkKey& k) const noexcept { return ((size_t)k.srcAttr << 32) ^ (size_t)k.dstAttr; } };
    struct LinkKeyEq { bool operator()(const LinkKey& a, const LinkKey& b) const noexcept { return a.srcAttr==b.srcAttr && a.dstAttr==b.dstAttr; } };
    std::unordered_map<LinkKey, int, LinkKeyHash, LinkKeyEq> linkToId;
    int nextLinkId { 1000 };
    int getLinkId(int srcAttr, int dstAttr)
    {
        LinkKey k{ srcAttr, dstAttr };
        auto it = linkToId.find(k);
        if (it != linkToId.end()) return it->second;
        const int id = nextLinkId++;
        linkToId.emplace(k, id);
        return id;
    }

    // Cable inspector highlight state (updated once per frame after EndNodeEditor)
    juce::uint32 hoveredLinkSrcId { 0 };
    juce::uint32 hoveredLinkDstId { 0 };
    static constexpr juce::uint32 kOutputHighlightId = 0xFFFFFFFFu; // sentinel for main output node highlight
    int lastHoveredLinkId { -1 }; // cache inside-editor hovered link id for post-editor use

    // Positions to apply for specific node IDs on the next render (grid space)
    std::unordered_map<int, ImVec2> pendingNodePositions;
    // Screen-space positions queued for just-created nodes (converted after draw)
    std::unordered_map<int, ImVec2> pendingNodeScreenPositions;
    // Sizes to apply for specific node IDs on the next render (for Comment nodes)
    std::unordered_map<int, ImVec2> pendingNodeSizes;

    // Cable inspector rolling stats (last N seconds) for quick visual validation
    struct ChannelHistory { std::deque<std::pair<double,float>> samples; };
    std::map<std::pair<juce::uint32,int>, ChannelHistory> inspectorHistory; // key: (logicalId, channel)
    float inspectorWindowSeconds { 5.0f };

    // --- NEW STATE FOR CABLE SPLITTING ---
    // Stores the attribute ID of the pin we are splitting from.
    // -1 means no split operation is active.
    int splittingFromAttrId = -1;

    // A map to cache the screen position of every pin attribute ID each frame.
    // This is a necessary workaround as ImNodes doesn't provide a public API
    // to get a pin's position by its ID.
    std::unordered_map<int, ImVec2> attrPositions;


    // UI state / hover
    int lastHoveredNodeId { -1 };
    bool isDraggingNode { false };
    bool snapshotAfterEditor { false }; // arm when action requires node to exist (add/duplicate)
    // zoom/pan disabled

    // --- Undo/Redo (module ops) ---
    struct Snapshot
    {
        juce::MemoryBlock synthState;
        juce::ValueTree   uiState;
    };
    std::vector<Snapshot> undoStack;
    std::vector<Snapshot> redoStack;
    void pushSnapshot();
    void restoreSnapshot (const Snapshot& s);
    
    // SampleLoader texture management (use JUCE OpenGLTexture to avoid raw GL includes)
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> sampleLoaderTextureIds;

    // Preset status tracking
    juce::String currentPresetFile;
    bool isPatchDirty { false };

    // Help window
    bool showShortcutsWindow { false };

    // Shortcut debounce
    bool mixerShortcutCooldown { false };
    bool insertNodeShortcutCooldown { false };
    bool showInsertNodePopup { false };
    bool showDebugMenu { false };
    bool showMidiDeviceManager { false };
    int pendingInsertLinkId { -1 };
    
    // Probe tool state
    bool isProbeModeActive { false };
    bool showProbeScope { true };
    
    // Insert node on link state
    struct LinkInfo
    {
        int linkId = -1;
        bool isMod = false;
        // For Audio links:
        PinID srcPin;
        PinID dstPin;
        // For Mod links:
        juce::uint32 srcLogicalId;
        int srcChan;
        juce::uint32 dstLogicalId;
        juce::String paramId;
    };
    LinkInfo linkToInsertOn;
    
    // Mute/Bypass state management (non-destructive)
    struct MutedNodeState {
        std::vector<ModularSynthProcessor::ConnectionInfo> incomingConnections;
        std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
    };
    std::map<juce::uint32, MutedNodeState> mutedNodeStates;
    
    void muteNodeSilent(juce::uint32 logicalId);  // Store mute state without modifying graph (for loading presets)
    void muteNode(juce::uint32 logicalId);
    void unmuteNode(juce::uint32 logicalId);
    void handleMuteToggle();

    // Copy/Paste settings clipboard
    juce::ValueTree nodeSettingsClipboard;
    juce::String clipboardModuleType;

    // Helper functions
    void insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position);
    void insertNodeOnLinkStereo(const juce::String& nodeType, const LinkInfo& linkLeft, const LinkInfo& linkRight, const ImVec2& position);
    juce::File findPresetsDirectory();

    // --- NEW: Handler for node chaining shortcut ---
    void handleNodeChaining();

    // --- NEW: Handlers for color-coded chaining ---
    void handleColorCodedChaining(PinDataType targetType);
    std::vector<AudioPin> getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType);
    
    // --- Recorder Output Shortcut ---
    void handleRecordOutput();
    
    // --- Unified Preset Loading ---
    void loadPresetFromFile(const juce::File& file);
    void mergePresetFromFile(const juce::File& file, ImVec2 dropPosition);
    
    // --- Meta Module (Sub-Patching) Support ---
    void handleCollapseToMetaModule();
    
    // --- Module Category Color Coding ---
    enum class ModuleCategory { Source, Effect, Modulator, Utility, Analysis, Comment, Plugin, MIDI, Physics };
    ModuleCategory getModuleCategory(const juce::String& moduleType);
    unsigned int getImU32ForCategory(ModuleCategory category, bool hovered = false);
    
    // --- Quick Add Menu ---
    std::map<juce::String, std::pair<const char*, const char*>> getModuleRegistry();
    std::vector<std::pair<juce::String, const char*>> getModuleDescriptions();
    
    // --- VST Plugin Support ---
    void addPluginModules();
};


================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.cpp
================================================================================


#include "ImGuiNodeEditorComponent.h"
#include "PinDatabase.h"

#include <imgui.h>
#include <imnodes.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <unordered_map>
#include <unordered_set>
#include <cstdint>
#include <algorithm>
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/modules/AudioInputModuleProcessor.h"
#include "../audio/modules/AttenuverterModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/RandomModuleProcessor.h"
#include "../audio/modules/ValueModuleProcessor.h"
#include "../audio/modules/SampleLoaderModuleProcessor.h"
#include "../audio/modules/MIDIPlayerModuleProcessor.h"
#include "../audio/modules/PolyVCOModuleProcessor.h"
#include "../audio/modules/TrackMixerModuleProcessor.h"
#include "../audio/modules/MathModuleProcessor.h"
#include "../audio/modules/StepSequencerModuleProcessor.h"
#include "../audio/modules/MultiSequencerModuleProcessor.h"
#include "../audio/modules/StrokeSequencerModuleProcessor.h"
#include "../audio/modules/AnimationModuleProcessor.h"
#include "../audio/modules/TempoClockModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/LagProcessorModuleProcessor.h"
#include "../audio/modules/DeCrackleModuleProcessor.h"
#include "../audio/modules/GraphicEQModuleProcessor.h"
#include "../audio/modules/FrequencyGraphModuleProcessor.h"
#include "../audio/modules/ChorusModuleProcessor.h"
#include "../audio/modules/PhaserModuleProcessor.h"
#include "../audio/modules/CompressorModuleProcessor.h"
#include "../audio/modules/RecordModuleProcessor.h"
#include "../audio/modules/CommentModuleProcessor.h"
#include "../audio/modules/LimiterModuleProcessor.h"
#include "../audio/modules/GateModuleProcessor.h"
#include "../audio/modules/DriveModuleProcessor.h"
#include "../audio/modules/VstHostModuleProcessor.h"
// #include "../audio/modules/SnapshotSequencerModuleProcessor.h"  // Commented out - causing build errors
#include "../audio/modules/MIDICVModuleProcessor.h"
#include "../audio/modules/ScopeModuleProcessor.h"
#include "../audio/modules/MetaModuleProcessor.h"
#include "../audio/modules/InletModuleProcessor.h"
#include "../audio/modules/OutletModuleProcessor.h"
#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include <juce_audio_processors/juce_audio_processors.h>
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>
#include <juce_opengl/juce_opengl.h>

#define NODE_DEBUG 1

// --- Module Descriptions for Tooltips ---
static const char* toString(PinDataType t)
{
    switch (t)
    {
        case PinDataType::Audio: return "Audio";
        case PinDataType::CV: return "CV";
        case PinDataType::Gate: return "Gate";
        case PinDataType::Raw: return "Raw";
        default: return "Unknown";
    }
}

#define LOG_LINK(msg) do { if (NODE_DEBUG) juce::Logger::writeToLog("[LINK] " + juce::String(msg)); } while(0)

struct Range { float min; float max; };

// Forward declarations
class ModularSynthProcessor;
class RandomModuleProcessor;
class ValueModuleProcessor;
class StepSequencerModuleProcessor;
class MapRangeModuleProcessor;

// Helper methods for MapRange configuration
ImGuiNodeEditorComponent::Range getSourceRange(const ImGuiNodeEditorComponent::PinID& srcPin, ModularSynthProcessor* synth)
{
    if (synth == nullptr) return {0.0f, 1.0f};
    
    auto* module = synth->getModuleForLogical(srcPin.logicalId);
    if (auto* random = dynamic_cast<RandomModuleProcessor*>(module))
    {
        auto& ap = random->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* value = dynamic_cast<ValueModuleProcessor*>(module))
    {
        auto& ap = value->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* stepSeq = dynamic_cast<StepSequencerModuleProcessor*>(module))
    {
        // StepSequencer outputs CV range
        return {0.0f, 1.0f};
    }
    // Fallback: estimate from source's lastOutputValues
    // TODO: implement fallback estimation
    return {0.0f, 1.0f};
}

void configureMapRangeFor(PinDataType srcType, PinDataType dstType, MapRangeModuleProcessor& m, ImGuiNodeEditorComponent::Range inRange)
{
    auto& ap = m.getAPVTS();
    
    // Set input range
    if (auto* inMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin")))
        *inMinParam = inRange.min;
    if (auto* inMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax")))
        *inMaxParam = inRange.max;
    
    // Set output range based on destination type
    if (dstType == PinDataType::Audio)
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = -1.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
    else // CV or Gate
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = 0.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
}




ImGuiNodeEditorComponent::ImGuiNodeEditorComponent(juce::AudioDeviceManager& dm)
    : deviceManager(dm)
{
    juce::Logger::writeToLog("ImGuiNodeEditorComponent constructor starting...");
    
    // --- THIS WILL BE THE SMOKING GUN ---
    juce::Logger::writeToLog("About to populate pin database...");
    populatePinDatabase(); // Initialize the pin database for color coding
    juce::Logger::writeToLog("Pin database populated.");
    
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
    
    // Initialize browser paths (load from saved settings or use defaults)
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        // Load the last used paths, providing defaults if they don't exist
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultPresetPath = appFile.getParentDirectory().getChildFile("Presets");
        juce::File defaultSamplePath = appFile.getParentDirectory().getChildFile("Samples");

        m_presetScanPath = juce::File(props->getValue("presetScanPath", defaultPresetPath.getFullPathName()));
        m_sampleScanPath = juce::File(props->getValue("sampleScanPath", defaultSamplePath.getFullPathName()));
    }
    
    // Create these directories if they don't already exist
    if (!m_presetScanPath.exists())
        m_presetScanPath.createDirectory();
    if (!m_sampleScanPath.exists())
        m_sampleScanPath.createDirectory();
    
    juce::Logger::writeToLog("[UI] Preset path set to: " + m_presetScanPath.getFullPathName());
    juce::Logger::writeToLog("[UI] Sample path set to: " + m_sampleScanPath.getFullPathName());
    
    // --- MIDI BROWSER PATH INITIALIZATION ---
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultMidiPath = appFile.getParentDirectory().getChildFile("audio").getChildFile("MIDI");
        m_midiScanPath = juce::File(props->getValue("midiScanPath", defaultMidiPath.getFullPathName()));
    }
    if (!m_midiScanPath.exists())
        m_midiScanPath.createDirectory();
    juce::Logger::writeToLog("[UI] MIDI path set to: " + m_midiScanPath.getFullPathName());
    // --- END OF MIDI INITIALIZATION ---
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    glContext.detach();
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}

// Input handled by imgui_juce backend

void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    ImGui::StyleColorsDark();

    // --- FONT LOADING FOR CHINESE CHARACTERS ---
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->AddFontDefault(); // Load default English font

    // Define the path to your new font file
    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
    auto fontFile = appFile.getParentDirectory().getChildFile("../../Source/assets/NotoSansSC-VariableFont_wght.ttf");

    if (fontFile.existsAsFile())
    {
        ImFontConfig config;
        config.MergeMode = true; // IMPORTANT: This merges the new font into the default one
        config.PixelSnapH = true;

        // Define the character ranges to load for Chinese
        static const ImWchar ranges[] = { 0x4e00, 0x9fbf, 0, }; // Basic CJK Unified Ideographs

        io.Fonts->AddFontFromFileTTF(fontFile.getFullPathName().toRawUTF8(), 16.0f, &config, ranges);
        juce::Logger::writeToLog("ImGuiNodeEditor: Chinese font loaded successfully");
    }
    else
    {
        juce::Logger::writeToLog("ImGuiNodeEditor: WARNING - Chinese font not found at: " + fontFile.getFullPathName());
    }
    
    // --- END OF FONT LOADING ---

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    
    // Build fonts after renderer is initialized
    io.Fonts->Build();

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    
    // Enable grid snapping
    ImNodes::GetStyle().GridSpacing = 64.0f;
    
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);
}

void ImGuiNodeEditorComponent::renderImGui()
{
    static int frameCounter = 0;
    frameCounter++;

    // ========================= THE DEFINITIVE FIX =========================
    //
    // Rebuild the audio graph at the START of the frame if a change is pending.
    // This ensures that the synth model is in a consistent state BEFORE we try
    // to draw the UI, eliminating the "lost frame" that caused nodes to jump.
    //
    if (graphNeedsRebuild.load())
    {
        juce::Logger::writeToLog("[GraphSync] Rebuild flag is set. Committing changes now...");
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false; // Reset the flag immediately after committing.
        
        // CRITICAL: Invalidate hover state to prevent cable inspector from accessing
        // modules that were just deleted/recreated during commitChanges()
        lastHoveredLinkId = -1;
        lastHoveredNodeId = -1;
        hoveredLinkSrcId = 0;
        hoveredLinkDstId = 0;
        
        juce::Logger::writeToLog("[GraphSync] Graph rebuild complete.");
    }
    // ========================== END OF FIX ==========================

    // Frame start
    
    // --- Stateless Frame Rendering ---
    // Clear link registries at start of each frame for fully stateless rendering.
    // Pin IDs are now generated directly via bitmasking, no maps needed.
    linkIdToAttrs.clear();
    linkToId.clear();
    nextLinkId = 1000;

    // Handle F1 key for shortcuts window
    if (ImGui::IsKeyPressed(ImGuiKey_F1, false))
    {
        showShortcutsWindow = !showShortcutsWindow;
    }

    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_MenuBar);

    // --- DEFINITIVE STATUS OVERLAY ---
    // This code creates the small, semi-transparent window for the preset status.
    const float sidebarWidth = 260.0f;
    const float menuBarHeight = ImGui::GetFrameHeight();
    const float padding = 10.0f;

    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(0.5f);
    ImGui::Begin("Preset Status Overlay", nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize);

    // Display the preset name or "Unsaved Patch"
    if (currentPresetFile.isNotEmpty()) {
        ImGui::Text("Preset: %s", currentPresetFile.toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    // Display the "Saved" or "Edited" status
    if (isPatchDirty) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");
    } else {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
    }

    ImGui::End();
    // --- END OF OVERLAY ---
    
    // === PROBE SCOPE OVERLAY ===
    if (synth != nullptr && showProbeScope)
    {
        if (auto* scope = dynamic_cast<ScopeModuleProcessor*>(synth->getProbeScopeProcessor()))
        {
            ImGui::SetNextWindowPos(ImVec2((float)getWidth() - 270.0f, menuBarHeight + padding), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowSize(ImVec2(260, 180), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowBgAlpha(0.85f);
            
            if (ImGui::Begin("🔬 Probe Scope", &showProbeScope, ImGuiWindowFlags_NoFocusOnAppearing))
            {
                ImGui::Text("Signal Probe");
                ImGui::Separator();
                
                // Get scope buffer
                const auto& buffer = scope->getScopeBuffer();
                
                if (buffer.getNumSamples() > 0)
                {
                    // Create a simple waveform display
                    const int numSamples = buffer.getNumSamples();
                    const float* samples = buffer.getReadPointer(0);
                    
                    // Calculate min/max for this buffer
                    float minVal = 0.0f, maxVal = 0.0f;
                    for (int i = 0; i < numSamples; ++i)
                    {
                        minVal = juce::jmin(minVal, samples[i]);
                        maxVal = juce::jmax(maxVal, samples[i]);
                    }
                    
                    // Display stats
                    ImGui::Text("Min: %.3f  Max: %.3f", minVal, maxVal);
                    ImGui::Text("Peak: %.3f", juce::jmax(std::abs(minVal), std::abs(maxVal)));
                    
                    // Draw waveform with explicit width to avoid node expansion feedback
                    ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
                    ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
                    
                    // Button to clear probe connection
                    if (ImGui::Button("Clear Probe"))
                    {
                        synth->clearProbeConnection();
                    }
                }
                else
                {
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No signal probed");
                    ImGui::Text("Right-click > Probe Signal");
                    ImGui::Text("Then click any output pin");
                }
            }
            ImGui::End();
        }
    }
    // === END OF PROBE SCOPE OVERLAY ===

    // Clean up textures for deleted sample loaders
    if (synth != nullptr)
    {
        auto infos = synth->getModulesInfo();
        std::unordered_set<int> activeSampleLoaderIds;
        for (const auto& info : infos)
        {
            if (info.second.equalsIgnoreCase("sample loader"))
            {
                activeSampleLoaderIds.insert((int)info.first);
            }
        }

        for (auto it = sampleLoaderTextureIds.begin(); it != sampleLoaderTextureIds.end(); )
        {
            if (activeSampleLoaderIds.find(it->first) == activeSampleLoaderIds.end())
            {
                if (it->second)
                    it->second.reset();
                it = sampleLoaderTextureIds.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            
            // ADD: Audio Settings menu item
            if (ImGui::MenuItem("Audio Settings..."))
            {
                if (onShowAudioSettings)
                    onShowAudioSettings();
            }
            
            // MIDI Device Manager menu item
            if (ImGui::MenuItem("MIDI Device Manager..."))
            {
                showMidiDeviceManager = !showMidiDeviceManager;
            }
            
            ImGui::Separator();
            
            // Plugin scanning menu item
            if (ImGui::MenuItem("Scan for Plugins..."))
            {
                // Get the application instance to access plugin management
                auto& app = PresetCreatorApplication::getApp();
                auto& formatManager = app.getPluginFormatManager();
                auto& knownPluginList = app.getKnownPluginList();

                // 1. Find the VST3 format
                juce::VST3PluginFormat* vst3Format = nullptr;
                for (int i = 0; i < formatManager.getNumFormats(); ++i)
                {
                    if (auto* format = formatManager.getFormat(i); format->getName() == "VST3")
                    {
                        vst3Format = dynamic_cast<juce::VST3PluginFormat*>(format);
                        break;
                    }
                }

                if (vst3Format != nullptr)
                {
                    // 2. Define the specific folder to scan
                    juce::File vstDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile)
                                            .getParentDirectory().getChildFile("VST");

                    juce::FileSearchPath searchPath;
                    if (vstDir.isDirectory())
                    {
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Starting scan in: " + vstDir.getFullPathName());
                    }
                    else
                    {
                        vstDir.createDirectory();
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Created VST directory at: " + vstDir.getFullPathName());
                    }

                    // 3. Scan for plugins
                    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                        .getChildFile(app.getApplicationName());
                    
                    juce::PluginDirectoryScanner scanner(knownPluginList, *vst3Format, searchPath, true,
                                                         appDataDir.getChildFile("dead_plugins.txt"), true);

                    // 4. Perform the scan
                    juce::String pluginBeingScanned;
                    int numFound = 0;
                    while (scanner.scanNextFile(true, pluginBeingScanned))
                    {
                        juce::Logger::writeToLog("[VST Scan] Scanning: " + pluginBeingScanned);
                        ++numFound;
                    }
                    
                    juce::Logger::writeToLog("[VST Scan] Scan complete. Found " + juce::String(numFound) + " plugin(s).");
                    juce::Logger::writeToLog("[VST Scan] Total plugins in list: " + juce::String(knownPluginList.getNumTypes()));
                    
                    // 5. Save the updated plugin list
                    auto pluginListFile = appDataDir.getChildFile("known_plugins.xml");
                    if (auto pluginListXml = knownPluginList.createXml())
                    {
                        if (pluginListXml->writeTo(pluginListFile))
                        {
                            juce::Logger::writeToLog("[VST Scan] Saved plugin list to: " + pluginListFile.getFullPathName());
                        }
                    }
                }
                else
                {
                    juce::Logger::writeToLog("[VST Scan] ERROR: VST3 format not found in format manager.");
                }
            }
            
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Actions"))
        {
            // This item should only be enabled if at least one node is selected
            bool anyNodesSelected = ImNodes::NumSelectedNodes() > 0;
            bool multipleNodesSelected = ImNodes::NumSelectedNodes() > 1;
            
            if (ImGui::MenuItem("Connect Selected to Track Mixer", nullptr, false, anyNodesSelected))
            {
                handleConnectSelectedToTrackMixer();
            }
            
            // Meta Module: Collapse selected nodes into a reusable sub-patch
            if (ImGui::MenuItem("Collapse to Meta Module", "Ctrl+Shift+M", false, multipleNodesSelected))
            {
                handleCollapseToMetaModule();
            }
            
            if (ImGui::MenuItem("Record Output", "Ctrl+R"))
            {
                handleRecordOutput();
            }
            
            if (ImGui::MenuItem("Beautify Layout", "Ctrl+B"))
            {
                handleBeautifyLayout();
            }
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Recording"))
        {
            if (synth != nullptr)
            {
                bool isAnyRecording = synth->isAnyModuleRecording();
                const char* label = isAnyRecording ? "Stop All Recordings" : "Start All Recordings";
                if (ImGui::MenuItem(label))
                {
                    if (isAnyRecording)
                    {
                        synth->stopAllRecorders();
                    }
                    else
                    {
                        synth->startAllRecorders();
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Insert Node"))
        {
            bool isNodeSelected = (selectedLogicalId != 0);
            
            if (ImGui::BeginMenu("Audio Path", isNodeSelected))
            {
                if (ImGui::MenuItem("VCF")) { insertNodeBetween("VCF"); }
                if (ImGui::MenuItem("VCA")) { insertNodeBetween("VCA"); }
                if (ImGui::MenuItem("Delay")) { insertNodeBetween("Delay"); }
                if (ImGui::MenuItem("Reverb")) { insertNodeBetween("Reverb"); }
                if (ImGui::MenuItem("Chorus")) { insertNodeBetween("chorus"); }
                if (ImGui::MenuItem("Phaser")) { insertNodeBetween("phaser"); }
                if (ImGui::MenuItem("Compressor")) { insertNodeBetween("compressor"); }
                if (ImGui::MenuItem("Limiter")) { insertNodeBetween("limiter"); }
                if (ImGui::MenuItem("Gate")) { insertNodeBetween("gate"); }
                if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
                if (ImGui::MenuItem("Graphic EQ")) { insertNodeBetween("graphic eq"); }
                if (ImGui::MenuItem("Waveshaper")) { insertNodeBetween("Waveshaper"); }
                if (ImGui::MenuItem("Time/Pitch Shifter")) { insertNodeBetween("timepitch"); }
                if (ImGui::MenuItem("De-Crackle")) { insertNodeBetween("De-Crackle"); }
                if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); }
                if (ImGui::MenuItem("Mixer")) { insertNodeBetween("Mixer"); }
                if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping oscillator"); }
                if (ImGui::MenuItem("Function Generator")) { insertNodeBetween("Function Generator"); }
                if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); }
                if (ImGui::MenuItem("Granulator")) { insertNodeBetween("Granulator"); }
                if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic shaper"); }
                if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("Vocal Tract Filter"); }
                if (ImGui::MenuItem("Scope")) { insertNodeBetween("Scope"); }
                if (ImGui::MenuItem("Frequency Graph")) { insertNodeBetween("Frequency Graph"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Modulation Path", isNodeSelected))
            {
                if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("Attenuverter"); }
                if (ImGui::MenuItem("Lag Processor")) { insertNodeBetween("Lag Processor"); }
                if (ImGui::MenuItem("Math")) { insertNodeBetween("Math"); }
                if (ImGui::MenuItem("MapRange")) { insertNodeBetween("MapRange"); }
                if (ImGui::MenuItem("Quantizer")) { insertNodeBetween("Quantizer"); }
                if (ImGui::MenuItem("S&H")) { insertNodeBetween("S&H"); }
                if (ImGui::MenuItem("Rate")) { insertNodeBetween("Rate"); }
                if (ImGui::MenuItem("Logic")) { insertNodeBetween("Logic"); }
                if (ImGui::MenuItem("Comparator")) { insertNodeBetween("Comparator"); }
                if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("CV Mixer"); }
                if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("Sequential Switch"); }
                ImGui::EndMenu();
            }
            
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Inspector"))
        {
            ImGui::SliderFloat("Window (s)", &inspectorWindowSeconds, 0.5f, 20.0f, "%.1f s");
            ImGui::EndMenu();
        }
        
        // === DEBUG MENU ===
        if (ImGui::BeginMenu("Debug"))
        {
            if (ImGui::MenuItem("Show System Diagnostics", "Ctrl+Shift+D")) 
            {
                showDebugMenu = !showDebugMenu;
            }
            
            
            if (ImGui::MenuItem("Log System State"))
            {
                if (synth != nullptr)
                {
                    juce::Logger::writeToLog("=== SYSTEM DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getSystemDiagnostics());
                }
            }
            
            if (ImGui::MenuItem("Log Selected Module Diagnostics"))
            {
                if (synth != nullptr && selectedLogicalId != 0)
                {
                    juce::Logger::writeToLog("=== MODULE DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getModuleDiagnostics(selectedLogicalId));
                }
            }
            
            ImGui::EndMenu();
        }
        
        // === TRANSPORT CONTROLS ===
        if (synth != nullptr)
        {
            // Get current transport state
            auto transportState = synth->getTransportState();
            
            // Add some spacing before transport controls
            ImGui::Separator();
            ImGui::Spacing();
            
            // Play/Pause button
            if (transportState.isPlaying)
            {
                if (ImGui::Button("Pause"))
                    synth->setPlaying(false);
            }
            else
            {
                if (ImGui::Button("Play"))
                    synth->setPlaying(true);
            }
            
            ImGui::SameLine();
            
            // Stop button (resets position)
            if (ImGui::Button("Stop"))
            {
                synth->setPlaying(false);
                synth->resetTransportPosition();
            }
            
            ImGui::SameLine();
            
            // BPM control (greyed out if controlled by Tempo Clock module)
            float bpm = static_cast<float>(transportState.bpm);
            ImGui::SetNextItemWidth(80.0f);
            
            bool isControlled = transportState.isTempoControlledByModule.load();
            if (isControlled)
                ImGui::BeginDisabled();
                
            if (ImGui::DragFloat("BPM", &bpm, 0.1f, 20.0f, 999.0f, "%.1f"))
                synth->setBPM(static_cast<double>(bpm));
                
            if (isControlled)
            {
                ImGui::EndDisabled();
                if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
                {
                    ImGui::BeginTooltip();
                    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                    ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Module Active");
                    ImGui::TextUnformatted("A Tempo Clock node with 'Sync to Host' disabled is controlling the global BPM.");
                    ImGui::PopTextWrapPos();
                    ImGui::EndTooltip();
                }
            }
            
            ImGui::SameLine();
            
            // Position display
            ImGui::Text("%.2f beats", transportState.songPositionBeats);
        }
        
        // === MULTI-MIDI DEVICE ACTIVITY INDICATOR ===
        ImGui::SameLine();
        ImGui::Separator();
        ImGui::SameLine();
        
        if (synth != nullptr)
        {
            auto activityState = synth->getMidiActivityState();
            
            if (activityState.deviceNames.empty())
            {
                // No MIDI devices connected
                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                ImGui::Text("MIDI: No Devices");
                ImGui::PopStyleColor();
            }
            else
            {
                ImGui::Text("MIDI:");
                ImGui::SameLine();
                
                // Display each device with active channels
                for (const auto& [deviceIndex, deviceName] : activityState.deviceNames)
                {
                    ImGui::SameLine();
                    
                    bool hasActivity = false;
                    if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                    {
                        const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                        for (bool active : channels)
                        {
                            if (active)
                            {
                                hasActivity = true;
                                break;
                            }
                        }
                    }
                    
                    // Abbreviated device name (max 12 chars)
                    juce::String abbrevName = deviceName;
                    if (abbrevName.length() > 12)
                        abbrevName = abbrevName.substring(0, 12) + "...";
                    
                    // Color: bright green if active, dim gray if inactive
                    if (hasActivity)
                        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255));
                    else
                        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                    
                    ImGui::Text("[%s]", abbrevName.toRawUTF8());
                    ImGui::PopStyleColor();
                    
                    // Tooltip with full name and active channels
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("%s", deviceName.toRawUTF8());
                        ImGui::Separator();
                        
                        if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                        {
                            const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                            ImGui::Text("Active Channels:");
                            juce::String activeChannels;
                            for (int ch = 0; ch < 16; ++ch)
                            {
                                if (channels[ch])
                                {
                                    if (activeChannels.isNotEmpty())
                                        activeChannels += ", ";
                                    activeChannels += juce::String(ch + 1);
                                }
                            }
                            if (activeChannels.isEmpty())
                                activeChannels = "None";
                            ImGui::Text("%s", activeChannels.toRawUTF8());
                        }
                        
                        ImGui::EndTooltip();
                    }
                }
            }
        }
        else
        {
            ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
            ImGui::Text("MIDI: ---");
            ImGui::PopStyleColor();
        }
        // === END OF MULTI-MIDI INDICATOR ===
        
        ImGui::EndMainMenuBar();
    }

    // --- PRESET STATUS OVERLAY ---
    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(0.7f);
    ImGui::Begin("Preset Status", nullptr, 
                 ImGuiWindowFlags_NoDecoration | 
                 ImGuiWindowFlags_NoMove | 
                 ImGuiWindowFlags_NoFocusOnAppearing | 
                 ImGuiWindowFlags_NoNav | 
                 ImGuiWindowFlags_AlwaysAutoResize);

    if (currentPresetFile.isNotEmpty()) {
        ImGui::Text("Preset: %s", currentPresetFile.toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    if (isPatchDirty) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");
    } else {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
    }

    ImGui::End();
    // --- END OF PRESET STATUS OVERLAY ---

    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, 260.0f);

    // Zoom removed

    // ADD THIS BLOCK:
    ImGui::Text("Browser");
    
    // Create a scrolling child window to contain the entire browser
    ImGui::BeginChild("BrowserScrollRegion", ImVec2(0, 0), true);
    
    // Helper lambda to recursively draw the directory tree for presets
    std::function<void(const PresetManager::DirectoryNode*)> drawPresetTree = 
        [&](const PresetManager::DirectoryNode* node)
    {
        if (!node || (node->presets.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawPresetTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw presets in this directory with drag-and-drop support
        for (const auto& preset : node->presets)
        {
            if (m_presetSearchTerm.isEmpty() || preset.name.containsIgnoreCase(m_presetSearchTerm))
            {
                // Draw the selectable item and capture its return value
                bool clicked = ImGui::Selectable(preset.name.toRawUTF8());

                // --- THIS IS THE FIX ---
                // Check if this item is the source of a drag operation
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload type and data (the preset's file path)
                    const juce::String path = preset.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_PRESET_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback while dragging
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Merge Preset: %s", preset.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // If a drag did NOT occur, and the item was clicked, load the preset
                else if (clicked)
                {
                    loadPresetFromFile(preset.file);
                }
                // --- END OF FIX ---
                
                // Tooltip (only shown when hovering, not dragging)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0) && preset.description.isNotEmpty())
                {
                    ImGui::BeginTooltip();
                    ImGui::TextUnformatted(preset.description.toRawUTF8());
                    if (!preset.tags.isEmpty())
                        ImGui::Text("Tags: %s", preset.tags.joinIntoString(", ").toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // Helper to push category colors (used for all module category headers)
    auto pushCategoryColor = [&](ModuleCategory cat) {
        ImU32 color = getImU32ForCategory(cat);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        ImGui::PushStyleColor(ImGuiCol_Header, color);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
    };

    // === PRESET BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(218, 165, 32, 255)); // Gold
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(238, 185, 52, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(255, 205, 72, 255));
    bool presetsExpanded = ImGui::CollapsingHeader("Presets");
    ImGui::PopStyleColor(3);
    
    if (presetsExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_presetScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##presetpath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##preset"))
        {
            presetPathChooser = std::make_unique<juce::FileChooser>("Select Preset Directory", m_presetScanPath);
            presetPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_presetScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("presetScanPath", m_presetScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##preset"))
        {
            m_presetManager.clearCache();
            m_presetManager.scanDirectory(m_presetScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_presetSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##preset", searchBuf, sizeof(searchBuf)))
            m_presetSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical preset tree
        drawPresetTree(m_presetManager.getRootNode());
    }
    
    // Helper lambda to recursively draw the directory tree for samples
    std::function<void(const SampleManager::DirectoryNode*)> drawSampleTree = 
        [&](const SampleManager::DirectoryNode* node)
    {
        if (!node || (node->samples.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawSampleTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw samples in this directory with drag-and-drop support
        for (const auto& sample : node->samples)
        {
            if (m_sampleSearchTerm.isEmpty() || sample.name.containsIgnoreCase(m_sampleSearchTerm))
            {
                // --- THIS IS THE HEROIC FIX ---

                // A. Draw the selectable item and capture its return value (which is true on mouse release).
                bool clicked = ImGui::Selectable(sample.name.toRawUTF8());

                // B. Check if this item is the source of a drag operation. This takes priority.
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload (the data we are transferring is the sample's file path).
                    const juce::String path = sample.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_SAMPLE_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback during the drag.
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Dragging: %s", sample.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // C. If a drag did NOT occur, and the item was clicked (mouse released on it), then create the node.
                else if (clicked)
                {
                    if (synth != nullptr)
                    {
                        auto newNodeId = synth->addModule("sample_loader");
                        auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                        pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                        if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                        {
                            sampleLoader->loadSample(sample.file);
                        }
                        snapshotAfterEditor = true;
                    }
                }
                
                // --- END OF FIX ---

                // (Existing tooltip for sample info remains the same)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Duration: %.2f s", sample.durationSeconds);
                    ImGui::Text("Rate: %d Hz", sample.sampleRate);
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // === SAMPLE BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(0, 180, 180, 255)); // Cyan
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(20, 200, 200, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(40, 220, 220, 255));
    bool samplesExpanded = ImGui::CollapsingHeader("Samples");
    ImGui::PopStyleColor(3);
    
    if (samplesExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_sampleScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##samplepath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##sample"))
        {
            samplePathChooser = std::make_unique<juce::FileChooser>("Select Sample Directory", m_sampleScanPath);
            samplePathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_sampleScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("sampleScanPath", m_sampleScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##sample"))
        {
            m_sampleManager.clearCache();
            m_sampleManager.scanDirectory(m_sampleScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_sampleSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##sample", searchBuf, sizeof(searchBuf)))
            m_sampleSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical sample tree
        drawSampleTree(m_sampleManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MIDI BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(180, 120, 255, 255)); // Purple
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(200, 140, 255, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(220, 160, 255, 255));
    bool midiExpanded = ImGui::CollapsingHeader("MIDI Files");
    ImGui::PopStyleColor(3);
    
    if (midiExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_midiScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##midipath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##midi"))
        {
            midiPathChooser = std::make_unique<juce::FileChooser>("Select MIDI Directory", m_midiScanPath);
            midiPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_midiScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("midiScanPath", m_midiScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##midi"))
        {
            m_midiManager.clearCache();
            m_midiManager.scanDirectory(m_midiScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_midiSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##midi", searchBuf, sizeof(searchBuf)))
            m_midiSearchTerm = juce::String(searchBuf);

        ImGui::Separator();
        
        // 5. Display hierarchical MIDI tree
        std::function<void(const MidiManager::DirectoryNode*)> drawMidiTree = 
            [&](const MidiManager::DirectoryNode* node)
        {
            if (!node || (node->midiFiles.empty() && node->subdirectories.empty())) return;

            // Draw subdirectories first
            for (const auto& subdir : node->subdirectories)
            {
                if (ImGui::TreeNode(subdir->name.toRawUTF8()))
                {
                    drawMidiTree(subdir.get());
                    ImGui::TreePop();
                }
            }
            
            // Then draw MIDI files in this directory with drag-and-drop support
            for (const auto& midi : node->midiFiles)
            {
                if (m_midiSearchTerm.isEmpty() || midi.name.containsIgnoreCase(m_midiSearchTerm))
                {
                    // Draw the selectable item and capture its return value
                    bool clicked = ImGui::Selectable(midi.name.toRawUTF8());

                    // Check if this item is the source of a drag operation
                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                    {
                        // Set the payload (the MIDI file path)
                        const juce::String path = midi.file.getFullPathName();
                        const std::string pathStr = path.toStdString();
                        ImGui::SetDragDropPayload("DND_MIDI_PATH", pathStr.c_str(), pathStr.length() + 1);
                        
                        // Provide visual feedback during the drag
                        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                        ImGui::Text("Dragging: %s", midi.name.toRawUTF8());
                        
                        ImGui::EndDragDropSource();
                    }
                    // If a drag did NOT occur, and the item was clicked, create a new MIDI Player node
                    else if (clicked)
                    {
                        if (synth != nullptr)
                        {
                            auto newNodeId = synth->addModule("midi_player");
                            auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                            pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                            
                            // Load the MIDI file into the new player
                            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                            {
                                midiPlayer->loadMIDIFile(midi.file);
                            }
                            
                            snapshotAfterEditor = true;
                        }
                    }
                    
                    // Tooltip for MIDI info (only shown when hovering, not dragging)
                    if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("MIDI File: %s", midi.file.getFileName().toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
            }
        };
        
        drawMidiTree(m_midiManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MODULE BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(80, 80, 80, 255)); // Neutral Grey
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(100, 100, 100, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(120, 120, 120, 255));
    bool modulesExpanded = ImGui::CollapsingHeader("Modules", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    
    if (modulesExpanded)
    {
    
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
        
        // --- FIX: Show tooltip with module description on hover ---
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            
            // Find the description in our list using the module's internal 'type'
            bool found = false;
            for (const auto& pair : getModuleDescriptions())
            {
                if (pair.first.equalsIgnoreCase(type))
                {
                    // If found, display it
                    ImGui::TextUnformatted(pair.second);
                    found = true;
                    break;
                }
            }
            if (!found)
            {
                // Fallback text if a description is missing
                ImGui::TextUnformatted("No description available.");
            }
            
            ImGui::EndTooltip();
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // MODULE NAMING CONVENTION:
    // ─────────────────────────────────────────────────────────────────────────────── 
    // ALL module type names MUST follow this strict naming convention:
    //   • Use ONLY lowercase letters (a-z)
    //   • Use ONLY numbers (0-9) where appropriate
    //   • Replace ALL spaces with underscores (_)
    //   • NO capital letters allowed
    //   • NO hyphens or other special characters
    //
    // Examples:
    //   ✓ CORRECT:   "midi_player", "sample_loader", "graphic_eq", "vco"
    //   ✗ INCORRECT: "MIDI Player", "Sample Loader", "Graphic EQ", "VCO"
    //
    // This ensures consistent module identification across the system.
    // ═══════════════════════════════════════════════════════════════════════════════
    
    pushCategoryColor(ModuleCategory::Source);
    bool sourcesExpanded = ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (sourcesExpanded) {
    addModuleButton("Audio Input", "audio_input");
    addModuleButton("VCO", "vco");
    addModuleButton("Polyphonic VCO", "polyvco");
    addModuleButton("Noise", "noise");
        addModuleButton("Sequencer", "sequencer");
        addModuleButton("Multi Sequencer", "multi_sequencer");
        addModuleButton("Stroke Sequencer", "stroke_sequencer");
        addModuleButton("Value", "value");
        addModuleButton("Sample Loader", "sample_loader");
    }
    
    pushCategoryColor(ModuleCategory::MIDI);
    bool midiFamilyExpanded = ImGui::CollapsingHeader("MIDI Family", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (midiFamilyExpanded) {
        addModuleButton("MIDI CV", "midi_cv");
        addModuleButton("MIDI Player", "midi_player");
        ImGui::Separator();
        addModuleButton("MIDI Faders", "midi_faders");
        addModuleButton("MIDI Knobs", "midi_knobs");
        addModuleButton("MIDI Buttons", "midi_buttons");
        addModuleButton("MIDI Jog Wheel", "midi_jog_wheel");
        addModuleButton("MIDI Pads", "midi_pads");
        ImGui::Separator();
        addModuleButton("MIDI Logger", "midi_logger");
        ImGui::Separator();
    }
    
    pushCategoryColor(ModuleCategory::Source);
    bool ttsFamilyExpanded = ImGui::CollapsingHeader("TTS Family", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (ttsFamilyExpanded) {

        addModuleButton("TTS Performer", "tts_performer");
        addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
    }
    
    pushCategoryColor(ModuleCategory::Physics);
    bool physicsFamilyExpanded = ImGui::CollapsingHeader("Physics Family", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (physicsFamilyExpanded) {
        addModuleButton("Physics", "physics");
        addModuleButton("Animation", "animation");
    }
    
    pushCategoryColor(ModuleCategory::Effect);
    bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (effectsExpanded) {
        addModuleButton("VCF", "vcf");
        // addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
        addModuleButton("Delay", "delay");
        addModuleButton("Reverb", "reverb");
        addModuleButton("Chorus", "chorus");
        addModuleButton("Phaser", "phaser");
        addModuleButton("Compressor", "compressor");
        addModuleButton("Recorder", "recorder");
        addModuleButton("Limiter", "limiter");
        addModuleButton("Noise Gate", "gate");
        addModuleButton("Drive", "drive");
        addModuleButton("Graphic EQ", "graphic_eq");
        addModuleButton("Time/Pitch Shifter", "timepitch");
        addModuleButton("Waveshaper", "waveshaper");
        addModuleButton("8-Band Shaper", "8bandshaper");
        addModuleButton("Granulator", "granulator");
        addModuleButton("Harmonic Shaper", "harmonic_shaper");
    }
    
    pushCategoryColor(ModuleCategory::Modulator);
    bool modulatorsExpanded = ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (modulatorsExpanded) {
        addModuleButton("LFO", "lfo");
        addModuleButton("ADSR", "adsr");
        addModuleButton("Random", "random");
    addModuleButton("S&H", "s_and_h");
            addModuleButton("Function Generator", "function_generator");
        addModuleButton("Shaping Oscillator", "shaping_oscillator");

    }
    
    pushCategoryColor(ModuleCategory::Utility);
    bool utilitiesExpanded = ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (utilitiesExpanded) {
        addModuleButton("VCA", "vca");
        addModuleButton("Mixer", "mixer");
        addModuleButton("CV Mixer", "cv_mixer");
        addModuleButton("Track Mixer", "track_mixer");
    addModuleButton("Attenuverter", "attenuverter");
        addModuleButton("Lag Processor", "lag_processor");
        addModuleButton("De-Crackle", "de_crackle");
        addModuleButton("Math", "math");
        addModuleButton("Map Range", "map_range");
        addModuleButton("Quantizer", "quantizer");
        addModuleButton("Rate", "rate");
        addModuleButton("Comparator", "comparator");
        addModuleButton("Logic", "logic");
        addModuleButton("Clock Divider", "clock_divider");
        addModuleButton("Sequential Switch", "sequential_switch");
        addModuleButton("Tempo Clock", "tempo_clock");
        addModuleButton("Snapshot Sequencer", "snapshot_sequencer");
        addModuleButton("Best Practice", "best_practice");
    }
    
    pushCategoryColor(ModuleCategory::Analysis);
    bool analysisExpanded = ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (analysisExpanded) {
        addModuleButton("Scope", "scope");
        addModuleButton("Debug", "debug");
        addModuleButton("Input Debug", "input_debug");
        addModuleButton("Frequency Graph", "frequency_graph");
    }
    
    } // End of Modules collapsing header
    
    // VST Plugins section
    pushCategoryColor(ModuleCategory::Plugin);
    bool pluginsExpanded = ImGui::CollapsingHeader("Plugins", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (pluginsExpanded) {
        addPluginModules();
    }

    // End the scrolling region
    ImGui::EndChild();

    ImGui::NextColumn();

    // --- DEFINITIVE FIX FOR PRESET DRAG-AND-DROP WITH VISUAL FEEDBACK ---
    // Step 1: Define canvas dimensions first (needed for the drop target)
    const ImU32 GRID_COLOR = IM_COL32(50, 50, 50, 255);
    const ImU32 GRID_ORIGIN_COLOR = IM_COL32(80, 80, 80, 255);
    const float GRID_SIZE = 64.0f;
    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Step 2: Create a full-canvas invisible button to act as our drop area
    ImGui::SetCursorScreenPos(canvas_p0);
    ImGui::InvisibleButton("##canvas_drop_target", canvas_sz);

    // Step 3: Make this area a drop target with visual feedback
    if (ImGui::BeginDragDropTarget())
    {
        // Check if a preset payload is being hovered over the canvas
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_PRESET_PATH", ImGuiDragDropFlags_AcceptBeforeDelivery))
        {
            // Draw a semi-transparent overlay to show the canvas is a valid drop zone
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            drawList->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(218, 165, 32, 80)); // Preset Gold color
            
            // Check if the mouse button was released to complete the drop
            if (payload->IsDelivery())
            {
                const char* path = (const char*)payload->Data;
                ImVec2 dropPos = ImGui::GetMousePos(); // Get the exact drop position
                mergePresetFromFile(juce::File(path), dropPos);
            }
        }
        ImGui::EndDragDropTarget();
    }
    // --- END OF DEFINITIVE FIX ---

    // Reset cursor position for subsequent drawing
    ImGui::SetCursorScreenPos(canvas_p0);

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinId({0, c.dstChan, true}) : 
                encodePinId({c.dstLogicalId, c.dstChan, true});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = IM_COL32(150, 150, 150, 255); // Grey for disconnected
    const ImU32 colPinConnected = IM_COL32(120, 255, 120, 255); // Green for connected
    // <<< END OF BLOCK >>>

    // Pre-register is no longer needed - stateless encoding generates IDs on-the-fly
    // (Removed the old pre-registration loop)

    // --- BACKGROUND GRID AND COORDINATE DISPLAY ---
    // (Canvas dimensions already defined above in the drop target code)
    ImDrawList* draw_list = ImGui::GetBackgroundDrawList();
    ImVec2 panning = ImNodes::EditorContextGetPanning();

    // Draw grid lines
    for (float x = fmodf(panning.x, GRID_SIZE); x < canvas_sz.x; x += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p0.y + canvas_sz.y), GRID_COLOR);
    for (float y = fmodf(panning.y, GRID_SIZE); y < canvas_sz.y; y += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + y), GRID_COLOR);

    // Draw thicker lines for the origin (0,0)
    ImVec2 origin_on_screen = ImVec2(canvas_p0.x + panning.x, canvas_p0.y + panning.y);
    draw_list->AddLine(ImVec2(origin_on_screen.x, canvas_p0.y), ImVec2(origin_on_screen.x, canvas_p1.y), GRID_ORIGIN_COLOR, 2.0f);
    draw_list->AddLine(ImVec2(canvas_p0.x, origin_on_screen.y), ImVec2(canvas_p1.x, origin_on_screen.y), GRID_ORIGIN_COLOR, 2.0f);

    // Draw scale markers every 400 grid units as a grid (not a cross)
    const float SCALE_INTERVAL = 400.0f;
    const ImU32 SCALE_TEXT_COLOR = IM_COL32(150, 150, 150, 80); // Reduced opacity
    ImDrawList* fg_draw_list = ImGui::GetForegroundDrawList();
    
    // X-axis scale markers - always at the bottom edge
    float gridLeft = -panning.x;
    float gridRight = canvas_sz.x - panning.x;
    int startX = (int)std::floor(gridLeft / SCALE_INTERVAL);
    int endX = (int)std::ceil(gridRight / SCALE_INTERVAL);
    
    for (int i = startX; i <= endX; ++i)
    {
        float gridX = i * SCALE_INTERVAL;
        float screenX = canvas_p0.x + panning.x + gridX;
        
        // Only draw if visible on screen
        if (screenX >= canvas_p0.x && screenX <= canvas_p1.x)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridX);
            // Always draw at bottom edge
            fg_draw_list->AddText(ImVec2(screenX + 2, canvas_p1.y - 45), SCALE_TEXT_COLOR, label);
        }
    }
    
    // Y-axis scale markers - always at the left edge
    float gridTop = -panning.y;
    float gridBottom = canvas_sz.y - panning.y;
    int startY = (int)std::floor(gridTop / SCALE_INTERVAL);
    int endY = (int)std::ceil(gridBottom / SCALE_INTERVAL);
    
    for (int i = startY; i <= endY; ++i)
    {
        float gridY = i * SCALE_INTERVAL;
        float screenY = canvas_p0.y + panning.y + gridY;
        
        // Only draw if visible on screen
        if (screenY >= canvas_p0.y && screenY <= canvas_p1.y)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridY);
            // Always draw at left edge
            fg_draw_list->AddText(ImVec2(canvas_p0.x + 5, screenY + 2), SCALE_TEXT_COLOR, label);
        }
    }

    // Mouse coordinate display overlay (bottom-left)
    ImVec2 mouseScreenPos = ImGui::GetMousePos();
    ImVec2 mouseGridPos = ImVec2(mouseScreenPos.x - canvas_p0.x - panning.x, mouseScreenPos.y - canvas_p0.y - panning.y);
    char posStr[32];
    snprintf(posStr, sizeof(posStr), "%.0f, %.0f", mouseGridPos.x, mouseGridPos.y);
    // Use the foreground draw list to ensure text is on top of everything
    // Position at bottom-left: canvas_p1.y is bottom edge, subtract text height plus padding
    ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), IM_COL32(200, 200, 200, 150), posStr);
    // --- END OF BACKGROUND GRID AND COORDINATE DISPLAY ---

    // Node canvas bound to the underlying model if available
    ImNodes::BeginNodeEditor();
    // Begin the editor

    // +++ ADD THIS LINE AT THE START OF THE RENDER LOOP +++
    attrPositions.clear(); // Clear the cache at the beginning of each frame.
    // Rebuild mod attribute mapping from currently drawn nodes only
    // modAttrToParam.clear(); // TODO: Remove when fully migrated
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    // Track duplicates to diagnose disappearing pins
    std::unordered_set<int> seenAttrs;
    auto linkIdOf = [this] (int srcAttr, int dstAttr) -> int
    {
        return getLinkId(srcAttr, dstAttr);
    };

    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                if (!(x == 0.0f && y == 0.0f))
                    pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        // Graph is now always in consistent state since we rebuild at frame start
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;

            // Color-code modules by category (base colors)
            const auto moduleCategory = getModuleCategory(type);
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, getImU32ForCategory(moduleCategory));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));

            // Highlight nodes participating in the hovered link (overrides category color)
            const bool isHoveredSource = (hoveredLinkSrcId != 0 && hoveredLinkSrcId == (juce::uint32) lid);
            const bool isHoveredDest   = (hoveredLinkDstId != 0 && hoveredLinkDstId == (juce::uint32) lid);
            if (isHoveredSource || isHoveredDest)
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));

            // Visual feedback for muted nodes (overrides category color and hover)
            const bool isMuted = mutedNodeStates.count(lid) > 0;
            if (isMuted) {
                ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(80, 80, 80, 255));
            }

            ImNodes::BeginNode ((int) lid);
            ImNodes::BeginNodeTitleBar();
            ImGui::TextUnformatted (type.toRawUTF8());
            ImNodes::EndNodeTitleBar();

            // Constrain node content width for compact layout and predictable label placement
            const float nodeContentWidth = 240.0f;

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
if (auto* mp = synth->getModuleForLogical (lid))
{
    ImGui::PushID ((int) lid);

    // This new lambda function checks if a parameter is being modulated
    auto isParamModulated = [&](const juce::String& paramId) -> bool {
        if (!synth) return false;
        if (auto* mp = synth->getModuleForLogical(lid))
        {
            int busIdx = -1, chInBus = -1;
            // Use the new standardized routing API on the module itself
            if (!mp->getParamRouting(paramId, busIdx, chInBus)) 
                return false;

            // Calculate the absolute channel index that the graph uses for this bus/channel pair
            const int absoluteChannelIndex = mp->getChannelIndexInProcessBlockBuffer(true, busIdx, chInBus);
            if (absoluteChannelIndex < 0) return false;
            
            // Scan the simple graph connections for a match
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == lid && c.dstChan == absoluteChannelIndex)
                    return true;
            }
        }
        return false;
    };

    // Helper to read a live, modulated value if available (respects _mod alias)
    auto getLiveValueOr = [&](const juce::String& paramId, float fallback) -> float
    {
        if (!synth) return fallback;
        if (auto* mp = synth->getModuleForLogical(lid))
            return mp->getLiveParamValueFor(paramId + "_mod", paramId + "_live", fallback);
        return fallback;
    };

    // Create a new function that calls pushSnapshot
    auto onModificationEnded = [&](){ this->pushSnapshot(); };

    // --- SPECIAL RENDERING FOR SAMPLE LOADER ---
    if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (buttons, sliders, etc.)
        // We pass a modified onModificationEnded to avoid creating undo states while dragging.
        sampleLoader->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);

        // Now, handle the spectrogram texture and drawing
        juce::OpenGLTexture* texturePtr = nullptr;
        if (auto it = sampleLoaderTextureIds.find((int)lid); it != sampleLoaderTextureIds.end())
            texturePtr = it->second.get();

        juce::Image spectrogram = sampleLoader->getSpectrogramImage();
        if (spectrogram.isValid())
        {
            if (texturePtr == nullptr)
            {
                auto tex = std::make_unique<juce::OpenGLTexture>();
                texturePtr = tex.get();
                sampleLoaderTextureIds[(int)lid] = std::move(tex);
            }
            // Upload or update texture from JUCE image (handles format & parameters internally)
            texturePtr->loadImage(spectrogram);

            ImGui::Image((void*)(intptr_t) texturePtr->getTextureID(), ImVec2(nodeContentWidth, 100.0f));

            // Drag state is tracked per Sample Loader node to avoid cross-node interference
            static std::unordered_map<int,int> draggedHandleByNode; // lid -> -1,0,1
            int& draggedHandle = draggedHandleByNode[(int) lid];
            if (draggedHandle != 0 && draggedHandle != 1) draggedHandle = -1;
            ImGui::SetCursorScreenPos(ImGui::GetItemRectMin());
            ImGui::InvisibleButton("##spectrogram_interaction", ImVec2(nodeContentWidth, 100.0f));

            auto* drawList = ImGui::GetWindowDrawList();
            const ImVec2 rectMin = ImGui::GetItemRectMin();
            const ImVec2 rectMax = ImGui::GetItemRectMax();

            float startNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeStart")->load();
            float endNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeEnd")->load();

            // Use live telemetry values when modulated
            startNorm = sampleLoader->getLiveParamValueFor("rangeStart_mod", "rangeStart_live", startNorm);
            endNorm = sampleLoader->getLiveParamValueFor("rangeEnd_mod", "rangeEnd_live", endNorm);

            // Visual guard even when modulated
            const float kMinGap = 0.001f;
            startNorm = juce::jlimit(0.0f, 1.0f, startNorm);
            endNorm   = juce::jlimit(0.0f, 1.0f, endNorm);
            if (startNorm >= endNorm)
            {
                if (startNorm <= 1.0f - kMinGap)
                    endNorm = juce::jmin(1.0f, startNorm + kMinGap);
                else
                    startNorm = juce::jmax(0.0f, endNorm - kMinGap);
            }

            // --- FIX FOR BUG 1: Separate modulation checks for each handle ---
            bool startIsModulated = isParamModulated("rangeStart_mod");
            bool endIsModulated = isParamModulated("rangeEnd_mod");

            const bool itemHovered = ImGui::IsItemHovered();
            const bool itemActive  = ImGui::IsItemActive();
            if (itemHovered)
            {
                ImVec2 mousePos = ImGui::GetMousePos();
                float startHandleX = rectMin.x + startNorm * nodeContentWidth;
                float endHandleX = rectMin.x + endNorm * nodeContentWidth;

                bool canDragStart = !startIsModulated && (std::abs(mousePos.x - startHandleX) < 5);
                bool canDragEnd = !endIsModulated && (std::abs(mousePos.x - endHandleX) < 5);

                if (draggedHandle == -1 && (canDragStart || canDragEnd))
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                }

                if (ImGui::IsItemClicked())
                {
                    // Only allow dragging to start if the corresponding handle is not modulated
                    if (canDragStart && canDragEnd)
                        draggedHandle = (std::abs(mousePos.x - startHandleX) < std::abs(mousePos.x - endHandleX)) ? 0 : 1;
                    else if (canDragStart)
                        draggedHandle = 0;
                    else if (canDragEnd)
                        draggedHandle = 1;
                }
            }

            if (itemActive && ImGui::IsMouseReleased(0))
            {
                if (draggedHandle != -1) onModificationEnded();
                draggedHandle = -1;
            }

            // Handle the drag update, checking the specific modulation flag for the active handle
            if (itemActive && draggedHandle != -1 && ImGui::IsMouseDragging(0))
            {
                float newNormX = juce::jlimit(0.0f, 1.0f, (ImGui::GetMousePos().x - rectMin.x) / nodeContentWidth);
                if (draggedHandle == 0 && !startIsModulated)
                {
                    // Guard: start cannot be >= end
                    startNorm = juce::jmin(newNormX, endNorm - 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeStart")->setValueNotifyingHost(startNorm);
                }
                else if (draggedHandle == 1 && !endIsModulated)
                {
                    // Guard: end cannot be <= start
                    endNorm = juce::jmax(newNormX, startNorm + 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeEnd")->setValueNotifyingHost(endNorm);
                }
            }

            float startX = rectMin.x + startNorm * nodeContentWidth;
            float endX = rectMin.x + endNorm * nodeContentWidth;
            drawList->AddRectFilled(rectMin, ImVec2(startX, rectMax.y), IM_COL32(0, 0, 0, 120));
            drawList->AddRectFilled(ImVec2(endX, rectMin.y), rectMax, IM_COL32(0, 0, 0, 120));
            drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
            drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
        }
    }
    // --- SPECIAL RENDERING FOR AUDIO INPUT (MULTI-CHANNEL) ---
    else if (auto* audioIn = dynamic_cast<AudioInputModuleProcessor*>(mp))
    {
        auto& apvts = audioIn->getAPVTS();

        // --- Device Selectors ---
        juce::AudioDeviceManager::AudioDeviceSetup setup;
        deviceManager.getAudioDeviceSetup(setup);
        
        // Input Device
        juce::StringArray availableInputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableInputDevices = deviceType->getDeviceNames(true);
        }
        std::vector<const char*> inputDeviceItems;
        for (const auto& name : availableInputDevices) inputDeviceItems.push_back(name.toRawUTF8());
        int currentInputDeviceIndex = availableInputDevices.indexOf(setup.inputDeviceName);
        if (currentInputDeviceIndex < 0) currentInputDeviceIndex = 0;

        ImGui::PushItemWidth(nodeContentWidth);
        if (ImGui::Combo("Input Device", &currentInputDeviceIndex, inputDeviceItems.data(), (int)inputDeviceItems.size())) {
            if (currentInputDeviceIndex < availableInputDevices.size()) {
                setup.inputDeviceName = availableInputDevices[currentInputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }

        // Output Device
        juce::StringArray availableOutputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableOutputDevices = deviceType->getDeviceNames(false);
        }
        std::vector<const char*> outputDeviceItems;
        for (const auto& name : availableOutputDevices) outputDeviceItems.push_back(name.toRawUTF8());
        int currentOutputDeviceIndex = availableOutputDevices.indexOf(setup.outputDeviceName);
        if (currentOutputDeviceIndex < 0) currentOutputDeviceIndex = 0;
        
        if (ImGui::Combo("Output Device", &currentOutputDeviceIndex, outputDeviceItems.data(), (int)outputDeviceItems.size())) {
            if (currentOutputDeviceIndex < availableOutputDevices.size()) {
                setup.outputDeviceName = availableOutputDevices[currentOutputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }
        
        // --- Channel Count ---
        auto* numChannelsParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("numChannels"));
        int numChannels = numChannelsParam->get();
        if (ImGui::SliderInt("Channels", &numChannels, 1, AudioInputModuleProcessor::MAX_CHANNELS)) {
            *numChannelsParam = numChannels;
            onModificationEnded();
        }
        
        // --- Threshold Sliders ---
        auto* gateThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"));
        float gateThresh = gateThreshParam->get();
        if (ImGui::SliderFloat("Gate Threshold", &gateThresh, 0.0f, 1.0f, "%.3f")) {
            *gateThreshParam = gateThresh;
            onModificationEnded();
        }
        
        auto* trigThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("triggerThreshold"));
        float trigThresh = trigThreshParam->get();
        if (ImGui::SliderFloat("Trigger Threshold", &trigThresh, 0.0f, 1.0f, "%.3f")) {
            *trigThreshParam = trigThresh;
            onModificationEnded();
        }
        
        ImGui::PopItemWidth();

        // --- Dynamic Channel Selectors & VU Meters ---
        auto hardwareChannels = deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getInputChannelNames() : juce::StringArray{};
        if (!hardwareChannels.isEmpty())
        {
            std::vector<const char*> hwChannelItems;
            for (const auto& name : hardwareChannels) hwChannelItems.push_back(name.toRawUTF8());
            
            for (int i = 0; i < numChannels; ++i) {
                auto* mappingParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(i)));
                int selectedHwChannel = mappingParam->get();
                selectedHwChannel = juce::jlimit(0, (int)hwChannelItems.size() - 1, selectedHwChannel);

                ImGui::PushID(i);
                ImGui::PushItemWidth(nodeContentWidth * 0.6f);
                if (ImGui::Combo(("Input for Out " + juce::String(i + 1)).toRawUTF8(), &selectedHwChannel, hwChannelItems.data(), (int)hwChannelItems.size())) {
                    *mappingParam = selectedHwChannel;
                    std::vector<int> newMapping(numChannels);
                    for (int j = 0; j < numChannels; ++j) {
                        auto* p = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(j)));
                        newMapping[j] = p->get();
                    }
                    synth->setAudioInputChannelMapping(synth->getNodeIdForLogical(lid), newMapping);
                    onModificationEnded();
                }
                ImGui::PopItemWidth();

                ImGui::SameLine();
                
                // --- VU Meter with Threshold Lines ---
                float level = (i < (int)audioIn->channelLevels.size() && audioIn->channelLevels[i]) ? audioIn->channelLevels[i]->load() : 0.0f;
                ImVec2 meterSize(nodeContentWidth * 0.38f, ImGui::GetTextLineHeightWithSpacing() * 0.8f);
                ImGui::ProgressBar(level, meterSize, "");

                // Draw threshold lines on top of the progress bar
                ImVec2 p_min = ImGui::GetItemRectMin();
                ImVec2 p_max = ImGui::GetItemRectMax();
                ImDrawList* draw_list = ImGui::GetWindowDrawList();

                // Gate Threshold (Yellow)
                float gateLineX = p_min.x + gateThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);

                // Trigger Threshold (Orange)
                float trigLineX = p_min.x + trigThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
                
                ImGui::PopID();
            }
        }
    }
    // --- SPECIAL RENDERING FOR SNAPSHOT SEQUENCER ---
    // Commented out - SnapshotSequencerModuleProcessor causing build errors
    /*else if (auto* snapshotSeq = dynamic_cast<SnapshotSequencerModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (number of steps, etc.)
        snapshotSeq->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
        
        ImGui::Separator();
        ImGui::Text("Snapshot Management:");
        
        const int numSteps = 8; // Default, could read from parameter
        const int currentStepIndex = 0; // TODO: Get from module if exposed
        
        // Draw capture/clear buttons for each step
        for (int i = 0; i < numSteps; ++i)
        {
            ImGui::PushID(i);
            
            bool stored = snapshotSeq->isSnapshotStored(i);
            
            // Capture button
            if (ImGui::Button("Capture"))
            {
                // Get the current state of the whole synth
                juce::MemoryBlock currentState;
                synth->getStateInformation(currentState);
                
                // Store it in the snapshot sequencer
                snapshotSeq->setSnapshotForStep(i, currentState);
                
                // Create undo state
                pushSnapshot();
                
                juce::Logger::writeToLog("[SnapshotSeq UI] Captured snapshot for step " + juce::String(i));
            }
            
            ImGui::SameLine();
            
            // Clear button (only enabled if snapshot exists)
            if (!stored)
            {
                ImGui::BeginDisabled();
            }
            
            if (ImGui::Button("Clear"))
            {
                snapshotSeq->clearSnapshotForStep(i);
                pushSnapshot();
                juce::Logger::writeToLog("[SnapshotSeq UI] Cleared snapshot for step " + juce::String(i));
            }
            
            if (!stored)
            {
                ImGui::EndDisabled();
            }
            
            ImGui::PopID();
        }
    }*/
    else
    {
        mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);
    }
    ImGui::Spacing();
    ImGui::PopID();
}
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
            
            // Helper to draw right-aligned text within a node's content width
            // From imnodes examples (color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73):
            // Use ImGui::Indent() for right-alignment - this is the CORRECT ImNodes pattern!
            auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
            {
                const ImVec2 textSize = ImGui::CalcTextSize(txt);
                
                // Indent by (nodeWidth - textWidth) to right-align the text
                // CRITICAL: Must call Unindent() to prevent indent from persisting!
                const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
                ImGui::Indent(indentAmount);
                ImGui::TextUnformatted(txt);
                ImGui::Unindent(indentAmount);  // Reset indent!
            };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinId({lid, channel, true});
                seenAttrs.insert(attr);
                availableAttrs.insert(attr);

                // Get pin data type for color coding
                PinID pinId = { lid, channel, true, false, "" };
                PinDataType pinType = this->getPinDataTypeForPin(pinId);
                unsigned int pinColor = this->getImU32ForType(pinType);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                ImNodes::BeginInputAttribute(attr); ImGui::TextUnformatted(label); ImNodes::EndInputAttribute();

                // --- THIS IS THE DEFINITIVE FIX ---
                // Get the bounding box of the pin circle that was just drawn.
                ImVec2 pinMin = ImGui::GetItemRectMin();
                ImVec2 pinMax = ImGui::GetItemRectMax();
                // Calculate the exact center and cache it.
                float centerX = (pinMin.x + pinMax.x) * 0.5f;
                float centerY = (pinMin.y + pinMax.y) * 0.5f;
                attrPositions[attr] = ImVec2(centerX, centerY);
                // --- END OF FIX ---

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                {
                                    float value = srcMod->getOutputChannelValue(c.srcChan);
                                    ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                    ImGui::Text("Value: %.3f", value);
                                }
                                break; 
                            }
                        }
                    } else {
                        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                    }
                    // Show pin data type
                    ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                    ImGui::EndTooltip();
                }
            };

                // NEW CLEAN OUTPUT PIN TEXT FUNCTION - FIXED SPACING
                helpers.drawAudioOutputPin = [&](const char* label, int channel)
                {
                    const int attr = encodePinId({(juce::uint32)lid, channel, false});
                    seenAttrs.insert(attr);
                    availableAttrs.insert(attr);

                    PinID pinId = {(juce::uint32)lid, channel, false, false, ""};
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(attr) > 0;

                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                    // EXACT OFFICIAL PATTERN: Text right-aligned, pin touches text edge
                    ImNodes::BeginOutputAttribute(attr);
                    const float label_width = ImGui::CalcTextSize(label).x;
                    ImGui::Indent(nodeContentWidth - label_width);  // Right-align to content width
                    ImGui::TextUnformatted(label);
                    ImGui::Unindent(nodeContentWidth - label_width);
                    ImNodes::EndOutputAttribute();

                    // Cache pin center
                    {
                        ImVec2 pinMin = ImGui::GetItemRectMin();
                        ImVec2 pinMax = ImGui::GetItemRectMax();
                        float centerY = (pinMin.y + pinMax.y) * 0.5f;
                        float x_pos   = pinMax.x;
                        attrPositions[attr] = ImVec2(x_pos, centerY);
                    }

                    ImNodes::PopColorStyle();

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        if (isConnected) {
                            ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        } else {
                            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                        }
                        ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                        if (auto* mp = synth->getModuleForLogical(lid))
                        {
                            float value = mp->getOutputChannelValue(channel);
                            ImGui::Text("Value: %.3f", value);
                        }
                        ImGui::EndTooltip();
                    }
                };

            // ADD THE NEW drawParallelPins HELPER
            helpers.drawParallelPins = [&](const char* inLabel, int inChannel, const char* outLabel, int outChannel)
            {
                // 3-column layout: [InputPin] [Right-aligned Output Label] [Output Pin]
                ImGui::PushID((inChannel << 16) ^ outChannel ^ lid);
                ImGui::Columns(3, "parallel_io_layout", false);

                const float pinW = 18.0f;
                const float spacing = ImGui::GetStyle().ItemSpacing.x;
                // CRITICAL FIX: Use stable nodeContentWidth to set ALL column widths explicitly
                // This prevents the feedback loop that causes position-dependent node scaling
                
                // Calculate column widths to fill exactly nodeContentWidth
                float inTextW = inLabel ? ImGui::CalcTextSize(inLabel).x : 0.0f;
                float inColW = inLabel ? (inTextW + pinW + spacing) : 0.0f;  // Input label + pin + spacing
                float outPinColW = 20.0f;  // Output pin column (fixed narrow width)
                float labelColW = nodeContentWidth - inColW - outPinColW - spacing;  // Middle fills remaining space

                ImGui::SetColumnWidth(0, inColW);
                ImGui::SetColumnWidth(1, labelColW);
                ImGui::SetColumnWidth(2, outPinColW);

                // Column 0: Input pin with label
                if (inLabel != nullptr)
                {
                    int inAttr = encodePinId({lid, inChannel, true});
                    seenAttrs.insert(inAttr);
                    availableAttrs.insert(inAttr);
                    PinID pinId = { lid, inChannel, true, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedInputAttrs.count(inAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginInputAttribute(inAttr);
                    ImGui::TextUnformatted(inLabel);
                    ImNodes::EndInputAttribute();
                    ImNodes::PopColorStyle();
                }

                // Column 1: Output label (right-aligned within this column)
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    // EXACT OFFICIAL PATTERN: Same as regular output pins
                    const float textW = ImGui::CalcTextSize(outLabel).x;
                    ImGui::Indent(labelColW - textW);  // Right-align to column width
                    ImGui::TextUnformatted(outLabel);
                    ImGui::Unindent(labelColW - textW);
                }

                // Column 2: Output pin
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    int outAttr = encodePinId({lid, outChannel, false});
                    seenAttrs.insert(outAttr);
                    availableAttrs.insert(outAttr);
                    PinID pinId = { lid, outChannel, false, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(outAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginOutputAttribute(outAttr);
                    ImGui::Dummy(ImVec2(1.0f, ImGui::GetTextLineHeight()));
                    ImNodes::EndOutputAttribute();

                    // Cache pin center
                    ImVec2 pinMin = ImGui::GetItemRectMin();
                    ImVec2 pinMax = ImGui::GetItemRectMax();
                    float yCenter = pinMin.y + (pinMax.y - pinMin.y) * 0.5f;
                    float xPos = pinMax.x;
                    attrPositions[outAttr] = ImVec2(xPos, yCenter);
                    ImNodes::PopColorStyle();
                }

                // Restore to single column for the next row
                ImGui::Columns(1);
                ImGui::PopID();
            };

            // --- DYNAMIC PIN FIX ---
            // Add a new helper that uses dynamic pin information from modules
            helpers.drawIoPins = [&](ModuleProcessor* module) {
                if (!module) return;
                const auto logicalId = module->getLogicalId();
                const auto moduleType = synth->getModuleTypeForLogical(logicalId);

                // 1. Get dynamic pins from the module itself.
                auto dynamicInputs = module->getDynamicInputPins();
                auto dynamicOutputs = module->getDynamicOutputPins();

                // 2. Get static pins from the database as a fallback.
                const auto& pinDb = getModulePinDatabase();
                auto pinInfoIt = pinDb.find(moduleType.toLowerCase());
                const bool hasStaticPinInfo = (pinInfoIt != pinDb.end());
                const auto& staticPinInfo = hasStaticPinInfo ? pinInfoIt->second : ModulePinInfo{};

                // 3. If the module has dynamic pins, use the new system
                const bool hasDynamicPins = !dynamicInputs.empty() || !dynamicOutputs.empty();
                
                if (hasDynamicPins)
                {
                    // Draw inputs (dynamic if available, otherwise static)
                    if (!dynamicInputs.empty())
                    {
                        for (const auto& pin : dynamicInputs)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioIns)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    
                    // Draw outputs (dynamic if available, otherwise static)
                    if (!dynamicOutputs.empty())
                    {
                        for (const auto& pin : dynamicOutputs)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioOuts)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                }
                else
                {
                    // 4. Otherwise, fall back to the module's custom drawIoPins implementation
                    module->drawIoPins(helpers);
                }
            };
            // --- END OF DYNAMIC PIN FIX ---

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                    helpers.drawIoPins(mp);

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
            
            // Cache position for snapshot safety
            // Graph is always in consistent state since we rebuild at frame start
            lastKnownNodePositions[(int)lid] = ImNodes::GetNodeGridSpacePos((int)lid);
            
            // Pop muted node styles (in reverse order of push)
            if (isMuted) {
                ImNodes::PopColorStyle();      // Mute TitleBar
                ImGui::PopStyleVar();          // Alpha
                ImNodes::PopStyleVar();        // NodePadding
            }
            
            // Pop hover highlight color
            if (isHoveredSource || isHoveredDest)
                ImNodes::PopColorStyle();      // Hover TitleBar
            
            // Pop category colors (in reverse order of push)
            ImNodes::PopColorStyle();          // TitleBarSelected
            ImNodes::PopColorStyle();          // TitleBarHovered
            ImNodes::PopColorStyle();          // TitleBar
            
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
        if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
        {
            // Apply saved position once; do not write (0,0) defaults
            const ImVec2 p = it->second;
            if (!(p.x == 0.0f && p.y == 0.0f))
            {
                ImNodes::SetNodeGridSpacePos((int) lid, p);
                juce::Logger::writeToLog("[PositionRestore] Applied pending position for node " + juce::String((int)lid) + ": (" + juce::String(p.x) + ", " + juce::String(p.y) + ")");
            }
            pendingNodePositions.erase(it);
        }
            // Apply pending size if queued (for Comment nodes to prevent feedback loop)
            if (auto itSize = pendingNodeSizes.find((int) lid); itSize != pendingNodeSizes.end())
            {
                // Store the desired size in the Comment module itself
                if (auto* comment = dynamic_cast<CommentModuleProcessor*>(synth->getModuleForLogical((juce::uint32)lid)))
                {
                    comment->nodeWidth = itSize->second.x;
                    comment->nodeHeight = itSize->second.y;
                }
                pendingNodeSizes.erase(itSize);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        bool triggerInsertMixer = false;
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0)
            {
                mutedNodeStates.erase((juce::uint32)selectedLogicalId); // Clean up muted state if exists
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                // Post-state snapshot
                pushSnapshot();
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    // Post-state snapshot after duplication and position
                    pushSnapshot();
                }
            }
            if (ImGui::MenuItem("Insert Mixer", "Ctrl+T") && selectedLogicalId != 0) { triggerInsertMixer = true; }
            ImGui::EndPopup();
        }

        // Shortcut: Ctrl+T to insert a Mixer after selected node and reroute
        // Debounced Ctrl+T
        const bool ctrlDown = ImGui::GetIO().KeyCtrl;
        if (!ctrlDown) {
            mixerShortcutCooldown = false;
            insertNodeShortcutCooldown = false;
        }
        // Ctrl+R: Record Output
        if (ctrlDown && ImGui::IsKeyPressed(ImGuiKey_R, false))
        {
            handleRecordOutput();
        }
        
        if ((triggerInsertMixer || (selectedLogicalId != 0 && ctrlDown && ImGui::IsKeyPressed(ImGuiKey_T))) && !mixerShortcutCooldown)
        {
            mixerShortcutCooldown = true; // Prevent re-triggering in the same frame
            const juce::uint32 srcLid = (juce::uint32) selectedLogicalId;

            juce::Logger::writeToLog("--- [InsertMixer] Start ---");
            juce::Logger::writeToLog("[InsertMixer] Selected Node Logical ID: " + juce::String(srcLid));

            auto srcNodeId = synth->getNodeIdForLogical(srcLid);
            if (srcNodeId.uid == 0) 
            {
                juce::Logger::writeToLog("[InsertMixer] ABORT: Source node with logical ID " + juce::String(srcLid) + " is invalid or could not be found.");
            } 
            else 
            {
                // 1. Collect all outgoing connections from the selected node
                std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
                for (const auto& c : synth->getConnectionsInfo()) {
                    if (c.srcLogicalId == srcLid) {
                        outgoingConnections.push_back(c);
                    }
                }
                juce::Logger::writeToLog("[InsertMixer] Found " + juce::String(outgoingConnections.size()) + " outgoing connections to reroute.");
                for (const auto& c : outgoingConnections) {
                    juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                    juce::Logger::writeToLog("  - Stored connection: [Src: " + juce::String(c.srcLogicalId) + ":" + juce::String(c.srcChan) + "] -> [Dst: " + destStr + ":" + juce::String(c.dstChan) + "]");
                }

                // 2. Create and position the new mixer node intelligently
                auto mixNodeIdGraph = synth->addModule("mixer");
                const juce::uint32 mixLid = synth->getLogicalIdForNode(mixNodeIdGraph);
                
                ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(selectedLogicalId);
                ImVec2 avgDestPos = srcPos; // Default to source pos if no outputs
                
                if (!outgoingConnections.empty())
                {
                    float totalX = 0.0f, totalY = 0.0f;
                    for (const auto& c : outgoingConnections)
                    {
                        int destId = c.dstIsOutput ? 0 : (int)c.dstLogicalId;
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(destId);
                        totalX += pos.x;
                        totalY += pos.y;
                    }
                    avgDestPos = ImVec2(totalX / outgoingConnections.size(), totalY / outgoingConnections.size());
                }
                else
                {
                    // If there are no outgoing connections, place it to the right
                    avgDestPos.x += 600.0f;
                }
                
                // Place the new mixer halfway between the source and the average destination
                pendingNodePositions[(int)mixLid] = ImVec2((srcPos.x + avgDestPos.x) * 0.5f, (srcPos.y + avgDestPos.y) * 0.5f);
                juce::Logger::writeToLog("[InsertMixer] Added new Mixer. Logical ID: " + juce::String(mixLid) + ", Node ID: " + juce::String(mixNodeIdGraph.uid));

                // 3. Disconnect all original outgoing links
                juce::Logger::writeToLog("[InsertMixer] Disconnecting original links...");
                for (const auto& c : outgoingConnections) {
                    auto currentSrcNodeId = synth->getNodeIdForLogical(c.srcLogicalId);
                    auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);

                    if (currentSrcNodeId.uid != 0 && dstNodeId.uid != 0) {
                        bool success = synth->disconnect(currentSrcNodeId, c.srcChan, dstNodeId, c.dstChan);
                        juce::Logger::writeToLog("  - Disconnecting [" + juce::String(currentSrcNodeId.uid) + ":" + juce::String(c.srcChan) + "] -> [" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                    } else {
                        juce::Logger::writeToLog("  - SKIPPING Disconnect due to invalid node ID.");
                    }
                }

                // 4. Connect the source node to the new mixer's first input
                juce::Logger::writeToLog("[InsertMixer] Connecting source node to new mixer...");
                bool c1 = synth->connect(srcNodeId, 0, mixNodeIdGraph, 0); // L to In A L
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":0] -> [" + juce::String(mixNodeIdGraph.uid) + ":0]... " + (c1 ? "SUCCESS" : "FAILED"));
                bool c2 = synth->connect(srcNodeId, 1, mixNodeIdGraph, 1); // R to In A R
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":1] -> [" + juce::String(mixNodeIdGraph.uid) + ":1]... " + (c2 ? "SUCCESS" : "FAILED"));


                // 5. Connect the mixer's output to all the original destinations (maintaining the chain)
                juce::Logger::writeToLog("[InsertMixer] Connecting mixer to original destinations to maintain chain...");
                if (outgoingConnections.empty()) {
                    juce::Logger::writeToLog("  - No original outgoing connections. Connecting mixer to Main Output by default.");
                    auto outNode = synth->getOutputNodeID();
                    if (outNode.uid != 0) {
                        bool o1 = synth->connect(mixNodeIdGraph, 0, outNode, 0);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":0] -> [Output:0]... " + (o1 ? "SUCCESS" : "FAILED"));
                        bool o2 = synth->connect(mixNodeIdGraph, 1, outNode, 1);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":1] -> [Output:1]... " + (o2 ? "SUCCESS" : "FAILED"));
                    }
                } else {
                    for (const auto& c : outgoingConnections) {
                        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                        if (dstNodeId.uid != 0) {
                            // Connect mixer output to the same destination the original node was connected to
                            // This maintains the chain: original -> mixer -> destination
                            bool success = synth->connect(mixNodeIdGraph, c.srcChan, dstNodeId, c.dstChan);
                            juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                            juce::Logger::writeToLog("  - Maintaining chain: Mixer [" + juce::String(mixNodeIdGraph.uid) + ":" + juce::String(c.srcChan) + "] -> " + destStr + "[" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                        } else {
                            juce::Logger::writeToLog("  - SKIPPING Reconnect due to invalid destination node ID for original logical ID " + juce::String(c.dstLogicalId));
                        }
                    }
                }

                graphNeedsRebuild = true;
                pushSnapshot(); // Make the entire operation undoable
                juce::Logger::writeToLog("[InsertMixer] Rerouting complete. Flagging for graph rebuild.");
            }
            juce::Logger::writeToLog("--- [InsertMixer] End ---");
        }

        // Shortcut: Ctrl+I to show Insert Node popup menu
        if (selectedLogicalId != 0 && ctrlDown && ImGui::IsKeyPressed(ImGuiKey_I) && !insertNodeShortcutCooldown)
        {
            insertNodeShortcutCooldown = true;
            showInsertNodePopup = true;
        }

        // Insert Node popup menu
        if (showInsertNodePopup)
        {
            ImGui::OpenPopup("InsertNodePopup");
            showInsertNodePopup = false;
        }

        if (ImGui::BeginPopup("InsertNodePopup"))
        {
            ImGui::Text("Insert Node Between Connections");
            
            // Audio Path
            if (ImGui::MenuItem("VCF")) { insertNodeBetween("VCF"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("VCA")) { insertNodeBetween("VCA"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Delay")) { insertNodeBetween("Delay"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Reverb")) { insertNodeBetween("Reverb"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Mixer")) { insertNodeBetween("Mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping oscillator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Granulator")) { insertNodeBetween("Granulator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic shaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("Vocal Tract Filter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Scope")) { insertNodeBetween("Scope"); ImGui::CloseCurrentPopup(); }
            
            ImGui::Separator();
            
            // Modulation Path
            if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("Attenuverter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Math")) { insertNodeBetween("Math"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Comparator")) { insertNodeBetween("Comparator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("CV Mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("Sequential Switch"); ImGui::CloseCurrentPopup(); }
            
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        const bool isOutputHovered = (hoveredLinkDstId == kOutputHighlightId);
        if (isOutputHovered)
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted ("Output");
        ImNodes::EndNodeTitleBar();
        if (isOutputHovered)
            ImNodes::PopColorStyle();
        
        // In L pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 0, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 0, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
            ImGui::Text ("In L");
            ImNodes::EndInputAttribute();
            ImNodes::PopColorStyle();
        }
        
        // In R pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 1, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 1, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
            ImGui::Text ("In R");
            ImNodes::EndInputAttribute();
            ImNodes::PopColorStyle();
        }
        
        ImNodes::EndNode();
        
        // Cache output node position for snapshot safety
        // Graph is always in consistent state since we rebuild at frame start
        lastKnownNodePositions[0] = ImNodes::GetNodeGridSpacePos(0);
        
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            juce::Logger::writeToLog("[PositionRestore] Applied pending position for output node 0: (" + juce::String(it->second.x) + ", " + juce::String(it->second.y) + ")");
            pendingNodePositions.erase(it);
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections (IDs stable via bitmasking)
        int cableIdx = 0;
        for (const auto& c : synth->getConnectionsInfo())
        {
            
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) {
                continue;
            }
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) {
                continue;
            }
            
            const int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            const int dstAttr = c.dstIsOutput ? encodePinId({0, c.dstChan, true}) : encodePinId({c.dstLogicalId, c.dstChan, true});
            
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
            {
                static std::unordered_set<std::string> skipOnce;
                const std::string key = std::to_string((int)c.srcLogicalId) + ":" + std::to_string(c.srcChan) + "->" +
                                         (c.dstIsOutput? std::string("0") : std::to_string((int)c.dstLogicalId)) + ":" + std::to_string(c.dstChan);
                if (skipOnce.insert(key).second)
                {
                    juce::Logger::writeToLog(
                        juce::String("[ImNodes][SKIP] missing attr: srcPresent=") + (availableAttrs.count(srcAttr)?"1":"0") +
                        " dstPresent=" + (availableAttrs.count(dstAttr)?"1":"0") +
                        " srcKey=(lid=" + juce::String((int)c.srcLogicalId) + ",ch=" + juce::String(c.srcChan) + ")" +
                        " dstKey=(lid=" + juce::String(c.dstIsOutput?0:(int)c.dstLogicalId) + ",ch=" + juce::String(c.dstChan) + ",in=1) id(s)=" +
                        juce::String(srcAttr) + "," + juce::String(dstAttr));
                }
                continue;
            }
            
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            
            // --- THIS IS THE DEFINITIVE FIX ---
            // 1. Determine the base color and check for signal activity.
            auto srcPin = decodePinId(srcAttr);
            PinDataType linkDataType = getPinDataTypeForPin(srcPin);
            ImU32 linkColor = getImU32ForType(linkDataType);
            float magnitude = 0.0f;
            bool hasThicknessModification = false;

            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
            {
                magnitude = srcModule->getOutputChannelValue(srcPin.channel);
            }

            // 2. If the signal is active, calculate a glowing/blinking color.
            if (magnitude > 0.01f)
            {
                const float blinkSpeed = 8.0f;
                float blinkFactor = (std::sin((float)ImGui::GetTime() * blinkSpeed) + 1.0f) * 0.5f;
                float glowIntensity = juce::jlimit(0.0f, 1.0f, blinkFactor * magnitude * 2.0f);

                // Brighten the base color and modulate alpha for glow effect
                ImVec4 colorVec = ImGui::ColorConvertU32ToFloat4(linkColor);
                colorVec.x = juce::jmin(1.0f, colorVec.x + glowIntensity * 0.4f);
                colorVec.y = juce::jmin(1.0f, colorVec.y + glowIntensity * 0.4f);
                colorVec.z = juce::jmin(1.0f, colorVec.z + glowIntensity * 0.4f);
                colorVec.w = juce::jlimit(0.5f, 1.0f, 0.5f + glowIntensity * 0.5f);
                linkColor = ImGui::ColorConvertFloat4ToU32(colorVec);

                // Make active cables slightly thicker
                ImNodes::PushStyleVar(ImNodesStyleVar_LinkThickness, 3.0f);
                hasThicknessModification = true;
            }

            // 3. Push the chosen color (either normal or glowing) to the style stack.
            ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);
            ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(255, 255, 0, 255));
            ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(255, 255, 0, 255));

            // 4. Check for node hover highlight (this should override the glow).
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(255, 255, 0, 255));
            }
            
            // 5. Tell imnodes to draw the link. It will use the color we just pushed.
            ImNodes::Link(linkId, srcAttr, dstAttr);
            
            // 6. Pop ALL style modifications to restore the defaults for the next link.
            if (hl) ImNodes::PopColorStyle();
            ImNodes::PopColorStyle(); // LinkSelected
            ImNodes::PopColorStyle(); // LinkHovered
            ImNodes::PopColorStyle(); // Link
            if (hasThicknessModification) ImNodes::PopStyleVar(); // LinkThickness
            
            // --- END OF FIX ---
        }

        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    // --- Handle Auto-Connect Requests from MIDI Players ---
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
        {
            // Check for initial button presses
            if (midiPlayer->autoConnectTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Samplers;
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO;
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Hybrid;
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            // --- THIS IS THE NEW LOGIC ---
            // Check if an update was requested after a new file was loaded
            else if (midiPlayer->connectionUpdateRequested.exchange(false))
            {
                // Re-run the correct handler based on the saved state
                switch (midiPlayer->lastAutoConnectState.load())
                {
                    case MIDIPlayerModuleProcessor::AutoConnectState::Samplers:
                        handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO:
                        handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::Hybrid:
                        handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::None:
                    default:
                        // Do nothing if it wasn't auto-connected before
                        break;
                }
            }
            // --- END OF NEW LOGIC ---
        }
    }

    // --- Handle Auto-Connect Requests using new intelligent system ---
    handleAutoConnectionRequests();

    ImNodes::MiniMap (0.2f, ImNodesMiniMapLocation_BottomRight);

    ImNodes::EndNodeEditor();
    
    // ================== MIDI PLAYER QUICK CONNECT LOGIC ==================
    // Poll all MIDI Player modules for connection requests
    if (synth != nullptr)
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                int requestType = midiPlayer->getAndClearConnectionRequest();
                if (requestType > 0)
                {
                    handleMIDIPlayerConnectionRequest(modInfo.first, midiPlayer, requestType);
                    break; // Only handle one request per frame
                }
            }
        }
    }
    // ================== END MIDI PLAYER QUICK CONNECT ==================
    
    // ================== META MODULE EDITING LOGIC ==================
    // Check if any Meta Module has requested to be edited
    if (synth != nullptr && metaModuleToEditLid == 0) // Only check if not already editing one
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                // Atomically check and reset the flag
                if (metaModule->editRequested.exchange(false))
                {
                    metaModuleToEditLid = modInfo.first;
                    juce::Logger::writeToLog("[MetaEdit] Opening editor for Meta Module L-ID " + juce::String((int)metaModuleToEditLid));
                    ImGui::OpenPopup("Edit Meta Module");
                    break; // Only handle one request per frame
                }
            }
        }
    }
    
    // Draw the modal popup for the internal editor if one is selected
    if (metaModuleToEditLid != 0)
    {
        ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
        if (ImGui::BeginPopupModal("Edit Meta Module", nullptr, ImGuiWindowFlags_MenuBar))
        {
            // Get the internal synth processor from the meta module
            auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaModuleToEditLid));
            if (metaModule && metaModule->getInternalGraph())
            {
                // Display a placeholder for now
                // TODO: Full recursive editor implementation would go here
                ImGui::Text("Editing internal graph of Meta Module %d", (int)metaModuleToEditLid);
                ImGui::Separator();
                
                auto* internalGraph = metaModule->getInternalGraph();
                auto modules = internalGraph->getModulesInfo();
                
                ImGui::Text("Internal modules: %d", (int)modules.size());
                if (ImGui::BeginChild("ModuleList", ImVec2(0, -30), true))
                {
                    for (const auto& [lid, type] : modules)
                    {
                        ImGui::Text("  [%d] %s", (int)lid, type.toRawUTF8());
                    }
                }
                ImGui::EndChild();
                
                ImGui::Text("NOTE: Full nested editor UI is a TODO");
                ImGui::Text("For now, you can inspect the internal graph structure above.");
            }
            
            if (ImGui::Button("Close"))
            {
                ImGui::CloseCurrentPopup();
                metaModuleToEditLid = 0;
                // When closing, the meta module might have new/removed inlets/outlets,
                // so we need to rebuild the main graph to update its pins
                graphNeedsRebuild = true;
            }
            ImGui::EndPopup();
        }
        else
        {
            // If the popup was closed by the user (e.g., pressing ESC)
            metaModuleToEditLid = 0;
            graphNeedsRebuild = true;
        }
    }
    // ======================= END OF META MODULE LOGIC =======================

    // --- CONSOLIDATED HOVERED LINK DETECTION ---
    // Declare these variables ONCE, immediately after the editor has ended.
    // All subsequent features that need to know about hovered links can now
    // safely reuse these results without causing redefinition or scope errors.
    // Graph is always in consistent state since we rebuild at frame start
    int hoveredLinkId = -1;
    bool isLinkHovered = ImNodes::IsLinkHovered(&hoveredLinkId);
    // --- END OF CONSOLIDATED DECLARATION ---
    
    // Smart cable visualization is now integrated directly into the link drawing loop above.
    // No separate overlay needed - cables glow by modifying their own color.
    
    // === PROBE TOOL MODE HANDLING ===
    if (isProbeModeActive)
    {
        // Change cursor to indicate probe mode is active
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        
        // Draw "PROBE ACTIVE" indicator at mouse position
        auto* drawList = ImGui::GetForegroundDrawList();
        ImVec2 mousePos = ImGui::GetMousePos();
        const char* text = "PROBE MODE: Click output pin";
        auto textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImVec2(mousePos.x + 20, mousePos.y - 20);
        drawList->AddRectFilled(
            ImVec2(textPos.x - 5, textPos.y - 2),
            ImVec2(textPos.x + textSize.x + 5, textPos.y + textSize.y + 2),
            IM_COL32(50, 50, 50, 200)
        );
        drawList->AddText(textPos, IM_COL32(255, 255, 100, 255), text);
        
        // Check for pin clicks
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                auto pinId = decodePinId(hoveredPinId);
                // Check if it's an output pin (not input, not mod)
                if (!pinId.isInput && !pinId.isMod && pinId.logicalId != 0)
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on valid output pin. LogicalID: " + juce::String(pinId.logicalId) + ", Channel: " + juce::String(pinId.channel));
                    auto nodeId = synth->getNodeIdForLogical(pinId.logicalId);
                    synth->setProbeConnection(nodeId, pinId.channel);
                    isProbeModeActive = false; // Deactivate after probing
                }
                else
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on an invalid pin (input or output node). Cancelling.");
                    isProbeModeActive = false;
                }
            }
            else
            {
                // Clicked on empty space, cancel probe mode
                juce::Logger::writeToLog("[PROBE_UI] Probe clicked on empty space. Cancelling.");
                isProbeModeActive = false;
            }
        }
        
        // Allow ESC to cancel probe mode
        if (ImGui::IsKeyPressed(ImGuiKey_Escape))
        {
            isProbeModeActive = false;
            juce::Logger::writeToLog("[PROBE_UI] Cancelled with ESC");
        }
    }

    // --- CONTEXTUAL RIGHT-CLICK HANDLER ---
    // A cable was right-clicked. Store its info and open the insert popup.
    if (isLinkHovered && hoveredLinkId != -1 && ImGui::IsMouseClicked(ImGuiMouseButton_Right))
    {
        juce::Logger::writeToLog("[InsertNode][RC] Hovered link id=" + juce::String(hoveredLinkId));
        // A cable was right-clicked. Store its info and open the insert popup.
        linkToInsertOn = {}; // Reset previous info
        linkToInsertOn.linkId = hoveredLinkId;

        bool captured = false;
        // TODO: Implement modulation link detection for new bus-based system
        // if (modLinkIdToRoute.count(hoveredLinkId))
        // {
        //     linkToInsertOn.isMod = true;
        //     auto& route = modLinkIdToRoute[hoveredLinkId];
        //     linkToInsertOn.srcLogicalId = std::get<0>(route);
        //     linkToInsertOn.srcChan = std::get<1>(route);
        //     linkToInsertOn.dstLogicalId = std::get<2>(route);
        //     linkToInsertOn.paramId = std::get<3>(route);
        //     juce::Logger::writeToLog("[InsertNode][RC] Mod link captured: srcLID=" + juce::String((int)linkToInsertOn.srcLogicalId) +
        //                               " srcChan=" + juce::String(linkToInsertOn.srcChan) +
        //                               " dstLID=" + juce::String((int)linkToInsertOn.dstLogicalId) +
        //                               " param='" + linkToInsertOn.paramId + "'");
        //     captured = true;
        // }
        if (linkIdToAttrs.count(hoveredLinkId))
        {
            linkToInsertOn.isMod = false;
            auto& attrs = linkIdToAttrs[hoveredLinkId];
            juce::Logger::writeToLog("[InsertNode][RC] Audio link attrs: srcAttr=" + juce::String(attrs.first) +
                                      " dstAttr=" + juce::String(attrs.second));
            linkToInsertOn.srcPin = decodePinId(attrs.first);
            linkToInsertOn.dstPin = decodePinId(attrs.second);
            juce::Logger::writeToLog("[InsertNode][RC] Audio pins: src(lid=" + juce::String((int)linkToInsertOn.srcPin.logicalId) +
                                      ",ch=" + juce::String(linkToInsertOn.srcPin.channel) +
                                      ",in=" + juce::String((int)linkToInsertOn.srcPin.isInput) + ") -> dst(lid=" +
                                      juce::String((int)linkToInsertOn.dstPin.logicalId) + ",ch=" +
                                      juce::String(linkToInsertOn.dstPin.channel) + ",in=" +
                                      juce::String((int)linkToInsertOn.dstPin.isInput) + ")");
            captured = true;
        }
        else
        {
            juce::Logger::writeToLog("[InsertNode][RC] Link id not found in maps");
        }

        if (captured)
        {
            showInsertNodePopup = true; // defer opening until after EndNodeEditor
            pendingInsertLinkId = hoveredLinkId;
            juce::Logger::writeToLog("[InsertNode][RC] Will open popup after EndNodeEditor");
        }
        else
        {
            linkToInsertOn.linkId = -1; // nothing recognized; do not open
        }
    }

    // --- Keyboard Shortcuts for Node Chaining ---
    // Check if multiple nodes are selected and no modifiers are held
    if (ImNodes::NumSelectedNodes() > 1 && !ImGui::GetIO().KeyCtrl && !ImGui::GetIO().KeyShift && !ImGui::GetIO().KeyAlt)
    {
        // C: Standard stereo chaining (channels 0->0, 1->1)
        if (ImGui::IsKeyPressed(ImGuiKey_C))
        {
            handleNodeChaining();
        }
        // G: Audio type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_G))
        {
            handleColorCodedChaining(PinDataType::Audio);
        }
        // B: CV type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_B))
        {
            handleColorCodedChaining(PinDataType::CV);
        }
        // R: Raw type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_R))
        {
            handleColorCodedChaining(PinDataType::Raw);
        }
        // Y: Gate type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_Y))
        {
            handleColorCodedChaining(PinDataType::Gate);
        }
    }
    // --- END OF KEYBOARD SHORTCUTS ---

    // --- Cable Splitting (Ctrl+Middle-Click) ---
    if (isLinkHovered && hoveredLinkId != -1)
    {
        if (ImGui::GetIO().KeyCtrl && ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            // User initiated a split. Find the source pin of the hovered link.
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                splittingFromAttrId = it->second.first; // The source attribute ID
                juce::Logger::writeToLog("[CableSplit] Starting split from attr ID: " + juce::String(splittingFromAttrId));
            }
        }
    }
    // --- END OF CABLE SPLITTING ---

    // 2. If a split-drag is active, handle drawing and completion.
    if (splittingFromAttrId != -1)
    {
        // Draw a line from the source pin to the mouse cursor for visual feedback.
        if (auto it = attrPositions.find(splittingFromAttrId); it != attrPositions.end())
        {
            ImVec2 sourcePos = it->second;
            ImVec2 mousePos = ImGui::GetMousePos();
            ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, IM_COL32(255, 255, 0, 200), 3.0f);
        }

        // 3. Handle completion or cancellation of the drag.
        // We use Left-click to complete the link, matching ImNodes' default behavior.
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                // User dropped the link on a pin.
                auto srcPin = decodePinId(splittingFromAttrId);
                auto dstPin = decodePinId(hoveredPinId);

                // Ensure the connection is valid (Output -> Input).
                if (!srcPin.isInput && dstPin.isInput)
                {
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    graphNeedsRebuild = true;
                    pushSnapshot(); // Make it undoable
                }
            }

            // ALWAYS reset the state, whether the connection was successful or not.
            splittingFromAttrId = -1;
        }
        // Also allow cancellation with a right-click.
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            splittingFromAttrId = -1; // Cancel the operation.
        }
    }
    // --- END OF NEW LOGIC ---

    // Open popup now (outside editor) if requested this frame
    if (showInsertNodePopup)
    {
        showInsertNodePopup = false;
        // Validate the link still exists
        if (pendingInsertLinkId != -1)
        {
            bool stillValid = (/* modLinkIdToRoute.count(pendingInsertLinkId) || */ linkIdToAttrs.count(pendingInsertLinkId));
            if (!stillValid)
            {
                juce::Logger::writeToLog("[InsertNode] Skipping popup: link disappeared this frame");
                pendingInsertLinkId = -1;
            }
        }
        if (pendingInsertLinkId != -1)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            // Consume the mouse release/click so the popup stays open
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode] Opened popup (post-editor)");
        }
        else
        {
            linkToInsertOn = {}; // safety
        }
        pendingInsertLinkId = -1;
    }

    // Fallback: If user right-clicked and a link was hovered this frame, open popup using cached hover
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Right)
        && lastHoveredLinkId != -1
        && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        int id = lastHoveredLinkId;
        linkToInsertOn = {}; linkToInsertOn.linkId = id;
        bool captured = false;
        // TODO: Handle modulation link deletion for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(id); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][RC-Fallback] Mod link captured id=" + juce::String(id));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            captured = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Audio link captured id=" + juce::String(id));
        }
        if (captured)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Opened popup");
        }
        else
        {
            linkToInsertOn.linkId = -1;
        }
    }
    // This function draws the popup if the popup is open.
    drawInsertNodeOnLinkPopup();

    // --- Cable Inspector: Stateless, rebuild-safe implementation ---
    hoveredLinkSrcId = 0;
    hoveredLinkDstId = 0;

    // Skip inspector if popups are open (graph is always in consistent state now)
    const bool anyPopupOpen = ImGui::IsPopupOpen("InsertNodeOnLinkPopup") || ImGui::IsPopupOpen("AddModulePopup");
    // Do not early-return here; we still need to finish the frame and close any ImGui scopes.

    if (!anyPopupOpen && isLinkHovered && hoveredLinkId != -1 && synth != nullptr)
    {
        // Safety: Re-verify link still exists in our mapping
        auto it = linkIdToAttrs.find(hoveredLinkId);
        if (it != linkIdToAttrs.end())
        {
            auto srcPin = decodePinId(it->second.first);
            auto dstPin = decodePinId(it->second.second);

            // Set highlight IDs for this frame only
            hoveredLinkSrcId = srcPin.logicalId;
            hoveredLinkDstId = (dstPin.logicalId == 0) ? kOutputHighlightId : dstPin.logicalId;

            // Query source module (no caching - stateless)
            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
            {
                // Validate channel index
                const int numOutputs = srcModule->getTotalNumOutputChannels();
                if (srcPin.channel >= 0 && srcPin.channel < numOutputs)
                {
                    // Optional: Throttle value sampling to 60 Hz (every 16.67ms)
                    // For now, query every frame for responsive UI
                    const float liveValue = srcModule->getOutputChannelValue(srcPin.channel);
                    const juce::String srcName = srcModule->getName();
                    const juce::String srcLabel = srcModule->getAudioOutputLabel(srcPin.channel);

                    // Render tooltip (stateless - no caching)
                    ImGui::BeginTooltip();
                    ImGui::Text("Value: %.3f", liveValue);
                    ImGui::Text("From: %s (ID %u)", srcName.toRawUTF8(), (unsigned)srcPin.logicalId);
                    if (srcLabel.isNotEmpty())
                        ImGui::Text("Pin: %s", srcLabel.toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    }
    

    // Update hovered node/link id for next frame (must be called outside editor scope)
    // Graph is always in consistent state since we rebuild at frame start
    int hv = -1;
    if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    
    int hl = -1;
    if (ImNodes::IsLinkHovered(&hl)) lastHoveredLinkId = hl; else lastHoveredLinkId = -1;
    

    // Shortcut: press 'I' while hovering a link to open Insert-on-Link popup (bypasses mouse handling)
    if (ImGui::IsKeyPressed(ImGuiKey_I) && lastHoveredLinkId != -1 && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        linkToInsertOn = {}; // reset
        linkToInsertOn.linkId = lastHoveredLinkId;
        bool captured = false;
        // TODO: Handle modulation link hover end for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(lastHoveredLinkId); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][KeyI] Mod link captured id=" + juce::String(lastHoveredLinkId));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(lastHoveredLinkId); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            captured = true;
            juce::Logger::writeToLog("[InsertNode][KeyI] Audio link captured id=" + juce::String(lastHoveredLinkId));
        }
        if (captured)
        {
            pendingInsertLinkId = lastHoveredLinkId;
            showInsertNodePopup = true; // will open next lines
        }
        else
        {
            linkToInsertOn.linkId = -1;
            juce::Logger::writeToLog("[InsertNode][KeyI] No link data found for id=" + juce::String(lastHoveredLinkId));
        }
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }

    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        // Avoid passing nullptr to ImNodes::IsLinkHovered; some builds may write to the pointer
        int dummyHoveredLinkId = -1;
        const bool anyLinkHovered = ImNodes::IsLinkHovered(&dummyHoveredLinkId);
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered()
            && !anyLinkHovered
            && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup")
            && linkToInsertOn.linkId == -1) // avoid conflict with insert-on-link popup
        {
                ImGui::OpenPopup("AddModulePopup");
        }

        // --- REVISED AND IMPROVED "QUICK ADD" POPUP ---
        if (ImGui::BeginPopup("AddModulePopup"))
        {
            static char searchQuery[128] = "";

            // Auto-focus the search bar when the popup opens and clear any previous search
            if (ImGui::IsWindowAppearing()) {
                ImGui::SetKeyboardFocusHere(0);
                searchQuery[0] = '\0';
            }
            
            ImGui::Text("Add Module");
            ImGui::PushItemWidth(250.0f);
            if (ImGui::InputText("Search##addmodule", searchQuery, sizeof(searchQuery))) {
                // Text was changed
            }
            ImGui::PopItemWidth();
            ImGui::Separator();
            
            // --- PROBE TOOL ---
            if (ImGui::MenuItem("🔬 Probe Signal (Click any output pin)"))
            {
                isProbeModeActive = true;
                ImGui::CloseCurrentPopup();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Activate probe mode to instantly visualize any signal without manual patching.\nClick on any output pin to route it to the probe scope.");
            }
            ImGui::Separator();

            auto addAtMouse = [this](const char* type) {
                auto nodeId = synth->addModule(type);
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                // This places the new node exactly where the user right-clicked
                pendingNodeScreenPositions[logicalId] = ImGui::GetMousePosOnOpeningCurrentPopup();
                
                // Special handling for recorder module
                if (juce::String(type).equalsIgnoreCase("recorder"))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical((juce::uint32)logicalId)))
                    {
                        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
                    }
                }
                
                // Give comment nodes a default size to prevent feedback loop
                if (juce::String(type).equalsIgnoreCase("comment"))
                {
                    pendingNodeSizes[logicalId] = ImVec2(250.f, 150.f);
                }
                
                snapshotAfterEditor = true;
                ImGui::CloseCurrentPopup();
            };
            
            juce::String filter(searchQuery);

            ImGui::BeginChild("ModuleList", ImVec2(280, 350), true);

            if (filter.isEmpty())
            {
                // --- BROWSE MODE (No text in search bar) ---
                if (ImGui::BeginMenu("Sources")) {
                    if (ImGui::MenuItem("Audio Input")) addAtMouse("audio_input");
                    if (ImGui::MenuItem("VCO")) addAtMouse("vco");
                    if (ImGui::MenuItem("Polyphonic VCO")) addAtMouse("polyvco");
                    if (ImGui::MenuItem("Noise")) addAtMouse("noise");
                    if (ImGui::MenuItem("Sequencer")) addAtMouse("sequencer");
                    if (ImGui::MenuItem("Multi Sequencer")) addAtMouse("multi_sequencer");
                    if (ImGui::MenuItem("Snapshot Sequencer")) addAtMouse("snapshot_sequencer");
                    if (ImGui::MenuItem("Stroke Sequencer")) addAtMouse("stroke_sequencer");
                    if (ImGui::MenuItem("Value")) addAtMouse("value");
                    if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample_loader");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("MIDI Family")) {
                    if (ImGui::MenuItem("MIDI CV")) addAtMouse("midi_cv");
                    if (ImGui::MenuItem("MIDI Player")) addAtMouse("midi_player");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Faders")) addAtMouse("midi_faders");
                    if (ImGui::MenuItem("MIDI Knobs")) addAtMouse("midi_knobs");
                    if (ImGui::MenuItem("MIDI Buttons")) addAtMouse("midi_buttons");
                    if (ImGui::MenuItem("MIDI Jog Wheel")) addAtMouse("midi_jog_wheel");
                    if (ImGui::MenuItem("MIDI Pads")) addAtMouse("midi_pads");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Logger")) addAtMouse("midi_logger");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("TTS")) {
                    if (ImGui::MenuItem("TTS Performer")) addAtMouse("tts_performer");
                    if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("vocal_tract_filter");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Physics Family")) {
                    if (ImGui::MenuItem("Physics")) addAtMouse("physics");
                    if (ImGui::MenuItem("Animation")) addAtMouse("animation");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Effects")) {
                    if (ImGui::MenuItem("VCF")) addAtMouse("vcf");
                    if (ImGui::MenuItem("Delay")) addAtMouse("delay");
                    if (ImGui::MenuItem("Reverb")) addAtMouse("reverb");
                    if (ImGui::MenuItem("Chorus")) addAtMouse("chorus");
                    if (ImGui::MenuItem("Phaser")) addAtMouse("phaser");
                    if (ImGui::MenuItem("Compressor")) addAtMouse("compressor");
                    if (ImGui::MenuItem("Recorder")) addAtMouse("recorder");
                    if (ImGui::MenuItem("Limiter")) addAtMouse("limiter");
                    if (ImGui::MenuItem("Noise Gate")) addAtMouse("gate");
                    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
                    if (ImGui::MenuItem("Graphic EQ")) addAtMouse("graphic_eq");
                    if (ImGui::MenuItem("Waveshaper")) addAtMouse("waveshaper");
                    if (ImGui::MenuItem("8-Band Shaper")) addAtMouse("8bandshaper");
                    if (ImGui::MenuItem("Granulator")) addAtMouse("granulator");
                    if (ImGui::MenuItem("Harmonic Shaper")) addAtMouse("harmonic_shaper");
                    if (ImGui::MenuItem("Time/Pitch Shifter")) addAtMouse("timepitch");
                    if (ImGui::MenuItem("De-Crackle")) addAtMouse("de_crackle");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Modulators")) {
                    if (ImGui::MenuItem("LFO")) addAtMouse("lfo");
                    if (ImGui::MenuItem("ADSR")) addAtMouse("adsr");
                    if (ImGui::MenuItem("Random")) addAtMouse("random");
                    if (ImGui::MenuItem("S&H")) addAtMouse("s_and_h");
                    if (ImGui::MenuItem("Tempo Clock")) addAtMouse("tempo_clock");
                    if (ImGui::MenuItem("Function Generator")) addAtMouse("function_generator");
                    if (ImGui::MenuItem("Shaping Oscillator")) addAtMouse("shaping_oscillator");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Utilities & Logic")) {
                    if (ImGui::MenuItem("VCA")) addAtMouse("vca");
                    if (ImGui::MenuItem("Mixer")) addAtMouse("mixer");
                    if (ImGui::MenuItem("CV Mixer")) addAtMouse("cv_mixer");
                    if (ImGui::MenuItem("Track Mixer")) addAtMouse("track_mixer");
                    if (ImGui::MenuItem("Attenuverter")) addAtMouse("attenuverter");
                    if (ImGui::MenuItem("Lag Processor")) addAtMouse("lag_processor");
                    if (ImGui::MenuItem("Math")) addAtMouse("math");
                    if (ImGui::MenuItem("Map Range")) addAtMouse("map_range");
                    if (ImGui::MenuItem("Quantizer")) addAtMouse("quantizer");
                    if (ImGui::MenuItem("Rate")) addAtMouse("rate");
                    if (ImGui::MenuItem("Comparator")) addAtMouse("comparator");
                    if (ImGui::MenuItem("Logic")) addAtMouse("logic");
                    if (ImGui::MenuItem("Clock Divider")) addAtMouse("clock_divider");
                    if (ImGui::MenuItem("Sequential Switch")) addAtMouse("sequential_switch");
                    if (ImGui::MenuItem("Comment")) addAtMouse("comment");
                    if (ImGui::MenuItem("Best Practice")) addAtMouse("best_practice");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Analysis")) {
                    if (ImGui::MenuItem("Scope")) addAtMouse("scope");
                    if (ImGui::MenuItem("Debug")) addAtMouse("debug");
                    if (ImGui::MenuItem("Input Debug")) addAtMouse("input_debug");
                    if (ImGui::MenuItem("Frequency Graph")) addAtMouse("frequency_graph");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("VST Plugins")) {
                    addPluginModules(); // Re-use your existing plugin menu logic
                    ImGui::EndMenu();
                }
            }
            else
            {
                // --- SEARCH MODE (Text has been entered) ---
                // Use the new registry to get display names and internal types
                for (const auto& entry : getModuleRegistry())
                {
                    const juce::String& displayName = entry.first;
                    const char* internalType = entry.second.first;
                    const char* description = entry.second.second;

                    // Search against the display name, not the internal type
                    if (displayName.containsIgnoreCase(filter))
                    {
                        if (ImGui::Selectable(displayName.toRawUTF8()))
                        {
                            // Use the correct internal type name!
                            addAtMouse(internalType);
                        }
                        if (ImGui::IsItemHovered())
                        {
                            ImGui::BeginTooltip();
                            ImGui::TextUnformatted(description);
                            ImGui::EndTooltip();
                        }
                    }
                }
            }

            ImGui::EndChild();
            ImGui::EndPopup();
        }

        // Helper functions are now class methods

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinId(startAttr);
            auto endPin = decodePinId(endAttr);
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // Ensure connection is always Output -> Input
            if (!srcPin.isInput && dstPin.isInput)
            {
                PinDataType srcType = getPinDataTypeForPin(srcPin);
                PinDataType dstType = getPinDataTypeForPin(dstPin);

                bool conversionHandled = false;

                // Determine if a converter is needed based on pin types
                if (srcType == PinDataType::Audio && dstType == PinDataType::CV)
                {
                    insertNodeBetween("Attenuverter", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::CV && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("Comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Audio && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("Comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Raw && dstType != PinDataType::Raw)
                {
                    insertNodeBetween("MapRange", srcPin, dstPin);
                    conversionHandled = true;
                }

                if (conversionHandled)
                {
                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
                else
                {
                    // All other combinations are considered directly compatible.
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    // Immediate commit for RecordModuleProcessor filename update
                    synth->commitChanges();

                    if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId)) {
                        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule)) {
                            juce::String sourceName;
                            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId)) {
                                sourceName = srcModule->getName();
                            }
                            recorder->updateSuggestedFilename(sourceName);
                        }
                    }

                    pushSnapshot();
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                // Debug log disconnect intent
                juce::Logger::writeToLog(
                    juce::String("[LinkDelete] src(lid=") + juce::String((int)srcPin.logicalId) + ",ch=" + juce::String(srcPin.channel) +
                    ") -> dst(lid=" + juce::String((int)dstPin.logicalId) + ",ch=" + juce::String(dstPin.channel) + ")");

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                
                // Immediate commit for RecordModuleProcessor filename update
                synth->commitChanges();
                
                // After disconnecting, tell the recorder to update (pass empty string for unconnected)
                if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule))
                    {
                        recorder->updateSuggestedFilename(""); // Empty = unconnected
                    }
                }
                
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)

        // Keyboard shortcuts
        // Only process global keyboard shortcuts if no ImGui widget wants the keyboard
        if (!ImGui::GetIO().WantCaptureKeyboard)
        {
            const bool ctrl = ImGui::GetIO().KeyCtrl;
            const bool shift = ImGui::GetIO().KeyShift;
            const bool alt = ImGui::GetIO().KeyAlt;
            
            if (ctrl && ImGui::IsKeyPressed (ImGuiKey_S)) { startSaveDialog(); }
            if (ctrl && ImGui::IsKeyPressed (ImGuiKey_O)) { startLoadDialog(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_P)) { handleRandomizePatch(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_M)) { handleRandomizeConnections(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_B)) { handleBeautifyLayout(); }
            if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_R, false)) { handleRecordOutput(); }
        
        // M: Mute/Bypass selected nodes (without Ctrl modifier)
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_M, false) && ImNodes::NumSelectedNodes() > 0)
        {
            handleMuteToggle();
        }
        
        // Ctrl + A: Select All
        if (ctrl && !shift && ImGui::IsKeyPressed(ImGuiKey_A, false))
        {
            if (synth != nullptr)
            {
                const auto& modules = synth->getModulesInfo();
                std::vector<int> allNodeIds;
                allNodeIds.push_back(0); // Include output node
                for (const auto& mod : modules)
                {
                    allNodeIds.push_back((int)mod.first);
                }
                ImNodes::ClearNodeSelection();
                for (int id : allNodeIds)
                {
                    ImNodes::SelectNode(id);
                }
            }
        }
        
        // Ctrl + R: Reset selected node(s) to default parameters
        if (ctrl && ImGui::IsKeyPressed(ImGuiKey_R, false))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0 && synth != nullptr)
            {
                // Create a single undo state for the entire operation
                pushSnapshot();
                
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());

                for (int lid : selectedNodeIds)
                {
                    if (auto* module = synth->getModuleForLogical((juce::uint32)lid))
                    {
                        // Get all parameters for this module
                        auto& params = module->getParameters();
                        for (auto* paramBase : params)
                        {
                            // Cast to a ranged parameter to access default values
                            if (auto* param = dynamic_cast<juce::RangedAudioParameter*>(paramBase))
                            {
                                // Get the default value (normalized 0-1) and apply it
                                param->setValueNotifyingHost(param->getDefaultValue());
                            }
                        }
                        juce::Logger::writeToLog("[Reset] Reset parameters for node " + juce::String(lid));
                    }
                }
            }
        }
        
        // O: Connect selected to Output
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_O, false) && ImNodes::NumSelectedNodes() == 1)
        {
            if (synth != nullptr)
            {
                int selectedId;
                ImNodes::GetSelectedNodes(&selectedId);
                if (selectedId != 0)
                {
                    synth->connect(synth->getNodeIdForLogical(selectedId), 0, synth->getOutputNodeID(), 0);
                    synth->connect(synth->getNodeIdForLogical(selectedId), 1, synth->getOutputNodeID(), 1);
                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
            }
        }
        
        // Alt + D: Disconnect selected nodes
        if (alt && ImGui::IsKeyPressed(ImGuiKey_D, false) && ImNodes::NumSelectedNodes() > 0)
        {
            if (synth != nullptr)
            {
                std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                for (int id : selectedNodeIds)
                {
                    synth->clearConnectionsForNode(synth->getNodeIdForLogical(id));
                }
                graphNeedsRebuild = true;
                pushSnapshot();
            }
        }
        
        // --- REVISED 'F' and 'Home' KEY LOGIC ---
        auto frameNodes = [&](const std::vector<int>& nodeIds) {
            if (nodeIds.empty() || synth == nullptr) return;

            juce::Rectangle<float> bounds;
            bool foundAny = false;
            
            // Build a set of valid node IDs for checking
            std::unordered_set<int> validNodes;
            validNodes.insert(0); // Output node
            for (const auto& mod : synth->getModulesInfo())
                validNodes.insert((int)mod.first);
            
            for (size_t i = 0; i < nodeIds.size(); ++i)
            {
                // Ensure the node exists before getting its position
                if (validNodes.find(nodeIds[i]) != validNodes.end())
                {
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeIds[i]);
                    if (!foundAny)
                    {
                        bounds = juce::Rectangle<float>(pos.x, pos.y, 1, 1);
                        foundAny = true;
                    }
                    else
                    {
                        bounds = bounds.getUnion(juce::Rectangle<float>(pos.x, pos.y, 1, 1));
                    }
                }
            }

            if (!foundAny) return;

            // Add some padding to the bounds
            if (!nodeIds.empty() && validNodes.find(nodeIds[0]) != validNodes.end())
                bounds = bounds.expanded(ImNodes::GetNodeDimensions(nodeIds[0]).x, ImNodes::GetNodeDimensions(nodeIds[0]).y);
            
            ImVec2 center((bounds.getX() + bounds.getRight()) * 0.5f, (bounds.getY() + bounds.getBottom()) * 0.5f);
            ImNodes::EditorContextResetPanning(center);
        };

        // F: Frame Selected
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_F, false))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                frameNodes(selectedNodeIds);
            }
        }

        // Home and Ctrl+Home: Frame All / Reset to Origin
        if (ImGui::IsKeyPressed(ImGuiKey_Home, false))
        {
            if (ctrl) // Ctrl+Home: Reset to origin
            {
                ImNodes::EditorContextResetPanning(ImVec2(0, 0));
            }
            else // Home: Frame all
            {
                if (synth != nullptr)
                {
                    auto modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0); // Include output node
                    for (const auto& mod : modules)
                    {
                        allNodeIds.push_back((int)mod.first);
                    }
                    frameNodes(allNodeIds);
                }
            }
        }
        
        // Debug menu (Ctrl+Shift+D)
        if (ctrl && shift && ImGui::IsKeyPressed(ImGuiKey_D)) { showDebugMenu = !showDebugMenu; }

        // Undo / Redo (Ctrl+Z / Ctrl+Y)
    if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Z))
        {
            if (undoStack.size() > 1)
            {
                Snapshot current = undoStack.back();
                redoStack.push_back (current);
                undoStack.pop_back();
                restoreSnapshot (undoStack.back());
                // After a restore, clear transient link maps only; keep pending positions so they apply next frame
                linkIdToAttrs.clear();
                // modLinkIdToRoute.clear(); // TODO: Remove when fully migrated
            }
        }
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Y))
        {
            if (! redoStack.empty())
            {
                Snapshot s = redoStack.back(); redoStack.pop_back();
                restoreSnapshot (s);
                undoStack.push_back (s);
                linkIdToAttrs.clear();
                // modLinkIdToRoute.clear(); // TODO: Remove when fully migrated
            }
        }

        // Duplicate selected nodes (Ctrl+D) and Duplicate with connections (Shift+D)
        if ((ctrl || ImGui::GetIO().KeyShift) && ImGui::IsKeyPressed (ImGuiKey_D))
        {
            const int n = ImNodes::NumSelectedNodes();
            if (n > 0)
            {
                std::vector<int> sel((size_t) n);
                ImNodes::GetSelectedNodes(sel.data());
                for (int oldId : sel)
                {
                    if (oldId == 0) continue;
                    const juce::String type = getTypeForLogical ((juce::uint32) oldId);
                    if (type.isEmpty()) continue;
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    const juce::uint32 newLogical = synth->getLogicalIdForNode (newNodeId);
                    if (newLogical != 0)
                    {
                        if (auto* src = synth->getModuleForLogical ((juce::uint32) oldId))
                            if (auto* dst = synth->getModuleForLogical (newLogical))
                                dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                        // Position offset
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos (oldId);
                        pendingNodePositions[(int) newLogical] = ImVec2 (pos.x + 40.0f, pos.y + 40.0f);

                        // If Shift is held: duplicate connections into and out of this node
                        if (!ctrl && ImGui::GetIO().KeyShift)
                        {
                            const auto oldNode = synth->getNodeIdForLogical ((juce::uint32) oldId);
                            const auto newNode = newNodeId;
                            // Duplicate audio/CV connections
                            for (const auto& c : synth->getConnectionsInfo())
                            {
                                // Outgoing from old -> someone
                                if ((int) c.srcLogicalId == oldId)
                                {
                                    auto dstNode = (c.dstLogicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical (c.dstLogicalId);
                                    synth->connect (newNode, c.srcChan, dstNode, c.dstChan);
                                }
                                // Incoming from someone -> old
                                if ((int) c.dstLogicalId == oldId)
                                {
                                    auto srcNode = synth->getNodeIdForLogical (c.srcLogicalId);
                                    synth->connect (srcNode, c.srcChan, newNode, c.dstChan);
                                }
                            }
                            // TODO: Implement modulation route duplication for new bus-based system
                        }
                    }
                }
                pushSnapshot();
            }
        }
        
        } // End of keyboard shortcuts (WantCaptureKeyboard check)

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }

    // === MIDI DEVICE MANAGER WINDOW ===
    if (showMidiDeviceManager)
    {
        if (ImGui::Begin("MIDI Device Manager", &showMidiDeviceManager, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::TextColored(ImVec4(0.6f, 0.8f, 1.0f, 1.0f), "MIDI Input Devices");
            ImGui::Separator();
            
            // Access MidiDeviceManager from PresetCreatorComponent
            auto* presetCreator = dynamic_cast<PresetCreatorComponent*>(getParentComponent());
            if (presetCreator && presetCreator->midiDeviceManager)
            {
                auto& midiMgr = *presetCreator->midiDeviceManager;
                const auto& devices = midiMgr.getDevices();
                
                if (devices.empty())
                {
                    ImGui::TextDisabled("No MIDI devices found");
                }
                else
                {
                    ImGui::Text("Found %d device(s):", (int)devices.size());
                    ImGui::Spacing();
                    
                    // Display each device
                    for (const auto& device : devices)
                    {
                        ImGui::PushID(device.identifier.toRawUTF8());
                        
                        // Checkbox to enable/disable device
                        bool enabled = device.enabled;
                        if (ImGui::Checkbox("##enabled", &enabled))
                        {
                            if (enabled)
                                midiMgr.enableDevice(device.identifier);
                            else
                                midiMgr.disableDevice(device.identifier);
                        }
                        
                        ImGui::SameLine();
                        
                        // Device name
                        ImGui::Text("%s", device.name.toRawUTF8());
                        
                        // Activity indicator
                        auto activity = midiMgr.getDeviceActivity(device.identifier);
                        if (activity.lastMessageTime > 0)
                        {
                            ImGui::SameLine();
                            float timeSinceMessage = (juce::Time::getMillisecondCounter() - activity.lastMessageTime) / 1000.0f;
                            if (timeSinceMessage < 1.0f)
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255));
                                ImGui::Text("ACTIVE");
                                ImGui::PopStyleColor();
                            }
                            else
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                                ImGui::Text("idle");
                                ImGui::PopStyleColor();
                            }
                        }
                        
                        ImGui::PopID();
                    }
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                // Rescan button
                if (ImGui::Button("Rescan Devices"))
                {
                    midiMgr.scanDevices();
                }
                
                ImGui::SameLine();
                
                // Enable/Disable all buttons
                if (ImGui::Button("Enable All"))
                {
                    midiMgr.enableAllDevices();
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Disable All"))
                {
                    midiMgr.disableAllDevices();
                }
            }
            else
            {
                ImGui::TextDisabled("MIDI Manager not available");
            }
        }
        ImGui::End();
    }

    // === DEBUG WINDOW ===
    if (showDebugMenu)
    {
        if (ImGui::Begin("System Diagnostics", &showDebugMenu))
        {
            if (synth != nullptr)
            {
                ImGui::Text("=== SYSTEM OVERVIEW ===");
                if (ImGui::Button("Refresh"))
                {
                    // Force refresh of diagnostics
                }
                
                
                // System diagnostics
                ImGui::Text("System State:");
                juce::String systemDiag = synth->getSystemDiagnostics();
                ImGui::TextWrapped("%s", systemDiag.toUTF8());
                
                
                // Module selector
                ImGui::Text("Module Diagnostics:");
                auto modules = synth->getModulesInfo();
                if (!modules.empty())
                {
                    static int selectedModuleIndex = 0;
                    if (selectedModuleIndex >= (int)modules.size()) selectedModuleIndex = 0;
                    
                    juce::String moduleList = "";
                    for (size_t i = 0; i < modules.size(); ++i)
                    {
                        if (i > 0) moduleList += "\0";
                        moduleList += "Logical " + juce::String((int)modules[i].first) + ": " + modules[i].second;
                    }
                    moduleList += "\0";
                    
                    if (ImGui::Combo("Select Module", &selectedModuleIndex, moduleList.toUTF8()))
                    {
                        if (selectedModuleIndex < (int)modules.size())
                        {
                            juce::String moduleDiag = synth->getModuleDiagnostics(modules[selectedModuleIndex].first);
                            ImGui::TextWrapped("%s", moduleDiag.toUTF8());
                        }
                    }
                }
                else
                {
                    ImGui::Text("No modules found.");
                }
            }
            else
            {
                ImGui::Text("No synth processor available.");
            }
        }
        ImGui::End();
    }

    // Keyboard Shortcuts Help Window (F1)
    if (showShortcutsWindow)
    {
        ImGui::Begin("Keyboard Shortcuts", &showShortcutsWindow, ImGuiWindowFlags_AlwaysAutoResize);
        
        // --- NEW, COMPREHENSIVE SHORTCUT LIST ---

        ImGui::Text("Patch & File Management");
        ImGui::Separator();
        ImGui::BulletText("Ctrl + S: Save Preset.");
        ImGui::BulletText("Ctrl + O: Load Preset.");
        ImGui::BulletText("Ctrl + Z: Undo last action.");
        ImGui::BulletText("Ctrl + Y: Redo last action.");
        ImGui::BulletText("Ctrl + P: Generate a new random patch.");

        ImGui::Spacing();
        ImGui::Text("Node Creation & Deletion");
        ImGui::Separator();
        ImGui::BulletText("Right-click canvas: Open Quick Add menu to create a node.");
        ImGui::BulletText("Delete: Delete selected nodes and links.");
        ImGui::BulletText("Shift + Delete: Bypass-delete selected node(s), preserving signal chain.");
        ImGui::BulletText("Ctrl + D: Duplicate selected node(s).");
        ImGui::BulletText("Shift + D: Duplicate selected node(s) with their connections.");
        ImGui::BulletText("Ctrl + Shift + M: Collapse selected nodes into a new 'Meta Module'.");

        ImGui::Spacing();
        ImGui::Text("Connections & Signal Flow");
        ImGui::Separator();
        ImGui::BulletText("Right-click canvas -> Probe Signal: Enter Probe Mode.");
        ImGui::BulletText("  (In Probe Mode) Left-click output pin: Instantly view signal in the Probe Scope.");
        ImGui::BulletText("Right-click link: Open menu to insert a node on that cable.");
        ImGui::BulletText("I key (while hovering link): Open 'Insert Node' menu for that cable.");
        ImGui::BulletText("Ctrl + Middle-click link: Split a new cable from a connected output pin.");
        ImGui::BulletText("O key (with one node selected): Connect node's output to the Main Output.");
        ImGui::BulletText("Alt + D: Disconnect all cables from selected node(s).");
        ImGui::BulletText("Ctrl + M: Randomize connections between existing nodes.");
        ImGui::BulletText("C key (multi-select): Chain selected nodes (L->L, R->R).");
        ImGui::BulletText("G, B, Y, R keys (multi-select): Chain pins by type (Audio, CV, Gate, Raw).");
        
        ImGui::Spacing();
        ImGui::Text("Navigation & View");
        ImGui::Separator();
        ImGui::BulletText("F: Frame (zoom to fit) selected nodes.");
        ImGui::BulletText("Home: Frame all nodes in the patch.");
        ImGui::BulletText("Ctrl + Home: Reset view panning to the origin (0,0).");
        ImGui::BulletText("Ctrl + B: Automatically arrange nodes for a clean layout ('Beautify').");
        ImGui::BulletText("Ctrl + A: Select all nodes.");

        ImGui::Spacing();
        ImGui::Text("Parameter & Settings");
        ImGui::Separator();
        ImGui::BulletText("M key (with node(s) selected): Mute or Bypass the selected node(s).");
        ImGui::BulletText("Ctrl + R (with node(s) selected): Reset parameters of selected node(s) to default.");
        ImGui::BulletText("Ctrl + Shift + C: Copy selected node's settings to clipboard.");
        ImGui::BulletText("Ctrl + Shift + V: Paste settings to selected node (must be same type).");
        ImGui::BulletText("Mouse Wheel (on slider): Fine-tune parameter value.");

        ImGui::Spacing();
        ImGui::Text("General & Debugging");
        ImGui::Separator();
        ImGui::BulletText("Ctrl + R (no node selected): Insert a Recorder tapped into the Main Output.");
        ImGui::BulletText("Ctrl + Shift + D: Show System Diagnostics window.");
        ImGui::BulletText("F1: Toggle this help window.");
        
        ImGui::End();
    }

    ImGui::End();
    // drawPendingModPopup(); // TODO: Remove when fully migrated

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        // Temporarily mask rebuild flag to avoid ImNodes queries during capture
        const bool rebuilding = graphNeedsRebuild.load();
        if (rebuilding) {
            // getUiValueTree will still avoid ImNodes now, but assert safety
        }
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        // Do not commit pending positions of (0,0) which are placeholders
        for (int i = 0; i < applied.getNumChildren(); ++i)
        {
            auto n = applied.getChild(i);
            if (! n.hasType("node")) continue;
            const float x = (float) n.getProperty("x", 0.0f);
            const float y = (float) n.getProperty("y", 0.0f);
            if (x == 0.0f && y == 0.0f) {
                // Try to recover from last-known or pending
                const int nid = (int) n.getProperty("id", -1);
                auto itL = lastKnownNodePositions.find(nid);
                if (itL != lastKnownNodePositions.end()) { n.setProperty("x", itL->second.x, nullptr); n.setProperty("y", itL->second.y, nullptr); }
                else if (auto itP = pendingNodePositions.find(nid); itP != pendingNodePositions.end()) { n.setProperty("x", itP->second.x, nullptr); n.setProperty("y", itP->second.y, nullptr); }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        isPatchDirty = true; // Mark patch as dirty
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
    
    // Mark patch as dirty whenever a change is made
    isPatchDirty = true;
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed


juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree()
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        
        // Prefer cached position if available; never query ImNodes while rebuilding
        ImVec2 pos;
        if (lastKnownNodePositions.count(nid) > 0)
        {
            pos = lastKnownNodePositions[nid];
        }
        else if (graphNeedsRebuild.load())
        {
            // Fallback to any pending position queued for this node
            auto it = pendingNodePositions.find(nid);
            pos = (it != pendingNodePositions.end()) ? it->second : ImVec2(0.0f, 0.0f);
        }
        else
        {
            pos = ImNodes::GetNodeGridSpacePos(nid);
        }
        
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        
        // --- FIX: Save muted/bypassed state ---
        // If this node's ID is in our map of muted nodes, add the property to the XML
        if (mutedNodeStates.count(nid) > 0)
        {
            n.setProperty("muted", true, nullptr);
        }
        
        ui.addChild (n, -1, nullptr);
    }
    
    // --- FIX: Explicitly save the output node position (ID 0) ---
    // The main output node is not part of getModulesInfo(), so we need to save it separately
    
    // Prefer cached output position; avoid ImNodes when rebuilding
    ImVec2 outputPos;
    if (lastKnownNodePositions.count(0) > 0)
        outputPos = lastKnownNodePositions[0];
    else if (graphNeedsRebuild.load())
    {
        auto it0 = pendingNodePositions.find(0);
        outputPos = (it0 != pendingNodePositions.end()) ? it0->second : ImVec2(0.0f, 0.0f);
    }
    else
        outputPos = ImNodes::GetNodeGridSpacePos(0);
    
    juce::ValueTree outputNode("node");
    outputNode.setProperty("id", 0, nullptr);
    outputNode.setProperty("x", outputPos.x, nullptr);
    outputNode.setProperty("y", outputPos.y, nullptr);
    ui.addChild(outputNode, -1, nullptr);
    // --- END OF FIX ---
    
    return ui;
}

void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid() || synth == nullptr) return;
    
    juce::Logger::writeToLog("[UI_RESTORE] Applying UI ValueTree now...");

    // This is the core of the crash: the synth graph has already been rebuilt by setStateInformation.
    // We must clear our stale UI data (like muted nodes) before applying the new state from the preset.
    mutedNodeStates.clear();
    
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);

        // ========================= THE FIX STARTS HERE =========================
        //
        // Before applying any property, VERIFY that this node ID actually exists
        // in the synth. This prevents crashes when loading presets that contain
        // modules which are not available in the current build.
        //
        bool nodeExistsInSynth = (nid == 0); // Node 0 is always the output node.
        if (!nodeExistsInSynth) {
            for (const auto& modInfo : synth->getModulesInfo()) {
                if ((int)modInfo.first == nid) {
                    nodeExistsInSynth = true;
                    break;
                }
            }
        }

        if (!nodeExistsInSynth)
        {
            juce::Logger::writeToLog("[UI_RESTORE] WARNING: Skipping UI properties for non-existent node ID " + juce::String(nid) + ". The module may be missing or failed to load.");
            continue; // Skip to the next node in the preset.
        }
        // ========================== END OF FIX ==========================

        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        if (!(x == 0.0f && y == 0.0f))
        {
            pendingNodePositions[nid] = ImVec2(x, y);
            juce::Logger::writeToLog("[UI_RESTORE] Queued position for node " + juce::String(nid) + ": (" + juce::String(x) + ", " + juce::String(y) + ")");
        }
        
        // Read and apply muted state from preset for existing nodes.
        if ((bool) n.getProperty("muted", false))
        {
            // Use muteNodeSilent to store the original connections first,
            // then apply the mute (which creates bypass connections)
            muteNodeSilent(nid);
            muteNode(nid);
        }
    }
    
    // Muting/unmuting modifies graph connections, so we must tell the
    // synth to rebuild its processing order.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[UI_RESTORE] UI state applied. Flagging for graph rebuild.");
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    // Shift+Delete => bypass delete (keep chain intact)
    if ((ImGui::GetIO().KeyShift) && ImGui::IsKeyPressed(ImGuiKey_Delete))
    {
        bypassDeleteSelectedNodes();
        return;
    }

    // Use new key query API (1.90+) for normal delete
    if (! ImGui::IsKeyPressed(ImGuiKey_Delete))
        return;

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            // TODO: Handle modulation link deletion for new bus-based system
            // if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
            // {
            //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
            //     // TODO: Handle modulation route removal
            //     // if (paramId.isNotEmpty())
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL, paramId);
            //     // else
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            // }
            // else 
            if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            mutedNodeStates.erase((juce::uint32)nid); // Clean up muted state if exists
            lastKnownNodePositions.erase(nid); // Clean up position cache
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
}

void ImGuiNodeEditorComponent::bypassDeleteSelectedNodes()
{
    const int numSelNodes = ImNodes::NumSelectedNodes();
    if (numSelNodes <= 0 || synth == nullptr) return;

    // Snapshot positions first if dragging
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    std::vector<int> nodeIds((size_t) numSelNodes);
    ImNodes::GetSelectedNodes(nodeIds.data());

    for (int nid : nodeIds)
    {
        if (nid == 0) continue; // don't bypass-delete the output sink
        bypassDeleteNode((juce::uint32) nid);
    }
    graphNeedsRebuild = true;
    pushSnapshot();
}

void ImGuiNodeEditorComponent::bypassDeleteNode(juce::uint32 logicalId)
{
    // Collect all incoming/outgoing audio links for this node
    std::vector<decltype(synth->getConnectionsInfo())::value_type> inputs, outputs;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) inputs.push_back(c);
        if (c.srcLogicalId == logicalId) outputs.push_back(c);
    }

    // For each output channel, find matching input channel to splice
    for (const auto& out : outputs)
    {
        // Try to find input with same channel index, else fallback to first input
        const auto* inPtr = (const decltype(inputs)::value_type*) nullptr;
        for (const auto& in : inputs) { if (in.dstChan == out.srcChan) { inPtr = &in; break; } }
        if (inPtr == nullptr && !inputs.empty()) inPtr = &inputs.front();

        // Disconnect out link first
        auto srcNode = synth->getNodeIdForLogical(out.srcLogicalId);
        auto dstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
        synth->disconnect(srcNode, out.srcChan, dstNode, out.dstChan);

        if (inPtr != nullptr)
        {
            // Disconnect incoming link from the node
            auto inSrcNode = synth->getNodeIdForLogical(inPtr->srcLogicalId);
            auto inDstNode = synth->getNodeIdForLogical(inPtr->dstLogicalId);
            synth->disconnect(inSrcNode, inPtr->srcChan, inDstNode, inPtr->dstChan);

            // Connect source of incoming directly to destination of outgoing
            auto finalDstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
            synth->connect(inSrcNode, inPtr->srcChan, finalDstNode, out.dstChan);
        }
    }

    // TODO: Remove modulation routes targeting or originating this node using new bus-based system

    // Finally remove the node itself
    mutedNodeStates.erase(logicalId); // Clean up muted state if exists
    synth->removeModule(synth->getNodeIdForLogical(logicalId));
}

// === Non-Destructive Mute/Bypass Implementation ===

void ImGuiNodeEditorComponent::muteNodeSilent(juce::uint32 logicalId)
{
    // This function is used when loading presets. It records the connections that were
    // loaded from the XML without modifying the graph or creating bypass connections.
    // This preserves the original "unmuted" connections for later use.
    
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // Store all connections attached to this node
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // Store the state, but DON'T modify the graph or create bypass connections
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[MuteSilent] Node " + juce::String(logicalId) + 
                            " marked as muted, stored " + juce::String(state.incomingConnections.size()) + 
                            " incoming and " + juce::String(state.outgoingConnections.size()) + 
                            " outgoing connections.");
}

void ImGuiNodeEditorComponent::muteNode(juce::uint32 logicalId)
{
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // 1. Find and store all connections attached to this node.
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // 2. Disconnect all of them.
    for (const auto& c : state.incomingConnections) {
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }
    
    // --- FIX: More robust bypass splicing logic ---
    // 3. Splice the connections to bypass the node.
    // Connect the FIRST input source to ALL output destinations.
    // This correctly handles cases where input channel != output channel (e.g., Mixer input 3 → output 0).
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Connect the primary input's source directly to the original output's destination
            synth->connect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Mute] Splicing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 4. Store the original state.
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " muted and bypassed.");
}

void ImGuiNodeEditorComponent::unmuteNode(juce::uint32 logicalId)
{
    if (!synth || mutedNodeStates.find(logicalId) == mutedNodeStates.end()) return;

    MutedNodeState state = mutedNodeStates[logicalId];

    // --- FIX: Remove bypass connections matching the new mute logic ---
    // 1. Find and remove the bypass connections.
    // The bypass connected the first input source to all output destinations.
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Disconnect the bypass connection
            synth->disconnect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Unmute] Removing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 2. Restore the original connections.
    for (const auto& c : state.incomingConnections) {
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }

    // 3. Remove from muted state.
    mutedNodeStates.erase(logicalId);
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " unmuted.");
}

void ImGuiNodeEditorComponent::handleMuteToggle()
{
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected == 0) return;

    pushSnapshot(); // Create a single undo state for the whole operation.

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    for (int lid : selectedNodeIds) {
        if (mutedNodeStates.count(lid)) {
            unmuteNode(lid);
        } else {
            muteNode(lid);
        }
    }

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::startSaveDialog()
{
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", findPresetsDirectory(), "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (! f.exists() && ! f.getParentDirectory().exists()) return;
        if (synth == nullptr) return;
        
        // --- FIX: Temporarily unmute nodes to save original connections ---
        // Collect all currently muted nodes
        std::vector<juce::uint32> currentlyMutedNodes;
        for (const auto& pair : mutedNodeStates)
        {
            currentlyMutedNodes.push_back(pair.first);
        }
        
        // Temporarily UNMUTE all of them to restore the original connections
        for (juce::uint32 lid : currentlyMutedNodes)
        {
            unmuteNode(lid);
        }
        
        // Force the synth to apply these connection changes immediately
        if (synth)
        {
            synth->commitChanges();
        }
        // At this point, the synth graph is in its "true", unmuted state
        
        // NOW get the state - this will save the correct, original connections
        juce::MemoryBlock mb; synth->getStateInformation (mb);
        auto xml = juce::XmlDocument::parse (mb.toString());
        
        // IMMEDIATELY RE-MUTE the nodes to return the editor to its visible state
        for (juce::uint32 lid : currentlyMutedNodes)
        {
            muteNode(lid);
        }
        
        // Force the synth to apply the re-mute changes immediately
        if (synth)
        {
            synth->commitChanges();
        }
        // The synth graph is now back to its bypassed state for audio processing
        // --- END OF FIX ---
        
        if (! xml) return;
        juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
        presetVT.addChild (getUiValueTree(), -1, nullptr);
        f.replaceWithText (presetVT.createXml()->toString());
        
        // Update preset status tracking
        isPatchDirty = false;
        currentPresetFile = f.getFileName();
    });
}

void ImGuiNodeEditorComponent::startLoadDialog()
{
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", findPresetsDirectory(), "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.existsAsFile())
        {
            loadPresetFromFile(f); // Use the unified loading function
        }
    });
}

void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "VCO", "Noise", "Sequencer", "VCF", "Delay", "Reverb", "Waveshaper",
        "LFO", "ADSR", "Random", "S&H", "Math", "MapRange", "Quantizer", "ClockDivider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    addedModules.push_back({mixerId, "Mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));
    addedModules.push_back({scopeId, "Scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "Mixer") finalMixerId = mod.first;
        if (mod.second == "Scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "Mixer") mixerId = mod.first;
        if (mod.second == "Scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleBeautifyLayout()
{
    if (synth == nullptr) return;

    // Graph is always in consistent state since we rebuild at frame start
    // Create an undo state so the action can be reversed
    pushSnapshot();
    juce::Logger::writeToLog("--- [Beautify Layout] Starting ---");

    // --- STEP 1: Build Graph Representation ---
    // Adjacency list: map<source_lid, vector<destination_lid>>
    std::map<juce::uint32, std::vector<juce::uint32>> adjacencyList;
    std::map<juce::uint32, int> inDegree; // Counts incoming connections for each node
    std::vector<juce::uint32> sourceNodes;

    auto modules = synth->getModulesInfo();
    for (const auto& mod : modules)
    {
        inDegree[mod.first] = 0;
        adjacencyList[mod.first] = {};
    }
    // Include the output node in the graph
    inDegree[0] = 0; // Output node ID is 0
    adjacencyList[0] = {}; // Output node has no outgoing connections

    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput)
        {
            adjacencyList[conn.srcLogicalId].push_back(0); // Connect to output node
            inDegree[0]++;
        }
        else
        {
            adjacencyList[conn.srcLogicalId].push_back(conn.dstLogicalId);
            inDegree[conn.dstLogicalId]++;
        }
    }

    for (const auto& mod : modules)
    {
        if (inDegree[mod.first] == 0)
        {
            sourceNodes.push_back(mod.first);
        }
    }

    juce::Logger::writeToLog("[Beautify] Found " + juce::String(sourceNodes.size()) + " source nodes");

    // --- STEP 2: Assign Nodes to Columns (Topological Sort) ---
    std::map<juce::uint32, int> nodeColumn;
    std::vector<std::vector<juce::uint32>> columns;
    int maxColumn = 0;

    // Initialize source nodes in column 0
    for (juce::uint32 nodeId : sourceNodes)
    {
        nodeColumn[nodeId] = 0;
    }
    columns.push_back(sourceNodes);

    // Process each column and assign children to appropriate columns
    std::queue<juce::uint32> processQueue;
    for (juce::uint32 srcNode : sourceNodes)
        processQueue.push(srcNode);

    while (!processQueue.empty())
    {
        juce::uint32 u = processQueue.front();
        processQueue.pop();

        for (juce::uint32 v : adjacencyList[u])
        {
            // The column for node 'v' is the maximum of its predecessors' columns + 1
            int newColumn = nodeColumn[u] + 1;
            if (nodeColumn.count(v) == 0 || newColumn > nodeColumn[v])
            {
                nodeColumn[v] = newColumn;
                maxColumn = std::max(maxColumn, newColumn);
                processQueue.push(v);
            }
        }
    }

    // Re-populate columns based on assignments
    columns.assign(maxColumn + 1, {});
    for (const auto& pair : nodeColumn)
    {
        columns[pair.second].push_back(pair.first);
    }

    juce::Logger::writeToLog("[Beautify] Arranged nodes into " + juce::String(maxColumn + 1) + " columns");

    // --- STEP 3: Optimize Node Ordering Within Columns ---
    // Sort nodes in each column based on median position of their parents
    for (int c = 1; c <= maxColumn; ++c)
    {
        std::map<juce::uint32, float> medianPositions;
        
        for (juce::uint32 nodeId : columns[c])
        {
            std::vector<float> parentPositions;
            
            // Find all parents in previous columns
            for (const auto& pair : adjacencyList)
            {
                for (juce::uint32 dest : pair.second)
                {
                    if (dest == nodeId)
                    {
                        // Find the vertical index of the parent node
                        int parentColumn = nodeColumn[pair.first];
                        auto& parentColVec = columns[parentColumn];
                        auto it = std::find(parentColVec.begin(), parentColVec.end(), pair.first);
                        if (it != parentColVec.end())
                        {
                            parentPositions.push_back((float)std::distance(parentColVec.begin(), it));
                        }
                    }
                }
            }
            
            if (!parentPositions.empty())
            {
                std::sort(parentPositions.begin(), parentPositions.end());
                medianPositions[nodeId] = parentPositions[parentPositions.size() / 2];
            }
            else
            {
                medianPositions[nodeId] = 0.0f;
            }
        }
        
        // Sort the column based on median positions
        std::sort(columns[c].begin(), columns[c].end(), [&](juce::uint32 a, juce::uint32 b) {
            return medianPositions[a] < medianPositions[b];
        });
    }

    // --- STEP 4: Calculate Final Coordinates ---
    const float COLUMN_WIDTH = 400.0f;
    const float NODE_VERTICAL_PADDING = 50.0f;

    // Find the tallest column to center shorter ones
    float tallestColumnHeight = 0.0f;
    for (const auto& col : columns)
    {
        float height = 0.0f;
        for (juce::uint32 lid : col)
        {
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            height += nodeSize.y + NODE_VERTICAL_PADDING;
        }
        tallestColumnHeight = std::max(tallestColumnHeight, height);
    }

    // --- STEP 5: Apply Positions ---
    for (int c = 0; c <= maxColumn; ++c)
    {
        // Calculate column height for centering
        float columnHeight = 0.0f;
        for (juce::uint32 lid : columns[c])
        {
            columnHeight += ImNodes::GetNodeDimensions((int)lid).y + NODE_VERTICAL_PADDING;
        }
        
        // Start Y position (centered vertically)
        float currentY = (tallestColumnHeight - columnHeight) / 2.0f;

        for (juce::uint32 lid : columns[c])
        {
            float x = c * COLUMN_WIDTH;
            pendingNodePositions[(int)lid] = ImVec2(x, currentY);
            
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            currentY += nodeSize.y + NODE_VERTICAL_PADDING;
        }
    }

    // Position the output node to the right of all other modules
    float finalX = (maxColumn + 1) * COLUMN_WIDTH;
    float outputNodeY = (tallestColumnHeight - ImNodes::GetNodeDimensions(0).y) / 2.0f;
    pendingNodePositions[0] = ImVec2(finalX, outputNodeY);
    juce::Logger::writeToLog("[Beautify] Applied position to Output Node");
    
    juce::Logger::writeToLog("[Beautify] Applied positions to " + juce::String(modules.size()) + " nodes");
    juce::Logger::writeToLog("--- [Beautify Layout] Complete ---");
}

void ImGuiNodeEditorComponent::handleConnectSelectedToTrackMixer()
{
    if (synth == nullptr || ImNodes::NumSelectedNodes() <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: No synth or no nodes selected.");
        return;
    }

    // This is a significant action, so create an undo state first.
    pushSnapshot();
    juce::Logger::writeToLog("--- [Connect to Mixer] Starting routine ---");

    // 1. Get all selected node IDs.
    const int numSelectedNodes = ImNodes::NumSelectedNodes();
    std::vector<int> selectedNodeLids(numSelectedNodes);
    ImNodes::GetSelectedNodes(selectedNodeLids.data());

    // 2. Find the geometric center of the selected nodes to position our new modules.
    float totalX = 0.0f, maxX = 0.0f, totalY = 0.0f;
    for (int lid : selectedNodeLids)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(lid);
        totalX += pos.x;
        totalY += pos.y;
        if (pos.x > maxX) {
            maxX = pos.x;
        }
    }
    ImVec2 centerPos = ImVec2(totalX / numSelectedNodes, totalY / numSelectedNodes);
    
    // 3. Create the Value node and set its value to the number of selected nodes.
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    if (auto* valueProc = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(valueProc->getAPVTS().getParameter("value")))
        {
            *p = (float)numSelectedNodes;
            juce::Logger::writeToLog("[AutoConnect] Created Value node " + juce::String(valueLid) + " and set its value to " + juce::String(numSelectedNodes));
        }
    }
    // Position it slightly to the right of the center of the selection.
    pendingNodePositions[(int)valueLid] = ImVec2(centerPos.x + 400.0f, centerPos.y);

    // 4. Create the Track Mixer node.
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    // Position it to the right of the right-most selected node for a clean signal flow.
    pendingNodePositions[(int)mixerLid] = ImVec2(maxX + 800.0f, centerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 5. Connect the Value node to the Track Mixer's "Num Tracks Mod" input.
    // The Value module's "Raw" output is channel 0 (provides the exact value entered by the user).
    // The Track Mixer's "Num Tracks Mod" is on Bus 1, Channel 0, which is absolute channel 64.
    synth->connect(valueNodeId, 0, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected Value node 'Raw' output to Track Mixer's Num Tracks Mod input.");

    // 6. Connect the primary audio output of each selected node to a unique input on the Track Mixer.
    int mixerInputChannel = 0;
    for (int lid : selectedNodeLids)
    {
        if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;

        auto sourceNodeId = synth->getNodeIdForLogical((juce::uint32)lid);
        
        // We will connect the first audio output (channel 0) of the source to the next available mixer input.
        synth->connect(sourceNodeId, 0, mixerNodeId, mixerInputChannel);
        juce::Logger::writeToLog("[AutoConnect] Connected node " + juce::String(lid) + " (Out 0) to Track Mixer (In " + juce::String(mixerInputChannel + 1) + ")");
        
        mixerInputChannel++;
    }

    // 7. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [Connect to Mixer] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: MIDI Player not ready.");
        return;
    }

    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);

    // --- FIX: Create and position the Track Mixer first ---
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 1200.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // --- FIX: Connect MIDI Player "Num Tracks" output to Track Mixer "Num Tracks Mod" input ---
    // This ensures the Track Mixer automatically adjusts its track count based on the MIDI file content
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected MIDI Player Num Tracks to Track Mixer Num Tracks Mod");

    // 2. Create and connect a Sample Loader for each active MIDI track.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnect] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks.");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= MIDIPlayerModuleProcessor::kMaxTracks) break;

        // A. Create and position the new modules.
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y + (i * 350.0f));

        auto mapRangeNodeId = synth->addModule("map_range");
        auto mapRangeLid = synth->getLogicalIdForNode(mapRangeNodeId);
        pendingNodePositions[(int)mapRangeLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y + (i * 350.0f));
        
        // B. Configure the MapRange module for Pitch CV conversion.
        if (auto* mapRangeProc = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(mapRangeLid)))
        {
            auto& ap = mapRangeProc->getAPVTS();
            // MIDI Player Pitch Out (0..1) -> Sample Loader Pitch Mod (-24..+24 semitones)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = 0.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = 1.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = -24.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = 24.0f;
        }

        // C. Connect the outputs for this track.
        const int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        const int gateChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 1;
        const int trigChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 3;

        // Pitch: MIDI Player -> MapRange -> Sample Loader
        synth->connect(midiPlayerNodeId, pitchChan, mapRangeNodeId, 0); // Pitch Out -> MapRange In
        synth->connect(mapRangeNodeId, 1, samplerNodeId, 0);             // MapRange Raw Out -> SampleLoader Pitch Mod In

        // Gate: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, gateChan, samplerNodeId, 2);    // Gate Out -> SampleLoader Gate Mod In

        // Trigger: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, trigChan, samplerNodeId, 3);    // Trigger Out -> SampleLoader Trigger Mod In

        // --- FIX: Connect the Sample Loader's audio output to the Track Mixer ---
        // The Sample Loader's main audio output is channel 0.
        // The Track Mixer's inputs are mono channels 0, 1, 2...
        synth->connect(samplerNodeId, 0, mixerNodeId, i);
    }

    // --- FIX: Connect the mixer to the main output so you can hear it! ---
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R

    // 3. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnectVCO] Aborted: MIDI Player not ready.");
        return;
    }
    
    juce::Logger::writeToLog("--- [AutoConnectVCO] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear all existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);
    
    // 2. Create and position the PolyVCO and Track Mixer.
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created PolyVCO with logical ID " + juce::String(polyVcoLid));

    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 3. Connect the track count outputs to control both new modules.
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, polyVcoNodeId, 0); // Raw Num Tracks -> PolyVCO Num Voices Mod
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS); // Raw Num Tracks -> Mixer Num Tracks Mod
    juce::Logger::writeToLog("[AutoConnectVCO] Connected MIDI Player raw track counts to PolyVCO and Track Mixer modulation inputs.");
    
    // 4. Loop through active MIDI tracks to connect CV routes and audio.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnectVCO] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks. Patching voices...");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= PolyVCOModuleProcessor::MAX_VOICES) break; // Don't try to connect more voices than the PolyVCO has

        int sourceTrackIndex = activeTrackIndices[i];

        // A. Connect CV modulation routes from MIDI Player to the corresponding PolyVCO voice.
        int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        int velChan   = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 2;
        
        // Connect MIDI CV to the corresponding PolyVCO voice inputs
        synth->connect(midiPlayerNodeId, pitchChan, polyVcoNodeId, 1 + i); // Pitch -> Freq Mod
        synth->connect(midiPlayerNodeId, velChan,   polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Velocity -> Gate Mod

        // B. Connect the PolyVCO voice's audio output to the Track Mixer's input.
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // 5. Connect the Track Mixer to the main audio output.
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R
    
    // 6. Flag the graph for a rebuild.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnectVCO] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer) return;

    pushSnapshot();

    const int numTracks = midiPlayer->getNumTracks();
    if (numTracks == 0) return;

    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);

    // --- THIS IS THE NEW "FIND-BY-TRACING" LOGIC ---

    juce::uint32 polyVcoLid = 0;
    juce::uint32 trackMixerLid = 0;

    // 1. Scan existing connections to find modules to reuse by tracing backwards.
    // First, find a TrackMixer connected to the output.
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("trackmixer"))
        {
            trackMixerLid = conn.srcLogicalId; // Found a TrackMixer to reuse!
            break;
        }
    }
    // If we found a TrackMixer, now find a PolyVCO connected to it.
    if (trackMixerLid != 0)
    {
        for (const auto& conn : synth->getConnectionsInfo())
        {
            if (conn.dstLogicalId == trackMixerLid && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("polyvco"))
            {
                polyVcoLid = conn.srcLogicalId; // Found a PolyVCO to reuse!
                break;
            }
        }
    }

    // 2. Clear all old Pitch/Gate/Velocity connections from the MIDI Player.
    std::vector<ModularSynthProcessor::ConnectionInfo> oldConnections;
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.srcLogicalId == midiPlayerLid && conn.srcChan < 16 * 3)
            oldConnections.push_back(conn);
    }
    for (const auto& conn : oldConnections)
    {
        synth->disconnect(synth->getNodeIdForLogical(conn.srcLogicalId), conn.srcChan,
                          synth->getNodeIdForLogical(conn.dstLogicalId), conn.dstChan);
    }

    // 3. If we didn't find a PolyVCO to reuse after tracing, create a new one.
    if (polyVcoLid == 0)
    {
        auto polyVcoNodeId = synth->addModule("polyvco", false);
        polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
        pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPos.x + 400.0f, midiPos.y);
    }

    // 4. If we didn't find a TrackMixer to reuse after tracing, create a new one.
    if (trackMixerLid == 0)
    {
        auto trackMixerNodeId = synth->addModule("track_mixer", false);
        trackMixerLid = synth->getLogicalIdForNode(trackMixerNodeId);
        pendingNodePositions[(int)trackMixerLid] = ImVec2(midiPos.x + 800.0f, midiPos.y);
    }
    // --- END OF NEW LOGIC ---

    auto polyVcoNodeId = synth->getNodeIdForLogical(polyVcoLid);
    auto trackMixerNodeId = synth->getNodeIdForLogical(trackMixerLid);

    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numTracks;
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(trackMixerLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numTracks;

    int voicesToConnect = std::min({numTracks, PolyVCOModuleProcessor::MAX_VOICES, 64});
    for (int i = 0; i < voicesToConnect; ++i)
    {
        synth->connect(midiPlayerNodeId, i, polyVcoNodeId, 1 + i);
        synth->connect(midiPlayerNodeId, i + 16, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2 + 1);
    }
    
    synth->connect(trackMixerNodeId, 0, synth->getOutputNodeID(), 0);
    synth->connect(trackMixerNodeId, 1, synth->getOutputNodeID(), 1);

    synth->commitChanges();
}

void ImGuiNodeEditorComponent::handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid)
{
    if (!synth || !strokeSeq) return;

    juce::Logger::writeToLog("🥁 BUILD DRUM KIT handler called! Creating modules...");

    // 1. Get Stroke Sequencer position
    auto seqNodeId = synth->getNodeIdForLogical(strokeSeqLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)strokeSeqLid);

    // 2. Create 3 Sample Loaders (for Floor, Mid, Ceiling triggers)
    auto sampler1NodeId = synth->addModule("sample_loader");
    auto sampler2NodeId = synth->addModule("sample_loader");
    auto sampler3NodeId = synth->addModule("sample_loader");
    
    auto sampler1Lid = synth->getLogicalIdForNode(sampler1NodeId);
    auto sampler2Lid = synth->getLogicalIdForNode(sampler2NodeId);
    auto sampler3Lid = synth->getLogicalIdForNode(sampler3NodeId);
    
    // Position samplers in a vertical stack to the right
    pendingNodePositions[(int)sampler1Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    pendingNodePositions[(int)sampler2Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 220.0f);
    pendingNodePositions[(int)sampler3Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 440.0f);

    // 3. Create Track Mixer (will be set to 6 tracks by Value node)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 200.0f);

    // 4. Create Value node set to 6.0 (for 3 stereo tracks = 6 channels)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(seqPos.x + 600.0f, seqPos.y + 550.0f);
    
    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = 6.0f;
    }

    // 5. Connect Stroke Sequencer TRIGGERS to Sample Loader TRIGGER MOD inputs (channel 3)
    synth->connect(seqNodeId, 0, sampler1NodeId, 3); // Floor Trig   -> Sampler 1 Trigger Mod
    synth->connect(seqNodeId, 1, sampler2NodeId, 3); // Mid Trig     -> Sampler 2 Trigger Mod
    synth->connect(seqNodeId, 2, sampler3NodeId, 3); // Ceiling Trig -> Sampler 3 Trigger Mod

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    // Sampler 1 (L+R) -> Mixer Audio 1+2
    synth->connect(sampler1NodeId, 0, mixerNodeId, 0); // Sampler 1 L -> Mixer Audio 1
    synth->connect(sampler1NodeId, 1, mixerNodeId, 1); // Sampler 1 R -> Mixer Audio 2
    
    // Sampler 2 (L+R) -> Mixer Audio 3+4
    synth->connect(sampler2NodeId, 0, mixerNodeId, 2); // Sampler 2 L -> Mixer Audio 3
    synth->connect(sampler2NodeId, 1, mixerNodeId, 3); // Sampler 2 R -> Mixer Audio 4
    
    // Sampler 3 (L+R) -> Mixer Audio 5+6
    synth->connect(sampler3NodeId, 0, mixerNodeId, 4); // Sampler 3 L -> Mixer Audio 5
    synth->connect(sampler3NodeId, 1, mixerNodeId, 5); // Sampler 3 R -> Mixer Audio 6

    // 7. Connect Value node (6.0) to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value (6) -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid)
{
    if (!synth || !animModule) return;

    // Query the dynamic output pins to determine how many bones are tracked
    auto dynamicPins = animModule->getDynamicOutputPins();
    
    // Each bone has 3 outputs: Vel X, Vel Y, Hit
    // So number of bones = number of pins / 3
    int numTrackedBones = (int)dynamicPins.size() / 3;
    
    if (numTrackedBones == 0)
    {
        juce::Logger::writeToLog("🦶 BUILD TRIGGERS AUDIO: No tracked bones! Add bones first.");
        return;
    }

    juce::Logger::writeToLog("🦶 BUILD TRIGGERS AUDIO handler called! Creating modules for " + 
                             juce::String(numTrackedBones) + " tracked bones...");

    // 1. Get Animation Module position
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    ImVec2 animPos = ImNodes::GetNodeGridSpacePos((int)animModuleLid);

    // 2. Create one Sample Loader per tracked bone
    std::vector<juce::AudioProcessorGraph::NodeID> samplerNodeIds;
    std::vector<juce::uint32> samplerLids;
    
    for (int i = 0; i < numTrackedBones; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        samplerNodeIds.push_back(samplerNodeId);
        samplerLids.push_back(synth->getLogicalIdForNode(samplerNodeId));
        
        // Position samplers in a vertical stack to the right
        pendingNodePositions[(int)samplerLids[i]] = ImVec2(animPos.x + 400.0f, animPos.y + i * 220.0f);
    }

    // 3. Create Track Mixer (num_bones * 2 for stereo pairs)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(animPos.x + 800.0f, animPos.y + (numTrackedBones * 110.0f));

    // 4. Create Value node for mixer track count
    int numMixerTracks = numTrackedBones * 2; // 2 channels per sampler (stereo)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(animPos.x + 600.0f, animPos.y + (numTrackedBones * 220.0f));

    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = (float)numMixerTracks;
    }

    // 5. Connect Animation Module TRIGGERS to Sample Loader TRIGGER MOD inputs
    // Animation Module Output Channels (per bone):
    //   i*3 + 0: Bone Vel X
    //   i*3 + 1: Bone Vel Y
    //   i*3 + 2: Bone Hit (trigger) ← Connect this to sampler
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int triggerChannel = i * 3 + 2; // Every 3rd channel starting at 2 (2, 5, 8, 11, ...)
        synth->connect(animNodeId, triggerChannel, samplerNodeIds[i], 3); // Bone Hit -> Sampler Trigger Mod
    }

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int mixerChannelL = i * 2;       // 0, 2, 4, 6, ...
        int mixerChannelR = i * 2 + 1;   // 1, 3, 5, 7, ...
        
        synth->connect(samplerNodeIds[i], 0, mixerNodeId, mixerChannelL); // Sampler L -> Mixer Audio L
        synth->connect(samplerNodeIds[i], 1, mixerNodeId, mixerChannelR); // Sampler R -> Mixer Audio R
    }

    // 7. Connect Value node to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
    
    juce::Logger::writeToLog("🦶 BUILD TRIGGERS AUDIO complete! " + juce::String(numTrackedBones) + 
                             " samplers + mixer + wiring created.");
}

void ImGuiNodeEditorComponent::handleAnimationConnectBpmToClock(juce::uint32 animModuleLid)
{
    if (!synth) return;

    // 1. Find the Animation Module
    auto* animModule = synth->getModuleForLogical(animModuleLid);
    if (!animModule)
    {
        juce::Logger::writeToLog("❌ Animation Module not found!");
        return;
    }

    // 2. Find the Tempo Clock Module in the patch (by trying to dynamic_cast each module)
    ModuleProcessor* clockModule = nullptr;
    juce::uint32 clockLid = 0;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* mod = synth->getModuleForLogical(modInfo.first);
        if (auto* tempoClock = dynamic_cast<TempoClockModuleProcessor*>(mod))
        {
            clockModule = tempoClock;
            clockLid = modInfo.first;
            break;
        }
    }

    if (!clockModule)
    {
        juce::Logger::writeToLog("❌ No Tempo Clock module found in patch. Add one first!");
        return;
    }

    // 3. Get node IDs for the connection
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    auto clockNodeId = synth->getNodeIdForLogical(clockLid);

    // 4. Animation BPM output is channel 0 (static pin)
    // Tempo Clock's bpm_mod input is channel 0 (according to the guide)
    const int animBpmOutputChannel = 0;
    const int clockBpmInputChannel = 0;

    // 5. Clear any existing connection to the clock's BPM input by finding and disconnecting it
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstLogicalId == clockLid && conn.dstChan == clockBpmInputChannel)
        {
            // Found an existing connection to this input, disconnect it
            auto srcNodeId = synth->getNodeIdForLogical(conn.srcLogicalId);
            synth->disconnect(srcNodeId, conn.srcChan, clockNodeId, clockBpmInputChannel);
        }
    }

    // 6. Make the new connection
    synth->connect(animNodeId, animBpmOutputChannel, clockNodeId, clockBpmInputChannel);

    // 7. Commit changes and trigger UI update
    synth->commitChanges();
    graphNeedsRebuild = true;
    
    // 8. Save undo state
    pushSnapshot();

    juce::Logger::writeToLog("✅ Connected Animation BPM output to Tempo Clock!");
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. Create the necessary Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 100.0f);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        *dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")) = numSteps;
    }

    // 3. CREATE a Sample Loader for each step and connect its audio to the mixer
    for (int i = 0; i < numSteps; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(seqPos.x + 400.0f, seqPos.y + (i * 220.0f));

        // Connect this sampler's audio output to the mixer's input
        synth->connect(samplerNodeId, 0 /*Audio Output*/, mixerNodeId, i);
        
        // Connect the Sequencer's CV/Trig for this step directly to the new sampler
        synth->connect(seqNodeId, 7 + i * 3 + 0, samplerNodeId, 0); // Pitch N -> Pitch Mod
        synth->connect(seqNodeId, 1, samplerNodeId, 2); // Main Gate -> Gate Mod
        synth->connect(seqNodeId, 7 + i * 3 + 2, samplerNodeId, 3); // Trig N  -> Trigger Mod
    }
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod

    // 4. Connect the mixer to the main output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. CREATE the PolyVCO and Track Mixer
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numSteps;
    }
    
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numSteps;
    }

    // 3. Connect CV, Audio, and Main Output
    for (int i = 0; i < numSteps; ++i)
    {
        // Connect CV: Sequencer -> PolyVCO
        synth->connect(seqNodeId, 7 + i * 3 + 0, polyVcoNodeId, 1 + i);                                  // Pitch N -> Freq N Mod
        synth->connect(seqNodeId, 1, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Main Gate -> Gate N Mod

        // Connect Audio: PolyVCO -> Mixer
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // Connect Num Steps output (channel 6) to PolyVCO's Num Voices Mod input (channel 0)
    synth->connect(seqNodeId, 6, polyVcoNodeId, 0); // Num Steps -> Num Voices Mod
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod
    
    // Connect Mixer -> Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

// Add this exact helper function to the class
void ImGuiNodeEditorComponent::parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex)
{
    outIndex = -1; // Default to no index
    outType = fullName;

    if (fullName.contains(" "))
    {
        const juce::String lastWord = fullName.substring(fullName.lastIndexOfChar(' ') + 1);
        if (lastWord.containsOnly("0123456789"))
        {
            outIndex = lastWord.getIntValue();
            outType = fullName.substring(0, fullName.lastIndexOfChar(' '));
        }
    }
}

// Helper functions to get pins from modules
std::vector<AudioPin> ImGuiNodeEditorComponent::getOutputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioOuts;
    return {};
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getInputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioIns;
    return {};
}

AudioPin* ImGuiNodeEditorComponent::findInputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getInputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

AudioPin* ImGuiNodeEditorComponent::findOutputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getOutputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::findNodesOfType(const juce::String& moduleType)
{
    std::vector<juce::uint32> result;
    if (!synth) return result;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleTypeForLogical(modInfo.first) == moduleType)
        {
            result.push_back(modInfo.first);
        }
    }
    return result;
}

// New dynamic pin-fetching helper
std::vector<PinInfo> ImGuiNodeEditorComponent::getDynamicOutputPins(ModuleProcessor* module)
{
    std::vector<PinInfo> pins;
    if (!module) return pins;

    const int numOutputChannels = module->getBus(false, 0)->getNumberOfChannels();
    for (int i = 0; i < numOutputChannels; ++i)
    {
        juce::String pinName = module->getAudioOutputLabel(i);
        if (pinName.isNotEmpty())
        {
            pins.push_back({(uint32_t)i, pinName}); // Store the full pin name in the type field
        }
    }
    return pins;
}

// Template function implementations
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToMonophonicTargets(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping,
    const std::vector<juce::uint32>& targetLids)
{
    if (!synth || !sourceNode || targetLids.empty()) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToMonophonicTargets called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    // Use provided target logical IDs explicitly
    auto targetNodes = targetLids;

    int currentTargetIndex = 0;

    // First, group all of the source node's output pins by their index number.
    // For example, "Pitch 1" and "Trig 1" will both be in the group for index 1.
    std::map<int, std::vector<PinInfo>> pinsByIndex;
    
    // THE FIX: Get pins directly from the module instance.
    auto outputPins = getDynamicOutputPins(sourceNode);
    
    for (const auto& pin : outputPins)
    {
        juce::String type;
        int index = -1;
        parsePinName(pin.type, type, index); // Use pin.type instead of pin.name
        if (index != -1) {
            // Store channel ID as the pin's ID
            pinsByIndex[index].push_back({(uint32_t)pin.id, type}); 
        }
    }

    // Now, loop through each group of pins (each voice).
    for (auto const& [index, pinsInGroup] : pinsByIndex)
    {
        if (currentTargetIndex >= (int)targetNodes.size()) break; // Stop if we run out of targets
        auto targetNodeId = targetNodes[currentTargetIndex];

        // For each pin in the group (e.g., for "Pitch 1" and "Trig 1")...
        for (const auto& pinInfo : pinsInGroup)
        {
            // Check if we have a connection rule for this pin type (e.g., "Pitch").
            if (pinNameMapping.count(pinInfo.type))
            {
                juce::String targetPinName = pinNameMapping.at(pinInfo.type);
                auto* targetPin = findInputPin("sample loader", targetPinName);

                // If the target pin exists, create the connection.
                if (targetPin)
                {
                    juce::uint32 sourceLogicalId = 0;
                    for (const auto& modInfo : synth->getModulesInfo())
                    {
                        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
                        {
                            sourceLogicalId = modInfo.first;
                            break;
                        }
                    }
                    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);
                    synth->connect(sourceNodeId, pinInfo.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
                }
            }
        }
        // IMPORTANT: Move to the next target module for the next voice.
        currentTargetIndex++;
    }
}

template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToPolyphonicTarget(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping)
{
    if (!synth || !sourceNode) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToPolyphonicTarget called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    juce::uint32 sourceLogicalId = 0;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            sourceLogicalId = modInfo.first;
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    auto targetNodes = findNodesOfType("polyvco");
    if (targetNodes.empty()) return;
    auto targetNodeId = targetNodes[0]; // Use the first available PolyVCO

    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);

    // THE FIX: Get pins directly from the module instance, not the database.
    auto outputPins = getDynamicOutputPins(sourceNode);

    // Loop through every output pin on the source module.
    for (const auto& sourcePin : outputPins)
    {
        // Parse the source pin's name to get its type and index.
        juce::String sourceType;
        int sourceIndex = -1;
        parsePinName(sourcePin.type, sourceType, sourceIndex); // Use pin.type instead of pin.name

        if (sourceIndex == -1) continue; // Skip pins that aren't numbered.

        // Check if we have a rule for this pin type (e.g., "Pitch" maps to "Freq").
        if (pinNameMapping.count(sourceType))
        {
            juce::String targetType = pinNameMapping.at(sourceType);
            // PolyVCO inputs use the format "Freq 1 Mod", "Gate 1 Mod", etc.
            juce::String targetPinName = targetType + " " + juce::String(sourceIndex) + " Mod";

            // Find that pin on the target and connect it if available.
            auto* targetPin = findInputPin("polyvco", targetPinName);
            if (targetPin)
            {
                synth->connect(sourceNodeId, sourcePin.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
            }
        }
    }
}

void ImGuiNodeEditorComponent::handleAutoConnectionRequests()
{
    if (!synth) return;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* module = synth->getModuleForLogical(modInfo.first);
        if (!module) continue;

        // --- Check MultiSequencer Flags ---
        if (auto* multiSeq = dynamic_cast<MultiSequencerModuleProcessor*>(module))
        {
            if (multiSeq->autoConnectSamplersTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectSamplers(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
            if (multiSeq->autoConnectVCOTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectVCO(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
        }
        
        // --- Check StrokeSequencer Flags ---
        if (auto* strokeSeq = dynamic_cast<StrokeSequencerModuleProcessor*>(module))
        {
            if (strokeSeq->autoBuildDrumKitTriggered.exchange(false))
            {
                handleStrokeSeqBuildDrumKit(strokeSeq, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check AnimationModule Flags ---
        if (auto* animModule = dynamic_cast<AnimationModuleProcessor*>(module))
        {
            if (animModule->autoBuildTriggersAudioTriggered.exchange(false))
            {
                handleAnimationBuildTriggersAudio(animModule, modInfo.first);
                pushSnapshot();
                return;
            }
            
            if (animModule->connectBpmToClockTriggered.exchange(false))
            {
                handleAnimationConnectBpmToClock(modInfo.first);
                // pushSnapshot() is called inside the handler
                return;
            }
        }
        
        // --- Check MIDIPlayer Flags ---
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(module))
        {
            if (midiPlayer->autoConnectTriggered.exchange(false)) // Samplers
            {
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
        }
    }
}

void ImGuiNodeEditorComponent::handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType)
{
    if (!synth || !midiPlayer) return;
    
    juce::Logger::writeToLog("[MIDI Player Quick Connect] Request type: " + juce::String(requestType));
    
    // Get ALL tracks (don't filter by whether they have notes)
    const auto& notesByTrack = midiPlayer->getNotesByTrack();
    int numTracks = (int)notesByTrack.size();
    
    if (numTracks == 0)
    {
        juce::Logger::writeToLog("[MIDI Player Quick Connect] No tracks in MIDI file");
        return;
    }
    
    // Get MIDI Player position for positioning new nodes
    ImVec2 playerPos = ImNodes::GetNodeEditorSpacePos(static_cast<int>(midiPlayerLid));
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    
    // Request Type: 1=PolyVCO, 2=Samplers, 3=Both
    juce::uint32 polyVCOLid = 0;
    juce::uint32 mixerLid = 0;
    
    if (requestType == 1 || requestType == 3) // PolyVCO or Both
    {
        // 1. Create PolyVCO
        auto polyVCONodeId = synth->addModule("polyvco");
        polyVCOLid = synth->getLogicalIdForNode(polyVCONodeId);
        pendingNodeScreenPositions[(int)polyVCOLid] = ImVec2(playerPos.x + 400.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created PolyVCO at LID " + juce::String((int)polyVCOLid));
        
        // 2. Create Track Mixer
        auto mixerNodeId = synth->addModule("track_mixer");
        mixerLid = synth->getLogicalIdForNode(mixerNodeId);
        pendingNodeScreenPositions[(int)mixerLid] = ImVec2(playerPos.x + 700.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        
        // 3. Connect MIDI Player tracks to PolyVCO
        // Connect ALL tracks, regardless of whether they have notes
        int trackIdx = 0;
        for (size_t i = 0; i < notesByTrack.size() && trackIdx < 32; ++i)
        {
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiVeloPin = trackIdx * 4 + 2;
            
            const int vcoFreqPin = trackIdx + 1;
            const int vcoWavePin = 32 + trackIdx + 1;
            const int vcoGatePin = 64 + trackIdx + 1;
            
            synth->connect(midiPlayerNodeId, midiPitchPin, polyVCONodeId, vcoFreqPin);
            synth->connect(midiPlayerNodeId, midiGatePin, polyVCONodeId, vcoGatePin);
            synth->connect(midiPlayerNodeId, midiVeloPin, polyVCONodeId, vcoWavePin);
            trackIdx++;
        }
        
        // 4. Connect Num Tracks to PolyVCO (Num Voices Mod on channel 0)
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       polyVCONodeId, 0);
        
        // 5. Connect PolyVCO outputs to Track Mixer inputs
        for (int i = 0; i < trackIdx; ++i)
        {
            synth->connect(polyVCONodeId, i, mixerNodeId, i);
        }
        
        // 6. Connect Num Tracks output to mixer's Num Tracks Mod input
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
        
        // 7. Connect Track Mixer to main output
        auto outputNodeId = synth->getOutputNodeID();
        synth->connect(mixerNodeId, 0, outputNodeId, 0); // L
        synth->connect(mixerNodeId, 1, outputNodeId, 1); // R
        
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                " tracks: MIDI Player → PolyVCO → Track Mixer → Output");
    }
    
    if (requestType == 2 || requestType == 3) // Samplers or Both
    {
        float samplerX = playerPos.x + 400.0f;
        float mixerX = playerPos.x + 700.0f;
        
        // If PolyVCO mode (Both), offset samplers and use same mixer
        if (requestType == 3)
        {
            samplerX += 300.0f; // Offset samplers if PolyVCO exists
            // Reuse existing mixer created in PolyVCO section
        }
        else
        {
            // 1. Create Track Mixer for Samplers-only mode
            auto mixerNodeId = synth->addModule("track_mixer");
            mixerLid = synth->getLogicalIdForNode(mixerNodeId);
            pendingNodeScreenPositions[(int)mixerLid] = ImVec2(mixerX, playerPos.y);
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        }
        
        // 2. Create samplers and connect
        // Connect ALL tracks, regardless of whether they have notes
        auto mixerNodeId = synth->getNodeIdForLogical(mixerLid);
        int trackIdx = 0;
        int totalTracks = (int)notesByTrack.size();
        int mixerStartChannel = (requestType == 3) ? totalTracks : 0; // Offset for "Both" mode
        
        for (size_t i = 0; i < notesByTrack.size(); ++i)
        {
            // Create SampleLoader
            float samplerY = playerPos.y + (trackIdx * 150.0f);
            auto samplerNodeId = synth->addModule("sample_loader");
            juce::uint32 samplerLid = synth->getLogicalIdForNode(samplerNodeId);
            pendingNodeScreenPositions[(int)samplerLid] = ImVec2(samplerX, samplerY);
            
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiTrigPin = trackIdx * 4 + 3;
            
            // Connect MIDI Player to Sampler
            synth->connect(midiPlayerNodeId, midiPitchPin, samplerNodeId, 0);
            synth->connect(midiPlayerNodeId, midiGatePin, samplerNodeId, 2);
            synth->connect(midiPlayerNodeId, midiTrigPin, samplerNodeId, 3);
            
            // Connect Sampler output to Track Mixer input
            synth->connect(samplerNodeId, 0, mixerNodeId, mixerStartChannel + trackIdx);
            
            trackIdx++;
        }
        
        // 3. Connect Num Tracks to mixer and route to output (only if not already done in PolyVCO mode)
        if (requestType != 3)
        {
            synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                           mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
            
            // 4. Connect Track Mixer to output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(mixerNodeId, 0, outputNodeId, 0);
            synth->connect(mixerNodeId, 1, outputNodeId, 1);
            
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Complete chain: " + juce::String(trackIdx) + 
                                    " SampleLoaders → Track Mixer (with Num Tracks) → Stereo Output");
        }
        else
        {
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                    " SampleLoaders → Track Mixer (channels " + juce::String(mixerStartChannel) + 
                                    "-" + juce::String(mixerStartChannel + trackIdx - 1) + 
                                    ") [Mixer already connected in PolyVCO section]");
        }
    }
    
    // Commit changes
    if (synth)
    {
        synth->commitChanges();
        graphNeedsRebuild = true;
    }
    
    pushSnapshot();
}

void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        const int numSelected = ImNodes::NumSelectedLinks();
        const bool isMultiInsert = numSelected > 1;

        // --- FIX: Use map to separate display names from internal type names ---
        // Map format: {Display Name, Internal Type}
        // Internal types use lowercase with underscores for spaces
        const std::map<const char*, const char*> audioInsertable = {
            {"VCF", "vcf"}, {"VCA", "vca"}, {"Delay", "delay"}, {"Reverb", "reverb"},
            {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
            {"Recorder", "recorder"}, {"Limiter", "limiter"}, {"Gate", "gate"}, {"Drive", "drive"},
            {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"}, {"Time/Pitch Shifter", "timepitch"},
            {"Attenuverter", "attenuverter"}, {"De-Crackle", "de_crackle"}, {"Mixer", "mixer"},
            {"Shaping Oscillator", "shaping_oscillator"}, {"Function Generator", "function_generator"},
            {"8-Band Shaper", "8bandshaper"},
            {"Granulator", "granulator"}, {"Harmonic Shaper", "harmonic_shaper"},
            {"Vocal Tract Filter", "vocal_tract_filter"}, {"Scope", "scope"}
        };
        const std::map<const char*, const char*> modInsertable = {
            {"Attenuverter", "attenuverter"}, {"Lag Processor", "lag_processor"}, {"Math", "math"},
            {"MapRange", "map_range"}, {"Quantizer", "quantizer"}, {"S&H", "s_and_h"},
            {"Rate", "rate"}, {"Logic", "logic"}, {"Comparator", "comparator"},
            {"CV Mixer", "cv_mixer"}, {"Sequential Switch", "sequential_switch"}
        };
        const auto& listToShow = linkToInsertOn.isMod ? modInsertable : audioInsertable;

        if (isMultiInsert)
            ImGui::Text("Insert Node on %d Cables", numSelected);
        else
            ImGui::Text("Insert Node on Cable");

        // --- FIX: Iterate over map pairs instead of simple strings ---
        for (const auto& pair : listToShow)
        {
            // pair.first = display label, pair.second = internal type
            if (ImGui::MenuItem(pair.first))
            {
                if (isMultiInsert)
                {
                    handleInsertNodeOnSelectedLinks(pair.second);
                }
                else
                {
                    insertNodeBetween(pair.second);
                }
                ImGui::CloseCurrentPopup();
            }
        }
        
        // VST Plugins submenu (only for audio cables)
        if (!linkToInsertOn.isMod)
        {
            ImGui::Separator();
            if (ImGui::BeginMenu("VST"))
            {
                auto& app = PresetCreatorApplication::getApp();
                auto& knownPluginList = app.getKnownPluginList();
                
                for (const auto& desc : knownPluginList.getTypes())
                {
                    if (ImGui::MenuItem(desc.name.toRawUTF8()))
                    {
                        if (isMultiInsert)
                        {
                            handleInsertNodeOnSelectedLinks(desc.name);
                        }
                        else
                        {
                            insertNodeBetween(desc.name);
                        }
                        ImGui::CloseCurrentPopup();
                    }
                    
                    // Show tooltip with plugin info
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
                        ImGui::Text("Version: %s", desc.version.toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
                ImGui::EndMenu();
            }
        }
        
        ImGui::EndPopup();
    }
    else
    {
        // --- FIX: Reset state when popup is closed ---
        // If the popup is not open (i.e., it was closed or the user clicked away),
        // we must reset the state variable. This ensures that the application
        // is no longer "stuck" in the insert-on-link mode and right-click on
        // empty canvas will work again.
        linkToInsertOn.linkId = -1;
    }
}

// --- NEW HELPER FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position)
{
    if (synth == nullptr) return;

    PinDataType srcType = getPinDataTypeForPin(linkInfo.srcPin);
    PinDataType dstType = getPinDataTypeForPin(linkInfo.dstPin);

    // 1. Create and Position the New Node
    // Check if this is a VST plugin by checking against known plugins
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // This is a VST plugin - use addVstModule
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        // Regular module - use addModule
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points
    auto originalSrcNodeId = synth->getNodeIdForLogical(linkInfo.srcPin.logicalId);
    auto originalDstNodeId = (linkInfo.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkInfo.dstPin.logicalId);

    // 3. Disconnect the Original Link
    synth->disconnect(originalSrcNodeId, linkInfo.srcPin.channel, originalDstNodeId, linkInfo.dstPin.channel);

    // 4. Configure newly inserted node if necessary (e.g., MapRange)
    int newNodeOutputChannel = 0;
    if (nodeType == "MapRange")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(linkInfo.srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    // 5. Reconnect Through the New Node
    synth->connect(originalSrcNodeId, linkInfo.srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, linkInfo.dstPin.channel);
}

void ImGuiNodeEditorComponent::insertNodeOnLinkStereo(const juce::String& nodeType, 
                                                       const LinkInfo& linkLeft, 
                                                       const LinkInfo& linkRight, 
                                                       const ImVec2& position)
{
    if (synth == nullptr) return;

    juce::Logger::writeToLog("[InsertStereo] Inserting stereo node: " + nodeType);
    juce::Logger::writeToLog("[InsertStereo] Left cable: " + juce::String(linkLeft.srcPin.logicalId) + 
                            " ch" + juce::String(linkLeft.srcPin.channel) + " -> " + 
                            juce::String(linkLeft.dstPin.logicalId) + " ch" + juce::String(linkLeft.dstPin.channel));
    juce::Logger::writeToLog("[InsertStereo] Right cable: " + juce::String(linkRight.srcPin.logicalId) + 
                            " ch" + juce::String(linkRight.srcPin.channel) + " -> " + 
                            juce::String(linkRight.dstPin.logicalId) + " ch" + juce::String(linkRight.dstPin.channel));

    // 1. Create ONE node for both channels
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points for LEFT cable (first cable)
    auto leftSrcNodeId = synth->getNodeIdForLogical(linkLeft.srcPin.logicalId);
    auto leftDstNodeId = (linkLeft.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkLeft.dstPin.logicalId);

    // 3. Get Original Connection Points for RIGHT cable (second cable)
    auto rightSrcNodeId = synth->getNodeIdForLogical(linkRight.srcPin.logicalId);
    auto rightDstNodeId = (linkRight.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkRight.dstPin.logicalId);

    // 4. Disconnect BOTH Original Links (using their actual source/dest channels)
    synth->disconnect(leftSrcNodeId, linkLeft.srcPin.channel, leftDstNodeId, linkLeft.dstPin.channel);
    synth->disconnect(rightSrcNodeId, linkRight.srcPin.channel, rightDstNodeId, linkRight.dstPin.channel);

    // 5. Reconnect Through the New Node
    // Left cable -> new node's LEFT input (ch0)
    synth->connect(leftSrcNodeId, linkLeft.srcPin.channel, newNodeId, 0);
    
    // Right cable -> new node's RIGHT input (ch1)
    synth->connect(rightSrcNodeId, linkRight.srcPin.channel, newNodeId, 1);
    
    // New node's outputs -> original destinations
    // Note: We'll connect both outputs to their respective destinations
    synth->connect(newNodeId, 0, leftDstNodeId, linkLeft.dstPin.channel);
    synth->connect(newNodeId, 1, rightDstNodeId, linkRight.dstPin.channel);

    juce::Logger::writeToLog("[InsertStereo] Successfully inserted stereo node with separate sources/destinations");
}

// --- REFACTORED OLD FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin)
{
    if (synth == nullptr) return;

    // 1. Get positions to place the new node between the source and destination
    ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(srcPin.logicalId);
    ImVec2 dstPos = ImNodes::GetNodeGridSpacePos(dstPin.logicalId == 0 ? 0 : dstPin.logicalId);
    ImVec2 newNodePos = ImVec2((srcPos.x + dstPos.x) * 0.5f, (srcPos.y + dstPos.y) * 0.5f);

    // 2. Create and position the new converter node
    // Check if this is a VST plugin
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodePositions[(int)newNodeLid] = newNodePos;

    // 3. Get original node IDs
    auto originalSrcNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
    auto originalDstNodeId = (dstPin.logicalId == 0)
        ? synth->getOutputNodeID()
        : synth->getNodeIdForLogical(dstPin.logicalId);

    // 4. Configure the new node if it's a MapRange or Attenuverter
    int newNodeOutputChannel = 0;
    if (nodeType == "MapRange") {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid))) {
            PinDataType srcType = getPinDataTypeForPin(srcPin);
            PinDataType dstType = getPinDataTypeForPin(dstPin);
            Range inRange = getSourceRange(srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0; // Use Raw Out for Audio, Norm Out for CV
        }
    } else if (nodeType == "Attenuverter") {
        // You might want to pre-configure the Attenuverter here if needed
    }

    // 5. Connect the signal chain: Original Source -> New Node -> Original Destination
    synth->connect(originalSrcNodeId, srcPin.channel, newNodeId, 0); // Source -> New Node's first input
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, dstPin.channel); // New Node -> Destination

    juce::Logger::writeToLog("[AutoConvert] Inserted '" + nodeType + "' between " + juce::String(srcPin.logicalId) + " and " + juce::String(dstPin.logicalId));
}

void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType)
{
    // This function is now just a wrapper that calls the helper
    // with the stored link info and the current mouse position.
    if (linkToInsertOn.linkId != -1)
    {
        insertNodeOnLink(nodeType, linkToInsertOn, ImGui::GetMousePos());
        graphNeedsRebuild = true;
        pushSnapshot();
        linkToInsertOn.linkId = -1; // Reset state
    }
}

void ImGuiNodeEditorComponent::handleInsertNodeOnSelectedLinks(const juce::String& nodeType)
{
    if (synth == nullptr || ImNodes::NumSelectedLinks() == 0) return;

    pushSnapshot(); // Create one undo state for the entire batch operation.

    const int numSelectedLinks = ImNodes::NumSelectedLinks();
    std::vector<int> selectedLinkIds(numSelectedLinks);
    ImNodes::GetSelectedLinks(selectedLinkIds.data());

    ImVec2 basePosition = ImGui::GetMousePos();
    float x_offset = 0.0f;

    // === OPTION A: If exactly 2 audio cables are selected, insert ONE stereo node ===
    if (numSelectedLinks == 2)
    {
        // Get info for both cables
        auto it0 = linkIdToAttrs.find(selectedLinkIds[0]);
        auto it1 = linkIdToAttrs.find(selectedLinkIds[1]);
        
        if (it0 != linkIdToAttrs.end() && it1 != linkIdToAttrs.end())
        {
            LinkInfo link0, link1;
            link0.linkId = selectedLinkIds[0];
            link0.srcPin = decodePinId(it0->second.first);
            link0.dstPin = decodePinId(it0->second.second);
            link0.isMod = link0.srcPin.isMod || link0.dstPin.isMod;
            
            link1.linkId = selectedLinkIds[1];
            link1.srcPin = decodePinId(it1->second.first);
            link1.dstPin = decodePinId(it1->second.second);
            link1.isMod = link1.srcPin.isMod || link1.dstPin.isMod;
            
            // Check if BOTH are audio cables (not mod cables)
            if (!link0.isMod && !link1.isMod)
            {
                // Create ONE stereo node with link0 -> Left (ch0), link1 -> Right (ch1)
                insertNodeOnLinkStereo(nodeType, link0, link1, basePosition);
                juce::Logger::writeToLog("[InsertNode] Inserted STEREO node for 2 selected audio cables");
                graphNeedsRebuild = true;
                return; // Done - we've handled both cables with one node
            }
        }
    }

    // === FALLBACK: Multiple cables or mixed mod/audio - insert separate nodes ===
    std::set<int> processedLinks; // Track which links we've already handled
    
    for (size_t i = 0; i < selectedLinkIds.size(); ++i)
    {
        int linkId = selectedLinkIds[i];
        if (processedLinks.count(linkId)) continue;

        auto it = linkIdToAttrs.find(linkId);
        if (it == linkIdToAttrs.end()) continue;

        LinkInfo currentLink;
        currentLink.linkId = linkId;
        currentLink.srcPin = decodePinId(it->second.first);
        currentLink.dstPin = decodePinId(it->second.second);
        currentLink.isMod = currentLink.srcPin.isMod || currentLink.dstPin.isMod;

        ImVec2 newPosition = ImVec2(basePosition.x + x_offset, basePosition.y);
        
        // === MONO INSERT: Create separate node for each cable ===
        insertNodeOnLink(nodeType, currentLink, newPosition);
        processedLinks.insert(linkId);
        juce::Logger::writeToLog("[InsertNode] Inserted MONO node for link " + juce::String(linkId));

        x_offset += 40.0f;
    }

    graphNeedsRebuild = true;
    // The single pushSnapshot at the beginning handles the undo state.
}

juce::File ImGuiNodeEditorComponent::findPresetsDirectory()
{
    // Search upwards from the executable's location for a sibling directory
    // named "Synth_presets". This is robust to different build configurations.
    juce::File dir = juce::File::getSpecialLocation(juce::File::currentApplicationFile);

    for (int i = 0; i < 8; ++i) // Limit search depth to 8 levels
    {
        dir = dir.getParentDirectory();
        if (!dir.exists()) break;

        juce::File candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.isDirectory())
        {
            return candidate;
        }
    }
    
    // Fallback to an empty file (system default) if not found
    return {};
}

// Helper function implementations
PinDataType ImGuiNodeEditorComponent::getPinDataTypeForPin(const PinID& pin)
{
    if (synth == nullptr) return PinDataType::Raw;

    // Handle the main output node as a special case
    if (pin.logicalId == 0)
    {
        return PinDataType::Audio;
    }

    juce::String moduleType = getTypeForLogical(pin.logicalId);
    if (moduleType.isEmpty()) return PinDataType::Raw;

    // *** NEW: Check dynamic pins FIRST ***
    if (auto* module = synth->getModuleForLogical(pin.logicalId))
    {
        // Check dynamic input pins
        if (pin.isInput && !pin.isMod)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            for (const auto& dynPin : dynamicInputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
        // Check dynamic output pins
        else if (!pin.isInput && !pin.isMod)
        {
            auto dynamicOutputs = module->getDynamicOutputPins();
            for (const auto& dynPin : dynamicOutputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
    }
    // *** END NEW CODE ***

    auto it = getModulePinDatabase().find(moduleType);
    if (it == getModulePinDatabase().end())
    {
        // Fallback: case-insensitive lookup (module registry may use different casing)
        juce::String moduleTypeLower = moduleType.toLowerCase();
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0 || kv.first.toLowerCase() == moduleTypeLower)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
        if (it == getModulePinDatabase().end())
        {
            // If the module type is not in our static database, it's likely a VST plugin.
            // A safe assumption is that its pins are for audio.
            if (auto* module = synth->getModuleForLogical(pin.logicalId))
            {
                if (dynamic_cast<VstHostModuleProcessor*>(module))
                {
                    return PinDataType::Audio; // Green for VST pins
                }
            }
            return PinDataType::Raw;
        }
    }

    const auto& pinInfo = it->second;

    if (pin.isMod)
    {
        for (const auto& modPin : pinInfo.modIns)
        {
            if (modPin.paramId == pin.paramId)
            {
                return modPin.type;
            }
        }
    }
    else // It's an audio pin
    {
        const auto& pins = pin.isInput ? pinInfo.audioIns : pinInfo.audioOuts;
        for (const auto& audioPin : pins)
        {
            if (audioPin.channel == pin.channel)
            {
                return audioPin.type;
            }
        }
    }
    return PinDataType::Raw; // Fallback
}

unsigned int ImGuiNodeEditorComponent::getImU32ForType(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return IM_COL32(100, 150, 255, 255); // Blue
        case PinDataType::Audio: return IM_COL32(100, 255, 150, 255); // Green
        case PinDataType::Gate:  return IM_COL32(255, 220, 100, 255); // Yellow
        case PinDataType::Raw:   return IM_COL32(255, 100, 100, 255); // Red
        default:                 return IM_COL32(150, 150, 150, 255); // Grey
    }
}

const char* ImGuiNodeEditorComponent::pinDataTypeToString(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return "CV (0 to 1)";
        case PinDataType::Audio: return "Audio (-1 to 1)";
        case PinDataType::Gate:  return "Gate/Trigger";
        case PinDataType::Raw:   return "Raw";
        default:                 return "Unknown";
    }
}

// Add this new function implementation to the .cpp file.

void ImGuiNodeEditorComponent::handleNodeChaining()
{
    if (synth == nullptr) return;

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1) return;

    juce::Logger::writeToLog("[Node Chaining] Initiated for " + juce::String(numSelected) + " nodes.");

    // 1. Get all selected nodes and their horizontal positions.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        // Don't include the main output node in the chaining logic.
        if (nodeId == 0) continue;
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    // 2. Sort the nodes from left to right based on their X position.
    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    // 3. Connect the nodes in sequence.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid != 0 && destNodeId.uid != 0)
        {
            // Standard stereo connection: Out L -> In L, Out R -> In R
            synth->connect(sourceNodeId, 0, destNodeId, 0); // Connect channel 0
            synth->connect(sourceNodeId, 1, destNodeId, 1); // Connect channel 1

            juce::Logger::writeToLog("[Node Chaining] Connected " + getTypeForLogical(sourceLid) + " (" + juce::String(sourceLid) + ") to " + getTypeForLogical(destLid) + " (" + juce::String(destLid) + ")");
            
            // Check if the destination is a recorder and update its filename
            if (auto* destModule = synth->getModuleForLogical(destLid))
            {
                if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                {
                    if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                    {
                        recorder->updateSuggestedFilename(sourceModule->getName());
                    }
                }
            }
        }
    }

    // 4. Apply all the new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Add this new helper function implementation.

std::vector<AudioPin> ImGuiNodeEditorComponent::getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType)
{
    std::vector<AudioPin> matchingPins;
    juce::String moduleType = getTypeForLogical(logicalId);

    if (moduleType.isEmpty())
    {
        return matchingPins;
    }

    auto it = getModulePinDatabase().find(moduleType);

    // --- CASE-INSENSITIVE LOOKUP ---
    if (it == getModulePinDatabase().end())
    {
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
    }

    if (it != getModulePinDatabase().end())
    {
        // --- Standard path for built-in modules ---
        const auto& pins = isInput ? it->second.audioIns : it->second.audioOuts;
        for (const auto& pin : pins)
        {
            if (pin.type == targetType)
            {
                matchingPins.push_back(pin);
            }
        }
    }
    else if (auto* module = synth->getModuleForLogical(logicalId))
    {
        // --- DYNAMIC PATH FOR MODULES WITH getDynamicInputPins/getDynamicOutputPins ---
        auto dynamicPins = isInput ? module->getDynamicInputPins() : module->getDynamicOutputPins();
        
        if (!dynamicPins.empty())
        {
            // Module provides dynamic pins - filter by type
            for (const auto& pin : dynamicPins)
            {
                if (pin.type == targetType)
                {
                    matchingPins.emplace_back(pin.name, pin.channel, pin.type);
                }
            }
        }
        else if (dynamic_cast<VstHostModuleProcessor*>(module))
        {
            // For VSTs without dynamic pins, assume all pins are 'Audio' type for chaining.
            if (targetType == PinDataType::Audio)
            {
                const int numChannels = isInput ? module->getTotalNumInputChannels() : module->getTotalNumOutputChannels();
                for (int i = 0; i < numChannels; ++i)
                {
                    juce::String pinName = isInput ? module->getAudioInputLabel(i) : module->getAudioOutputLabel(i);
                    if (pinName.isNotEmpty())
                    {
                        matchingPins.emplace_back(pinName, i, PinDataType::Audio);
                    }
                }
            }
        }
    }

    return matchingPins;
}

// Add this new function implementation to the .cpp file.

void ImGuiNodeEditorComponent::handleRecordOutput()
{
    if (!synth) return;

    pushSnapshot();
    juce::Logger::writeToLog("[Record Output] Initiated.");

    // 1. Find connections going to the main output node.
    std::vector<ModularSynthProcessor::ConnectionInfo> outputFeeds;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstIsOutput)
        {
            outputFeeds.push_back(c);
        }
    }

    if (outputFeeds.empty())
    {
        juce::Logger::writeToLog("[Record Output] No connections to main output found.");
        return;
    }

    // 2. Create and position the recorder.
    auto recorderNodeId = synth->addModule("recorder");
    auto recorderLid = synth->getLogicalIdForNode(recorderNodeId);
    ImVec2 outPos = ImNodes::GetNodeGridSpacePos(0);
    pendingNodePositions[(int)recorderLid] = ImVec2(outPos.x - 400.0f, outPos.y);
    
    auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical(recorderLid));
    if (recorder)
    {
        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
    }

    // 3. "Tap" the signals by connecting the original sources to the recorder.
    juce::String sourceName;
    for (const auto& feed : outputFeeds)
    {
        auto srcNodeId = synth->getNodeIdForLogical(feed.srcLogicalId);
        synth->connect(srcNodeId, feed.srcChan, recorderNodeId, feed.dstChan); // dstChan will be 0 or 1
        
        // Get the name of the first source for the filename prefix
        if (sourceName.isEmpty())
        {
            if (auto* srcModule = synth->getModuleForLogical(feed.srcLogicalId))
            {
                sourceName = srcModule->getName();
            }
        }
    }
    
    if (recorder)
    {
        recorder->updateSuggestedFilename(sourceName);
    }

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[Record Output] Recorder added and connected.");
}

void ImGuiNodeEditorComponent::handleColorCodedChaining(PinDataType targetType)
{
    if (synth == nullptr)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: synth is nullptr");
        return;
    }

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: numSelected <= 1 (" + juce::String(numSelected) + ")");
        return;
    }

    juce::Logger::writeToLog("[Color Chaining] Started for " + juce::String(toString(targetType)) + " with " + juce::String(numSelected) + " nodes");

    // 1. Get and sort selected nodes by their horizontal position.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0) continue; // Exclude the output node.
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    if (sortedNodes.empty())
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: No valid nodes after filtering");
        return;
    }

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    int totalConnectionsMade = 0;
    int totalConnectionAttempts = 0;

    // 2. Iterate through sorted nodes and connect matching pins.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[Color Chaining] Skipping invalid node pair: " + juce::String(sourceLid) + " -> " + juce::String(destLid));
            continue;
        }

        // Find all matching output pins on the source and input pins on the destination.
        auto sourcePins = getPinsOfType(sourceLid, false, targetType);
        auto destPins   = getPinsOfType(destLid, true, targetType);

        if (sourcePins.empty() || destPins.empty())
        {
            juce::Logger::writeToLog("[Color Chaining] No matching pins: " + juce::String(sourcePins.size()) + " src, " + juce::String(destPins.size()) + " dst");
            continue;
        }

        // Connect them one-to-one until we run out of available pins on either side.
        int connectionsToMake = std::min((int)sourcePins.size(), (int)destPins.size());

        for (int j = 0; j < connectionsToMake; ++j)
        {
            totalConnectionAttempts++;
            bool connectResult = synth->connect(sourceNodeId, sourcePins[j].channel, destNodeId, destPins[j].channel);
            if (connectResult)
            {
                totalConnectionsMade++;
                juce::Logger::writeToLog("[Color Chaining] Connected " + getTypeForLogical(sourceLid) + " -> " + getTypeForLogical(destLid));

                // Check if the destination is a recorder and update its filename
                if (auto* destModule = synth->getModuleForLogical(destLid))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                    {
                        if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                        {
                            recorder->updateSuggestedFilename(sourceModule->getName());
                        }
                    }
                }
            }
        }
    }

    juce::Logger::writeToLog("[Color Chaining] Completed: " + juce::String(totalConnectionsMade) + "/" + juce::String(totalConnectionAttempts) + " connections made");

    // 3. Apply all new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Module Category Color Coding
ImGuiNodeEditorComponent::ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleType)
{
    juce::String lower = moduleType.toLowerCase();
    
    // --- MIDI Family (Vibrant Purple) ---
    if (lower.contains("midi"))
        return ModuleCategory::MIDI;
    
    // --- Physics Family (Cyan) ---
    if (lower.contains("physics"))
        return ModuleCategory::Physics;
    
    // --- Sources (Green) ---
    // Check specific matches first to avoid substring conflicts
    if (lower == "tts performer")  // Explicit TTS categorization
        return ModuleCategory::Source;
    
    if (lower.contains("vco") || lower.contains("noise") || 
        lower.contains("sequencer") || lower.contains("sample") || 
        lower.contains("input") ||
        lower.contains("polyvco") || lower.contains("value")) 
        return ModuleCategory::Source;
    
    // --- Effects (Red) ---
    // Check "Vocal Tract Filter" before general "filter" check
    if (lower == "vocal tract filter")
        return ModuleCategory::Effect;
    
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("reverb") || lower.contains("chorus") || 
        lower.contains("phaser") || lower.contains("compressor") || 
        lower.contains("drive") || lower.contains("shaper") ||  // Note: "shaping oscillator" handled above
        lower.contains("filter") || lower.contains("waveshaper") ||
        lower.contains("limiter") || lower.contains("gate") ||
        lower.contains("granulator") || lower.contains("eq") ||
        lower.contains("crackle") || lower.contains("timepitch") ||
        lower.contains("recorder"))  // Moved from Analysis
        return ModuleCategory::Effect;
    
    // --- Modulators (Blue) ---
    if (lower.contains("lfo") || lower.contains("adsr") || 
        lower.contains("random") || lower.contains("s&h") || 
        lower.contains("function")) 
        return ModuleCategory::Modulator;
    
    // --- Analysis (Purple) ---
    if (lower.contains("scope") || lower.contains("debug") || 
        lower.contains("graph")) 
        return ModuleCategory::Analysis;
    
    // --- Comment (Grey) ---
    if (lower.contains("comment")) 
        return ModuleCategory::Comment;
    
    // --- Plugins (Teal) ---
    if (lower.contains("vst") || lower.contains("plugin"))
        return ModuleCategory::Plugin;
    
    // --- Utilities & Logic (Orange) - Default ---
    return ModuleCategory::Utility;
}

unsigned int ImGuiNodeEditorComponent::getImU32ForCategory(ModuleCategory category, bool hovered)
{
    ImU32 color;
    switch (category)
    {
        case ModuleCategory::Source:     color = IM_COL32(50, 120, 50, 255); break;   // Green
        case ModuleCategory::Effect:     color = IM_COL32(130, 60, 60, 255); break;   // Red
        case ModuleCategory::Modulator:  color = IM_COL32(50, 50, 130, 255); break;   // Blue
        case ModuleCategory::Utility:    color = IM_COL32(110, 80, 50, 255); break;   // Orange
        case ModuleCategory::Analysis:   color = IM_COL32(100, 50, 110, 255); break;  // Purple
        case ModuleCategory::Comment:    color = IM_COL32(80, 80, 80, 255); break;    // Grey
        case ModuleCategory::Plugin:     color = IM_COL32(50, 110, 110, 255); break;  // Teal
        case ModuleCategory::MIDI:       color = IM_COL32(180, 120, 255, 255); break; // Vibrant Purple
        case ModuleCategory::Physics:    color = IM_COL32(50, 200, 200, 255); break;  // Cyan
        default:                         color = IM_COL32(70, 70, 70, 255); break;
    }
    
    if (hovered) 
    { 
        // Brighten on hover
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        c.x *= 1.3f; c.y *= 1.3f; c.z *= 1.3f;
        return ImGui::ColorConvertFloat4ToU32(c);
    }
    return color;
}

// Quick Add Menu - Module Registry - Dictionary
// Maps Display Name -> { Internal Type, Description }
std::map<juce::String, std::pair<const char*, const char*>> ImGuiNodeEditorComponent::getModuleRegistry()
{
    return {
        // Sources
        {"Audio Input", {"audio_input", "Records audio from your audio interface"}},
        {"VCO", {"vco", "Voltage Controlled Oscillator - generates waveforms"}},
        {"Polyphonic VCO", {"polyvco", "Polyphonic VCO with multiple voices"}},
        {"Noise", {"noise", "White, pink, or brown noise generator"}},
        {"Sequencer", {"sequencer", "Step sequencer for creating patterns"}},
        {"Multi Sequencer", {"multi_sequencer", "Multi-track step sequencer"}},
        {"Stroke Sequencer", {"stroke_sequencer", "Freeform visual rhythmic and CV generator"}},
        {"MIDI Player", {"midi_player", "Plays MIDI files"}},
        {"MIDI CV", {"midi_cv", "Converts MIDI Note/CC messages to CV signals. (Monophonic)"}},
        {"MIDI Faders", {"midi_faders", "Up to 16 MIDI faders with CC learning"}},
        {"MIDI Knobs", {"midi_knobs", "Up to 16 MIDI knobs/rotary encoders with CC learning"}},
        {"MIDI Buttons", {"midi_buttons", "Up to 32 MIDI buttons with Gate/Toggle/Trigger modes"}},
        {"MIDI Jog Wheel", {"midi_jog_wheel", "Single MIDI jog wheel/rotary encoder"}},
        {"MIDI Pads", {"midi_pads", "16-pad MIDI controller with polyphonic triggers and velocity outputs"}},
        {"MIDI Logger", {"midi_logger", "Records CV/Gate to MIDI events with piano roll editor and .mid export"}},
        {"Value", {"value", "Constant CV value output"}},
        {"Sample Loader", {"sample_loader", "Loads and plays audio samples"}},
        
        // TTS
        {"TTS Performer", {"tts_performer", "Text-to-speech synthesizer"}},
        {"Vocal Tract Filter", {"vocal_tract_filter", "Physical model vocal tract filter"}},
        
        // Physics & Animation
        {"Physics", {"physics", "2D physics simulation for audio modulation"}},
        {"Animation", {"animation", "Skeletal animation system with glTF file support"}},
        
        // Effects
        {"VCF", {"vcf", "Voltage Controlled Filter"}},
        {"Delay", {"delay", "Echo/delay effect"}},
        {"Reverb", {"reverb", "Reverb effect"}},
        {"Chorus", {"chorus", "Chorus effect for thickening sound"}},
        {"Phaser", {"phaser", "Phaser modulation effect"}},
        {"Compressor", {"compressor", "Dynamic range compressor"}},
        {"Recorder", {"recorder", "Records audio to disk"}},
        {"Limiter", {"limiter", "Peak limiter"}},
        {"Noise Gate", {"gate", "Noise gate"}},
        {"Drive", {"drive", "Distortion/overdrive"}},
        {"Graphic EQ", {"graphic_eq", "Graphic equalizer"}},
        {"Waveshaper", {"waveshaper", "Waveshaping distortion"}},
        {"8-Band Shaper", {"8bandshaper", "8-band spectral shaper"}},
        {"Granulator", {"granulator", "Granular synthesis effect"}},
        {"Harmonic Shaper", {"harmonic_shaper", "Harmonic content shaper"}},
        {"Time/Pitch Shifter", {"timepitch", "Time stretching and pitch shifting"}},
        {"De-Crackle", {"de_crackle", "Removes clicks and pops"}},
        
        // Modulators
        {"LFO", {"lfo", "Low Frequency Oscillator for modulation"}},
        {"ADSR", {"adsr", "Attack Decay Sustain Release envelope"}},
        {"Random", {"random", "Random value generator"}},
        {"S&H", {"s_and_h", "Sample and Hold"}},
        {"Tempo Clock", {"tempo_clock", "Global clock with BPM control, transport (play/stop/reset), division, swing, and clock/gate outputs. Use External Takeover to drive the master transport."}},
        {"Function Generator", {"function_generator", "Custom function curves"}},
        {"Shaping Oscillator", {"shaping_oscillator", "Oscillator with waveshaping"}},
        
        // Utilities
        {"VCA", {"vca", "Voltage Controlled Amplifier"}},
        {"Mixer", {"mixer", "Audio/CV mixer"}},
        {"CV Mixer", {"cv_mixer", "CV signal mixer"}},
        {"Track Mixer", {"track_mixer", "Multi-track mixer with panning"}},
        {"Attenuverter", {"attenuverter", "Attenuate and invert signals"}},
        {"Lag Processor", {"lag_processor", "Slew rate limiter/smoother"}},
        {"Math", {"math", "Mathematical operations"}},
        {"Map Range", {"map_range", "Map values from one range to another"}},
        {"Quantizer", {"quantizer", "Quantize CV to scales"}},
        {"Rate", {"rate", "Rate/frequency divider"}},
        {"Comparator", {"comparator", "Compare and threshold signals"}},
        {"Logic", {"logic", "Boolean logic operations"}},
        {"Clock Divider", {"clock_divider", "Clock division and multiplication"}},
        {"Sequential Switch", {"sequential_switch", "Sequential signal router"}},
        {"Comment", {"comment", "Text comment box"}},
        {"Best Practice", {"best_practice", "Best practice node template"}},
        {"Snapshot Sequencer", {"snapshot_sequencer", "Snapshot sequencer for parameter automation"}},
        
        // Analysis
        {"Scope", {"scope", "Oscilloscope display"}},
        {"Debug", {"debug", "Debug value display"}},
        {"Input Debug", {"input_debug", "Input signal debugger"}},
        {"Frequency Graph", {"frequency_graph", "Spectrum analyzer display"}}
    };
}

// Legacy function for backwards compatibility with tooltip display
std::vector<std::pair<juce::String, const char*>> ImGuiNodeEditorComponent::getModuleDescriptions()
{
    std::vector<std::pair<juce::String, const char*>> result;
    for (const auto& entry : getModuleRegistry())
    {
        // Return {internal type, description} for compatibility
        result.push_back({entry.second.first, entry.second.second});
    }
    return result;
}

// VST Plugin Support
void ImGuiNodeEditorComponent::addPluginModules()
{
    if (synth == nullptr)
        return;
    
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    auto& formatManager = app.getPluginFormatManager();
    
    // Set the plugin format manager and known plugin list on the synth if not already set
    synth->setPluginFormatManager(&formatManager);
    synth->setKnownPluginList(&knownPluginList);
    
    // Display each known plugin as a button
    const auto& plugins = knownPluginList.getTypes();
    
    if (plugins.isEmpty())
    {
        ImGui::TextDisabled("No plugins found.");
        ImGui::TextDisabled("Use 'Scan for Plugins...' in the File menu.");
        return;
    }
    
    for (const auto& desc : plugins)
    {
        juce::String buttonLabel = desc.name;
        if (desc.manufacturerName.isNotEmpty())
        {
            buttonLabel += " (" + desc.manufacturerName + ")";
        }
        
        if (ImGui::Selectable(buttonLabel.toRawUTF8()))
        {
            auto nodeId = synth->addVstModule(formatManager, desc);
            if (nodeId.uid != 0)
            {
                const ImVec2 mouse = ImGui::GetMousePos();
                const auto logicalId = synth->getLogicalIdForNode(nodeId);
                pendingNodeScreenPositions[(int)logicalId] = mouse;
                snapshotAfterEditor = true;
                juce::Logger::writeToLog("[VST] Added plugin: " + desc.name);
            }
            else
            {
                juce::Logger::writeToLog("[VST] ERROR: Failed to add plugin: " + desc.name);
            }
        }
        
        // Show tooltip with plugin info on hover
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("Name: %s", desc.name.toRawUTF8());
            ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
            ImGui::Text("Version: %s", desc.version.toRawUTF8());
            ImGui::Text("Format: %s", desc.pluginFormatName.toRawUTF8());
            ImGui::Text("Type: %s", desc.isInstrument ? "Instrument" : "Effect");
            ImGui::Text("Inputs: %d", desc.numInputChannels);
            ImGui::Text("Outputs: %d", desc.numOutputChannels);
            ImGui::EndTooltip();
        }
    }
}

void ImGuiNodeEditorComponent::handleCollapseToMetaModule()
{
    if (!synth)
        return;
    
    juce::Logger::writeToLog("[Meta Module] Starting collapse operation...");
    
    // 1. Get selected nodes
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected < 2)
    {
        juce::Logger::writeToLog("[Meta Module] ERROR: Need at least 2 nodes selected");
        return;
    }
    
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());
    
    // Convert to logical IDs
    std::set<juce::uint32> selectedLogicalIds;
    for (int nodeId : selectedNodeIds)
    {
        selectedLogicalIds.insert((juce::uint32)nodeId);
    }
    
    juce::Logger::writeToLog("[Meta Module] Selected " + juce::String(numSelected) + " nodes");
    
    // 2. Analyze boundary connections
    struct BoundaryConnection
    {
        juce::uint32 externalLogicalId;
        int externalChannel;
        juce::uint32 internalLogicalId;
        int internalChannel;
        bool isInput; // true = external -> internal, false = internal -> external
    };
    
    std::vector<BoundaryConnection> boundaries;
    auto allConnections = synth->getConnectionsInfo();
    
    for (const auto& conn : allConnections)
    {
        bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
        bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0 && !conn.dstIsOutput;
        bool dstIsOutput = conn.dstIsOutput;
        
        // Inlet: external -> selected
        if (!srcIsSelected && dstIsSelected)
        {
            BoundaryConnection bc;
            bc.externalLogicalId = conn.srcLogicalId;
            bc.externalChannel = conn.srcChan;
            bc.internalLogicalId = conn.dstLogicalId;
            bc.internalChannel = conn.dstChan;
            bc.isInput = true;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found inlet: " + juce::String(bc.externalLogicalId) + 
                                    " -> " + juce::String(bc.internalLogicalId));
        }
        // Outlet: selected -> external or output
        else if (srcIsSelected && (!dstIsSelected || dstIsOutput))
        {
            BoundaryConnection bc;
            bc.externalLogicalId = dstIsOutput ? 0 : conn.dstLogicalId;
            bc.externalChannel = conn.dstChan;
            bc.internalLogicalId = conn.srcLogicalId;
            bc.internalChannel = conn.srcChan;
            bc.isInput = false;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found outlet: " + juce::String(bc.internalLogicalId) + 
                                    " -> " + (dstIsOutput ? "OUTPUT" : juce::String(bc.externalLogicalId)));
        }
    }
    
    // Count inlets and outlets
    int numInlets = 0;
    int numOutlets = 0;
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            numInlets++;
        else
            numOutlets++;
    }
    
    juce::Logger::writeToLog("[META] Boundary Detection: Found " + juce::String(numInlets) + " inlets and " + juce::String(numOutlets) + " outlets.");
    juce::Logger::writeToLog("[META] Found " + juce::String(boundaries.size()) + " boundary connections");
    
    if (boundaries.empty())
    {
        juce::Logger::writeToLog("[META] WARNING: No boundary connections - creating isolated meta module");
    }
    
    // 3. Create the internal graph state
    pushSnapshot(); // Make undoable
    
    // Save the state of selected nodes
    juce::MemoryBlock internalState;
    {
        // Create a temporary state containing only selected nodes
        juce::ValueTree internalRoot("ModularSynthPreset");
        internalRoot.setProperty("version", 1, nullptr);
        
        juce::ValueTree modsVT("modules");
        juce::ValueTree connsVT("connections");
        
        // Add selected modules
        std::map<juce::uint32, juce::uint32> oldToNewLogicalId;
        juce::uint32 newLogicalId = 1;
        
        for (juce::uint32 oldId : selectedLogicalIds)
        {
            oldToNewLogicalId[oldId] = newLogicalId++;
            
            auto* module = synth->getModuleForLogical(oldId);
            if (!module)
                continue;
            
            juce::String moduleType = synth->getModuleTypeForLogical(oldId);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)oldToNewLogicalId[oldId], nullptr);
            mv.setProperty("type", moduleType, nullptr);
            
            // Save parameters
            juce::ValueTree params = module->getAPVTS().copyState();
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(params, -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            // Save extra state
            if (auto extra = module->getExtraStateTree(); extra.isValid())
            {
                juce::ValueTree extraWrapper("extra");
                extraWrapper.addChild(extra, -1, nullptr);
                mv.addChild(extraWrapper, -1, nullptr);
            }
            
            modsVT.addChild(mv, -1, nullptr);
        }
        
        // Add inlet modules for each unique input
        std::map<std::pair<juce::uint32, int>, juce::uint32> inletMap; // (extId, extCh) -> inletLogicalId
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                auto key = std::make_pair(bc.externalLogicalId, bc.externalChannel);
                if (inletMap.find(key) == inletMap.end())
                {
                    juce::uint32 inletId = newLogicalId++;
                    inletMap[key] = inletId;
                    
                    juce::ValueTree mv("module");
                    mv.setProperty("logicalId", (int)inletId, nullptr);
                    mv.setProperty("type", "inlet", nullptr);
                    modsVT.addChild(mv, -1, nullptr);
                    
                    juce::Logger::writeToLog("[Meta Module] Created inlet node ID=" + juce::String(inletId));
                }
            }
        }
        
        // Add outlet modules for each unique output
        std::map<std::pair<juce::uint32, int>, juce::uint32> outletMap; // (intId, intCh) -> outletLogicalId
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                auto key = std::make_pair(bc.internalLogicalId, bc.internalChannel);
                if (outletMap.find(key) == outletMap.end())
                {
                    juce::uint32 outletId = newLogicalId++;
                    outletMap[key] = outletId;
                    
                    juce::ValueTree mv("module");
                    mv.setProperty("logicalId", (int)outletId, nullptr);
                    mv.setProperty("type", "outlet", nullptr);
                    modsVT.addChild(mv, -1, nullptr);
                    
                    juce::Logger::writeToLog("[Meta Module] Created outlet node ID=" + juce::String(outletId));
                }
            }
        }
        
        // Add internal connections (between selected nodes)
        for (const auto& conn : allConnections)
        {
            bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
            bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0;
            
            if (srcIsSelected && dstIsSelected)
            {
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[conn.srcLogicalId], nullptr);
                cv.setProperty("srcChan", conn.srcChan, nullptr);
                cv.setProperty("dstId", (int)oldToNewLogicalId[conn.dstLogicalId], nullptr);
                cv.setProperty("dstChan", conn.dstChan, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from inlets to internal nodes
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                auto key = std::make_pair(bc.externalLogicalId, bc.externalChannel);
                juce::uint32 inletId = inletMap[key];
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)inletId, nullptr);
                cv.setProperty("srcChan", 0, nullptr); // Inlets output on channel 0
                cv.setProperty("dstId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("dstChan", bc.internalChannel, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from internal nodes to outlets
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                auto key = std::make_pair(bc.internalLogicalId, bc.internalChannel);
                juce::uint32 outletId = outletMap[key];
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("srcChan", bc.internalChannel, nullptr);
                cv.setProperty("dstId", (int)outletId, nullptr);
                cv.setProperty("dstChan", 0, nullptr); // Outlets input on channel 0
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        internalRoot.addChild(modsVT, -1, nullptr);
        internalRoot.addChild(connsVT, -1, nullptr);
        
        // Serialize to memory block
        if (auto xml = internalRoot.createXml())
        {
            juce::MemoryOutputStream mos(internalState, false);
            xml->writeTo(mos);
            juce::Logger::writeToLog("[META] Generated state for sub-patch.");
        }
    }
    
    // 4. Calculate average position for the meta module
    ImVec2 avgPos(0.0f, 0.0f);
    int posCount = 0;
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos((int)logicalId);
        avgPos.x += pos.x;
        avgPos.y += pos.y;
        posCount++;
    }
    if (posCount > 0)
    {
        avgPos.x /= posCount;
        avgPos.y /= posCount;
    }
    
    // 5. Delete selected nodes
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        auto nodeId = synth->getNodeIdForLogical(logicalId);
        synth->removeModule(nodeId);
    }
    
    // 6. Create meta module
    auto metaNodeId = synth->addModule("meta module");
    auto metaLogicalId = synth->getLogicalIdForNode(metaNodeId);
    pendingNodePositions[(int)metaLogicalId] = avgPos;
    
    juce::Logger::writeToLog("[META] Created new MetaModule with logical ID: " + juce::String((int)metaLogicalId));
    
    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule)
    {
        // Load the internal state
        metaModule->setStateInformation(internalState.getData(), (int)internalState.getSize());
        juce::Logger::writeToLog("[META] Loaded internal state into meta module");
    }
    else
    {
        juce::Logger::writeToLog("[META] ERROR: Failed to create meta module");
        return;
    }
    
    // 7. Reconnect external connections
    // Note: This is a simplified implementation - in production, you'd need to map
    // inlet/outlet indices to meta module input/output channels properly
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
        {
            // Connect external source to meta module input
            auto extNodeId = synth->getNodeIdForLogical(bc.externalLogicalId);
            synth->connect(extNodeId, bc.externalChannel, metaNodeId, 0);
        }
        else if (bc.externalLogicalId != 0)
        {
            // Connect meta module output to external destination
            auto extNodeId = synth->getNodeIdForLogical(bc.externalLogicalId);
            synth->connect(metaNodeId, 0, extNodeId, bc.externalChannel);
        }
        else
        {
            // Connect meta module output to main output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(metaNodeId, 0, outputNodeId, bc.externalChannel);
        }
    }
    
    graphNeedsRebuild = true;
    synth->commitChanges();
    
    juce::Logger::writeToLog("[META] Reconnected external cables. Collapse complete!");
}

void ImGuiNodeEditorComponent::loadPresetFromFile(const juce::File& file)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    // 1. Load the file content.
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);

    // 2. Set the synthesizer's state. This rebuilds the audio graph.
    synth->setStateInformation(mb.getData(), (int)mb.getSize());

    // 3. Parse the XML to find the UI state.
    juce::ValueTree uiState;
    if (auto xml = juce::XmlDocument::parse(mb.toString()))
    {
        auto vt = juce::ValueTree::fromXml(*xml);
        uiState = vt.getChildWithName("NodeEditorUI");
        if (uiState.isValid())
        {
            // 4. Apply the UI state (node positions, muted status, etc.).
            // This queues the changes to be applied on the next frame.
            applyUiValueTree(uiState);
        }
    }

    // 5. Create an undo snapshot for this action.
    Snapshot s;
    synth->getStateInformation(s.synthState);
    s.uiState = uiState.isValid() ? uiState : getUiValueTree();
    undoStack.push_back(std::move(s));
    redoStack.clear();

    // 6. Update the UI status trackers.
    isPatchDirty = false;
    currentPresetFile = file.getFileName();
    
    juce::Logger::writeToLog("[Preset] Successfully loaded preset: " + file.getFullPathName());
}

void ImGuiNodeEditorComponent::mergePresetFromFile(const juce::File& file, ImVec2 dropPosition)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    auto xml = juce::XmlDocument::parse(file);
    if (xml == nullptr) return;

    juce::ValueTree preset = juce::ValueTree::fromXml(*xml);
    auto modulesVT = preset.getChildWithName("modules");
    auto connectionsVT = preset.getChildWithName("connections");
    auto uiVT = preset.getChildWithName("NodeEditorUI");

    if (!modulesVT.isValid()) return;

    pushSnapshot(); // Create an undo state before we start merging.

    // --- THIS IS THE NEW LOGIC ---
    // 1. Find the top-most Y coordinate of all existing nodes on the canvas.
    float topMostY = FLT_MAX;
    auto currentUiState = getUiValueTree();
    bool canvasHasNodes = false;
    for (int i = 0; i < currentUiState.getNumChildren(); ++i)
    {
        auto nodePosVT = currentUiState.getChild(i);
        if (nodePosVT.hasType("node"))
        {
            canvasHasNodes = true;
            float y = (float)nodePosVT.getProperty("y");
            if (y < topMostY)
            {
                topMostY = y;
            }
        }
    }
    // If the canvas is empty, use the drop position as the reference.
    if (!canvasHasNodes)
    {
        topMostY = dropPosition.y;
    }

    // 2. Find the bounding box of the nodes within the preset we are dropping.
    float presetMinX = FLT_MAX;
    float presetMaxY = -FLT_MAX;
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                float x = (float)nodePosVT.getProperty("x");
                float y = (float)nodePosVT.getProperty("y");
                if (x < presetMinX) presetMinX = x;
                if (y > presetMaxY) presetMaxY = y; // We need the lowest point (max Y) of the preset group.
            }
        }
    }
    
    // 3. Calculate the necessary offsets.
    const float verticalPadding = 100.0f;
    const float yOffset = topMostY - presetMaxY - verticalPadding;
    const float xOffset = dropPosition.x - presetMinX;
    // --- END OF NEW LOGIC ---

    // This map will track how we remap old IDs from the file to new, unique IDs on the canvas.
    std::map<juce::uint32, juce::uint32> oldIdToNewId;

    // First pass: create all the new modules from the preset.
    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleNode = modulesVT.getChild(i);
        if (moduleNode.hasType("module"))
        {
            juce::uint32 oldLogicalId = (juce::uint32)(int)moduleNode.getProperty("logicalId");
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Add the module without committing the graph changes yet.
            auto newNodeId = synth->addModule(type, false);
            juce::uint32 newLogicalId = synth->getLogicalIdForNode(newNodeId);

            oldIdToNewId[oldLogicalId] = newLogicalId; // Store the mapping

            // Restore the new module's parameters and extra state.
            if (auto* proc = synth->getModuleForLogical(newLogicalId))
            {
                auto paramsWrapper = moduleNode.getChildWithName("params");
                if (paramsWrapper.isValid()) proc->getAPVTS().replaceState(paramsWrapper.getChild(0));
                
                auto extraWrapper = moduleNode.getChildWithName("extra");
                if (extraWrapper.isValid()) proc->setExtraStateTree(extraWrapper.getChild(0));
            }
        }
    }

    // Second pass: recreate the internal connections between the new modules.
    if (connectionsVT.isValid())
    {
        for (int i = 0; i < connectionsVT.getNumChildren(); ++i)
        {
            auto connNode = connectionsVT.getChild(i);
            if (connNode.hasType("connection"))
            {
                juce::uint32 oldSrcId = (juce::uint32)(int)connNode.getProperty("srcId");
                int srcChan = (int)connNode.getProperty("srcChan");
                juce::uint32 oldDstId = (juce::uint32)(int)connNode.getProperty("dstId");
                int dstChan = (int)connNode.getProperty("dstChan");

                // Only connect if both source and destination are part of the preset we're merging.
                if (oldIdToNewId.count(oldSrcId) && oldIdToNewId.count(oldDstId))
                {
                    auto newSrcNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldSrcId]);
                    auto newDstNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldDstId]);
                    synth->connect(newSrcNodeId, srcChan, newDstNodeId, dstChan);
                }
            }
        }
    }
    
    // Third pass: Apply UI positions using our new calculated offsets.
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                juce::uint32 oldId = (juce::uint32)(int)nodePosVT.getProperty("id");
                if (oldIdToNewId.count(oldId)) // Check if it's one of our new nodes
                {
                    ImVec2 pos = ImVec2((float)nodePosVT.getProperty("x"), (float)nodePosVT.getProperty("y"));
                    
                    // Apply the smart offsets
                    ImVec2 newPos = ImVec2(pos.x + xOffset, pos.y + yOffset);
                    
                    pendingNodeScreenPositions[(int)oldIdToNewId[oldId]] = newPos;
                }
            }
        }
    }

    // Finally, commit all the changes to the audio graph at once.
    synth->commitChanges();
    isPatchDirty = true; // Mark the patch as edited.
    
    juce::Logger::writeToLog("[Preset] Successfully merged preset: " + file.getFullPathName() + 
                             " above existing nodes with offsets (" + juce::String(xOffset) + ", " + juce::String(yOffset) + ")");
}




================================================================================
FILE: juce\Source\preset_creator\PinDatabase.h
================================================================================


#pragma once

#include "../audio/modules/ModuleProcessor.h"
#include <map>

// Getter functions that return references to static local variables
// This ensures safe initialization after JUCE is ready (construct on first use idiom)

// Returns the pin database for all module types
inline std::map<juce::String, ModulePinInfo>& getModulePinDatabase()
{
    // By declaring the map as static inside a function, we ensure it's
    // initialized safely on its first use, after JUCE is ready.
    static std::map<juce::String, ModulePinInfo> modulePinDatabase;
    return modulePinDatabase;
}

// Returns the module descriptions database
inline std::map<juce::String, const char*>& getModuleDescriptions()
{
    static std::map<juce::String, const char*> moduleDescriptions;
    return moduleDescriptions;
}

// Function to populate both databases - must be called before first use
void populatePinDatabase();



================================================================================
FILE: juce\Source\preset_creator\PinDatabase.cpp
================================================================================


#include "PinDatabase.h"
#include "ImGuiNodeEditorComponent.h" // For NodeWidth enum

// Module Descriptions - populated on first use
void populateModuleDescriptions()
{
    auto& descriptions = getModuleDescriptions();
    if (!descriptions.empty()) return; // Only run once
    
    // Sources
    descriptions["audio_input"] = "Brings hardware audio into the patch.";
    descriptions["VCO"] = "A standard Voltage-Controlled Oscillator.";
    descriptions["polyvco"] = "A multi-voice oscillator bank for polyphony.";
    descriptions["Noise"] = "Generates white, pink, or brown noise.";
    descriptions["Sequencer"] = "A classic 16-step CV and Gate sequencer.";
    descriptions["multi sequencer"] = "Advanced sequencer with parallel per-step outputs.";
    descriptions["midi player"] = "Plays MIDI files and outputs CV/Gate for each track.";
    descriptions["midi cv"] = "Converts MIDI Note/CC messages to CV signals. (Monophonic)";
    descriptions["midi control center"] = "A powerful MIDI learn interface to map any MIDI CC to CV/Gate outputs.";
    descriptions["midi faders"] = "1-16 MIDI-learnable faders with customizable output ranges.";
    descriptions["midi knobs"] = "1-16 MIDI-learnable knobs with customizable output ranges.";
    descriptions["midi buttons"] = "1-32 MIDI-learnable buttons with Gate/Toggle/Trigger modes.";
    descriptions["midi jog wheel"] = "A single MIDI-learnable jog wheel control for expressive modulation.";
    descriptions["Value"] = "Outputs a constant, adjustable numerical value.";
    descriptions["sample_loader"] = "Loads and plays audio samples with pitch/time control.";
    descriptions["best_practice"] = "A template and example node demonstrating best practices.";
    // TTS Family
    descriptions["TTS Performer"] = "Advanced Text-to-Speech engine with word-level sequencing.";
    descriptions["Vocal Tract Filter"] = "A formant filter that simulates human vowel sounds.";
    // Effects
    descriptions["VCF"] = "A Voltage-Controlled Filter (LP, HP, BP).";
    descriptions["Delay"] = "A stereo delay effect with modulation.";
    descriptions["Reverb"] = "A stereo reverb effect.";
    descriptions["chorus"] = "A stereo chorus effect.";
    descriptions["phaser"] = "A stereo phaser effect.";
    descriptions["compressor"] = "Reduces the dynamic range of a signal.";
    descriptions["limiter"] = "Prevents a signal from exceeding a set level.";
    descriptions["gate"] = "A stereo noise gate to silence signals below a threshold.";
    descriptions["drive"] = "A waveshaping distortion effect.";
    descriptions["graphic_eq"] = "An 8-band graphic equalizer.";
    descriptions["frequency_graph"] = "A high-resolution, real-time spectrum analyzer.";
    descriptions["Waveshaper"] = "A distortion effect with multiple shaping algorithms.";
    descriptions["8bandshaper"] = "A multi-band waveshaper for frequency-specific distortion.";
    descriptions["Granulator"] = "A granular synthesizer/effect that plays small grains of a sample.";
    descriptions["harmonic shaper"] = "Shapes the harmonic content of a signal.";
    descriptions["timepitch"] = "Real-time pitch and time manipulation using RubberBand.";
    descriptions["De-Crackle"] = "A utility to reduce clicks from discontinuous signals.";
    descriptions["recorder"] = "Records incoming audio to a WAV, AIFF, or FLAC file.";
    descriptions["tempo_clock"] = "Global clock generator with BPM control, transport, and clock outputs.";
    // Modulators
    descriptions["LFO"] = "A Low-Frequency Oscillator for modulation.";
    descriptions["ADSR"] = "An Attack-Decay-Sustain-Release envelope generator.";
    descriptions["Random"] = "A random value generator with internal sample & hold.";
    descriptions["S&H"] = "A classic Sample and Hold module.";
    descriptions["function_generator"] = "A complex, drawable envelope/LFO generator.";
    descriptions["shaping_oscillator"] = "An oscillator with a built-in waveshaper.";
    // Utilities & Logic
    descriptions["VCA"] = "A Voltage-Controlled Amplifier to control signal level.";
    descriptions["Mixer"] = "A stereo audio mixer with crossfading and panning.";
    descriptions["cv mixer"] = "A mixer specifically for control voltage signals.";
    descriptions["trackmixer"] = "A multi-channel mixer for polyphonic sources.";
    descriptions["Attenuverter"] = "Attenuates (reduces) and/or inverts signals.";
    descriptions["Lag Processor"] = "Smooths out abrupt changes in a signal (slew limiter).";
    descriptions["Math"] = "Performs mathematical operations on signals.";
    descriptions["MapRange"] = "Remaps a signal from one numerical range to another.";
    descriptions["Quantizer"] = "Snaps a continuous signal to a musical scale.";
    descriptions["Rate"] = "Converts a control signal into a normalized rate value.";
    descriptions["Comparator"] = "Outputs a high signal if an input is above a threshold.";
    descriptions["Logic"] = "Performs boolean logic (AND, OR, XOR, NOT) on gate signals.";
    descriptions["ClockDivider"] = "Divides and multiplies clock signals.";
    descriptions["SequentialSwitch"] = "A signal router with multiple thresholds.";
    // Analysis
    descriptions["Scope"] = "Visualizes an audio or CV signal.";
    descriptions["debug"] = "A tool for logging signal value changes.";
    descriptions["input_debug"] = "A passthrough version of the Debug node for inspecting signals on a cable.";
    
    // Add aliases for underscore naming conventions
    descriptions["clock_divider"] = descriptions["ClockDivider"];
    descriptions["sequential_switch"] = descriptions["SequentialSwitch"];
    descriptions["s_and_h"] = descriptions["S&H"];
    descriptions["snapshot_sequencer"] = "A sequencer that stores and recalls complete patch states.";
}

void populatePinDatabase()
{
    // Populate both databases
    populateModuleDescriptions();
    
    auto& db = getModulePinDatabase();
    if (!db.empty()) return; // Only run once

    // --- Sources ---
    db["audio_input"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Out 1", 0, PinDataType::Audio), AudioPin("Out 2", 1, PinDataType::Audio),
          AudioPin("Gate", 16, PinDataType::Gate), AudioPin("Trigger", 17, PinDataType::Gate), AudioPin("EOP", 18, PinDataType::Gate) },
        {}
    );
    db["vco"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Frequency", 0, PinDataType::CV), AudioPin("Waveform", 1, PinDataType::CV), AudioPin("Gate", 2, PinDataType::Gate) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    db["noise"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Level Mod", 0, PinDataType::CV), AudioPin("Colour Mod", 1, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) }, // Stereo output to match actual implementation
        {}
    );
    db["value"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Raw", 0, PinDataType::Raw), AudioPin("Normalized", 1, PinDataType::CV), AudioPin("Inverted", 2, PinDataType::Raw),
          AudioPin("Integer", 3, PinDataType::Raw), AudioPin("CV Out", 4, PinDataType::CV) },
        {}
    );
    db["sample_loader"] = ModulePinInfo(
        NodeWidth::Big,
        { AudioPin("Pitch Mod", 0, PinDataType::CV), AudioPin("Speed Mod", 1, PinDataType::CV), AudioPin("Gate Mod", 2, PinDataType::CV),
          AudioPin("Trigger Mod", 3, PinDataType::Gate), AudioPin("Range Start Mod", 4, PinDataType::CV), AudioPin("Range End Mod", 5, PinDataType::CV),
          AudioPin("Randomize Trig", 6, PinDataType::Gate) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // --- Effects ---
    db["vcf"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Cutoff Mod", 2, PinDataType::CV),
          AudioPin("Resonance Mod", 3, PinDataType::CV), AudioPin("Type Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["delay"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Time Mod", 2, PinDataType::CV),
          AudioPin("Feedback Mod", 3, PinDataType::CV), AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["reverb"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Size Mod", 2, PinDataType::CV),
          AudioPin("Damp Mod", 3, PinDataType::CV), AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["compressor"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Thresh Mod", 2, PinDataType::CV),
          AudioPin("Ratio Mod", 3, PinDataType::CV), AudioPin("Attack Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV),
          AudioPin("Makeup Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // --- Modulators ---
    db["lfo"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Rate Mod", 0, PinDataType::CV), AudioPin("Depth Mod", 1, PinDataType::CV), AudioPin("Wave Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );
    db["adsr"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Gate In", 0, PinDataType::Gate), AudioPin("Trigger In", 1, PinDataType::Gate), AudioPin("Attack Mod", 2, PinDataType::CV),
          AudioPin("Decay Mod", 3, PinDataType::CV), AudioPin("Sustain Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV) },
        { AudioPin("Env Out", 0, PinDataType::CV), AudioPin("Inv Out", 1, PinDataType::CV), AudioPin("EOR Gate", 2, PinDataType::Gate),
          AudioPin("EOC Gate", 3, PinDataType::Gate) },
        {}
    );
    db["random"] = ModulePinInfo(
        NodeWidth::Small,
        {}, // No inputs - self-contained random generator
        { AudioPin("Norm Out", 0, PinDataType::CV), AudioPin("Raw Out", 1, PinDataType::Raw), AudioPin("CV Out", 2, PinDataType::CV),
          AudioPin("Bool Out", 3, PinDataType::Gate), AudioPin("Trig Out", 4, PinDataType::Gate) },
        {}
    );

    // --- Utilities ---
    db["vca"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Gain Mod", 2, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["mixer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A L", 0, PinDataType::Audio), AudioPin("In A R", 1, PinDataType::Audio), AudioPin("In B L", 2, PinDataType::Audio),
          AudioPin("In B R", 3, PinDataType::Audio), AudioPin("Gain Mod", 4, PinDataType::CV), AudioPin("Pan Mod", 5, PinDataType::CV),
          AudioPin("X-Fade Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["scope"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In", 0, PinDataType::Audio) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    db["graphic_eq"] = ModulePinInfo(
        NodeWidth::Big,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Band 1 Mod", 2, PinDataType::CV), AudioPin("Band 2 Mod", 3, PinDataType::CV),
          AudioPin("Band 3 Mod", 4, PinDataType::CV), AudioPin("Band 4 Mod", 5, PinDataType::CV),
          AudioPin("Band 5 Mod", 6, PinDataType::CV), AudioPin("Band 6 Mod", 7, PinDataType::CV),
          AudioPin("Band 7 Mod", 8, PinDataType::CV), AudioPin("Band 8 Mod", 9, PinDataType::CV),
          AudioPin("Gate Thresh Mod", 10, PinDataType::CV), AudioPin("Trig Thresh Mod", 11, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio),
          AudioPin("Gate Out", 2, PinDataType::Gate), AudioPin("Trig Out", 3, PinDataType::Gate) },
        {}
    );
    db["frequency_graph"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("In", 0, PinDataType::Audio) }, // Mono Audio Input
        { // Outputs: Stereo audio pass-through + 8 Gate/Trigger outputs
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio),
            AudioPin("Sub Gate", 2, PinDataType::Gate),
            AudioPin("Sub Trig", 3, PinDataType::Gate),
            AudioPin("Bass Gate", 4, PinDataType::Gate),
            AudioPin("Bass Trig", 5, PinDataType::Gate),
            AudioPin("Mid Gate", 6, PinDataType::Gate),
            AudioPin("Mid Trig", 7, PinDataType::Gate),
            AudioPin("High Gate", 8, PinDataType::Gate),
            AudioPin("High Trig", 9, PinDataType::Gate)
        },
        {} // No modulation inputs
    );
    db["chorus"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Depth Mod", 3, PinDataType::CV),
          AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["phaser"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Depth Mod", 3, PinDataType::CV),
          AudioPin("Centre Mod", 4, PinDataType::CV), AudioPin("Feedback Mod", 5, PinDataType::CV),
          AudioPin("Mix Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["compressor"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Thresh Mod", 2, PinDataType::CV), AudioPin("Ratio Mod", 3, PinDataType::CV),
          AudioPin("Attack Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV),
          AudioPin("Makeup Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["Recorder"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        {}, // No outputs
        {}
    );
    db["limiter"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Thresh Mod", 2, PinDataType::CV), AudioPin("Release Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["gate"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["drive"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["timepitch"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Speed Mod", 2, PinDataType::CV), AudioPin("Pitch Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["waveshaper"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Drive Mod", 2, PinDataType::CV), AudioPin("Type Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["8bandshaper"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("In L", 0, PinDataType::Audio),
            AudioPin("In R", 1, PinDataType::Audio),
            AudioPin("Drive 1 Mod", 2, PinDataType::CV),
            AudioPin("Drive 2 Mod", 3, PinDataType::CV),
            AudioPin("Drive 3 Mod", 4, PinDataType::CV),
            AudioPin("Drive 4 Mod", 5, PinDataType::CV),
            AudioPin("Drive 5 Mod", 6, PinDataType::CV),
            AudioPin("Drive 6 Mod", 7, PinDataType::CV),
            AudioPin("Drive 7 Mod", 8, PinDataType::CV),
            AudioPin("Drive 8 Mod", 9, PinDataType::CV),
            AudioPin("Gain Mod", 10, PinDataType::CV)
        },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["granulator"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("In L", 0, PinDataType::Audio),
            AudioPin("In R", 1, PinDataType::Audio),
            AudioPin("Trigger In", 2, PinDataType::Gate),
            AudioPin("Density Mod", 3, PinDataType::CV),
            AudioPin("Size Mod", 4, PinDataType::CV),
            AudioPin("Position Mod", 5, PinDataType::CV),
            AudioPin("Pitch Mod", 6, PinDataType::CV),
            AudioPin("Gate Mod", 7, PinDataType::CV)
        },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["mixer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A L", 0, PinDataType::Audio), AudioPin("In A R", 1, PinDataType::Audio), AudioPin("In B L", 2, PinDataType::Audio), AudioPin("In B R", 3, PinDataType::Audio), AudioPin("Gain Mod", 4, PinDataType::CV), AudioPin("Pan Mod", 5, PinDataType::CV), AudioPin("X-Fade Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("Mod In L", 0, PinDataType::Audio), AudioPin("Mod In R", 1, PinDataType::Audio), AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Gate Mod", 3, PinDataType::CV), AudioPin("Steps Mod", 4, PinDataType::CV), AudioPin("Gate Thr Mod", 5, PinDataType::CV),
          // Per-step value mods absolute 6..21 (Step1..Step16)
          AudioPin("Step 1 Mod", 6, PinDataType::CV), AudioPin("Step 2 Mod", 7, PinDataType::CV), AudioPin("Step 3 Mod", 8, PinDataType::CV), AudioPin("Step 4 Mod", 9, PinDataType::CV),
          AudioPin("Step 5 Mod", 10, PinDataType::CV), AudioPin("Step 6 Mod", 11, PinDataType::CV), AudioPin("Step 7 Mod", 12, PinDataType::CV), AudioPin("Step 8 Mod", 13, PinDataType::CV),
          AudioPin("Step 9 Mod", 14, PinDataType::CV), AudioPin("Step 10 Mod", 15, PinDataType::CV), AudioPin("Step 11 Mod", 16, PinDataType::CV), AudioPin("Step 12 Mod", 17, PinDataType::CV),
          AudioPin("Step 13 Mod", 18, PinDataType::CV), AudioPin("Step 14 Mod", 19, PinDataType::CV), AudioPin("Step 15 Mod", 20, PinDataType::CV), AudioPin("Step 16 Mod", 21, PinDataType::CV),
          // Per-step trig mods absolute 22..37 (Step1..Step16) — these are Gates
          AudioPin("Step 1 Trig Mod", 22, PinDataType::Gate), AudioPin("Step 2 Trig Mod", 23, PinDataType::Gate), AudioPin("Step 3 Trig Mod", 24, PinDataType::Gate), AudioPin("Step 4 Trig Mod", 25, PinDataType::Gate),
          AudioPin("Step 5 Trig Mod", 26, PinDataType::Gate), AudioPin("Step 6 Trig Mod", 27, PinDataType::Gate), AudioPin("Step 7 Trig Mod", 28, PinDataType::Gate), AudioPin("Step 8 Trig Mod", 29, PinDataType::Gate),
          AudioPin("Step 9 Trig Mod", 30, PinDataType::Gate), AudioPin("Step 10 Trig Mod", 31, PinDataType::Gate), AudioPin("Step 11 Trig Mod", 32, PinDataType::Gate), AudioPin("Step 12 Trig Mod", 33, PinDataType::Gate),
          AudioPin("Step 13 Trig Mod", 34, PinDataType::Gate), AudioPin("Step 14 Trig Mod", 35, PinDataType::Gate), AudioPin("Step 15 Trig Mod", 36, PinDataType::Gate), AudioPin("Step 16 Trig Mod", 37, PinDataType::Gate),
          // Per-step gate level mods absolute 38..53
          AudioPin("Step 1 Gate Mod", 38, PinDataType::CV), AudioPin("Step 2 Gate Mod", 39, PinDataType::CV), AudioPin("Step 3 Gate Mod", 40, PinDataType::CV), AudioPin("Step 4 Gate Mod", 41, PinDataType::CV),
          AudioPin("Step 5 Gate Mod", 42, PinDataType::CV), AudioPin("Step 6 Gate Mod", 43, PinDataType::CV), AudioPin("Step 7 Gate Mod", 44, PinDataType::CV), AudioPin("Step 8 Gate Mod", 45, PinDataType::CV),
          AudioPin("Step 9 Gate Mod", 46, PinDataType::CV), AudioPin("Step 10 Gate Mod", 47, PinDataType::CV), AudioPin("Step 11 Gate Mod", 48, PinDataType::CV), AudioPin("Step 12 Gate Mod", 49, PinDataType::CV),
          AudioPin("Step 13 Gate Mod", 50, PinDataType::CV), AudioPin("Step 14 Gate Mod", 51, PinDataType::CV), AudioPin("Step 15 Gate Mod", 52, PinDataType::CV), AudioPin("Step 16 Gate Mod", 53, PinDataType::CV) },
        { AudioPin("Pitch", 0, PinDataType::CV), AudioPin("Gate", 1, PinDataType::Gate), AudioPin("Gate Nuanced", 2, PinDataType::CV), AudioPin("Velocity", 3, PinDataType::CV), AudioPin("Mod", 4, PinDataType::CV), AudioPin("Trigger", 5, PinDataType::Gate) },
        {}
    );

    db["value"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Raw", 0, PinDataType::Raw), AudioPin("Normalized", 1, PinDataType::CV), AudioPin("Inverted", 2, PinDataType::Raw), AudioPin("Integer", 3, PinDataType::Raw), AudioPin("CV Out", 4, PinDataType::CV) },
        {}
    );

db["random"] = ModulePinInfo(
    NodeWidth::Small,
    {}, // No inputs - self-contained random generator
    { 
        AudioPin("Norm Out", 0, PinDataType::CV), 
        AudioPin("Raw Out", 1, PinDataType::Raw), 
        AudioPin("CV Out", 2, PinDataType::CV),
        AudioPin("Bool Out", 3, PinDataType::Gate), 
        AudioPin("Trig Out", 4, PinDataType::Gate) 
    },
    {} // No modulation inputs
);

    db["tts performer"] = ModulePinInfo(
        NodeWidth::Big,
        { // Inputs (absolute channels based on bus structure)
            AudioPin("Rate Mod", 0, PinDataType::CV),
            AudioPin("Gate Mod", 1, PinDataType::CV),
            AudioPin("Trigger", 2, PinDataType::Gate),
            AudioPin("Reset", 3, PinDataType::Gate),
            AudioPin("Randomize Trig", 4, PinDataType::Gate),
            AudioPin("Trim Start Mod", 5, PinDataType::CV),
            AudioPin("Trim End Mod", 6, PinDataType::CV),
            AudioPin("Speed Mod", 7, PinDataType::CV),
            AudioPin("Pitch Mod", 8, PinDataType::CV),
            // Word Triggers (Channels 9-24)
            AudioPin("Word 1 Trig", 9, PinDataType::Gate), AudioPin("Word 2 Trig", 10, PinDataType::Gate),
            AudioPin("Word 3 Trig", 11, PinDataType::Gate), AudioPin("Word 4 Trig", 12, PinDataType::Gate),
            AudioPin("Word 5 Trig", 13, PinDataType::Gate), AudioPin("Word 6 Trig", 14, PinDataType::Gate),
            AudioPin("Word 7 Trig", 15, PinDataType::Gate), AudioPin("Word 8 Trig", 16, PinDataType::Gate),
            AudioPin("Word 9 Trig", 17, PinDataType::Gate), AudioPin("Word 10 Trig", 18, PinDataType::Gate),
            AudioPin("Word 11 Trig", 19, PinDataType::Gate), AudioPin("Word 12 Trig", 20, PinDataType::Gate),
            AudioPin("Word 13 Trig", 21, PinDataType::Gate), AudioPin("Word 14 Trig", 22, PinDataType::Gate),
            AudioPin("Word 15 Trig", 23, PinDataType::Gate), AudioPin("Word 16 Trig", 24, PinDataType::Gate)
        },
        { // Outputs
            AudioPin("Audio", 0, PinDataType::Audio),
            AudioPin("Word Gate", 1, PinDataType::Gate),
            AudioPin("EOP Gate", 2, PinDataType::Gate),
            // Per-Word Gates (Channels 3-18)
            AudioPin("Word 1 Gate", 3, PinDataType::Gate), AudioPin("Word 2 Gate", 4, PinDataType::Gate),
            AudioPin("Word 3 Gate", 5, PinDataType::Gate), AudioPin("Word 4 Gate", 6, PinDataType::Gate),
            AudioPin("Word 5 Gate", 7, PinDataType::Gate), AudioPin("Word 6 Gate", 8, PinDataType::Gate),
            AudioPin("Word 7 Gate", 9, PinDataType::Gate), AudioPin("Word 8 Gate", 10, PinDataType::Gate),
            AudioPin("Word 9 Gate", 11, PinDataType::Gate), AudioPin("Word 10 Gate", 12, PinDataType::Gate),
            AudioPin("Word 11 Gate", 13, PinDataType::Gate), AudioPin("Word 12 Gate", 14, PinDataType::Gate),
            AudioPin("Word 13 Gate", 15, PinDataType::Gate), AudioPin("Word 14 Gate", 16, PinDataType::Gate),
            AudioPin("Word 15 Gate", 17, PinDataType::Gate), AudioPin("Word 16 Gate", 18, PinDataType::Gate),
            // Per-Word Triggers (Channels 19-34)
            AudioPin("Word 1 Trig", 19, PinDataType::Gate), AudioPin("Word 2 Trig", 20, PinDataType::Gate),
            AudioPin("Word 3 Trig", 21, PinDataType::Gate), AudioPin("Word 4 Trig", 22, PinDataType::Gate),
            AudioPin("Word 5 Trig", 23, PinDataType::Gate), AudioPin("Word 6 Trig", 24, PinDataType::Gate),
            AudioPin("Word 7 Trig", 25, PinDataType::Gate), AudioPin("Word 8 Trig", 26, PinDataType::Gate),
            AudioPin("Word 9 Trig", 27, PinDataType::Gate), AudioPin("Word 10 Trig", 28, PinDataType::Gate),
            AudioPin("Word 11 Trig", 29, PinDataType::Gate), AudioPin("Word 12 Trig", 30, PinDataType::Gate),
            AudioPin("Word 13 Trig", 31, PinDataType::Gate), AudioPin("Word 14 Trig", 32, PinDataType::Gate),
            AudioPin("Word 15 Trig", 33, PinDataType::Gate), AudioPin("Word 16 Trig", 34, PinDataType::Gate)
        },
        { // Modulation Pins (for UI parameter disabling)
            ModPin("Rate", "rate_mod", PinDataType::CV),
            ModPin("Gate", "gate_mod", PinDataType::CV),
            ModPin("Trim Start", "trimStart_mod", PinDataType::CV),
            ModPin("Trim End", "trimEnd_mod", PinDataType::CV),
            ModPin("Speed", "speed_mod", PinDataType::CV),
            ModPin("Pitch", "pitch_mod", PinDataType::CV)
        }
    );
    db["vocal tract filter"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Audio In", 0, PinDataType::Audio) },
        { AudioPin("Audio Out", 0, PinDataType::Audio) },
        { ModPin("Vowel", "vowelShape", PinDataType::CV), ModPin("Formant", "formantShift", PinDataType::CV), ModPin("Instability", "instability", PinDataType::CV), ModPin("Gain", "formantGain", PinDataType::CV) }
    );
    db["best_practice"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Wave Mod", 3, PinDataType::CV), AudioPin("Drive Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        { ModPin("Frequency", "frequency_mod", PinDataType::CV), ModPin("Waveform", "waveform_mod", PinDataType::CV), ModPin("Drive", "drive_mod", PinDataType::CV) }
    );
    db["shaping_oscillator"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Wave Mod", 3, PinDataType::CV), AudioPin("Drive Mod", 4, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        { ModPin("Frequency", "frequency_mod", PinDataType::CV), ModPin("Waveform", "waveform_mod", PinDataType::CV), ModPin("Drive", "drive_mod", PinDataType::CV) }
    );
    db["harmonic shaper"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Drive Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        { ModPin("Master Frequency", "masterFrequency_mod", PinDataType::CV), ModPin("Master Drive", "masterDrive_mod", PinDataType::CV) }
    );
    db["function_generator"] = ModulePinInfo(
        NodeWidth::Big,
        { 
            AudioPin("Gate In", 0, PinDataType::Gate),
            AudioPin("Trigger In", 1, PinDataType::Gate),
            AudioPin("Sync In", 2, PinDataType::Gate),
            AudioPin("Rate Mod", 3, PinDataType::CV),
            AudioPin("Slew Mod", 4, PinDataType::CV),
            AudioPin("Gate Thresh Mod", 5, PinDataType::CV),
            AudioPin("Trig Thresh Mod", 6, PinDataType::CV),
            AudioPin("Pitch Base Mod", 7, PinDataType::CV),
            AudioPin("Value Mult Mod", 8, PinDataType::CV),
            AudioPin("Curve Select Mod", 9, PinDataType::CV)
        },
        { 
            AudioPin("Value", 0, PinDataType::CV),
            AudioPin("Inverted", 1, PinDataType::CV),
            AudioPin("Bipolar", 2, PinDataType::CV),
            AudioPin("Pitch", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate),
            AudioPin("Trigger", 5, PinDataType::Gate),
            AudioPin("End of Cycle", 6, PinDataType::Gate),
            // New dedicated outputs
            AudioPin("Blue Value", 7, PinDataType::CV),
            AudioPin("Blue Pitch", 8, PinDataType::CV),
            AudioPin("Red Value", 9, PinDataType::CV),
            AudioPin("Red Pitch", 10, PinDataType::CV),
            AudioPin("Green Value", 11, PinDataType::CV),
            AudioPin("Green Pitch", 12, PinDataType::CV)
        },
        { 
            ModPin("Rate", "rate_mod", PinDataType::CV),
            ModPin("Slew", "slew_mod", PinDataType::CV),
            ModPin("Gate Thresh", "gateThresh_mod", PinDataType::CV),
            ModPin("Trig Thresh", "trigThresh_mod", PinDataType::CV),
            ModPin("Pitch Base", "pitchBase_mod", PinDataType::CV),
            ModPin("Value Mult", "valueMult_mod", PinDataType::CV),
            ModPin("Curve Select", "curveSelect_mod", PinDataType::CV)
        }
    );

    db["multi sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { // Inputs: Mod In L, Mod In R, Rate Mod, Gate Mod, Steps Mod, Gate Thr Mod, plus per-step mods and triggers
            AudioPin("Mod In L", 0, PinDataType::Audio), AudioPin("Mod In R", 1, PinDataType::Audio),
            AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Gate Mod", 3, PinDataType::CV),
            AudioPin("Steps Mod", 4, PinDataType::CV), AudioPin("Gate Thr Mod", 5, PinDataType::CV),
            // Per-step mods (channels 6-21)
            AudioPin("Step 1 Mod", 6, PinDataType::CV), AudioPin("Step 2 Mod", 7, PinDataType::CV),
            AudioPin("Step 3 Mod", 8, PinDataType::CV), AudioPin("Step 4 Mod", 9, PinDataType::CV),
            AudioPin("Step 5 Mod", 10, PinDataType::CV), AudioPin("Step 6 Mod", 11, PinDataType::CV),
            AudioPin("Step 7 Mod", 12, PinDataType::CV), AudioPin("Step 8 Mod", 13, PinDataType::CV),
            AudioPin("Step 9 Mod", 14, PinDataType::CV), AudioPin("Step 10 Mod", 15, PinDataType::CV),
            AudioPin("Step 11 Mod", 16, PinDataType::CV), AudioPin("Step 12 Mod", 17, PinDataType::CV),
            AudioPin("Step 13 Mod", 18, PinDataType::CV), AudioPin("Step 14 Mod", 19, PinDataType::CV),
            AudioPin("Step 15 Mod", 20, PinDataType::CV), AudioPin("Step 16 Mod", 21, PinDataType::CV),
            // Per-step trigger mods (channels 22-37)
            AudioPin("Step 1 Trig Mod", 22, PinDataType::Gate), AudioPin("Step 2 Trig Mod", 23, PinDataType::Gate),
            AudioPin("Step 3 Trig Mod", 24, PinDataType::Gate), AudioPin("Step 4 Trig Mod", 25, PinDataType::Gate),
            AudioPin("Step 5 Trig Mod", 26, PinDataType::Gate), AudioPin("Step 6 Trig Mod", 27, PinDataType::Gate),
            AudioPin("Step 7 Trig Mod", 28, PinDataType::Gate), AudioPin("Step 8 Trig Mod", 29, PinDataType::Gate),
            AudioPin("Step 9 Trig Mod", 30, PinDataType::Gate), AudioPin("Step 10 Trig Mod", 31, PinDataType::Gate),
            AudioPin("Step 11 Trig Mod", 32, PinDataType::Gate), AudioPin("Step 12 Trig Mod", 33, PinDataType::Gate),
            AudioPin("Step 13 Trig Mod", 34, PinDataType::Gate), AudioPin("Step 14 Trig Mod", 35, PinDataType::Gate),
            AudioPin("Step 15 Trig Mod", 36, PinDataType::Gate), AudioPin("Step 16 Trig Mod", 37, PinDataType::Gate)
        },
        { // Outputs: Live outputs (0-6) + Parallel step outputs (7+)
            // Live Outputs
            AudioPin("Pitch", 0, PinDataType::CV), AudioPin("Gate", 1, PinDataType::Gate),
            AudioPin("Gate Nuanced", 2, PinDataType::CV), AudioPin("Velocity", 3, PinDataType::CV),
            AudioPin("Mod", 4, PinDataType::CV), AudioPin("Trigger", 5, PinDataType::Gate),
            AudioPin("Num Steps", 6, PinDataType::Raw),
            // Parallel Step Outputs (Corrected Names and Channels, shifted by +1 after Num Steps)
            AudioPin("Pitch 1", 7, PinDataType::CV), AudioPin("Gate 1", 8, PinDataType::Gate), AudioPin("Trig 1", 9, PinDataType::Gate),
            AudioPin("Pitch 2", 10, PinDataType::CV), AudioPin("Gate 2", 11, PinDataType::Gate), AudioPin("Trig 2", 12, PinDataType::Gate),
            AudioPin("Pitch 3", 13, PinDataType::CV), AudioPin("Gate 3", 14, PinDataType::Gate), AudioPin("Trig 3", 15, PinDataType::Gate),
            AudioPin("Pitch 4", 16, PinDataType::CV), AudioPin("Gate 4", 17, PinDataType::Gate), AudioPin("Trig 4", 18, PinDataType::Gate),
            AudioPin("Pitch 5", 19, PinDataType::CV), AudioPin("Gate 5", 20, PinDataType::Gate), AudioPin("Trig 5", 21, PinDataType::Gate),
            AudioPin("Pitch 6", 22, PinDataType::CV), AudioPin("Gate 6", 23, PinDataType::Gate), AudioPin("Trig 6", 24, PinDataType::Gate),
            AudioPin("Pitch 7", 25, PinDataType::CV), AudioPin("Gate 7", 26, PinDataType::Gate), AudioPin("Trig 7", 27, PinDataType::Gate),
            AudioPin("Pitch 8", 28, PinDataType::CV), AudioPin("Gate 8", 29, PinDataType::Gate), AudioPin("Trig 8", 30, PinDataType::Gate),
            AudioPin("Pitch 9", 31, PinDataType::CV), AudioPin("Gate 9", 32, PinDataType::Gate), AudioPin("Trig 9", 33, PinDataType::Gate),
            AudioPin("Pitch 10", 34, PinDataType::CV), AudioPin("Gate 10", 35, PinDataType::Gate), AudioPin("Trig 10", 36, PinDataType::Gate),
            AudioPin("Pitch 11", 37, PinDataType::CV), AudioPin("Gate 11", 38, PinDataType::Gate), AudioPin("Trig 11", 39, PinDataType::Gate),
            AudioPin("Pitch 12", 40, PinDataType::CV), AudioPin("Gate 12", 41, PinDataType::Gate), AudioPin("Trig 12", 42, PinDataType::Gate),
            AudioPin("Pitch 13", 43, PinDataType::CV), AudioPin("Gate 13", 44, PinDataType::Gate), AudioPin("Trig 13", 45, PinDataType::Gate),
            AudioPin("Pitch 14", 46, PinDataType::CV), AudioPin("Gate 14", 47, PinDataType::Gate), AudioPin("Trig 14", 48, PinDataType::Gate),
            AudioPin("Pitch 15", 49, PinDataType::CV), AudioPin("Gate 15", 50, PinDataType::Gate), AudioPin("Trig 15", 51, PinDataType::Gate),
            AudioPin("Pitch 16", 52, PinDataType::CV), AudioPin("Gate 16", 53, PinDataType::Gate), AudioPin("Trig 16", 54, PinDataType::Gate)
        },
        {}
    );
    db["comparator"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In", 0, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Gate) },
        {}
    );

    db["sample_loader"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("Pitch Mod", 0, PinDataType::CV),
            AudioPin("Speed Mod", 1, PinDataType::CV),
            AudioPin("Gate Mod", 2, PinDataType::CV),
            AudioPin("Trigger Mod", 3, PinDataType::Gate),
            AudioPin("Range Start Mod", 4, PinDataType::CV),
            AudioPin("Range End Mod", 5, PinDataType::CV),
            AudioPin("Randomize Trig", 6, PinDataType::Gate)
        },
        {
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    // Track Mixer - first 8 tracks UI definition (mono per track + gain/pan CV) and a Tracks Mod pin
    db["track mixer"] = ModulePinInfo(
        NodeWidth::Big,
        {
            // Mono audio inputs for first 8 tracks (absolute channels 0..7)
            AudioPin("In 1", 0, PinDataType::Audio),
            AudioPin("In 2", 1, PinDataType::Audio),
            AudioPin("In 3", 2, PinDataType::Audio),
            AudioPin("In 4", 3, PinDataType::Audio),
            AudioPin("In 5", 4, PinDataType::Audio),
            AudioPin("In 6", 5, PinDataType::Audio),
            AudioPin("In 7", 6, PinDataType::Audio),
            AudioPin("In 8", 7, PinDataType::Audio),

            // Num Tracks modulation CV at absolute channel 64 (start of Mod bus)
            AudioPin("Num Tracks Mod", 64, PinDataType::Raw),

            // Per-track CV inputs on Mod bus: Gain at 65,67,... Pan at 66,68,...
            AudioPin("Gain 1 Mod", 65, PinDataType::CV),  AudioPin("Pan 1 Mod", 66, PinDataType::CV),
            AudioPin("Gain 2 Mod", 67, PinDataType::CV),  AudioPin("Pan 2 Mod", 68, PinDataType::CV),
            AudioPin("Gain 3 Mod", 69, PinDataType::CV),  AudioPin("Pan 3 Mod", 70, PinDataType::CV),
            AudioPin("Gain 4 Mod", 71, PinDataType::CV),  AudioPin("Pan 4 Mod", 72, PinDataType::CV),
            AudioPin("Gain 5 Mod", 73, PinDataType::CV),  AudioPin("Pan 5 Mod", 74, PinDataType::CV),
            AudioPin("Gain 6 Mod", 75, PinDataType::CV),  AudioPin("Pan 6 Mod", 76, PinDataType::CV),
            AudioPin("Gain 7 Mod", 77, PinDataType::CV),  AudioPin("Pan 7 Mod", 78, PinDataType::CV),
            AudioPin("Gain 8 Mod", 79, PinDataType::CV),  AudioPin("Pan 8 Mod", 80, PinDataType::CV)
        },
        {
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    // Add PolyVCO module - Build the pin lists directly in initializer list
    db["polyvco"] = ModulePinInfo(
        NodeWidth::Big,
        {
            // Num Voices modulation input
            AudioPin("Num Voices Mod", 0, PinDataType::Raw),
            
            // Frequency modulation inputs (channels 1-32)
            AudioPin("Freq 1 Mod", 1, PinDataType::CV), AudioPin("Freq 2 Mod", 2, PinDataType::CV),
            AudioPin("Freq 3 Mod", 3, PinDataType::CV), AudioPin("Freq 4 Mod", 4, PinDataType::CV),
            AudioPin("Freq 5 Mod", 5, PinDataType::CV), AudioPin("Freq 6 Mod", 6, PinDataType::CV),
            AudioPin("Freq 7 Mod", 7, PinDataType::CV), AudioPin("Freq 8 Mod", 8, PinDataType::CV),
            AudioPin("Freq 9 Mod", 9, PinDataType::CV), AudioPin("Freq 10 Mod", 10, PinDataType::CV),
            AudioPin("Freq 11 Mod", 11, PinDataType::CV), AudioPin("Freq 12 Mod", 12, PinDataType::CV),
            AudioPin("Freq 13 Mod", 13, PinDataType::CV), AudioPin("Freq 14 Mod", 14, PinDataType::CV),
            AudioPin("Freq 15 Mod", 15, PinDataType::CV), AudioPin("Freq 16 Mod", 16, PinDataType::CV),
            AudioPin("Freq 17 Mod", 17, PinDataType::CV), AudioPin("Freq 18 Mod", 18, PinDataType::CV),
            AudioPin("Freq 19 Mod", 19, PinDataType::CV), AudioPin("Freq 20 Mod", 20, PinDataType::CV),
            AudioPin("Freq 21 Mod", 21, PinDataType::CV), AudioPin("Freq 22 Mod", 22, PinDataType::CV),
            AudioPin("Freq 23 Mod", 23, PinDataType::CV), AudioPin("Freq 24 Mod", 24, PinDataType::CV),
            AudioPin("Freq 25 Mod", 25, PinDataType::CV), AudioPin("Freq 26 Mod", 26, PinDataType::CV),
            AudioPin("Freq 27 Mod", 27, PinDataType::CV), AudioPin("Freq 28 Mod", 28, PinDataType::CV),
            AudioPin("Freq 29 Mod", 29, PinDataType::CV), AudioPin("Freq 30 Mod", 30, PinDataType::CV),
            AudioPin("Freq 31 Mod", 31, PinDataType::CV), AudioPin("Freq 32 Mod", 32, PinDataType::CV),
            
            // Waveform modulation inputs (channels 33-64)
            AudioPin("Wave 1 Mod", 33, PinDataType::CV), AudioPin("Wave 2 Mod", 34, PinDataType::CV),
            AudioPin("Wave 3 Mod", 35, PinDataType::CV), AudioPin("Wave 4 Mod", 36, PinDataType::CV),
            AudioPin("Wave 5 Mod", 37, PinDataType::CV), AudioPin("Wave 6 Mod", 38, PinDataType::CV),
            AudioPin("Wave 7 Mod", 39, PinDataType::CV), AudioPin("Wave 8 Mod", 40, PinDataType::CV),
            AudioPin("Wave 9 Mod", 41, PinDataType::CV), AudioPin("Wave 10 Mod", 42, PinDataType::CV),
            AudioPin("Wave 11 Mod", 43, PinDataType::CV), AudioPin("Wave 12 Mod", 44, PinDataType::CV),
            AudioPin("Wave 13 Mod", 45, PinDataType::CV), AudioPin("Wave 14 Mod", 46, PinDataType::CV),
            AudioPin("Wave 15 Mod", 47, PinDataType::CV), AudioPin("Wave 16 Mod", 48, PinDataType::CV),
            AudioPin("Wave 17 Mod", 49, PinDataType::CV), AudioPin("Wave 18 Mod", 50, PinDataType::CV),
            AudioPin("Wave 19 Mod", 51, PinDataType::CV), AudioPin("Wave 20 Mod", 52, PinDataType::CV),
            AudioPin("Wave 21 Mod", 53, PinDataType::CV), AudioPin("Wave 22 Mod", 54, PinDataType::CV),
            AudioPin("Wave 23 Mod", 55, PinDataType::CV), AudioPin("Wave 24 Mod", 56, PinDataType::CV),
            AudioPin("Wave 25 Mod", 57, PinDataType::CV), AudioPin("Wave 26 Mod", 58, PinDataType::CV),
            AudioPin("Wave 27 Mod", 59, PinDataType::CV), AudioPin("Wave 28 Mod", 60, PinDataType::CV),
            AudioPin("Wave 29 Mod", 61, PinDataType::CV), AudioPin("Wave 30 Mod", 62, PinDataType::CV),
            AudioPin("Wave 31 Mod", 63, PinDataType::CV), AudioPin("Wave 32 Mod", 64, PinDataType::CV),
            
            // Gate modulation inputs (channels 65-96)
            AudioPin("Gate 1 Mod", 65, PinDataType::Gate), AudioPin("Gate 2 Mod", 66, PinDataType::Gate),
            AudioPin("Gate 3 Mod", 67, PinDataType::Gate), AudioPin("Gate 4 Mod", 68, PinDataType::Gate),
            AudioPin("Gate 5 Mod", 69, PinDataType::Gate), AudioPin("Gate 6 Mod", 70, PinDataType::Gate),
            AudioPin("Gate 7 Mod", 71, PinDataType::Gate), AudioPin("Gate 8 Mod", 72, PinDataType::Gate),
            AudioPin("Gate 9 Mod", 73, PinDataType::Gate), AudioPin("Gate 10 Mod", 74, PinDataType::Gate),
            AudioPin("Gate 11 Mod", 75, PinDataType::Gate), AudioPin("Gate 12 Mod", 76, PinDataType::Gate),
            AudioPin("Gate 13 Mod", 77, PinDataType::Gate), AudioPin("Gate 14 Mod", 78, PinDataType::Gate),
            AudioPin("Gate 15 Mod", 79, PinDataType::Gate), AudioPin("Gate 16 Mod", 80, PinDataType::Gate),
            AudioPin("Gate 17 Mod", 81, PinDataType::Gate), AudioPin("Gate 18 Mod", 82, PinDataType::Gate),
            AudioPin("Gate 19 Mod", 83, PinDataType::Gate), AudioPin("Gate 20 Mod", 84, PinDataType::Gate),
            AudioPin("Gate 21 Mod", 85, PinDataType::Gate), AudioPin("Gate 22 Mod", 86, PinDataType::Gate),
            AudioPin("Gate 23 Mod", 87, PinDataType::Gate), AudioPin("Gate 24 Mod", 88, PinDataType::Gate),
            AudioPin("Gate 25 Mod", 89, PinDataType::Gate), AudioPin("Gate 26 Mod", 90, PinDataType::Gate),
            AudioPin("Gate 27 Mod", 91, PinDataType::Gate), AudioPin("Gate 28 Mod", 92, PinDataType::Gate),
            AudioPin("Gate 29 Mod", 93, PinDataType::Gate), AudioPin("Gate 30 Mod", 94, PinDataType::Gate),
            AudioPin("Gate 31 Mod", 95, PinDataType::Gate), AudioPin("Gate 32 Mod", 96, PinDataType::Gate)
        },
        {
            // Audio outputs (channels 0-31)
            AudioPin("Out 1", 0, PinDataType::Audio), AudioPin("Out 2", 1, PinDataType::Audio),
            AudioPin("Out 3", 2, PinDataType::Audio), AudioPin("Out 4", 3, PinDataType::Audio),
            AudioPin("Out 5", 4, PinDataType::Audio), AudioPin("Out 6", 5, PinDataType::Audio),
            AudioPin("Out 7", 6, PinDataType::Audio), AudioPin("Out 8", 7, PinDataType::Audio),
            AudioPin("Out 9", 8, PinDataType::Audio), AudioPin("Out 10", 9, PinDataType::Audio),
            AudioPin("Out 11", 10, PinDataType::Audio), AudioPin("Out 12", 11, PinDataType::Audio),
            AudioPin("Out 13", 12, PinDataType::Audio), AudioPin("Out 14", 13, PinDataType::Audio),
            AudioPin("Out 15", 14, PinDataType::Audio), AudioPin("Out 16", 15, PinDataType::Audio),
            AudioPin("Out 17", 16, PinDataType::Audio), AudioPin("Out 18", 17, PinDataType::Audio),
            AudioPin("Out 19", 18, PinDataType::Audio), AudioPin("Out 20", 19, PinDataType::Audio),
            AudioPin("Out 21", 20, PinDataType::Audio), AudioPin("Out 22", 21, PinDataType::Audio),
            AudioPin("Out 23", 22, PinDataType::Audio), AudioPin("Out 24", 23, PinDataType::Audio),
            AudioPin("Out 25", 24, PinDataType::Audio), AudioPin("Out 26", 25, PinDataType::Audio),
            AudioPin("Out 27", 26, PinDataType::Audio), AudioPin("Out 28", 27, PinDataType::Audio),
            AudioPin("Out 29", 28, PinDataType::Audio), AudioPin("Out 30", 29, PinDataType::Audio),
            AudioPin("Out 31", 30, PinDataType::Audio), AudioPin("Out 32", 31, PinDataType::Audio)
        },
        {}
    );
    
    // Add missing modules
    db["Quantizer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("CV In", 0, PinDataType::CV), AudioPin("Scale Mod", 1, PinDataType::CV), AudioPin("Root Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );
    
    db["TimePitch"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Audio In", 0, PinDataType::Audio), AudioPin("Speed Mod", 1, PinDataType::CV), AudioPin("Pitch Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    
    // Note: TTS Performer pin database is defined earlier in this function (around line 378)
    // Duplicate entry removed to avoid conflicts

    
    // Add TrackMixer module alias (main definition is "track mixer" above)
    db["trackmixer"] = db["track mixer"];
    
    
    // Add MIDI Player module
    db["midiplayer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        {},
        {},
        {}
    );
    
    // Add converter modules
    db["Attenuverter"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Amount Mod", 2, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    
    // Add lowercase alias for Attenuverter
    db["attenuverter"] = db["Attenuverter"];
    
    // Add Sample & Hold module
    db["s&h"] = ModulePinInfo(
        NodeWidth::Small,
        { 
            AudioPin("Signal In L", 0, PinDataType::Audio),
            AudioPin("Signal In R", 1, PinDataType::Audio),
            AudioPin("Trig In L", 2, PinDataType::Gate),
            AudioPin("Trig In R", 3, PinDataType::Gate),
            AudioPin("Threshold Mod", 4, PinDataType::CV),
            AudioPin("Edge Mod", 5, PinDataType::CV),
            AudioPin("Slew Mod", 6, PinDataType::CV)
        },
        { 
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    db["MapRange"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Raw In", 0, PinDataType::Raw) },
        { AudioPin("CV Out", 0, PinDataType::CV), AudioPin("Audio Out", 1, PinDataType::Audio) },
        { ModPin("Min In", "minIn", PinDataType::Raw), ModPin("Max In", "maxIn", PinDataType::Raw), ModPin("Min Out", "minOut", PinDataType::Raw), ModPin("Max Out", "maxOut", PinDataType::Raw) }
    );
    
    db["Lag Processor"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Signal In", 0, PinDataType::CV), AudioPin("Rise Mod", 1, PinDataType::CV), AudioPin("Fall Mod", 2, PinDataType::CV) },
        { AudioPin("Smoothed Out", 0, PinDataType::CV) },
        {}
    );
    
    db["De-Crackle"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // ADD MISSING MODULES FOR COLOR-CODED CHAINING

    db["Scope"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In", 0, PinDataType::Audio) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );

    db["Logic"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A", 0, PinDataType::Gate), AudioPin("In B", 1, PinDataType::Gate) },
        {
            AudioPin("AND", 0, PinDataType::Gate),
            AudioPin("OR", 1, PinDataType::Gate),
            AudioPin("XOR", 2, PinDataType::Gate),
            AudioPin("NOT A", 3, PinDataType::Gate)
        },
        {}
    );

    db["ClockDivider"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Clock In", 0, PinDataType::Gate), AudioPin("Reset", 1, PinDataType::Gate) },
        {
            AudioPin("/2", 0, PinDataType::Gate), AudioPin("/4", 1, PinDataType::Gate),
            AudioPin("/8", 2, PinDataType::Gate), AudioPin("x2", 3, PinDataType::Gate),
            AudioPin("x3", 4, PinDataType::Gate), AudioPin("x4", 5, PinDataType::Gate)
        },
        {}
    );

    db["Rate"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Rate Mod", 0, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );

    // ADD REMAINING MISSING MODULES FROM CMAKE LISTS

    db["Math"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A", 0, PinDataType::CV), AudioPin("In B", 1, PinDataType::CV) },
        { AudioPin("Add", 0, PinDataType::CV), AudioPin("Subtract", 1, PinDataType::CV),
          AudioPin("Multiply", 2, PinDataType::CV), AudioPin("Divide", 3, PinDataType::CV) },
        {}
    );

    db["SequentialSwitch"] = ModulePinInfo(
        NodeWidth::Small,
        { 
            AudioPin("Gate In", 0, PinDataType::Audio),
            AudioPin("Thresh 1 CV", 1, PinDataType::CV),
            AudioPin("Thresh 2 CV", 2, PinDataType::CV),
            AudioPin("Thresh 3 CV", 3, PinDataType::CV),
            AudioPin("Thresh 4 CV", 4, PinDataType::CV)
        },
        { 
            AudioPin("Out 1", 0, PinDataType::Audio),
            AudioPin("Out 2", 1, PinDataType::Audio),
            AudioPin("Out 3", 2, PinDataType::Audio),
            AudioPin("Out 4", 3, PinDataType::Audio)
        },
        {}
    );

    db["snapshot_sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("Clock", 0, PinDataType::Gate), AudioPin("Reset", 1, PinDataType::Gate) },
        {}, // No audio outputs
        {}
    );

    db["midi cv"] = ModulePinInfo(
        NodeWidth::Medium,
        {}, // No inputs - receives MIDI messages
        {
            AudioPin("Pitch", 0, PinDataType::CV),
            AudioPin("Gate", 1, PinDataType::Gate),
            AudioPin("Velocity", 2, PinDataType::CV),
            AudioPin("Mod Wheel", 3, PinDataType::CV),
            AudioPin("Pitch Bend", 4, PinDataType::CV),
            AudioPin("Aftertouch", 5, PinDataType::CV)
        },
        {}
    );

    // MIDI Family - New Modules with Correct Pin Types
    {
        // MIDI Faders: All outputs are CV (blue)
        db["midi faders"] = ModulePinInfo();
        db["midi faders"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 16; ++i)
            db["midi faders"].audioOuts.emplace_back("Fader " + juce::String(i+1), i, PinDataType::CV);

        // MIDI Knobs: All outputs are CV (blue)
        db["midi knobs"] = ModulePinInfo();
        db["midi knobs"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 16; ++i)
            db["midi knobs"].audioOuts.emplace_back("Knob " + juce::String(i+1), i, PinDataType::CV);

        // MIDI Buttons: All outputs are Gate/Trigger (yellow)
        db["midi buttons"] = ModulePinInfo();
        db["midi buttons"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 32; ++i)
            db["midi buttons"].audioOuts.emplace_back("Button " + juce::String(i+1), i, PinDataType::Gate);

        // MIDI Jog Wheel: Output is CV (blue)
        db["midi jog wheel"] = ModulePinInfo(
            NodeWidth::Small,
            {},
            { AudioPin("Value", 0, PinDataType::CV) },
            {}
        );
    }

    db["Debug"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In", 0, PinDataType::Audio) },
        {}, // No outputs
        {}
    );

    db["InputDebug"] = ModulePinInfo(
        NodeWidth::Small,
        {}, // No inputs
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );

    // Tempo Clock
    db["tempo_clock"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        {
            AudioPin("BPM Mod", 0, PinDataType::CV),
            AudioPin("Tap", 1, PinDataType::Gate),
            AudioPin("Nudge+", 2, PinDataType::Gate),
            AudioPin("Nudge-", 3, PinDataType::Gate),
            AudioPin("Play", 4, PinDataType::Gate),
            AudioPin("Stop", 5, PinDataType::Gate),
            AudioPin("Reset", 6, PinDataType::Gate),
            AudioPin("Swing Mod", 7, PinDataType::CV)
        },
        {
            AudioPin("Clock", 0, PinDataType::Gate),
            AudioPin("Beat Trig", 1, PinDataType::Gate),
            AudioPin("Bar Trig", 2, PinDataType::Gate),
            AudioPin("Beat Gate", 3, PinDataType::Gate),
            AudioPin("Phase", 4, PinDataType::CV),
            AudioPin("BPM CV", 5, PinDataType::CV),
            AudioPin("Downbeat", 6, PinDataType::Gate)
        },
        {
            ModPin("BPM", "bpm_mod", PinDataType::CV),
            ModPin("Tap", "tap_mod", PinDataType::Gate),
            ModPin("Nudge+", "nudge_up_mod", PinDataType::Gate),
            ModPin("Nudge-", "nudge_down_mod", PinDataType::Gate),
            ModPin("Play", "play_mod", PinDataType::Gate),
            ModPin("Stop", "stop_mod", PinDataType::Gate),
            ModPin("Reset", "reset_mod", PinDataType::Gate),
            ModPin("Swing", "swing_mod", PinDataType::CV)
        }
    );

    // Physics Module - Exception size (custom dimensions defined by module)
    db["physics"] = ModulePinInfo(
        NodeWidth::Exception,
        {}, // Dynamic inputs defined by module
        {}, // Dynamic outputs defined by module
        {}
    );

    // Add aliases for nodes with underscore naming convention
    db["clock_divider"] = db["ClockDivider"];
    db["sequential_switch"] = db["SequentialSwitch"];
    db["s_and_h"] = db["s&h"];

}





================================================================================
FILE: juce\Source\preset_creator\PresetManager.h
================================================================================


#pragma once
#include <juce_core/juce_core.h>
#include <vector>
#include <memory>

class PresetManager
{
public:
    struct PresetInfo
    {
        juce::String name;
        juce::File file;
        juce::String description;
        juce::StringArray tags;
    };

    struct DirectoryNode
    {
        juce::String name;
        juce::File directory;
        std::vector<PresetInfo> presets;
        std::vector<std::unique_ptr<DirectoryNode>> subdirectories;
    };

    PresetManager() : rootNode(std::make_unique<DirectoryNode>()) {}

    DirectoryNode* getRootNode() const { return rootNode.get(); }

    void scanDirectory(const juce::File& directory)
    {
        rootNode->name = directory.getFileName();
        rootNode->directory = directory;
        rootNode->presets.clear();
        rootNode->subdirectories.clear();
        scanRecursively(rootNode.get());
    }

    void clearCache()
    {
        rootNode = std::make_unique<DirectoryNode>();
    }

private:
    void scanRecursively(DirectoryNode* node)
    {
        if (!node->directory.isDirectory()) return;

        for (const auto& entry : juce::RangedDirectoryIterator(node->directory, false, "*", juce::File::findFilesAndDirectories))
        {
            const auto& file = entry.getFile();
            if (file.isDirectory())
            {
                auto subdir = std::make_unique<DirectoryNode>();
                subdir->name = file.getFileName();
                subdir->directory = file;
                scanRecursively(subdir.get());
                node->subdirectories.push_back(std::move(subdir));
            }
            else if (file.hasFileExtension(".xml"))
            {
                PresetInfo info;
                info.name = file.getFileNameWithoutExtension();
                info.file = file;
                if (auto xml = juce::parseXML(file))
                {
                    info.description = xml->getStringAttribute("description", "");
                    info.tags = juce::StringArray::fromTokens(xml->getStringAttribute("tags", ""), ",", "");
                }
                node->presets.push_back(info);
            }
        }
    }

    std::unique_ptr<DirectoryNode> rootNode;
};


================================================================================
FILE: juce\Source\preset_creator\PresetManager.cpp
================================================================================


#include "PresetManager.h"

PresetManager::PresetManager()
{
}

void PresetManager::scanDirectory(const juce::File& directory)
{
    if (!directory.exists() || !directory.isDirectory())
        return;
    
    // Find all .xml preset files
    juce::Array<juce::File> presetFiles;
    directory.findChildFiles(presetFiles, juce::File::findFiles, false, "*.xml");
    
    for (const auto& file : presetFiles)
    {
        PresetInfo info = extractMetadata(file);
        m_presets.push_back(info);
    }
    
    juce::Logger::writeToLog("[PresetManager] Scanned " + juce::String(m_presets.size()) + 
                            " presets from: " + directory.getFullPathName());
}

std::vector<PresetManager::PresetInfo> PresetManager::searchPresets(const juce::String& searchTerm) const
{
    std::vector<PresetInfo> results;
    
    for (const auto& preset : m_presets)
    {
        if (preset.matchesSearch(searchTerm))
            results.push_back(preset);
    }
    
    return results;
}

std::vector<PresetManager::PresetInfo> PresetManager::getPresetsByTag(const juce::String& tag) const
{
    std::vector<PresetInfo> results;
    
    for (const auto& preset : m_presets)
    {
        if (preset.tags.contains(tag))
            results.push_back(preset);
    }
    
    return results;
}

juce::StringArray PresetManager::getAllTags() const
{
    juce::StringArray allTags;
    
    for (const auto& preset : m_presets)
    {
        for (const auto& tag : preset.tags)
        {
            if (!allTags.contains(tag))
                allTags.add(tag);
        }
    }
    
    allTags.sort(true);
    return allTags;
}

juce::XmlElement* PresetManager::loadPreset(const juce::File& file)
{
    if (!file.exists())
        return nullptr;
    
    return juce::XmlDocument::parse(file).release();
}

bool PresetManager::savePreset(const juce::File& file, 
                               const juce::XmlElement& presetData,
                               const juce::String& description,
                               const juce::StringArray& tags)
{
    // Create a copy of the preset data and add metadata
    std::unique_ptr<juce::XmlElement> presetCopy(new juce::XmlElement(presetData));
    
    // Add metadata properties to the root element
    if (description.isNotEmpty())
        presetCopy->setAttribute("description", description);
    
    if (!tags.isEmpty())
        presetCopy->setAttribute("tags", tags.joinIntoString(","));
    
    // Write to file
    if (presetCopy->writeTo(file))
    {
        // Update cache
        PresetInfo info = extractMetadata(file);
        
        // Remove old entry if exists
        m_presets.erase(std::remove_if(m_presets.begin(), m_presets.end(),
            [&file](const PresetInfo& p) { return p.file == file; }), m_presets.end());
        
        // Add new entry
        m_presets.push_back(info);
        
        return true;
    }
    
    return false;
}

PresetManager::PresetInfo PresetManager::extractMetadata(const juce::File& file)
{
    PresetInfo info;
    info.file = file;
    info.name = file.getFileNameWithoutExtension();
    info.lastModified = file.getLastModificationTime();
    
    // Parse the XML to extract metadata
    std::unique_ptr<juce::XmlElement> xml = juce::XmlDocument::parse(file);
    
    if (xml != nullptr)
    {
        // Extract description
        info.description = xml->getStringAttribute("description", "");
        
        // Extract tags
        juce::String tagsStr = xml->getStringAttribute("tags", "");
        if (tagsStr.isNotEmpty())
        {
            info.tags.addTokens(tagsStr, ",", "");
            info.tags.trim();
        }
    }
    
    return info;
}



================================================================================
FILE: juce\Source\preset_creator\SampleManager.h
================================================================================


#pragma once
#include <juce_core/juce_core.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <vector>
#include <memory>

class SampleManager
{
public:
    struct SampleInfo
    {
        juce::String name;
        juce::File file;
        double durationSeconds;
        int sampleRate;
        int numChannels;
    };

    struct DirectoryNode
    {
        juce::String name;
        juce::File directory;
        std::vector<SampleInfo> samples;
        std::vector<std::unique_ptr<DirectoryNode>> subdirectories;
    };

    SampleManager() : rootNode(std::make_unique<DirectoryNode>())
    {
        formatManager.registerBasicFormats();
    }

    DirectoryNode* getRootNode() const { return rootNode.get(); }

    void scanDirectory(const juce::File& directory)
    {
        rootNode->name = directory.getFileName();
        rootNode->directory = directory;
        rootNode->samples.clear();
        rootNode->subdirectories.clear();
        scanRecursively(rootNode.get());
    }

    void clearCache()
    {
        rootNode = std::make_unique<DirectoryNode>();
    }

private:
    void scanRecursively(DirectoryNode* node)
    {
        if (!node->directory.isDirectory()) return;

        for (const auto& entry : juce::RangedDirectoryIterator(node->directory, false, "*", juce::File::findFilesAndDirectories))
        {
            const auto& file = entry.getFile();
            if (file.isDirectory())
            {
                auto subdir = std::make_unique<DirectoryNode>();
                subdir->name = file.getFileName();
                subdir->directory = file;
                scanRecursively(subdir.get());
                node->subdirectories.push_back(std::move(subdir));
            }
            else if (file.hasFileExtension(".wav") || file.hasFileExtension(".aif") || file.hasFileExtension(".flac") || file.hasFileExtension(".mp3") || file.hasFileExtension(".ogg"))
            {
                SampleInfo info;
                info.name = file.getFileNameWithoutExtension();
                info.file = file;
                if (auto* reader = formatManager.createReaderFor(file))
                {
                    info.durationSeconds = reader->lengthInSamples / reader->sampleRate;
                    info.sampleRate = (int)reader->sampleRate;
                    info.numChannels = (int)reader->numChannels;
                    delete reader;
                }
                node->samples.push_back(info);
            }
        }
    }
    
    juce::AudioFormatManager formatManager;
    std::unique_ptr<DirectoryNode> rootNode;
};


================================================================================
FILE: juce\Source\preset_creator\SampleManager.cpp
================================================================================


#include "SampleManager.h"

SampleManager::SampleManager()
{
    // Register common audio formats
    m_formatManager.registerBasicFormats();
}

void SampleManager::scanDirectory(const juce::File& directory, bool recursive)
{
    if (!directory.exists() || !directory.isDirectory())
        return;
    
    // Supported audio file extensions
    juce::String wildcardPattern = "*.wav;*.mp3;*.aif;*.aiff;*.flac;*.ogg";
    
    // Find all audio files
    juce::Array<juce::File> audioFiles;
    directory.findChildFiles(audioFiles, 
                             juce::File::findFiles, 
                             recursive, 
                             wildcardPattern);
    
    for (const auto& file : audioFiles)
    {
        SampleInfo info = extractMetadata(file);
        if (info.sampleRate > 0) // Valid audio file
            m_samples.push_back(info);
    }
    
    juce::Logger::writeToLog("[SampleManager] Scanned " + juce::String(m_samples.size()) + 
                            " samples from: " + directory.getFullPathName());
}

std::vector<SampleManager::SampleInfo> SampleManager::searchSamples(const juce::String& searchTerm) const
{
    std::vector<SampleInfo> results;
    
    for (const auto& sample : m_samples)
    {
        if (sample.matchesSearch(searchTerm))
            results.push_back(sample);
    }
    
    return results;
}

SampleManager::SampleInfo SampleManager::extractMetadata(const juce::File& file)
{
    SampleInfo info;
    info.file = file;
    info.name = file.getFileNameWithoutExtension();
    info.lastModified = file.getLastModificationTime();
    
    // Try to read audio file metadata
    std::unique_ptr<juce::AudioFormatReader> reader(m_formatManager.createReaderFor(file));
    
    if (reader != nullptr)
    {
        info.sampleRate = static_cast<int>(reader->sampleRate);
        info.numChannels = static_cast<int>(reader->numChannels);
        info.lengthInSamples = reader->lengthInSamples;
        
        if (info.sampleRate > 0)
            info.durationSeconds = info.lengthInSamples / static_cast<double>(info.sampleRate);
    }
    
    return info;
}



================================================================================
FILE: juce\Source\preset_creator\PresetCreatorApplication.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>

class PresetCreatorApplication : public juce::JUCEApplication
{
public:
    const juce::String getApplicationName() override { return "Preset Creator"; }
    const juce::String getApplicationVersion() override { return "0.1.0"; }
    
    // Accessors for shared components
    juce::AudioDeviceManager& getAudioDeviceManager() { return audioDeviceManager; }
    juce::AudioPluginFormatManager& getPluginFormatManager() { return pluginFormatManager; }
    juce::KnownPluginList& getKnownPluginList() { return knownPluginList; }
    
    // Static getter for global access
    static PresetCreatorApplication& getApp()
    {
        return *dynamic_cast<PresetCreatorApplication*>(juce::JUCEApplication::getInstance());
    }
    
    juce::PropertiesFile* getProperties() { return appProperties.get(); }
    
    void initialise(const juce::String&) override;
    void shutdown() override;

    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow(juce::String name, 
                   juce::AudioDeviceManager& adm,
                   juce::AudioPluginFormatManager& fm,
                   juce::KnownPluginList& kl);
        void closeButtonPressed() override { juce::JUCEApplication::getInstance()->systemRequestedQuit(); }
        
    private:
        juce::AudioDeviceManager& deviceManager;
        juce::AudioPluginFormatManager& pluginFormatManager;
        juce::KnownPluginList& knownPluginList;
    };

private:
    // Shared components for the entire application
    juce::AudioDeviceManager audioDeviceManager;
    juce::AudioPluginFormatManager pluginFormatManager;
    juce::KnownPluginList knownPluginList;
    juce::File pluginScanListFile;
    
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<juce::PropertiesFile> appProperties;
};



================================================================================
FILE: juce\Source\preset_creator\PresetCreatorMain.cpp
================================================================================


#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include "../utils/RtLogger.h"

void PresetCreatorApplication::initialise(const juce::String&)
    {
        DBG("[PresetCreator] initialise() starting"); RtLogger::init();
        // Crash handler to capture unexpected exceptions
        std::set_terminate([]{
            auto bt = juce::SystemStats::getStackBacktrace();
            juce::Logger::writeToLog("[PresetCreator][FATAL] terminate called. Backtrace:\n" + bt);
            std::abort();
        });
        // Set up file logger for diagnostics
        auto logsDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile)
                           .getParentDirectory().getChildFile ("juce").getChildFile ("logs");
        logsDir.createDirectory();
        auto logFile = logsDir.getChildFile ("preset_creator_" + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log");
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 0);
        juce::Logger::setCurrentLogger (fileLogger.get());
        DBG("[PresetCreator] Logger initialised at: " + logFile.getFullPathName());
        juce::Logger::writeToLog("PresetCreatorApplication::initialise called");
        
        // ADD: Load persistent audio settings
        // Define where to store the settings file
        auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                .getChildFile(getApplicationName());
        appDataDir.createDirectory(); // Ensure the directory exists
        auto settingsFile = appDataDir.getChildFile("audio_settings.xml");

        std::unique_ptr<juce::XmlElement> savedState;
        if (settingsFile.existsAsFile())
        {
            savedState = juce::XmlDocument::parse(settingsFile);
            juce::Logger::writeToLog("Loading audio settings from: " + settingsFile.getFullPathName());
        }
        else
        {
            juce::Logger::writeToLog("No saved audio settings found, using defaults");
        }
        
        // Pass the saved state to the device manager.
        // It will automatically use the saved settings or fall back to defaults.
        audioDeviceManager.initialise(2, 2, savedState.get(), true);
        
        // Initialize plugin management
        pluginFormatManager.addDefaultFormats();
        
        // Initialize application properties
        juce::PropertiesFile::Options options;
        options.applicationName = getApplicationName();
        options.filenameSuffix = ".settings";
        options.osxLibrarySubFolder = "Application Support";
        options.folderName = appDataDir.getFullPathName();
        appProperties = std::make_unique<juce::PropertiesFile>(options);
        
        // Define where to save the plugin list XML
        auto deadMansPedalFile = appDataDir.getChildFile("blacklisted_plugins.txt");
        pluginScanListFile = appDataDir.getChildFile("known_plugins.xml");
        
        // Load the list from the XML file
        if (pluginScanListFile.existsAsFile())
        {
            auto pluginListXml = juce::XmlDocument::parse(pluginScanListFile);
            if (pluginListXml != nullptr)
            {
                knownPluginList.recreateFromXml(*pluginListXml);
                juce::Logger::writeToLog("Loaded " + juce::String(knownPluginList.getNumTypes()) + " plugin(s) from cache");
            }
        }
        else
        {
            juce::Logger::writeToLog("No cached plugin list found");
        }
        
        juce::Logger::writeToLog("Attempting to create MainWindow...");
        mainWindow.reset (new MainWindow (getApplicationName(), 
                                         audioDeviceManager,
                                         pluginFormatManager,
                                         knownPluginList));
        juce::Logger::writeToLog("MainWindow created successfully");
}

void PresetCreatorApplication::shutdown()
{ 
        // Save persistent audio settings
        std::unique_ptr<juce::XmlElement> currentState(audioDeviceManager.createStateXml());

        if (currentState != nullptr)
        {
            // Define the same settings file path as in initialise()
            auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                    .getChildFile(getApplicationName());
            auto settingsFile = appDataDir.getChildFile("audio_settings.xml");

            // Write the XML to the file
            if (currentState->writeTo(settingsFile))
            {
                juce::Logger::writeToLog("Audio settings saved to: " + settingsFile.getFullPathName());
            }
            else
            {
                juce::Logger::writeToLog("Failed to save audio settings to: " + settingsFile.getFullPathName());
            }
        }
        
        // Save plugin list
        if (auto pluginListXml = knownPluginList.createXml())
        {
            if (pluginListXml->writeTo(pluginScanListFile))
            {
                juce::Logger::writeToLog("Plugin list saved to: " + pluginScanListFile.getFullPathName());
            }
        }
        
        // Save application properties
        if (appProperties)
            appProperties->saveIfNeeded();
        
        RtLogger::shutdown(); 
        mainWindow = nullptr; 
        juce::Logger::setCurrentLogger (nullptr); 
        fileLogger = nullptr; 
}

PresetCreatorApplication::MainWindow::MainWindow(juce::String name, 
                                                 juce::AudioDeviceManager& adm,
                                                 juce::AudioPluginFormatManager& fm,
                                                 juce::KnownPluginList& kl)
    : DocumentWindow(name,
                     juce::Desktop::getInstance().getDefaultLookAndFeel()
                         .findColour(ResizableWindow::backgroundColourId),
                     DocumentWindow::allButtons),
      deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("MainWindow constructor starting...");
    setUsingNativeTitleBar(true);
    juce::Logger::writeToLog("Attempting to create PresetCreatorComponent...");
    setContentOwned(new PresetCreatorComponent(deviceManager, pluginFormatManager, knownPluginList), true);
    juce::Logger::writeToLog("PresetCreatorComponent created and set.");
    centreWithSize(2600, 1080);
    setVisible(true);
    toFront(true);
    juce::Logger::writeToLog("MainWindow setup complete");
}

START_JUCE_APPLICATION (PresetCreatorApplication)




================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/MidiDeviceManager.h"

class PresetCreatorComponent : public juce::Component,
                               private juce::Button::Listener,
                               private juce::Timer
{
public:
    PresetCreatorComponent(juce::AudioDeviceManager& deviceManager,
                           juce::AudioPluginFormatManager& formatManager,
                           juce::KnownPluginList& knownPluginList);
    ~PresetCreatorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    
    // Unified playback control (audio engine + transport)
    void setMasterPlayState(bool shouldBePlaying);
    
    bool keyPressed (const juce::KeyPress& key) override;
    bool keyStateChanged (bool isKeyDown) override;
    void visibilityChanged() override;

    // ADD: Public function to show audio settings dialog
    void showAudioSettingsDialog();
    
    // Get MIDI activity indicator state
    int getMidiActivityFrames() const { return midiActivityFrames; }
    
    // Multi-MIDI device manager (public for access from ImGuiNodeEditorComponent)
    std::unique_ptr<MidiDeviceManager> midiDeviceManager;

private:
    int midiActivityFrames = 0; // For MIDI activity indicator

    void setWindowFileName(const juce::String& fileName);
    void buttonClicked (juce::Button*) override;
    void timerCallback() override;
    void refreshModulesList();
    void doConnect();
    void doSave();
    void doLoad();
    void startAudition();
    void stopAudition();

    juce::TextButton btnAddVCO { "Add VCO" };
    juce::TextButton btnAddVCF { "Add VCF" };
    juce::TextButton btnAddVCA { "Add VCA" };
    juce::TextButton btnConnect { "Connect" };
    juce::TextButton btnSave { "Save Preset" };
    juce::TextButton btnLoad { "Load Preset" };

    juce::ListBox listModules { "Modules", nullptr };
    struct ModulesModel : public juce::ListBoxModel
    {
        juce::StringArray rows;
        int getNumRows() override { return rows.size(); }
        void paintListBoxItem (int row, juce::Graphics& g, int w, int h, bool sel) override
        {
            g.fillAll (sel ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
            g.setColour (juce::Colours::white);
            if (row >= 0 && row < rows.size()) g.drawText (rows[row], 6, 0, w - 12, h, juce::Justification::centredLeft);
        }
    } modulesModel;

    juce::ComboBox cbSrc, cbDst, cbSrcChan, cbDstChan;
    juce::TextEditor log;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<class ImGuiNodeEditorComponent> editor;

    std::unique_ptr<ModularSynthProcessor> synth;
    double sampleRate { 48000.0 };
    int blockSize { 512 };

    std::unique_ptr<juce::FileChooser> saveChooser;
    std::unique_ptr<juce::FileChooser> loadChooser;

    // Unified spacebar control (toggle and momentary gate mode)
    juce::uint64 spacebarDownTime { 0 };
    bool wasLongPress { false };
    static constexpr int longPressThresholdMs = 250;

    juce::AudioDeviceManager& deviceManager;
    juce::AudioPluginFormatManager& pluginFormatManager;
    juce::KnownPluginList& knownPluginList;
    juce::AudioProcessorPlayer processorPlayer;
    bool auditioning { false };
};




================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.cpp
================================================================================


// RtLogger flush integrated via timer in component
#include "PresetCreatorComponent.h"
#include "ImGuiNodeEditorComponent.h"
#include "../utils/RtLogger.h"

PresetCreatorComponent::PresetCreatorComponent(juce::AudioDeviceManager& adm,
                                               juce::AudioPluginFormatManager& fm,
                                               juce::KnownPluginList& kl)
    : deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("PresetCreatorComponent constructor starting...");
    addAndMakeVisible (log);

    // Replace list/combos UI with ImGui node editor
    juce::Logger::writeToLog("Attempting to create ImGuiNodeEditorComponent...");
    editor.reset (new ImGuiNodeEditorComponent(deviceManager));
    juce::Logger::writeToLog("ImGuiNodeEditorComponent created.");
    editor->onShowAudioSettings = [this]() { this->showAudioSettingsDialog(); };
    addAndMakeVisible (editor.get());
    log.setMultiLine (true); log.setReadOnly (true);

    juce::Logger::writeToLog("Creating ModularSynthProcessor...");
    synth = std::make_unique<ModularSynthProcessor>();
    
    // --- THIS IS THE FIX ---
    // Set the managers immediately so the synth is ready for state restoration.
    synth->setPluginFormatManager(&pluginFormatManager);
    synth->setKnownPluginList(&knownPluginList);
    juce::Logger::writeToLog("Plugin managers set on ModularSynthProcessor.");
    // --- END OF FIX ---
    
    juce::Logger::writeToLog("Setting model on editor...");
    if (editor != nullptr)
        editor->setModel (synth.get());
    synth->prepareToPlay (sampleRate, blockSize);

    // Use the shared AudioDeviceManager settings
    if (auto* dev = deviceManager.getCurrentAudioDevice())
    {
        sampleRate = dev->getCurrentSampleRate();
        blockSize = dev->getCurrentBufferSizeSamples();
        synth->prepareToPlay (sampleRate, blockSize);
        juce::Logger::writeToLog ("Audio device: " + dev->getName() +
                                   ", sr=" + juce::String (sampleRate) +
                                   ", bs=" + juce::String (blockSize));
    }
    // AudioProcessorPlayer lives in juce_audio_utils namespace path include; type is juce::AudioSourcePlayer for routing
    // Use AudioProcessorPlayer via juce_audio_utils module
    processorPlayer.setProcessor (synth.get());
    
    // --- MULTI-MIDI DEVICE SUPPORT ---
    // Initialize multi-device MIDI manager
    midiDeviceManager = std::make_unique<MidiDeviceManager>(deviceManager);
    midiDeviceManager->scanDevices();
    midiDeviceManager->enableAllDevices();  // Enable all MIDI devices by default
    juce::Logger::writeToLog("[MIDI] Multi-device manager initialized");
    // Note: MidiDeviceManager now handles all MIDI input callbacks
    // The processorPlayer will receive MIDI through ModularSynthProcessor's processBlock
    // --- END MULTI-MIDI SUPPORT ---
    
    // === CRITICAL FIX: Audio callback must ALWAYS be active for MIDI processing ===
    // Without this, processBlock never runs and MIDI learn doesn't work!
    deviceManager.addAudioCallback(&processorPlayer);
    auditioning = true;  // Set flag to indicate audio is active
    juce::Logger::writeToLog("[Audio] Audio callback started - synth is now processing");
    // === END FIX ===
    
    setWantsKeyboardFocus (true);

    // Setup FileLogger at the same path the user checks: <exe>/juce/logs/preset_creator_*.log
    {
        auto exeDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory();
        auto juceLogsDir = exeDir.getChildFile ("juce").getChildFile ("logs");
        juceLogsDir.createDirectory();
        auto logName = juce::String ("preset_creator_") + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log";
        auto logFile = juceLogsDir.getChildFile (logName);
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 10 * 1024 * 1024);
        if (fileLogger != nullptr)
            juce::Logger::setCurrentLogger (fileLogger.get());
        juce::Logger::writeToLog ("PresetCreator log file: " + logFile.getFullPathName());
    }
    // Init RT logger and start periodic flush
    RtLogger::init (2048, 256);
    
    // NOTE: Audio Settings button removed - now using menu integration
    
    juce::Logger::writeToLog ("PresetCreator constructed");
    startTimerHz (30);
    
    setWindowFileName({}); // Set the default title on startup
}

// ADD: Implementation of the audio settings dialog function
void PresetCreatorComponent::showAudioSettingsDialog()
{
    auto* component = new juce::AudioDeviceSelectorComponent(
        deviceManager, 0, 256, 0, 256, true, true, false, false);
    
    component->setSize(500, 450);

    juce::DialogWindow::LaunchOptions o;
    o.content.setOwned(component);
    o.dialogTitle                   = "Audio Settings";
    o.dialogBackgroundColour        = juce::Colours::darkgrey;
    o.escapeKeyTriggersCloseButton  = true;
    o.resizable                     = false;
    o.launchAsync();
}

void PresetCreatorComponent::setWindowFileName(const juce::String& fileName)
{
    // Find the parent window of this component
    if (auto* window = findParentComponentOfClass<juce::DocumentWindow>())
    {
        juce::String newTitle = "Preset Creator"; // The default title
        if (fileName.isNotEmpty())
        {
            newTitle += " - " + fileName; // Append the filename if one is provided
        }
        window->setName(newTitle);
    }
}

void PresetCreatorComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void PresetCreatorComponent::resized()
{
    for (auto* c : getChildren())
        if (dynamic_cast<ImGuiNodeEditorComponent*>(c) != nullptr)
            c->setBounds (0, 0, getWidth(), getHeight());
    
    // Audio Settings button removed - now using menu integration
    
    // Keep log overlay minimal for now
    log.setBounds (10, getHeight() - 160, getWidth() - 20, 150);
}

void PresetCreatorComponent::setMasterPlayState(bool shouldBePlaying)
{
    if (synth == nullptr)
        return;

    // 1. Control the Audio Engine (start/stop pulling audio)
    if (shouldBePlaying)
    {
        if (!auditioning)
        {
            deviceManager.addAudioCallback(&processorPlayer);
            auditioning = true;
        }
    }
    else
    {
        if (auditioning)
        {
            deviceManager.removeAudioCallback(&processorPlayer);
            auditioning = false;
        }
    }

    // 2. Control the synth's internal transport clock
    synth->setPlaying(shouldBePlaying);
}

PresetCreatorComponent::~PresetCreatorComponent()
{
    // MULTI-MIDI SUPPORT: MidiDeviceManager handles cleanup automatically in its destructor
    midiDeviceManager.reset();

    stopAudition();
    processorPlayer.setProcessor (nullptr);
    juce::Logger::writeToLog ("PresetCreator destroyed");
    RtLogger::shutdown();
    juce::Logger::setCurrentLogger (nullptr);
}

void PresetCreatorComponent::buttonClicked (juce::Button* b)
{
    if (b == &btnAddVCO) { synth->addModule ("VCO"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCF) { synth->addModule ("VCF"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCA) { synth->addModule ("VCA"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnConnect) { doConnect(); }
    else if (b == &btnSave) { doSave(); }
    else if (b == &btnLoad) { doLoad(); }
}

void PresetCreatorComponent::refreshModulesList()
{
    modulesModel.rows.clear();
    cbSrc.clear(); cbDst.clear();
    int idx = 1;
    for (auto [logicalId, type] : synth->getModulesInfo())
    {
        modulesModel.rows.add (juce::String ((int) logicalId) + " - " + type);
        cbSrc.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        cbDst.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        ++idx;
    }
    cbDst.addItem ("Output", 9999);
    listModules.updateContent();
}

void PresetCreatorComponent::doConnect()
{
    int selSrc = cbSrc.getSelectedId();
    int selDst = cbDst.getSelectedId();
    if (selSrc <= 0 || selDst <= 0) { log.insertTextAtCaret ("Select src/dst first\n"); return; }

    // Extract logical IDs from combo texts
    auto parseId = [] (const juce::String& s) -> juce::uint32 { return (juce::uint32) s.upToFirstOccurrenceOf(" ", false, false).getIntValue(); };
    juce::uint32 srcLogical = parseId (cbSrc.getText());
    juce::uint32 dstLogical = parseId (cbDst.getText());

    auto srcNode = synth->getNodeIdForLogical (srcLogical);
    juce::AudioProcessorGraph::NodeID dstNode;
    if (cbDst.getSelectedId() == 9999)
        dstNode = synth->getOutputNodeID();
    else
        dstNode = synth->getNodeIdForLogical (dstLogical);
    const int srcChan = cbSrcChan.getSelectedId() - 1;
    const int dstChan = cbDstChan.getSelectedId() - 1;
    if (srcNode.uid != 0 && dstNode.uid != 0)
    {
        if (synth->connect (srcNode, srcChan, dstNode, dstChan))
        {
            log.insertTextAtCaret ("Connected\n");
            synth->commitChanges();
        }
        else
        {
            log.insertTextAtCaret ("Connect failed\n");
        }
    }
}

void PresetCreatorComponent::doSave()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", startDir, "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.exists() || f.getParentDirectory().exists())
        {
            // Ensure directory exists when saving into default folder
            f.getParentDirectory().createDirectory();
            
            // --- FIX: Temporarily unmute nodes to save original connections ---
            // When nodes are muted, their connections are replaced with bypass routing.
            // We must save the ORIGINAL connections, not the bypass connections.
            
            // 1. Get a list of all currently muted nodes from the editor
            std::vector<juce::uint32> currentlyMutedNodes;
            if (editor)
            {
                for (const auto& pair : editor->mutedNodeStates)
                {
                    currentlyMutedNodes.push_back(pair.first);
                }
                
                // 2. Temporarily UNMUTE all of them to restore the original connections
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->unmuteNode(lid);
                }
            }
            
            // 3. CRITICAL: Force the synth to apply these connection changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // At this point, the synth graph is in its "true", unmuted state
            
            // 4. NOW get the state - this will save the correct, original connections
            juce::MemoryBlock mb;
            synth->getStateInformation (mb);
            auto xml = juce::XmlDocument::parse (mb.toString());
            if (! xml) return;
            
            // 5. IMMEDIATELY RE-MUTE the nodes to return the editor to its visible state
            if (editor)
            {
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->muteNode(lid);
                }
            }
            
            // 6. CRITICAL: Force the synth to apply the re-mute changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // The synth graph is now back to its bypassed state for audio processing
            // --- END OF FIX ---
            
            juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
            // Attach UI state as child (which correctly contains the "muted" flags)
            if (editor)
            {
                juce::ValueTree ui = editor->getUiValueTree();
                presetVT.addChild (ui, -1, nullptr);
            }
            // Write
            f.replaceWithText (presetVT.createXml()->toString());
            log.insertTextAtCaret ("Saved: " + f.getFullPathName() + "\n");
            
            setWindowFileName(f.getFileName()); // Update title bar with filename
        }
    });
}

void PresetCreatorComponent::doLoad()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", startDir, "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData (mb);
                // First set the synth state
                synth->setStateInformation (mb.getData(), (int) mb.getSize());
                // Then parse and queue UI state for next frame (ensures editor exists and nodes are created)
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse (mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml (*xml);
                        auto ui = vt.getChildWithName ("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow (ui);
                    }
                }
                refreshModulesList();
                log.insertTextAtCaret ("Loaded: " + f.getFullPathName() + "\n");
                
                setWindowFileName(f.getFileName()); // Update title bar with filename
            }
        } catch (...) {
            juce::Logger::writeToLog ("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}

bool PresetCreatorComponent::keyPressed (const juce::KeyPress& key)
{
    if (key.getKeyCode() == juce::KeyPress::spaceKey)
    {
        if (spacebarDownTime == 0) // Only record time on the initial press
        {
            spacebarDownTime = juce::Time::getMillisecondCounter();
            wasLongPress = false;
        }
        return true;
    }
    return false;
}

bool PresetCreatorComponent::keyStateChanged (bool isKeyDown)
{
    juce::ignoreUnused (isKeyDown);

    if (!juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
    {
        if (spacebarDownTime != 0) // Key was just released
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration < longPressThresholdMs && !wasLongPress)
            {
                // SHORT PRESS (TOGGLE)
                if (synth)
                {
                    const bool isCurrentlyPlaying = synth->getTransportState().isPlaying;
                    setMasterPlayState(!isCurrentlyPlaying); // Use the unified function
                }
            }
            // If it was a long press, the timer callback will handle stopping.
        }
        spacebarDownTime = 0; // Reset for next press
    }
    return false;
}

void PresetCreatorComponent::visibilityChanged()
{
    juce::Logger::writeToLog (juce::String ("Component visible? ") + (isShowing() ? "yes" : "no"));
}

void PresetCreatorComponent::startAudition()
{
    if (auditioning) return;
    deviceManager.addAudioCallback (&processorPlayer);
    auditioning = true;
    log.insertTextAtCaret ("[Audition] Start (hold space)\n");
}

void PresetCreatorComponent::stopAudition()
{
    if (! auditioning) return;
    deviceManager.removeAudioCallback (&processorPlayer);
    auditioning = false;
    log.insertTextAtCaret ("[Audition] Stop\n");
}

void PresetCreatorComponent::timerCallback()
{
    RtLogger::flushToFileLogger();
    
    // MULTI-MIDI SUPPORT: Transfer MIDI messages from MidiDeviceManager to ModularSynthProcessor
    if (midiDeviceManager && synth)
    {
        std::vector<MidiDeviceManager::MidiMessageWithSource> midiMessages;
        midiDeviceManager->swapMessageBuffer(midiMessages);
        
        if (!midiMessages.empty())
        {
            juce::Logger::writeToLog("[PresetCreator] Received " + juce::String(midiMessages.size()) + 
                                    " MIDI messages from MidiDeviceManager");
            
            // Convert to ModularSynthProcessor format
            std::vector<MidiMessageWithDevice> convertedMessages;
            convertedMessages.reserve(midiMessages.size());
            
            for (const auto& msg : midiMessages)
            {
                MidiMessageWithDevice converted;
                converted.message = msg.message;
                converted.deviceIdentifier = msg.deviceIdentifier;
                converted.deviceName = msg.deviceName;
                converted.deviceIndex = msg.deviceIndex;
                convertedMessages.push_back(converted);
            }
            
            juce::Logger::writeToLog("[PresetCreator] Passing " + juce::String(convertedMessages.size()) + 
                                    " messages to ModularSynthProcessor");
            
            // Pass to synth for distribution to modules
            synth->processMidiWithDeviceInfo(convertedMessages);
        }
    }
    
    // Check for MIDI activity from the synth
    if (synth != nullptr && synth->hasMidiActivity())
        midiActivityFrames = 30;
    
    // Update MIDI activity indicator in editor
    if (editor != nullptr)
        editor->setMidiActivityFrames(midiActivityFrames);
    
    if (synth != nullptr)
    {
        // Check for long press activation
        if (spacebarDownTime != 0 && !wasLongPress)
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration >= longPressThresholdMs)
            {
                wasLongPress = true;
                setMasterPlayState(true); // Use the unified function
            }
        }
        
        // Check for long press release
        if (wasLongPress && !juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
        {
            setMasterPlayState(false); // Use the unified function
            wasLongPress = false;
            spacebarDownTime = 0;
        }
    }

    static int counter = 0;
    if ((++counter % 60) == 0)
        juce::Logger::writeToLog ("[Heartbeat] UI alive");
}


================================================================================
FILE: juce\Source\ui\MainComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "VisualiserComponent.h"
#include "TestHarnessComponent.h" // Add this include

// Forward declarations for audio stubs
class AudioEngine;
class CommandProcessor;

class MainComponent : public juce::AudioAppComponent
{
public:
    MainComponent();
    ~MainComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;

    // AudioAppComponent hooks (pass-through to AudioEngine)
    void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override;
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override;
    void releaseResources() override;

private:
    juce::Label statusLabel;
    juce::Slider masterVolumeSlider;
public:
    juce::Label connLabel;
    juce::Timer* timerHook { nullptr };
    std::unique_ptr<AudioEngine> audioEngine;
    TestHarnessComponent testHarness; // ADD THIS
    std::unique_ptr<VisualiserComponent> visualiser;
};




================================================================================
FILE: juce\Source\ui\MainComponent.cpp
================================================================================


#include "MainComponent.h"
#include "../audio/AudioEngine.h"

struct ConnTimer : public juce::Timer {
    MainComponent& mc;
    ConnTimer (MainComponent& m) : mc (m) { startTimerHz (10); }
    void timerCallback() override {
        mc.connLabel.setText ("OSC: listening", juce::dontSendNotification);
    }
};

MainComponent::MainComponent()
    : testHarness(deviceManager) // Initialize testHarness with deviceManager in member initializer list
{
    // Create audio engine (OSC + graph, acts as AudioSource)
    audioEngine = std::make_unique<AudioEngine>(deviceManager);
    
    // Make the UI visible
    addAndMakeVisible(testHarness);
    
    // THIS IS THE CRITICAL CONNECTION:
    // Pass the engine pointer to the UI component.
    testHarness.setAudioEngine(audioEngine.get());

    // Open default audio device on this MainComponent (the AudioAppComponent)
    setAudioChannels (2, 2); // Request 2 input channels, 2 output channels

    setSize(1600, 900); // Set a default size for the main window
}

MainComponent::~MainComponent()
{
    // Close audio device on MainComponent
    shutdownAudio();
}

void MainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (16.0f);
    g.drawFittedText ("Collider Audio Engine (JUCE)", getLocalBounds(), juce::Justification::centredTop, 1);
}

void MainComponent::resized()
{
    // Make the TestHarnessComponent fill the entire window.
    testHarness.setBounds(getLocalBounds());
}

void MainComponent::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    juce::Logger::writeToLog ("[APP] MainComponent::prepareToPlay called");
    // Log current audio device selection for diagnostics
    {
        juce::AudioDeviceManager::AudioDeviceSetup setup; deviceManager.getAudioDeviceSetup (setup);
        auto* dev = deviceManager.getCurrentAudioDevice();
        juce::Logger::writeToLog ("[APP] Audio device: out='" + setup.outputDeviceName
                                  + "' sr=" + juce::String (dev ? dev->getCurrentSampleRate() : 0.0)
                                  + " bs=" + juce::String (dev ? dev->getCurrentBufferSizeSamples() : 0));
    }
    if (audioEngine)
        audioEngine->prepareToPlay (samplesPerBlockExpected, sampleRate);
}

void MainComponent::getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill)
{
    if (audioEngine)
        audioEngine->getNextAudioBlock (bufferToFill);
    else if (bufferToFill.buffer != nullptr)
        bufferToFill.buffer->clear();
}

void MainComponent::releaseResources()
{
    juce::Logger::writeToLog ("[APP] MainComponent::releaseResources called");
    if (audioEngine)
        audioEngine->releaseResources();
}




================================================================================
FILE: juce\Source\ui\VisualiserComponent.h
================================================================================


// Rationale: VisualiserComponent renders a minimal debug dashboard of the
// listener and active voices using the VisualiserState from AudioEngine.
#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include "DebugInfo.h"

class AudioEngine;

class VisualiserComponent : public juce::Component, private juce::Timer
{
public:
    explicit VisualiserComponent (AudioEngine& engineRef);
    ~VisualiserComponent() override;

    void paint (juce::Graphics& g) override;
    void resized() override;

private:
    void timerCallback() override;
    juce::Point<int> worldToScreen (juce::Point<float> p) const;
    void drawLegend (juce::Graphics& g) const;

    AudioEngine& engine;
    // World coordinate bounds (from Python game): origin at (0,0), width=1920, height=1080
    juce::Rectangle<float> worldBounds { 0.0f, 0.0f, 1920.0f, 1080.0f };
};




================================================================================
FILE: juce\Source\ui\VisualiserComponent.cpp
================================================================================


#include "VisualiserComponent.h"
#include "DebugInfo.h"
#include "../audio/AudioEngine.h"

VisualiserComponent::VisualiserComponent (AudioEngine& engineRef)
    : engine (engineRef)
{
    startTimerHz (30);
}

VisualiserComponent::~VisualiserComponent()
{
    stopTimer();
}

void VisualiserComponent::timerCallback()
{
    repaint();
}

void VisualiserComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);

    auto state = engine.getVisualiserState();

    // Draw listener
    g.setColour (juce::Colours::white);
    auto lp = worldToScreen (state.listenerPosition);
    g.fillEllipse ((float) lp.x - 6.0f, (float) lp.y - 6.0f, 12.0f, 12.0f);

    // Draw voices
    for (auto& v : state.voices)
    {
        juce::Colour c = juce::Colours::grey;
        switch (v.state)
        {
            case VoiceDebugState::Playing:  c = juce::Colours::yellow; break;
            case VoiceDebugState::Stopping: c = juce::Colours::orange; break;
            case VoiceDebugState::Clipping: c = juce::Colours::red;    break;
            case VoiceDebugState::Prepared: c = juce::Colours::cornflowerblue; break;
            case VoiceDebugState::Silent:   c = juce::Colours::darkgrey; break;
            case VoiceDebugState::Error:    c = juce::Colours::deeppink; break;
            case VoiceDebugState::Created:  c = juce::Colours::lightblue; break;
        }
        g.setColour (c);
        auto p = worldToScreen (v.position);
        g.fillEllipse ((float) p.x - 4.0f, (float) p.y - 4.0f, 8.0f, 8.0f);
    }

    drawLegend (g);
}

void VisualiserComponent::resized()
{
}

juce::Point<int> VisualiserComponent::worldToScreen (juce::Point<float> p) const
{
    auto screen = getLocalBounds();
    const float wx0 = worldBounds.getX();
    const float wy0 = worldBounds.getY();
    const float wx1 = worldBounds.getRight();
    const float wy1 = worldBounds.getBottom();

    // Map X: [wx0, wx1] -> [screen.getX(), screen.getRight()]
    const float sx = juce::jmap (p.x, wx0, wx1, (float) screen.getX(), (float) screen.getRight());

    // Map Y (invert): game Y increases up, screen Y increases down
    // World Y=wy0 (bottom) should map to screen.getBottom()
    // World Y=wy1 (top)    should map to screen.getY()
    const float sy = juce::jmap (p.y, wy0, wy1, (float) screen.getBottom(), (float) screen.getY());

    const int ix = juce::jlimit (screen.getX(), screen.getRight(), (int) std::lround (sx));
    const int iy = juce::jlimit (screen.getY(), screen.getBottom(), (int) std::lround (sy));
    return { ix, iy };
}

void VisualiserComponent::drawLegend (juce::Graphics& g) const
{
    juce::Rectangle<int> panel (10, getHeight() - 110, 260, 100);
    g.setColour (juce::Colours::black.withAlpha (0.6f));
    g.fillRoundedRectangle (panel.toFloat(), 6.0f);
    g.setColour (juce::Colours::white);
    g.drawText ("Legend:", panel.removeFromTop (18), juce::Justification::left);

    auto row = [&](juce::Colour col, const juce::String& text, int y) {
        g.setColour (col); g.fillEllipse (14.0f, (float) y + 4.0f, 8.0f, 8.0f);
        g.setColour (juce::Colours::white); g.drawText (text, 30, y, 220, 16, juce::Justification::left);
    };
    int baseY = getHeight() - 88;
    row (juce::Colours::yellow, "Playing", baseY);
    row (juce::Colours::orange, "Stopping", baseY + 16);
    row (juce::Colours::red,    "Clipping", baseY + 32);
    row (juce::Colours::cornflowerblue, "Prepared", baseY + 48);
    row (juce::Colours::darkgrey, "Silent", baseY + 64);
}




================================================================================
FILE: juce\Source\ui\TestHarnessComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_dsp/juce_dsp.h>
#include "../audio/graph/VoiceProcessor.h"
#include "../audio/assets/SampleBank.h"

// Forward declaration
class AudioEngine;
#include "../audio/AudioEngine.h"

// Simple on-screen logger used by the harness
struct OnScreenLogger
{
    static void attach (juce::TextEditor* editor);
    static void log (const juce::String& msg);
};

class TestHarnessComponent : public juce::Component, // Changed from AudioAppComponent
                             private juce::Button::Listener,
                             private juce::Slider::Listener,
                             private juce::ComboBox::Listener,
                             private juce::Timer
{
public:
    // Accept the shared AudioDeviceManager from the parent so we can show audio settings
    TestHarnessComponent(juce::AudioDeviceManager& adm);
    ~TestHarnessComponent() override;

    void prepareToPlay (int samplesPerBlockExpected, double sampleRate);
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill);
    void releaseResources();

    void paint (juce::Graphics&) override;
    void resized() override;
    void timerCallback() override;
    
    // Connection to AudioEngine
    void setAudioEngine(AudioEngine* engine);
    // List models (nested types)
    struct DirListModel : public juce::ListBoxModel {
        DirListModel(TestHarnessComponent& ownerRef) : owner(ownerRef) {}
        int getNumRows() override;
        void paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected) override;
        void selectedRowsChanged (int lastRowSelected) override;
        void listBoxItemClicked (int row, const juce::MouseEvent&) override;
        TestHarnessComponent& owner;
    };
    struct SampleListModel : public juce::ListBoxModel {
        SampleListModel(TestHarnessComponent& ownerRef) : owner(ownerRef) {}
        int getNumRows() override;
        void paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected) override;
        void selectedRowsChanged (int lastRowSelected) override;
        TestHarnessComponent& owner;
    };

    struct VoiceListModel : public juce::ListBoxModel {
        VoiceListModel(TestHarnessComponent& ownerRef) : owner(ownerRef) {}
        int getNumRows() override;
        void paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected) override;
        void selectedRowsChanged (int lastRowSelected) override;
        void listBoxItemClicked (int row, const juce::MouseEvent&) override;
        TestHarnessComponent& owner;
    };

private:
    void buttonClicked (juce::Button* b) override;
    void sliderValueChanged (juce::Slider* s) override;
    void comboBoxChanged (juce::ComboBox* c) override;

    // AudioEngine connection
    AudioEngine* audioEngine = nullptr;
    
    // This vector will hold the synced voice list from the engine
    std::vector<AudioEngine::VoiceInfo> engineVoices;
    juce::uint64 controlledVoiceId { 0 };
    bool isSyncingSliders = false;

    juce::AudioBuffer<float> tempMixBuffer; // For manual mixing
    
    // --- Audio settings integration ---
    juce::AudioDeviceManager& deviceManager; // reference to shared device manager
    std::unique_ptr<juce::AudioDeviceSelectorComponent> audioSetupComp;
    juce::TextButton btnAudioSettings { "Audio Settings..." };
    SampleBank sampleBank; // To provide samples
    juce::TextButton btnCreateSynth { "Create Synth" };
    juce::TextButton btnCreateSample { "Create Sample" };
    juce::TextButton btnCreateNoise { "Create Noise" };
    juce::TextButton btnCreateModular { "Create Modular" };
    juce::TextButton btnLoadPreset { "Load Preset for Modular" };
    juce::TextButton btnDestroy { "Destroy Last Voice" };
    juce::TextButton btnDestroyRandom { "Destroy Random Voice" };
    juce::TextButton btnDestroySelected { "Destroy Selected Voice" };
    juce::TextButton btnRandomPitch { "Random Pitch" };
    juce::TextButton btnRandomTime { "Random Time" };
    juce::TextButton btnResetFx { "Reset FX Defaults" };
    juce::ToggleButton btnChaos { "Enable Chaos Mode" };
    juce::Slider sliderGain, sliderPan;
    juce::Label lblGain { {}, "Gain" }, lblPan { {}, "Pan" }, lblStatus;
    juce::Label lblDevice { {}, "Device: -" }, lblVoices { {}, "Voices: 0" }, lblPeak { {}, "Peak: 0.0" };
    juce::TextEditor logView;
    juce::ToggleButton btnManualFx { "Manual FX Control" };
    juce::Label lEngine { {}, "Engine" };
    juce::ComboBox comboEngine;

    // FX sliders
    juce::Slider sFilterCutoff, sFilterRes, sChRate, sChDepth, sChMix;
    juce::Slider sPhRate, sPhDepth, sPhCentre, sPhFb, sPhMix;
    juce::Slider sRvRoom, sRvDamp, sRvWidth, sRvMix;
    juce::Slider sDlTime, sDlFb, sDlMix;
    juce::Slider sCpThresh, sCpRatio, sCpAtk, sCpRel, sCpMake;
    juce::Slider sLmThresh, sLmRel;
    juce::Slider sDrAmt, sDrMix;
    juce::Slider sGtThresh, sGtAtk, sGtRel;
    juce::Slider sTsRatio, sPtSemis;

    juce::Label lFilterCutoff { {}, "Filt Cutoff" }, lFilterRes { {}, "Filt Q" }, lChRate { {}, "Ch Rate" }, lChDepth { {}, "Ch Depth" }, lChMix { {}, "Ch Mix" };
    juce::Label lPhRate { {}, "Ph Rate" }, lPhDepth { {}, "Ph Depth" }, lPhCentre { {}, "Ph Ctr" }, lPhFb { {}, "Ph FB" }, lPhMix { {}, "Ph Mix" };
    juce::Label lRvRoom { {}, "Rv Room" }, lRvDamp { {}, "Rv Damp" }, lRvWidth { {}, "Rv Width" }, lRvMix { {}, "Rv Mix" };
    juce::Label lDlTime { {}, "Dly ms" }, lDlFb { {}, "Dly FB" }, lDlMix { {}, "Dly Mix" };
    juce::Label lCpThresh { {}, "Cp Thr" }, lCpRatio { {}, "Cp Ratio" }, lCpAtk { {}, "Cp Atk" }, lCpRel { {}, "Cp Rel" }, lCpMake { {}, "Cp Make" };
    juce::Label lLmThresh { {}, "Lm Thr" }, lLmRel { {}, "Lm Rel" };
    juce::Label lDrAmt { {}, "Drv Amt" }, lDrMix { {}, "Drv Mix" };
    juce::Label lGtThresh { {}, "Gate Thr" }, lGtAtk { {}, "Gate Atk" }, lGtRel { {}, "Gate Rel" };
    juce::Label lTsRatio { {}, "Time" }, lPtSemis { {}, "Pitch" };
    juce::Slider sPtRatio; juce::Label lPtRatio { {}, "Pitch x" };

    // Sample loader UI
    juce::ListBox listDirs { "Folders" };
    juce::ListBox listSamples { "Samples" };
    juce::ListBox listVoices { "Voices" };
    DirListModel dirModel { *this };
    SampleListModel sampleModel { *this };
    VoiceListModel voiceModel { *this };
    juce::StringArray dirNames;
    juce::Array<juce::File> dirPaths;
    juce::StringArray sampleNames;
    juce::Array<juce::File> samplePaths;
    int selectedDirIndex { -1 };
    int selectedSampleIndex { -1 };
    juce::File samplesRoot;
    std::unique_ptr<juce::FileChooser> loadChooser;

    void refreshDirectories();
    void refreshSamples();
    void refreshVoicesList();
    void syncSlidersWithSelectedVoice();
    void setControlledVoiceByIndex (int index);

    juce::uint64 lastVoiceId { 0 };
    bool hasEngineConfirmedReady { false };
    double harnessStartMs { 0.0 };
    // (Adapter handles modular voices as normal VoiceProcessor instances)

    // (Removed VCO verification fields)
};




================================================================================
FILE: juce\Source\ui\TestHarnessComponent.cpp
================================================================================


#include "TestHarnessComponent.h"
#include "MainComponent.h"
#include "../audio/voices/NoiseVoiceProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include "../audio/voices/SynthVoiceProcessor.h"
#include "../audio/voices/SampleVoiceProcessor.h"
#include "../audio/voices/ModularVoice.h"
#include "../audio/utils/VoiceDeletionUtils.h"
#include "../audio/AudioEngine.h"
#include "../ipc/CommandBus.h"

static juce::TextEditor* gLoggerEditor = nullptr;

void OnScreenLogger::attach (juce::TextEditor* editor)
{
    gLoggerEditor = editor;
}

void OnScreenLogger::log (const juce::String& msg)
{
    if (gLoggerEditor != nullptr)
    {
        if (juce::MessageManager::getInstanceWithoutCreating() != nullptr
            && juce::MessageManager::getInstance()->isThisTheMessageThread())
        {
            gLoggerEditor->moveCaretToEnd();
            gLoggerEditor->insertTextAtCaret (msg + "\n");
        }
        else
        {
            juce::MessageManager::callAsync ([s = msg]
            {
                if (gLoggerEditor != nullptr)
                {
                    gLoggerEditor->moveCaretToEnd();
                    gLoggerEditor->insertTextAtCaret (s + "\n");
                }
            });
        }
    }
    juce::Logger::writeToLog (msg);
}

TestHarnessComponent::TestHarnessComponent(juce::AudioDeviceManager& adm)
    : deviceManager(adm)
{
    OnScreenLogger::attach (&logView);
    OnScreenLogger::log ("Harness: Constructor starting...");

    // Set initial harness window size once
    setSize (1600, 900); // More reasonable default size


    addAndMakeVisible (btnAudioSettings);
    addAndMakeVisible (btnCreateSynth);
    addAndMakeVisible (btnCreateSample);
    addAndMakeVisible (btnCreateNoise);
    addAndMakeVisible (btnCreateModular);
    addAndMakeVisible (btnLoadPreset);
    addAndMakeVisible (btnDestroy);
    addAndMakeVisible (btnDestroyRandom);
    addAndMakeVisible (btnDestroySelected);
    addAndMakeVisible (btnRandomPitch);
    addAndMakeVisible (btnRandomTime);
    addAndMakeVisible (btnResetFx);
    addAndMakeVisible (btnChaos);
    addAndMakeVisible (btnManualFx);
    addAndMakeVisible (lEngine);
    addAndMakeVisible (comboEngine);
    comboEngine.addItem ("RubberBand", 1);
    comboEngine.addItem ("Naive", 2);
    comboEngine.setSelectedId (1, juce::dontSendNotification);
    comboEngine.addListener (this);
    addAndMakeVisible (sliderGain);
    addAndMakeVisible (sliderPan);
    addAndMakeVisible (lblGain);
    addAndMakeVisible (lblPan);
    addAndMakeVisible (lblStatus);
    addAndMakeVisible (lblDevice);
    addAndMakeVisible (lblVoices);
    addAndMakeVisible (lblPeak);
    addAndMakeVisible (logView);
    addAndMakeVisible (listDirs);
    addAndMakeVisible (listSamples);
    addAndMakeVisible (listVoices);
    listDirs.setRowHeight (22);
    listSamples.setRowHeight (22);
    listVoices.setRowHeight (22);
    listDirs.setMultipleSelectionEnabled (false);
    listSamples.setMultipleSelectionEnabled (false);
    listVoices.setMultipleSelectionEnabled (false);
    listDirs.setModel (&dirModel);
    listSamples.setModel (&sampleModel);
    listVoices.setModel (&voiceModel);
    listDirs.getVerticalScrollBar().setAutoHide (false);
    listSamples.getVerticalScrollBar().setAutoHide (false);
    listVoices.getVerticalScrollBar().setAutoHide (false);
    auto initSlider = [] (juce::Slider& s, double min, double max, double def, double inc=0.001)
    {
        s.setRange (min, max, inc);
        s.setValue (def);
    };
    auto addL = [this] (juce::Label& l) { addAndMakeVisible (l); };
    auto addS = [this] (juce::Slider& s) { addAndMakeVisible (s); s.addListener (this); };

    // Initialize FX sliders, defaults to "dry" positions
    addL (lFilterCutoff); addS (sFilterCutoff); initSlider (sFilterCutoff, 20.0, 20000.0, 20000.0, 1.0);
    addL (lFilterRes);    addS (sFilterRes);    initSlider (sFilterRes, 1.0, 20.0, 1.0);

    addL (lChRate);  addS (sChRate);  initSlider (sChRate, 0.1, 10.0, 1.0);
    addL (lChDepth); addS (sChDepth); initSlider (sChDepth, 0.0, 1.0, 0.0);
    addL (lChMix);   addS (sChMix);   initSlider (sChMix, 0.0, 1.0, 0.0);

    addL (lPhRate);   addS (sPhRate);   initSlider (sPhRate, 0.01, 10.0, 0.5);
    addL (lPhDepth);  addS (sPhDepth);  initSlider (sPhDepth, 0.0, 1.0, 0.0);
    addL (lPhCentre); addS (sPhCentre); initSlider (sPhCentre, 20.0, 20000.0, 1000.0, 1.0);
    addL (lPhFb);     addS (sPhFb);     initSlider (sPhFb, -0.99, 0.99, 0.0);
    addL (lPhMix);    addS (sPhMix);    initSlider (sPhMix, 0.0, 1.0, 0.0);

    addL (lRvRoom); addS (sRvRoom); initSlider (sRvRoom, 0.0, 1.0, 0.0);
    addL (lRvDamp); addS (sRvDamp); initSlider (sRvDamp, 0.0, 1.0, 0.5);
    addL (lRvWidth);addS (sRvWidth);initSlider (sRvWidth,0.0, 1.0, 1.0);
    addL (lRvMix);  addS (sRvMix);  initSlider (sRvMix,  0.0, 1.0, 0.0);

    addL (lDlTime); addS (sDlTime); initSlider (sDlTime, 1.0, 2000.0, 0.0, 1.0);
    addL (lDlFb);   addS (sDlFb);   initSlider (sDlFb,   0.0, 0.95, 0.0);
    addL (lDlMix);  addS (sDlMix);  initSlider (sDlMix,  0.0, 1.0, 0.0);

    addL (lCpThresh); addS (sCpThresh); initSlider (sCpThresh, -60.0, 0.0, 0.0);
    addL (lCpRatio);  addS (sCpRatio);  initSlider (sCpRatio,  1.0, 20.0, 1.0);
    addL (lCpAtk);    addS (sCpAtk);    initSlider (sCpAtk,    0.1, 200.0, 10.0);
    addL (lCpRel);    addS (sCpRel);    initSlider (sCpRel,    5.0, 1000.0, 100.0);
    addL (lCpMake);   addS (sCpMake);   initSlider (sCpMake,  -12.0, 12.0, 0.0);

    addL (lLmThresh); addS (sLmThresh); initSlider (sLmThresh, -20.0, 0.0, 0.0);
    addL (lLmRel);    addS (sLmRel);    initSlider (sLmRel,     1.0, 200.0, 10.0);

    addL (lDrAmt); addS (sDrAmt); initSlider (sDrAmt, 0.0, 2.0, 0.0);
    addL (lDrMix); addS (sDrMix); initSlider (sDrMix, 0.0, 1.0, 0.0);

    addL (lGtThresh); addS (sGtThresh); initSlider (sGtThresh, -80.0, -20.0, -100.0);
    addL (lGtAtk);    addS (sGtAtk);    initSlider (sGtAtk,      0.1, 50.0, 1.0);
    addL (lGtRel);    addS (sGtRel);    initSlider (sGtRel,        5.0, 500.0, 50.0);

    addL (lTsRatio); addS (sTsRatio); initSlider (sTsRatio, 0.25, 6.0, 1.0);
    addL (lPtSemis); addS (sPtSemis); initSlider (sPtSemis, -24.0, 24.0, 0.0);
    addL (lPtRatio); addS (sPtRatio); initSlider (sPtRatio, 0.5, 2.0, 1.0);

    btnAudioSettings.addListener (this);
    btnCreateSynth.addListener (this);
    btnCreateSample.addListener (this);
    btnCreateNoise.addListener (this);
    btnCreateModular.addListener (this);
    btnLoadPreset.addListener (this);
    btnDestroy.addListener (this);
    btnDestroyRandom.addListener (this);
    btnDestroySelected.addListener (this);
    btnRandomPitch.addListener (this);
    btnRandomTime.addListener (this);
    btnResetFx.addListener (this);

    sliderGain.setRange (0.0, 1.0, 0.001);
    sliderGain.setSkewFactor (0.7);
    sliderGain.setValue (0.7);
    sliderGain.addListener (this);

    sliderPan.setRange (-1.0, 1.0, 0.001);
    sliderPan.setValue (0.0);
    sliderPan.addListener (this);

    lblStatus.setText ("Controlling Voice ID: -", juce::dontSendNotification);
    logView.setMultiLine (true); logView.setReadOnly (true); logView.setScrollbarsShown (true); logView.setCaretVisible (false);
    logView.setText ("[Harness] Ready\n");
    startTimerHz (15);

    // (Removed VCO verification instantiation and slider)

    // Load samples by searching upwards for 'audio/samples' from exe and CWD
    auto findSamplesDir = []() -> juce::File
    {
        juce::Array<juce::File> starts;
        starts.add (juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory());
        starts.add (juce::File::getCurrentWorkingDirectory());
        for (auto s : starts)
        {
            juce::File cur = s;
            for (int i = 0; i < 8; ++i)
            {
                juce::File candidate = cur.getChildFile ("audio").getChildFile ("samples");
                if (candidate.isDirectory())
                    return candidate;
                cur = cur.getParentDirectory();
            }
        }
        return {};
    };

    juce::File root = findSamplesDir();
    if (root.isDirectory())
    {
        OnScreenLogger::log ("[SampleBank] Searching samples in: " + root.getFullPathName());
        sampleBank.loadSamplesFromDirectory (root);
        samplesRoot = root;
        refreshDirectories();
        refreshSamples();
    }
    else
    {
        OnScreenLogger::log ("[SampleBank][WARN] Could not locate 'audio/samples' relative to exe or CWD.");
    }

    OnScreenLogger::log ("Harness: Constructor finished.");
}

// ----------- ListBoxModel (shared for both lists) -----------
int TestHarnessComponent::DirListModel::getNumRows() { return owner.dirNames.size(); }
void TestHarnessComponent::DirListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowNumber < 0 || rowNumber >= owner.dirNames.size()) return;
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    g.setColour (juce::Colours::white);
    g.drawText (owner.dirNames[rowNumber], 6, 0, width - 12, height, juce::Justification::centredLeft);
}
void TestHarnessComponent::DirListModel::selectedRowsChanged (int /*lastRowSelected*/)
{
    owner.selectedDirIndex = owner.listDirs.getSelectedRow();
    owner.refreshSamples();
}
void TestHarnessComponent::DirListModel::listBoxItemClicked (int row, const juce::MouseEvent&)
{
    owner.selectedDirIndex = row;
    owner.listDirs.selectRow (row);
    owner.refreshSamples();
}
int TestHarnessComponent::SampleListModel::getNumRows() { return owner.sampleNames.size(); }
void TestHarnessComponent::SampleListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowNumber < 0 || rowNumber >= owner.sampleNames.size()) return;
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    g.setColour (juce::Colours::white);
    g.drawText (owner.sampleNames[rowNumber], 6, 0, width - 12, height, juce::Justification::centredLeft);
}
void TestHarnessComponent::SampleListModel::selectedRowsChanged (int lastRowSelected)
{
    owner.selectedSampleIndex = lastRowSelected;
}

// -------- Voices list model --------
// --- VoiceListModel Methods ---
int TestHarnessComponent::VoiceListModel::getNumRows() { return (int)owner.engineVoices.size(); }

void TestHarnessComponent::VoiceListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    if (rowNumber >= 0 && rowNumber < (int)owner.engineVoices.size())
    {
        const auto& voiceInfo = owner.engineVoices[rowNumber];
        juce::String text = juce::String((juce::int64)voiceInfo.voiceId) + " - " + voiceInfo.voiceType;
        if (voiceInfo.displayName.isNotEmpty())
            text += " (" + voiceInfo.displayName + ")";
        g.setColour (juce::Colours::white);
        g.drawText (text, 6, 0, width - 12, height, juce::Justification::centredLeft);
    }
}

void TestHarnessComponent::VoiceListModel::listBoxItemClicked (int row, const juce::MouseEvent&)
{
    owner.listVoices.selectRow(row);
}

void TestHarnessComponent::VoiceListModel::selectedRowsChanged(int lastRowSelected)
{
    owner.setControlledVoiceByIndex(lastRowSelected);
}

void TestHarnessComponent::refreshDirectories()
{
    dirNames.clear(); dirPaths.clear();
    if (! samplesRoot.isDirectory()) return;
    auto sub = samplesRoot.findChildFiles (juce::File::findDirectories, false);
    sub.sort();
    for (auto& d : sub)
    {
        dirNames.add (d.getFileName());
        dirPaths.add (d);
    }
    listDirs.updateContent();
    if (selectedDirIndex < 0 && dirNames.size() > 0)
    {
        selectedDirIndex = 0;
        listDirs.selectRow (0);
    }
}

void TestHarnessComponent::refreshSamples()
{
    sampleNames.clear(); samplePaths.clear();
    if (selectedDirIndex >= 0 && selectedDirIndex < dirPaths.size())
    {
        auto dir = dirPaths[(int) selectedDirIndex];
        juce::Array<juce::File> files;
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.wav"));
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.aif"));
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.aiff"));
        files.sort();
        for (auto& f : files)
        {
            sampleNames.add (f.getFileName());
            samplePaths.add (f);
        }
    }
    listSamples.updateContent();
}

TestHarnessComponent::~TestHarnessComponent()
{
}

void TestHarnessComponent::setAudioEngine(AudioEngine* engine)
{
    audioEngine = engine;
    OnScreenLogger::log ("Harness: Connected to AudioEngine.");
}




void TestHarnessComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (16.0f);
    g.drawFittedText ("Collider Audio Test Harness", getLocalBounds(), juce::Justification::centredTop, 1);
}

void TestHarnessComponent::resized()
{
	// Do not setSize() here; window size controlled in constructor and by host
	int x = 10, y = 40, w = juce::jmin (340, getWidth() - 20), h = 24, gap = 6;
    btnAudioSettings.setBounds (x, y, w, h); y += h + gap;
	btnCreateSynth.setBounds (x, y, w, h); y += h + gap;
	btnCreateSample.setBounds (x, y, w, h); y += h + gap;
	btnCreateNoise.setBounds (x, y, w, h); y += h + gap;
	btnCreateModular.setBounds (x, y, w, h); y += h + gap;
	btnLoadPreset.setBounds(x, y, w, h); y += h + gap;
	btnDestroy.setBounds (x, y, w, h); y += h + gap;
	btnDestroyRandom.setBounds (x, y, w, h); y += h + gap;
	btnDestroySelected.setBounds (x, y, w, h); y += h + gap;
	btnRandomPitch.setBounds (x, y, w, h); y += h + gap;
	btnRandomTime.setBounds (x, y, w, h); y += h + gap;
	btnResetFx.setBounds (x, y, w, h); y += h + gap;
	btnManualFx.setBounds (x, y, w, h); btnManualFx.setToggleState (true, juce::dontSendNotification); y += h + gap * 2;
    lEngine.setBounds (x, y, 70, h); comboEngine.setBounds (x + 75, y, w - 80, h); y += h + gap;

	lblGain.setBounds (x, y, 70, h); sliderGain.setBounds (x + 75, y, w - 80, h); y += h + gap;
	lblPan.setBounds (x, y, 70, h); sliderPan.setBounds (x + 75, y, w - 80, h); y += h + gap;
	btnChaos.setBounds (x, y, w, h); y += h + gap;
	lblStatus.setBounds (x, y, w, h); y += h + gap;
	lblDevice.setBounds (x, y, w, h); y += h + gap;
	lblVoices.setBounds (x, y, w, h); y += h + gap;
	lblPeak.setBounds (x, y, w, h); y += h + gap;

	// FX grid to the right with column wrap
	int gx = x + w + 20;
	int gy = 40;
	const int gw = 300;
	auto place = [&] (juce::Label& l, juce::Slider& s)
	{
		if (gy + h > getHeight() - 40)
		{
			gx += gw + 30;
			gy = 40;
		}
		l.setBounds (gx, gy, 100, h); s.setBounds (gx + 105, gy, gw - 110, h); gy += h + gap;
	};
	place (lFilterCutoff, sFilterCutoff);
	place (lFilterRes,    sFilterRes);
	place (lChRate,       sChRate);
	place (lChDepth,      sChDepth);
	place (lChMix,        sChMix);
	place (lPhRate,       sPhRate);
	place (lPhDepth,      sPhDepth);
	place (lPhCentre,     sPhCentre);
	place (lPhFb,         sPhFb);
	place (lPhMix,        sPhMix);
	place (lRvRoom,       sRvRoom);
	place (lRvDamp,       sRvDamp);
	place (lRvWidth,      sRvWidth);
	place (lRvMix,        sRvMix);
	place (lDlTime,       sDlTime);
	place (lDlFb,         sDlFb);
	place (lDlMix,        sDlMix);
	place (lCpThresh,     sCpThresh);
	place (lCpRatio,      sCpRatio);
	place (lCpAtk,        sCpAtk);
	place (lCpRel,        sCpRel);
	place (lCpMake,       sCpMake);
	place (lLmThresh,     sLmThresh);
	place (lLmRel,        sLmRel);
	place (lDrAmt,        sDrAmt);
	place (lDrMix,        sDrMix);
	place (lGtThresh,     sGtThresh);
	place (lGtAtk,        sGtAtk);
	place (lGtRel,        sGtRel);
	place (lTsRatio,      sTsRatio);
	place (lPtSemis,      sPtSemis);
	place (lPtRatio,      sPtRatio);

	int rightX = gx + gw + 30;
	int panelAreaW = getWidth() - (rightX + 40);
	int panelW = juce::jmin (500, panelAreaW / 2);
	int voicesW = juce::jmin (500, panelAreaW - panelW - 20);
	int totalH = getHeight() - 60;
	int dirsH = totalH / 2;
	int samH  = totalH - dirsH - 10;
	listDirs.setBounds (rightX, 40, panelW, dirsH);
	listSamples.setBounds (rightX, 40 + dirsH + 10, panelW, samH);
	listVoices.setBounds (rightX + panelW + 20, 40, voicesW, totalH);
	logView.setBounds (rightX + panelW + 20 + voicesW + 20, 40, getWidth() - (rightX + panelW + 20 + voicesW + 30), getHeight() - 50);
}

void TestHarnessComponent::comboBoxChanged (juce::ComboBox* c)
{
    if (c != &comboEngine) return;
    if (!audioEngine || controlledVoiceId == 0) return;
    // Send engine selection as a dedicated Update param understood by SampleVoiceProcessor via APVTS
    Command cmd; cmd.type = Command::Type::Update; cmd.voiceId = controlledVoiceId;
    cmd.paramName = "engine"; // mirrored by SampleLoader in Preset Creator
    cmd.paramValue = (float) (comboEngine.getSelectedId() == 2 ? 1.0f : 0.0f); // 0=RB, 1=Naive
    audioEngine->getCommandBus().enqueueLatest (cmd);
    OnScreenLogger::log ("[UI] Engine set to: " + comboEngine.getText());
}

void TestHarnessComponent::buttonClicked (juce::Button* b)
{
    // Ensure the engine is connected before sending any commands
    if (audioEngine == nullptr) {
        OnScreenLogger::log("[UI] ERROR: No AudioEngine connected!");
        return;
    }

    // --- Create Logic ---
    if (b == &btnCreateSynth || b == &btnCreateSample || b == &btnCreateNoise || b == &btnCreateModular)
    {
        Command cmd;
        cmd.type = Command::Type::Create;
        cmd.voiceId = juce::Time::getMillisecondCounterHiRes();

        if (b == &btnCreateSynth) {
            cmd.voiceType = "synth";
            OnScreenLogger::log("[UI] Sending CREATE command for Synth voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateNoise) {
            cmd.voiceType = "noise";
            OnScreenLogger::log("[UI] Sending CREATE command for Noise voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateModular) {
            cmd.voiceType = "modular";
            OnScreenLogger::log("[UI] Sending CREATE command for Modular voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateSample) {
            if (selectedSampleIndex >= 0 && selectedSampleIndex < samplePaths.size()) {
                cmd.voiceType = "sample";
                cmd.resourceName = samplePaths[(int)selectedSampleIndex].getFullPathName();
                OnScreenLogger::log("[UI] Sending CREATE command for Sample voice: " + cmd.resourceName);
                audioEngine->getCommandBus().enqueue(cmd);
            } else {
                OnScreenLogger::log("[UI] No sample selected. Cannot create sample voice.");
            }
        }
    }
    // --- Load Preset for Modular ---
    else if (b == &btnLoadPreset)
    {
        // 1. Check if a voice is selected.
        if (controlledVoiceId == 0)
        {
            OnScreenLogger::log("[UI] ERROR: No voice selected to load preset into.");
            return;
        }

        // 2. Verify that the selected voice is a Modular voice.
        bool isModular = false;
        for (const auto& voiceInfo : engineVoices)
        {
            if (voiceInfo.voiceId == controlledVoiceId && voiceInfo.voiceType == "Modular")
            {
                isModular = true;
                break;
            }
        }

        if (!isModular)
        {
            OnScreenLogger::log("[UI] ERROR: The selected voice is not a Modular Synth.");
            return;
        }

        // 3. Launch the file chooser.
        loadChooser = std::make_unique<juce::FileChooser>("Load Modular Preset", juce::File{}, "*.xml");
        auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

        loadChooser->launchAsync(chooserFlags, [this](const juce::FileChooser& fc)
        {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                // 4. Read file content and create the command.
                Command cmd;
                cmd.type = Command::Type::LoadPreset;
                cmd.voiceId = controlledVoiceId;
                cmd.presetData = f.loadFileAsString();

                // 5. Send the command to the engine.
                if (audioEngine)
                {
                    audioEngine->getCommandBus().enqueue(cmd);
                    OnScreenLogger::log("[UI] Sent LoadPreset command for voice " + juce::String((juce::int64)controlledVoiceId));
                }
            }
        });
    }

    // --- Destroy Logic ---
    else if (b == &btnDestroySelected || b == &btnDestroy) // Treat "Destroy" and "Destroy Selected" as the same action
    {
        if (controlledVoiceId != 0) {
            Command cmd;
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = controlledVoiceId;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI] Sending DESTROY command for selected voice ID: " + juce::String((juce::int64)controlledVoiceId));
            controlledVoiceId = 0; // De-select the voice since it's being deleted
        } else {
            OnScreenLogger::log("[UI] No voice selected to destroy.");
        }
    }
    // --- Audio Settings Dialog ---
    else if (b == &btnAudioSettings)
    {
        if (audioSetupComp == nullptr)
        {
            audioSetupComp = std::make_unique<juce::AudioDeviceSelectorComponent>(
                deviceManager,
                0, 256,   // min/max inputs
                0, 256,   // min/max outputs
                true, false, false, false);
        }
        audioSetupComp->setSize(500, 450);
        juce::DialogWindow::LaunchOptions o;
        o.content.setOwned(audioSetupComp.get());
        o.content.get()->setSize(500, 450);
        o.dialogTitle = "Audio Settings";
        o.dialogBackgroundColour = juce::Colours::darkgrey;
        o.escapeKeyTriggersCloseButton = true;
        o.resizable = false;
        o.launchAsync();
    }
    else if (b == &btnDestroyRandom)
    {
        if (!engineVoices.empty()) {
            auto& rng = juce::Random::getSystemRandom();
            const int index = rng.nextInt((int)engineVoices.size());
            const juce::uint64 idToDestroy = engineVoices[index].voiceId;
            
            Command cmd;
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = idToDestroy;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI] Sending DESTROY command for random voice ID: " + juce::String((juce::int64)idToDestroy));
            
            if (controlledVoiceId == idToDestroy) {
                controlledVoiceId = 0; // De-select if it was the one deleted
            }
        } else {
            OnScreenLogger::log("[UI] No voices to destroy at random.");
        }
    }
    else
    {
        OnScreenLogger::log("[UI] Button '" + b->getButtonText() + "' is not yet wired to the AudioEngine.");
    }
}

void TestHarnessComponent::sliderValueChanged (juce::Slider* s)
{
    if (isSyncingSliders) return;
    // Ensure the engine is connected before sending any commands
    if (audioEngine == nullptr) {
        OnScreenLogger::log("[UI] ERROR: No AudioEngine connected!");
        return;
    }

    // Create a lambda for sending update commands
    auto set = [this] (const char* id, double v)
    {
        OnScreenLogger::log("[UI LOG] Slider for '" + juce::String(id) + "' was moved.");
        
        if (audioEngine && controlledVoiceId != 0)
        {
            Command cmd;
            cmd.type = Command::Type::Update;
            cmd.voiceId = controlledVoiceId;
            cmd.paramName = id;
            cmd.paramValue = (float)v;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI LOG] Sent UPDATE command for '" + juce::String(id) + "' to AudioEngine.");
        }
        else
        {
            OnScreenLogger::log("[UI LOG] ERROR: No voice selected!");
        }
    };

    if (s == &sliderGain)
    {
        set("gain", sliderGain.getValue());
    }
    else if (s == &sliderPan)
    {
        set("pan", sliderPan.getValue());
    }
    else if (btnManualFx.getToggleState())
    {
        if (s == &sFilterCutoff) set ("filterCutoff", s->getValue());
        else if (s == &sFilterRes) set ("filterResonance", s->getValue());
        else if (s == &sChRate) set ("chorusRate", s->getValue());
        else if (s == &sChDepth) set ("chorusDepth", s->getValue());
        else if (s == &sChMix) set ("chorusMix", s->getValue());
        else if (s == &sPhRate) set ("phaserRate", s->getValue());
        else if (s == &sPhDepth) set ("phaserDepth", s->getValue());
        else if (s == &sPhCentre) set ("phaserCentre", s->getValue());
        else if (s == &sPhFb) set ("phaserFeedback", s->getValue());
        else if (s == &sPhMix) set ("phaserMix", s->getValue());
        else if (s == &sRvRoom) set ("reverbRoom", s->getValue());
        else if (s == &sRvDamp) set ("reverbDamp", s->getValue());
        else if (s == &sRvWidth) set ("reverbWidth", s->getValue());
        else if (s == &sRvMix) set ("reverbMix", s->getValue());
        else if (s == &sDlTime) set ("delayTimeMs", s->getValue());
        else if (s == &sDlFb) set ("delayFeedback", s->getValue());
        else if (s == &sDlMix) set ("delayMix", s->getValue());
        else if (s == &sCpThresh) set ("compThreshold", s->getValue());
        else if (s == &sCpRatio) set ("compRatio", s->getValue());
        else if (s == &sCpAtk) set ("compAttackMs", s->getValue());
        else if (s == &sCpRel) set ("compReleaseMs", s->getValue());
        else if (s == &sCpMake) set ("compMakeup", s->getValue());
        else if (s == &sLmThresh) set ("limitThreshold", s->getValue());
        else if (s == &sLmRel) set ("limitReleaseMs", s->getValue());
        else if (s == &sDrAmt) set ("driveAmount", s->getValue());
        else if (s == &sDrMix) set ("driveMix", s->getValue());
        else if (s == &sGtThresh) set ("gateThreshold", s->getValue());
        else if (s == &sGtAtk) set ("gateAttackMs", s->getValue());
        else if (s == &sGtRel) set ("gateReleaseMs", s->getValue());
        else if (s == &sTsRatio) set ("timeStretchRatio", s->getValue());
        else if (s == &sPtSemis) set ("pitchSemitones", s->getValue());
        else if (s == &sPtRatio) set ("pitchRatio", s->getValue());
    }
}

// --- Sync Timer ---
void TestHarnessComponent::timerCallback()
{
    if (audioEngine)
    {
        auto currentEngineVoices = audioEngine->getActiveVoicesInfo();
        // Check if the list has changed before updating the UI to prevent flickering
        if (currentEngineVoices.size() != engineVoices.size()) // A simple check is enough for now
        {
            engineVoices.clear();
            for (const auto& voice : currentEngineVoices)
            {
                AudioEngine::VoiceInfo info;
                info.voiceId = voice.voiceId;
                info.voiceType = voice.voiceType;
                info.displayName = voice.displayName;
                engineVoices.push_back(info);
            }
            listVoices.updateContent();
            lblVoices.setText("Voices: " + juce::String((int)engineVoices.size()), juce::dontSendNotification);
        }
        
        // Update peak level display
        auto stats = audioEngine->getRuntimeStats();
        lblPeak.setText("Peak: " + juce::String(stats.lastPeak, 3), juce::dontSendNotification);
        
        // Update device info display
        lblDevice.setText("Device: " + juce::String(stats.sampleRate, 0) + "Hz, " + 
                         juce::String(stats.blockSize) + " samples", juce::dontSendNotification);
        
        // Route engine logs to UI
        auto engineLogs = audioEngine->drainLogs();
        for (const auto& log : engineLogs) {
            OnScreenLogger::log(log);
        }
    }
}

void TestHarnessComponent::refreshVoicesList()
{
    listVoices.updateContent();
}

void TestHarnessComponent::syncSlidersWithSelectedVoice()
{
    if (!audioEngine || controlledVoiceId == 0) return;

    isSyncingSliders = true;

    auto syncSlider = [&](juce::Slider& slider, const juce::String& paramId)
    {
        float value = audioEngine->getVoiceParameterValue(controlledVoiceId, paramId);
        slider.setValue(value, juce::dontSendNotification);
    };

    // Core & Time/Pitch
    syncSlider(sliderGain, "gain");
    syncSlider(sliderPan, "pan");
    syncSlider(sTsRatio, "timeStretchRatio");
    syncSlider(sPtSemis, "pitchSemitones");
    syncSlider(sPtRatio, "pitchRatio");

    // Filter
    syncSlider(sFilterCutoff, "filterCutoff");
    syncSlider(sFilterRes,    "filterResonance");

    // Chorus
    syncSlider(sChRate,  "chorusRate");
    syncSlider(sChDepth, "chorusDepth");
    syncSlider(sChMix,   "chorusMix");

    // Phaser
    syncSlider(sPhRate,   "phaserRate");
    syncSlider(sPhDepth,  "phaserDepth");
    syncSlider(sPhCentre, "phaserCentre");
    syncSlider(sPhFb,     "phaserFeedback");
    syncSlider(sPhMix,    "phaserMix");

    // Reverb
    syncSlider(sRvRoom,  "reverbRoom");
    syncSlider(sRvDamp,  "reverbDamp");
    syncSlider(sRvWidth, "reverbWidth");
    syncSlider(sRvMix,   "reverbMix");

    // Delay
    syncSlider(sDlTime, "delayTimeMs");
    syncSlider(sDlFb,   "delayFeedback");
    syncSlider(sDlMix,  "delayMix");

    // Compressor
    syncSlider(sCpThresh, "compThreshold");
    syncSlider(sCpRatio,  "compRatio");
    syncSlider(sCpAtk,    "compAttackMs");
    syncSlider(sCpRel,    "compReleaseMs");
    syncSlider(sCpMake,   "compMakeup");

    // Limiter
    syncSlider(sLmThresh, "limitThreshold");
    syncSlider(sLmRel,    "limitReleaseMs");

    // Drive
    syncSlider(sDrAmt, "driveAmount");
    syncSlider(sDrMix, "driveMix");

    // Gate
    syncSlider(sGtThresh, "gateThreshold");
    syncSlider(sGtAtk,    "gateAttackMs");
    syncSlider(sGtRel,    "gateReleaseMs");

    isSyncingSliders = false;
}

// --- Control Logic ---
void TestHarnessComponent::setControlledVoiceByIndex (int index)
{
    if (index >= 0 && index < (int)engineVoices.size())
    {
        controlledVoiceId = engineVoices[index].voiceId;
        OnScreenLogger::log("[UI] Selected voice ID: " + juce::String((juce::int64)controlledVoiceId));
        syncSlidersWithSelectedVoice(); // Sync UI with voice parameters
    }
    else
    {
        controlledVoiceId = 0;
    }
    lblStatus.setText("Controlling Voice ID: " + (controlledVoiceId != 0 ? juce::String((juce::int64)controlledVoiceId) : "-"), juce::dontSendNotification);
}



================================================================================
FILE: juce\CMakeLists.txt
================================================================================


cmake_minimum_required(VERSION 3.22)
project(ColliderAudioEngine VERSION 0.1.0)

# --- TTS Integration (Piper) ---

# 1. Set paths to pre-built Piper and ONNX Runtime
set(PIPER_DIR "${CMAKE_SOURCE_DIR}/../vendor/piper/piper" CACHE PATH "Path to Piper TTS")
set(ONNXRUNTIME_DIR "${CMAKE_SOURCE_DIR}/../vendor/onnxruntime" CACHE PATH "Path to ONNX Runtime")

if(NOT EXISTS "${PIPER_DIR}")
    message(WARNING "Piper TTS not found at ${PIPER_DIR}. TTS features will be limited.")
endif()

if(NOT EXISTS "${ONNXRUNTIME_DIR}")
    message(WARNING "ONNX Runtime not found at ${ONNXRUNTIME_DIR}. TTS features will be limited.")
endif()

# 2. Add SoundTouch library
set(SOUNDTOUCH_SOURCE_DIR "${CMAKE_SOURCE_DIR}/../soundtouch/source")
add_library(soundtouch STATIC
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/AAFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/BPMDetect.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIFOSampleBuffer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIRFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateCubic.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateLinear.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateShannon.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/PeakFinder.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/RateTransposer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/SoundTouch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/TDStretch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/cpu_detect_x86.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/mmx_optimized.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/sse_optimized.cpp
)
target_include_directories(soundtouch PUBLIC 
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(FetchContent)

# ==============================================================================
# Third-Party Dependencies (Fetch Only)
# ==============================================================================

FetchContent_Declare(JUCE
    GIT_REPOSITORY https://github.com/juce-framework/JUCE.git
    GIT_TAG 7.0.9
)
set(JUCE_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(JUCE_BUILD_EXTRAS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(JUCE)

FetchContent_Declare(imgui_fc
    GIT_REPOSITORY https://github.com/ocornut/imgui.git
    GIT_TAG v1.92.0
)
FetchContent_MakeAvailable(imgui_fc)

# imnodes uses find_package(imgui) in its CMake; build as sources instead
FetchContent_Declare(imnodes_fc
    GIT_REPOSITORY https://github.com/Nelarius/imnodes.git
    GIT_TAG b2ec254ce576ac3d42dfb7aef61deadbff8e7211
)
FetchContent_GetProperties(imnodes_fc)
if(NOT imnodes_fc_POPULATED)
  FetchContent_Populate(imnodes_fc)
endif()

# imgui_juce backend (dedicated JUCE bridge for ImGui)
FetchContent_Declare(imgui_juce_fc
    GIT_REPOSITORY https://github.com/Krasjet/imgui_juce.git
    GIT_TAG master
)
FetchContent_MakeAvailable(imgui_juce_fc)

# --------------------------------------------------------------
# Box2D (2D physics engine for physics-based audio module)
# --------------------------------------------------------------
FetchContent_Declare(box2d_fc
    GIT_REPOSITORY https://github.com/erincatto/box2d.git
    GIT_TAG v2.4.1
)
set(BOX2D_BUILD_UNIT_TESTS OFF CACHE BOOL "" FORCE)
set(BOX2D_BUILD_TESTBED OFF CACHE BOOL "" FORCE)
set(BOX2D_BUILD_DOCS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(box2d_fc)

# --------------------------------------------------------------
# GLM (OpenGL Mathematics library for 3D vector/matrix math)
# --------------------------------------------------------------
FetchContent_Declare(
  glm
  GIT_REPOSITORY https://github.com/g-truc/glm.git
  GIT_TAG        1.0.1 # Latest stable version
)
FetchContent_MakeAvailable(glm)

# --------------------------------------------------------------
# nlohmann/json (required by tinygltf)
# --------------------------------------------------------------
FetchContent_Declare(
  nlohmann_json
  GIT_REPOSITORY https://github.com/nlohmann/json.git
  GIT_TAG        v3.11.3 # A recent stable version
)
FetchContent_MakeAvailable(nlohmann_json)

# --------------------------------------------------------------
# tinygltf (glTF 2.0 file loader for animation system)
# --------------------------------------------------------------
FetchContent_Declare(
  tinygltf
  GIT_REPOSITORY https://github.com/syoyo/tinygltf.git
  GIT_TAG        v2.8.20 # A recent stable version
)
FetchContent_MakeAvailable(tinygltf)

# --------------------------------------------------------------
# ufbx (FBX file loader for animation system)
# --------------------------------------------------------------
FetchContent_Declare(
  ufbx
  GIT_REPOSITORY https://github.com/ufbx/ufbx.git
  GIT_TAG        v0.10.0 # A recent stable version of ufbx
)
FetchContent_MakeAvailable(ufbx)

# Get the path to the downloaded ufbx source code
FetchContent_GetProperties(ufbx SOURCE_DIR ufbx_SOURCE_DIR)

# Create a dedicated static library target for ufbx (single-header library needs separate compilation unit)
add_library(ufbx_static STATIC ${ufbx_SOURCE_DIR}/ufbx.c)
target_include_directories(ufbx_static PUBLIC ${ufbx_SOURCE_DIR})

# --------------------------------------------------------------
# Rubber Band (optional, real-time timestretcher/pitch-shifter)
# --------------------------------------------------------------
set(USE_RUBBERBAND ON CACHE BOOL "Enable Rubber Band time/pitch processing")
if (USE_RUBBERBAND)
  FetchContent_Declare(rubberband_fc
    GIT_REPOSITORY https://github.com/breakfastquay/rubberband.git
    GIT_TAG v3.3.0
  )
  FetchContent_MakeAvailable(rubberband_fc)
  # Build from single-file amalgamation to avoid external link issues
  # Use official amalgamated single-file build (works cross-platform)
  add_library(rubberband_single STATIC
    ${rubberband_fc_SOURCE_DIR}/single/RubberBandSingle.cpp
  )
  target_include_directories(rubberband_single PUBLIC
    ${rubberband_fc_SOURCE_DIR}
    ${rubberband_fc_SOURCE_DIR}/single
  )
  target_compile_definitions(rubberband_single PUBLIC
    NOMINMAX
    _USE_MATH_DEFINES
    RUBBERBAND_USE_R3=1
    RUBBERBAND_BUILD_FFT=KISSFFT
    RUBBERBAND_BUILD_RESAMPLER=NONE
  )
  set(RUBBERBAND_TARGET rubberband_single)
  set(RUBBERBAND_INCLUDE_DIR "${rubberband_fc_SOURCE_DIR}")
endif()

# ==============================================================================
# Main Engine App Target (Unchanged)
# ==============================================================================
juce_add_gui_app(ColliderApp
    PRODUCT_NAME "Collider Audio Engine"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(ColliderApp PRIVATE
    Source/main.cpp
    Source/app/MainApplication.cpp
    Source/app/MainApplication.h
    Source/ui/MainComponent.cpp
    Source/ui/MainComponent.h
    Source/ui/TestHarnessComponent.cpp
    Source/ui/TestHarnessComponent.h
    Source/ui/VisualiserComponent.cpp
    Source/ui/VisualiserComponent.h
    Source/ui/DebugInfo.h
    Source/audio/AudioEngine.h
    Source/audio/AudioEngine.cpp
    Source/audio/MidiDeviceManager.h
    Source/audio/MidiDeviceManager.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/voices/SynthVoiceProcessor.h
    Source/audio/voices/SynthVoiceProcessor.cpp
    Source/audio/voices/NoiseVoiceProcessor.h
    Source/audio/voices/NoiseVoiceProcessor.cpp
    Source/audio/voices/ModularVoice.h
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/fx/FXChain.h
    Source/audio/fx/GainProcessor.h
    Source/audio/fx/GainProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/ModuleProcessor.cpp
    Source/audio/modules/AudioInputModuleProcessor.h
    Source/audio/modules/AudioInputModuleProcessor.cpp
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/CVMixerModuleProcessor.h
    Source/audio/modules/CVMixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MultiSequencerModuleProcessor.h
    Source/audio/modules/MultiSequencerModuleProcessor.cpp
    Source/audio/modules/LagProcessorModuleProcessor.h
    Source/audio/modules/LagProcessorModuleProcessor.cpp
    Source/audio/modules/DeCrackleModuleProcessor.h
    Source/audio/modules/DeCrackleModuleProcessor.cpp
    Source/audio/modules/GraphicEQModuleProcessor.h
    Source/audio/modules/GraphicEQModuleProcessor.cpp
    Source/audio/modules/FrequencyGraphModuleProcessor.h
    Source/audio/modules/FrequencyGraphModuleProcessor.cpp
    Source/audio/modules/ChorusModuleProcessor.h
    Source/audio/modules/ChorusModuleProcessor.cpp
    Source/audio/modules/PhaserModuleProcessor.h
    Source/audio/modules/PhaserModuleProcessor.cpp
    Source/audio/modules/CompressorModuleProcessor.h
    Source/audio/modules/CompressorModuleProcessor.cpp
    Source/audio/modules/RecordModuleProcessor.h
    Source/audio/modules/RecordModuleProcessor.cpp
    Source/audio/modules/CommentModuleProcessor.h
    Source/audio/modules/CommentModuleProcessor.cpp
    Source/audio/modules/LimiterModuleProcessor.h
    Source/audio/modules/LimiterModuleProcessor.cpp
    Source/audio/modules/GateModuleProcessor.h
    Source/audio/modules/GateModuleProcessor.cpp
    Source/audio/modules/DriveModuleProcessor.h
    Source/audio/modules/DriveModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/ComparatorModuleProcessor.h
    Source/audio/modules/ComparatorModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/MultiBandShaperModuleProcessor.h
    Source/audio/modules/MultiBandShaperModuleProcessor.cpp
    Source/audio/modules/GranulatorModuleProcessor.h
    Source/audio/modules/GranulatorModuleProcessor.cpp
    Source/audio/modules/HarmonicShaperModuleProcessor.h
    Source/audio/modules/HarmonicShaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
    Source/audio/modules/TimePitchModuleProcessor.h
    Source/audio/modules/TimePitchModuleProcessor.cpp
    Source/audio/modules/MIDIPlayerModuleProcessor.h
    Source/audio/modules/MIDIPlayerModuleProcessor.cpp
        Source/audio/modules/TrackMixerModuleProcessor.h
        Source/audio/modules/TrackMixerModuleProcessor.cpp
    Source/audio/modules/PolyVCOModuleProcessor.h
    Source/audio/modules/PolyVCOModuleProcessor.cpp
        Source/audio/modules/DebugModuleProcessor.h
        Source/audio/modules/DebugModuleProcessor.cpp
        Source/audio/modules/CommentModuleProcessor.h
        Source/audio/modules/CommentModuleProcessor.cpp
        Source/audio/modules/InputDebugModuleProcessor.h
        Source/audio/modules/InputDebugModuleProcessor.cpp
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/TimingData.h
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/FunctionGeneratorModuleProcessor.h
    Source/audio/modules/FunctionGeneratorModuleProcessor.cpp
    Source/audio/modules/BestPracticeNodeProcessor.h
    Source/audio/modules/BestPracticeNodeProcessor.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/modules/VstHostModuleProcessor.h
    Source/audio/modules/VstHostModuleProcessor.cpp
    Source/audio/modules/ShapingOscillatorModuleProcessor.h
    Source/audio/modules/ShapingOscillatorModuleProcessor.cpp
    Source/audio/modules/InletModuleProcessor.h
    Source/audio/modules/InletModuleProcessor.cpp
    Source/audio/modules/OutletModuleProcessor.h
    Source/audio/modules/OutletModuleProcessor.cpp
    Source/audio/modules/MetaModuleProcessor.h
    Source/audio/modules/MetaModuleProcessor.cpp
    Source/audio/modules/SnapshotSequencerModuleProcessor.h
    Source/audio/modules/SnapshotSequencerModuleProcessor.cpp
    Source/audio/modules/MIDICVModuleProcessor.h
    Source/audio/modules/MIDICVModuleProcessor.cpp
    Source/audio/modules/MIDIFadersModuleProcessor.h
    Source/audio/modules/MIDIFadersModuleProcessor.cpp
    Source/audio/modules/MIDIKnobsModuleProcessor.h
    Source/audio/modules/MIDIKnobsModuleProcessor.cpp
    Source/audio/modules/MIDIButtonsModuleProcessor.h
    Source/audio/modules/MIDIButtonsModuleProcessor.cpp
    Source/audio/modules/MIDIJogWheelModuleProcessor.h
    Source/audio/modules/MIDIJogWheelModuleProcessor.cpp
    Source/audio/modules/MIDIPadModuleProcessor.h
    Source/audio/modules/MIDIPadModuleProcessor.cpp
    Source/audio/modules/MidiLoggerModuleProcessor.h
    Source/audio/modules/MidiLoggerModuleProcessor.cpp
    Source/audio/modules/TempoClockModuleProcessor.h
    Source/audio/modules/TempoClockModuleProcessor.cpp
    Source/audio/modules/PhysicsModuleProcessor.h
    Source/audio/modules/PhysicsModuleProcessor.cpp
    Source/audio/modules/StrokeSequencerModuleProcessor.h
    Source/audio/modules/StrokeSequencerModuleProcessor.cpp
    Source/audio/modules/AnimationModuleProcessor.h
    Source/audio/modules/AnimationModuleProcessor.cpp
    Source/animation/AnimationData.h
    Source/animation/RawAnimationData.h
    Source/animation/RawAnimationData.cpp
    Source/animation/AnimationBinder.h
    Source/animation/AnimationBinder.cpp
    Source/animation/Animator.h
    Source/animation/Animator.cpp
    Source/animation/AnimationFileLoader.h
    Source/animation/AnimationFileLoader.cpp
    Source/animation/GltfLoader.h
    Source/animation/GltfLoader.cpp
    Source/animation/FbxLoader.h
    Source/animation/FbxLoader.cpp
    Source/animation/AnimationRenderer.h
    Source/animation/AnimationRenderer.cpp
    Source/ipc/IpcServer.cpp
    Source/ipc/IpcServer.h
    Source/ipc/OscClient.h
    Source/ipc/CommandBus.cpp
    Source/ipc/CommandBus.h
    Source/audio/utils/VoiceDeletionUtils.h
    Source/audio/dsp/TimePitchProcessor.h
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
)

target_compile_definitions(ColliderApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:ColliderApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:ColliderApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    JUCE_PLUGINHOST_VST3=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
)

target_link_libraries(ColliderApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    juce::juce_osc
    soundtouch
    box2d
    glm::glm
    tinygltf
    ufbx_static
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
    # Piper TTS libraries (pre-built)
    ${ONNXRUNTIME_DIR}/lib/onnxruntime.lib
)

# Add include directories for ColliderApp
target_include_directories(ColliderApp PRIVATE
    ${PIPER_DIR}
    ${ONNXRUNTIME_DIR}/include
    ${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64/samples/cpp/thirdparty/nlohmann_json/single_include
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    ${ufbx_SOURCE_DIR}
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# ==============================================================================
# Preset Creator App Target (Final Corrected Version)
# ==============================================================================

juce_add_gui_app(PresetCreatorApp
    PRODUCT_NAME "Preset Creator"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(PresetCreatorApp PRIVATE
    # Your application sources
    Source/preset_creator/PresetCreatorMain.cpp
    Source/preset_creator/PinDatabase.h
    Source/preset_creator/PinDatabase.cpp
    Source/preset_creator/ImGuiNodeEditorComponent.h
    Source/preset_creator/ImGuiNodeEditorComponent.cpp
    Source/preset_creator/PresetCreatorComponent.h
    Source/preset_creator/PresetCreatorComponent.cpp
    Source/preset_creator/ControllerPresetManager.h
    Source/preset_creator/ControllerPresetManager.cpp

    # Add ImGui, imnodes, and the backend DIRECTLY as source files
    ${imgui_fc_SOURCE_DIR}/imgui.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_widgets.cpp
    ${imgui_fc_SOURCE_DIR}/backends/imgui_impl_opengl2.cpp
    ${imnodes_fc_SOURCE_DIR}/imnodes.cpp

    # Your other reused engine modules
    Source/audio/MidiDeviceManager.h
    Source/audio/MidiDeviceManager.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/ModuleProcessor.cpp
    Source/audio/modules/AudioInputModuleProcessor.h
    Source/audio/modules/AudioInputModuleProcessor.cpp
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/CVMixerModuleProcessor.h
    Source/audio/modules/CVMixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/ComparatorModuleProcessor.h
    Source/audio/modules/ComparatorModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/MultiBandShaperModuleProcessor.h
    Source/audio/modules/MultiBandShaperModuleProcessor.cpp
    Source/audio/modules/GranulatorModuleProcessor.h
    Source/audio/modules/GranulatorModuleProcessor.cpp
    Source/audio/modules/HarmonicShaperModuleProcessor.h
    Source/audio/modules/HarmonicShaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
        Source/audio/modules/DebugModuleProcessor.h
        Source/audio/modules/DebugModuleProcessor.cpp
        Source/audio/modules/CommentModuleProcessor.h
        Source/audio/modules/CommentModuleProcessor.cpp
        Source/audio/modules/InputDebugModuleProcessor.h
        Source/audio/modules/InputDebugModuleProcessor.cpp
    Source/audio/modules/TimePitchModuleProcessor.h
    Source/audio/modules/TimePitchModuleProcessor.cpp
    Source/audio/modules/MIDIPlayerModuleProcessor.h
    Source/audio/modules/MIDIPlayerModuleProcessor.cpp
        Source/audio/modules/TrackMixerModuleProcessor.h
        Source/audio/modules/TrackMixerModuleProcessor.cpp
    Source/audio/modules/PolyVCOModuleProcessor.h
    Source/audio/modules/PolyVCOModuleProcessor.cpp
    
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/TimingData.h
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/FunctionGeneratorModuleProcessor.h
    Source/audio/modules/FunctionGeneratorModuleProcessor.cpp
    Source/audio/modules/BestPracticeNodeProcessor.h
    Source/audio/modules/BestPracticeNodeProcessor.cpp
    Source/audio/modules/ShapingOscillatorModuleProcessor.h
    Source/audio/modules/ShapingOscillatorModuleProcessor.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/modules/VstHostModuleProcessor.h
    Source/audio/modules/VstHostModuleProcessor.cpp
    Source/audio/modules/MultiSequencerModuleProcessor.h
    Source/audio/modules/MultiSequencerModuleProcessor.cpp
    Source/audio/modules/LagProcessorModuleProcessor.h
    Source/audio/modules/LagProcessorModuleProcessor.cpp
    Source/audio/modules/DeCrackleModuleProcessor.h
    Source/audio/modules/DeCrackleModuleProcessor.cpp
    Source/audio/modules/GraphicEQModuleProcessor.h
    Source/audio/modules/GraphicEQModuleProcessor.cpp
    Source/audio/modules/FrequencyGraphModuleProcessor.h
    Source/audio/modules/FrequencyGraphModuleProcessor.cpp
    Source/audio/modules/ChorusModuleProcessor.h
    Source/audio/modules/ChorusModuleProcessor.cpp
    Source/audio/modules/PhaserModuleProcessor.h
    Source/audio/modules/PhaserModuleProcessor.cpp
    Source/audio/modules/CompressorModuleProcessor.h
    Source/audio/modules/CompressorModuleProcessor.cpp
    Source/audio/modules/RecordModuleProcessor.h
    Source/audio/modules/RecordModuleProcessor.cpp
    Source/audio/modules/CommentModuleProcessor.h
    Source/audio/modules/CommentModuleProcessor.cpp
    Source/audio/modules/LimiterModuleProcessor.h
    Source/audio/modules/LimiterModuleProcessor.cpp
    Source/audio/modules/GateModuleProcessor.h
    Source/audio/modules/GateModuleProcessor.cpp
    Source/audio/modules/DriveModuleProcessor.h
    Source/audio/modules/DriveModuleProcessor.cpp
    Source/audio/modules/InletModuleProcessor.h
    Source/audio/modules/InletModuleProcessor.cpp
    Source/audio/modules/OutletModuleProcessor.h
    Source/audio/modules/OutletModuleProcessor.cpp
    Source/audio/modules/MetaModuleProcessor.h
    Source/audio/modules/MetaModuleProcessor.cpp
    Source/audio/modules/SnapshotSequencerModuleProcessor.h
    Source/audio/modules/SnapshotSequencerModuleProcessor.cpp
    Source/audio/modules/MIDICVModuleProcessor.h
    Source/audio/modules/MIDICVModuleProcessor.cpp
    Source/audio/modules/MIDIFadersModuleProcessor.h
    Source/audio/modules/MIDIFadersModuleProcessor.cpp
    Source/audio/modules/MIDIKnobsModuleProcessor.h
    Source/audio/modules/MIDIKnobsModuleProcessor.cpp
    Source/audio/modules/MIDIButtonsModuleProcessor.h
    Source/audio/modules/MIDIButtonsModuleProcessor.cpp
    Source/audio/modules/MIDIJogWheelModuleProcessor.h
    Source/audio/modules/MIDIJogWheelModuleProcessor.cpp
    Source/audio/modules/MIDIPadModuleProcessor.h
    Source/audio/modules/MIDIPadModuleProcessor.cpp
    Source/audio/modules/MidiLoggerModuleProcessor.h
    Source/audio/modules/MidiLoggerModuleProcessor.cpp
    Source/audio/modules/TempoClockModuleProcessor.h
    Source/audio/modules/TempoClockModuleProcessor.cpp
    Source/audio/modules/PhysicsModuleProcessor.h
    Source/audio/modules/PhysicsModuleProcessor.cpp
    Source/audio/modules/StrokeSequencerModuleProcessor.h
    Source/audio/modules/StrokeSequencerModuleProcessor.cpp
    Source/audio/modules/AnimationModuleProcessor.h
    Source/audio/modules/AnimationModuleProcessor.cpp
    Source/animation/AnimationData.h
    Source/animation/RawAnimationData.h
    Source/animation/RawAnimationData.cpp
    Source/animation/AnimationBinder.h
    Source/animation/AnimationBinder.cpp
    Source/animation/Animator.h
    Source/animation/Animator.cpp
    Source/animation/AnimationFileLoader.h
    Source/animation/AnimationFileLoader.cpp
    Source/animation/GltfLoader.h
    Source/animation/GltfLoader.cpp
    Source/animation/FbxLoader.h
    Source/animation/FbxLoader.cpp
    Source/animation/AnimationRenderer.h
    Source/animation/AnimationRenderer.cpp
)

# This target now needs to know where to find all the headers
target_include_directories(PresetCreatorApp PRIVATE
    ${imgui_fc_SOURCE_DIR}
    ${imgui_fc_SOURCE_DIR}/backends
    ${imnodes_fc_SOURCE_DIR}
    ${imgui_juce_fc_SOURCE_DIR}
    ${PIPER_DIR}
    ${ONNXRUNTIME_DIR}/include
    ${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64/samples/cpp/thirdparty/nlohmann_json/single_include
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    ${ufbx_SOURCE_DIR}
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# This target also needs the compile definitions
target_compile_definitions(PresetCreatorApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:PresetCreatorApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:PresetCreatorApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    JUCE_PLUGINHOST_VST3=1
    IMGUI_IMPL_JUCE_BEZEL=0
    IMGUI_DEFINE_MATH_OPERATORS
    IMNODES_NAMESPACE=ImNodes
    IMNODES_STATIC_DEFINE
    PRESET_CREATOR_UI=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
)

target_link_libraries(PresetCreatorApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_devices
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    imgui_impl_juce
    soundtouch
    box2d
    glm::glm
    tinygltf
    ufbx_static
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
    # Piper TTS libraries (pre-built)
    ${ONNXRUNTIME_DIR}/lib/onnxruntime.lib
)

if(WIN32)
    # Copy Piper executable and DLLs to output directories
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper.exe"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper_phonemize.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/espeak-ng.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime_providers_shared.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${PIPER_DIR}/espeak-ng-data"
                "$<TARGET_FILE_DIR:ColliderApp>/espeak-ng-data"
        COMMENT "Copying Piper TTS runtime files to ColliderApp output directory"
    )
    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper.exe"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper_phonemize.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/espeak-ng.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime_providers_shared.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${PIPER_DIR}/espeak-ng-data"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/espeak-ng-data"
        COMMENT "Copying Piper TTS runtime files to PresetCreatorApp output directory"
    )
endif()


================================================================================
FILE: guides\IMGUI_NODE_DESIGN_GUIDE.md
================================================================================


# 📐 ImGui Node UI Design Guide

**Version**: 2.3.2  
**Last Updated**: 2025-10-24  
**Based on**: `imgui_demo.cpp` best practices + **official imnodes examples**

---

## 🎯 Purpose

This guide documents proven UI patterns for designing professional, consistent, and user-friendly node interfaces in our modular synth environment. All patterns are derived from `imgui_demo.cpp` and real-world refinement.

**Golden Rule**: *Every UI element must respect node boundaries and provide clear, immediate feedback to the user.*

---

## 📏 1. Node Layout & Structure

### 1.1 Item Width Management

**Rule**: Always respect the `itemWidth` parameter passed to `drawParametersInNode()`.

```cpp
void drawParametersInNode(float itemWidth, ...) override
{
    ImGui::PushItemWidth(itemWidth);
    
    // All controls here...
    
    ImGui::PopItemWidth();
}
```

**Why**: This ensures controls don't overflow node boundaries.

---

### 1.2 Section Separators (CRITICAL!)

**❌ NEVER USE** `ImGui::Separator()` or `ImGui::SeparatorText()` inside nodes!

These functions consume full available width and **extend beyond node boundaries**, creating visual glitches.

**✅ CORRECT APPROACH**:

```cpp
// Option 1: Simple text title + spacing
ImGui::Text("Section Name");
ImGui::Spacing();

// Option 2: Color-coded section title (preferred)
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Section Name");
ImGui::Spacing();

// Option 3: Custom separator (advanced)
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 pos = ImGui::GetCursorScreenPos();
ImVec2 lineEnd = ImVec2(pos.x + itemWidth, pos.y);
drawList->AddLine(pos, lineEnd, IM_COL32(100, 100, 100, 255), 1.0f);
ImGui::Dummy(ImVec2(0, 1)); // Reserve space for line
ImGui::Spacing();
```

**Reference**: See `MIDIFadersModuleProcessor.cpp` lines 180-185 for working examples.

---

### 1.3 Vertical Spacing

**Best Practice**: Use `ImGui::Spacing()` liberally for visual breathing room.

```cpp
// Between major sections
ImGui::Spacing();
ImGui::Spacing();

// Between related controls
ImGui::Spacing();
```

**From imgui_demo.cpp**: Consistent spacing improves readability significantly.

---

## 🎨 2. Visual Feedback & Indicators

### 2.1 Color-Coded Modulation States

**Pattern**: Use distinct colors to show when parameters are under CV control.

```cpp
const bool isModulated = isParamModulated(paramId);

if (isModulated)
{
    // Cyan for CV modulation
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
}

if (isModulated) ImGui::BeginDisabled();
// ... slider/control here ...
if (isModulated) ImGui::EndDisabled();

if (isModulated) ImGui::PopStyleColor(3);
```

**Color Scheme**:
- **Cyan** (0.4, 0.8, 1.0): Frequency/Pitch modulation
- **Orange** (1.0, 0.8, 0.4): Timbre/Waveform modulation
- **Magenta** (1.0, 0.4, 1.0): Amplitude/Level modulation
- **Green** (0.4, 1.0, 0.4): Filter/EQ modulation

**Reference**: `VCOModuleProcessor.h` lines 59-64, 151-155

---

### 2.2 Real-Time Meters & Displays

**Pattern**: Use `ImGui::ProgressBar()` for level meters with color coding.

```cpp
float level = lastOutputValues[0]->load();
float absLevel = std::abs(level);

// Color-coded by level
ImVec4 meterColor;
if (absLevel < 0.7f)
    meterColor = ImVec4(0.2f, 0.8f, 0.2f, 1.0f); // Green (safe)
else if (absLevel < 0.9f)
    meterColor = ImVec4(0.9f, 0.7f, 0.0f, 1.0f); // Yellow (hot)
else
    meterColor = ImVec4(0.9f, 0.2f, 0.2f, 1.0f); // Red (clipping!)

ImGui::PushStyleColor(ImGuiCol_PlotHistogram, meterColor);
ImGui::ProgressBar(absLevel, ImVec2(itemWidth, 0), "");
ImGui::PopStyleColor();

ImGui::SameLine(0, 5);
ImGui::Text("%.3f", level);
```

**Reference**: `VCOModuleProcessor.h` lines 202-213

---

### 2.3 Waveform/Data Visualization

**Pattern**: Use `ImGui::PlotLines()` for waveform previews.

```cpp
float waveformData[128];
// ... populate waveformData ...

ImGui::PlotLines(
    "##wavepreview",           // Hidden label (## prefix)
    waveformData,              // Data array
    128,                       // Array size
    0,                         // Values offset
    nullptr,                   // Overlay text
    -1.2f,                     // Scale min
    1.2f,                      // Scale max
    ImVec2(itemWidth, 80)      // Size
);
```

**From imgui_demo.cpp**: Lines 1982-1985, 2012-2013

**Reference**: `VCOModuleProcessor.h` lines 178-192

---

## 💡 3. Tooltips & Help System

### 3.1 HelpMarker Function (Standard)

**REQUIRED**: Implement this helper in every `drawParametersInNode()`:

```cpp
auto HelpMarker = [](const char* desc)
{
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
};
```

**From imgui_demo.cpp**: Lines 273-282

**Usage**:
```cpp
ImGui::SliderFloat("Frequency", &freq, 20.0f, 20000.0f);
HelpMarker("Sets the fundamental frequency.\nCan be modulated by CV input.");
```

---

### 3.2 Tooltip Best Practices

**Do**:
- ✅ Explain what the parameter does
- ✅ Mention CV modulation behavior
- ✅ Provide typical ranges or values
- ✅ Use `\n` for multi-line explanations

**Don't**:
- ❌ Write essays (keep under 3 lines)
- ❌ Repeat the obvious
- ❌ Forget to call `HelpMarker()` after EVERY control

**Reference**: `VCOModuleProcessor.h` lines 85, 175, 217

---

## 🎛️ 4. Control Patterns

### 4.1 Slider with Label Pattern

**Standard**:
```cpp
if (ImGui::SliderFloat("##paramId", &value, min, max, "%.1f", flags))
{
    if (!isModulated)
        *apvtsParam = value;
}
if (ImGui::IsItemDeactivatedAfterEdit())
    onModificationEnded();

ImGui::SameLine();
ImGui::Text("Parameter Name");
HelpMarker("Description here");
```

**Why separate label?**: Allows color-coding the text independently of the slider.

---

### 4.2 Quick Preset Buttons

**Pattern**: Provide common values as one-click buttons.

```cpp
ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 4));
float btnWidth = (itemWidth - 12) / 4.0f;  // 4 buttons with spacing

if (ImGui::Button("A4", ImVec2(btnWidth, 0)))
{
    *frequencyParam = 440.0f;
    onModificationEnded();
}
if (ImGui::IsItemHovered())
    ImGui::SetTooltip("440 Hz (Concert A)");

ImGui::SameLine();
// ... more buttons ...

ImGui::PopStyleVar();
```

**Reference**: `VCOModuleProcessor.h` lines 103-140

---

### 4.3 Combo Box (Dropdown) Pattern

```cpp
const char* items[] = { "Option 1", "Option 2", "Option 3" };
int currentItem = 0;

if (ImGui::Combo("##comboId", &currentItem, items, IM_ARRAYSIZE(items)))
{
    *apvtsParam = currentItem;
}
if (ImGui::IsItemDeactivatedAfterEdit())
    onModificationEnded();

ImGui::SameLine();
ImGui::Text("Selector Name");
HelpMarker("Choose from available options");
```

---

## 🔄 5. Tables & Multi-Control Layouts

### 5.1 Table Flags (From MIDI Modules Experience)

**REQUIRED FLAGS**:
```cpp
ImGuiTableFlags flags = 
    ImGuiTableFlags_SizingFixedFit |    // Fixed column widths
    ImGuiTableFlags_NoHostExtendX |     // Don't extend beyond itemWidth
    ImGuiTableFlags_Borders |           // Show cell borders
    ImGuiTableFlags_RowBg;              // Alternating row colors

if (ImGui::BeginTable("##tableId", numColumns, flags))
{
    // Setup columns with FIXED width
    ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_WidthFixed, 120.0f);
    // ... content ...
    ImGui::EndTable();
}
```

**Critical**: ALL columns must use `ImGuiTableColumnFlags_WidthFixed` when using `NoHostExtendX`.

**Reference**: `MIDIFadersModuleProcessor.cpp` table implementation (lines ~400-500)

---

### 5.2 Button Grids

**Pattern**: Use calculated widths for perfect alignment.

```cpp
float spacing = 4.0f;
float btnWidth = (itemWidth - spacing * (numButtons - 1)) / numButtons;

ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

for (int i = 0; i < numButtons; ++i)
{
    if (i > 0) ImGui::SameLine();
    
    ImGui::PushID(i);  // CRITICAL for unique IDs!
    if (ImGui::Button("Button", ImVec2(btnWidth, 0)))
    {
        // Action
    }
    ImGui::PopID();
}

ImGui::PopStyleVar();
```

---

## 🆔 6. ID Management

### 6.1 Unique IDs Rule

**Every widget must have a unique ImGui ID!**

**Methods**:

1. **Hidden Label Suffix** (`##`):
```cpp
ImGui::SliderFloat("##freq", &freq, ...);  // ID = "##freq"
ImGui::SameLine();
ImGui::Text("Frequency");  // Visible label separate
```

2. **Push/Pop ID Scope**:
```cpp
for (int i = 0; i < count; ++i)
{
    ImGui::PushID(i);
    ImGui::Button("Learn");  // Unique ID: "Learn/0", "Learn/1", etc.
    ImGui::PopID();
}
```

3. **String ID in Popups/Combos**:
```cpp
ImGui::OpenPopup("SavePreset##nodeId");  // Unique per node
```

**From imgui_demo.cpp**: ID management examples throughout, especially lines 1000-1200 (widgets section)

---

## 🎨 7. Custom Drawing (Advanced)

### 7.1 Circular Indicators (Jog Wheel Pattern)

```cpp
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 center = ImGui::GetCursorScreenPos();
center.x += itemWidth * 0.5f;
center.y += 80.0f;

float radius = 40.0f;

// Background circle
drawList->AddCircle(center, radius, IM_COL32(100, 100, 100, 255), 32, 2.0f);

// Indicator needle
float angle = value * 2.0f * M_PI;  // Convert value to radians
ImVec2 needleEnd(
    center.x + std::cos(angle - M_PI / 2.0f) * (radius - 5.0f),
    center.y + std::sin(angle - M_PI / 2.0f) * (radius - 5.0f)
);

drawList->AddLine(center, needleEnd, IM_COL32(100, 200, 255, 255), 3.0f);
drawList->AddCircleFilled(center, 4.0f, IM_COL32(100, 200, 255, 255));

ImGui::Dummy(ImVec2(itemWidth, 160));  // Reserve space
```

**Reference**: `MIDIJogWheelModuleProcessor.cpp` lines 310-340

---

### 7.2 Clipping Regions

**Pattern**: Constrain drawing to specific area.

```cpp
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 pos = ImGui::GetCursorScreenPos();
ImVec2 size(itemWidth, 100);

drawList->PushClipRect(pos, ImVec2(pos.x + size.x, pos.y + size.y), true);
// ... drawing code ...
drawList->PopClipRect();
```

**From imgui_demo.cpp**: Lines 6800-6850 (custom rendering examples)

---

## 📦 8. Complete Node Template

```cpp
#if defined(PRESET_CREATOR_UI)
void drawParametersInNode(float itemWidth,
                          const std::function<bool(const juce::String&)>& isParamModulated,
                          const std::function<void()>& onModificationEnded) override
{
    // 1. HelpMarker helper
    auto HelpMarker = [](const char* desc)
    {
        ImGui::SameLine();
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip())
        {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    ImGui::PushItemWidth(itemWidth);

    // 2. Section 1: Main Controls
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Main Controls");
    ImGui::Spacing();
    
    // 3. Modulation-aware slider
    const bool isModulated = isParamModulated("param1");
    
    if (isModulated)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
    }
    
    if (isModulated) ImGui::BeginDisabled();
    
    float param1 = param1Param->load();
    if (ImGui::SliderFloat("##param1", &param1, 0.0f, 1.0f))
    {
        if (!isModulated)
            *param1Param = param1;
    }
    if (ImGui::IsItemDeactivatedAfterEdit())
        onModificationEnded();
    
    if (isModulated) ImGui::EndDisabled();
    
    ImGui::SameLine();
    if (isModulated)
    {
        ImGui::TextColored(ImVec4(0.4f, 0.8f, 1.0f, 1.0f), "Parameter 1 (CV)");
        ImGui::PopStyleColor(3);
    }
    else
    {
        ImGui::Text("Parameter 1");
    }
    HelpMarker("This parameter does something important.\nRange: 0 to 1");

    ImGui::Spacing();
    ImGui::Spacing();

    // 4. Section 2: Visualization
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Output");
    ImGui::Spacing();
    
    // 5. Real-time meter
    float level = lastOutputValues[0]->load();
    ImVec4 color = (std::abs(level) < 0.7f) 
        ? ImVec4(0.2f, 0.8f, 0.2f, 1.0f)   // Green
        : ImVec4(0.9f, 0.2f, 0.2f, 1.0f);  // Red
    
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, color);
    ImGui::ProgressBar(std::abs(level), ImVec2(itemWidth, 0), "");
    ImGui::PopStyleColor();
    
    ImGui::SameLine(0, 5);
    ImGui::Text("%.3f", level);
    HelpMarker("Current output level");

    ImGui::PopItemWidth();
}

void drawIoPins(const NodePinHelpers& helpers) override
{
    helpers.drawAudioInputPin("In", 0);
    helpers.drawAudioOutputPin("Out", 0);
}
#endif
```

---

## 🔌 8. Pin Label Spacing (CRITICAL!)

### 8.1 Output Pin Text Alignment

**Problem**: Default spacing between pin labels and pin circles creates visual disconnection.

**From imgui_demo.cpp**: Line 447 shows `ImGui::SameLine(0, 0)` for minimal spacing between elements.

**Best Practice**: Use `ImGui::Indent()` for right-alignment (IMNODES OFFICIAL PATTERN).

```cpp
// ✅ CORRECT: Use Indent() - this is how ALL imnodes examples do it!
// From: color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73
auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
{
    const ImVec2 textSize = ImGui::CalcTextSize(txt);
    
    // Indent by (nodeWidth - textWidth) to right-align
    // ImNodes uses Indent(), NOT Dummy() + SameLine()!
    const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
    ImGui::Indent(indentAmount);
    ImGui::TextUnformatted(txt);
    ImGui::Unindent(indentAmount);  // CRITICAL: Reset indent!
};
```

**⚠️ CRITICAL**: Always call `Unindent()` to match `Indent()`! Indent is **persistent** and will affect all subsequent ImGui elements until reset.

**❌ WRONG**: Using Dummy() + SameLine() (imgui_demo.cpp pattern doesn't work for imnodes!)
```cpp
// BAD: This works in regular ImGui windows but NOT in imnodes!
// Causes layout issues and scrollbars in node contexts
ImGui::Dummy(ImVec2(dummyWidth, 0));
ImGui::SameLine(0, 0);
ImGui::TextUnformatted(txt);  // Wrong for imnodes!
```

**❌ WRONG**: Manual cursor positioning
```cpp
// BAD: SetCursorPosX() fights with ImNodes' internal layout
const float leftEdge = ImGui::GetCursorPosX();
ImGui::SetCursorPosX(leftEdge + nodeContentWidth - textWidth);  // Breaks!
```

**❌ WRONG**: GetContentRegionAvail() causes infinite scrollbars!
```cpp
// BAD: GetContentRegionAvail() changes as you add content!
// Creates feedback loop in fixed-size nodes
const float availWidth = ImGui::GetContentRegionAvail().x;
float x = cursorX + (availWidth - textWidth);  // Infinite scaling!
```

**Why `Indent()` is the Correct Pattern for ImNodes**:
- **Official ImNodes pattern**: Used in ALL official imnodes examples
- **Works with ImNodes layout**: Respects node padding and spacing
- **No side effects**: Doesn't trigger scrollbars or layout recalculation
- **Simple and clean**: Single function call, no SameLine() needed

**Example from Official ImNodes (color_node_editor.cpp:351-356)**:
```cpp
ImNodes::BeginOutputAttribute(node.id);
const float label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - label_width);  // ← This is the pattern!
ImGui::TextUnformatted("result");
ImNodes::EndOutputAttribute();
```

**Key Insight**: `Dummy()` is used in imnodes to SET node minimum width (line 425), NOT for text alignment!

**Reference**: `ImGuiNodeEditorComponent.cpp` lines 1976-1985

---

### 8.2 Output Pin Circle Positioning (CRITICAL!)

**Problem**: The pin circle itself can be positioned with an offset from the text, creating additional gap.

**❌ WRONG**: Adding offset to pin position
```cpp
const float PIN_CIRCLE_OFFSET = 8.0f;  // Creates 8px gap!
float x_pos = pinMax.x + PIN_CIRCLE_OFFSET;
attrPositions[attr] = ImVec2(x_pos, y_center);
```

**✅ CORRECT**: Zero offset - pin circle at text edge
```cpp
// Text is right-aligned to nodeContentWidth
// Pin circle positioned RIGHT at the edge
float x_pos = pinMax.x;  // No offset!
attrPositions[attr] = ImVec2(x_pos, y_center);
```

**Complete Flow**:
1. Text is right-aligned using `rightLabelWithinWidth` (0px padding)
2. `pinMax.x` captures the rightmost edge of the text area
3. Pin circle is positioned AT `pinMax.x` with no additional offset
4. Result: Pin circle touches text, which touches node border

**Reference**: `ImGuiNodeEditorComponent.cpp` lines 2175-2181, 2061-2067

---

### 8.3 SameLine Spacing Patterns

**From imgui_demo.cpp**:

```cpp
// Zero spacing (tight alignment)
ImGui::Text("Label");
ImGui::SameLine(0, 0);  // Second param = 0 removes extra spacing
ImGui::Button("Button");

// Small spacing (5px)
ImGui::ProgressBar(0.5f);
ImGui::SameLine(0, 5);  // 5px gap
ImGui::Text("50%%");

// Default spacing
ImGui::Checkbox("Option", &flag);
ImGui::SameLine();  // Uses style.ItemSpacing.x
HelpMarker("Tooltip text");
```

**Rule**: Use `SameLine(0, 0)` when you want elements visually "touching" (like pin labels to pins).

---

## 📦 9. ImNodes-Specific Patterns (FROM OFFICIAL EXAMPLES)

### 9.1 Node Content Width Management

**Pattern**: Use fixed widths, NOT GetContentRegionAvail()

```cpp
// From color_node_editor.cpp:314, 363, 415, 482
const float node_width = 100.0f;  // Fixed width for predictable layout
```

**Use Dummy() to set minimum width**:
```cpp
// From color_node_editor.cpp:425
ImGui::Dummy(ImVec2(node_width, 0.f));  // At START of node content
```

**Why Fixed Width**:
- Nodes don't resize dynamically like windows
- Prevents feedback loops and scrollbars
- All examples use hardcoded values (100.0f, 120.0f)

---

### 9.2 Input Attribute Pattern (Left Side)

**Structure**: Text first, then optional control

```cpp
// From color_node_editor.cpp:321-331
ImNodes::BeginInputAttribute(pin_id);
const float label_width = ImGui::CalcTextSize("left").x;
ImGui::TextUnformatted("left");

// If pin not connected, show input control
if (not_connected)
{
    ImGui::SameLine();
    ImGui::PushItemWidth(node_width - label_width);
    ImGui::DragFloat("##hidelabel", &value, 0.01f);
    ImGui::PopItemWidth();
}
ImNodes::EndInputAttribute();
```

**Key Points**:
- Label first, control after (if shown)
- Use `SameLine()` to put control next to label
- `PushItemWidth(node_width - label_width)` ensures control fits

---

### 9.3 Output Attribute Pattern (Right Side)

**Structure**: Indent first, text, then Unindent (NO SameLine!)

```cpp
// From color_node_editor.cpp:351-356 (with Unindent() added for persistence prevention)
ImNodes::BeginOutputAttribute(pin_id);
const float label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - label_width);  // ← Right-align!
ImGui::TextUnformatted("result");
ImGui::Unindent(node_width - label_width);  // ← Reset indent! CRITICAL!
ImNodes::EndOutputAttribute();
```

**Critical**: 
- Use `Indent()` for right-alignment, NOT Dummy() + SameLine()!
- **ALWAYS** call `Unindent()` to match `Indent()` - indent is persistent!

**Why Unindent() is Required**:
The imnodes examples work because they only have ONE output per node, so the indent doesn't affect anything else. In our multi-pin nodes, failing to unindent causes ALL subsequent elements to be indented cumulatively, creating the "red line" alignment bug where all text appears at the same wrong X position.

---

### 9.4 Static Attribute Pattern (No Pin)

**Structure**: For controls that don't connect to anything

```cpp
// From save_load.cpp:69-73, multi_editor.cpp:65-69
ImNodes::BeginStaticAttribute(attr_id);
ImGui::PushItemWidth(120.f);
ImGui::DragFloat("value", &value, 0.01f);
ImGui::PopItemWidth();
ImNodes::EndStaticAttribute();
```

**Use Cases**:
- Node settings/parameters
- Controls that affect node behavior
- UI elements without data flow

---

### 9.5 Node Layout Best Practices

**From ALL imnodes examples**:

1. **Title bar always first**:
```cpp
ImNodes::BeginNode(node_id);
ImNodes::BeginNodeTitleBar();
ImGui::TextUnformatted("node name");
ImNodes::EndNodeTitleBar();
// ... content ...
ImNodes::EndNode();
```

2. **Use Spacing() between sections**:
```cpp
// From color_node_editor.cpp:348, 400, 441, 458, 508
ImGui::Spacing();  // Visual separation
```

3. **Input pins before output pins**:
```cpp
// Input pins (left side)
ImNodes::BeginInputAttribute(...);
// Output pins (right side)  
ImNodes::BeginOutputAttribute(...);
```

4. **Calculate widths based on text**:
```cpp
const float label_width = ImGui::CalcTextSize("label").x;
```

---

### 9.6 Common Mistakes to Avoid

**❌ DON'T**: Forget to call Unindent() (CRITICAL BUG!)
```cpp
// BAD: Indent persists and affects all subsequent elements!
ImGui::Indent(node_width - text_width);
ImGui::Text("out");
// Missing Unindent() causes "red line" alignment bug!
```

**✅ DO**: Always match Indent() with Unindent()
```cpp
ImGui::Indent(node_width - text_width);
ImGui::Text("out");
ImGui::Unindent(node_width - text_width);  // CRITICAL!
```

**❌ DON'T**: Use Dummy() + SameLine() for output text
```cpp
// This is for ImGui windows, NOT imnodes!
ImGui::Dummy(ImVec2(width, 0));
ImGui::SameLine();
ImGui::Text("out");
```

**❌ DON'T**: Use GetContentRegionAvail() or -1 width in nodes
```cpp
float w = ImGui::GetContentRegionAvail().x;  // Causes scrollbars!
ImGui::ProgressBar(progress, ImVec2(-1, 0), "");  // -1 width also causes infinite scaling!
```

**✅ DO**: Use fixed widths from itemWidth parameter
```cpp
const float node_width = 240.0f;
ImGui::ProgressBar(progress, ImVec2(itemWidth, 0), "");  // Fixed width!
```

**Real-world bug**: MIDI Player initially used `ImVec2(-1, 0)` for progress bar, causing infinite right-side scaling. Fixed by using `ImVec2(itemWidth, 0)`.

**❌ DON'T**: Manually position with SetCursorPosX()
```cpp
ImGui::SetCursorPosX(x);  // Fights with ImNodes layout
```

**✅ DO**: Let ImNodes handle positioning with Indent()
```cpp
ImGui::Indent(amount);
```

---

### 9.7 Complete Node Example (From Official Examples)

```cpp
const float node_width = 100.0f;
ImNodes::BeginNode(node_id);

// Title
ImNodes::BeginNodeTitleBar();
ImGui::TextUnformatted("add");
ImNodes::EndNodeTitleBar();

// Input pin with optional control
ImNodes::BeginInputAttribute(input_id);
const float label_width = ImGui::CalcTextSize("left").x;
ImGui::TextUnformatted("left");
if (!is_connected)
{
    ImGui::SameLine();
    ImGui::PushItemWidth(node_width - label_width);
    ImGui::DragFloat("##hide", &value, 0.01f);
    ImGui::PopItemWidth();
}
ImNodes::EndInputAttribute();

ImGui::Spacing();  // Visual separation

// Output pin (right-aligned)
ImNodes::BeginOutputAttribute(output_id);
const float out_label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - out_label_width);
ImGui::TextUnformatted("result");
ImNodes::EndOutputAttribute();

ImNodes::EndNode();
```

**Reference**: color_node_editor.cpp:313-359, save_load.cpp:57-82, multi_editor.cpp:54-78

---

## ✅ 10. Pre-Flight Checklist

Before committing any node UI:

- [ ] No `ImGui::Separator()` or `ImGui::SeparatorText()` used
- [ ] All sections use `ImGui::TextColored()` + `ImGui::Spacing()`
- [ ] Every control has a `HelpMarker()` tooltip
- [ ] Modulated parameters have color-coding
- [ ] All tables use `NoHostExtendX` + `WidthFixed` columns
- [ ] Unique IDs for all widgets (check with `##` or `PushID()`)
- [ ] `ImGui::PushItemWidth(itemWidth)` at start
- [ ] `ImGui::PopItemWidth()` at end
- [ ] Real-time feedback where applicable (meters, plots)
- [ ] Output pins use `Indent()` for right-alignment (NOT Dummy() + SameLine!)
- [ ] Fixed node width used (NOT GetContentRegionAvail())
- [ ] Input pins: label first, control after with SameLine()
- [ ] Output pins: Indent() first, then text
- [ ] Tested with modulation connected and disconnected

---

## 📚 11. Reference Examples

**Best Implementations**:
1. **VCOModuleProcessor.h** (lines 28-220): Complete modern node with all patterns
2. **MIDIFadersModuleProcessor.cpp** (lines 180-600): Table layouts, learn modes
3. **MIDIJogWheelModuleProcessor.cpp** (lines 140-340): Custom drawing, circular indicators

**imgui_demo.cpp Sections**:
- Lines 273-282: HelpMarker implementation
- Lines 1982-2032: PlotLines examples
- Lines 3552-3555: TextColored usage
- Lines 6800-7000: Custom drawing with ImDrawList

**imnodes Official Examples** (H:\0000_CODE\01_collider_pyo\imnode_examples\):
- **hello.cpp**: Basic node structure (lines 17-32)
- **color_node_editor.cpp**: Complete node patterns
  - Fixed width pattern (lines 314, 363, 415, 482)
  - Input attribute with control (lines 321-331)
  - Output attribute with Indent() (lines 351-356)
  - Dummy() for minimum width (line 425)
- **save_load.cpp**: Simple node with static attribute (lines 57-82)
- **multi_editor.cpp**: Multi-context management (lines 54-78)

---

## 🔢 12. Multi-Voice & Collapsible UI Patterns

### 12.1 Collapsible Headers (For Polyphonic/Multi-Instance Modules)

When dealing with many similar controls (e.g., 32 voices in PolyVCO), use collapsible headers with proper state management.

**Pattern**:

```cpp
// Add Expand/Collapse All controls
static bool expandAllState = false;
static bool collapseAllState = false;

if (ImGui::SmallButton("Expand All")) {
    expandAllState = true;
}
ImGui::SameLine();
if (ImGui::SmallButton("Collapse All")) {
    collapseAllState = true;
}

ImGui::Spacing();

for (int i = 0; i < numVoices; ++i)
{
    ImGui::PushID(i);  // CRITICAL: Unique ID per iteration
    
    // CRITICAL: Use else-if to prevent SetNextItemOpen calls from overlapping
    if (expandAllState) {
        ImGui::SetNextItemOpen(true);
    }
    else if (collapseAllState) {
        ImGui::SetNextItemOpen(false);
    }
    else {
        // Default open state (first 4 only, on first use)
        ImGui::SetNextItemOpen(i < 4, ImGuiCond_Once);
    }
    
    // Color-code for visual distinction
    float hue = (float)i / (float)maxVoices;
    ImGui::PushStyleColor(ImGuiCol_Text, ImColor::HSV(hue, 0.7f, 1.0f).Value);
    
    if (ImGui::CollapsingHeader(("Voice " + juce::String(i+1)).toRawUTF8(),
                                ImGuiTreeNodeFlags_None))
    {
        ImGui::PopStyleColor();
        
        // Controls go here (see next section for table layout)
    }
    else
    {
        ImGui::PopStyleColor();
    }
    
    ImGui::PopID();
}

// Reset expand/collapse state after loop
expandAllState = false;
collapseAllState = false;
```

**Key Points**:
- `ImGui::PushID(i)` prevents ID conflicts between similar controls
- **CRITICAL**: Use `else-if` logic to prevent `SetNextItemOpen()` calls from overlapping! Only ONE call should execute per iteration
- `ImGuiCond_Once` ensures default state applies only on first use (but gets overwritten if not protected by else-if)
- **DO NOT** use `ImGuiTreeNodeFlags_SpanAvailWidth` or `ImGuiTreeNodeFlags_FramePadding` - they cause visual bleeding outside node bounds
- Use `ImGuiTreeNodeFlags_None` for clean, minimal headers in fixed-size nodes
- Color-coding helps distinguish voices at a glance

---

### 12.2 Table Layout Inside Collapsible Sections

For compact, multi-column layouts inside headers, use tables instead of Indent().

**Pattern**:

```cpp
if (ImGui::CollapsingHeader("Voice 1", ...))
{
    const float columnWidth = itemWidth / 3.0f;
    
    if (ImGui::BeginTable("voiceTable", 3,
                          ImGuiTableFlags_SizingFixedFit |
                          ImGuiTableFlags_NoBordersInBody,
                          ImVec2(itemWidth, 0)))
    {
        // Column 1
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);  // 8px padding
        ImGui::Combo("##wave", &wave, "Sine\0Saw\0Square\0\0");
        ImGui::TextUnformatted("Wave");
        ImGui::PopItemWidth();
        
        // Column 2
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);
        ImGui::SliderFloat("##freq", &freq, 20.0f, 20000.0f, "%.0f", 
                          ImGuiSliderFlags_Logarithmic);
        ImGui::TextUnformatted("Hz");
        ImGui::PopItemWidth();
        
        // Column 3
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);
        ImGui::SliderFloat("##gate", &gate, 0.0f, 1.0f, "%.2f");
        ImGui::TextUnformatted("Gate");
        ImGui::PopItemWidth();
        
        ImGui::EndTable();
    }
}
```

**Why Tables**:
- Avoids cumulative Indent() bugs
- Provides consistent column widths
- Handles overflow better than manual layout
- **CRITICAL**: Don't use `ImGuiTableFlags_RowBg` with fixed-size tables in nodes! Row backgrounds can bleed outside node boundaries. Use plain tables with `NoBordersInBody` only.

---

### 12.3 Parallel Pin Drawing (Multi-Voice Nodes)

For nodes with multiple voices/channels, use `helpers.drawParallelPins()` to align inputs with outputs.

**Pattern**:

```cpp
void drawIoPins(const NodePinHelpers& helpers) override
{
    // Global input (no output pairing)
    helpers.drawParallelPins("NumVoices Mod", 0, nullptr, -1);
    
    for (int i = 0; i < getEffectiveNumVoices(); ++i)
    {
        juce::String idx = juce::String(i + 1);
        
        // Pair primary input with output on same row
        helpers.drawParallelPins(("Freq " + idx + " Mod").toRawUTF8(), 
                                 1 + i,
                                 ("Voice " + idx).toRawUTF8(), 
                                 i);
        
        // Secondary inputs (no output pairing)
        helpers.drawParallelPins(("Wave " + idx + " Mod").toRawUTF8(), 
                                 1 + MAX_VOICES + i, 
                                 nullptr, -1);
        helpers.drawParallelPins(("Gate " + idx + " Mod").toRawUTF8(), 
                                 1 + (2 * MAX_VOICES) + i, 
                                 nullptr, -1);
    }
}
```

**Why Parallel Pins**:
- Creates visual alignment between related inputs/outputs
- Reduces vertical node height
- Makes signal flow clearer
- Matches MultiSequencer pattern for consistency

**Signature**:
```cpp
void drawParallelPins(const char* inputLabel, int inputChannel,
                     const char* outputLabel, int outputChannel);
```

Pass `nullptr` and `-1` for outputLabel/outputChannel when there's no output on that row.

---

### 12.4 Complete Example: PolyVCO Node

See `juce/Source/audio/modules/PolyVCOModuleProcessor.cpp` for the complete, production-ready implementation featuring:
- Expand/Collapse All buttons
- Color-coded collapsible headers (HSV hue cycling)
- 3-column table layout for voice parameters
- Parallel pin drawing with 3 inputs per voice + 1 output
- Live modulation feedback with "(mod)" indicators
- First 4 voices open by default

---

## 🔄 13. Update Log

| Date | Version | Changes |
|------|---------|---------|
| 2025-10-24 | **2.3.2** | **🐛 DOUBLE CRITICAL FIX**: Fixed PolyVCO Expand/Collapse buttons + blue bleeding lines!<br>• **Problem 1**: Expand/Collapse All buttons didn't work<br>• **Root cause**: Multiple `SetNextItemOpen()` calls - last one wins! `ImGuiCond_Once` was overwriting button state<br>• **Solution**: Use `else-if` logic to ensure only ONE SetNextItemOpen call executes<br>• **Problem 2**: Blue lines from collapsing headers bleeding outside node<br>• **Root cause**: `ImGuiTreeNodeFlags_SpanAvailWidth` and `FramePadding` extend beyond bounds<br>• **Solution**: Use `ImGuiTreeNodeFlags_None` for minimal, clean headers<br>• Updated Section 12.1 with critical else-if pattern and flag warnings |
| 2025-10-24 | **2.3.1** | **🐛 CRITICAL FIX**: Removed `ImGuiTableFlags_RowBg` from PolyVCO tables!<br>• **Problem**: Blue row backgrounds were bleeding outside node boundaries<br>• **Root cause**: `RowBg` creates backgrounds that extend beyond fixed-size table constraints in nodes<br>• **Solution**: Use `SizingFixedFit + NoBordersInBody` WITHOUT `RowBg` flag<br>• Updated Section 12.2 with warning about RowBg in fixed-size nodes<br>• Based on imgui_demo.cpp analysis: RowBg is for scrollable/dynamic tables, not fixed-size property grids |
| 2025-10-24 | **2.3** | **🎯 NEW PATTERNS**: Multi-Voice & Collapsible UI!<br>• Added Section 12: Complete patterns for polyphonic nodes<br>• **12.1**: Collapsible headers with Expand/Collapse All<br>• **12.2**: Table-based layouts inside headers (avoids Indent bugs)<br>• **12.3**: Parallel pin drawing for multi-voice nodes<br>• **12.4**: PolyVCO as reference implementation<br>• Fixed PolyVCO node (32 voices, 3-column tables, parallel pins)<br>• Documented stable ID management and HSV color-coding |
| 2025-10-24 | **2.2** | **🚨 CRITICAL BUG FIX**: Documented `-1` width issue in ProgressBar!<br>• **Real-world bug**: MIDI Player used `ImVec2(-1, 0)` for progress bar width<br>• **Symptom**: Infinite right-side scaling, unusable node<br>• **Fix**: Use `ImVec2(itemWidth, 0)` with fixed width parameter<br>• Updated Section 9.6 with progress bar example<br>• Added warning about `-1` width alongside `GetContentRegionAvail()` issue |
| 2025-10-24 | **2.1** | **🚨 CRITICAL BUG FIX**: Added `Unindent()` to match every `Indent()` call!<br>• **Root cause**: Indent() is persistent and was affecting all subsequent elements<br>• **Symptom**: All output labels appeared at same X position ("red line" bug)<br>• **Fix**: Always call `ImGui::Unindent(amount)` after `ImGui::Indent(amount)`<br>• Updated Section 9.3 with Unindent() requirement<br>• Added new Common Mistake #1: Forgetting Unindent()<br>**Why imnodes examples didn't show this**: They only have ONE output per node! |
| 2025-10-24 | **2.0** | **🎯 MAJOR UPDATE**: Analyzed ALL official imnodes examples. Discovered `ImGui::Indent()` is the CORRECT pattern (NOT Dummy()!).<br>• Added comprehensive Section 9: ImNodes-Specific Patterns<br>• Documented input/output attribute patterns from official examples<br>• Added complete node example with all best practices<br>• Updated all code to use Indent() for output pin alignment<br>• Expanded reference section with imnodes examples<br>**Breaking insight**: imgui_demo.cpp patterns don't always apply to imnodes! |
| 2025-10-24 | 1.6 | ~~Dummy() + SameLine() approach~~ (WRONG for imnodes, fixed in v2.0) |
| 2025-10-24 | 1.5 | ~~Manual cursor positioning~~ (WRONG, fixed in v2.0) |
| 2025-10-24 | 1.4 | ~~GetContentRegionAvail()~~ (caused scrollbars, fixed in v2.0) |
| 2025-10-24 | 1.3 | **CRITICAL FIX**: Eliminated PIN_CIRCLE_OFFSET (was 8px). Added Section 8.2: Output Pin Circle Positioning. Pin circles now positioned at pinMax.x with zero offset for perfect node border alignment. |
| 2025-10-24 | 1.2 | Further reduced pin padding from 2px to 0px for maximum tightness. Updated all examples and checklist. |
| 2025-10-24 | 1.1 | Added Section 8: Pin Label Spacing (CRITICAL!). Fixed output pin text gap issue by reducing padding from 8px to 2px. Added SameLine spacing patterns from imgui_demo.cpp. |
| 2025-10-24 | 1.0 | Initial guide created. Added separator fix, color-coding patterns, tooltip system. |

---

## 📝 12. Contributing to This Guide

When you discover a new pattern or fix an issue:

1. Document it here with a clear example
2. Reference the source file and line numbers
3. Explain WHY this pattern is better
4. Add to the Pre-Flight Checklist if applicable
5. Update the version number and log

**This guide is a living document!** Update it after every successful node redesign.

---

**End of Guide** | Version 2.3.2 | 2025-10-24



================================================================================
FILE: guides\XML_SAVING_AND_LOADING_HOW_TO.md
================================================================================


# XML Preset Saving and Loading - Complete Technical Guide

**Target Audience:** AI assistants and developers who need to understand the complete XML preset system in this JUCE-based modular synthesizer project.

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture](#architecture)
3. [The Save Process](#the-save-process)
4. [The Load Process](#the-load-process)
5. [XML File Structure](#xml-file-structure)
6. [Module Parameter Serialization](#module-parameter-serialization)
7. [Connection Management](#connection-management)
8. [UI State Persistence](#ui-state-persistence)
9. [Special Cases](#special-cases)
10. [Code Examples](#code-examples)

---

## System Overview

This modular synthesizer uses **XML-based presets** to save and restore complete patch configurations including:

- **Modules** (VCO, VCF, VCA, effects, utilities, etc.)
- **Module parameters** (frequency, waveform, envelope settings, etc.)
- **Audio connections** (routing between modules)
- **Modulation routings** (CV parameter modulation)
- **UI state** (node positions, colors, mute states)
- **VST plugin instances** (including their internal state)

The system is built on **JUCE's ValueTree** and **AudioProcessorValueTreeState (APVTS)** framework, which provides:
- Automatic parameter management
- Undo/redo support
- Thread-safe parameter access
- XML serialization/deserialization

---

## Architecture

### Key Classes

#### 1. **ModularSynthProcessor** (`juce/Source/audio/graph/ModularSynthProcessor.cpp`)
The core audio graph that manages all modules and connections.

**Responsibilities:**
- Maintains the `AudioProcessorGraph` (JUCE's internal audio routing system)
- Tracks all modules via **logical IDs** (stable across save/load)
- Implements `getStateInformation()` and `setStateInformation()` for serialization
- Manages audio connections between modules

#### 2. **ModuleProcessor** (`juce/Source/audio/modules/ModuleProcessor.h`)
Abstract base class for all synthesizer modules.

**Responsibilities:**
- Provides `getAPVTS()` for parameter access
- Implements `getExtraStateTree()` for module-specific state (file paths, etc.)
- Handles audio processing via `processBlock()`

#### 3. **PresetCreatorComponent** (`juce/Source/preset_creator/PresetCreatorComponent.cpp`)
The UI layer that triggers save/load operations.

**Responsibilities:**
- Presents file chooser dialogs
- Orchestrates save/load sequences
- Handles mute state management during save
- Updates UI after load

#### 4. **ImGuiNodeEditorComponent** (`juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`)
The visual node graph editor.

**Responsibilities:**
- Stores node positions, colors, sizes
- Manages mute states
- Provides `getUiValueTree()` for UI serialization
- Applies UI state via `applyUiValueTreeNow()`

---

## The Save Process

### High-Level Flow

```
User clicks Save → File chooser → Unmute nodes → Get synth state → 
Re-mute nodes → Append UI state → Write XML file
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doSave()`)

```cpp
void PresetCreatorComponent::doSave()
{
    // Find default save location (project-root/Synth_presets)
    juce::File startDir;
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    // Search up to 8 parent directories for Synth_presets folder
    auto dir = exeDir;
    for (int i = 0; i < 8 && dir.exists(); ++i)
    {
        auto candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.exists() && candidate.isDirectory()) 
        { 
            startDir = candidate; 
            break; 
        }
        dir = dir.getParentDirectory();
    }
    
    // Launch async file chooser
    saveChooser = std::make_unique<juce::FileChooser>("Save preset", startDir, "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        // Callback continues in Step 2...
    });
}
```

#### Step 2: Unmute Nodes (Critical Fix)

**Problem:** Muted nodes have their connections replaced with bypass routing in the audio graph. If we save while nodes are muted, we'll save the bypass routing instead of the original connections.

**Solution:** Temporarily unmute all nodes before getting state, then immediately re-mute them.

```cpp
// 1. Get list of currently muted nodes
std::vector<juce::uint32> currentlyMutedNodes;
if (editor)
{
    for (const auto& pair : editor->mutedNodeStates)
    {
        currentlyMutedNodes.push_back(pair.first);
    }
    
    // 2. Temporarily UNMUTE all of them
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->unmuteNode(lid);
    }
}

// 3. Force synth to apply connection changes immediately
if (synth)
{
    synth->commitChanges();
}
```

#### Step 3: Get Synth State (`ModularSynthProcessor::getStateInformation()`)

This is where the core serialization happens.

```cpp
void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock(moduleLock);
    
    // Create root ValueTree
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    // === SERIALIZE MODULES ===
    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32)kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int)logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                // Special handling for VST modules
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    // Standard module: save APVTS parameters
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    // Save extra state (file paths, custom data)
                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    // === SERIALIZE CONNECTIONS ===
    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32)c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32)c.destination.nodeID.uid;
        
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            // Module-to-module connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int)dstIt->second, nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            // Module-to-output connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else
        {
            continue; // Skip internal graph connections
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    // === CONVERT TO XML ===
    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}
```

**Key Concepts:**

- **Logical IDs:** Each module gets a stable logical ID (1, 2, 3...) that persists across sessions
- **Node UIDs:** JUCE's internal graph node IDs (unstable, change on reload)
- **Parameter Storage:** Uses JUCE's APVTS `.copyState()` to serialize all parameters
- **Extra State:** Custom data (file paths, text, etc.) stored separately via `getExtraStateTree()`

#### Step 4: Re-mute Nodes and Add UI State

```cpp
// 5. IMMEDIATELY RE-MUTE the nodes to return editor to visible state
if (editor)
{
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->muteNode(lid);
    }
}

// 6. Force synth to apply the re-mute changes
if (synth)
{
    synth->commitChanges();
}

// === ADD UI STATE ===
juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);
if (editor)
{
    juce::ValueTree ui = editor->getUiValueTree();
    presetVT.addChild(ui, -1, nullptr);
}

// Write to file
f.replaceWithText(presetVT.createXml()->toString());
```

The UI state includes:
- Node X/Y positions
- Node colors
- Mute states
- Node widths/heights (for custom-sized modules)

---

## The Load Process

### High-Level Flow

```
User clicks Load → File chooser → Parse XML → Clear existing state → 
Recreate modules → Restore parameters → Recreate connections → Apply UI state
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doLoad()`)

```cpp
void PresetCreatorComponent::doLoad()
{
    // Find default location
    juce::File startDir;
    // (same directory search logic as save)
    
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", startDir, "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData(mb);
                
                // First: set the synth state
                synth->setStateInformation(mb.getData(), (int)mb.getSize());
                
                // Then: parse and apply UI state
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse(mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml(*xml);
                        auto ui = vt.getChildWithName("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow(ui);
                    }
                }
                
                refreshModulesList();
                log.insertTextAtCaret("Loaded: " + f.getFullPathName() + "\n");
            }
        } catch (...) {
            juce::Logger::writeToLog("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}
```

#### Step 2: Set State (`ModularSynthProcessor::setStateInformation()`)

This is the most complex part of the system.

```cpp
void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    
    // Parse XML
    std::unique_ptr<juce::XmlElement> xml(
        juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes))
    );
    
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML");
        return;
    }

    // === CLEAR EXISTING STATE ===
    clearAll();
    
    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // === RESTORE GLOBAL SETTINGS ===
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found");
        return;
    }
    
    // === FIND HIGHEST LOGICAL ID ===
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    // === RECREATE MODULES ===
    std::map<juce::uint32, NodeID> logicalToNodeId;
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module")) continue;

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module: logicalId=" + juce::String(logicalId) + 
                                " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            // Check if this is a VST module
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr)
                    {
                        // Find VST in known plugins list
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE] Loading VST: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                break;
                            }
                        }
                    }
                }
            }
            
            if (!isVstModule)
            {
                // Standard module
                nodeId = addModule(type, false);
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                if (!isVstModule)
                {
                    // Update logical ID mapping
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;

                // === RESTORE STATE (ORDER MATTERS!) ===
                
                // FIRST: Restore extra state
                // This loads files, initializes custom data structures, etc.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE] Restored extra state.");
                    }
                }

                // SECOND: Restore parameters
                // This overwrites any defaults set by extra state loading
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE] Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE] ERROR: Node creation failed!");
            }
        }
    }
    
    // === RESTORE CONNECTIONS ===
    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connected " + juce::String(connectedCount) + " connections.");
    }

    // === FINALIZE ===
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}
```

**Critical Points:**

1. **Order of restoration:** Extra state BEFORE parameters (file loading sets defaults, then parameters overwrite them)
2. **Logical ID assignment:** Must match saved logical IDs for connections to work
3. **VST handling:** Separate code path for loading VST plugins vs. built-in modules
4. **Connection restoration:** Uses logical ID mapping to reconnect modules

#### Step 3: Apply UI State (`ImGuiNodeEditorComponent::applyUiValueTreeNow()`)

```cpp
void ImGuiNodeEditorComponent::applyUiValueTreeNow(const juce::ValueTree& uiTree)
{
    if (!uiTree.isValid()) return;
    
    // Clear existing UI state
    nodePositions.clear();
    nodeColors.clear();
    mutedNodeStates.clear();
    
    // Restore node positions and properties
    for (int i = 0; i < uiTree.getNumChildren(); ++i)
    {
        auto child = uiTree.getChild(i);
        if (child.hasType("node"))
        {
            int logicalId = child.getProperty("id", 0);
            float x = child.getProperty("x", 0.0f);
            float y = child.getProperty("y", 0.0f);
            
            nodePositions[logicalId] = ImVec2(x, y);
            
            // Restore color if saved
            if (child.hasProperty("color"))
            {
                juce::uint32 colorInt = child.getProperty("color", 0);
                nodeColors[logicalId] = ImColor(colorInt);
            }
            
            // Restore mute state
            if (child.getProperty("muted", false))
            {
                mutedNodeStates[logicalId] = true;
                // Apply mute routing
                muteNode(logicalId);
            }
            
            // Restore width override
            if (child.hasProperty("width"))
            {
                float width = child.getProperty("width", 0.0f);
                nodeWidthOverrides[logicalId] = width;
            }
        }
    }
    
    graphNeedsRebuild = true;
}
```

---

## XML File Structure

### Complete Example

```xml
<?xml version="1.0" encoding="UTF-8"?>

<ModularSynthPreset version="1">
  <modules>
    <module logicalId="3" type="VCO">
      <params>
        <VCOParams>
          <PARAM id="frequency" value="440.0"/>
          <PARAM id="waveform" value="0.0"/>
        </VCOParams>
      </params>
    </module>
    
    <module logicalId="4" type="Sample_Loader">
      <params>
        <SampleLoaderParams>
          <PARAM id="trimStart" value="0.0"/>
          <PARAM id="trimEnd" value="1.0"/>
          <PARAM id="cvMax" value="1.0"/>
          <PARAM id="cvMin" value="0.0"/>
        </SampleLoaderParams>
      </params>
      <extra>
        <SampleLoaderState audioFilePath="H:\audio\samples\kick.wav" 
                          loopMode="0" loopStart="0" loopEnd="44100"/>
      </extra>
    </module>
    
    <module logicalId="5" type="Pro-Q 3">
      <extra>
        <VstHostState fileOrIdentifier="C:\VST\FabFilter Pro-Q 3.vst3"
                      name="Pro-Q 3" 
                      manufacturerName="FabFilter" 
                      version="3.2.1.0"
                      pluginFormatName="VST3" 
                      pluginState="(base64 encoded state data)"/>
      </extra>
    </module>
  </modules>
  
  <connections>
    <connection srcId="3" srcChan="0" dstId="4" dstChan="0"/>
    <connection srcId="4" srcChan="0" dstId="5" dstChan="0"/>
    <connection srcId="5" srcChan="0" dstId="output" dstChan="0"/>
  </connections>
  
  <NodeEditorUI>
    <node id="3" x="100.0" y="200.0" color="4294901760" width="200.0"/>
    <node id="4" x="400.0" y="200.0" muted="true"/>
    <node id="5" x="700.0" y="200.0"/>
    <node id="0" x="1000.0" y="200.0"/>
  </NodeEditorUI>
</ModularSynthPreset>
```

### Structure Breakdown

#### Root Element
```xml
<ModularSynthPreset version="1">
```
- `version`: Schema version (for future compatibility)

#### Modules Section
```xml
<modules>
  <module logicalId="X" type="ModuleType">
    <params>
      <ModuleTypeParams>
        <PARAM id="paramId" value="0.5"/>
      </ModuleTypeParams>
    </params>
    <extra>
      <!-- Module-specific state -->
    </extra>
  </module>
</modules>
```

- `logicalId`: Stable identifier for this module instance
- `type`: Module type string (must match factory registration)
- `params`: APVTS-generated parameter state
- `extra`: Custom state (file paths, text, etc.)

#### Connections Section
```xml
<connections>
  <connection srcId="1" srcChan="0" dstId="2" dstChan="1"/>
  <connection srcId="2" srcChan="0" dstId="output" dstChan="0"/>
</connections>
```

- `srcId`: Source module logical ID
- `srcChan`: Source output channel (0-indexed)
- `dstId`: Destination module logical ID (or "output")
- `dstChan`: Destination input channel (0-indexed)

#### UI Section
```xml
<NodeEditorUI>
  <node id="X" x="123.45" y="678.90" color="4294901760" muted="true" width="250.0"/>
</NodeEditorUI>
```

- `id`: Module logical ID (or 0 for output node)
- `x`, `y`: Node position in canvas space
- `color`: ARGB color as 32-bit integer (optional)
- `muted`: Boolean mute state (optional)
- `width`: Custom width override (optional)

---

## Module Parameter Serialization

### How APVTS Works

**AudioProcessorValueTreeState (APVTS)** is JUCE's parameter management system. Each module creates an APVTS in its constructor:

```cpp
class VCOModuleProcessor : public ModuleProcessor
{
public:
    VCOModuleProcessor()
        : ModuleProcessor(/* bus layout */),
          apvts(*this, nullptr, "VCOParams", createParameterLayout())
    {
    }
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
    {
        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        
        layout.add(std::make_unique<juce::AudioParameterFloat>(
            "frequency",                    // Parameter ID
            "Frequency",                    // Display name
            juce::NormalisableRange<float>(20.0f, 20000.0f, 0.01f, 0.3f),
            440.0f));                       // Default value
        
        layout.add(std::make_unique<juce::AudioParameterChoice>(
            "waveform",
            "Waveform",
            juce::StringArray{"Sine", "Square", "Saw", "Triangle"},
            0));
        
        return layout;
    }
};
```

### Serialization

When we call `apvts.copyState()`, JUCE creates a ValueTree:

```xml
<VCOParams>
  <PARAM id="frequency" value="440.0"/>
  <PARAM id="waveform" value="0.0"/>
</VCOParams>
```

### Deserialization

When we call `apvts.replaceState(params)`, JUCE:
1. Finds each parameter by ID
2. Converts the string value to the parameter's native type
3. Sets the parameter value
4. Triggers any attached listeners

---

## Connection Management

### Connection Storage

Connections are stored in `juce::AudioProcessorGraph` as:

```cpp
struct Connection
{
    struct EndPoint
    {
        NodeID nodeID;
        int channelIndex;
    } source, destination;
};
```

### Channel Types

- **Audio channels:** 0, 1, 2, ... (stereo = channels 0 and 1)
- **MIDI channel:** `juce::AudioProcessorGraph::midiChannelIndex` (special constant)

### Connection Creation

```cpp
bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel,
                                    const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection{
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    // Check for duplicate
    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            return true; // Already connected
        }
    }

    // Add connection (deferred until commitChanges())
    return internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}
```

### Why Logical IDs?

**Problem:** JUCE's `NodeID::uid` values are unstable - they change every time you load a preset.

**Solution:** We maintain a separate `logicalId` system:

```cpp
// Mapping stored in ModularSynthProcessor
std::map<juce::uint32, LogicalModule> logicalIdToModule;

struct LogicalModule
{
    juce::AudioProcessorGraph::NodeID nodeID;  // Changes on reload
    juce::String type;
};
```

When saving:
```cpp
// Convert NodeID → Logical ID
nodeUidToLogical[nodeID.uid] = logicalId;
```

When loading:
```cpp
// Convert Logical ID → NodeID (new UID)
logicalToNodeId[logicalId] = newNodeId;
```

---

## UI State Persistence

### What UI State Includes

- **Node positions** (X, Y coordinates)
- **Node colors** (custom color per node)
- **Mute states** (which nodes are bypassed)
- **Width overrides** (custom widths for nodes)
- **Canvas pan/zoom** (viewport state)

### Generation (`ImGuiNodeEditorComponent::getUiValueTree()`)

```cpp
juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui("NodeEditorUI");
    
    // Save all module nodes
    for (const auto& pair : nodePositions)
    {
        int logicalId = pair.first;
        ImVec2 pos = pair.second;
        
        juce::ValueTree nodeVT("node");
        nodeVT.setProperty("id", logicalId, nullptr);
        nodeVT.setProperty("x", pos.x, nullptr);
        nodeVT.setProperty("y", pos.y, nullptr);
        
        // Optional: color
        if (nodeColors.count(logicalId))
        {
            ImU32 colorInt = nodeColors.at(logicalId);
            nodeVT.setProperty("color", (int)colorInt, nullptr);
        }
        
        // Optional: mute state
        if (mutedNodeStates.count(logicalId) && mutedNodeStates.at(logicalId))
        {
            nodeVT.setProperty("muted", true, nullptr);
        }
        
        // Optional: width override
        if (nodeWidthOverrides.count(logicalId))
        {
            nodeVT.setProperty("width", nodeWidthOverrides.at(logicalId), nullptr);
        }
        
        ui.addChild(nodeVT, -1, nullptr);
    }
    
    // Always save output node position
    if (outputNodePosition.x != 0.0f || outputNodePosition.y != 0.0f)
    {
        juce::ValueTree outputVT("node");
        outputVT.setProperty("id", 0, nullptr); // Output node is always ID 0
        outputVT.setProperty("x", outputNodePosition.x, nullptr);
        outputVT.setProperty("y", outputNodePosition.y, nullptr);
        ui.addChild(outputVT, -1, nullptr);
    }
    
    return ui;
}
```

### Restoration (shown earlier in Load Process)

---

## Special Cases

### 1. VST Plugins

VST plugins have opaque internal state that we can't inspect. JUCE provides:

```cpp
// Get plugin state
juce::MemoryBlock stateData;
plugin->getStateInformation(stateData);

// Restore plugin state
plugin->setStateInformation(stateData.getData(), stateData.getSize());
```

We wrap this in `VstHostModuleProcessor` and store:
- Plugin identifier (file path)
- Plugin metadata (name, manufacturer, version)
- Plugin state (base64 encoded in XML)

### 2. Sample Loader

The Sample Loader module needs to store:
- File path (absolute path to audio file)
- Trim points (start/end in samples)
- Loop settings

This uses "extra state":

```cpp
juce::ValueTree SampleLoaderModuleProcessor::getExtraStateTree()
{
    juce::ValueTree state("SampleLoaderState");
    state.setProperty("audioFilePath", currentFilePath, nullptr);
    state.setProperty("loopMode", (int)loopMode, nullptr);
    state.setProperty("loopStart", loopStart, nullptr);
    state.setProperty("loopEnd", loopEnd, nullptr);
    return state;
}

void SampleLoaderModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    if (!state.hasType("SampleLoaderState")) return;
    
    currentFilePath = state.getProperty("audioFilePath", "").toString();
    loopMode = (LoopMode)(int)state.getProperty("loopMode", 0);
    loopStart = state.getProperty("loopStart", 0);
    loopEnd = state.getProperty("loopEnd", 0);
    
    // Load the audio file
    if (currentFilePath.isNotEmpty())
    {
        loadAudioFile(juce::File(currentFilePath));
    }
}
```

### 3. Comment Module

Comments store text and dimensions:

```cpp
<extra>
  <CommentState title="My Note" 
                text="This is important!" 
                width="250.0" 
                height="150.0"/>
</extra>
```

### 4. Mute States

Muting is complex because it modifies the audio graph:

**When a node is muted:**
1. Store original connections
2. Remove all connections to/from node
3. Create bypass connections (input → output directly)

**When saving with muted nodes:**
1. Temporarily unmute all nodes (restore original connections)
2. Save the unmuted connections
3. Immediately re-mute nodes

**When loading with muted nodes:**
1. Load normal connections
2. Apply mute states from UI tree
3. This triggers the mute logic, which replaces connections with bypasses

---

## Code Examples

### Example 1: Creating a Simple Module with APVTS

```cpp
// SimpleGainModule.h
#pragma once
#include "ModuleProcessor.h"

class SimpleGainModuleProcessor : public ModuleProcessor
{
public:
    SimpleGainModuleProcessor();
    ~SimpleGainModuleProcessor() override = default;
    
    const juce::String getName() const override { return "Simple Gain"; }
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override;
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SimpleGainModuleProcessor)
};

// SimpleGainModule.cpp
#include "SimpleGainModuleProcessor.h"

SimpleGainModuleProcessor::SimpleGainModuleProcessor()
    : ModuleProcessor(BusesProperties()
                       .withInput("Input", juce::AudioChannelSet::stereo())
                       .withOutput("Output", juce::AudioChannelSet::stereo())),
      apvts(*this, nullptr, "SimpleGainParams", createParameterLayout())
{
}

juce::AudioProcessorValueTreeState::ParameterLayout SimpleGainModuleProcessor::createParameterLayout()
{
    juce::AudioProcessorValueTreeState::ParameterLayout layout;
    
    layout.add(std::make_unique<juce::AudioParameterFloat>(
        "gain",                                           // Parameter ID
        "Gain",                                          // Display name
        juce::NormalisableRange<float>(0.0f, 2.0f),     // Range
        1.0f));                                          // Default value
    
    return layout;
}

void SimpleGainModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Read parameter value
    float gain = apvts.getRawParameterValue("gain")->load();
    
    // Apply gain
    buffer.applyGain(gain);
    
    // Update telemetry for visualization
    updateOutputTelemetry(buffer);
}
```

**What gets saved automatically:**
```xml
<module logicalId="X" type="Simple Gain">
  <params>
    <SimpleGainParams>
      <PARAM id="gain" value="1.5"/>
    </SimpleGainParams>
  </params>
</module>
```

### Example 2: Adding Extra State (File Path)

```cpp
class MyFileModuleProcessor : public ModuleProcessor
{
public:
    // ... (constructor, APVTS, etc.)
    
    // Override these two methods
    juce::ValueTree getExtraStateTree() override
    {
        juce::ValueTree state("MyFileModuleState");
        state.setProperty("filePath", currentFilePath, nullptr);
        state.setProperty("customData", someOtherData, nullptr);
        return state;
    }
    
    void setExtraStateTree(const juce::ValueTree& state) override
    {
        if (!state.hasType("MyFileModuleState")) return;
        
        currentFilePath = state.getProperty("filePath", "").toString();
        someOtherData = state.getProperty("customData", 0);
        
        // Do something with the loaded data
        if (currentFilePath.isNotEmpty())
        {
            loadFile(juce::File(currentFilePath));
        }
    }
    
private:
    juce::String currentFilePath;
    int someOtherData = 0;
};
```

**What gets saved:**
```xml
<module logicalId="X" type="MyFileModule">
  <params>
    <!-- APVTS parameters -->
  </params>
  <extra>
    <MyFileModuleState filePath="C:\audio\file.wav" customData="42"/>
  </extra>
</module>
```

### Example 3: Programmatic Save/Load

```cpp
// Save preset programmatically
void savePresetToFile(ModularSynthProcessor* synth, const juce::File& file)
{
    juce::MemoryBlock mb;
    synth->getStateInformation(mb);
    
    auto xml = juce::XmlDocument::parse(mb.toString());
    if (xml)
    {
        file.replaceWithText(xml->toString());
    }
}

// Load preset programmatically
void loadPresetFromFile(ModularSynthProcessor* synth, const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);
    
    synth->setStateInformation(mb.getData(), (int)mb.getSize());
}
```

---

## Summary

The XML preset system in this modular synthesizer is built on these key principles:

1. **Logical IDs** provide stable module references across save/load cycles
2. **JUCE's APVTS** handles automatic parameter serialization
3. **Extra state trees** allow modules to store custom data (files, text, etc.)
4. **Connection serialization** uses logical IDs instead of unstable node IDs
5. **UI state separation** keeps visual data separate from audio graph data
6. **Mute state handling** requires careful connection management during save
7. **VST support** wraps opaque plugin state in a standardized format

The complete flow is:
```
Save: UI → Get State → Serialize → Write XML
Load: Read XML → Parse → Recreate Graph → Apply UI
```

This architecture provides:
- ✅ **Stability:** Presets work across app restarts
- ✅ **Extensibility:** Easy to add new module types
- ✅ **Debugging:** Human-readable XML format
- ✅ **Performance:** Deferred graph updates via `commitChanges()`
- ✅ **Completeness:** Captures all module state, connections, and UI layout

---

## Key Files Reference

| File | Purpose |
|------|---------|
| `ModularSynthProcessor.cpp` | Core save/load implementation |
| `ModularSynthProcessor.h` | Logical ID management |
| `ModuleProcessor.h` | Base class for all modules |
| `PresetCreatorComponent.cpp` | UI save/load dialogs |
| `ImGuiNodeEditorComponent.cpp` | UI state management |
| `VCOModuleProcessor.cpp` | Example APVTS usage |
| `SampleLoaderModuleProcessor.cpp` | Example extra state usage |
| `VstHostModuleProcessor.cpp` | VST plugin state handling |

---

## Common Pitfalls

### ❌ Don't: Use Node UID in Connections
```cpp
// BAD: Node UIDs change on reload!
save_connection(node->nodeID.uid, otherNode->nodeID.uid);
```

### ✅ Do: Use Logical IDs
```cpp
// GOOD: Logical IDs are stable
save_connection(logicalId1, logicalId2);
```

### ❌ Don't: Save Parameters Manually
```cpp
// BAD: Duplicate work, error-prone
xml->setAttribute("frequency", frequency);
xml->setAttribute("waveform", waveform);
```

### ✅ Do: Use APVTS
```cpp
// GOOD: Automatic, correct, handles undo/redo
juce::ValueTree params = apvts.copyState();
```

### ❌ Don't: Forget commitChanges()
```cpp
// BAD: Changes not applied to audio thread
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
// Missing: synth->commitChanges();
```

### ✅ Do: Always Commit
```cpp
// GOOD: Audio graph updated properly
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
synth->commitChanges(); // ✓
```

---

**End of Guide**

This document provides a complete understanding of the XML preset save/load system. For specific module implementation details, refer to the individual module processor files in `juce/Source/audio/modules/`.



================================================================================
FILE: guides\UNDO_REDO_SYSTEM_GUIDE.md
================================================================================


# Undo/Redo System - Comprehensive Guide

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Core Components](#core-components)
4. [How It Works](#how-it-works)
5. [Snapshot Creation Strategy](#snapshot-creation-strategy)
6. [User Interface Integration](#user-interface-integration)
7. [Module-Level Undo Support](#module-level-undo-support)
8. [Best Practices](#best-practices)
9. [Implementation Examples](#implementation-examples)
10. [Limitations and Considerations](#limitations-and-considerations)

---

## Overview

The undo/redo system in this JUCE-based modular synthesizer provides comprehensive history tracking for all user modifications to patches. It captures the **complete state** of both the audio graph and the visual node editor, allowing users to freely navigate through their editing history.

### Key Features:
- **Full State Capture**: Saves both audio processing state and UI layout
- **Unlimited History**: No hard limit on undo stack size (limited only by memory)
- **Keyboard Shortcuts**: Standard `Ctrl+Z` (undo) and `Ctrl+Y` (redo)
- **Automatic Snapshot Creation**: Strategic placement ensures all major operations are undoable
- **Thread-Safe**: Designed to work safely with real-time audio processing

---

## Architecture

The undo/redo system is implemented in the `ImGuiNodeEditorComponent` class, which serves as the main UI controller for the node editor. It uses a **dual-stack architecture** to maintain history.

### File Locations:
- **Header**: `juce/Source/preset_creator/ImGuiNodeEditorComponent.h`
- **Implementation**: `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

### High-Level Design:

```
┌─────────────────────────────────────────────┐
│      ImGuiNodeEditorComponent               │
│                                              │
│  ┌────────────────────────────────────────┐ │
│  │  Undo Stack (std::vector<Snapshot>)   │ │
│  │  ┌────────┐ ┌────────┐ ┌────────┐     │ │
│  │  │ State  │ │ State  │ │ State  │ ... │ │
│  │  │   1    │ │   2    │ │   3    │     │ │
│  │  └────────┘ └────────┘ └────────┘     │ │
│  │                            ↑           │ │
│  │                      Current State     │ │
│  └────────────────────────────────────────┘ │
│                                              │
│  ┌────────────────────────────────────────┐ │
│  │  Redo Stack (std::vector<Snapshot>)   │ │
│  │  ┌────────┐ ┌────────┐                │ │
│  │  │ State  │ │ State  │ ...            │ │
│  │  │   4    │ │   5    │                │ │
│  │  └────────┘ └────────┘                │ │
│  └────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

---

## Core Components

### 1. The Snapshot Structure

Located in `ImGuiNodeEditorComponent.h` (lines 301-305):

```cpp
struct Snapshot
{
    juce::MemoryBlock synthState;  // Complete audio graph state
    juce::ValueTree   uiState;     // Complete UI/editor state
};
```

**What's Stored:**

#### `synthState` (MemoryBlock):
- All module processor states (APVTS for each module)
- Audio graph connections (node relationships)
- Module parameter values
- Internal audio routing configuration
- Module-specific state data

#### `uiState` (ValueTree):
- Node positions in the editor grid
- Node selection state
- Muted/bypassed state for each node
- Output node position (ID 0)
- Visual editor layout

### 2. The Stack Storage

Located in `ImGuiNodeEditorComponent.h` (lines 306-307):

```cpp
std::vector<Snapshot> undoStack;  // History of previous states
std::vector<Snapshot> redoStack;  // History of undone states
```

- **undoStack**: Grows as user makes changes; the **back()** is always the current state
- **redoStack**: Populated when user undos; **cleared** when user makes a new change

### 3. Core Methods

```cpp
void pushSnapshot();                    // Create new undo point
void restoreSnapshot(const Snapshot& s); // Restore a previous state
```

---

## How It Works

### Creating a Snapshot (`pushSnapshot()`)

Located in `ImGuiNodeEditorComponent.cpp` (lines 4194-4237):

#### The Process:

1. **Capture UI State**: Calls `getUiValueTree()` to capture all node positions and visual state
2. **Capture Audio State**: Calls `synth->getStateInformation()` to serialize the audio graph
3. **Apply Pending Positions**: Merges any pending node position updates into the snapshot
4. **Push to Stack**: Adds the snapshot to the `undoStack`
5. **Clear Redo Stack**: Any new action invalidates the redo history
6. **Mark Patch as Dirty**: Sets `isPatchDirty = true` to indicate unsaved changes

#### Code Flow:

```cpp
void ImGuiNodeEditorComponent::pushSnapshot()
{
    // First check if we have pending positions to apply (for nodes just created)
    if (!pendingNodePositions.empty())
    {
        juce::ValueTree applied = getUiValueTree();
        
        // Apply any pending positions to the captured state
        for (const auto& kv : pendingNodePositions)
        {
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int)n.getProperty("id", -1) == kv.first)
                {
                    n.setProperty("x", kv.second.x, nullptr);
                    n.setProperty("y", kv.second.y, nullptr);
                    break;
                }
            }
        }
        
        // Create snapshot with applied positions
        Snapshot s;
        s.uiState = applied;
        if (synth != nullptr)
            synth->getStateInformation(s.synthState);
        
        undoStack.push_back(std::move(s));
        redoStack.clear();
        isPatchDirty = true;
        return;
    }
    
    // Normal snapshot creation
    Snapshot s;
    s.uiState = getUiValueTree();
    if (synth != nullptr)
        synth->getStateInformation(s.synthState);
    
    undoStack.push_back(std::move(s));
    redoStack.clear();
    isPatchDirty = true;
}
```

### Restoring a Snapshot (`restoreSnapshot()`)

Located in `ImGuiNodeEditorComponent.cpp` (lines 4239-4245):

#### The Process:

1. **Restore Audio State**: Calls `synth->setStateInformation()` with the saved memory block
2. **Restore UI State**: Calls `applyUiValueTreeNow()` to restore node positions
3. **Clear Transient Data**: Clears frame-specific data like link ID mappings

#### Code:

```cpp
void ImGuiNodeEditorComponent::restoreSnapshot(const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation(s.synthState.getData(), (int)s.synthState.getSize());
    
    // Restore UI positions exactly as saved
    applyUiValueTreeNow(s.uiState);
}
```

### Undo Operation (Ctrl+Z)

Located in `ImGuiNodeEditorComponent.cpp` (lines 3857-3869):

#### The Algorithm:

```
if undoStack.size() > 1:
    1. Save current state to redoStack
    2. Remove current state from undoStack
    3. Restore the previous state (now at undoStack.back())
    4. Clear transient link maps
```

#### Code:

```cpp
if (ctrl && ImGui::IsKeyPressed(ImGuiKey_Z))
{
    if (undoStack.size() > 1)
    {
        Snapshot current = undoStack.back();
        redoStack.push_back(current);
        undoStack.pop_back();
        restoreSnapshot(undoStack.back());
        
        // Clear transient data
        linkIdToAttrs.clear();
    }
}
```

**Why `size() > 1`?**
- The undo stack always contains at least the current state
- We need at least 2 states (current + previous) to perform an undo

### Redo Operation (Ctrl+Y)

Located in `ImGuiNodeEditorComponent.cpp` (lines 3870-3880):

#### The Algorithm:

```
if redoStack is not empty:
    1. Pop state from redoStack
    2. Restore that state
    3. Push it onto undoStack
    4. Clear transient link maps
```

#### Code:

```cpp
if (ctrl && ImGui::IsKeyPressed(ImGuiKey_Y))
{
    if (!redoStack.empty())
    {
        Snapshot s = redoStack.back();
        redoStack.pop_back();
        restoreSnapshot(s);
        undoStack.push_back(s);
        linkIdToAttrs.clear();
    }
}
```

---

## Snapshot Creation Strategy

The system strategically creates snapshots after **significant user actions**. Here's where `pushSnapshot()` is called:

### 1. Node Operations

| Operation | Location | Example Code |
|-----------|----------|--------------|
| **Add Node** | After module creation | `pushSnapshot();` |
| **Delete Node** | After node removal | `snapshotAfterEditor = true;` |
| **Duplicate Node(s)** | After duplication | Line 3932 |
| **Move Node** | After drag ends | Line 2806 (conditional) |

### 2. Connection Operations

| Operation | Location | Example Code |
|-----------|----------|--------------|
| **Create Connection** | After link created | Implicit in graph rebuild |
| **Delete Connection** | After link removed | Implicit in graph rebuild |
| **Clear Connections** | Menu operations | Lines 599, 619 |
| **Insert Mixer** | After mixer insertion | Line 2593 |
| **Insert Node on Link** | After node insertion | Line 3164 |

### 3. Complex Operations

| Operation | Location | Purpose |
|-----------|----------|---------|
| **Randomize Patch** | `handleRandomizePatch()` | Line 3717 |
| **Beautify Layout** | `handleBeautifyLayout()` | Line 4682 |
| **Auto-Connect Operations** | Various handlers | Lines 4975, 5167, 6492, etc. |
| **Build Drum Kit** | StrokeSequencer operation | Line 7365 |
| **Meta Module Operations** | Meta module editing | Lines 7619, 7623, 7648 |

### 4. State-Modifying Menu Actions

| Menu Item | Location | Purpose |
|-----------|----------|---------|
| **Clear Output Connections** | Edit menu | Line 599 |
| **Clear Selected Node Connections** | Edit menu | Line 619 |

---

## User Interface Integration

### Keyboard Shortcuts

Implemented in `ImGuiNodeEditorComponent.cpp` (lines 3856-3880):

```cpp
// Check if keyboard input should be processed
if (!ImGui::GetIO().WantCaptureKeyboard)
{
    bool ctrl = ImGui::GetIO().KeyCtrl;
    bool shift = ImGui::GetIO().KeyShift;
    
    // Undo: Ctrl+Z
    if (ctrl && ImGui::IsKeyPressed(ImGuiKey_Z))
    {
        // [Undo implementation]
    }
    
    // Redo: Ctrl+Y
    if (ctrl && ImGui::IsKeyPressed(ImGuiKey_Y))
    {
        // [Redo implementation]
    }
}
```

**WantCaptureKeyboard Check:**
- Prevents undo/redo when user is typing in text fields
- Only processes shortcuts when ImGui doesn't need keyboard input

### Model Reset on Load

Located in `ImGuiNodeEditorComponent.h` (lines 68-73):

```cpp
void setModel(ModularSynthProcessor* model) 
{ 
    synth = model; 
    undoStack.clear();   // Clear undo history
    redoStack.clear();   // Clear redo history
}
```

**Why Clear History?**
- Loading a new synth/patch represents a clean slate
- Previous undo states reference the old synth pointer
- Prevents crashes from restoring invalid state

---

## Module-Level Undo Support

Individual modules can trigger undo states through the **`onModificationEnded`** callback pattern.

### The Callback Pattern

Located in `ImGuiNodeEditorComponent.cpp` (line 1796):

```cpp
// Create a callback that modules can invoke when user finishes an edit
auto onModificationEnded = [&](){ this->pushSnapshot(); };
```

This callback is passed to modules via `drawParametersInNode()`:

```cpp
mp->drawParametersInNode(
    nodeContentWidth,
    isParamModulated,
    onModificationEnded  // Callback to create undo state
);
```

### Module Integration

Modules call `onModificationEnded()` after **discrete, user-initiated actions**. Examples:

#### Example 1: Stroke Sequencer Preset Loading

Located in `StrokeSequencerModuleProcessor.cpp` (line 753):

```cpp
if (ImGui::Combo("##StrokePreset", &selectedStrokePresetIndex, names.data(), (int)names.size()))
{
    if (selectedStrokePresetIndex >= 0)
    {
        activeStrokePresetName = presetNames[selectedStrokePresetIndex];
        juce::ValueTree presetData = presetManager.loadPreset(/*...*/);
        setExtraStateTree(presetData);
        onModificationEnded(); // Create undo state after preset loaded
    }
}
```

#### Example 2: MIDI Controller Modules

Pattern used in:
- `MIDIKnobsModuleProcessor.cpp` (line 251)
- `MIDIFadersModuleProcessor.cpp` (line 301)
- `MIDIButtonsModuleProcessor.cpp` (line 298)

```cpp
// When user finishes editing the MIDI mapping or controller state
onModificationEnded(); // Create an undo state
```

#### Example 3: Comment Module Resizing

Located in `CommentModuleProcessor.cpp` (line 92):

```cpp
// Just finished resizing, trigger undo snapshot
onModificationEnded();
```

### When NOT to Call onModificationEnded

❌ **During Continuous Parameter Changes** (slider dragging)
- Would create hundreds of undo states
- Only call after user releases the control

❌ **During Real-Time Audio Processing**
- `onModificationEnded` is a UI-thread operation
- Never call from `processBlock()`

❌ **For Internal State Updates**
- Only call for user-initiated actions
- Automatic/computed updates should not create history

---

## Best Practices

### 1. Strategic Snapshot Timing

✅ **Good Times to Create Snapshots:**
- After user completes an action (mouse release, menu selection)
- Before complex multi-step operations
- After batch operations complete

❌ **Bad Times to Create Snapshots:**
- During continuous drag operations
- Every frame of an animation
- Inside tight loops

### 2. Granularity Guidelines

**Single Snapshot for Atomic Operations:**
```cpp
// Good: One snapshot for the entire "Insert Mixer" operation
void handleInsertMixer()
{
    // 1. Create mixer node
    // 2. Disconnect original links
    // 3. Connect mixer in chain
    // 4. Position mixer
    
    pushSnapshot(); // One undo state for all steps
}
```

**Avoid Over-Snapshotting:**
```cpp
// Bad: Multiple snapshots for one logical operation
void handleInsertMixer()
{
    createMixer();
    pushSnapshot(); // ❌
    
    disconnectLinks();
    pushSnapshot(); // ❌
    
    connectMixer();
    pushSnapshot(); // ❌ User can't undo the whole operation at once
}
```

### 3. Memory Considerations

Each snapshot stores the **complete** synth state. For large patches:
- A single snapshot can be several hundred KB
- 100 undo states ≈ tens of MB

**Future Optimization Ideas:**
- Implement delta-based snapshots (store only changes)
- Add configurable undo limit
- Compress snapshots using JUCE's `GZIPCompressorOutputStream`

### 4. Thread Safety

The undo system runs on the **UI thread** (ImGui render thread), separate from the audio thread:

✅ **Safe:**
- Calling `pushSnapshot()` from UI event handlers
- Calling `restoreSnapshot()` from keyboard shortcuts
- Accessing `undoStack`/`redoStack` in render loop

❌ **Unsafe:**
- Calling undo methods from `processBlock()`
- Accessing undo stacks from audio callback

**The synth's state serialization is thread-safe** via JUCE's audio processor lock.

---

## Implementation Examples

### Example 1: Adding Undo to a New Menu Action

```cpp
// In ImGuiNodeEditorComponent.cpp - Menu rendering code
if (ImGui::MenuItem("My New Action"))
{
    if (synth != nullptr)
    {
        // Perform the action
        synth->performCustomOperation();
        
        // Make it undoable
        pushSnapshot();
    }
}
```

### Example 2: Adding Undo to a Custom Module Operation

```cpp
// In your CustomModuleProcessor.cpp
void CustomModuleProcessor::drawParametersInNode(
    float itemWidth,
    const std::function<bool(const juce::String&)>& isParamModulated,
    const std::function<void()>& onModificationEnded)
{
    if (ImGui::Button("Randomize Settings"))
    {
        randomizeInternalSettings();
        onModificationEnded(); // Create undo state
    }
}
```

### Example 3: Undo After Complex Multi-Step Operation

```cpp
void ImGuiNodeEditorComponent::handleCustomAutoConnect()
{
    // Step 1: Create multiple nodes
    auto osc1 = synth->addModule("VCO");
    auto osc2 = synth->addModule("VCO");
    auto mixer = synth->addModule("Mixer");
    
    // Step 2: Connect them
    synth->connect(osc1, 0, mixer, 0);
    synth->connect(osc2, 0, mixer, 1);
    
    // Step 3: Position them nicely
    pendingNodePositions[(int)osc1Lid] = ImVec2(100, 100);
    pendingNodePositions[(int)osc2Lid] = ImVec2(100, 300);
    pendingNodePositions[(int)mixerLid] = ImVec2(400, 200);
    
    // Step 4: ONE undo state for the entire operation
    pushSnapshot();
}
```

---

## Limitations and Considerations

### Current Limitations

1. **No Undo Limit**: The stack grows unbounded (until memory exhaustion)
   - **Mitigation**: Could add `maxUndoStackSize` parameter

2. **Full State Storage**: Every snapshot stores the complete patch
   - **Mitigation**: Could implement delta/diff-based snapshots

3. **No Undo Across Sessions**: Undo history is cleared when synth is destroyed
   - **Mitigation**: Could serialize undo stack to disk

4. **No Undo for File Operations**: Loading/saving patches clears undo history
   - **Mitigation**: Could preserve undo stack through loads

5. **Memory Usage**: Large patches with long history can consume significant RAM
   - **Mitigation**: Add optional compression for old snapshots

### Design Trade-offs

**Simplicity vs. Efficiency:**
- Current design prioritizes simplicity and reliability
- Full state snapshots are easier to implement and debug
- Delta-based systems are more complex but more efficient

**Consistency vs. Granularity:**
- System creates snapshots at logical operation boundaries
- User can't undo individual sub-steps of complex operations
- This prevents "partial undo" bugs where patch is in invalid state

---

## State Restoration Details

### What Gets Restored?

#### Audio Graph State:
- All module processor parameter values (APVTS state)
- Audio connection topology (which pins connect to which)
- Modulation routing (parameter modulation connections)
- Module-specific internal state (sequencer patterns, sample references, etc.)

#### UI/Editor State:
- Node positions (X, Y coordinates in grid space)
- Node muted/bypassed states
- Output node position
- **NOT restored**: selection state, zoom level (these are transient)

### Restore Order

The restoration happens in two phases:

1. **Audio State First** (line 4241-4242):
   ```cpp
   synth->setStateInformation(s.synthState.getData(), (int)s.synthState.getSize());
   ```
   - Reconstructs the entire audio graph
   - May add/remove modules
   - Reconnects all audio and modulation routing

2. **UI State Second** (line 4244):
   ```cpp
   applyUiValueTreeNow(s.uiState);
   ```
   - Repositions nodes to match saved layout
   - Restores visual properties

**Why This Order?**
- UI state depends on nodes existing in the synth
- Restoring audio first ensures all node IDs are valid
- UI restore then matches visual layout to restored graph

### Graph Rebuild After Restore

After restoration, the system triggers a graph rebuild:
```cpp
graphNeedsRebuild = true;
```

This flag tells the renderer to:
1. Clear all transient rendering data
2. Rebuild ImNodes visual representation
3. Recompute link IDs and pin positions
4. Update node appearance based on new state

---

## Advanced Topics

### Dirty State Tracking

The `isPatchDirty` flag (line 4236, 4227) tracks whether the patch has unsaved changes:

```cpp
pushSnapshot()
{
    // ... create snapshot ...
    isPatchDirty = true; // Mark patch as having unsaved changes
}
```

This flag is used to:
- Display "*" in window title
- Prompt user before closing unsaved work
- Determine if save is needed

**Reset when:**
- Patch is saved to disk
- New patch is loaded
- Synth model is replaced

### Transient Data Clearing

After undo/redo, certain frame-specific data is cleared:

```cpp
linkIdToAttrs.clear();
```

**Why?**
- `linkIdToAttrs` maps ImNodes link IDs to audio connection attributes
- These IDs are assigned per-frame during rendering
- After graph structure changes, old IDs are invalid
- Clearing forces regeneration on next frame

### Pending Position Handling

The `pendingNodePositions` map stores positions for nodes that will exist after current operation:

```cpp
std::unordered_map<int, ImVec2> pendingNodePositions;
```

**Used for:**
- Positioning newly created nodes before they render
- Applying positions after batch operations
- Ensuring snapshots capture intended layout

**Special handling in `pushSnapshot()`:**
- Merges pending positions into captured UI state
- Ensures undo will restore correct positions
- Prevents (0,0) placeholder positions from being saved

---

## Debugging Tips

### Inspecting Undo Stack

Add debug logging to track snapshot creation:

```cpp
void ImGuiNodeEditorComponent::pushSnapshot()
{
    Snapshot s;
    s.uiState = getUiValueTree();
    if (synth != nullptr)
        synth->getStateInformation(s.synthState);
    
    // Debug: Log snapshot details
    DBG("=== SNAPSHOT CREATED ===");
    DBG("Undo stack size: " + juce::String(undoStack.size()));
    DBG("Synth state size: " + juce::String(s.synthState.getSize()) + " bytes");
    DBG("UI nodes: " + juce::String(s.uiState.getNumChildren()));
    
    undoStack.push_back(std::move(s));
    redoStack.clear();
    isPatchDirty = true;
}
```

### Validating Restoration

Add assertions to ensure restoration succeeds:

```cpp
void ImGuiNodeEditorComponent::restoreSnapshot(const Snapshot& s)
{
    jassert(s.synthState.getSize() > 0); // Should have valid state
    
    if (synth != nullptr && s.synthState.getSize() > 0)
    {
        synth->setStateInformation(s.synthState.getData(), (int)s.synthState.getSize());
        DBG("Restored synth state: " + juce::String(synth->getModulesInfo().size()) + " modules");
    }
    
    applyUiValueTreeNow(s.uiState);
    DBG("Restored UI state: " + juce::String(s.uiState.getNumChildren()) + " nodes");
}
```

### Common Issues

**Issue: Undo doesn't restore node positions**
- Check that `getUiValueTree()` is capturing positions correctly
- Verify `applyUiValueTreeNow()` is applying them
- Ensure `graphNeedsRebuild` isn't preventing position queries

**Issue: Undo causes audio glitches**
- Restoration happens on UI thread; shouldn't affect audio
- If glitches occur, investigate audio processor lock contention
- Check if modules are properly implementing `setStateInformation()`

**Issue: Redo stack unexpectedly cleared**
- This is intentional - any new action invalidates redo
- If you want to preserve redo after specific operations, modify `pushSnapshot()`

---

## Future Enhancement Ideas

### 1. Delta-Based Snapshots

Instead of storing full state each time, store only what changed:

```cpp
struct DeltaSnapshot
{
    std::vector<ModuleChange> moduleChanges;  // Only changed modules
    std::vector<ConnectionChange> linkChanges; // Only changed connections
    std::vector<PositionChange> positionChanges; // Only moved nodes
};
```

**Pros:**
- Much smaller memory footprint
- Faster snapshot creation
- Can support longer history

**Cons:**
- More complex implementation
- Harder to debug
- Requires careful change tracking

### 2. Undo Limit with Circular Buffer

Implement a maximum stack size with automatic pruning:

```cpp
const size_t MAX_UNDO_STATES = 100;

void pushSnapshot()
{
    // ... create snapshot ...
    
    undoStack.push_back(std::move(s));
    
    // Prune oldest if over limit
    if (undoStack.size() > MAX_UNDO_STATES)
        undoStack.erase(undoStack.begin());
    
    redoStack.clear();
}
```

### 3. Persistent Undo Across Sessions

Save undo history with the patch:

```cpp
void savePatchWithHistory(const juce::File& file)
{
    juce::ValueTree root("PatchData");
    
    // Save current state
    root.addChild(getCurrentPatchTree(), -1, nullptr);
    
    // Save undo history
    juce::ValueTree history("UndoHistory");
    for (const auto& snapshot : undoStack)
        history.addChild(serializeSnapshot(snapshot), -1, nullptr);
    
    root.addChild(history, -1, nullptr);
    
    // Write to disk
    auto xml = root.createXml();
    xml->writeTo(file);
}
```

### 4. Undo Coalescing

Merge consecutive similar operations:

```cpp
void pushSnapshot(SnapshotType type = SnapshotType::Normal)
{
    // If last snapshot was a parameter change and this is too,
    // replace instead of adding new
    if (!undoStack.empty() &&
        type == SnapshotType::ParameterChange &&
        undoStack.back().type == SnapshotType::ParameterChange)
    {
        undoStack.back() = createSnapshot();
        return;
    }
    
    undoStack.push_back(createSnapshot());
    redoStack.clear();
}
```

### 5. Branching History (Git-like)

Allow exploring alternate edit branches:

```
        ┌─ Branch A ─┐
State 1 ─┤            ├─ State 3 (current)
        └─ Branch B ─┘
```

This would require a tree structure instead of linear stacks.

---

## Summary

The undo/redo system is a **full-state snapshot architecture** that captures both audio processing and UI layout at strategic points in the user's workflow. It prioritizes:

1. **Reliability**: Complete state capture eliminates partial-undo bugs
2. **Simplicity**: Linear history is easy to reason about and debug
3. **Consistency**: Operations undo as complete units, not individual sub-steps
4. **Integration**: Works seamlessly with JUCE's state serialization

The system is extensible and can be enhanced with delta-based storage, undo limits, and persistent history as needed. For most use cases, the current implementation provides robust, predictable undo/redo functionality with minimal complexity.

---

**Last Updated**: October 2025  
**Version**: 1.0  
**Related Files**:
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.h`
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`
- `juce/Source/audio/modules/ModuleProcessor.h`



================================================================================
FILE: guides\TEMPO_CLOCK_INTEGRATION_GUIDE.md
================================================================================


# Tempo Clock Module Integration Guide

## Overview

This guide explains how the **TempoClockModuleProcessor** integrates with the global transport system and provides patterns for implementing similar transport-aware behavior in other modules.

## Table of Contents

1. [Transport System Architecture](#transport-system-architecture)
2. [Reading Transport State](#reading-transport-state)
3. [Controlling Transport](#controlling-transport)
4. [Tempo Synchronization Modes](#tempo-synchronization-modes)
5. [Division Override System](#division-override-system)
6. [CV Input Edge Detection](#cv-input-edge-detection)
7. [Live Parameter Telemetry](#live-parameter-telemetry)
8. [UI Integration Patterns](#ui-integration-patterns)
9. [Implementation Checklist](#implementation-checklist)

---

## Transport System Architecture

### Key Concepts

The transport system provides:
- **Global BPM** - Shared tempo across all modules
- **Song Position** - Current playback position in beats
- **Play/Stop State** - Global transport control
- **Division Override** - One clock can control global subdivision
- **Tempo Control Flag** - Indicates if a module is controlling the global tempo

### Parent Processor Interface

All modules inherit from `ModuleProcessor` which provides access to the parent `ModularSynthProcessor`:

```cpp
auto* parent = getParent();  // Returns ModularSynthProcessor*
```

### Transport State Structure

The `m_currentTransport` member (inherited from `ModuleProcessor`) contains:

```cpp
struct {
    double bpm;                    // Current tempo
    double songPositionBeats;      // Current position in beats
    bool isPlaying;                // Transport running state
    // ... other fields
} m_currentTransport;
```

This structure is automatically updated **before** each `processBlock()` call via `updateTransportState()`.

---

## Reading Transport State

### Basic Pattern

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    // m_currentTransport is already updated by base class
    double currentBPM = m_currentTransport.bpm;
    double songPosition = m_currentTransport.songPositionBeats;
    bool isPlaying = m_currentTransport.isPlaying;
    
    // Use transport state in your processing...
}
```

### Computing Phase from Transport

```cpp
// Use transport position for stable, drift-free timing
double phaseBeats = m_currentTransport.songPositionBeats;

for (int i = 0; i < numSamples; ++i)
{
    // Advance phase using current BPM
    phaseBeats += (1.0 / sampleRate) * (currentBPM / 60.0);
    
    // Compute subdivision phase
    double scaled = phaseBeats * division;
    double frac = scaled - std::floor(scaled);
    
    // Generate clock output from phase...
}
```

**Why this matters:** Using the transport position ensures all modules stay in sync, even when BPM changes or transport is reset.

---

## Controlling Transport

### Setting Global BPM

```cpp
if (auto* parent = getParent())
{
    parent->setBPM(newBPM);
}
```

### Play/Stop/Reset

```cpp
if (auto* parent = getParent())
{
    parent->setPlaying(true);   // Start transport
    parent->setPlaying(false);  // Stop transport
    parent->resetTransportPosition();  // Reset to beat 0
}
```

### Example: Responding to CV Triggers

```cpp
// Edge detection helper
auto edge = [&](const float* cv, bool& last) {
    bool now = (cv && cv[0] > 0.5f);
    bool rising = now && !last;
    last = now;
    return rising;
};

// Process transport control inputs
if (edge(playCV, lastPlayHigh))   if (auto* p = getParent()) p->setPlaying(true);
if (edge(stopCV, lastStopHigh))   if (auto* p = getParent()) p->setPlaying(false);
if (edge(resetCV, lastResetHigh)) if (auto* p = getParent()) p->resetTransportPosition();
```

---

## Tempo Synchronization Modes

The Tempo Clock module supports two modes:

### Mode 1: Controlling Transport (Default)

```cpp
// This module CONTROLS the global BPM
if (auto* parent = getParent())
{
    parent->setBPM(localBPM);
    parent->setTempoControlledByModule(true);  // Mark as controlling
}
```

**Effect:**
- Module pushes its BPM to global transport
- Other modules see this BPM in `m_currentTransport.bpm`
- Top bar BPM control is **greyed out** (controlled by module)

### Mode 2: Syncing to Transport

```cpp
// This module FOLLOWS the global BPM
if (auto* parent = getParent())
{
    localBPM = (float)m_currentTransport.bpm;  // Read from transport
    parent->setTempoControlledByModule(false);  // Not controlling
}
```

**Effect:**
- Module reads BPM from transport
- Top bar BPM control is **enabled** (user can adjust)
- Module responds to external tempo changes

### Implementing Switchable Modes

```cpp
bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;

if (auto* parent = getParent())
{
    if (syncToHost)
    {
        // Mode 2: FOLLOW transport
        bpm = (float)m_currentTransport.bpm;
        parent->setTempoControlledByModule(false);
    }
    else
    {
        // Mode 1: CONTROL transport
        parent->setBPM(bpm);
        parent->setTempoControlledByModule(true);
    }
}
```

---

## Division Override System

### Purpose

Allows one Tempo Clock to broadcast its subdivision (1/4, 1/16, etc.) globally, forcing all synced modules to use the same division.

### Implementation

#### Broadcasting Division (Master Clock)

```cpp
bool divisionOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
int localDivisionIdx = divisionParam ? (int)divisionParam->load() : 3;  // 0=1/32, 3=1/4, etc.

if (auto* parent = getParent())
{
    if (divisionOverride)
    {
        // Broadcast this module's division globally
        parent->setGlobalDivisionIndex(localDivisionIdx);
    }
    else
    {
        // Not overriding - clear the broadcast
        parent->setGlobalDivisionIndex(-1);
    }
}
```

#### Reading Global Division (Follower Module)

```cpp
if (auto* parent = getParent())
{
    int globalDiv = parent->getGlobalDivisionIndex();
    
    if (globalDiv >= 0)
    {
        // Use global division (master clock is broadcasting)
        divisionIdx = globalDiv;
    }
    else
    {
        // Use local division parameter
        divisionIdx = (int)divisionParam->load();
    }
}
```

### Division Index to Value Mapping

```cpp
static const double divisions[] = {
    1.0/32.0,  // idx 0: 1/32 notes
    1.0/16.0,  // idx 1: 1/16 notes
    1.0/8.0,   // idx 2: 1/8 notes
    1.0/4.0,   // idx 3: 1/4 notes (quarter notes)
    1.0/2.0,   // idx 4: 1/2 notes (half notes)
    1.0,       // idx 5: whole notes
    2.0,       // idx 6: 2 bars
    4.0        // idx 7: 4 bars
};

double div = divisions[juce::jlimit(0, 7, divisionIdx)];
double scaled = phaseBeats * div;  // Scale transport position by division
```

---

## CV Input Edge Detection

### Pattern: Reading CV Inputs Only When Connected

```cpp
// Check connection state ONCE per buffer (fast)
const bool playMod = isParamInputConnected("play_mod");
const bool stopMod = isParamInputConnected("stop_mod");
const bool resetMod = isParamInputConnected("reset_mod");

// Get read pointers ONLY if connected
const float* playCV  = (playMod  && in.getNumChannels() > 4) ? in.getReadPointer(4) : nullptr;
const float* stopCV  = (stopMod  && in.getNumChannels() > 5) ? in.getReadPointer(5) : nullptr;
const float* resetCV = (resetMod && in.getNumChannels() > 6) ? in.getReadPointer(6) : nullptr;
```

**Benefits:**
- Zero overhead when inputs are disconnected
- Follows best practices from TTS/BestPractice modules

### Edge Detection Helper

```cpp
// Lambda for detecting rising edges (0->1 transitions)
auto edge = [&](const float* cv, bool& last) {
    bool now = (cv && cv[0] > 0.5f);  // High when CV > 0.5
    bool rising = now && !last;        // Rising edge
    last = now;                        // Store state for next frame
    return rising;
};

// Usage:
if (edge(playCV, lastPlayHigh))   { /* Trigger action */ }
if (edge(stopCV, lastStopHigh))   { /* Trigger action */ }
if (edge(resetCV, lastResetHigh)) { /* Trigger action */ }
```

### Member Variables for Edge Detection

```cpp
class YourModuleProcessor : public ModuleProcessor
{
private:
    // Edge detection state
    bool lastPlayHigh = false;
    bool lastStopHigh = false;
    bool lastResetHigh = false;
    bool lastTapHigh = false;
    // ... etc
};
```

---

## Live Parameter Telemetry

### Purpose

Publish real-time values to the UI so parameters can display actual processed values (e.g., after CV modulation).

### Publishing Values

```cpp
void YourModuleProcessor::processBlock(...)
{
    // Compute final values (after CV modulation)
    float finalBPM = bpmParam->load();
    if (bpmCV)
    {
        const float cv = juce::jlimit(0.0f, 1.0f, bpmCV[0]);
        finalBPM = juce::jmap(std::pow(cv, 0.3f), 0.0f, 1.0f, 20.0f, 300.0f);
    }
    
    // Publish live telemetry (used by UI)
    setLiveParamValue("bpm_live", finalBPM);
    setLiveParamValue("swing_live", finalSwing);
    setLiveParamValue("phase_live", currentPhase);
}
```

### Reading Values in UI

```cpp
void YourModuleProcessor::drawParametersInNode(...)
{
    // Check if parameter is modulated
    bool bpmMod = isParamModulated("bpm_mod");
    
    // Read live value if modulated, otherwise read parameter
    float displayBPM = bpmMod 
        ? getLiveParamValueFor("bpm_mod", "bpm_live", bpmParam->load())
        : bpmParam->load();
    
    // Display with modulation indicator
    if (bpmMod) ImGui::BeginDisabled();
    ImGui::SliderFloat("BPM", &displayBPM, 20.0f, 300.0f, "%.1f");
    if (bpmMod) {
        ImGui::EndDisabled();
        ImGui::SameLine();
        ImGui::TextUnformatted("(mod)");
    }
}
```

---

## UI Integration Patterns

### Pattern 1: Disabling Controls When Synced

```cpp
// Grey out BPM control when synced to host
bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;

if (syncToHost) ImGui::BeginDisabled();

if (ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f, "%.1f"))
{
    if (!syncToHost)  // Only allow changes when NOT synced
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("bpm")))
            *p = bpm;
    }
}

if (syncToHost) {
    ImGui::EndDisabled();
    ImGui::SameLine();
    ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.8f, 1.0f), "(synced)");
}
```

### Pattern 2: Status Indicators

```cpp
// Show sync status prominently
if (syncToHost)
{
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 1.0f, 0.8f, 1.0f));
    ImGui::Text("⚡ SYNCED TO HOST TRANSPORT");
    ImGui::PopStyleColor();
}

if (divisionOverride)
{
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.2f, 1.0f));
    ImGui::Text("⚡ MASTER DIVISION SOURCE");
    ImGui::PopStyleColor();
}
```

### Pattern 3: Live Clock Display

```cpp
// Animated beat indicator (4 boxes for 4/4 time)
float phase = getLiveParamValue("phase_live", 0.0f);
int currentBeat = (int)(phase * 4.0f) % 4;

for (int i = 0; i < 4; ++i)
{
    if (i > 0) ImGui::SameLine();
    
    bool isCurrentBeat = (currentBeat == i);
    ImVec4 color = isCurrentBeat 
        ? ImVec4(1.0f, 0.3f, 0.3f, 1.0f)  // Red when active
        : ImVec4(0.3f, 0.3f, 0.3f, 1.0f); // Grey when inactive
    
    ImGui::PushStyleColor(ImGuiCol_Button, color);
    ImGui::Button(juce::String(i + 1).toRawUTF8(), ImVec2(itemWidth * 0.23f, 30));
    ImGui::PopStyleColor();
}

// Current BPM display
ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.0f, 0.7f, 1.0f));
ImGui::Text("♩ = %.1f BPM", getLiveParamValue("bpm_live", bpm));
ImGui::PopStyleColor();
```

### Pattern 4: Help Tooltips

```cpp
auto HelpMarker = [](const char* desc) {
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip()) {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
};

// Usage:
ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f);
ImGui::SameLine();
HelpMarker("Beats per minute (20-300 BPM)\nDisabled when synced to host");
```

---

## Implementation Checklist

### For Modules That Need Transport Awareness

- [ ] **Read transport state** from `m_currentTransport` (automatically updated)
- [ ] **Use transport position** for timing instead of local counters
- [ ] **Respect global BPM** unless your module is controlling it
- [ ] **Add sync parameter** if module can follow OR control transport
- [ ] **Call `setTempoControlledByModule()`** to indicate control state
- [ ] **Check global division** if your module uses subdivisions
- [ ] **Publish live telemetry** for UI display

### For Modules That Control Transport

- [ ] **Call `setBPM()`** when controlling global tempo
- [ ] **Call `setTempoControlledByModule(true)`** when active
- [ ] **Call `setTempoControlledByModule(false)`** when syncing
- [ ] **Handle play/stop/reset** from CV inputs
- [ ] **Disable BPM control** in UI when syncing to host
- [ ] **Show sync status** prominently in UI

### For Modules That Use Division Override

- [ ] **Check `getGlobalDivisionIndex()`** before using local division
- [ ] **Use global division** when >= 0, local division when -1
- [ ] **Optionally broadcast** division using `setGlobalDivisionIndex()`
- [ ] **Add divisionOverride parameter** if module can be master
- [ ] **Show override status** in UI

### Parameter Routing

- [ ] **Map CV inputs** to virtual parameter IDs
- [ ] **Implement `getParamRouting()`** for input routing
- [ ] **Check connections** before reading CV buffers
- [ ] **Use edge detection** for trigger inputs
- [ ] **Store edge state** in member variables

### UI Best Practices

- [ ] **Disable controls** when externally controlled
- [ ] **Show modulation indicators** "(mod)" next to live values
- [ ] **Show sync status** with colored text/icons
- [ ] **Display live values** using telemetry
- [ ] **Add help tooltips** for complex parameters
- [ ] **Group related controls** with section headers
- [ ] **Use consistent colors** (green=synced, yellow=master, red=active)

---

## Common Patterns Summary

### Reading BPM

```cpp
// Simple: Just read current BPM
double bpm = m_currentTransport.bpm;
```

### Controlling BPM

```cpp
// Set global BPM and mark as controlling
if (auto* p = getParent()) {
    p->setBPM(myBPM);
    p->setTempoControlledByModule(true);
}
```

### Reading Division

```cpp
// Check for global division override
int div = 3;  // Default to 1/4
if (auto* p = getParent()) {
    int globalDiv = p->getGlobalDivisionIndex();
    if (globalDiv >= 0) div = globalDiv;
    else div = (int)divisionParam->load();
}
```

### Syncing to Transport

```cpp
// Use transport position for stable timing
double phase = m_currentTransport.songPositionBeats;
for (int i = 0; i < numSamples; ++i) {
    phase += (1.0 / sampleRate) * (bpm / 60.0);
    // ... use phase for clock generation
}
```

---

## Example: Minimal Transport-Aware Module

```cpp
class MyTransportModule : public ModuleProcessor
{
public:
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi) override
    {
        // 1. Read transport state (already updated by base class)
        double bpm = m_currentTransport.bpm;
        double songPos = m_currentTransport.songPositionBeats;
        bool playing = m_currentTransport.isPlaying;
        
        // 2. Check for global division override
        int divIdx = 3;  // Default 1/4
        if (auto* p = getParent()) {
            int globalDiv = p->getGlobalDivisionIndex();
            if (globalDiv >= 0) divIdx = globalDiv;
        }
        
        // 3. Use transport position for timing
        double phase = songPos;
        for (int i = 0; i < buffer.getNumSamples(); ++i) {
            phase += (1.0 / sampleRate) * (bpm / 60.0);
            // ... process using phase
        }
        
        // 4. Publish telemetry for UI
        setLiveParamValue("phase_live", (float)phase);
    }
};
```

---

## Questions to Ask When Implementing

1. **Does my module need to know the current BPM?**
   - YES: Read `m_currentTransport.bpm`
   - Add sync parameter if module should control OR follow

2. **Does my module need timing/phase information?**
   - YES: Use `m_currentTransport.songPositionBeats`
   - Advance phase using BPM/sampleRate formula

3. **Should my module respect global division?**
   - YES: Check `getGlobalDivisionIndex()` before using local division
   - Fallback to local division when global is -1

4. **Does my module generate tempo?**
   - YES: Call `setBPM()` and `setTempoControlledByModule(true)`
   - Disable in UI when syncing to host

5. **Does my module respond to transport controls?**
   - YES: Handle play/stop/reset from CV inputs
   - Use edge detection pattern

6. **Do I need to show live values in UI?**
   - YES: Publish telemetry with `setLiveParamValue()`
   - Read with `getLiveParamValue()` in UI code

---

## Related Files

- `TempoClockModuleProcessor.cpp` - Reference implementation
- `ModularSynthProcessor.h` - Parent processor interface
- `ModuleProcessor.h` - Base class with transport support
- `StepSequencerModuleProcessor.cpp` - Example of division override usage

---

## Conclusion

The transport system provides a unified way for modules to:
- Share timing information
- Control or follow global tempo
- Synchronize subdivisions
- Respond to transport controls

By following these patterns, your modules will integrate seamlessly with the rest of the synthesis environment and provide a consistent user experience.

For most modules, you only need to:
1. Read `m_currentTransport` for timing
2. Check global division if using subdivisions
3. Show live values in UI with telemetry

Advanced modules can control the transport or broadcast divisions, but this is optional.


