
================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "../modules/ModuleProcessor.h"
#include "../utils/TapProcessor.h"

class ModularSynthProcessor : public juce::AudioProcessor
{
public:
    ModularSynthProcessor();
    ~ModularSynthProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    const juce::String getName() const override { return "Modular Synth"; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return true; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    // Public API (initial)
public:
    using Node = juce::AudioProcessorGraph::Node;
    using NodeID = juce::AudioProcessorGraph::NodeID;

    NodeID addModule(const juce::String& moduleType);
    void removeModule(const NodeID& nodeID);
    void clearAll(); // Add this line
    void clearAllConnections(); // Add this line
    void clearOutputConnections(); // <<< ADD THIS LINE
    void clearConnectionsForNode(const NodeID& nodeID); // <<< ADD THIS LINE
    bool connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    void commitChanges();
    NodeID getOutputNodeID() const { return audioOutputNode ? audioOutputNode->nodeID : NodeID{}; }
    // Introspection for editor
    std::vector<std::pair<juce::uint32, juce::String>> getModulesInfo() const;
    juce::AudioProcessorGraph::NodeID getNodeIdForLogical (juce::uint32 logicalId) const;
    juce::uint32 getLogicalIdForNode (const NodeID& nodeId) const;
    bool disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    struct ConnectionInfo
    {
        juce::uint32 srcLogicalId { 0 };
        int srcChan { 0 };
        juce::uint32 dstLogicalId { 0 }; // 0 means audio output
        int dstChan { 0 };
        bool dstIsOutput { false };
    };
    std::vector<ConnectionInfo> getConnectionsInfo() const;
    bool isParameterModulated(juce::uint32 logicalId, const juce::String& paramId) const;

    // Access a module processor for UI parameter editing
    ModuleProcessor* getModuleForLogical (juce::uint32 logicalId) const;

    // Modulation routes (control audio -> parameter)
    struct ModRoute { NodeID srcNode; int srcChan; juce::uint32 dstLogicalId; juce::String paramId; float depth; juce::AudioProcessorGraph::NodeID tapNode; };
    std::vector<ModRoute> modRoutes;
    bool addModulationRoute (const NodeID& srcNode, int srcChan, juce::uint32 dstLogicalId, const juce::String& paramId, float depth = 1.0f);
    bool addModulationRouteByLogical (juce::uint32 srcLogicalId, int srcChan, juce::uint32 dstLogicalId, const juce::String& paramId, float depth = 1.0f)
    { return addModulationRoute (getNodeIdForLogical (srcLogicalId), srcChan, dstLogicalId, paramId, depth); }
    void clearModulationForLogical (juce::uint32 logicalId);
    bool removeModulationRoute (const NodeID& srcNode, int srcChan, juce::uint32 dstLogicalId);
    struct ModRouteInfo { juce::uint32 srcLogicalId; int srcChan; juce::uint32 dstLogicalId; juce::String paramId; float depth; };
    std::vector<ModRouteInfo> getModRoutesInfo() const;

private:
    // The internal graph that represents the modular patch
    std::unique_ptr<juce::AudioProcessorGraph> internalGraph;

    // Special nodes for handling I/O within the internal graph
    Node::Ptr audioInputNode;
    Node::Ptr audioOutputNode;
    Node::Ptr midiInputNode;

    // The APVTS that will expose proxy parameters to the host/AudioEngine
    juce::AudioProcessorValueTreeState apvts;

    // Manage module nodes (legacy map by NodeID.uid)
    std::map<juce::uint32, Node::Ptr> modules; // keyed by NodeID.uid
    // Logical ID mapping for preset save/load
    struct LogicalModule
    {
        juce::AudioProcessorGraph::NodeID nodeID;
        juce::String type;
    };
    std::map<juce::uint32, LogicalModule> logicalIdToModule; // logicalId -> module
    juce::uint32 nextLogicalId { 1 };

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModularSynthProcessor)
};




================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.cpp
================================================================================


#include "ModularSynthProcessor.h"
#include "../modules/VCOModuleProcessor.h"
#include "../modules/VCFModuleProcessor.h"
#include "../modules/VCAModuleProcessor.h"
#include "../modules/NoiseModuleProcessor.h"
#include "../modules/LFOModuleProcessor.h"
#include "../modules/ADSRModuleProcessor.h"
#include "../modules/MixerModuleProcessor.h"
#include "../modules/DelayModuleProcessor.h"
#include "../modules/ReverbModuleProcessor.h"
#include "../modules/AttenuverterModuleProcessor.h"
#include "../modules/ScopeModuleProcessor.h"
#include "../modules/SAndHModuleProcessor.h"
#include "../modules/StepSequencerModuleProcessor.h"
#include "../modules/MathModuleProcessor.h"
#include "../modules/MapRangeModuleProcessor.h"
#include "../modules/RandomModuleProcessor.h"
#include "../modules/RateModuleProcessor.h"
#include "../modules/QuantizerModuleProcessor.h"
#include "../modules/SequentialSwitchModuleProcessor.h"
#include "../modules/LogicModuleProcessor.h"
#include "../modules/ValueModuleProcessor.h"
#include "../modules/ClockDividerModuleProcessor.h"
#include "../modules/WaveshaperModuleProcessor.h"
#include "../modules/TTSModuleProcessor.h"
#include "../modules/TTSPerformerModuleProcessor.h"
#include "../modules/VocalTractFilterModuleProcessor.h"
#include "../modules/SampleLoaderModuleProcessor.h"

ModularSynthProcessor::ModularSynthProcessor()
    : juce::AudioProcessor(BusesProperties()
                            .withInput("Input", juce::AudioChannelSet::stereo(), true)
                            .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "ModularSynthParams", {})
{
    internalGraph = std::make_unique<juce::AudioProcessorGraph>();

    using IOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor;
    audioInputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioInputNode));
    audioOutputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioOutputNode));
    midiInputNode  = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::midiInputNode));

    // Intentionally do NOT connect audio input -> output.
    // The modular container acts as a source; connections are created programmatically.

    internalGraph->addConnection({ { midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex },
                                   { audioOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex } });
}

ModularSynthProcessor::~ModularSynthProcessor() {}

void ModularSynthProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Ensure the internal graph has matching I/O channel counts before preparation
    internalGraph->setPlayConfigDetails(getTotalNumInputChannels(), getTotalNumOutputChannels(), sampleRate, samplesPerBlock);
    internalGraph->prepareToPlay(sampleRate, samplesPerBlock);

    // Recreate tap nodes for modulation routes if any
    for (auto& r : modRoutes)
    {
        if (r.tapNode.uid != 0)
            internalGraph->removeNode (r.tapNode, juce::AudioProcessorGraph::UpdateKind::none);
        auto tap = internalGraph->addNode (std::make_unique<TapProcessor>(), {}, juce::AudioProcessorGraph::UpdateKind::none);
        r.tapNode = tap->nodeID;
        // Route source channel to tap
        internalGraph->addConnection ({ { r.srcNode, r.srcChan }, { r.tapNode, 0 } }, juce::AudioProcessorGraph::UpdateKind::none);
    }
    internalGraph->rebuild();
}

void ModularSynthProcessor::releaseResources()
{
    internalGraph->releaseResources();
}

void ModularSynthProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    internalGraph->processBlock(buffer, midiMessages);

    // Read tap values and apply modulation
    for (auto& r : modRoutes)
    {
        auto* tapNode = internalGraph->getNodeForId (r.tapNode);
        if (tapNode == nullptr) continue;
        auto* tap = dynamic_cast<TapProcessor*> (tapNode->getProcessor());
        if (tap == nullptr) continue;
        // Normalised modulation value from source (0..1); modules that need a
        // specific physical range will map it themselves (e.g. sequencer rate 0.01..50 Hz).
        const float valueNorm = juce::jlimit (0.0f, 1.0f, tap->getLastValue());
        if (auto* dst = getModuleForLogical (r.dstLogicalId))
        {
            auto* p = dst->getAPVTS().getParameter (r.paramId);
            if (auto* pf = dynamic_cast<juce::AudioParameterFloat*> (p))
            {
                const auto& range = pf->range;
                const float targetValue = juce::jlimit (range.start, range.end, range.convertFrom0to1 (valueNorm));
                *pf = targetValue;
            }
        }
    }
}

void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);

    // Modules
    juce::ValueTree modsVT("modules");
    // Build reverse lookup NodeID.uid -> logicalId
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32) kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int) logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        // Attach params as child using the module's APVTS state
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                juce::ValueTree params = modProc->getAPVTS().copyState();
                // Wrap params under a known tag
                juce::ValueTree paramsWrapper("params");
                paramsWrapper.addChild(params, -1, nullptr);
                mv.addChild(paramsWrapper, -1, nullptr);
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    // Connections
    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32) c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32) c.destination.nodeID.uid;
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int) dstIt->second, nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else
        {
            continue; // skip non-module connections
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    // Modulation routes
    juce::ValueTree modsVT2 ("modRoutes");
    for (const auto& r : modRoutes)
    {
        juce::ValueTree mr ("modRoute");
        const juce::uint32 srcLogical = getLogicalIdForNode (r.srcNode);
        mr.setProperty ("srcId", (int) srcLogical, nullptr);
        mr.setProperty ("srcChan", (int) r.srcChan, nullptr);
        mr.setProperty ("dstId", (int) r.dstLogicalId, nullptr);
        mr.setProperty ("param", r.paramId, nullptr);
        mr.setProperty ("depth", r.depth, nullptr);
        modsVT2.addChild (mr, -1, nullptr);
    }
    root.addChild (modsVT2, -1, nullptr);

    // Serialize to XML
    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}

void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes)));
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("Snapshot is invalid or empty. Aborting restore.");
        return;
    }

    // --- THIS IS THE NEW, CORRECTED LOGIC ---

    // 1. Clear the entire existing state first.
    clearAll();

    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid()) return;

    // 2. First pass: Find the maximum logical ID in the preset to prevent future collisions.
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1; // Set the counter to be safely above the highest loaded ID.

    // 3. Second pass: Recreate all modules and map their logical IDs.
    std::map<juce::uint32, NodeID> logicalToNodeId;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module")) continue;

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        if (logicalId > 0 && type.isNotEmpty())
        {
            // Create the module using the existing addModule function
            auto nodeId = addModule(type);
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                // Remove the auto-assigned logical mapping and assign the correct one
                for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                {
                    if (it->second.nodeID == nodeId)
                        it = logicalIdToModule.erase(it);
                    else
                        ++it;
                }
                logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                logicalToNodeId[logicalId] = nodeId;

                // Restore parameters for this module
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                        mp->getAPVTS().replaceState(params);
                }
            }
        }
    }

    // 4. Recreate connections using the now-populated logical ID map.
    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
            }
        }
    }

    // 5. Recreate modulation routes.
    auto mvt = root.getChildWithName("modRoutes");
    if (mvt.isValid())
    {
        for (int i = 0; i < mvt.getNumChildren(); ++i)
        {
            auto mv = mvt.getChild(i);
            if (!mv.hasType("modRoute")) continue;
            
            juce::uint32 sId = (juce::uint32)(int)mv.getProperty("srcId", 0);
            int sCh = (int)mv.getProperty("srcChan", 0);
            juce::uint32 dId = (juce::uint32)(int)mv.getProperty("dstId", 0);
            juce::String param = mv.getProperty("param").toString();
            float depth = (float)mv.getProperty("depth", 1.0f);

            if (sId != 0 && dId != 0 && param.isNotEmpty())
            {
                addModulationRouteByLogical(sId, sCh, dId, param, depth);
            }
        }
    }

    // 6. Finalize all changes.
    commitChanges();
}

namespace {
    static juce::String toLowerId (const juce::String& s)
    {
        return s.toLowerCase();
    }

    using Creator = std::function<std::unique_ptr<juce::AudioProcessor>()>;

    static std::map<juce::String, Creator>& getModuleFactory()
    {
        static std::map<juce::String, Creator> factory;
        static bool initialised = false;
        if (!initialised)
        {
            auto reg = [&](const juce::String& key, Creator c) { factory.emplace(toLowerId(key), std::move(c)); };

            reg("vco", []{ return std::make_unique<VCOModuleProcessor>(); });
            reg("vcf", []{ return std::make_unique<VCFModuleProcessor>(); });
            reg("vca", []{ return std::make_unique<VCAModuleProcessor>(); });
            reg("noise", []{ return std::make_unique<NoiseModuleProcessor>(); });
            reg("lfo", []{ return std::make_unique<LFOModuleProcessor>(); });
            reg("adsr", []{ return std::make_unique<ADSRModuleProcessor>(); });
            reg("mixer", []{ return std::make_unique<MixerModuleProcessor>(); });
            reg("delay", []{ return std::make_unique<DelayModuleProcessor>(); });
            reg("reverb", []{ return std::make_unique<ReverbModuleProcessor>(); });
            reg("attenuverter", []{ return std::make_unique<AttenuverterModuleProcessor>(); });
            reg("scope", []{ return std::make_unique<ScopeModuleProcessor>(); });
            reg("s&h", []{ return std::make_unique<SAndHModuleProcessor>(); });
            reg("sandh", []{ return std::make_unique<SAndHModuleProcessor>(); });
            reg("sequencer", []{ return std::make_unique<StepSequencerModuleProcessor>(); });
            reg("stepsequencer", []{ return std::make_unique<StepSequencerModuleProcessor>(); });
            reg("math", []{ return std::make_unique<MathModuleProcessor>(); });
            reg("maprange", []{ return std::make_unique<MapRangeModuleProcessor>(); });
            reg("random", []{ return std::make_unique<RandomModuleProcessor>(); });
            reg("rate", []{ return std::make_unique<RateModuleProcessor>(); });
            reg("quantizer", []{ return std::make_unique<QuantizerModuleProcessor>(); });
            reg("sequentialswitch", []{ return std::make_unique<SequentialSwitchModuleProcessor>(); });
            reg("logic", []{ return std::make_unique<LogicModuleProcessor>(); });
            reg("clockdivider", []{ return std::make_unique<ClockDividerModuleProcessor>(); });
            reg("waveshaper", []{ return std::make_unique<WaveshaperModuleProcessor>(); });
            reg("vocal tract filter", []{ return std::make_unique<VocalTractFilterModuleProcessor>(); });
            reg("value", []{ return std::make_unique<ValueModuleProcessor>(); });
            reg("tts", []{ return std::make_unique<TTSModuleProcessor>(); });
            reg("tts performer", []{ return std::make_unique<TTSPerformerModuleProcessor>(); });
            reg("sample loader", []{ return std::make_unique<SampleLoaderModuleProcessor>(); });

            initialised = true;
        }
        return factory;
    }
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addModule(const juce::String& moduleType)
{
    auto& factory = getModuleFactory();
    const juce::String key = moduleType.toLowerCase();
    std::unique_ptr<juce::AudioProcessor> processor;

    if (auto it = factory.find(key); it != factory.end())
        processor = it->second();

    if (! processor)
    {
        // Try loose match if aliases weren’t added
        for (const auto& kv : factory)
            if (moduleType.equalsIgnoreCase(kv.first)) { processor = kv.second(); break; }
    }

    if (processor)
    {
        auto node = internalGraph->addNode(std::move(processor), {}, juce::AudioProcessorGraph::UpdateKind::none);
        modules[(juce::uint32) node->nodeID.uid] = node;
        const juce::uint32 logicalId = nextLogicalId++;
        logicalIdToModule[logicalId] = LogicalModule{ node->nodeID, moduleType };
        return node->nodeID;
    }

    juce::Logger::writeToLog("[ModSynth][WARN] Unknown module type: " + moduleType);
    return {};
}

void ModularSynthProcessor::removeModule(const NodeID& nodeID)
{
    internalGraph->removeNode(nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    modules.erase((juce::uint32) nodeID.uid);
    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
    {
        if (it->second.nodeID == nodeID) it = logicalIdToModule.erase(it); else ++it;
    }
}

bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    const bool ok = internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
    if (! ok)
    {
        juce::Logger::writeToLog("[ModSynth][WARN] Failed to connect [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                 + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
    }
    return ok;
}

void ModularSynthProcessor::commitChanges()
{
    internalGraph->rebuild();

    // --- BEGIN DIAGNOSTIC INSERTION ---
    juce::Logger::writeToLog("--- Modular Synth Internal Patch State ---");
    juce::Logger::writeToLog("Num Nodes: " + juce::String(internalGraph->getNodes().size()));
    juce::Logger::writeToLog("Num Connections: " + juce::String(internalGraph->getConnections().size()));
    for (const auto& node : internalGraph->getNodes())
    {
        auto* p = node->getProcessor();
        juce::String name = p ? p->getName() : juce::String("<null>");
        const int ins  = p ? p->getTotalNumInputChannels()  : -1;
        const int outs = p ? p->getTotalNumOutputChannels() : -1;
        juce::Logger::writeToLog("  Node: id=" + juce::String(node->nodeID.uid) + " name='" + name + "' ins=" + juce::String(ins) + " outs=" + juce::String(outs));
    }
    for (const auto& conn : internalGraph->getConnections())
    {
        juce::Logger::writeToLog("  Connection: [" + juce::String(conn.source.nodeID.uid) + ":" + juce::String(conn.source.channelIndex)
            + "] -> [" + juce::String(conn.destination.nodeID.uid) + ":" + juce::String(conn.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog("-----------------------------------------");
    // --- END DIAGNOSTIC INSERTION ---
}

void ModularSynthProcessor::clearAll()
{
    // Remove all modulation routes first
    for (auto& r : modRoutes)
        if (r.tapNode.uid != 0)
            internalGraph->removeNode (r.tapNode, juce::AudioProcessorGraph::UpdateKind::none);
    modRoutes.clear();

    // Remove all module nodes
    for (const auto& kv : logicalIdToModule)
    {
        internalGraph->removeNode(kv.second.nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    }

    // Clear tracking maps and reset ID counter
    modules.clear();
    logicalIdToModule.clear();
    nextLogicalId = 1;

    // Rebuild the graph to apply changes
    commitChanges();
}

void ModularSynthProcessor::clearAllConnections()
{
    // Remove all modulation routes first
    for (auto& r : modRoutes)
        if (r.tapNode.uid != 0)
            internalGraph->removeNode (r.tapNode, juce::AudioProcessorGraph::UpdateKind::none);
    modRoutes.clear();

    // Remove all audio connections, except for the internal MIDI connection
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        // Check if this is a MIDI connection by comparing with MIDI channel index
        if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex && 
            conn.destination.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearOutputConnections()
{
    if (audioOutputNode == nullptr)
        return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == audioOutputNode->nodeID)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearConnectionsForNode(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;

    // --- 1. Remove Audio Connections ---
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == nodeID || conn.destination.nodeID == nodeID)
        {
            // Don't remove the internal MIDI pass-through connection
            if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
            {
                internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            }
        }
    }

    // --- 2. Remove Modulation Routes ---
    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);
    if (logicalId != 0)
    {
        // Use the erase-remove idiom to safely remove elements from the vector
        modRoutes.erase(
            std::remove_if(modRoutes.begin(), modRoutes.end(),
                [&](const ModRoute& route)
                {
                    bool shouldRemove = (getLogicalIdForNode(route.srcNode) == logicalId) || (route.dstLogicalId == logicalId);
                    if (shouldRemove && route.tapNode.uid != 0)
                    {
                        // Also remove the associated tap node from the graph
                        internalGraph->removeNode(route.tapNode, juce::AudioProcessorGraph::UpdateKind::none);
                    }
                    return shouldRemove;
                }),
            modRoutes.end());
    }

    // --- 3. Apply all changes ---
    commitChanges();
}

std::vector<std::pair<juce::uint32, juce::String>> ModularSynthProcessor::getModulesInfo() const
{
    std::vector<std::pair<juce::uint32, juce::String>> out;
    out.reserve(logicalIdToModule.size());
    for (const auto& kv : logicalIdToModule)
        out.emplace_back(kv.first, kv.second.type);
    return out;
}

juce::AudioProcessorGraph::NodeID ModularSynthProcessor::getNodeIdForLogical (juce::uint32 logicalId) const
{
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return {};
    return it->second.nodeID;
}

juce::uint32 ModularSynthProcessor::getLogicalIdForNode (const NodeID& nodeId) const
{
    for (const auto& kv : logicalIdToModule)
        if (kv.second.nodeID == nodeId)
            return kv.first;
    return 0;
}

bool ModularSynthProcessor::disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };
    return internalGraph->removeConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}

std::vector<ModularSynthProcessor::ConnectionInfo> ModularSynthProcessor::getConnectionsInfo() const
{
    std::vector<ConnectionInfo> out;
    for (const auto& c : internalGraph->getConnections())
    {
        ConnectionInfo info;
        info.srcLogicalId = getLogicalIdForNode(c.source.nodeID);
        info.srcChan = c.source.channelIndex;
        info.dstLogicalId = getLogicalIdForNode(c.destination.nodeID);
        info.dstChan = c.destination.channelIndex;
        info.dstIsOutput = (c.destination.nodeID == audioOutputNode->nodeID);
        if (info.srcLogicalId != 0 && (info.dstLogicalId != 0 || info.dstIsOutput))
            out.push_back(info);
    }
    return out;
}

bool ModularSynthProcessor::isParameterModulated(juce::uint32 logicalId, const juce::String& paramId) const
{
    for (const auto& route : modRoutes)
    {
        if (route.dstLogicalId == logicalId && route.paramId == paramId)
            return true;
    }
    return false;
}

ModuleProcessor* ModularSynthProcessor::getModuleForLogical (juce::uint32 logicalId) const
{
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return nullptr;
    if (auto* node = internalGraph->getNodeForId(it->second.nodeID))
        return dynamic_cast<ModuleProcessor*>(node->getProcessor());
    return nullptr;
}

bool ModularSynthProcessor::addModulationRoute (const NodeID& srcNode, int srcChan, juce::uint32 dstLogicalId, const juce::String& paramId, float depth)
{
    ModRoute r; r.srcNode = srcNode; r.srcChan = srcChan; r.dstLogicalId = dstLogicalId; r.paramId = paramId; r.depth = depth;
    auto tap = internalGraph->addNode (std::make_unique<TapProcessor>(), {}, juce::AudioProcessorGraph::UpdateKind::none);
    r.tapNode = tap->nodeID;
    const bool ok = internalGraph->addConnection ({ { srcNode, srcChan }, { r.tapNode, 0 } }, juce::AudioProcessorGraph::UpdateKind::none);
    if (! ok)
        return false;
    modRoutes.push_back (r);
    internalGraph->rebuild();
    return true;
}

void ModularSynthProcessor::clearModulationForLogical (juce::uint32 logicalId)
{
    for (auto it = modRoutes.begin(); it != modRoutes.end(); )
    {
        const bool match = (getLogicalIdForNode (it->srcNode) == logicalId) || (it->dstLogicalId == logicalId);
        if (match)
        {
            if (it->tapNode.uid != 0)
                internalGraph->removeNode (it->tapNode, juce::AudioProcessorGraph::UpdateKind::none);
            it = modRoutes.erase (it);
        }
        else ++it;
    }
    internalGraph->rebuild();
}

bool ModularSynthProcessor::removeModulationRoute (const NodeID& srcNode, int srcChan, juce::uint32 dstLogicalId)
{
    for (auto it = modRoutes.begin(); it != modRoutes.end(); ++it)
    {
        if (it->srcNode == srcNode && it->srcChan == srcChan && it->dstLogicalId == dstLogicalId)
        {
            if (it->tapNode.uid != 0)
                internalGraph->removeNode (it->tapNode, juce::AudioProcessorGraph::UpdateKind::none);
            modRoutes.erase (it);
            internalGraph->rebuild();
            return true;
        }
    }
    return false;
}

std::vector<ModularSynthProcessor::ModRouteInfo> ModularSynthProcessor::getModRoutesInfo() const
{
    std::vector<ModRouteInfo> out;
    for (const auto& r : modRoutes)
    {
        ModRouteInfo info; info.srcLogicalId = getLogicalIdForNode (r.srcNode); info.srcChan = r.srcChan; info.dstLogicalId = r.dstLogicalId; info.paramId = r.paramId; info.depth = r.depth; out.push_back (info);
    }
    return out;
}




================================================================================
FILE: juce\Source\audio\graph\VoiceProcessor.cpp
================================================================================


#include "VoiceProcessor.h"

VoiceProcessor::VoiceProcessor()
    : AudioProcessor(BusesProperties()
        .withInput("Input", juce::AudioChannelSet::stereo(), true)
        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "Parameters", createParameterLayout())
{}

void VoiceProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 2 };
    currentSampleRate = sampleRate;
    filter.reset();
    filter.prepare (spec);
    filter.setType (juce::dsp::StateVariableTPTFilterType::lowpass);
    chorus.reset();
    chorus.prepare (spec);
    phaser.reset();
    phaser.prepare (spec);
    reverb.reset();
    reverb.prepare (spec);
    compressor.reset();
    compressor.prepare (spec);
    limiter.reset();
    limiter.prepare (spec);
    waveshaper.reset();
    delayL.reset(); delayR.reset();
    {
        juce::dsp::ProcessSpec specMono { sampleRate, (juce::uint32) samplesPerBlock, 1 };
        delayL.prepare (specMono);
        delayR.prepare (specMono);
    }
    fxPrepared = true;
    preparedChannels = spec.numChannels;
}

void VoiceProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    // Work on the OUTPUT bus buffer explicitly (input may be silent/unconnected)
    auto out = getBusBuffer (buffer, /*isInput*/ false, /*busIndex*/ 0);
    // 1. Generate raw sound directly into the output buffer.
    out.clear();
    renderBlock(out, midi);

    // No logging on audio thread

    // Load all parameters at the top
    const float cutoff        = apvts.getRawParameterValue("filterCutoff")    ? apvts.getRawParameterValue("filterCutoff")->load()    : 20000.0f;
    const float resonance     = apvts.getRawParameterValue("filterResonance") ? apvts.getRawParameterValue("filterResonance")->load() : 1.0f;
    const float chorusRate    = apvts.getRawParameterValue("chorusRate")      ? apvts.getRawParameterValue("chorusRate")->load()      : 1.0f;
    const float chorusDepth   = apvts.getRawParameterValue("chorusDepth")     ? apvts.getRawParameterValue("chorusDepth")->load()     : 0.25f;
    const float chorusMix     = apvts.getRawParameterValue("chorusMix")       ? apvts.getRawParameterValue("chorusMix")->load()       : 0.5f;
    const float phaserRate    = apvts.getRawParameterValue("phaserRate")      ? apvts.getRawParameterValue("phaserRate")->load()      : 0.5f;
    const float phaserDepth   = apvts.getRawParameterValue("phaserDepth")     ? apvts.getRawParameterValue("phaserDepth")->load()     : 0.5f;
    const float phaserCentre  = apvts.getRawParameterValue("phaserCentre")    ? apvts.getRawParameterValue("phaserCentre")->load()    : 1000.0f;
    const float phaserFB      = apvts.getRawParameterValue("phaserFeedback")  ? apvts.getRawParameterValue("phaserFeedback")->load()  : 0.0f;
    const float phaserMix     = apvts.getRawParameterValue("phaserMix")       ? apvts.getRawParameterValue("phaserMix")->load()       : 0.0f;
    const float revRoom       = apvts.getRawParameterValue("reverbRoom")      ? apvts.getRawParameterValue("reverbRoom")->load()      : 0.0f;
    const float revDamp       = apvts.getRawParameterValue("reverbDamp")      ? apvts.getRawParameterValue("reverbDamp")->load()      : 0.5f;
    const float revWidth      = apvts.getRawParameterValue("reverbWidth")     ? apvts.getRawParameterValue("reverbWidth")->load()     : 1.0f;
    const float revMix        = apvts.getRawParameterValue("reverbMix")       ? apvts.getRawParameterValue("reverbMix")->load()       : 0.0f;
    const float delayMs       = apvts.getRawParameterValue("delayTimeMs")     ? apvts.getRawParameterValue("delayTimeMs")->load()     : 0.0f;
    const float delayFB       = apvts.getRawParameterValue("delayFeedback")   ? apvts.getRawParameterValue("delayFeedback")->load()   : 0.0f;
    const float delayMix      = apvts.getRawParameterValue("delayMix")        ? apvts.getRawParameterValue("delayMix")->load()        : 0.0f;
    const float compThresh    = apvts.getRawParameterValue("compThreshold")   ? apvts.getRawParameterValue("compThreshold")->load()   : 0.0f;
    const float compRatio     = apvts.getRawParameterValue("compRatio")       ? apvts.getRawParameterValue("compRatio")->load()       : 1.0f;
    const float compAttack    = apvts.getRawParameterValue("compAttackMs")    ? apvts.getRawParameterValue("compAttackMs")->load()    : 10.0f;
    const float compRelease   = apvts.getRawParameterValue("compReleaseMs")   ? apvts.getRawParameterValue("compReleaseMs")->load()   : 100.0f;
    const float compMakeup    = apvts.getRawParameterValue("compMakeup")      ? apvts.getRawParameterValue("compMakeup")->load()      : 0.0f;
    const float limitThresh   = apvts.getRawParameterValue("limitThreshold")  ? apvts.getRawParameterValue("limitThreshold")->load()  : 0.0f;
    const float limitRelease  = apvts.getRawParameterValue("limitReleaseMs")  ? apvts.getRawParameterValue("limitReleaseMs")->load()  : 10.0f;
    const float drive         = apvts.getRawParameterValue("driveAmount")     ? apvts.getRawParameterValue("driveAmount")->load()     : 0.0f;
    const float driveMix      = apvts.getRawParameterValue("driveMix")        ? apvts.getRawParameterValue("driveMix")->load()        : 0.0f;
    const float gateThresh    = apvts.getRawParameterValue("gateThreshold")   ? apvts.getRawParameterValue("gateThreshold")->load()   : -100.0f;
    const float gateAttack    = apvts.getRawParameterValue("gateAttackMs")    ? apvts.getRawParameterValue("gateAttackMs")->load()    : 1.0f;
    const float gateRelease   = apvts.getRawParameterValue("gateReleaseMs")   ? apvts.getRawParameterValue("gateReleaseMs")->load()   : 50.0f;

    // --- 2. Process FX: Filter then Chorus ---
    // Guard against unprepared FX or channel mismatch
    juce::dsp::AudioBlock<float> block (out);
    if (fxPrepared && preparedChannels > 0 && block.getNumChannels() > 0 && block.getNumChannels() == preparedChannels)
    {
        juce::dsp::ProcessContextReplacing<float> context (block);

        // Apply Filter only if non-neutral
    if (cutoff < 19900.0f || resonance > 1.0f)
    {
        filter.setCutoffFrequency (juce::jlimit (20.0f, 20000.0f, cutoff));
        filter.setResonance       (juce::jlimit (0.1f, 20.0f,   resonance));
        filter.process (context);
    }

    // Apply Chorus only if it has depth
    if (chorusDepth > 0.001f)
    {
        chorus.setRate  (juce::jlimit (0.05f, 5.0f, chorusRate));
        chorus.setDepth (juce::jlimit (0.0f, 1.0f,  chorusDepth));
        chorus.setMix   (juce::jlimit (0.0f, 1.0f,  chorusMix));
        chorus.process (context);
    }

    // Phaser
    if (phaserDepth > 0.001f || std::abs (phaserFB) > 0.001f)
    {
        phaser.setRate (juce::jlimit (0.01f, 10.0f, phaserRate));
        phaser.setDepth (juce::jlimit (0.0f, 1.0f, phaserDepth));
        phaser.setCentreFrequency (juce::jlimit (20.0f, 20000.0f, phaserCentre));
        phaser.setFeedback (juce::jlimit (-0.99f, 0.99f, phaserFB));
        if (phaserMix > 0.0f)
        {
            tempBuffer.makeCopyOf (out, true);
            juce::dsp::AudioBlock<float> tmp (tempBuffer);
            juce::dsp::ProcessContextReplacing<float> ctx (tmp);
            phaser.process (ctx);
            const float dry = 1.0f - phaserMix;
            const float wet = phaserMix;
            for (int ch = 0; ch < out.getNumChannels(); ++ch)
                out.addFrom (ch, 0, tempBuffer, ch, 0, out.getNumSamples(), wet - dry);
            out.applyGain (dry);
        }
        else
        {
            phaser.process (context);
        }
    }

    // Delay (simple stereo): process using dsp::DelayLine processSample to avoid state issues
    if (delayMix > 0.0f && delayMs > 0.0f)
    {
        const float maxDelaySamples = 4.0f * (float) currentSampleRate; // 4s safety
        const float delaySamples = juce::jlimit (1.0f, maxDelaySamples, delayMs * (float) currentSampleRate * 0.001f);
        const float fb = juce::jlimit (0.0f, 0.95f, delayFB);

        delayL.setDelay (delaySamples);
        delayR.setDelay (delaySamples);
        auto* l = out.getWritePointer (0);
        auto* r = out.getNumChannels() > 1 ? out.getWritePointer (1) : l;

        const float dry = 1.0f - delayMix;
        const float wet = delayMix;
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            const float yl = delayL.popSample (0);
            const float yr = delayR.popSample (0);
            const float dlIn = juce::jlimit (-1.0f, 1.0f, l[i] + yl * fb);
            const float drIn = juce::jlimit (-1.0f, 1.0f, r[i] + yr * fb);
            delayL.pushSample (0, dlIn);
            delayR.pushSample (0, drIn);
            l[i] = l[i] * dry + yl * wet;
            r[i] = r[i] * dry + yr * wet;
        }
    }

    // Reverb
    if (revMix > 0.0f)
    {
        juce::dsp::Reverb::Parameters rp;
        rp.roomSize = juce::jlimit (0.0f, 1.0f, revRoom);
        rp.damping  = juce::jlimit (0.0f, 1.0f, revDamp);
        rp.width    = juce::jlimit (0.0f, 1.0f, revWidth);
        rp.wetLevel = juce::jlimit (0.0f, 1.0f, revMix);
        rp.dryLevel = 1.0f - rp.wetLevel;
        reverb.setParameters (rp);
        reverb.process (context);
    }

    // Drive (tanh) with dry/wet
    if (drive > 0.001f)
    {
        const float k = juce::jlimit (0.0f, 10.0f, drive) * 5.0f;
        tempBuffer.makeCopyOf (buffer, true);
        for (int ch = 0; ch < tempBuffer.getNumChannels(); ++ch)
        {
            auto* d = tempBuffer.getWritePointer (ch);
            for (int i = 0; i < tempBuffer.getNumSamples(); ++i)
                d[i] = std::tanh (k * d[i]);
        }
        const float dry = juce::jlimit (0.0f, 1.0f, 1.0f - driveMix);
        const float wet = juce::jlimit (0.0f, 1.0f, driveMix);
        out.applyGain (dry);
        for (int ch = 0; ch < out.getNumChannels(); ++ch)
            out.addFrom (ch, 0, tempBuffer, ch, 0, out.getNumSamples(), wet);
    }

    // Compressor
    if (compRatio > 1.0f)
    {
        compressor.setThreshold (juce::jlimit (-60.0f, 0.0f, compThresh));
        compressor.setRatio (juce::jmax (1.0f, compRatio));
        compressor.setAttack (juce::jlimit (0.1f, 200.0f, compAttack));
        compressor.setRelease (juce::jlimit (5.0f, 1000.0f, compRelease));
        juce::dsp::AudioBlock<float> b (out);
        juce::dsp::ProcessContextReplacing<float> c (b);
        compressor.process (c);
        if (std::abs (compMakeup) > 0.001f)
            out.applyGain (juce::Decibels::decibelsToGain (compMakeup));
    }

    // Limiter
    if (limitThresh < 0.0f)
    {
        limiter.setThreshold (juce::jlimit (-20.0f, 0.0f, limitThresh));
        limiter.setRelease (juce::jlimit (1.0f, 200.0f, limitRelease));
        juce::dsp::AudioBlock<float> b (out);
        juce::dsp::ProcessContextReplacing<float> c (b);
        limiter.process (c);
    }

    // Simple noise gate (post FX, pre gain) using envelope follower against dB threshold
    if (gateThresh > -90.0f)
    {
        const float thrLin = juce::Decibels::decibelsToGain (gateThresh);
        const float atk = juce::jlimit (0.001f, 0.5f, gateAttack * 0.001f);
        const float rel = juce::jlimit (0.001f, 2.0f, gateRelease * 0.001f);
        auto* l = out.getWritePointer (0);
        auto* r = out.getNumChannels() > 1 ? out.getWritePointer (1) : l;
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            const float mag = std::max (std::abs (l[i]), std::abs (r[i]));
            const float target = (mag >= thrLin) ? 1.0f : 0.0f;
            gateEnvL += (target - gateEnvL) * (target > gateEnvL ? atk : rel);
            gateEnvR = gateEnvL;
            l[i] *= gateEnvL;
            r[i] *= gateEnvR;
        }
    }
    }

    // --- Apply final Gain and Pan. ---
    const float gain = apvts.getRawParameterValue("gain") ? apvts.getRawParameterValue("gain")->load() : 0.7f;
    const float pan  = apvts.getRawParameterValue("pan")  ? apvts.getRawParameterValue("pan")->load()  : 0.0f;

    // Calculate left and right channel multipliers based on pan law
    const float panL = std::cos((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);
    const float panR = std::sin((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);

    // Apply the master gain and the pan law separately for clarity and correctness.
    // First, apply the overall gain to all channels.
    out.applyGain(gain);

    // Then, apply the panning multipliers to their respective channels.
    out.applyGain(0, 0, out.getNumSamples(), panL);
    if (out.getNumChannels() > 1)
        out.applyGain(1, 0, out.getNumSamples(), panR);

#if JUCE_DEBUG
    {
        // Debug probe: check magnitude after final gain/pan
        const float mag = buffer.getMagnitude(0, buffer.getNumSamples());
        if (mag <= 0.000001f)
        {
            static int counter = 0; if ((++counter & 2047) == 0)
                DBG("[VoiceProcessor] Post-gain magnitude near zero");
        }
    }
#endif
}

juce::AudioProcessorValueTreeState::ParameterLayout VoiceProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    // Core Voice Params
    params.push_back(std::make_unique<juce::AudioParameterFloat>("gain", "Gain", 0.0f, 1.0f, 0.7f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("pan", "Pan", -1.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("frequency", "Frequency", 20.0f, 20000.0f, 440.0f));

    // --- FX PARAMS ---
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "filterCutoff", "Filter Cutoff",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 20000.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "filterResonance", "Filter Resonance",
        1.0f, 20.0f, 1.0f));

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusRate", "Chorus Rate",
        0.1f, 10.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusDepth", "Chorus Depth",
        0.0f, 1.0f, 0.25f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusMix", "Chorus Mix",
        0.0f, 1.0f, 0.5f));

    // Phaser
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserRate", "Phaser Rate",
        0.01f, 10.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserDepth", "Phaser Depth",
        0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserCentre", "Phaser Centre",
        20.0f, 20000.0f, 1000.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserFeedback", "Phaser Feedback",
        -0.99f, 0.99f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserMix", "Phaser Mix",
        0.0f, 1.0f, 0.0f));

    // Reverb
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbRoom", "Reverb Room",
        0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbDamp", "Reverb Damping",
        0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbWidth", "Reverb Width",
        0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbMix", "Reverb Mix",
        0.0f, 1.0f, 0.0f));

    // Delay
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayTimeMs", "Delay Time (ms)",
        1.0f, 2000.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayFeedback", "Delay Feedback",
        0.0f, 0.95f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayMix", "Delay Mix",
        0.0f, 1.0f, 0.0f));

    // Compressor
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compThreshold", "Comp Threshold (dB)",
        -60.0f, 0.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compRatio", "Comp Ratio",
        1.0f, 20.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compAttackMs", "Comp Attack (ms)",
        0.1f, 200.0f, 10.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compReleaseMs", "Comp Release (ms)",
        5.0f, 1000.0f, 100.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compMakeup", "Comp Makeup (dB)",
        -12.0f, 12.0f, 0.0f));

    // Limiter
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "limitThreshold", "Limiter Threshold (dB)",
        -20.0f, 0.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "limitReleaseMs", "Limiter Release (ms)",
        1.0f, 200.0f, 10.0f));

    // Distortion / Drive
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "driveAmount", "Drive Amount",
        0.0f, 2.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "driveMix", "Drive Mix",
        0.0f, 1.0f, 0.0f));

    // Time/Pitch
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "timeStretchRatio", "Time Stretch Ratio",
        0.25f, 6.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitchSemitones", "Pitch Shift (Semitones)",
        -24.0f, 24.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitchRatio", "Pitch Ratio",
        0.5f, 2.0f, 1.0f));

    // Noise Gate
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateThreshold", "Gate Threshold (dB)",
        -80.0f, -20.0f, -100.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateAttackMs", "Gate Attack (ms)",
        0.1f, 50.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateReleaseMs", "Gate Release (ms)",
        5.0f, 500.0f, 50.0f));

    return { params.begin(), params.end() };
}

================================================================================
FILE: juce\Source\audio\graph\VoiceProcessor.h
================================================================================


#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_dsp/juce_dsp.h>

class VoiceProcessor : public juce::AudioProcessor
{
public:
    VoiceProcessor();
    ~VoiceProcessor() override = default;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override final; // Final - cannot be overridden
    void releaseResources() override {}

    // Pure virtual method for subclasses to implement sound generation
    virtual void renderBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) = 0;

    const juce::String getName() const override { return "VoiceProcessor"; }
    // Implement all other necessary pure virtuals with empty bodies
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return ""; }
    void changeProgramName(int, const juce::String&) override {}
    void getStateInformation(juce::MemoryBlock&) override {}
    void setStateInformation(const void*, int) override {}

    juce::AudioProcessorValueTreeState& getAPVTS() { return apvts; }
    juce::uint64 uniqueId { 0 };

protected:
    juce::AudioProcessorValueTreeState apvts;

private:
    juce::dsp::StateVariableTPTFilter<float> filter;
    juce::dsp::Chorus<float>                 chorus;
    juce::dsp::Phaser<float>                 phaser;
    juce::dsp::Reverb                        reverb;
    juce::dsp::Compressor<float>             compressor;
    juce::dsp::Limiter<float>                limiter;
    juce::dsp::WaveShaper<float>             waveshaper;

    using DelayLine = juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear>;
    DelayLine                                   delayL { 192000 }, delayR { 192000 }; // up to ~2s @96k

    float gateEnvL { 1.0f }, gateEnvR { 1.0f };
    double currentSampleRate { 48000.0 };
    bool fxPrepared { false };
    juce::uint32 preparedChannels { 0 };
    juce::AudioBuffer<float>                 tempBuffer;
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VoiceProcessor)
};


================================================================================
FILE: juce\Source\audio\AudioEngine.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_core/juce_core.h>
#include "assets/SampleBank.h"
#include "graph/VoiceProcessor.h"
#include "fx/GainProcessor.h"
#include "voices/SampleVoiceProcessor.h"
#include "../ipc/CommandBus.h"
#include "../ipc/IpcServer.h"
#include "../ipc/OscClient.h"
#include "../ui/DebugInfo.h"

class AudioEngine : public juce::AudioSource, private juce::Timer
{
public:
    AudioEngine();
    ~AudioEngine() override;

    void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override;
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override;
    void releaseResources() override;

    VisualiserState getVisualiserState() const;
    void setMasterGain (float newGain);
    void dumpCurrentStateToLog();
    
    // Access to command bus for UI communication
    CommandBus& getCommandBus() { return commandBus; }
    
    // Get active voices info for UI
    struct VoiceInfo {
        juce::uint64 voiceId;
        juce::String voiceType;
        juce::String displayName;
    };
    juce::Array<VoiceInfo> getActiveVoicesInfo() const;
    float getVoiceParameterValue(juce::uint64 voiceId, const juce::String& paramName) const;

    // --- Test-harness direct control API (bypasses OSC/CommandBus) ---
    // Create a voice directly and wire it to the master gain node. Returns new voiceId (or 0 on failure).
    juce::uint64 test_createVoice (const juce::String& voiceType);
    // Update an APVTS-mapped parameter on a specific voice (e.g., "gain", "pan").
    void test_updateVoiceParameter (juce::uint64 voiceId, const juce::String& paramId, float value);
    // Destroy a voice immediately.
    void test_destroyVoice (juce::uint64 voiceId);

private:
    void timerCallback() override;

    void handleCreateVoice (const Command& cmd);
    void handleDestroyVoice (juce::uint64 voiceId);
    void handleUpdateParam (const Command& cmd);
    void handleListenerUpdate (float x, float y, float radius, float nearRatio);
    void sendFullInfoSnapshot();
    void resetVoiceParamsToDefaults (VoiceProcessor* v);

    juce::AudioProcessorGraph::Node::Ptr connectAndAddVoice (std::unique_ptr<juce::AudioProcessor> processor);

    CommandBus commandBus;
    IpcServer oscServer;
    OscClient oscClient;
    SampleBank sampleBank;

    using Node = juce::AudioProcessorGraph::Node;
    std::unique_ptr<juce::AudioProcessorGraph> mainGraph;
    Node::Ptr audioOutputNode;
    Node::Ptr masterGainNode;
    std::map<juce::uint64, Node::Ptr> activeVoices;
    std::map<juce::uint64, std::shared_ptr<SampleBank::Sample>> activeSampleRefs;

    // Runtime format
    double lastSampleRate { 0.0 };
    int lastBlockSize { 0 };
    bool chaosModeEnabled { false };

    // Lightweight logger and stats for the harness UI
    mutable juce::CriticalSection logLock;
    juce::StringArray logQueue;
    std::atomic<float> lastOutputPeak { 0.0f };

    // Reusable realtime scratch buffers to avoid per-callback allocations
    juce::AudioBuffer<float> tmpGraphBuffer;
    juce::AudioBuffer<float> tmpVoiceBuffer;

public:
    void appendLog (const juce::String& msg)
    {
        const juce::ScopedLock sl (logLock);
        logQueue.add ("[" + juce::Time::getCurrentTime().toString (true, true) + "] " + msg);
    }

    juce::StringArray drainLogs()
    {
        const juce::ScopedLock sl (logLock);
        juce::StringArray out;
        out.swapWith (logQueue);
        return out;
    }

    struct RuntimeStats { double sampleRate; int blockSize; int nodeCount; float masterGain; float lastPeak; int voiceCount; };
    RuntimeStats getRuntimeStats() const
    {
        RuntimeStats rs{};
        rs.sampleRate = lastSampleRate;
        rs.blockSize = lastBlockSize;
        rs.nodeCount = (int) (mainGraph ? mainGraph->getNodes().size() : 0);
        rs.lastPeak = lastOutputPeak.load();
        rs.voiceCount = (int) activeVoices.size();
        float g = 1.0f;
        if (masterGainNode != nullptr)
        {
            if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
            {
                if (auto* p = gp->getAPVTS().getRawParameterValue ("gain"))
                    g = p->load();
            }
        }
        rs.masterGain = g;
        return rs;
    }

    float listenerX { 0.0f }, listenerY { 0.0f }, listenerRadius { 300.0f }, listenerNear { 0.12f };
    double clockOffsetMs { 0.0 };
    bool clockSynced { false };

    mutable juce::CriticalSection visualiserLock;
    VisualiserState visualiserState;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioEngine)
}; 


================================================================================
FILE: juce\Source\audio\AudioEngine.cpp
================================================================================


#include "AudioEngine.h"
#include "voices/SampleVoiceProcessor.h"
#include "voices/SynthVoiceProcessor.h"
#include "voices/NoiseVoiceProcessor.h"
#include "graph/ModularSynthProcessor.h"
#include "voices/ModularVoice.h"
#include "fx/GainProcessor.h"
#include "../ipc/OscConfig.h"

AudioEngine::AudioEngine()
    : oscServer (commandBus)
{
    mainGraph = std::make_unique<juce::AudioProcessorGraph>();
    audioOutputNode = mainGraph->addNode (std::make_unique<juce::AudioProcessorGraph::AudioGraphIOProcessor>(juce::AudioProcessorGraph::AudioGraphIOProcessor::audioOutputNode));
    
    // Insert master gain node and route graph: Voices -> MasterGain -> Output
    auto master = std::make_unique<GainProcessor>();
    masterGainNode = mainGraph->addNode (std::move (master));
    {
        using NodeAndChannel = juce::AudioProcessorGraph::NodeAndChannel;
        juce::AudioProcessorGraph::Connection cL { NodeAndChannel{ masterGainNode->nodeID, 0 }, NodeAndChannel{ audioOutputNode->nodeID, 0 } };
        juce::AudioProcessorGraph::Connection cR { NodeAndChannel{ masterGainNode->nodeID, 1 }, NodeAndChannel{ audioOutputNode->nodeID, 1 } };
        mainGraph->addConnection (cL);
        mainGraph->addConnection (cR);

        // Constant tone removed
    }

    // Bind OSC server (Python -> JUCE)
    oscServer.bind (OscConfig::kJuceServerPort);
    // Connect OSC client (JUCE -> Python)
    oscClient.connect (OscConfig::kPythonHost, OscConfig::kPythonPort);

    // Kick main logic loop
    startTimerHz (120);
}
static void logGraphTopology (juce::AudioProcessorGraph* g)
{
    if (g == nullptr) return;
    juce::Logger::writeToLog ("--- MAIN GRAPH TOPOLOGY ---");
    auto nodes = g->getNodes();
    for (auto* n : nodes)
    {
        if (n == nullptr) continue;
        auto* p = n->getProcessor();
        const int ins  = p ? p->getTotalNumInputChannels()  : 0;
        const int outs = p ? p->getTotalNumOutputChannels() : 0;
        juce::Logger::writeToLog ("  Node: id=" + juce::String ((int) n->nodeID.uid)
            + " name='" + (p ? p->getName() : juce::String("<null>")) + "' ins=" + juce::String (ins)
            + " outs=" + juce::String (outs));
    }
    auto conns = g->getConnections();
    for (auto& c : conns)
    {
        juce::Logger::writeToLog ("  Conn: [" + juce::String ((int)c.source.nodeID.uid) + ":" + juce::String (c.source.channelIndex)
            + "] -> [" + juce::String ((int)c.destination.nodeID.uid) + ":" + juce::String (c.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog ("---------------------------");
}

AudioEngine::~AudioEngine()
{
    stopTimer();
}

void AudioEngine::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    lastSampleRate = sampleRate;
    lastBlockSize = samplesPerBlockExpected;
    // Ensure the graph I/O configuration matches the device: 0 inputs, 2 outputs
    if (mainGraph)
    {
        mainGraph->setPlayConfigDetails (0, 2, sampleRate, samplesPerBlockExpected);
        // Do NOT override individual node play configs here; the graph manages node formats.
    }
    mainGraph->prepareToPlay (sampleRate, samplesPerBlockExpected);
    appendLog ("Engine prepared: sr=" + juce::String (sampleRate) + " block=" + juce::String (samplesPerBlockExpected));
}

void AudioEngine::sendFullInfoSnapshot()
{
    // Enumerate devices and send info to Python
    juce::AudioDeviceManager dm; // local query
    dm.initialise (0, 2, nullptr, true);
    juce::AudioDeviceManager::AudioDeviceSetup setup;
    dm.getAudioDeviceSetup (setup);
    juce::StringArray ins, outs;
    if (auto* t = dm.getAvailableDeviceTypes().getFirst())
    {
        t->scanForDevices();
        ins = t->getDeviceNames (true);
        outs = t->getDeviceNames (false);
    }
    DBG ("AudioEngine::sendFullInfoSnapshot - sending devices and settings");
    oscClient.sendDeviceList ("input", ins);
    oscClient.sendDeviceList ("output", outs);
    // MIDI inputs
    {
        juce::StringArray midiIns;
        auto midiDevs = juce::MidiInput::getAvailableDevices();
        for (auto& d : midiDevs) midiIns.add (d.name);
        oscClient.sendMidiDeviceList (midiIns);
    }
    const float sr = (float) (dm.getCurrentAudioDevice() ? dm.getCurrentAudioDevice()->getCurrentSampleRate() : 0.0f);
    const int bs  = (dm.getCurrentAudioDevice() ? dm.getCurrentAudioDevice()->getCurrentBufferSizeSamples() : 0);
    oscClient.sendCurrentSettings (setup.inputDeviceName, setup.outputDeviceName, sr, bs);
    // Send latest master gain if available
    if (masterGainNode != nullptr)
    {
        float g = 1.0f;
        if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
        {
            if (auto* p = gp->getAPVTS().getRawParameterValue ("gain"))
                g = p->load();
        }
        oscClient.sendMasterGain (g);
    }
}

void AudioEngine::releaseResources()
{
    if (mainGraph) mainGraph->releaseResources();
}

juce::AudioProcessorGraph::Node::Ptr AudioEngine::connectAndAddVoice (std::unique_ptr<juce::AudioProcessor> processor)
{
    if (! mainGraph)
        return {};

    auto node = mainGraph->addNode (std::move (processor));
    using NodeAndChannel = juce::AudioProcessorGraph::NodeAndChannel;
    
    // Ensure bus layout on the voice processor is active and matches the graph's 0-in/2-out
    if (auto* vp = node->getProcessor())
    {
        const double sr = lastSampleRate > 0.0 ? lastSampleRate : 48000.0;
        const int    bs = lastBlockSize  > 0   ? lastBlockSize  : 512;
        vp->enableAllBuses();
        vp->setPlayConfigDetails (0, 2, sr, bs);
        vp->prepareToPlay (sr, bs);
    }

    // Connect the voice's audio output to the master gain
    juce::AudioProcessorGraph::Connection cL { NodeAndChannel{ node->nodeID, 0 }, NodeAndChannel{ masterGainNode->nodeID, 0 } };
    juce::AudioProcessorGraph::Connection cR { NodeAndChannel{ node->nodeID, 1 }, NodeAndChannel{ masterGainNode->nodeID, 1 } };
    mainGraph->addConnection (cL);
    mainGraph->addConnection (cR);

    // Direct bypass to output as a hard test path
    juce::AudioProcessorGraph::Connection vOutL { NodeAndChannel{ node->nodeID, 0 }, NodeAndChannel{ audioOutputNode->nodeID, 0 } };
    juce::AudioProcessorGraph::Connection vOutR { NodeAndChannel{ node->nodeID, 1 }, NodeAndChannel{ audioOutputNode->nodeID, 1 } };
    mainGraph->addConnection (vOutL);
    mainGraph->addConnection (vOutR);
    // Dump topology after adding the first few voices
    logGraphTopology (mainGraph.get());
    
    return node;
}

void AudioEngine::getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill)
{
    if (bufferToFill.buffer == nullptr)
        return;

    const int numCh = bufferToFill.buffer->getNumChannels();
    const int start = bufferToFill.startSample;
    const int num   = bufferToFill.numSamples;
    if (numCh <= 0 || num <= 0)
        return;

    // Clear just the region we're responsible for and process
    bufferToFill.buffer->clear (start, num);
    // Render graph into scratch buffer and copy back into the requested region
    // Build a zero-copy view into the requested region and process directly
    juce::HeapBlock<float*> chans (numCh);
    for (int ch = 0; ch < numCh; ++ch)
        chans[ch] = bufferToFill.buffer->getWritePointer (ch) + start;
    juce::AudioBuffer<float> view (chans.getData(), numCh, num);
    juce::MidiBuffer midi;
    mainGraph->processBlock (view, midi);

    // Update peak meter for UI on the region only
    const float pk = bufferToFill.buffer->getMagnitude (start, num);
    lastOutputPeak.store (pk);
}

void AudioEngine::timerCallback()
{
    // Drain commands
    for (int i = 0; i < 4096; ++i)
    {
        Command c; if (! commandBus.tryDequeue (c)) break;
        if (c.type == Command::Type::Create)          handleCreateVoice (c);
        else if (c.type == Command::Type::Destroy)    handleDestroyVoice (c.voiceId);
        else if (c.type == Command::Type::Update)     handleUpdateParam (c);
        else if (c.type == Command::Type::DebugDump)  dumpCurrentStateToLog();
        // ADD THIS ENTIRE NEW BLOCK:
        else if (c.type == Command::Type::LoadPreset)
        {
            // a. Find the target voice by its unique ID
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                // b. Safely check if this voice is a ModularVoice wrapper
                if (auto* mv = dynamic_cast<ModularVoice*>(it->second->getProcessor()))
                {
                    if (auto* msp = mv->getModularSynth()) // Get the internal synth
                    {
                        // c. Convert the XML string to a MemoryBlock and load the state
                        juce::MemoryBlock mb(c.presetData.toRawUTF8(), c.presetData.getNumBytesAsUTF8());
                        msp->setStateInformation(mb.getData(), (int)mb.getSize());
                        appendLog("Loaded preset onto Modular Synth voice ID: " + juce::String((juce::int64)c.voiceId));
                    }
                }
            }
        }
        else if (c.type == Command::Type::ResetFx)
        {
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
                {
                    resetVoiceParamsToDefaults(vp);
                    appendLog("Reset FX for voice ID: " + juce::String((juce::int64)c.voiceId));
                }
            }
        }
        else if (c.type == Command::Type::RandomizePitch)
        {
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
                {
                    if (auto* p = vp->getAPVTS().getParameter("pitchSemitones"))
                    {
                        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                        {
                            float randomPitch = juce::Random::getSystemRandom().nextFloat() * 24.0f - 12.0f; // -12 to +12 semitones
                            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(randomPitch));
                            appendLog("Randomized pitch for voice ID: " + juce::String((juce::int64)c.voiceId) + " to " + juce::String(randomPitch) + " semitones");
                        }
                    }
                }
            }
        }
        else if (c.type == Command::Type::RandomizeTime)
        {
            auto it = activeVoices.find(c.voiceId);
            if (it != activeVoices.end())
            {
                if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
                {
                    if (auto* p = vp->getAPVTS().getParameter("timeStretchRatio"))
                    {
                        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                        {
                            float randomRatio = juce::Random::getSystemRandom().nextFloat() * 4.0f + 0.25f; // 0.25 to 4.25 ratio
                            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(randomRatio));
                            appendLog("Randomized time stretch for voice ID: " + juce::String((juce::int64)c.voiceId) + " to " + juce::String(randomRatio) + " ratio");
                        }
                    }
                }
            }
        }
        else if (c.type == Command::Type::SetChaosMode)
        {
            chaosModeEnabled = c.chaosModeEnabled;
            appendLog("Chaos mode " + juce::String(chaosModeEnabled ? "enabled" : "disabled"));
        }
    }

    // Chaos Mode: Periodically randomize parameters if enabled
    static int chaosCounter = 0;
    if (chaosModeEnabled && ++chaosCounter % 100 == 0) // Every 100 timer calls
    {
        if (!activeVoices.empty())
        {
            auto& rng = juce::Random::getSystemRandom();
            auto it = activeVoices.begin();
            std::advance(it, rng.nextInt((int)activeVoices.size()));
            
            if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
            {
                // Random parameter list
                juce::StringArray params = {"filterCutoff", "filterResonance", "chorusRate", "chorusDepth", 
                                           "phaserRate", "phaserDepth", "reverbRoom", "reverbDamp", 
                                           "delayTimeMs", "delayFeedback", "driveAmount"};
                
                juce::String paramName = params[rng.nextInt(params.size())];
                if (auto* p = vp->getAPVTS().getParameter(paramName))
                {
                    if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                    {
                        float randomValue = rng.nextFloat(); // 0.0 to 1.0
                        r->setValueNotifyingHost(randomValue);
                    }
                }
            }
        }
    }

    // Bridge diagnostics to UI (minimal: just listener; voices left empty)
    {
        const juce::ScopedLock sl (visualiserLock);
        visualiserState.voices.clearQuick();
        visualiserState.listenerPosition = { listenerX, listenerY };
    }

    // CPU load reporting disabled to avoid repeated device manager init cost.
}

void AudioEngine::dumpCurrentStateToLog()
{
    juce::Logger::writeToLog ("--- JUCE STATE DUMP TRIGGERED ---");
    // Current audio device settings
    juce::AudioDeviceManager dm; dm.initialise (0, 2, nullptr, true);
    juce::AudioDeviceManager::AudioDeviceSetup setup; dm.getAudioDeviceSetup (setup);
    auto* dev = dm.getCurrentAudioDevice();
    const juce::String inName = setup.inputDeviceName;
    const juce::String outName = setup.outputDeviceName;
    const double sr = dev ? dev->getCurrentSampleRate() : 0.0;
    const int bs = dev ? dev->getCurrentBufferSizeSamples() : 0;
    juce::Logger::writeToLog ("[AUDIO] input='" + inName + "' output='" + outName + "' sr=" + juce::String (sr) + " bs=" + juce::String (bs));

    // Graph stats
    const int numNodes = (int) (mainGraph ? mainGraph->getNodes().size() : 0);
    juce::Logger::writeToLog ("[GRAPH] nodes=" + juce::String (numNodes));

    // Master gain param
    float masterGain = -1.0f;
    if (masterGainNode != nullptr)
    {
        if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
        {
            if (auto* p = gp->getAPVTS().getRawParameterValue ("gain"))
                masterGain = p->load();
        }
    }
    juce::Logger::writeToLog ("[GRAPH] masterGainParam=" + juce::String (masterGain));

    // Voices (log minimal APVTS values)
    juce::Logger::writeToLog ("[VOICES] count=" + juce::String ((int) activeVoices.size()));
    for (auto& kv : activeVoices)
    {
        const juce::uint64 vid = kv.first;
        auto* proc = kv.second ? kv.second->getProcessor() : nullptr;
        float apGain = -1.0f, apPan = 0.0f, apFreq = 0.0f;
        if (auto* vp = dynamic_cast<VoiceProcessor*> (proc))
        {
            if (auto* pG = vp->getAPVTS().getRawParameterValue ("gain")) apGain = pG->load();
            if (auto* pP = vp->getAPVTS().getRawParameterValue ("pan"))  apPan  = pP->load();
            if (auto* pF = vp->getAPVTS().getRawParameterValue ("frequency")) apFreq = pF->load();
        }
        juce::Logger::writeToLog ("[VOICE] id=" + juce::String ((juce::int64) vid) +
                                   " gain=" + juce::String (apGain) +
                                   " pan=" + juce::String (apPan) +
                                   " freq=" + juce::String (apFreq));
    }
}

juce::Array<AudioEngine::VoiceInfo> AudioEngine::getActiveVoicesInfo() const
{
    juce::Array<VoiceInfo> result;
    
    for (auto& kv : activeVoices)
    {
        const juce::uint64 voiceId = kv.first;
        auto node = kv.second;
        if (!node) continue;
        
        auto* proc = node->getProcessor();
        if (!proc) continue;
        
        VoiceInfo info;
        info.voiceId = voiceId;
        
        // Determine voice type and display name
        if (dynamic_cast<SynthVoiceProcessor*>(proc))
        {
            info.voiceType = "Synth";
            info.displayName = "Synth Voice " + juce::String((juce::int64)voiceId);
        }
        else if (dynamic_cast<NoiseVoiceProcessor*>(proc))
        {
            info.voiceType = "Noise";
            info.displayName = "Noise Voice " + juce::String((juce::int64)voiceId);
        }
        else if (auto* sampleProc = dynamic_cast<SampleVoiceProcessor*>(proc))
        {
            info.voiceType = "Sample";
            info.displayName = "Sample: " + sampleProc->getSourceName();
        }
        else if (dynamic_cast<ModularVoice*>(proc))
        {
            info.voiceType = "Modular";
            info.displayName = "Modular Synth " + juce::String((juce::int64)voiceId);
        }
        else
        {
            info.voiceType = "Unknown";
            info.displayName = "Unknown Voice " + juce::String((juce::int64)voiceId);
        }
        
        result.add(info);
    }
    
    return result;
}

float AudioEngine::getVoiceParameterValue(juce::uint64 voiceId, const juce::String& paramName) const
{
    auto it = activeVoices.find(voiceId);
    if (it != activeVoices.end())
    {
        if (auto* vp = dynamic_cast<VoiceProcessor*>(it->second->getProcessor()))
        {
            if (auto* p = vp->getAPVTS().getParameter(paramName))
            {
                if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
                {
                    return r->getNormalisableRange().convertFrom0to1(p->getValue());
                }
            }
        }
    }
    return 0.0f; // Default value if parameter not found
}

void AudioEngine::handleCreateVoice (const Command& cmd)
{
    if (!mainGraph) return;

    std::unique_ptr<VoiceProcessor> proc;
    // --- 1. Create the processor based on type ---
    if (cmd.voiceType.equalsIgnoreCase("synth")) {
        proc = std::make_unique<SynthVoiceProcessor>();
    } else if (cmd.voiceType.equalsIgnoreCase("noise")) {
        proc = std::make_unique<NoiseVoiceProcessor>();
    } else if (cmd.voiceType.equalsIgnoreCase("modular")) {
        proc = std::make_unique<ModularVoice>();
    } else if (cmd.voiceType.equalsIgnoreCase("sample")) {
        juce::File f(cmd.resourceName);
        auto smp = sampleBank.getOrLoad(f);
        if (!smp) {
            // FAILSAFE: Generate a 1-second sine wave if sample not found
            appendLog("WARNING: Sample not found: " + cmd.resourceName + " - generating sine wave failsafe");
            smp = sampleBank.generateSineWaveFailsafe(44100, 1.0); // 1 second at 44.1kHz
            if (!smp) {
                appendLog("ERROR: Failed to generate failsafe sample");
                return;
            }
        }
        auto sampleProc = std::make_unique<SampleVoiceProcessor>(smp);
        sampleProc->setSourceName(f.getFileName());
        sampleProc->setLooping(true); // Set looping by default
        activeSampleRefs[cmd.voiceId] = smp;
        proc = std::move(sampleProc);
    }

    if (proc == nullptr) {
        appendLog("ERROR: Unknown voice type for create command: " + cmd.voiceType);
        return;
    }

    // --- 2. Perform ALL necessary initialization steps BEFORE adding to the graph ---
    proc->uniqueId = cmd.voiceId;
    proc->prepareToPlay(lastSampleRate, lastBlockSize);
    resetVoiceParamsToDefaults(proc.get());

    // CRITICAL FIX for "no sound": Set a non-zero default gain and centered pan.
    if (auto* p = proc->getAPVTS().getParameter("gain"))
        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(0.7f));
    
    if (auto* p = proc->getAPVTS().getParameter("pan"))
        if (auto* r = dynamic_cast<juce::RangedAudioParameter*>(p))
            r->setValueNotifyingHost(r->getNormalisableRange().convertTo0to1(0.0f));
    
    // --- 3. Add the fully prepared processor to the graph and connect it ---
    auto node = connectAndAddVoice(std::move(proc));
    activeVoices[cmd.voiceId] = node;

    // --- 4. MIDI connection is handled automatically in connectAndAddVoice ---
    
    // --- 5. Perform type-specific post-creation setup ---
    if (auto* mv = dynamic_cast<ModularVoice*>(node->getProcessor())) {
        if (auto* msp = mv->getModularSynth()) {
            auto vco = msp->addModule("VCO");
            auto out = msp->getOutputNodeID();
            
            // SIMPLER, BETTER DEFAULT PATCH: VCO directly to output (no VCA needed for basic sound)
            msp->connect(vco, 0, out, 0); // VCO -> Left Out
            msp->connect(vco, 0, out, 1); // VCO -> Right Out
            msp->commitChanges();
            
            appendLog("Created default modular patch: VCO -> Output (stereo)");
        }
    }

    appendLog("Successfully created voice '" + cmd.voiceType + "' with ID: " + juce::String((juce::int64)cmd.voiceId));
}

void AudioEngine::handleDestroyVoice (juce::uint64 voiceId)
{
    if (! mainGraph) return;
    auto it = activeVoices.find (voiceId);
    if (it == activeVoices.end()) return;
    auto node = it->second;
    mainGraph->removeNode (node->nodeID);
    activeVoices.erase (it);
    activeSampleRefs.erase (voiceId);
}

void AudioEngine::handleUpdateParam (const Command& cmd)
{
    // ADD THIS LINE:
    appendLog("[ENGINE LOG] Received UPDATE command for '" + cmd.paramName + "'.");
    
    if (cmd.voiceId == 0)
    {
        if (cmd.paramName == "listener.posX") listenerX = cmd.paramValue;
        else if (cmd.paramName == "listener.posY") listenerY = cmd.paramValue;
        else if (cmd.paramName == "listener.radius") listenerRadius = juce::jmax (0.0f, cmd.paramValue);
        else if (cmd.paramName == "listener.near") listenerNear = juce::jlimit (0.0f, 1.0f, cmd.paramValue);
        else if (cmd.paramName == "master.gain") setMasterGain (cmd.paramValue);
        else if (cmd.paramName == "device.set")
        {
            // cmd.voiceType packed as "type\nname"
            auto parts = juce::StringArray::fromLines (cmd.voiceType);
            if (parts.size() >= 2)
            {
                const juce::String kind = parts[0];
                const juce::String name = parts[1];
                juce::AudioDeviceManager dm; dm.initialise (0, 2, nullptr, true);
                juce::AudioDeviceManager::AudioDeviceSetup setup; dm.getAudioDeviceSetup (setup);
                if (kind.equalsIgnoreCase ("input")) setup.inputDeviceName = name; else setup.outputDeviceName = name;
                dm.setAudioDeviceSetup (setup, true);
                static OscClient client; client.connect ("127.0.0.1", 9002);
                const float sr = (float) (dm.getCurrentAudioDevice() ? dm.getCurrentAudioDevice()->getCurrentSampleRate() : 0.0);
                const int bs = (dm.getCurrentAudioDevice() ? dm.getCurrentAudioDevice()->getCurrentBufferSizeSamples() : 0);
                client.sendCurrentSettings (setup.inputDeviceName, setup.outputDeviceName, sr, bs);
            }
        }
        else if (cmd.paramName == "device.bufferSize")
        {
            const int newBS = juce::jmax (16, (int) std::round (cmd.paramValue));
            juce::AudioDeviceManager dm; dm.initialise (0, 2, nullptr, true);
            juce::AudioDeviceManager::AudioDeviceSetup setup; dm.getAudioDeviceSetup (setup);
            setup.bufferSize = newBS;
            dm.setAudioDeviceSetup (setup, true);
            static OscClient client; client.connect ("127.0.0.1", 9002);
            const float sr = (float) (dm.getCurrentAudioDevice() ? dm.getCurrentAudioDevice()->getCurrentSampleRate() : 0.0);
            const int bs  = (dm.getCurrentAudioDevice() ? dm.getCurrentAudioDevice()->getCurrentBufferSizeSamples() : 0);
            client.sendCurrentSettings (setup.inputDeviceName, setup.outputDeviceName, sr, bs);
        }
        else if (cmd.paramName == "engine.requestInfo")
        {
            sendFullInfoSnapshot();
        }
        return;
    }

    auto it = activeVoices.find (cmd.voiceId);
    if (it == activeVoices.end()) return;
    if (auto* vp = dynamic_cast<VoiceProcessor*> (it->second->getProcessor()))
    {
        // Fast-path engine switches for SampleVoiceProcessor (bypass APVTS latency)
        if (auto* svp = dynamic_cast<SampleVoiceProcessor*>(vp))
        {
            if (cmd.paramName == "engine")
            {
                const bool useNaive = (cmd.paramValue >= 0.5f);
                svp->setEngine(useNaive ? SampleVoiceProcessor::Engine::Naive
                                        : SampleVoiceProcessor::Engine::RubberBand);
                return;
            }
        }
        // APVTS-based updates only
        auto setParam = [vp] (const juce::String& id, float val)
        {
            if (auto* p = vp->getAPVTS().getParameter (id))
                if (auto* r = dynamic_cast<juce::RangedAudioParameter*> (p))
                    r->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, r->getNormalisableRange().convertTo0to1 (val)));
        };
        // Generic parameter update - handle any valid parameter ID
        setParam (cmd.paramName, cmd.paramValue);
    }
}

void AudioEngine::handleListenerUpdate (float x, float y, float radius, float nearRatio)
{
    listenerX = x; listenerY = y; listenerRadius = radius; listenerNear = nearRatio;
}

VisualiserState AudioEngine::getVisualiserState() const
{
    const juce::ScopedLock sl (visualiserLock);
    return visualiserState;
}

void AudioEngine::setMasterGain (float newGain)
{
    if (masterGainNode != nullptr)
    {
        if (auto* gp = dynamic_cast<GainProcessor*> (masterGainNode->getProcessor()))
            gp->setLinearGain (newGain);
    }
}

juce::uint64 AudioEngine::test_createVoice (const juce::String& voiceType)
{
    if (! mainGraph)
        return 0;

    juce::uint64 newId = (juce::uint64) juce::Time::getMillisecondCounterHiRes();

    std::unique_ptr<juce::AudioProcessor> proc;
    if (voiceType.equalsIgnoreCase ("sample"))
    {
        // Try to load any available audio file from ./audio/samples or ./assets
        std::shared_ptr<SampleBank::Sample> smp;
        {
            juce::File cwd = juce::File::getCurrentWorkingDirectory();
            juce::File candidates[] = {
                cwd.getChildFile ("audio").getChildFile ("samples").getChildFile ("test.wav"),
                cwd.getChildFile ("assets").getChildFile ("test.wav")
            };
            for (auto& f : candidates)
            {
                if (f.existsAsFile()) { smp = sampleBank.getOrLoad (f); break; }
            }
        }
        if (! smp)
        {
            // Failsafe: synthesize a 1s sine tone into a temp buffer
            auto sample = std::make_shared<SampleBank::Sample>();
            const double sr = lastSampleRate > 0.0 ? lastSampleRate : 48000.0;
            const int n = (int) (sr);
            sample->stereo.setSize (2, n);
            for (int i = 0; i < n; ++i)
            {
                const float s = std::sin (2.0 * juce::MathConstants<double>::pi * 440.0 * (double) i / sr);
                sample->stereo.setSample (0, i, s);
                sample->stereo.setSample (1, i, s);
            }
            sample->buffer.makeCopyOf (sample->stereo, true);
            sample->sampleRate = sr;
            smp = sample;
        }
        auto p = std::make_unique<SampleVoiceProcessor> (smp);
        proc = std::move (p);
        activeSampleRefs[newId] = smp;
    }
    else if (voiceType.equalsIgnoreCase ("synth"))
    {
        auto p = std::make_unique<SynthVoiceProcessor>();
        proc = std::move (p);
    }
    else if (voiceType.equalsIgnoreCase ("noise"))
    {
        proc = std::make_unique<NoiseVoiceProcessor>();
    }
    else
    {
        return 0;
    }

    auto node = mainGraph->addNode (std::move (proc));
    using NodeAndChannel = juce::AudioProcessorGraph::NodeAndChannel;
    juce::AudioProcessorGraph::Connection cL { NodeAndChannel{ node->nodeID, 0 }, NodeAndChannel{ masterGainNode->nodeID, 0 } };
    juce::AudioProcessorGraph::Connection cR { NodeAndChannel{ node->nodeID, 1 }, NodeAndChannel{ masterGainNode->nodeID, 1 } };
    mainGraph->addConnection (cL);
    mainGraph->addConnection (cR);

    // Prepare the processor with current runtime format, then mark prepared
    if (auto* ap = node->getProcessor())
        ap->prepareToPlay (lastSampleRate > 0.0 ? lastSampleRate : 48000.0, lastBlockSize > 0 ? lastBlockSize : 512);
    if (auto* vp = dynamic_cast<VoiceProcessor*> (node->getProcessor()))
    {
        // Reasonable defaults via APVTS
        if (auto* p = vp->getAPVTS().getParameter ("gain"))
            if (auto* r = dynamic_cast<juce::RangedAudioParameter*> (p)) r->setValueNotifyingHost (r->getNormalisableRange().convertTo0to1 (0.7f));
        if (auto* p2 = vp->getAPVTS().getParameter ("pan"))
            if (auto* r2 = dynamic_cast<juce::RangedAudioParameter*> (p2)) r2->setValueNotifyingHost (r2->getNormalisableRange().convertTo0to1 (0.0f));
    }

    activeVoices[newId] = node;
    appendLog ("Created voice '" + voiceType + "' id=" + juce::String ((juce::int64) newId));
    return newId;
}

void AudioEngine::test_updateVoiceParameter (juce::uint64 voiceId, const juce::String& paramId, float value)
{
    auto it = activeVoices.find (voiceId);
    if (it == activeVoices.end()) return;
    auto* proc = it->second->getProcessor();
    if (! proc) return;
    // Update APVTS parameter by ID
    const int numParams = proc->getNumParameters();
    for (int i = 0; i < numParams; ++i)
    {
        if (auto* p = dynamic_cast<juce::AudioProcessorParameterWithID*> (proc->getParameters()[i]))
        {
            if (p->paramID.equalsIgnoreCase (paramId))
            {
                // Map linear value to normalized
                auto* ranged = dynamic_cast<juce::RangedAudioParameter*> (p);
                if (ranged != nullptr)
                {
                    const float norm = ranged->getNormalisableRange().convertTo0to1 (value);
                    ranged->beginChangeGesture();
                    ranged->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, norm));
                    ranged->endChangeGesture();
                    appendLog ("Set param '" + paramId + "'=" + juce::String (value) + " on voiceId=" + juce::String ((juce::int64) voiceId));
                }
                return;
            }
        }
    }
}

void AudioEngine::test_destroyVoice (juce::uint64 voiceId)
{
    handleDestroyVoice (voiceId);
}

void AudioEngine::resetVoiceParamsToDefaults (VoiceProcessor* v)
{
    if (v == nullptr) return;
    auto set = [v] (const char* id, float val)
    {
        if (auto* p = v->getAPVTS().getParameter (id))
            if (auto* r = dynamic_cast<juce::RangedAudioParameter*> (p))
                r->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, r->getNormalisableRange().convertTo0to1 (val)));
    };
    set ("filterCutoff", 20000.0f);
    set ("filterResonance", 1.0f);
    set ("chorusRate", 1.0f);
    set ("chorusDepth", 0.0f);
    set ("chorusMix", 0.0f);
    set ("phaserRate", 0.5f);
    set ("phaserDepth", 0.0f);
    set ("phaserCentre", 1000.0f);
    set ("phaserFeedback", 0.0f);
    set ("phaserMix", 0.0f);
    set ("reverbRoom", 0.0f);
    set ("reverbDamp", 0.5f);
    set ("reverbWidth", 1.0f);
    set ("reverbMix", 0.0f);
    set ("delayTimeMs", 0.0f);
    set ("delayFeedback", 0.0f);
    set ("delayMix", 0.0f);
    set ("compThreshold", 0.0f);
    set ("compRatio", 1.0f);
    set ("compAttackMs", 10.0f);
    set ("compReleaseMs", 100.0f);
    set ("compMakeup", 0.0f);
    set ("limitThreshold", 0.0f);
    set ("limitReleaseMs", 10.0f);
    set ("driveAmount", 0.0f);
    set ("driveMix", 0.0f);
    set ("gateThreshold", -100.0f);
    set ("gateAttackMs", 1.0f);
    set ("gateReleaseMs", 50.0f);
    set ("timeStretchRatio", 1.0f);
    set ("pitchSemitones", 0.0f);
    set ("pitchRatio", 1.0f);
}


================================================================================
FILE: juce\Source\audio\modules\ADSRModuleProcessor.cpp
================================================================================


#include "ADSRModuleProcessor.h"

ADSRModuleProcessor::ADSRModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("Gate In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Output", juce::AudioChannelSet::quadraphonic(), true)),
      apvts (*this, nullptr, "ADSRParams", createParameterLayout())
{
    attackParam  = apvts.getRawParameterValue (paramIdAttack);
    decayParam   = apvts.getRawParameterValue (paramIdDecay);
    sustainParam = apvts.getRawParameterValue (paramIdSustain);
    releaseParam = apvts.getRawParameterValue (paramIdRelease);
    attackModParam  = apvts.getRawParameterValue (paramIdAttackMod);
    decayModParam   = apvts.getRawParameterValue (paramIdDecayMod);
    sustainModParam = apvts.getRawParameterValue (paramIdSustainMod);
    releaseModParam = apvts.getRawParameterValue (paramIdReleaseMod);
    
    // CORRECTED INITIALIZATION:
    // Create unique_ptrs to heap-allocated atomics for each output channel.
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 0
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 1
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 2
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 3
}

juce::AudioProcessorValueTreeState::ParameterLayout ADSRModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdAttack,  "Attack",  juce::NormalisableRange<float> (0.001f, 5.0f, 0.01f, 0.4f), 0.01f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdDecay,   "Decay",   juce::NormalisableRange<float> (0.001f, 5.0f, 0.01f, 0.4f), 0.1f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdSustain, "Sustain", juce::NormalisableRange<float> (0.0f, 1.0f), 0.7f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdRelease, "Release", juce::NormalisableRange<float> (0.001f, 5.0f, 0.01f, 0.4f), 0.2f));
    
    // Add modulation parameters
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdAttackMod,  "Attack Mod",  0.0f, 1.0f, 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdDecayMod,   "Decay Mod",   0.0f, 1.0f, 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdSustainMod, "Sustain Mod", 0.0f, 1.0f, 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdReleaseMod, "Release Mod", 0.0f, 1.0f, 0.0f));
    return { p.begin(), p.end() };
}

void ADSRModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    adsr.setSampleRate (sampleRate);
}

void ADSRModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    // Read modulation parameters (0-1 range)
    float attackMod  = attackModParam  != nullptr ? attackModParam->load()  : 0.0f;
    float decayMod   = decayModParam   != nullptr ? decayModParam->load()   : 0.0f;
    float sustainMod = sustainModParam != nullptr ? sustainModParam->load() : 0.0f;
    float releaseMod = releaseModParam != nullptr ? releaseModParam->load() : 0.0f;

    // Apply modulation. Unipolar mod signals are converted to bipolar and scaled.
    juce::ADSR::Parameters par;
    par.attack  = juce::jlimit(0.001f, 5.0f, attackParam->load()  + (attackMod - 0.5f) * 2.0f); // Modulate by +/- 1s
    par.decay   = juce::jlimit(0.001f, 5.0f, decayParam->load()   + (decayMod - 0.5f) * 2.0f); // Modulate by +/- 1s
    par.sustain = juce::jlimit(0.0f, 1.0f,   sustainParam->load() + (sustainMod - 0.5f));      // Modulate by +/- 0.5
    par.release = juce::jlimit(0.001f, 5.0f, releaseParam->load() + (releaseMod - 0.5f) * 2.0f); // Modulate by +/- 1s
    adsr.setParameters (par);

    // Gate input from bus 0 channel 0
    auto gateBus = getBusBuffer (buffer, true, 0);
    const float* gateIn = gateBus.getNumChannels() > 0 ? gateBus.getReadPointer (0) : nullptr;

    // Clear only our output channels before writing envelope
    buffer.clear();
    float* l = buffer.getWritePointer (0);
    float* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : l;
    float* eorGate = buffer.getNumChannels() > 2 ? buffer.getWritePointer (2) : nullptr;
    float* unused = buffer.getNumChannels() > 3 ? buffer.getWritePointer (3) : nullptr;
    const int n = buffer.getNumSamples();

    for (int i = 0; i < n; ++i)
    {
        const bool gate = gateIn != nullptr ? (gateIn[i] > 0.5f) : false;
        if (gate && ! lastGate) adsr.noteOn();
        else if (! gate && lastGate) adsr.noteOff();
        lastGate = gate;

        const bool wasActive = adsr.isActive();
        const float env = adsr.getNextSample();
        const bool isActive = adsr.isActive();
        
        // EOR Gate: goes high when envelope transitions from active to inactive
        const float eorValue = (wasActive && !isActive) ? 1.0f : 0.0f;
        
        l[i] = env; 
        r[i] = env;
        if (eorGate != nullptr) eorGate[i] = eorValue;
        if (unused != nullptr) unused[i] = 0.0f; // Channel 3 unused for now
    }

    // CORRECTED UPDATE:
    // Check pointers and dereference before storing the new value.
    if (lastOutputValues.size() >= 4)
    {
        if (lastOutputValues[0] != nullptr)
            lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        
        if (lastOutputValues[1] != nullptr)
            lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
        
        if (lastOutputValues[2] != nullptr)
            lastOutputValues[2]->store(buffer.getSample(2, buffer.getNumSamples() - 1));
        
        if (lastOutputValues[3] != nullptr)
            lastOutputValues[3]->store(buffer.getSample(3, buffer.getNumSamples() - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\ADSRModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_audio_basics/juce_audio_basics.h>

class ADSRModuleProcessor : public ModuleProcessor
{
public:
    // Parameter ID constants
    static constexpr auto paramIdAttack = "attack";
    static constexpr auto paramIdDecay = "decay";
    static constexpr auto paramIdSustain = "sustain";
    static constexpr auto paramIdRelease = "release";
    static constexpr auto paramIdAttackMod = "attack_mod";
    static constexpr auto paramIdDecayMod = "decay_mod";
    static constexpr auto paramIdSustainMod = "sustain_mod";
    static constexpr auto paramIdReleaseMod = "release_mod";

    ADSRModuleProcessor();
    ~ADSRModuleProcessor() override = default;

    const juce::String getName() const override { return "ADSR"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float a=0.01f,d=0.1f,s=0.7f,r=0.2f;
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdAttack)))  a = *p;
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdDecay)))   d = *p;
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdSustain))) s = *p;
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdRelease))) r = *p;
        
        ImGui::PushItemWidth (itemWidth);
        
        // Attack
        bool isAttackModulated = isParamModulated(paramIdAttackMod);
        if (isAttackModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Attack",  &a, 0.001f, 5.0f, "%.3f s", ImGuiSliderFlags_Logarithmic)) if (!isAttackModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdAttack)))  *p = a;
        if (!isAttackModulated) adjustParamOnWheel (ap.getParameter(paramIdAttack), "attack", a);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isAttackModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Decay
        bool isDecayModulated = isParamModulated(paramIdDecayMod);
        if (isDecayModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Decay",   &d, 0.001f, 5.0f, "%.3f s", ImGuiSliderFlags_Logarithmic)) if (!isDecayModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdDecay)))   *p = d;
        if (!isDecayModulated) adjustParamOnWheel (ap.getParameter(paramIdDecay), "decay", d);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isDecayModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Sustain
        bool isSustainModulated = isParamModulated(paramIdSustainMod);
        if (isSustainModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Sustain", &s, 0.0f, 1.0f)) if (!isSustainModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdSustain))) *p = s;
        if (!isSustainModulated) adjustParamOnWheel (ap.getParameter(paramIdSustain), "sustain", s);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isSustainModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Release
        bool isReleaseModulated = isParamModulated(paramIdReleaseMod);
        if (isReleaseModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Release", &r, 0.001f, 5.0f, "%.3f s", ImGuiSliderFlags_Logarithmic)) if (!isReleaseModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdRelease))) *p = r;
        if (!isReleaseModulated) adjustParamOnWheel (ap.getParameter(paramIdRelease), "release", r);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isReleaseModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("Gate In", 0);
        helpers.drawModulationInputPin("Attack Mod", paramIdAttackMod);
        helpers.drawModulationInputPin("Decay Mod", paramIdDecayMod);
        helpers.drawModulationInputPin("Sustain Mod", paramIdSustainMod);
        helpers.drawModulationInputPin("Release Mod", paramIdReleaseMod);
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
        helpers.drawAudioOutputPin("EOR Gate", 2);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* attackParam { nullptr };
    std::atomic<float>* decayParam { nullptr };
    std::atomic<float>* sustainParam { nullptr };
    std::atomic<float>* releaseParam { nullptr };
    std::atomic<float>* attackModParam { nullptr };
    std::atomic<float>* decayModParam { nullptr };
    std::atomic<float>* sustainModParam { nullptr };
    std::atomic<float>* releaseModParam { nullptr };
    juce::ADSR adsr;
    bool lastGate { false };
};




================================================================================
FILE: juce\Source\audio\modules\AttenuverterModuleProcessor.cpp
================================================================================


#include "AttenuverterModuleProcessor.h"

AttenuverterModuleProcessor::AttenuverterModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("Input", juce::AudioChannelSet::stereo(), true)
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "AttenuverterParams", createParameterLayout())
{
    amountParam = apvts.getRawParameterValue ("amount");
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

juce::AudioProcessorValueTreeState::ParameterLayout AttenuverterModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("amount", "Amount", juce::NormalisableRange<float> (-10.0f, 10.0f), 1.0f));
    return { params.begin(), params.end() };
}

void AttenuverterModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

void AttenuverterModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    auto in  = getBusBuffer (buffer, true, 0);
    auto out = getBusBuffer (buffer, false, 0);
    const float gain = amountParam != nullptr ? amountParam->load() : 1.0f;
    const int nSamps = buffer.getNumSamples();
    for (int ch = 0; ch < out.getNumChannels(); ++ch)
    {
        const float* s = in.getReadPointer (juce::jmin(ch, in.getNumChannels()-1));
        float* d = out.getWritePointer (ch);
        for (int i = 0; i < nSamps; ++i) d[i] = s[i] * gain;
    }
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(out.getSample(0, nSamps - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(out.getSample(1, nSamps - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\AttenuverterModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class AttenuverterModuleProcessor : public ModuleProcessor
{
public:
    AttenuverterModuleProcessor();
    ~AttenuverterModuleProcessor() override = default;

    const juce::String getName() const override { return "Attenuverter"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float amt = amountParam != nullptr ? amountParam->load() : 1.0f;
        ImGui::PushItemWidth (itemWidth);
        
        bool isAmountModulated = isParamModulated("amount");
        if (isAmountModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Amount", &amt, -10.0f, 10.0f)) if (!isAmountModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("amount"))) *p = amt;
        if (!isAmountModulated) adjustParamOnWheel (ap.getParameter ("amount"), "amount", amt);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isAmountModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("In L", 0);
        helpers.drawAudioInputPin("In R", 1);
        helpers.drawModulationInputPin("Amount", "amount");
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* amountParam { nullptr }; // -1..1
};




================================================================================
FILE: juce\Source\audio\modules\ClockDividerModuleProcessor.cpp
================================================================================


#include "ClockDividerModuleProcessor.h"

juce::AudioProcessorValueTreeState::ParameterLayout ClockDividerModuleProcessor::createParameterLayout()
{
    // No parameters for this module
    return { std::vector<std::unique_ptr<juce::RangedAudioParameter>>().begin(), 
             std::vector<std::unique_ptr<juce::RangedAudioParameter>>().end() };
}

ClockDividerModuleProcessor::ClockDividerModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Clock In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Out", juce::AudioChannelSet::discreteChannels(6), true)),
      apvts(*this, nullptr, "ClockDivParams", createParameterLayout())
{
    // ADD THIS BLOCK:
    for (int i = 0; i < 6; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

void ClockDividerModuleProcessor::prepareToPlay(double sr, int)
{
    sampleRate = sr;
    clockCount = 0;
    div2State = div4State = div8State = false;
    currentClockInterval = sampleRate; // Default to 1 second
    samplesSinceLastClock = 0;
    multiplierPhase[0] = multiplierPhase[1] = multiplierPhase[2] = 0.0;
    lastInputState = false;
}

void ClockDividerModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);

    const float* clockIn = in.getReadPointer(0);
    float* div2Out = out.getWritePointer(0);
    float* div4Out = out.getWritePointer(1);
    float* div8Out = out.getWritePointer(2);
    float* mul2Out = out.getWritePointer(3);
    float* mul3Out = out.getWritePointer(4);
    float* mul4Out = out.getWritePointer(5);

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        bool inputHigh = clockIn[i] > 0.5f;
        samplesSinceLastClock++;

        // --- Division on rising edge ---
        if (inputHigh && !lastInputState)
        {
            currentClockInterval = samplesSinceLastClock;
            samplesSinceLastClock = 0;
            
            clockCount++;
            if (clockCount % 2 == 0) div2State = !div2State;
            if (clockCount % 4 == 0) div4State = !div4State;
            if (clockCount % 8 == 0) div8State = !div8State;
        }
        lastInputState = inputHigh;

        div2Out[i] = div2State ? 1.0f : 0.0f;
        div4Out[i] = div4State ? 1.0f : 0.0f;
        div8Out[i] = div8State ? 1.0f : 0.0f;

        // --- Multiplication via phase ---
        if (currentClockInterval > 0)
        {
            double phaseInc = 1.0 / currentClockInterval;
            
            // x2
            multiplierPhase[0] += phaseInc * 2.0;
            if (multiplierPhase[0] >= 1.0) multiplierPhase[0] -= 1.0;
            mul2Out[i] = (multiplierPhase[0] < 0.5) ? 1.0f : 0.0f;

            // x3
            multiplierPhase[1] += phaseInc * 3.0;
            if (multiplierPhase[1] >= 1.0) multiplierPhase[1] -= 1.0;
            mul3Out[i] = (multiplierPhase[1] < 0.5) ? 1.0f : 0.0f;

            // x4
            multiplierPhase[2] += phaseInc * 4.0;
            if (multiplierPhase[2] >= 1.0) multiplierPhase[2] -= 1.0;
            mul4Out[i] = (multiplierPhase[2] < 0.5) ? 1.0f : 0.0f;
        }
    }
    
    // ADD THIS BLOCK:
    if (lastOutputValues.size() >= 6)
    {
        for (int i = 0; i < 6; ++i)
            if (lastOutputValues[i])
                lastOutputValues[i]->store(out.getSample(i, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void ClockDividerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Clock In", 0);
    helpers.drawAudioOutputPin("/2", 0);
    helpers.drawAudioOutputPin("/4", 1);
    helpers.drawAudioOutputPin("/8", 2);
    helpers.drawAudioOutputPin("x2", 3);
    helpers.drawAudioOutputPin("x3", 4);
    helpers.drawAudioOutputPin("x4", 5);
}
#endif


================================================================================
FILE: juce\Source\audio\modules\ClockDividerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class ClockDividerModuleProcessor : public ModuleProcessor
{
public:
    ClockDividerModuleProcessor();
    ~ClockDividerModuleProcessor() override = default;

    const juce::String getName() const override { return "Clock Divider"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override { juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded); } // No parameters
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;

    // Division state
    int clockCount { 0 };
    bool div2State { false }, div4State { false }, div8State { false };

    // Multiplication state
    double sampleRate { 48000.0 };
    double currentClockInterval { 0.0 };
    int samplesSinceLastClock { 0 };
    double multiplierPhase[3] { 0.0, 0.0, 0.0 }; // For x2, x3, x4

    bool lastInputState { false };
};


================================================================================
FILE: juce\Source\audio\modules\DelayModuleProcessor.cpp
================================================================================


#include "DelayModuleProcessor.h"

DelayModuleProcessor::DelayModuleProcessor()
    : ModuleProcessor (BusesProperties()
        .withInput ("In", juce::AudioChannelSet::stereo(), true)
        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "DelayParams", createParameterLayout())
{
    timeMsParam   = apvts.getRawParameterValue ("timeMs");
    feedbackParam = apvts.getRawParameterValue ("feedback");
    mixParam      = apvts.getRawParameterValue ("mix");
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

juce::AudioProcessorValueTreeState::ParameterLayout DelayModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("timeMs",  "Time (ms)", juce::NormalisableRange<float> (1.0f, 2000.0f, 0.01f, 0.4f), 400.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("feedback","Feedback",  juce::NormalisableRange<float> (0.0f, 0.95f), 0.4f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("mix",     "Mix",       juce::NormalisableRange<float> (0.0f, 1.0f), 0.3f));
    return { p.begin(), p.end() };
}

void DelayModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sr = sampleRate;
    maxDelaySamples = (int) std::ceil (2.0 * sr); // allow up to 2s safely
    dlL.setMaximumDelayInSamples (maxDelaySamples);
    dlR.setMaximumDelayInSamples (maxDelaySamples);
    juce::dsp::ProcessSpec spec { sr, (juce::uint32) samplesPerBlock, 1 };
    dlL.prepare (spec);
    dlR.prepare (spec);
    dlL.reset(); dlR.reset();
    juce::Logger::writeToLog ("[Delay] prepare sr=" + juce::String (sr) + " maxSamps=" + juce::String (maxDelaySamples));
}

void DelayModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    const float fb  = feedbackParam->load();
    const float mix = mixParam->load();
    float delaySamps = (timeMsParam->load() / 1000.0f) * (float) sr;
    delaySamps = juce::jlimit (1.0f, (float) (maxDelaySamples - 1), delaySamps);
    dlL.setDelay (delaySamps); dlR.setDelay (delaySamps);
    if (delaySamps >= (float) (maxDelaySamples - 1) || delaySamps < 1.0f)
        juce::Logger::writeToLog ("[Delay] clamped delaySamps=" + juce::String (delaySamps) + " max=" + juce::String (maxDelaySamples));

    auto processChannel = [&] (int ch)
    {
        float* d = buffer.getWritePointer (ch);
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            const float in = d[i];
            const float delayed = (ch == 0 ? dlL.popSample (0, delaySamps) : dlR.popSample (0, delaySamps));
            if (ch == 0) dlL.pushSample (0, in + delayed * fb); else dlR.pushSample (0, in + delayed * fb);
            d[i] = in * (1.0f - mix) + delayed * mix;
        }
    };
    processChannel (0);
    if (buffer.getNumChannels() > 1) processChannel (1);
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\DelayModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class DelayModuleProcessor : public ModuleProcessor
{
public:
    DelayModuleProcessor();
    ~DelayModuleProcessor() override = default;

    const juce::String getName() const override { return "Delay"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float timeMs = timeMsParam != nullptr ? timeMsParam->load() : 400.0f;
        float fb = feedbackParam != nullptr ? feedbackParam->load() : 0.4f;
        float mix = mixParam != nullptr ? mixParam->load() : 0.3f;
        ImGui::PushItemWidth (itemWidth);

        // Time
        bool isTimeModulated = isParamModulated("timeMs");
        if (isTimeModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Time (ms)", &timeMs, 1.0f, 2000.0f, "%.1f")) if (!isTimeModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("timeMs"))) *p = timeMs;
        if (!isTimeModulated) adjustParamOnWheel (ap.getParameter ("timeMs"), "timeMs", timeMs);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isTimeModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Feedback
        bool isFbModulated = isParamModulated("feedback");
        if (isFbModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Feedback", &fb, 0.0f, 0.95f)) if (!isFbModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("feedback"))) *p = fb;
        if (!isFbModulated) adjustParamOnWheel (ap.getParameter ("feedback"), "feedback", fb);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isFbModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Mix
        bool isMixModulated = isParamModulated("mix");
        if (isMixModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Mix", &mix, 0.0f, 1.0f)) if (!isMixModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("mix"))) *p = mix;
        if (!isMixModulated) adjustParamOnWheel (ap.getParameter ("mix"), "mix", mix);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isMixModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
        
        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("In L", 0);
        helpers.drawAudioInputPin("In R", 1);
        helpers.drawModulationInputPin("Time", "timeMs");
        helpers.drawModulationInputPin("Feedback", "feedback");
        helpers.drawModulationInputPin("Mix", "mix");
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd> dlL { 48000 }, dlR { 48000 };
    std::atomic<float>* timeMsParam { nullptr };
    std::atomic<float>* feedbackParam { nullptr };
    std::atomic<float>* mixParam { nullptr };
    double sr { 48000.0 };
    int maxDelaySamples { 48000 };
};




================================================================================
FILE: juce\Source\audio\modules\LFOModuleProcessor.cpp
================================================================================


#include "LFOModuleProcessor.h"

LFOModuleProcessor::LFOModuleProcessor()
    : ModuleProcessor (BusesProperties().withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "LFOParams", createParameterLayout())
{
    rateParam = apvts.getRawParameterValue (paramIdRate);
    depthParam = apvts.getRawParameterValue (paramIdDepth);
    bipolarParam = apvts.getRawParameterValue (paramIdBipolar);
    waveParam = apvts.getRawParameterValue (paramIdWave);
    rateModParam = apvts.getRawParameterValue (paramIdRateMod);
    depthModParam = apvts.getRawParameterValue (paramIdDepthMod);
    waveModParam = apvts.getRawParameterValue (paramIdWaveMod);
    
    // CORRECTED INITIALIZATION:
    // Create unique_ptrs to heap-allocated atomics for each output channel.
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 0
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 1
    
    osc.initialise ([](float x){ return std::sin(x); }, 128);
}

juce::AudioProcessorValueTreeState::ParameterLayout LFOModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdRate, "Rate", juce::NormalisableRange<float> (0.05f, 20.0f, 0.01f, 0.3f), 1.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdDepth, "Depth", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    p.push_back (std::make_unique<juce::AudioParameterBool> (paramIdBipolar, "Bipolar", true));
    p.push_back (std::make_unique<juce::AudioParameterChoice> (paramIdWave, "Wave", juce::StringArray { "Sine", "Tri", "Saw" }, 0));
    
    // Add modulation parameters
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdRateMod, "Rate Mod", 0.0f, 1.0f, 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdDepthMod, "Depth Mod", 0.0f, 1.0f, 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdWaveMod, "Wave Mod", 0.0f, 1.0f, 0.0f));
    return { p.begin(), p.end() };
}

void LFOModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 2 };
    osc.prepare (spec);
}

void LFOModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    buffer.clear();
    // Waveform modulation
    float waveMod = waveModParam != nullptr ? waveModParam->load() : 0.0f; // 0..1
    int numWaveChoices = 3;
    int waveModChoice = static_cast<int>(std::floor(waveMod * numWaveChoices));
    const int w = (static_cast<int>(waveParam->load()) + waveModChoice) % numWaveChoices;
    if (w == 0)      osc.initialise ([](float x){ return std::sin(x); }, 128);
    else if (w == 1) osc.initialise ([](float x){ return 2.0f / juce::MathConstants<float>::pi * std::asin(std::sin(x)); }, 128);
    else             osc.initialise ([](float x){ return (x / juce::MathConstants<float>::pi); }, 128);

    // Rate modulation (exponentially for musical effect)
    float rateMod = rateModParam != nullptr ? rateModParam->load() : 0.0f; // 0..1
    float finalRate = rateParam->load() * std::pow(4.0f, rateMod - 0.5f); // Modulate by +/- 2 octaves
    osc.setFrequency (finalRate);

    // Depth modulation
    float depthMod = depthModParam != nullptr ? depthModParam->load() : 0.0f; // 0..1
    const float depth = juce::jlimit(0.0f, 1.0f, depthParam->load() + (depthMod - 0.5f)); // Modulate by +/- 0.5
    const bool bipolar = bipolarParam->load() > 0.5f;

    juce::dsp::AudioBlock<float> block (buffer);
    juce::dsp::ProcessContextReplacing<float> ctx (block);
    osc.process (ctx);

    for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
    {
        float* d = buffer.getWritePointer (ch);
        for (int i = 0; i < buffer.getNumSamples(); ++i)
            d[i] = (bipolar ? d[i] : (d[i] * 0.5f + 0.5f)) * depth; // depth-scaled modulation signal
    }

    // CORRECTED UPDATE:
    // Check pointers and dereference before storing the new value.
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0] != nullptr)
            lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        
        if (lastOutputValues[1] != nullptr)
            lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\LFOModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class LFOModuleProcessor : public ModuleProcessor
{
public:
    // Parameter ID constants
    static constexpr auto paramIdRate = "rate";
    static constexpr auto paramIdDepth = "depth";
    static constexpr auto paramIdWave = "wave";
    static constexpr auto paramIdBipolar = "bipolar";
    static constexpr auto paramIdRateMod = "rate_mod";
    static constexpr auto paramIdDepthMod = "depth_mod";
    static constexpr auto paramIdWaveMod = "wave_mod";

    LFOModuleProcessor();
    ~LFOModuleProcessor() override = default;

    const juce::String getName() const override { return "LFO"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float rate = rateParam != nullptr ? rateParam->load() : 1.0f;
        float depth = depthParam != nullptr ? depthParam->load() : 0.5f;
        int wave = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWave))) wave = p->getIndex();
        bool bipolar = bipolarParam != nullptr ? (bipolarParam->load() > 0.5f) : true;
        
        ImGui::PushItemWidth (itemWidth);

        // Rate
        bool isRateModulated = isParamModulated(paramIdRateMod);
        if (isRateModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Rate", &rate, 0.05f, 20.0f, "%.2f Hz", ImGuiSliderFlags_Logarithmic)) if (!isRateModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdRate))) *p = rate;
        if (!isRateModulated) adjustParamOnWheel (ap.getParameter(paramIdRate), "rateHz", rate);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
        
        // Depth
        bool isDepthModulated = isParamModulated(paramIdDepthMod);
        if (isDepthModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Depth", &depth, 0.0f, 1.0f)) if (!isDepthModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdDepth))) *p = depth;
        if (!isDepthModulated) adjustParamOnWheel (ap.getParameter(paramIdDepth), "depth", depth);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isDepthModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Wave
        bool isWaveModulated = isParamModulated(paramIdWaveMod);
        if (isWaveModulated) ImGui::BeginDisabled();
        if (ImGui::Combo ("Wave", &wave, "Sine\0Tri\0Saw\0\0")) if (!isWaveModulated) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWave))) *p = wave;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isWaveModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Bipolar (no modulation input for this control)
        if (ImGui::Checkbox ("Bipolar", &bipolar)) if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter(paramIdBipolar))) *p = bipolar;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        // LFO modulation inputs
        helpers.drawModulationInputPin("Rate Mod", paramIdRateMod);
        helpers.drawModulationInputPin("Depth Mod", paramIdDepthMod);
        helpers.drawModulationInputPin("Wave Mod", paramIdWaveMod);
        // LFO outputs
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Oscillator<float> osc;
    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* depthParam { nullptr };
    std::atomic<float>* bipolarParam { nullptr };
    std::atomic<float>* waveParam { nullptr };
    std::atomic<float>* rateModParam { nullptr };
    std::atomic<float>* depthModParam { nullptr };
    std::atomic<float>* waveModParam { nullptr };
};




================================================================================
FILE: juce\Source\audio\modules\LogicModuleProcessor.cpp
================================================================================


#include "LogicModuleProcessor.h"

LogicModuleProcessor::LogicModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("In", juce::AudioChannelSet::stereo(), true) // A and B
                        .withOutput("Out", juce::AudioChannelSet::mono(), true)),
      apvts(*this, nullptr, "LogicParams", createParameterLayout())
{
    operationParam = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("operation"));
    
    // ADD THIS:
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout LogicModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterChoice>("operation", "Operation",
        juce::StringArray{ "A AND B", "A OR B", "A XOR B", "NOT A" }, 0));
    return { p.begin(), p.end() };
}

void LogicModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);

    // Explicitly clear the output buffer before writing to it.
    out.clear();

    const float* inA = in.getReadPointer(0);
    const float* inB = in.getNumChannels() > 1 ? in.getReadPointer(1) : nullptr;
    float* dst = out.getWritePointer(0);

    const int op = operationParam->getIndex();

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        bool a = inA[i] > 0.5f;
        bool b = (inB != nullptr) ? (inB[i] > 0.5f) : false;
        bool result = false;

        switch (op)
        {
            case 0: result = a && b; break; // AND
            case 1: result = a || b; break; // OR
            case 2: result = a != b; break; // XOR
            case 3: result = !a; break;     // NOT A
        }
        
        dst[i] = result ? 1.0f : 0.0f;
    }
    
    // ADD THIS BLOCK:
    if (!lastOutputValues.empty() && lastOutputValues[0])
    {
        lastOutputValues[0]->store(out.getSample(0, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void LogicModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    int op = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("operation"))) op = p->getIndex();

    ImGui::PushItemWidth(itemWidth);
    if (ImGui::Combo("Operation", &op, "A AND B\0A OR B\0A XOR B\0NOT A\0\0"))
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("operation"))) *p = op;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    ImGui::PopItemWidth();
}

void LogicModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In A", 0);
    helpers.drawAudioInputPin("In B", 1);
    helpers.drawAudioOutputPin("Out", 0);
}
#endif


================================================================================
FILE: juce\Source\audio\modules\LogicModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class LogicModuleProcessor : public ModuleProcessor
{
public:
    LogicModuleProcessor();
    ~LogicModuleProcessor() override = default;

    const juce::String getName() const override { return "Logic"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override {}
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    juce::AudioParameterChoice* operationParam { nullptr };
};


================================================================================
FILE: juce\Source\audio\modules\MapRangeModuleProcessor.cpp
================================================================================


#include "MapRangeModuleProcessor.h"

MapRangeModuleProcessor::MapRangeModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "MapRangeParams", createParameterLayout())
{
    inMinParam  = apvts.getRawParameterValue("inMin");
    inMaxParam  = apvts.getRawParameterValue("inMax");
    outMinParam = apvts.getRawParameterValue("outMin");
    outMaxParam = apvts.getRawParameterValue("outMax");
    
    // ADD THIS BLOCK:
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout MapRangeModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>("inMin", "Input Min", juce::NormalisableRange<float>(-100.0f, 100.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("inMax", "Input Max", juce::NormalisableRange<float>(-100.0f, 100.0f), 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("outMin", "Output Min", juce::NormalisableRange<float>(-10000.0f, 10000.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("outMax", "Output Max", juce::NormalisableRange<float>(-10000.0f, 10000.0f), 1.0f));
    return { params.begin(), params.end() };
}

void MapRangeModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(sampleRate, samplesPerBlock);
}

void MapRangeModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    const float inMin = inMinParam->load();
    const float inMax = inMaxParam->load();
    const float outMin = outMinParam->load();
    const float outMax = outMaxParam->load();
    
    const float inRange = inMax - inMin;
    const float outRange = outMax - outMin;
    
    // Get pointers to both output channels: 0 for Norm, 1 for Raw
    float* normDst = out.getWritePointer(0);
    float* rawDst = out.getNumChannels() > 1 ? out.getWritePointer(1) : nullptr;

    if (std::abs(inRange) < 0.0001f)
    {
        // Handle division by zero: output the middle of the output range.
        const float rawVal = (outMin + outMax) * 0.5f;
        const float normVal = 0.5f;
        for (int i = 0; i < buffer.getNumSamples(); ++i) {
            normDst[i] = normVal;
            if (rawDst) rawDst[i] = rawVal;
        }
        lastInputValue.store(inMin);
        lastOutputValue.store(rawVal);
    }
    else
    {
        const float* src = in.getReadPointer(0);
        float sumInput = 0.0f;
        float sumOutput = 0.0f;
        
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            // Calculate raw output value
            float clampedInput = juce::jlimit(inMin, inMax, src[i]);
            float rawOutputVal = outMin + (clampedInput - inMin) * outRange / inRange;
            
            // Calculate normalized output value
            float normOutputVal = 0.5f;
            if (std::abs(outRange) > 0.0001f)
                normOutputVal = (rawOutputVal - outMin) / outRange;
            
            // Write to respective outputs
            normDst[i] = juce::jlimit(0.0f, 1.0f, normOutputVal);
            if (rawDst) rawDst[i] = rawOutputVal;
            
            sumInput += clampedInput;
            sumOutput += rawOutputVal;
        }
        
        lastInputValue.store(sumInput / (float) buffer.getNumSamples());
        lastOutputValue.store(sumOutput / (float) buffer.getNumSamples());
    }

    // Update the hover-value display for both pins
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0])
            lastOutputValues[0]->store(out.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1])
            lastOutputValues[1]->store(out.getSample(1, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void MapRangeModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    float inMin = inMinParam->load();
    float inMax = inMaxParam->load();
    float outMin = outMinParam->load();
    float outMax = outMaxParam->load();

    ImGui::PushItemWidth(itemWidth);
    
    if (ImGui::SliderFloat("Input Min", &inMin, -100.0f, 100.0f))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = inMin;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("inMin"), "inMin", inMin);
    
    if (ImGui::SliderFloat("Input Max", &inMax, -100.0f, 100.0f))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = inMax;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("inMax"), "inMax", inMax);
    
    if (ImGui::SliderFloat("Output Min", &outMin, -10000.0f, 10000.0f, "%.1f", ImGuiSliderFlags_Logarithmic))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = outMin;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("outMin"), "outMin", outMin);
    
    if (ImGui::SliderFloat("Output Max", &outMax, -10000.0f, 10000.0f, "%.1f", ImGuiSliderFlags_Logarithmic))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = outMax;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("outMax"), "outMax", outMax);

    ImGui::Text("Input: %.2f", getLastInputValue());
    ImGui::Text("Output: %.2f", getLastOutputValue());

    ImGui::PopItemWidth();
}

void MapRangeModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Input", 0);
    helpers.drawAudioOutputPin("Norm Out", 0);
    helpers.drawAudioOutputPin("Raw Out", 1);
}
#endif

float MapRangeModuleProcessor::getLastInputValue() const
{
    return lastInputValue.load();
}

float MapRangeModuleProcessor::getLastOutputValue() const
{
    return lastOutputValue.load();
}


================================================================================
FILE: juce\Source\audio\modules\MapRangeModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class MapRangeModuleProcessor : public ModuleProcessor
{
public:
    MapRangeModuleProcessor();
    ~MapRangeModuleProcessor() override = default;

    const juce::String getName() const override { return "Map Range"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    float getLastInputValue() const;
    float getLastOutputValue() const;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* inMinParam { nullptr };
    std::atomic<float>* inMaxParam { nullptr };
    std::atomic<float>* outMinParam { nullptr };
    std::atomic<float>* outMaxParam { nullptr };

    std::atomic<float> lastInputValue { 0.0f };
    std::atomic<float> lastOutputValue { 0.0f };
};


================================================================================
FILE: juce\Source\audio\modules\MathModuleProcessor.cpp
================================================================================


#include "MathModuleProcessor.h"

MathModuleProcessor::MathModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("In A", juce::AudioChannelSet::mono(), true)
                        .withInput ("In B", juce::AudioChannelSet::mono(), true)
                        .withOutput("Out", juce::AudioChannelSet::mono(), true)),
      apvts (*this, nullptr, "MathParams", createParameterLayout())
{
    valueBParam    = apvts.getRawParameterValue ("valueB");
    operationParam = apvts.getRawParameterValue ("operation");
    
    // ADD THIS:
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout MathModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterChoice> ("operation", "Operation", juce::StringArray { "Add", "Subtract", "Multiply" }, 0));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("valueB", "Value B", juce::NormalisableRange<float> (-1.0f, 1.0f), 0.0f));
    return { p.begin(), p.end() };
}

void MathModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

void MathModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);

    auto inA = getBusBuffer (buffer, true, 0);
    auto out = getBusBuffer (buffer, false, 0);

    // CORRECTED LOGIC:
    auto inB = getBusBuffer(buffer, true, 1);
    // Check if input B is connected by checking if it has channels and non-zero data
    bool inBConnected = false;
    if (inB.getNumChannels() > 0)
    {
        const float* srcB = inB.getReadPointer(0);
        for (int i = 0; i < inB.getNumSamples(); ++i)
        {
            if (std::abs(srcB[i]) > 0.0001f)
            {
                inBConnected = true;
                break;
            }
        }
    }

    const float valueB = valueBParam->load();
    const int operation = static_cast<int>(operationParam->load());
    
    const float* srcA = inA.getNumChannels() > 0 ? inA.getReadPointer (0) : nullptr;
    const float* srcB = inBConnected ? inB.getReadPointer (0) : nullptr;
    float* dst = out.getWritePointer (0);

    float sum = 0.0f;
    float sumA = 0.0f;
    float sumB = 0.0f;
    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        float valA = srcA != nullptr ? srcA[i] : 0.0f;
        float valB = inBConnected ? srcB[i] : valueB;

        switch (operation)
        {
            case 0: // Add
                dst[i] = valA + valB;
                break;
            case 1: // Subtract
                dst[i] = valA - valB;
                break;
            case 2: // Multiply
                dst[i] = valA * valB;
                break;
        }
        sum += dst[i];
        sumA += valA;
        sumB += valB;
    }
    lastValue.store(sum / (float) buffer.getNumSamples());
    lastValueA.store(sumA / (float) buffer.getNumSamples());
    lastValueB.store(sumB / (float) buffer.getNumSamples());
    
    // ADD THIS BLOCK:
    if (!lastOutputValues.empty() && lastOutputValues[0])
    {
        lastOutputValues[0]->store(out.getSample(0, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void MathModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    int op = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("operation"))) op = p->getIndex();
    float valB = valueBParam != nullptr ? valueBParam->load() : 0.0f;
    
    ImGui::PushItemWidth (itemWidth);
    if (ImGui::Combo ("Operation", &op, "Add\0Subtract\0Multiply\0\0"))
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("operation"))) *p = op;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();

    if (ImGui::SliderFloat ("Value B", &valB, -1.0f, 1.0f))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("valueB"))) *p = valB;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel (ap.getParameter("valueB"), "valueB", valB);

    ImGui::Text("In A: %.2f", getLastValueA());
    ImGui::Text("In B: %.2f", getLastValueB());
    ImGui::Text("Out: %.2f", getLastValue());

    ImGui::PopItemWidth();
}

void MathModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In A", 0);
    helpers.drawAudioInputPin("In B", 1);
    helpers.drawAudioOutputPin("Out", 0);
}
#endif

float MathModuleProcessor::getLastValue() const
{
    return lastValue.load();
}

float MathModuleProcessor::getLastValueA() const
{
    return lastValueA.load();
}

float MathModuleProcessor::getLastValueB() const
{
    return lastValueB.load();
}


================================================================================
FILE: juce\Source\audio\modules\MathModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class MathModuleProcessor : public ModuleProcessor
{
public:
    MathModuleProcessor();
    ~MathModuleProcessor() override = default;

    const juce::String getName() const override { return "Math"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

    float getLastValue() const;
    float getLastValueA() const;
    float getLastValueB() const;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* valueBParam { nullptr };
    std::atomic<float>* operationParam { nullptr };

    std::atomic<float> lastValue { 0.0f };
    std::atomic<float> lastValueA { 0.0f };
    std::atomic<float> lastValueB { 0.0f };
};


================================================================================
FILE: juce\Source\audio\modules\MixerModuleProcessor.cpp
================================================================================


#include "MixerModuleProcessor.h"

// Corrected constructor with two separate stereo inputs
MixerModuleProcessor::MixerModuleProcessor()
    : ModuleProcessor (BusesProperties()
        .withInput ("In A", juce::AudioChannelSet::stereo(), true)  // Bus 0
        .withInput ("In B", juce::AudioChannelSet::stereo(), true)  // Bus 1
        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "MixerParams", createParameterLayout())
{
    gainParam      = apvts.getRawParameterValue ("gain");
    panParam       = apvts.getRawParameterValue ("pan");
    crossfadeParam = apvts.getRawParameterValue ("crossfade"); // Get the new parameter

    // Initialize value tooltips for the stereo output
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

// Updated parameter layout with the new crossfade slider
juce::AudioProcessorValueTreeState::ParameterLayout MixerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("gain", "Gain", juce::NormalisableRange<float> (-60.0f, 6.0f, 0.01f), 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("pan",  "Pan",  juce::NormalisableRange<float> (-1.0f, 1.0f), 0.0f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("crossfade",  "Crossfade",  juce::NormalisableRange<float> (-1.0f, 1.0f), 0.0f)); // A <-> B
    return { p.begin(), p.end() };
}

void MixerModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

// Completely rewritten processBlock for crossfading
void MixerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    
    auto inA = getBusBuffer(buffer, true, 0);
    auto inB = getBusBuffer(buffer, true, 1);
    auto out = getBusBuffer(buffer, false, 0);

    const int numSamples = buffer.getNumSamples();
    const int numChannels = out.getNumChannels();

    const float crossfade = crossfadeParam->load(); // -1 for A, 1 for B

    // Use a constant power law for a smooth crossfade without volume dips
    const float mixAngle = (crossfade * 0.5f + 0.5f) * juce::MathConstants<float>::halfPi;
    const float gainA = std::cos(mixAngle);
    const float gainB = std::sin(mixAngle);

    // Perform the crossfade into the output buffer
    for (int ch = 0; ch < numChannels; ++ch)
    {
        const float* srcA = inA.getReadPointer(ch);
        const float* srcB = inB.getReadPointer(ch);
        float* dst = out.getWritePointer(ch);
        
        for (int i = 0; i < numSamples; ++i)
        {
            dst[i] = (srcA[i] * gainA) + (srcB[i] * gainB);
        }
    }

    // Now, apply the master gain and pan to the mixed signal in the output buffer
    const float masterGain = juce::Decibels::decibelsToGain (gainParam->load());
    const float pan = panParam->load();
    const float panAngleMaster = (pan * 0.5f + 0.5f) * juce::MathConstants<float>::halfPi;
    const float lGain = masterGain * std::cos(panAngleMaster);
    const float rGain = masterGain * std::sin(panAngleMaster);

    out.applyGain(0, 0, numSamples, lGain);
    if (numChannels > 1)
        out.applyGain(1, 0, numSamples, rGain);

    // Update tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(out.getSample(0, numSamples - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(out.getSample(1, numSamples - 1));
    }
}

// Updated UI drawing code
#if defined(PRESET_CREATOR_UI)
void MixerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    float gainDb = gainParam != nullptr ? gainParam->load() : 0.0f;
    float pan = panParam != nullptr ? panParam->load() : 0.0f;
    float crossfade = crossfadeParam != nullptr ? crossfadeParam->load() : 0.0f;

    ImGui::PushItemWidth (itemWidth);

    // New Crossfade Slider
    bool isXfModulated = isParamModulated("crossfade");
    if (isXfModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("A <-> B", &crossfade, -1.0f, 1.0f)) if (!isXfModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("crossfade"))) *p = crossfade;
    if (!isXfModulated) adjustParamOnWheel (ap.getParameter ("crossfade"), "crossfade", crossfade);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isXfModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    ImGui::Separator();

    // Existing Gain and Pan Sliders
    bool isGainModulated = isParamModulated("gain");
    if (isGainModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Gain dB", &gainDb, -60.0f, 6.0f)) if (!isGainModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("gain"))) *p = gainDb;
    if (!isGainModulated) adjustParamOnWheel (ap.getParameter ("gain"), "gainDb", gainDb);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isGainModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    bool isPanModulated = isParamModulated("pan");
    if (isPanModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Pan", &pan, -1.0f, 1.0f)) if (!isPanModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("pan")))  *p = pan;
    if (!isPanModulated) adjustParamOnWheel (ap.getParameter ("pan"), "pan", pan);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isPanModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    ImGui::PopItemWidth();
}

void MixerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In A L", 0); // Bus 0, Channel 0
    helpers.drawAudioInputPin("In A R", 1); // Bus 0, Channel 1
    helpers.drawAudioInputPin("In B L", 2); // Bus 1, Channel 0
    helpers.drawAudioInputPin("In B R", 3); // Bus 1, Channel 1
    helpers.drawModulationInputPin("Gain", "gain");
    helpers.drawModulationInputPin("Pan", "pan");
    helpers.drawModulationInputPin("X-Fade", "crossfade");
    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}
#endif

================================================================================
FILE: juce\Source\audio\modules\MixerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class MixerModuleProcessor : public ModuleProcessor
{
public:
    MixerModuleProcessor();
    ~MixerModuleProcessor() override = default;

    const juce::String getName() const override { return "Mixer"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* gainParam { nullptr };       // dB
    std::atomic<float>* panParam { nullptr };        // -1..1
    std::atomic<float>* crossfadeParam { nullptr };  // <<< ADD THIS LINE
};

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include "../../ui/NodeUI_fwd.h"
#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#include <cmath>
#endif

/**
    An abstract base class for all modular synthesizer components.

    This class enforces a common interface for modules, ensuring they can be
    managed by the ModularSynthProcessor. The key requirement is providing access
    to the module's own parameter state via getAPVTS().
*/
class ModuleProcessor : public juce::AudioProcessor
{
public:
    ModuleProcessor(const BusesProperties& ioLayouts) : juce::AudioProcessor(ioLayouts) {}
    ~ModuleProcessor() override = default;

    // Pure virtual method that all concrete modules MUST implement.
    // This is crucial for the parameter proxy system.
    virtual juce::AudioProcessorValueTreeState& getAPVTS() = 0;

    // Optional UI hook for drawing parameters inside nodes (used by Preset Creator)
    virtual void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
    {
        juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded);
    }

    // Optional UI hook for drawing IO pins inside nodes
    virtual void drawIoPins(const NodePinHelpers& /*helpers*/) {}

    // ADD THIS NEW VIRTUAL METHOD
    virtual float getOutputChannelValue(int channel) const
    {
        if (juce::isPositiveAndBelow(channel, (int)lastOutputValues.size()) && lastOutputValues[channel])
            return lastOutputValues[channel]->load();
        return 0.0f;
    }

protected:
    // Thread-safe storage for last known output values (for tooltips)
    std::vector<std::unique_ptr<std::atomic<float>>> lastOutputValues;

#if defined(PRESET_CREATOR_UI)
protected:
    static void adjustParamOnWheel (juce::RangedAudioParameter* parameter,
                                    const juce::String& idOrName,
                                    float displayedValue)
    {
        if (parameter == nullptr) return;
        if (! ImGui::IsItemHovered()) return;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel == 0.0f) return;

        if (auto* pf = dynamic_cast<juce::AudioParameterFloat*>(parameter))
        {
            const auto& range = pf->range;
            const float span = range.end - range.start;
            const juce::String id = idOrName.toLowerCase();
            float step = span / 200.0f; // default ~0.5% of range
            if (span <= 1.0f) step = 0.01f;
            // Custom: fine tune for sequencer steps
            if (id.contains ("step"))
            {
                step = 0.05f;
            }
            if (id.contains ("hz") || id.contains ("freq") || id.contains ("cutoff") || id.contains ("rate"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (1.0f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("ms") || id.contains ("time"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (0.1f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("db") || id.contains ("gain"))
            {
                step = 0.5f;
            }
            else if (id.contains ("mix") || id.contains ("depth") || id.contains ("amount") || id.contains ("resonance") || id.contains ("q") || id.contains ("size") || id.contains ("damp") || id.contains ("pan") || id.contains ("threshold"))
            {
                step = 0.01f;
            }

            float newVal = pf->get() + (wheel > 0 ? step : -step);
            newVal = juce::jlimit (range.start, range.end, newVal);
            *pf = newVal;
        }
        else if (auto* pc = dynamic_cast<juce::AudioParameterChoice*>(parameter))
        {
            int idx = pc->getIndex();
            idx += (ImGui::GetIO().MouseWheel > 0 ? 1 : -1);
            idx = juce::jlimit (0, pc->choices.size() - 1, idx);
            *pc = idx;
        }
        else if (auto* pi = dynamic_cast<juce::AudioParameterInt*>(parameter))
        {
            int currentVal = pi->get();
            int newVal = currentVal + (wheel > 0 ? 1 : -1);
            const auto& range = pi->getNormalisableRange();
            newVal = juce::jlimit((int)range.start, (int)range.end, newVal);
            *pi = newVal;
        }
        else if (auto* pb = dynamic_cast<juce::AudioParameterBool*>(parameter))
        {
            // Optional: toggle on strong scroll
            juce::ignoreUnused (pb);
        }
    }

#endif

    //==============================================================================
    // Provide default implementations for the pure virtuals to reduce boilerplate
    // in concrete module classes.
    //==============================================================================
    const juce::String getName() const override { return "Module"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModuleProcessor)
};




================================================================================
FILE: juce\Source\audio\modules\NoiseModuleProcessor.cpp
================================================================================


#include "NoiseModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

NoiseModuleProcessor::NoiseModuleProcessor()
    : ModuleProcessor (BusesProperties().withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "NoiseParams", createParameterLayout())
{
    colourParam = apvts.getRawParameterValue(paramIdColour);
    levelParam  = apvts.getRawParameterValue(paramIdLevel);
    colourModParam = apvts.getRawParameterValue(paramIdColourMod);
    
    // CORRECTED INITIALIZATION:
    // Create unique_ptrs to heap-allocated atomics for each output channel.
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 0
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 1
}

juce::AudioProcessorValueTreeState::ParameterLayout NoiseModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterChoice> (paramIdColour, "Colour", juce::StringArray { "White", "Pink" }, 0));
    params.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdLevel, "Level", juce::NormalisableRange<float> (-60.0f, 6.0f, 0.01f), -12.0f));
    
    // Add modulation parameter for colour
    params.push_back (std::make_unique<juce::AudioParameterFloat> (paramIdColourMod, "Colour Mod", 0.0f, 1.0f, 0.0f));
    return { params.begin(), params.end() };
}

void NoiseModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (sampleRate, samplesPerBlock);
}

void NoiseModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    buffer.clear();
    float colourMod = colourModParam != nullptr ? colourModParam->load() : 0.0f; // 0..1
    // If modulation is > 0.5, add 1 to the base choice
    int finalColour = (static_cast<int>(colourParam->load()) + (colourMod > 0.5f ? 1 : 0)) % 2;
    const bool pink = (finalColour == 1);
    const float lin = juce::Decibels::decibelsToGain (levelParam->load());

    for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
    {
        float* d = buffer.getWritePointer (ch);
        float b0 = 0, b1 = 0, b2 = 0; // simple pink-ish filter per channel, reset per block
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            float w = rng.nextFloat() * 2.0f - 1.0f;
            float s = w;
            if (pink)
            {
                // very rough pink approximation
                b0 = 0.99765f * b0 + w * 0.0990460f;
                b1 = 0.96300f * b1 + w * 0.2965164f;
                b2 = 0.57000f * b2 + w * 1.0526913f;
                s = b0 + b1 + b2 + w * 0.1848f;
            }
            d[i] = s * lin;
        }
    }

    // CORRECTED UPDATE:
    // Check pointers and dereference before storing the new value.
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0] != nullptr)
            lastOutputValues[0]->store(buffer.getMagnitude(0, 0, buffer.getNumSamples()));
        
        if (lastOutputValues[1] != nullptr)
            lastOutputValues[1]->store(buffer.getMagnitude(1, 0, buffer.getNumSamples()));
    }
}




================================================================================
FILE: juce\Source\audio\modules\NoiseModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class NoiseModuleProcessor : public ModuleProcessor
{
public:
    // Parameter ID constants
    static constexpr auto paramIdColour = "colour";
    static constexpr auto paramIdLevel = "level";
    static constexpr auto paramIdColourMod = "colour_mod";

    NoiseModuleProcessor();
    ~NoiseModuleProcessor() override = default;

    const juce::String getName() const override { return "Noise"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        int colour = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdColour))) colour = p->getIndex();
        float levelDb = levelParam != nullptr ? levelParam->load() : -12.0f;
        
        ImGui::PushItemWidth (itemWidth);

        // Colour
        bool isColourModulated = isParamModulated(paramIdColourMod);
        if (isColourModulated) ImGui::BeginDisabled();
        if (ImGui::Combo ("Colour", &colour, "White\0Pink\0\0")) if (!isColourModulated) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdColour))) *p = colour;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isColourModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Level
        bool isLevelModulated = isParamModulated(paramIdLevel);
        if (isLevelModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Level dB", &levelDb, -60.0f, 6.0f)) if (!isLevelModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdLevel))) *p = levelDb;
        if (!isLevelModulated) adjustParamOnWheel(ap.getParameter(paramIdLevel), "level", levelDb);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isLevelModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawModulationInputPin("Level", paramIdLevel);
        helpers.drawModulationInputPin("Colour", paramIdColourMod);
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* colourParam { nullptr }; // 0 white, 1 pink approx
    std::atomic<float>* levelParam { nullptr }; // dB
    std::atomic<float>* colourModParam { nullptr };

    juce::Random rng;
};




================================================================================
FILE: juce\Source\audio\modules\QuantizerModuleProcessor.cpp
================================================================================


#include "QuantizerModuleProcessor.h"

QuantizerModuleProcessor::QuantizerModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Out", juce::AudioChannelSet::mono(), true)),
      apvts(*this, nullptr, "QuantizerParams", createParameterLayout())
{
    scaleParam = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("scale"));
    rootNoteParam = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("rootNote"));
    scaleModParam = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("scale_mod"));
    rootModParam = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("root_mod"));

    // Define scales as semitone offsets from the root
    scales.push_back({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }); // Chromatic
    scales.push_back({ 0, 2, 4, 5, 7, 9, 11 }); // Major
    scales.push_back({ 0, 2, 3, 5, 7, 8, 10 }); // Natural Minor
    scales.push_back({ 0, 2, 4, 7, 9 }); // Major Pentatonic
    scales.push_back({ 0, 3, 5, 7, 10 }); // Minor Pentatonic
    
    // ADD THIS:
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout QuantizerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterChoice>("scale", "Scale",
        juce::StringArray{ "Chromatic", "Major", "Natural Minor", "Major Pentatonic", "Minor Pentatonic" }, 0));
    p.push_back(std::make_unique<juce::AudioParameterInt>("rootNote", "Root Note", 0, 11, 0)); // 0=C, 1=C#, etc.
    p.push_back(std::make_unique<juce::AudioParameterFloat>("scale_mod", "Scale Mod", 0.0f, 1.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>("root_mod", "Root Mod", 0.0f, 1.0f, 0.0f));
    return { p.begin(), p.end() };
}

void QuantizerModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(sampleRate, samplesPerBlock);
}

void QuantizerModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);

    // Read modulation signals (0.0 to 1.0)
    float scaleModValue = scaleModParam->get();
    float rootModValue = rootModParam->get();

    // Calculate final scale index, wrapping around if necessary
    int finalScaleIdx = (scaleParam->getIndex() + static_cast<int>(scaleModValue * (float)scales.size())) % (int)scales.size();

    // Calculate final root note, wrapping around the 12-semitone octave
    int finalRootNote = (rootNoteParam->get() + static_cast<int>(rootModValue * 12.0f)) % 12;

    const auto& currentScale = scales[finalScaleIdx];
    const float rootNote = (float)finalRootNote;

    const float* src = in.getReadPointer(0);
    float* dst = out.getWritePointer(0);
    
    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        const float inputCV = juce::jlimit(0.0f, 1.0f, src[i]);
        
        // Map 0..1 CV to a 5-octave range (60 semitones)
        const float totalSemitones = inputCV * 60.0f;
        const int octave = static_cast<int>(totalSemitones / 12.0f);
        const float noteInOctave = totalSemitones - (octave * 12.0f);
        
        // Find the closest note in the scale
        float closestNote = currentScale[0];
        float minDistance = 12.0f;
        for (float scaleNote : currentScale)
        {
            float distance = std::abs(noteInOctave - scaleNote);
            if (distance < minDistance)
            {
                minDistance = distance;
                closestNote = scaleNote;
            }
        }
        
        // Combine octave, root, and quantized note, then map back to 0..1 CV
        float finalSemitones = (octave * 12.0f) + closestNote + rootNote;
        dst[i] = juce::jlimit(0.0f, 1.0f, finalSemitones / 60.0f);
    }
    
    // ADD THIS BLOCK:
    if (!lastOutputValues.empty() && lastOutputValues[0])
    {
        lastOutputValues[0]->store(out.getSample(0, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void QuantizerModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    int scale = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("scale"))) scale = p->getIndex();
    int root = 0; if (auto* p = dynamic_cast<juce::AudioParameterInt*>(ap.getParameter("rootNote"))) root = *p;

    const char* scales = "Chromatic\0Major\0Natural Minor\0Major Pentatonic\0Minor Pentatonic\0\0";
    const char* notes = "C\0C#\0D\0D#\0E\0F\0F#\0G\0G#\0A\0A#\0B\0\0";
    
    ImGui::PushItemWidth(itemWidth);

    // Scale Combo Box
    bool isScaleModulated = isParamModulated("scale_mod");
    if (isScaleModulated) ImGui::BeginDisabled();
    if (ImGui::Combo("Scale", &scale, scales)) if (!isScaleModulated) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("scale"))) *p = scale;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (isScaleModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    // Root Note Combo Box
    bool isRootModulated = isParamModulated("root_mod");
    if (isRootModulated) ImGui::BeginDisabled();
    if (ImGui::Combo("Root", &root, notes)) if (!isRootModulated) if (auto* p = dynamic_cast<juce::AudioParameterInt*>(ap.getParameter("rootNote"))) *p = root;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (isRootModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    
    ImGui::PopItemWidth();
}

void QuantizerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In", 0);
    helpers.drawModulationInputPin("Scale Mod", "scale_mod");
    helpers.drawModulationInputPin("Root Mod", "root_mod");
    helpers.drawAudioOutputPin("Out", 0);
}
#endif


================================================================================
FILE: juce\Source\audio\modules\QuantizerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class QuantizerModuleProcessor : public ModuleProcessor
{
public:
    QuantizerModuleProcessor();
    ~QuantizerModuleProcessor() override = default;

    const juce::String getName() const override { return "Quantizer"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    
    // Parameter pointers
    juce::AudioParameterChoice* scaleParam { nullptr };
    juce::AudioParameterInt* rootNoteParam { nullptr };
    juce::AudioParameterFloat* scaleModParam { nullptr };
    juce::AudioParameterFloat* rootModParam { nullptr };

    // Scale definitions
    std::vector<std::vector<float>> scales;
};


================================================================================
FILE: juce\Source\audio\modules\RandomModuleProcessor.cpp
================================================================================


#include "RandomModuleProcessor.h"
#include <cmath>

RandomModuleProcessor::RandomModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Trigger In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "RandomParams", createParameterLayout())
{
    minParam  = apvts.getRawParameterValue("min");
    maxParam  = apvts.getRawParameterValue("max");
    slewParam = apvts.getRawParameterValue("slew");
    rateParam = apvts.getRawParameterValue("rate");
    rateModParam = apvts.getRawParameterValue("rate_mod");
    slewModParam = apvts.getRawParameterValue("slew_mod"); // ADD THIS LINE
    
    // ADD THIS BLOCK:
    // Initialize storage for the two output pins (Norm Out, Raw Out)
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout RandomModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>("min", "Min", juce::NormalisableRange<float>(-100.0f, 100.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("max", "Max", juce::NormalisableRange<float>(-100.0f, 100.0f), 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("slew", "Slew", juce::NormalisableRange<float>(0.0f, 1.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("rate", "Rate", juce::NormalisableRange<float>(0.1f, 50.0f, 0.01f), 1.0f));
    // Absolute modulation input 0..1 mapping to 0.01..50 Hz like sequencer
    params.push_back(std::make_unique<juce::AudioParameterFloat>("rate_mod", "Rate Mod", juce::NormalisableRange<float>(0.0f, 1.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("slew_mod", "Slew Mod", juce::NormalisableRange<float>(0.0f, 1.0f), 0.0f));
    return { params.begin(), params.end() };
}

void RandomModuleProcessor::prepareToPlay(double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    sampleRate = newSampleRate;
    // Initialize with a random value in the current range
    const float minVal = minParam != nullptr ? minParam->load() : 0.0f;
    const float maxVal = maxParam != nullptr ? maxParam->load() : 1.0f;
    targetValue = currentValue = minVal + rng.nextFloat() * (maxVal - minVal);
    lastTrig = 0.0f;
    phase = 0.0;
}

void RandomModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    out.clear();

    const float* trigIn = in.getNumChannels() > 0 ? in.getReadPointer(0) : nullptr;
    const int numSamples = buffer.getNumSamples();

    const float minVal = minParam->load();
    const float maxVal = maxParam->load();
    // ADD THIS BLOCK to replace the line above
    const float slewModNorm = slewModParam != nullptr ? slewModParam->load() : 0.0f;
    const bool slewIsModulated = slewModNorm > 0.0001f;
    const float slew = slewIsModulated ? slewModNorm : slewParam->load();
    const float rateBase = rateParam != nullptr ? rateParam->load() : 1.0f;
    const float rateModNorm = rateModParam != nullptr ? rateModParam->load() : 0.0f; // 0..1
    const float rateFromMod = 0.01f + rateModNorm * (50.0f - 0.01f);
    const float rate = (rateModNorm > 0.0001f) ? rateFromMod : rateBase;
    
    const float slewCoeff = slew == 0.0f ? 1.0f : (float)(1.0 - std::exp(-1.0 / (0.01 * slew * sampleRate)));
    const double phaseInc = (sampleRate > 0.0 ? (double) rate / sampleRate : 0.0);
    
    // Debug: Print rate info occasionally
    static int debugCounter = 0;
    if (++debugCounter > 44100) // Print every second at 44.1kHz
    {
        debugCounter = 0;
        // juce::Logger::writeToLog("Random Rate: " + juce::String(rate) + " Hz, PhaseInc: " + juce::String(phaseInc));
    }
    
    float sumOutput = 0.0f;
    
    for (int i = 0; i < numSamples; ++i)
    {
        bool shouldGenerateNew = false;
        
        // Always use rate-based generation for continuous output
        phase += phaseInc;
        if (phase >= 1.0)
        {
            phase -= 1.0;
            shouldGenerateNew = true;
        }
        
        // Check trigger input (audio trigger) - this overrides the rate
        if (trigIn != nullptr)
        {
            const bool triggered = trigIn[i] > 0.5f && lastTrig <= 0.5f;
            lastTrig = trigIn[i];
            if (triggered) shouldGenerateNew = true;
        }
        
        if (shouldGenerateNew)
        {
            targetValue = minVal + rng.nextFloat() * (maxVal - minVal);
        }

        // Apply slew filtering to the output value
        if (slew > 0.0f)
            currentValue = currentValue + slewCoeff * (targetValue - currentValue);
        else
            currentValue = targetValue;
            
        // Compute a 0..1 normalised version of the value based on current Min/Max
        float normValue;
        const float range = maxVal - minVal;
        if (range == 0.0f) normValue = 0.5f; else normValue = juce::jlimit (0.0f, 1.0f, (currentValue - minVal) / range);

        // Channel 0: normalised (0..1) for modulation routing
        // Channel 1: raw value
        out.setSample(0, i, normValue);
        if (out.getNumChannels() > 1)
            out.setSample(1, i, currentValue);
        
        sumOutput += currentValue;
    }
    
    lastOutputValue.store(sumOutput / (float) numSamples);
    
    // ADD THIS BLOCK:
    // Store the last sample value of each output channel for the hover tooltip.
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) // Norm Out
            lastOutputValues[0]->store(out.getSample(0, numSamples - 1));
        
        if (lastOutputValues[1]) // Raw Out
            lastOutputValues[1]->store(out.getSample(1, numSamples - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void RandomModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    float minVal = minParam->load();
    float maxVal = maxParam->load();
    float slew = slewParam->load();

    ImGui::PushItemWidth(itemWidth);
    
    if (ImGui::SliderFloat("Min", &minVal, -100.0f, 100.0f)) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min"))) *p = minVal;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("min"), "min", minVal);

    if (ImGui::SliderFloat("Max", &maxVal, -100.0f, 100.0f)) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max"))) *p = maxVal;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("max"), "max", maxVal);

    bool slewIsMod = isParamModulated("slew_mod");
    if (slewIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Slew", &slew, 0.0f, 1.0f)) if (!slewIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("slew"))) *p = slew;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (!slewIsMod) adjustParamOnWheel(ap.getParameter("slew"), "slew", slew);
    if (slewIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    const float rateBaseUi = rateParam != nullptr ? rateParam->load() : 1.0f;
    const bool rateIsMod = isParamModulated("rate_mod");
    float rateEff = rateIsMod ? (0.01f + rateModParam->load() * 49.99f) : rateBaseUi;
    if (rateIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Rate", &rateEff, 0.01f, 50.0f)) if (!rateIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("rate"))) *p = rateEff;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (!rateIsMod) adjustParamOnWheel(ap.getParameter("rate"), "rate", rateEff);
    if (rateIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    ImGui::Text("Output: %.2f", getLastOutputValue());
    ImGui::PopItemWidth();
}

void RandomModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Trigger In", 0);
    helpers.drawModulationInputPin("Rate Mod", "rate_mod");
    helpers.drawModulationInputPin("Slew Mod", "slew_mod"); // ADD THIS LINE
    helpers.drawAudioOutputPin("Norm Out", 0);
    helpers.drawAudioOutputPin("Raw Out", 1);
}
#endif

float RandomModuleProcessor::getLastOutputValue() const
{
    return lastOutputValue.load();
}


================================================================================
FILE: juce\Source\audio\modules\RandomModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class RandomModuleProcessor : public ModuleProcessor
{
public:
    RandomModuleProcessor();
    ~RandomModuleProcessor() override = default;

    const juce::String getName() const override { return "Random"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    float getLastOutputValue() const;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    juce::Random rng;
    
    std::atomic<float>* minParam { nullptr };
    std::atomic<float>* maxParam { nullptr };
    std::atomic<float>* slewParam { nullptr };
    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* rateModParam { nullptr }; // absolute 0..1 modulation
    std::atomic<float>* slewModParam { nullptr }; // ADD THIS LINE
    
    float lastTrig { 0.0f };
    float currentValue { 0.0f };
    float targetValue { 0.0f };
    double sampleRate { 44100.0 };
    double phase { 0.0 };
    
    std::atomic<float> lastOutputValue { 0.0f };
};


================================================================================
FILE: juce\Source\audio\modules\RateModuleProcessor.cpp
================================================================================


#include "RateModuleProcessor.h"

RateModuleProcessor::RateModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Mod In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Out", juce::AudioChannelSet::mono(), true)),
      apvts(*this, nullptr, "RateParams", createParameterLayout())
{
    baseRateParam = apvts.getRawParameterValue("baseRate");
    multiplierParam = apvts.getRawParameterValue("multiplier");
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out
}

juce::AudioProcessorValueTreeState::ParameterLayout RateModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>("baseRate", "Base Rate", juce::NormalisableRange<float>(0.1f, 20.0f, 0.01f), 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("multiplier", "Multiplier", juce::NormalisableRange<float>(0.1f, 10.0f, 0.01f), 1.0f));
    return { params.begin(), params.end() };
}

void RateModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(sampleRate, samplesPerBlock);
}

void RateModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    const float* src = in.getNumChannels() > 0 ? in.getReadPointer(0) : nullptr;
    float* dst = out.getWritePointer(0);
    
    const float baseRate = baseRateParam->load();
    const float multiplier = multiplierParam->load();
    
    float sumOutput = 0.0f;
    
    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        float modulation = 0.0f;
        if (src != nullptr)
        {
            // Convert audio input (-1 to 1) to modulation range (-0.5 to +0.5)
            modulation = src[i] * 0.5f;
        }
        
        // Calculate final rate: baseRate * multiplier * (1 + modulation)
        float finalRate = baseRate * multiplier * (1.0f + modulation);
        finalRate = juce::jlimit(0.01f, 50.0f, finalRate); // Clamp to reasonable range
        
        // Normalize the rate to 0.0..1.0 for modulation routing
        // Map 0.01..50.0 Hz -> 0.0..1.0
        const float normalizedRate = juce::jlimit (0.0f, 1.0f, (finalRate - 0.01f) / (50.0f - 0.01f));
        dst[i] = normalizedRate;
        sumOutput += finalRate;
    }
    
    lastOutputValue.store(sumOutput / (float) buffer.getNumSamples());
    
    // Update output values for tooltips
    if (!lastOutputValues.empty() && lastOutputValues[0])
    {
        lastOutputValues[0]->store(out.getSample(0, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void RateModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    float baseRate = baseRateParam->load();
    float multiplier = multiplierParam->load();

    ImGui::PushItemWidth(itemWidth);
    
    if (ImGui::SliderFloat("Base Rate", &baseRate, 0.1f, 20.0f))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("baseRate"))) *p = baseRate;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("baseRate"), "baseRate", baseRate);

    if (ImGui::SliderFloat("Multiplier", &multiplier, 0.1f, 10.0f))
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("multiplier"))) *p = multiplier;
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    adjustParamOnWheel(ap.getParameter("multiplier"), "multiplier", multiplier);

    ImGui::Text("Output: %.2f Hz", getLastOutputValue());
    
    ImGui::PopItemWidth();
}

void RateModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Mod In", 0);
    helpers.drawAudioOutputPin("Out", 0);
}
#endif

float RateModuleProcessor::getLastOutputValue() const
{
    return lastOutputValue.load();
}


================================================================================
FILE: juce\Source\audio\modules\RateModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class RateModuleProcessor : public ModuleProcessor
{
public:
    RateModuleProcessor();
    ~RateModuleProcessor() override = default;

    const juce::String getName() const override { return "Rate"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    float getLastOutputValue() const;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* baseRateParam { nullptr };
    std::atomic<float>* multiplierParam { nullptr };
    
    std::atomic<float> lastOutputValue { 0.0f };
};


================================================================================
FILE: juce\Source\audio\modules\ReverbModuleProcessor.cpp
================================================================================


#include "ReverbModuleProcessor.h"

ReverbModuleProcessor::ReverbModuleProcessor()
    : ModuleProcessor (BusesProperties()
        .withInput ("In", juce::AudioChannelSet::stereo(), true)
        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "ReverbParams", createParameterLayout())
{
    sizeParam = apvts.getRawParameterValue ("size");
    dampParam = apvts.getRawParameterValue ("damp");
    mixParam  = apvts.getRawParameterValue ("mix");
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

juce::AudioProcessorValueTreeState::ParameterLayout ReverbModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("size", "Size", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("damp", "Damp", juce::NormalisableRange<float> (0.0f, 1.0f), 0.3f));
    p.push_back (std::make_unique<juce::AudioParameterFloat> ("mix",  "Mix",  juce::NormalisableRange<float> (0.0f, 1.0f), 0.3f));
    return { p.begin(), p.end() };
}

void ReverbModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 2 };
    reverb.prepare (spec);
}

void ReverbModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    juce::dsp::Reverb::Parameters par;
    par.roomSize = sizeParam->load();
    par.damping  = dampParam->load();
    par.wetLevel = mixParam->load();
    par.dryLevel = 1.0f - par.wetLevel;
    reverb.setParameters (par);
    juce::dsp::AudioBlock<float> block (buffer);
    juce::dsp::ProcessContextReplacing<float> ctx (block);
    reverb.process (ctx);
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\ReverbModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class ReverbModuleProcessor : public ModuleProcessor
{
public:
    ReverbModuleProcessor();
    ~ReverbModuleProcessor() override = default;

    const juce::String getName() const override { return "Reverb"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float size = sizeParam != nullptr ? sizeParam->load() : 0.5f;
        float damp = dampParam != nullptr ? dampParam->load() : 0.3f;
        float mix = mixParam != nullptr ? mixParam->load() : 0.3f;
        ImGui::PushItemWidth (itemWidth);

        // Size
        bool isSizeModulated = isParamModulated("size");
        if (isSizeModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Size", &size, 0.0f, 1.0f)) if (!isSizeModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("size"))) *p = size;
        if (!isSizeModulated) adjustParamOnWheel (ap.getParameter ("size"), "size", size);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isSizeModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
        
        // Damp
        bool isDampModulated = isParamModulated("damp");
        if (isDampModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Damp", &damp, 0.0f, 1.0f)) if (!isDampModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("damp"))) *p = damp;
        if (!isDampModulated) adjustParamOnWheel (ap.getParameter ("damp"), "damp", damp);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isDampModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
        
        // Mix
        bool isMixModulated = isParamModulated("mix");
        if (isMixModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Mix", &mix, 0.0f, 1.0f)) if (!isMixModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("mix")))  *p = mix;
        if (!isMixModulated) adjustParamOnWheel (ap.getParameter ("mix"), "mix", mix);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isMixModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("In L", 0);
        helpers.drawAudioInputPin("In R", 1);
        helpers.drawModulationInputPin("Size", "size");
        helpers.drawModulationInputPin("Damp", "damp");
        helpers.drawModulationInputPin("Mix", "mix");
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Reverb reverb;
    std::atomic<float>* sizeParam { nullptr };
    std::atomic<float>* dampParam { nullptr };
    std::atomic<float>* mixParam { nullptr };
};




================================================================================
FILE: juce\Source\audio\modules\SampleLoaderModuleProcessor.cpp
================================================================================


#include "SampleLoaderModuleProcessor.h"
#include <juce_audio_formats/juce_audio_formats.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include "../../utils/RtLogger.h"

#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/ImGuiNodeEditorComponent.h"
#endif

SampleLoaderModuleProcessor::SampleLoaderModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withOutput("Audio Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "SampleLoaderParameters", createParameterLayout())
{
    // Parameter references will be obtained when needed
}

juce::AudioProcessorValueTreeState::ParameterLayout SampleLoaderModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters;
    
    // --- Basic Playback Parameters ---
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "speed", "Speed", 0.25f, 4.0f, 1.0f));
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitch", "Pitch (semitones)", -24.0f, 24.0f, 0.0f));
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "volume", "Volume", 0.0f, 1.0f, 0.8f));
    parameters.push_back(std::make_unique<juce::AudioParameterChoice>(
        "engine", "Engine", juce::StringArray { "RubberBand", "Naive" }, 0));
    parameters.push_back(std::make_unique<juce::AudioParameterBool>(
        "rbWindowShort", "RB Window Short", true));
    parameters.push_back(std::make_unique<juce::AudioParameterBool>(
        "rbPhaseInd", "RB Phase Independent", true));
    parameters.push_back(std::make_unique<juce::AudioParameterBool>(
        "loop", "Loop", false));
    
    // (Removed legacy SoundTouch tuning parameters)
    
    return { parameters.begin(), parameters.end() };
}

void SampleLoaderModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(sampleRate, samplesPerBlock);
    juce::Logger::writeToLog("[Sample Loader] prepareToPlay sr=" + juce::String(sampleRate) + ", block=" + juce::String(samplesPerBlock));
    // Auto-load sample from saved state if available
    if (currentSample == nullptr)
    {
        const auto savedPath = apvts.state.getProperty ("samplePath").toString();
        if (savedPath.isNotEmpty())
        {
            currentSamplePath = savedPath;
            loadSample (juce::File (currentSamplePath));
        }
    }
    // Create sample processor if we have a sample loaded
    if (currentSample != nullptr)
    {
        createSampleProcessor();
    }
}

void SampleLoaderModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    // Safe swap of processor if a new one was staged by UI thread
    if (auto* pending = newSampleProcessor.exchange(nullptr))
    {
        const juce::ScopedLock lock(processorSwapLock);
        processorToDelete = std::move(sampleProcessor);
        sampleProcessor.reset(pending);
    }
    buffer.clear();
    
    SampleVoiceProcessor* currentProcessor = nullptr;
    {
        const juce::ScopedLock lock(processorSwapLock);
        currentProcessor = sampleProcessor.get();
    }
    if (currentProcessor == nullptr || currentSample == nullptr)
    {
        return;
    }
    
    // No legacy SoundTouch updates; Rubber Band is configured in the voice's stretcher
    
    // Realtime parameter updates to voice (audio thread safe)
    if (currentProcessor)
    {
        const float speedNow = apvts.getRawParameterValue("speed")->load();
        const float pitchNow = apvts.getRawParameterValue("pitch")->load();
        currentProcessor->setZoneTimeStretchRatio(speedNow);
        currentProcessor->setBasePitchSemitones(pitchNow);
        const int engineIdx = (int) apvts.getRawParameterValue("engine")->load();
        currentProcessor->setEngine(engineIdx == 0 ? SampleVoiceProcessor::Engine::RubberBand
                                                   : SampleVoiceProcessor::Engine::Naive);
        const bool rbWinShort = apvts.getRawParameterValue("rbWindowShort")->load() > 0.5f;
        const bool rbPhaseInd = apvts.getRawParameterValue("rbPhaseInd")->load() > 0.5f;
        const bool loop = apvts.getRawParameterValue("loop")->load() > 0.5f;
        // Pass options via engine-specific setter on the voice (uses TimePitchProcessor::setOptions)
        currentProcessor->setRubberBandOptions(rbWinShort, rbPhaseInd);
        currentProcessor->setLooping(loop);
    }
    
    // Process the sample
    if (currentProcessor)
    {
        try {
            currentProcessor->renderBlock(buffer, midiMessages);
        } catch (...) {
            RtLogger::postf("[SampleLoader][FATAL] renderBlock exception");
            buffer.clear();
        }
    }
    else
        buffer.clear();
    
    // Apply volume
    buffer.applyGain(apvts.getRawParameterValue("volume")->load());
    
    // Debug output
    if (debugOutput)
    {
        static int debugCounter = 0;
        if (++debugCounter % 1000 == 0)
        {
            DBG("[Sample Loader] Speed: " + juce::String(apvts.getRawParameterValue("speed")->load()) + 
                ", Pitch: " + juce::String(apvts.getRawParameterValue("pitch")->load()));
        }
    }
}

void SampleLoaderModuleProcessor::reset()
{
    if (sampleProcessor != nullptr)
    {
        sampleProcessor->reset();
    }
}

void SampleLoaderModuleProcessor::loadSample(const juce::File& file)
{
    if (!file.existsAsFile())
    {
        DBG("[Sample Loader] File does not exist: " + file.getFullPathName());
        return;
    }

    // 1) Load the original shared sample from the bank
    SampleBank sampleBank;
    std::shared_ptr<SampleBank::Sample> original;
    try {
        original = sampleBank.getOrLoad(file);
    } catch (...) {
        DBG("[Sample Loader][FATAL] Exception in SampleBank::getOrLoad");
        return;
    }
    if (original == nullptr || original->stereo.getNumSamples() <= 0)
    {
        DBG("[Sample Loader] Failed to load sample or empty: " + file.getFullPathName());
        return;
    }

    currentSampleName = file.getFileName();
    currentSamplePath = file.getFullPathName();
    apvts.state.setProperty ("samplePath", currentSamplePath, nullptr);

    // 2) Create a private copy and convert to mono
    auto privateCopy = std::make_shared<SampleBank::Sample>();
    privateCopy->sampleRate = original->sampleRate;
    const int numSamples = original->stereo.getNumSamples();
    privateCopy->stereo.setSize(1, numSamples);

    if (original->stereo.getNumChannels() <= 1)
    {
        privateCopy->stereo.copyFrom(0, 0, original->stereo, 0, 0, numSamples);
    }
    else
    {
        privateCopy->stereo.clear();
        privateCopy->stereo.addFrom(0, 0, original->stereo, 0, 0, numSamples, 0.5f);
        privateCopy->stereo.addFrom(0, 0, original->stereo, 1, 0, numSamples, 0.5f);
    }

    // 3) Atomically assign our private copy for this module
    currentSample = privateCopy;
    DBG("[Sample Loader] Loaded and created private mono copy of: " << currentSampleName);

    // 4) If the module is prepared, stage a new processor
    if (getSampleRate() > 0.0 && getBlockSize() > 0)
    {
        createSampleProcessor();
    }
    else
    {
        DBG("[Sample Loader][Defer] Module not prepared yet; will create processor in prepareToPlay");
    }
}
void SampleLoaderModuleProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    juce::ValueTree vt ("SampleLoader");
    vt.setProperty ("samplePath", currentSamplePath, nullptr);
    vt.setProperty ("speed", apvts.getRawParameterValue("speed")->load(), nullptr);
    vt.setProperty ("pitch", apvts.getRawParameterValue("pitch")->load(), nullptr);
    vt.setProperty ("volume", apvts.getRawParameterValue("volume")->load(), nullptr);
    vt.setProperty ("engine", (int) apvts.getRawParameterValue("engine")->load(), nullptr);
    vt.setProperty ("rbWindowShort", apvts.getRawParameterValue("rbWindowShort")->load() > 0.5f, nullptr);
    vt.setProperty ("rbPhaseInd", apvts.getRawParameterValue("rbPhaseInd")->load() > 0.5f, nullptr);
    vt.setProperty ("loop", apvts.getRawParameterValue("loop")->load() > 0.5f, nullptr);
    if (auto xml = vt.createXml())
        copyXmlToBinary (*xml, destData);
}

void SampleLoaderModuleProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
    if (! xml) return;
    juce::ValueTree vt = juce::ValueTree::fromXml (*xml);
    if (! vt.isValid()) return;
    currentSamplePath = vt.getProperty ("samplePath").toString();
    if (currentSamplePath.isNotEmpty())
        loadSample (juce::File (currentSamplePath));
    if (auto* p = apvts.getParameter ("speed"))
        p->setValueNotifyingHost (apvts.getParameterRange("speed").convertTo0to1 ((float) vt.getProperty ("speed", 1.0f)));
    if (auto* p = apvts.getParameter ("pitch"))
        p->setValueNotifyingHost (apvts.getParameterRange("pitch").convertTo0to1 ((float) vt.getProperty ("pitch", 0.0f)));
    if (auto* p = apvts.getParameter ("volume"))
        p->setValueNotifyingHost (apvts.getParameterRange("volume").convertTo0to1 ((float) vt.getProperty ("volume", 0.8f)));
    if (auto* p = apvts.getParameter ("engine"))
        p->setValueNotifyingHost ((float) (int) vt.getProperty ("engine", 0));
    if (auto* p = apvts.getParameter ("rbWindowShort"))
        p->setValueNotifyingHost ((bool) vt.getProperty ("rbWindowShort", true) ? 1.0f : 0.0f);
    if (auto* p = apvts.getParameter ("rbPhaseInd"))
        p->setValueNotifyingHost ((bool) vt.getProperty ("rbPhaseInd", true) ? 1.0f : 0.0f);
    if (auto* p = apvts.getParameter ("loop"))
        p->setValueNotifyingHost ((bool) vt.getProperty ("loop", false) ? 1.0f : 0.0f);
}

void SampleLoaderModuleProcessor::loadSample(const juce::String& filePath)
{
    loadSample(juce::File(filePath));
}

juce::String SampleLoaderModuleProcessor::getCurrentSampleName() const
{
    return currentSampleName;
}

bool SampleLoaderModuleProcessor::hasSampleLoaded() const
{
    return currentSample != nullptr;
}

// Legacy SoundTouch setters removed

void SampleLoaderModuleProcessor::setDebugOutput(bool enabled)
{
    debugOutput = enabled;
}

void SampleLoaderModuleProcessor::logCurrentSettings() const
{
    if (debugOutput)
    {
        DBG("[Sample Loader] Current Settings:");
        DBG("  Sample: " + currentSampleName);
        DBG("  Speed: " + juce::String(apvts.getRawParameterValue("speed")->load()));
        DBG("  Pitch: " + juce::String(apvts.getRawParameterValue("pitch")->load()));
    }
}

void SampleLoaderModuleProcessor::updateSoundTouchSettings() {}

void SampleLoaderModuleProcessor::randomizeSample()
{
    if (currentSamplePath.isEmpty())
        return;
        
    juce::File currentFile(currentSamplePath);
    juce::File parentDir = currentFile.getParentDirectory();
    
    if (!parentDir.exists() || !parentDir.isDirectory())
        return;
        
    // Get all audio files in the same directory
    juce::Array<juce::File> audioFiles;
    parentDir.findChildFiles(audioFiles, juce::File::findFiles, true, "*.wav;*.mp3;*.flac;*.aiff;*.ogg");
    
    if (audioFiles.size() <= 1)
        return;
        
    // Remove current file from the list
    for (int i = audioFiles.size() - 1; i >= 0; --i)
    {
        if (audioFiles[i].getFullPathName() == currentSamplePath)
        {
            audioFiles.remove(i);
            break;
        }
    }
    
    if (audioFiles.isEmpty())
        return;
        
    // Pick a random file
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    juce::File randomFile = audioFiles[rng.nextInt(audioFiles.size())];
    
    DBG("[Sample Loader] Randomizing to: " + randomFile.getFullPathName());
    loadSample(randomFile);
}

void SampleLoaderModuleProcessor::createSampleProcessor()
{
    if (currentSample == nullptr)
    {
        return;
    }
    // Guard against double-creation and race with audio thread: build new then swap under lock
    auto newProcessor = std::make_unique<SampleVoiceProcessor>(currentSample);
    
    // Set up the sample processor
    const double sr = getSampleRate() > 0.0 ? getSampleRate() : 48000.0;
    const int bs = getBlockSize() > 0 ? getBlockSize() : 512;
    newProcessor->prepareToPlay(sr, bs);
    
    // Set parameters from our APVTS
    newProcessor->setZoneTimeStretchRatio(apvts.getRawParameterValue("speed")->load());
    newProcessor->setBasePitchSemitones(apvts.getRawParameterValue("pitch")->load());
    newSampleProcessor.store(newProcessor.release());
    DBG("[Sample Loader] Staged new sample processor for: " << currentSampleName);
    
    DBG("[Sample Loader] Created sample processor for: " + currentSampleName);
}

#if defined(PRESET_CREATOR_UI)
void SampleLoaderModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    // File loading section
    ImGui::Text("Sample Loader");
    
    // Current sample display
    if (hasSampleLoaded())
    {
        ImGui::Text("Loaded: %s", currentSampleName.toRawUTF8());
    }
    else
    {
        ImGui::Text("No sample loaded");
    }
    
    // File browser button
    if (ImGui::Button("Load Sample"))
    {
        // Open native file browser (persistent member so callback stays alive)
        fileChooser = std::make_unique<juce::FileChooser>("Select Audio Sample",
                                                          juce::File(),
                                                          "*.wav;*.mp3;*.flac;*.aiff;*.ogg");
        
        auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;
        fileChooser->launchAsync(chooserFlags, [this](const juce::FileChooser& fc)
        {
            try {
                auto file = fc.getResult();
                if (file != juce::File{})
                {
                    juce::Logger::writeToLog("[Sample Loader] User selected file: " + file.getFullPathName());
                    loadSample(file);
                }
                else
                {
                    juce::Logger::writeToLog("[Sample Loader] File selection cancelled or empty");
                }
            } catch (...) {
                juce::Logger::writeToLog("[Sample Loader][FATAL] Exception during file chooser callback");
            }
        });
    }
    
    // Basic playback parameters (scroll-editable like other nodes)
    ImGui::Text("Playback");
    ImGui::PushItemWidth(itemWidth);
    
    // Speed parameter
    bool speedModulated = isParamModulated("speed");
    if (speedModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 1.0f, 0.0f, 0.3f));
    float speed = apvts.getRawParameterValue("speed")->load();
    if (ImGui::InputFloat("Speed", &speed, 0.0f, 0.0f, "%.3fx"))
    {
        apvts.getParameter("speed")->setValueNotifyingHost(apvts.getParameterRange("speed").convertTo0to1(speed));
        onModificationEnded();
    }
    // Scroll-wheel acceleration for Speed
    if (ImGui::IsItemHovered())
    {
        static double lastScrollTimeS = 0.0; static float momentum = 1.0f;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel != 0.0f)
        {
            const double now = ImGui::GetTime();
            const double dt = now - lastScrollTimeS;
            if (dt > 0.2) momentum = 1.0f;
            const float baseStep = 0.01f;
            float finalStep = baseStep * momentum * (wheel > 0.0f ? 1.0f : -1.0f);
            speed = juce::jlimit(0.25f, 4.0f, speed + finalStep);
            apvts.getParameter("speed")->setValueNotifyingHost(apvts.getParameterRange("speed").convertTo0to1(speed));
            onModificationEnded();
            momentum = juce::jmin(2000.0f, momentum * 1.08f);
            lastScrollTimeS = now;
        }
    }
    if (speedModulated) ImGui::PopStyleColor();
    
    // Pitch parameter
    bool pitchModulated = isParamModulated("pitch");
    if (pitchModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 1.0f, 0.0f, 0.3f));
    float pitch = apvts.getRawParameterValue("pitch")->load();
    if (ImGui::InputFloat("Pitch", &pitch, 0.0f, 0.0f, "%.2f semitones"))
    {
        apvts.getParameter("pitch")->setValueNotifyingHost(apvts.getParameterRange("pitch").convertTo0to1(pitch));
        onModificationEnded();
    }
    // Scroll-wheel acceleration for Pitch
    if (ImGui::IsItemHovered())
    {
        static double lastScrollTimeS = 0.0; static float momentum = 1.0f;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel != 0.0f)
        {
            const double now = ImGui::GetTime();
            const double dt = now - lastScrollTimeS;
            if (dt > 0.2) momentum = 1.0f;
            const float baseStep = 0.1f;
            float finalStep = baseStep * momentum * (wheel > 0.0f ? 1.0f : -1.0f);
            pitch = juce::jlimit(-24.0f, 24.0f, pitch + finalStep);
            apvts.getParameter("pitch")->setValueNotifyingHost(apvts.getParameterRange("pitch").convertTo0to1(pitch));
            onModificationEnded();
            momentum = juce::jmin(2000.0f, momentum * 1.08f);
            lastScrollTimeS = now;
        }
    }
    if (pitchModulated) ImGui::PopStyleColor();
    
    // Volume parameter
    bool volumeModulated = isParamModulated("volume");
    if (volumeModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 1.0f, 0.0f, 0.3f));
    float volume = apvts.getRawParameterValue("volume")->load();
    if (ImGui::SliderFloat("Volume", &volume, 0.0f, 1.0f, "%.2f"))
    {
        apvts.getParameter("volume")->setValueNotifyingHost(apvts.getParameterRange("volume").convertTo0to1(volume));
        onModificationEnded();
    }
    if (volumeModulated) ImGui::PopStyleColor();
    
    ImGui::PopItemWidth();

    // Engine choice
    ImGui::Text("Engine");
    int engineIdx = (int) apvts.getRawParameterValue("engine")->load();
    const char* items[] = { "RubberBand", "Naive" };
    if (ImGui::Combo("##engine", &engineIdx, items, 2))
    {
        apvts.getParameter("engine")->setValueNotifyingHost((float) engineIdx);
        if (sampleProcessor)
            sampleProcessor->setEngine(engineIdx == 0 ? SampleVoiceProcessor::Engine::RubberBand
                                                      : SampleVoiceProcessor::Engine::Naive);
        onModificationEnded();
    }
    // RubberBand tuning
    if (engineIdx == 0)
    {
        bool winShort = apvts.getRawParameterValue("rbWindowShort")->load() > 0.5f;
        if (ImGui::Checkbox("RB Window Short", &winShort))
        {
            apvts.getParameter("rbWindowShort")->setValueNotifyingHost(winShort ? 1.0f : 0.0f);
            if (sampleProcessor) sampleProcessor->setRubberBandOptions(winShort, apvts.getRawParameterValue("rbPhaseInd")->load() > 0.5f);
            onModificationEnded();
        }
        bool phaseInd = apvts.getRawParameterValue("rbPhaseInd")->load() > 0.5f;
        if (ImGui::Checkbox("RB Phase Independent", &phaseInd))
        {
            apvts.getParameter("rbPhaseInd")->setValueNotifyingHost(phaseInd ? 1.0f : 0.0f);
            if (sampleProcessor) sampleProcessor->setRubberBandOptions(apvts.getRawParameterValue("rbWindowShort")->load() > 0.5f, phaseInd);
            onModificationEnded();
        }
    }
    
    // Smoothing controls (give maximum flexibility)
    // Smoothing (no divider)
    ImGui::Text("Smoothing");
    ImGui::PushItemWidth(itemWidth);
    static bool smoothingEnabledUI = true; // defaults per user preference
    static float timeMs = 100.0f, pitchMs = 100.0f;
    static float alphaTime = 0.4f, alphaPitch = 0.4f;
    static int maxBlocksTime = 1, maxBlocksPitch = 1;

    if (ImGui::Checkbox("Enabled", &smoothingEnabledUI))
    {
        if (sampleProcessor) sampleProcessor->setSmoothingEnabled(smoothingEnabledUI);
    }
    if (ImGui::InputFloat("Time Smooth (ms)", &timeMs, 0.0f, 0.0f, "%.2f"))
    {
        timeMs = juce::jlimit(0.0f, 100.0f, timeMs);
        if (sampleProcessor) sampleProcessor->setSmoothingTimeMs(timeMs, pitchMs);
    }
    if (ImGui::InputFloat("Pitch Smooth (ms)", &pitchMs, 0.0f, 0.0f, "%.2f"))
    {
        pitchMs = juce::jlimit(0.0f, 100.0f, pitchMs);
        if (sampleProcessor) sampleProcessor->setSmoothingTimeMs(timeMs, pitchMs);
    }
    if (ImGui::InputFloat("Time Alpha (0-1)", &alphaTime, 0.0f, 0.0f, "%.3f"))
    {
        alphaTime = juce::jlimit(0.0f, 0.999f, alphaTime);
        if (sampleProcessor) sampleProcessor->setSmoothingAlpha(alphaTime, alphaPitch);
    }
    if (ImGui::InputFloat("Pitch Alpha (0-1)", &alphaPitch, 0.0f, 0.0f, "%.3f"))
    {
        alphaPitch = juce::jlimit(0.0f, 0.999f, alphaPitch);
        if (sampleProcessor) sampleProcessor->setSmoothingAlpha(alphaTime, alphaPitch);
    }
    if (ImGui::InputInt("Max Blocks Time", &maxBlocksTime))
    {
        maxBlocksTime = juce::jlimit(1, 64, maxBlocksTime);
        if (sampleProcessor) sampleProcessor->setSmoothingMaxBlocks(maxBlocksTime, maxBlocksPitch);
    }
    if (ImGui::InputInt("Max Blocks Pitch", &maxBlocksPitch))
    {
        maxBlocksPitch = juce::jlimit(1, 64, maxBlocksPitch);
        if (sampleProcessor) sampleProcessor->setSmoothingMaxBlocks(maxBlocksTime, maxBlocksPitch);
    }
    // Snap thresholds & reset policy
    static float timeSnap = 0.5f; static float pitchSnap = 3.0f;
    static bool resetOnSnap = true; static bool resetNoSmooth = true;
    if (ImGui::InputFloat("Time Snap Threshold", &timeSnap, 0.0f, 0.0f, "%.3f"))
    {
        timeSnap = juce::jlimit(0.0f, 1.0f, timeSnap);
        if (sampleProcessor) sampleProcessor->setSmoothingSnapThresholds(timeSnap, pitchSnap);
    }
    if (ImGui::InputFloat("Pitch Snap Threshold (semitones)", &pitchSnap, 0.0f, 0.0f, "%.2f"))
    {
        pitchSnap = juce::jlimit(0.0f, 24.0f, pitchSnap);
        if (sampleProcessor) sampleProcessor->setSmoothingSnapThresholds(timeSnap, pitchSnap);
    }
    if (ImGui::Checkbox("Reset On Snap", &resetOnSnap))
    {
        if (sampleProcessor) sampleProcessor->setSmoothingResetPolicy(resetOnSnap, resetNoSmooth);
    }
    if (ImGui::Checkbox("Reset When No Smoothing", &resetNoSmooth))
    {
        if (sampleProcessor) sampleProcessor->setSmoothingResetPolicy(resetOnSnap, resetNoSmooth);
    }
    ImGui::PopItemWidth();
    
    // Debug output toggle
    static bool debugEnabled = false;
    if (ImGui::Checkbox("Debug Output", &debugEnabled))
    {
        setDebugOutput(debugEnabled);
    }
    
    // Log current settings button
    if (ImGui::Button("Log Settings"))
    {
        logCurrentSettings();
    }
}

void SampleLoaderModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // Audio output
    helpers.drawAudioOutputPin("Audio Output", 0);
}
#endif


================================================================================
FILE: juce\Source\audio\modules\SampleLoaderModuleProcessor.h
================================================================================


#pragma once

#include "../graph/ModularSynthProcessor.h"
#include "../assets/SampleBank.h"
#include "../voices/SampleVoiceProcessor.h"
#include "../dsp/TimePitchProcessor.h"

class SampleLoaderModuleProcessor : public ModuleProcessor
{
public:
    SampleLoaderModuleProcessor();
    ~SampleLoaderModuleProcessor() override = default;

    const juce::String getName() const override { return "Sample Loader"; }

    // --- Audio Processing ---
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages) override;
    void reset() override;
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

    // --- Required by ModuleProcessor ---
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // --- Sample Loading ---
    void loadSample(const juce::File& file);
    void loadSample(const juce::String& filePath);
    juce::String getCurrentSampleName() const;
    bool hasSampleLoaded() const;

    // (Removed SoundTouch controls; using Rubber Band via TimePitchProcessor)
    
    // --- Debug and Monitoring ---
    void setDebugOutput(bool enabled);
    void logCurrentSettings() const;

    // --- Parameter Layout ---
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    // --- APVTS ---
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* engineParam { nullptr }; // 0: rubberband, 1: naive
    
    // --- Sample Management ---
    std::shared_ptr<SampleBank::Sample> currentSample;
    std::unique_ptr<SampleVoiceProcessor> sampleProcessor;
    std::atomic<SampleVoiceProcessor*> newSampleProcessor { nullptr };
    juce::CriticalSection processorSwapLock;
    std::unique_ptr<SampleVoiceProcessor> processorToDelete;
    juce::String currentSampleName;
    juce::String currentSamplePath;
    
#if defined(PRESET_CREATOR_UI)
    // Keep a persistent chooser so async callback remains valid
    std::unique_ptr<juce::FileChooser> fileChooser;
#endif
    
    // Rubber Band is configured in TimePitchProcessor; keep no per-node ST params
    
    // --- Debug ---
    bool debugOutput { false };
    
    // --- Parameter References ---
    // Parameters are accessed directly via apvts.getRawParameterValue()
    
    // --- Internal Methods ---
    void updateSoundTouchSettings();
    void createSampleProcessor();
};


================================================================================
FILE: juce\Source\audio\modules\SAndHModuleProcessor.cpp
================================================================================


#include "SAndHModuleProcessor.h"

SAndHModuleProcessor::SAndHModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("Input", juce::AudioChannelSet::discreteChannels(4), true) // 0-1=signal, 2-3=trigger
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "SAndHParams", createParameterLayout())
{
    thresholdParam = apvts.getRawParameterValue ("threshold");
    slewMsParam = apvts.getRawParameterValue ("slewMs");
    edgeParam = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter ("edge"));
    thresholdModParam = apvts.getRawParameterValue ("threshold_mod");
    slewMsModParam = apvts.getRawParameterValue ("slewMs_mod");
    edgeModParam = apvts.getRawParameterValue ("edge_mod");
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

juce::AudioProcessorValueTreeState::ParameterLayout SAndHModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("threshold", "Threshold", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    params.push_back (std::make_unique<juce::AudioParameterChoice> ("edge", "Edge", juce::StringArray { "Rising", "Falling", "Both" }, 0));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("slewMs", "Slew (ms)", juce::NormalisableRange<float> (0.0f, 2000.0f, 0.01f, 0.35f), 0.0f));
    
    // Add modulation parameters
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("threshold_mod", "Threshold Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("slewMs_mod", "Slew Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("edge_mod", "Edge Mod", 0.0f, 1.0f, 0.0f));
    return { params.begin(), params.end() };
}

void SAndHModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sr = sampleRate;
    lastTrigL = lastTrigR = 0.0f;
    heldL = heldR = 0.0f;
    outL = outR = 0.0f;
}

void SAndHModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    // Single input bus with 4 channels: 0-1 signal, 2-3 trigger
    auto in  = getBusBuffer (buffer, true, 0);
    auto out = getBusBuffer (buffer, false, 0);

    const int numSamples = buffer.getNumSamples();
    
    // --- CORRECTED POINTER LOGIC ---
    const float* sigL = in.getReadPointer(0);
    // If input is mono, sigR should be the same as sigL.
    const float* sigR = in.getNumChannels() > 1 ? in.getReadPointer(1) : sigL;
    
    const float* trgL = in.getNumChannels() > 2 ? in.getReadPointer(2) : sigL;
    // If trigger input is mono, trgR should be the same as trgL, NOT sigR.
    const float* trgR = in.getNumChannels() > 3 ? in.getReadPointer(3) : trgL;
    // --- END OF CORRECTION ---
    float* outLw = out.getWritePointer (0);
    float* outRw = out.getNumChannels() > 1 ? out.getWritePointer (1) : out.getWritePointer (0);

    float threshMod = thresholdModParam != nullptr ? thresholdModParam->load() : 0.0f;
    const float thr = juce::jlimit(0.0f, 1.0f, thresholdParam->load() + (threshMod - 0.5f)); // Modulate by +/- 0.5

    float slewMod = slewMsModParam != nullptr ? slewMsModParam->load() : 0.0f;
    const float slewMs = juce::jlimit(0.0f, 2000.0f, slewMsParam->load() + (slewMod - 0.5f) * 1000.0f); // Modulate by +/- 500ms

    float edgeMod = edgeModParam != nullptr ? edgeModParam->load() : 0.0f;
    int numEdgeChoices = 3;
    int edgeModChoice = static_cast<int>(std::floor(edgeMod * numEdgeChoices));
    const int edge = (edgeParam != nullptr ? edgeParam->getIndex() + edgeModChoice : edgeModChoice) % numEdgeChoices;
    const float slewCoeff = (slewMs <= 0.0f) ? 1.0f : (float) (1.0 - std::exp(-1.0 / (0.001 * slewMs * sr)));

    for (int i = 0; i < numSamples; ++i)
    {
        const float tL = trgL[i];
        const float tR = trgR[i];
        const bool riseL = (tL > thr && lastTrigL <= thr);
        const bool fallL = (tL < thr && lastTrigL >= thr);
        const bool riseR = (tR > thr && lastTrigR <= thr);
        const bool fallR = (tR < thr && lastTrigR >= thr);

        const bool doL = (edge == 0 && riseL) || (edge == 1 && fallL) || (edge == 2 && (riseL || fallL));
        const bool doR = (edge == 0 && riseR) || (edge == 1 && fallR) || (edge == 2 && (riseR || fallR));

        if (doL) heldL = sigL[i];
        if (doR) heldR = sigR[i];
        lastTrigL = tL; lastTrigR = tR;
        // Slew limiting toward target
        outL = outL + slewCoeff * (heldL - outL);
        outR = outR + slewCoeff * (heldR - outR);
        outLw[i] = outL;
        outRw[i] = outR;
    }
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(outLw[numSamples - 1]);
        if (lastOutputValues[1]) lastOutputValues[1]->store(outRw[numSamples - 1]);
    }
}




================================================================================
FILE: juce\Source\audio\modules\SAndHModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class SAndHModuleProcessor : public ModuleProcessor
{
public:
    SAndHModuleProcessor();
    ~SAndHModuleProcessor() override = default;

    const juce::String getName() const override { return "S&H"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float thr=0.5f, slew=0.0f; int edge=0;
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("threshold"))) thr = *p;
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("edge"))) edge = p->getIndex();
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("slewMs"))) slew = *p;
        
        ImGui::PushItemWidth (itemWidth);

        // Threshold
        bool isThreshModulated = isParamModulated("threshold_mod");
        if (isThreshModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Threshold", &thr, 0.0f, 1.0f)) if (!isThreshModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("threshold"))) *p = thr;
        if (!isThreshModulated) adjustParamOnWheel (ap.getParameter ("threshold"), "threshold", thr);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isThreshModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Edge
        bool isEdgeModulated = isParamModulated("edge_mod");
        if (isEdgeModulated) ImGui::BeginDisabled();
        const char* items = "Rising\0Falling\0Both\0\0";
        if (ImGui::Combo ("Edge", &edge, items)) if (!isEdgeModulated) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("edge"))) *p = edge;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isEdgeModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Slew
        bool isSlewModulated = isParamModulated("slewMs_mod");
        if (isSlewModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Slew (ms)", &slew, 0.0f, 2000.0f)) if (!isSlewModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("slewMs"))) *p = slew;
        if (!isSlewModulated) adjustParamOnWheel (ap.getParameter ("slewMs"), "slewMs", slew);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isSlewModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        // Two stereo input pairs: signal (0,1) and trig (2,3)
        helpers.drawAudioInputPin("Signal In L", 0);
        helpers.drawAudioInputPin("Signal In R", 1);
        helpers.drawAudioInputPin("Trig In L", 2);
        helpers.drawAudioInputPin("Trig In R", 3);
        helpers.drawModulationInputPin("Threshold", "threshold");
        helpers.drawModulationInputPin("Slew", "slewMs");
        helpers.drawModulationInputPin("Threshold Mod", "threshold_mod");
        helpers.drawModulationInputPin("Slew Mod", "slewMs_mod");
        helpers.drawModulationInputPin("Edge Mod", "edge_mod");
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;

    // State
    float lastTrigL { 0.0f };
    float lastTrigR { 0.0f };
    float heldL { 0.0f };
    float heldR { 0.0f };
    float outL  { 0.0f };
    float outR  { 0.0f };
    double sr { 44100.0 };

    // Parameters
    std::atomic<float>* thresholdParam { nullptr }; // 0..1
    juce::AudioParameterChoice* edgeParam { nullptr }; // 0 rising, 1 falling, 2 both
    std::atomic<float>* slewMsParam { nullptr }; // 0..2000 ms
    std::atomic<float>* thresholdModParam { nullptr };
    std::atomic<float>* slewMsModParam { nullptr };
    std::atomic<float>* edgeModParam { nullptr };
};




================================================================================
FILE: juce\Source\audio\modules\ScopeModuleProcessor.cpp
================================================================================


#include "ScopeModuleProcessor.h"

ScopeModuleProcessor::ScopeModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("Input", juce::AudioChannelSet::stereo(), true)
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "ScopeParams", createParameterLayout())
{
}

juce::AudioProcessorValueTreeState::ParameterLayout ScopeModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    return { params.begin(), params.end() };
}

void ScopeModuleProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (sampleRate);
    scopeBuffer.setSize (1, 512);
    scopeBuffer.clear();
    writePos = 0;
}

void ScopeModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    // Pass-through
    auto in  = getBusBuffer (buffer, true, 0);
    auto out = getBusBuffer (buffer, false, 0);
    for (int ch = 0; ch < out.getNumChannels(); ++ch)
        out.copyFrom (ch, 0, in, juce::jmin(ch, in.getNumChannels()-1), 0, buffer.getNumSamples());

    // Copy first channel into scope buffer
    const float* src = in.getReadPointer (0);
    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        scopeBuffer.setSample (0, writePos, src[i]);
        writePos = (writePos + 1) % scopeBuffer.getNumSamples();
    }
}

#if defined(PRESET_CREATOR_UI)
void ScopeModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    juce::ignoreUnused (itemWidth, isParamModulated, onModificationEnded);
    // Draw waveform using ImGui draw list
    auto* dl = ImGui::GetWindowDrawList();
    const ImVec2 origin = ImGui::GetCursorScreenPos();
    const float width = 240.0f; const float height = 80.0f;
    const ImU32 bg = IM_COL32(30,30,30,255);
    const ImU32 fg = IM_COL32(100,200,255,255);
    const ImVec2 rectMax = ImVec2(origin.x + width, origin.y + height);
    dl->AddRectFilled (origin, rectMax, bg, 4.0f);
    ImGui::PushClipRect(origin, rectMax, true);
    const int N = scopeBuffer.getNumSamples();
    const float midY = origin.y + height * 0.5f;
    const float scaleY = height * 0.45f;
    const float stepX = width / (float) (N - 1);
    int idx = writePos; // newest
    float prevX = origin.x, prevY = midY;
    for (int i = 0; i < N; ++i)
    {
        idx = (idx + 1) % N;
        float s = scopeBuffer.getSample (0, idx);
        if (s < -1.5f) s = -1.5f; else if (s > 1.5f) s = 1.5f; // guard against runaway values
        const float x = origin.x + i * stepX;
        const float y = midY - s * scaleY;
        if (i > 0) dl->AddLine (ImVec2(prevX, prevY), ImVec2(x, y), fg, 1.5f);
        prevX = x; prevY = y;
    }
    ImGui::PopClipRect();
    ImGui::Dummy (ImVec2 (width, height));
}
#endif




================================================================================
FILE: juce\Source\audio\modules\ScopeModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class ScopeModuleProcessor : public ModuleProcessor
{
public:
    ScopeModuleProcessor();
    ~ScopeModuleProcessor() override = default;

    const juce::String getName() const override { return "Scope"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("In L", 0);
        helpers.drawAudioInputPin("In R", 1);
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

    const juce::AudioBuffer<float>& getScopeBuffer() const { return scopeBuffer; }

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;

    juce::AudioBuffer<float> scopeBuffer; // mono buffer for display
    int writePos { 0 };
};




================================================================================
FILE: juce\Source\audio\modules\SequentialSwitchModuleProcessor.cpp
================================================================================


#include "SequentialSwitchModuleProcessor.h"

SequentialSwitchModuleProcessor::SequentialSwitchModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("In", juce::AudioChannelSet::discreteChannels(2), true) // Ch0: Signal, Ch1: Trigger
                        .withOutput("Out", juce::AudioChannelSet::discreteChannels(4), true)),
      apvts(*this, nullptr, "SeqSwitchParams", createParameterLayout())
{
    numStepsParam = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numSteps"));
    resetParam = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("reset"));
    
    // ADD THIS BLOCK:
    for (int i = 0; i < 4; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout SequentialSwitchModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterInt>("numSteps", "Steps", 1, 4, 4));
    p.push_back(std::make_unique<juce::AudioParameterBool>("reset", "Reset", false));
    return { p.begin(), p.end() };
}

void SequentialSwitchModuleProcessor::prepareToPlay(double, int)
{
    currentIndex = 0;
    lastTriggerState = false;
    lastResetState = false;
}

void SequentialSwitchModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    out.clear();

    const float* signalIn = in.getReadPointer(0);
    const float* triggerIn = in.getReadPointer(1);

    const int numSteps = numStepsParam->get();
    const bool manualReset = resetParam->get();

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        // Check for rising edge on trigger
        bool triggerHigh = triggerIn[i] > 0.5f;
        if (triggerHigh && !lastTriggerState)
        {
            currentIndex = (currentIndex + 1) % numSteps;
        }
        lastTriggerState = triggerHigh;

        // Check for manual reset button press
        if (manualReset && !lastResetState)
        {
            currentIndex = 0;
        }
        lastResetState = manualReset;

        // Route signal to the active output channel
        if (currentIndex < out.getNumChannels())
        {
            out.setSample(currentIndex, i, signalIn[i]);
        }
    }
    
    // ADD THIS BLOCK:
    if (lastOutputValues.size() >= 4)
    {
        for (int i = 0; i < 4; ++i)
            if (lastOutputValues[i])
                lastOutputValues[i]->store(out.getSample(i, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void SequentialSwitchModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    juce::ignoreUnused(isParamModulated);
    
    auto& ap = getAPVTS();
    int steps = 4; if (auto* p = dynamic_cast<juce::AudioParameterInt*>(ap.getParameter("numSteps"))) steps = *p;
    
    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderInt("Steps", &steps, 1, 4))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(ap.getParameter("numSteps"))) *p = steps;
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

    if (ImGui::Button("Reset"))
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("reset"))) *p = true;
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    
    // Reset is momentary, so set it back to false
    if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("reset")))
        if (p->get()) *p = false;
    
    ImGui::Text("Active Output: %d", currentIndex + 1);
    ImGui::PopItemWidth();
}

void SequentialSwitchModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Signal In", 0);
    helpers.drawAudioInputPin("Trigger In", 1);
    helpers.drawAudioOutputPin("Out 1", 0);
    helpers.drawAudioOutputPin("Out 2", 1);
    helpers.drawAudioOutputPin("Out 3", 2);
    helpers.drawAudioOutputPin("Out 4", 3);
}
#endif


================================================================================
FILE: juce\Source\audio\modules\SequentialSwitchModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class SequentialSwitchModuleProcessor : public ModuleProcessor
{
public:
    SequentialSwitchModuleProcessor();
    ~SequentialSwitchModuleProcessor() override = default;

    const juce::String getName() const override { return "Sequential Switch"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioParameterInt* numStepsParam { nullptr };
    juce::AudioParameterBool* resetParam { nullptr };

    int currentIndex { 0 };
    bool lastTriggerState { false };
    bool lastResetState { false };
};


================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.cpp
================================================================================


#include "StepSequencerModuleProcessor.h"
#include <iostream>
#include <array>

using APVTS = juce::AudioProcessorValueTreeState;

static juce::NormalisableRange<float> makeRateRange()
{
    // FIX: Change the interval from 0.0f to a small, non-zero value like 0.01f.
    juce::NormalisableRange<float> r (0.1f, 20.0f, 0.01f, 0.5f); // semi-log response
    return r;
}

APVTS::ParameterLayout StepSequencerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps", "Number of Steps", 1, StepSequencerModuleProcessor::MAX_STEPS, 8));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate", "Rate", makeRateRange(), 2.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength", "Gate Length", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    
    // Add modulation parameters for rate, gate length and number of steps (absolute 0..1)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate_mod", "Rate Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength_mod", "Gate Length Mod", 0.0f, 1.0f, 0.0f));
    // Neutral default at 0.5 means "no override" (we'll treat values ~0.5 as disconnected)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("numSteps_mod", "Num Steps Mod", 0.0f, 1.0f, 0.5f));
    // Optional maximum steps bound (1..MAX_STEPS), default MAX_STEPS
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps_max", "Num Steps Max", 1, StepSequencerModuleProcessor::MAX_STEPS, StepSequencerModuleProcessor::MAX_STEPS));
    for (int i = 0; i < StepSequencerModuleProcessor::MAX_STEPS; ++i)
    {
        const juce::String pid = "step" + juce::String (i + 1);
        params.push_back (std::make_unique<juce::AudioParameterFloat> (pid, pid, juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));

        // ADD THIS: A new parameter for this step's modulation input
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        // Default 0.5 => no offset (unipolar 0..1 centered to bipolar -0.5..+0.5)
        params.push_back(std::make_unique<juce::AudioParameterFloat>(modPid, modPid, 0.0f, 1.0f, 0.5f));
    }
    return { params.begin(), params.end() };
}

StepSequencerModuleProcessor::StepSequencerModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("Mod In", juce::AudioChannelSet::stereo(), true)
                        .withOutput ("CV Outputs", juce::AudioChannelSet::quadraphonic(), true))
    , apvts (*this, nullptr, "SeqParams", createParameterLayout())
{
    // ADD THIS VERIFICATION LOGIC
    std::cout << "--- StepSequencerModuleProcessor Initializing ---" << std::endl;
    
    numStepsParam   = apvts.getRawParameterValue ("numSteps");
    rateParam       = apvts.getRawParameterValue ("rate");
    gateLengthParam = apvts.getRawParameterValue ("gateLength");
    rateModParam    = apvts.getRawParameterValue ("rate_mod");
    gateLengthModParam = apvts.getRawParameterValue ("gateLength_mod");
    numStepsModParam = apvts.getRawParameterValue ("numSteps_mod");
    stepsModMaxParam = apvts.getRawParameterValue ("numSteps_max");
    
    if (numStepsParam == nullptr) std::cout << "ERROR: 'numSteps' parameter is NULL!" << std::endl;
    if (rateParam == nullptr) std::cout << "ERROR: 'rate' parameter is NULL!" << std::endl;
    if (gateLengthParam == nullptr) std::cout << "ERROR: 'gateLength' parameter is NULL!" << std::endl;

    pitchParams.resize (MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        pitchParams[i] = apvts.getRawParameterValue ("step" + juce::String (i + 1));
        if (pitchParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "' parameter is NULL!" << std::endl;
        }
    }

    // Initialize stepModParams
    stepModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        stepModParams[i] = apvts.getRawParameterValue(modPid);
        if (stepModParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "_mod' parameter is NULL!" << std::endl;
        }
    }
    std::cout << "--- Initialization Check Complete ---" << std::endl;
    
    // Initialize output value tracking for tooltips (4 outputs: Pitch, Gate, Velocity, Mod)
    for (int i = 0; i < 4; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

void StepSequencerModuleProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sampleRate = newSampleRate > 0.0 ? newSampleRate : 44100.0;
    phase = 0.0;
}

void StepSequencerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    if (rateParam == nullptr || numStepsParam == nullptr || gateLengthParam == nullptr)
    {
        buffer.clear();
        return;
    }

    const int numSamples = buffer.getNumSamples();
    
    // Get write pointers for all 4 output channels
    auto* pitchOut    = buffer.getWritePointer(0);
    auto* gateOut     = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : nullptr;
    auto* velocityOut = buffer.getNumChannels() > 2 ? buffer.getWritePointer(2) : nullptr;
    auto* modOut      = buffer.getNumChannels() > 3 ? buffer.getWritePointer(3) : nullptr;
    
    // The old, commented-out input logic can now be completely removed.
    
    // Determine active steps (UI and processing) — mod input overrides base if present
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMax = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    if (numStepsModParam != nullptr)
    {
        const float sNorm = numStepsModParam->load(); // 0..1
        if (sNorm > 0.0001f)
        {
            const int mapped = 1 + (int) std::round (sNorm * (MAX_STEPS - 1));
            activeSteps = juce::jlimit (1, MAX_STEPS, mapped);
        }
    }
    
    // Apply modulation to rate
    // Mod input is normalized 0..1 representing the absolute target in [0.01, 50] Hz
    const float baseRate = rateParam->load();
    const float rateModNorm = rateModParam != nullptr ? rateModParam->load() : 0.0f; // 0..1
    const float modRateHz   = 0.01f + rateModNorm * (50.0f - 0.01f);
    // If no modulation connected (stays at 0), use baseRate; else use absolute modulated rate
    const float rate = (rateModNorm <= 0.0001f) ? baseRate : modRateHz;
    
    // Apply modulation to gate length - use neutral value 0.5 for "no modulation"
    const float baseGate = gateLengthParam != nullptr ? gateLengthParam->load() : 0.5f;
    const float gateLenMod = gateLengthModParam != nullptr ? gateLengthModParam->load() : 0.5f; // 0..1, 0.5 = neutral
    const float gateLen = (std::abs(gateLenMod - 0.5f) > 0.0001f) ? juce::jlimit (0.0f, 1.0f, gateLenMod)
                                                                  : baseGate;
    const double phaseInc = (sampleRate > 0.0 ? (double) rate / sampleRate : 0.0);

    for (int i = 0; i < numSamples; ++i)
    {
        phase += phaseInc;
        if (phase >= 1.0)
        {
            phase -= 1.0;
            currentStep.store((currentStep.load() + 1) % juce::jlimit (1, MAX_STEPS, activeSteps));
        }

        const int currentStepIndex = currentStep.load();
        const float sliderValue = pitchParams[currentStepIndex] != nullptr ? pitchParams[currentStepIndex]->load() : 0.0f;
        
        // Read modulation from the dedicated parameter and center it around 0.0
        float rawModValue = 0.0f;
        if (stepModParams[currentStepIndex] != nullptr)
        {
            rawModValue = stepModParams[currentStepIndex]->load();
        }
        // Center modulation around 0.0 (convert unipolar 0-1 to bipolar -0.5 to +0.5)
        const float modValue = rawModValue - 0.5f;

        const float pitchValue = juce::jlimit (0.0f, 1.0f, sliderValue + modValue);
        const float gateValue  = (phase < gateLen) ? 1.0f : 0.0f;

        pitchOut[i] = pitchValue;
        if (gateOut != nullptr)     gateOut[i] = gateValue;
        if (velocityOut != nullptr) velocityOut[i] = 0.85f;
        if (modOut != nullptr)      modOut[i] = 0.0f;
    }
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 4)
    {
        if (lastOutputValues[0] && pitchOut) lastOutputValues[0]->store(pitchOut[numSamples - 1]);
        if (lastOutputValues[1] && gateOut) lastOutputValues[1]->store(gateOut[numSamples - 1]);
        if (lastOutputValues[2] && velocityOut) lastOutputValues[2]->store(velocityOut[numSamples - 1]);
        if (lastOutputValues[3] && modOut) lastOutputValues[3]->store(modOut[numSamples - 1]);
    }
}

#if defined(PRESET_CREATOR_UI)
void StepSequencerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMaxUi = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const bool stepsAreModulated = isParamModulated("numSteps_mod");
    if (stepsAreModulated) {
        const float sNorm = numStepsModParam->load();
        const int mapped = 1 + (int) std::round (sNorm * (boundMaxUi - 1));
        activeSteps = juce::jlimit (1, boundMaxUi, mapped);
    }

    // Step count controls - now using a slider instead of +/- buttons
    int currentSteps = numStepsParam != nullptr ? (int)numStepsParam->load() : 8;

    // If modulated, the displayed value comes from the modulation input.
    // Otherwise, it comes from the parameter itself.
    int displayedSteps = currentSteps;
    if (stepsAreModulated) {
        const float sNorm = numStepsModParam->load();
        const int mapped = 1 + (int) std::round (sNorm * (boundMaxUi - 1));
        displayedSteps = juce::jlimit (1, boundMaxUi, mapped);
    }

    // Ensure the displayed value never exceeds the max bound
    displayedSteps = juce::jmin(displayedSteps, boundMaxUi);

    // Disable the slider if steps are being modulated
    if (stepsAreModulated) ImGui::BeginDisabled();

    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderInt("Steps", &displayedSteps, 1, boundMaxUi))
    {
        // Only update the parameter if the slider is not disabled
        if (!stepsAreModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numSteps"))) {
                *p = displayedSteps;
            }
        }
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    
    // Add scroll wheel support for the Steps slider
    if (!stepsAreModulated)
    {
        adjustParamOnWheel(apvts.getParameter("numSteps"), "numSteps", (float)displayedSteps);
    }
    
    ImGui::PopItemWidth();

    if (stepsAreModulated) {
        ImGui::EndDisabled();
        ImGui::SameLine(); 
        ImGui::TextUnformatted("(mod)");
    }

    // Use the displayed steps value for the slider strip
    const int shown = juce::jlimit (1, MAX_STEPS, displayedSteps);
    const float sliderW = itemWidth / (float) juce::jmax (8, shown) * 0.8f;

    ImGui::PushItemWidth (sliderW);
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();

        // Build display and interaction state
        float baseValue = (pitchParams[i] != nullptr ? pitchParams[i]->load() : 0.5f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        const bool modConnected = isParamModulated(modPid);
        
        float finalValue = baseValue;
        if (modConnected && stepModParams.size() > (size_t) i && stepModParams[i] != nullptr) {
            const float rawModValue = stepModParams[i]->load();
            const float modValue = rawModValue - 0.5f;
            finalValue = juce::jlimit (0.0f, 1.0f, baseValue + modValue);
        }

        float sliderValue = finalValue; // widget bound to final value

        const bool isActive = (i == currentStep.load());
        if (isActive)
        {
            ImGui::PushStyleColor (ImGuiCol_FrameBg, ImVec4(0.3f, 0.7f, 1.0f, 1.0f));
            ImGui::PushStyleColor (ImGuiCol_SliderGrab, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
        }

        const std::string label = "##s" + std::to_string(i);
        if (modConnected) ImGui::BeginDisabled();
        if (ImGui::VSliderFloat (label.c_str(), ImVec2 (sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected) {
                // Only update if not modulated
                float newBaseValue = juce::jlimit (0.0f, 1.0f, sliderValue);
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                    *p = newBaseValue;
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit (0.0f, 1.0f, baseValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                        *p = newBaseValue;
                }
            }
        }

        if (modConnected) { ImGui::EndDisabled(); }

        if (isActive) ImGui::PopStyleColor(2);
    }
    ImGui::PopItemWidth();

    // Current step indicator
    ImGui::Text("Current Step: %d", currentStep.load() + 1);

    // Rate and gate length sliders
    const bool isRateModulated = isParamModulated("rate_mod");
    float rateDisplay = isRateModulated ? (0.01f + rateModParam->load() * (50.0f - 0.01f)) : rateParam->load();
    
    ImGui::PushItemWidth (itemWidth);
    if (isRateModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Rate (Hz)", &rateDisplay, 0.01f, 50.0f, "%.2f")) {
        if (!isRateModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("rate"))) *p = rateDisplay;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (!isRateModulated) adjustParamOnWheel (apvts.getParameter ("rate"), "rate", rateDisplay);
    if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    const bool glIsModulated = isParamModulated("gateLength_mod");
    float glEff = glIsModulated ? gateLengthModParam->load() : gateLengthParam->load();

    if (glIsModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Gate", &glEff, 0.0f, 1.0f))
    {
        if (! glIsModulated)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateLength"))) *p = glEff;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (! glIsModulated)
        adjustParamOnWheel (apvts.getParameter ("gateLength"), "gateLength", glEff);
    if (glIsModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::PopItemWidth();
}

void StepSequencerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // Main stereo audio input pins
    helpers.drawAudioInputPin("Mod In L", 0);
    helpers.drawAudioInputPin("Mod In R", 1);
    
    // Global modulation inputs
    helpers.drawModulationInputPin("Rate Mod", "rate_mod");
    helpers.drawModulationInputPin("Gate Mod", "gateLength_mod");
    helpers.drawModulationInputPin("Steps Mod", "numSteps_mod");
    helpers.drawModulationInputPin("Steps Max", "numSteps_max");
    
    // Dynamic step modulation inputs
    const int boundMaxPins = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    if (numStepsModParam != nullptr)
    {
        const float sNorm = numStepsModParam->load();
        // Treat ~0.5 as disconnected neutral
        if (std::abs (sNorm - 0.5f) > 0.0001f)
        {
            const int mapped = 1 + (int) std::round (sNorm * (boundMaxPins - 1));
            activeSteps = juce::jlimit (1, boundMaxPins, mapped);
            const int maxIndex = activeSteps;
            const int cur = currentStep.load();
            if (cur >= maxIndex)
                currentStep.store (cur % maxIndex);
        }
    }
    activeSteps = juce::jlimit (1, boundMaxPins, activeSteps);
    for (int i = 0; i < activeSteps; ++i)
    {
        const juce::String paramId = "step" + juce::String(i + 1) + "_mod";
        helpers.drawModulationInputPin(("Step " + juce::String(i + 1) + " Mod").toRawUTF8(), paramId);
    }
    
    // Output pins
    helpers.drawAudioOutputPin("Pitch", 0);
    helpers.drawAudioOutputPin("Gate", 1);
    helpers.drawAudioOutputPin("Velocity", 2);
    helpers.drawAudioOutputPin("Mod", 3);
}
#endif




================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class StepSequencerModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_STEPS = 16;
    StepSequencerModuleProcessor();
    ~StepSequencerModuleProcessor() override = default;

    const juce::String getName() const override { return "Sequencer"; }

    void prepareToPlay (double newSampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;

    std::atomic<int> currentStep { 0 };
    double phase { 0.0 };
    double sampleRate { 44100.0 };

    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* gateLengthParam { nullptr };
    std::atomic<float>* rateModParam { nullptr };
    std::atomic<float>* gateLengthModParam { nullptr };
    std::atomic<float>* numStepsModParam { nullptr };
    std::atomic<float>* stepsModMaxParam { nullptr };
    std::vector<std::atomic<float>*> pitchParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepModParams; // size MAX_STEPS
    std::atomic<float>* numStepsParam { nullptr };
};




================================================================================
FILE: juce\Source\audio\modules\TTSModuleProcessor.cpp
================================================================================


#include "TTSModuleProcessor.h"
#include "../../../vendor/MeloTTS.cpp/src/tts.h"
#include <openvino/openvino.hpp>
#include <filesystem>
#include <iostream> // Added for std::cout
#include "juce_core/juce_core.h" // Add for MemoryBlock and Base64

#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/ImGuiNodeEditorComponent.h"
#endif

// ==============================================================================
// SYNTHESIS THREAD (runs in background)
// ==============================================================================
TTSModuleProcessor::SynthesisThread::SynthesisThread(TTSModuleProcessor& o)
    : juce::Thread("TTS Synthesis Thread"), owner(o)
{}

TTSModuleProcessor::SynthesisThread::~SynthesisThread()
{
    stopThread(5000);
}

void TTSModuleProcessor::SynthesisThread::run()
{
    while (!threadShouldExit())
    {
        if (owner.shouldStartSynthesis.load())
        {
            owner.shouldStartSynthesis = false;
            owner.currentStatus = Status::Synthesizing; // Set status

            // Get the language selected in the UI
            juce::String desiredLanguage = owner.languageParam->getCurrentChoiceName();

            // --- Dynamic Model Loading ---
            // If the engine isn't created yet, or the language has changed, load the correct models.
            if (ttsEngine == nullptr || currentLanguage != desiredLanguage)
            {
                try
                {
                    // Try multiple possible paths to find the MeloTTS.cpp directory
                    juce::File modelsDir;
                    bool found = false;
                    
                    // Path 1: Relative to current executable
                    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
                    auto meloCppDir1 = appFile.getParentDirectory().getChildFile("../../vendor/MeloTTS.cpp");
                    auto modelsDir1 = meloCppDir1.getChildFile("ov_models");
                    
                    DBG("[TTS] Trying path 1: " + modelsDir1.getFullPathName());
                    DBG("[TTS] Path 1 exists: " + juce::String(modelsDir1.exists()));
                    
                    if (modelsDir1.exists())
                    {
                        modelsDir = modelsDir1;
                        found = true;
                    }
                    else
                    {
                        // Path 2: Alternative relative path
                        auto meloCppDir2 = appFile.getParentDirectory().getChildFile("../../../vendor/MeloTTS.cpp");
                        auto modelsDir2 = meloCppDir2.getChildFile("ov_models");
                        
                        DBG("[TTS] Trying path 2: " + modelsDir2.getFullPathName());
                        DBG("[TTS] Path 2 exists: " + juce::String(modelsDir2.exists()));
                        
                        if (modelsDir2.exists())
                        {
                            modelsDir = modelsDir2;
                            found = true;
                        }
                        else
                        {
                            // Path 3: Absolute path fallback
                            auto absolutePath = juce::File("H:/0000_CODE/01_collider_pyo/vendor/MeloTTS.cpp/ov_models");
                            DBG("[TTS] Trying absolute path: " + absolutePath.getFullPathName());
                            DBG("[TTS] Absolute path exists: " + juce::String(absolutePath.exists()));
                            
                            if (absolutePath.exists())
                            {
                                modelsDir = absolutePath;
                                found = true;
                            }
                        }
                    }
                    
                    if (!found)
                    {
                        throw std::runtime_error("Could not find MeloTTS.cpp models directory in any expected location");
                    }
                    
                    DBG("[TTS] Using models directory: " + modelsDir.getFullPathName());

                    juce::File ttsModelPath, bertPath;
                    if (desiredLanguage == "English")
                    {
                        ttsModelPath = modelsDir.getChildFile("tts_en_int8.xml");
                        bertPath = modelsDir.getChildFile("bert_EN_int8.xml");
                    }
                    else if (desiredLanguage == "Chinese")
                    {
                        ttsModelPath = modelsDir.getChildFile("tts_zn_mix_en_int8.xml");
                        bertPath = modelsDir.getChildFile("bert_ZH_int8.xml");
                    }
                    
                    auto vocabPath = modelsDir.getChildFile("vocab.txt");
                    
                    DBG("[TTS] TTS model exists: " + juce::String(ttsModelPath.exists()) + " at " + ttsModelPath.getFullPathName());
                    DBG("[TTS] BERT model exists: " + juce::String(bertPath.exists()) + " at " + bertPath.getFullPathName());
                    DBG("[TTS] Vocab exists: " + juce::String(vocabPath.exists()) + " at " + vocabPath.getFullPathName());

                    if (ttsModelPath.exists() && bertPath.exists() && vocabPath.exists())
                    {
                        // Create OpenVINO Core
                        auto core = std::make_unique<ov::Core>();
                        
                        // Use the correct constructor with model directory and language
                        std::string languageCode = (desiredLanguage == "English") ? "EN" : "ZH";
                        ttsEngine = std::make_unique<melo::TTS>(
                            core,
                            std::filesystem::path(modelsDir.getFullPathName().toStdString()),
                            languageCode
                        );
                        currentLanguage = desiredLanguage;
                        DBG("[TTS] Loaded " + desiredLanguage + " models successfully.");
                    }
                    else { throw std::runtime_error("Required model files not found for " + desiredLanguage.toStdString()); }
            }
                catch (const std::exception& e)
                {
                    const juce::ScopedLock lock(owner.messageLock);
                    owner.errorMessage = e.what();
                    owner.currentStatus = Status::Error;
                    ttsEngine.reset();
                }
            }
            
            if (ttsEngine != nullptr)
            {
                try
                {
                    if (!owner.textToSynthesize.isEmpty())
                    {
                        std::vector<float> audioData;
                        
                        // CRITICAL FIX: Use .toUTF8() for correct encoding
                        const std::string textToSpeakUTF8 = owner.textToSynthesize.toUTF8().getAddress();
                        ttsEngine->tts_to_file(textToSpeakUTF8, audioData, 0);

                        int numSamples = (int)audioData.size();
                        if (numSamples > 0 && owner.abstractFifo.getFreeSpace() >= numSamples)
                        {
                            owner.isPlaying = true;
                            owner.currentStatus = Status::Playing;
                            auto write = owner.abstractFifo.write(numSamples);
                            owner.fifoBuffer.copyFrom(0, write.startIndex1, audioData.data(), write.blockSize1);
                            if (write.blockSize2 > 0)
                                owner.fifoBuffer.copyFrom(0, write.startIndex2, audioData.data() + write.blockSize1, write.blockSize2);
                        }
                        else { owner.currentStatus = Status::Idle; }
                    }
                    else { owner.currentStatus = Status::Idle; }
                }
                catch(const std::exception& e)
                {
                    const juce::ScopedLock lock(owner.messageLock);
                    owner.errorMessage = e.what();
                    owner.currentStatus = Status::Error;
                }
            }
        }
        
        wait(20); // Wait for the next request
    }
}

// ==============================================================================
// MAIN PROCESSOR (runs on message and audio threads)
// ==============================================================================
TTSModuleProcessor::TTSModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withInput("Gate In", juce::AudioChannelSet::mono(), true) // Add this input
        .withOutput("Audio Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "TTSParams", createParameterLayout()),
      fifoBuffer(1, 48000 * 15), // Mono buffer, 15 seconds at 48kHz
      abstractFifo(48000 * 15),
      synthesisThread(*this)
{
    volumeParam = apvts.getRawParameterValue("volume");
    languageParam = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("language"));
    synthesisThread.startThread();
}

TTSModuleProcessor::~TTSModuleProcessor() {}

void TTSModuleProcessor::prepareToPlay(double, int) {}

void TTSModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    if (cancelRequested.load())
    {
        buffer.clear();
        abstractFifo.reset(); // Clear any pending audio
        isPlaying = false;
        cancelRequested = false;
        return;
    }

    // --- Gate Trigger Logic ---
    auto gateBuffer = getBusBuffer(buffer, true, 0).getReadPointer(0);
    bool gateIsHigh = false;
    for (int i = 0; i < buffer.getNumSamples(); ++i) {
        if (gateBuffer[i] > 0.5f) {
            gateIsHigh = true;
            break;
        }
    }

    bool risingEdge = gateIsHigh && !lastGateState;
    lastGateState = gateIsHigh;

    // Start playing if gate trigger received
    if (risingEdge && !isPlaying.load() && abstractFifo.getNumReady() > 0)
    {
        isPlaying = true;
    }

    // --- Audio Playback Logic ---
    buffer.clear();
    if (!isPlaying.load()) return;

    // --- AUDIO THREAD LOGIC ---
    // This is fast, non-blocking, and real-time safe.
    int numSamplesAvailable = abstractFifo.getNumReady();
    int numSamplesToCopy = std::min(buffer.getNumSamples(), numSamplesAvailable);

    // Debug: Log audio processing every 1000 samples to avoid spam
    static int debugCounter = 0;
    if (++debugCounter % 1000 == 0)
    {
        DBG("[TTS] Audio processing - isPlaying: " + juce::String(isPlaying.load()) + ", FIFO ready: " + juce::String(numSamplesAvailable) + ", copying: " + juce::String(numSamplesToCopy));
    }

    if (numSamplesToCopy > 0)
    {
        auto read = abstractFifo.read(numSamplesToCopy);
        // Copy from our mono FIFO buffer to the stereo output buffer
        juce::AudioBuffer<float> fifoSlice(fifoBuffer.getArrayOfWritePointers(), 1, read.startIndex1, read.blockSize1);
        for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
            buffer.copyFrom(channel, 0, fifoSlice, 0, 0, read.blockSize1);

        if (read.blockSize2 > 0)
        {
            juce::AudioBuffer<float> fifoSlice2(fifoBuffer.getArrayOfWritePointers(), 1, read.startIndex2, read.blockSize2);
            for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
                buffer.copyFrom(channel, read.blockSize1, fifoSlice2, 0, 0, read.blockSize2);
        }
    }

    if (abstractFifo.getNumReady() == 0)
    {
        isPlaying = false; // Finished playing
        DBG("[TTS] Playback finished - no more samples in FIFO");
    }
    
    buffer.applyGain(volumeParam->load());
}

void TTSModuleProcessor::startSynthesis(const juce::String& text)
{
    bool expected = false;
    // This atomic operation ensures only one thread can start a new synthesis job.
    if (shouldStartSynthesis.compare_exchange_strong(expected, true))
    {
        textToSynthesize = text;
        synthesisThread.notify();
    }
}

void TTSModuleProcessor::cancelSynthesis()
{
    cancelRequested = true;
    shouldStartSynthesis = false;
    isPlaying = false;
    // Clear the FIFO buffer
    abstractFifo.reset();
}

juce::AudioProcessorValueTreeState::ParameterLayout TTSModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters;
    
    // Language selection parameter
    parameters.push_back(std::make_unique<juce::AudioParameterChoice>(
        "language", "Language", juce::StringArray { "English", "Chinese" }, 0));

    // Volume parameter (0.0 to 1.0)
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "volume", "Volume", 0.0f, 1.0f, 0.8f));
    
    return { parameters.begin(), parameters.end() };
}

#if defined(PRESET_CREATOR_UI)
void TTSModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    
        // Text input with Unicode support - try InputTextWithHint
        ImGui::PushItemWidth(itemWidth);
        if (ImGui::InputTextMultiline("Text", uiTextBuffer, sizeof(uiTextBuffer), ImVec2(itemWidth, 60), ImGuiInputTextFlags_None))
        {
            // Text input changed - this would trigger synthesis in a real implementation
        }
        ImGui::PopItemWidth();
    
    // Language selection dropdown
    if (languageParam)
    {
        int langIndex = languageParam->getIndex();
        const char* currentLang = languageParam->getCurrentChoiceName().toRawUTF8();
        if (ImGui::BeginCombo("Language", currentLang))
        {
            for (int i = 0; i < languageParam->choices.size(); ++i)
            {
                const bool isSelected = (langIndex == i);
                if (ImGui::Selectable(languageParam->choices[i].toRawUTF8(), isSelected))
                {
                    *languageParam = i; // Update the parameter when a new choice is made
                }
                if (isSelected) ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }
    }
    
    // Volume parameter
    auto* volumeP = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("volume"));
    if (volumeP)
    {
        float volumeValue = *volumeP;
        ImGui::PushItemWidth(itemWidth);
        if (ImGui::SliderFloat("Volume", &volumeValue, 0.0f, 1.0f, "%.2f"))
        {
            *volumeP = volumeValue;
        }
        if (ImGui::IsItemDeactivatedAfterEdit())
        {
            onModificationEnded();
        }
        adjustParamOnWheel(ap.getParameter("volume"), "volume", volumeValue);
        ImGui::PopItemWidth();
    }
    
    // --- Status-Aware Synthesis Button and Indicator ---
    Status status = currentStatus.load();
    bool isBusy = (status == Status::Synthesizing);

    if (isBusy)
    {
        ImGui::BeginDisabled();
    }

        if (ImGui::Button("SPEAK", ImVec2(itemWidth, 0)))
        {
            juce::String textToSpeak = juce::String(uiTextBuffer);
            DBG("[TTS] UI Text buffer content: " + textToSpeak);
            DBG("[TTS] UI Text buffer length: " + juce::String(textToSpeak.length()));
            DBG("[TTS] UI Text buffer bytes: " + juce::String(textToSpeak.toUTF8().sizeInBytes()));
            if (textToSpeak.isNotEmpty())
            {
                startSynthesis(textToSpeak);
            }
        }
        
        // Chinese text preset buttons
        ImGui::Text("Chinese Text Presets:");
        if (ImGui::Button("你好", ImVec2(itemWidth * 0.3f, 0)))
        {
            const char* testText = "你好";
            strncpy_s(uiTextBuffer, sizeof(uiTextBuffer), testText, _TRUNCATE);
            uiTextBuffer[sizeof(uiTextBuffer) - 1] = '\0';
            DBG("[TTS] Set Chinese text: 你好");
        }
        ImGui::SameLine();
        if (ImGui::Button("世界", ImVec2(itemWidth * 0.3f, 0)))
        {
            const char* testText = "世界";
            strncpy_s(uiTextBuffer, sizeof(uiTextBuffer), testText, _TRUNCATE);
            uiTextBuffer[sizeof(uiTextBuffer) - 1] = '\0';
            DBG("[TTS] Set Chinese text: 世界");
        }
        ImGui::SameLine();
        if (ImGui::Button("测试", ImVec2(itemWidth * 0.3f, 0)))
        {
            const char* testText = "测试";
            strncpy_s(uiTextBuffer, sizeof(uiTextBuffer), testText, _TRUNCATE);
            uiTextBuffer[sizeof(uiTextBuffer) - 1] = '\0';
            DBG("[TTS] Set Chinese text: 测试");
        }

    if (isBusy)
    {
        ImGui::EndDisabled();
    }
    
    // Status indicator text
    switch (status)
    {
        case Status::Idle:
            ImGui::Text("Status: Idle");
            break;
        case Status::Synthesizing:
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: Synthesizing...");
            break;
        case Status::Playing:
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: Playing...");
            break;
        case Status::Error:
            {
                const juce::ScopedLock lock(messageLock);
                ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Status: Error");
                ImGui::TextWrapped("Error: %s", errorMessage.toRawUTF8());
            }
            break;
    }
}
#endif

#if defined(PRESET_CREATOR_UI)
void TTSModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Gate In", 0);
    helpers.drawAudioOutputPin("Audio L", 0);
    helpers.drawAudioOutputPin("Audio R", 1);
}
#endif

// ==============================================================================
// PRESET SAVING & LOADING
// ==============================================================================

void TTSModuleProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    // Save the current state of the parameters
    auto state = apvts.copyState();
    
    // Serialize the audio buffer
    if (fifoBuffer.getNumSamples() > 0)
    {
        juce::ValueTree audioState("AudioData");
        
        // We need to know how many valid samples are in the FIFO
        int numValidSamples = abstractFifo.getNumReady();
        if (numValidSamples > 0)
        {
            // Create a temporary MemoryBlock to hold the raw audio
            juce::MemoryBlock audioBlock(numValidSamples * sizeof(float));
            auto read = abstractFifo.read(numValidSamples); // This is a non-destructive peek
            
            // Manually copy from the circular buffer's two potential segments
            memcpy(audioBlock.getData(), fifoBuffer.getReadPointer(0, read.startIndex1), read.blockSize1 * sizeof(float));
            if (read.blockSize2 > 0)
                memcpy(static_cast<char*>(audioBlock.getData()) + read.blockSize1 * sizeof(float), fifoBuffer.getReadPointer(0, read.startIndex2), read.blockSize2 * sizeof(float));

            audioState.setProperty("numSamples", numValidSamples, nullptr);
            audioState.setProperty("data", juce::Base64::toBase64(audioBlock.getData(), audioBlock.getSize()), nullptr);
        }
        state.addChild(audioState, -1, nullptr);
    }

    // Convert the ValueTree to XML and then to a MemoryBlock
    std::unique_ptr<juce::XmlElement> xml(state.createXml());
    copyXmlToBinary(*xml, destData);
}

void TTSModuleProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    // Get the ValueTree from the XML
    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));

    if (xmlState != nullptr)
    {
        if (xmlState->hasTagName(apvts.state.getType()))
        {
            apvts.replaceState(juce::ValueTree::fromXml(*xmlState));

            // Deserialize the audio buffer
            auto audioState = apvts.state.getChildWithName("AudioData");
            if (audioState.isValid())
            {
                int numSamples = audioState.getProperty("numSamples", 0);
                juce::String base64Data = audioState.getProperty("data").toString();
                
                if (numSamples > 0 && base64Data.isNotEmpty())
                {
                    juce::MemoryBlock audioBlock;
                    juce::MemoryOutputStream stream(audioBlock, false);
                    if (juce::Base64::convertFromBase64(stream, base64Data))
                    {
                        // Clear the FIFO and write the loaded audio data into it
                        abstractFifo.reset();
                        auto write = abstractFifo.write(numSamples);
                        fifoBuffer.copyFrom(0, write.startIndex1, static_cast<const float*>(audioBlock.getData()), write.blockSize1);
                        if (write.blockSize2 > 0)
                            fifoBuffer.copyFrom(0, write.startIndex2, static_cast<const float*>(audioBlock.getData()) + write.blockSize1, write.blockSize2);
                    }
                }
            }
        }
    }
}


================================================================================
FILE: juce\Source\audio\modules\TTSModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_core/juce_core.h>

namespace melo { class TTS; }

class TTSModuleProcessor : public ModuleProcessor
{
public:
    TTSModuleProcessor();
    ~TTSModuleProcessor() override;

    const juce::String getName() const override { return "TTS"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // --- Preset Saving & Loading ---
    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;

    // --- Public UI Control Methods ---
    void startSynthesis(const juce::String& text);
    void cancelSynthesis();

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    // --- Worker Thread for Non-Real-Time Synthesis ---
    class SynthesisThread : public juce::Thread
    {
    public:
        SynthesisThread(TTSModuleProcessor& owner);
        ~SynthesisThread() override;
        void run() override; // Main thread loop
    private:
        TTSModuleProcessor& owner;
        std::unique_ptr<melo::TTS> ttsEngine;
        juce::String currentLanguage;
    };

    // --- Real-Time-Safe Communication ---
    juce::AudioBuffer<float> fifoBuffer;
    juce::AbstractFifo abstractFifo;
    juce::String textToSynthesize;
    
        // --- Atomic State Flags for Thread Coordination ---
        std::atomic<bool> shouldStartSynthesis { false };
        std::atomic<bool> isPlaying { false };
        std::atomic<bool> cancelRequested { false };
        
        // --- Gate Input Tracking ---
        bool lastGateState { false };

    // --- Status Tracking ---
    enum class Status { Idle, Synthesizing, Playing, Error };
    std::atomic<Status> currentStatus { Status::Idle };
    juce::CriticalSection messageLock; // To protect the string
    juce::String errorMessage;

    // --- APVTS and Parameters ---
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* volumeParam { nullptr };
    juce::AudioParameterChoice* languageParam { nullptr };

    SynthesisThread synthesisThread;
    
#if defined(PRESET_CREATOR_UI)
    char uiTextBuffer[2048] { "" }; // Increased size for UTF-8 Chinese characters
#endif
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(TTSModuleProcessor);
};


================================================================================
FILE: juce\Source\audio\modules\TTSPerformerModuleProcessor.cpp
================================================================================


#include "TTSPerformerModuleProcessor.h"
#include "../../../vendor/MeloTTS.cpp/src/tts.h"
#include <openvino/openvino.hpp>
#include <filesystem>
#include <iostream>
#include "juce_core/juce_core.h"

#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/ImGuiNodeEditorComponent.h"
#endif

// ==============================================================================
// SYNTHESIS THREAD IMPLEMENTATION
// ==============================================================================

TTSPerformerModuleProcessor::SynthesisThread::SynthesisThread(TTSPerformerModuleProcessor& o) 
    : juce::Thread("TTS Synthesis Thread"), owner(o) {}

TTSPerformerModuleProcessor::SynthesisThread::~SynthesisThread() 
{ 
    stopThread(5000); 
}

void TTSPerformerModuleProcessor::SynthesisThread::run()
{
    std::cout << "[TTS Performer] SynthesisThread started" << std::endl;
    
    while (!threadShouldExit())
    {
        std::cout << "[TTS Performer] SynthesisThread waiting for notification..." << std::endl;
        wait(-1); // Wait indefinitely until notified
        if (threadShouldExit()) 
        {
            std::cout << "[TTS Performer] SynthesisThread exiting due to threadShouldExit" << std::endl;
            break;
        }

        // Safely read the text from the FIFO
        std::cout << "[TTS Performer] SynthesisThread notified, reading text from FIFO..." << std::endl;
        juce::String textToSynthesize;
        {
            std::cout << "[TTS Performer] Acquiring textBufferLock for reading..." << std::endl;
            const juce::ScopedLock lock(owner.textBufferLock);
            std::cout << "[TTS Performer] Lock acquired, reading from FIFO..." << std::endl;
            
            int start1, size1, start2, size2;
            owner.textFifo.prepareToRead(1, start1, size1, start2, size2);
            std::cout << "[TTS Performer] FIFO read prepared - start1: " << start1 << ", size1: " << size1 << std::endl;
            
            if (size1 > 0)
            {
                textToSynthesize = owner.textFifoBuffer[start1];
                std::cout << "[TTS Performer] Text read from FIFO: " << textToSynthesize.toStdString() << std::endl;
            }
            else
            {
                std::cout << "[TTS Performer] No text available in FIFO" << std::endl;
            }
            owner.textFifo.finishedRead(size1);
        }

        if (textToSynthesize.isEmpty()) 
        {
            std::cout << "[TTS Performer] Empty text, continuing..." << std::endl;
            continue;
        }

        std::cout << "[TTS Performer] Setting status to Synthesizing..." << std::endl;
        owner.currentStatus = Status::Synthesizing;

        juce::String desiredLanguage = owner.languageParam->getCurrentChoiceName();
        std::cout << "[TTS Performer] Desired language: " << desiredLanguage.toStdString() << std::endl;
        
        // --- Dynamic Model Loading ---
        std::cout << "[TTS Performer] Checking if model loading needed..." << std::endl;
        std::cout << "[TTS Performer] ttsEngine is null: " << (ttsEngine == nullptr) << std::endl;
        std::cout << "[TTS Performer] currentLanguage: " << currentLanguage.toStdString() << std::endl;
        std::cout << "[TTS Performer] Language changed: " << (currentLanguage != desiredLanguage) << std::endl;
        
        if (ttsEngine == nullptr || currentLanguage != desiredLanguage)
        {
            try
            {
                // Try multiple possible paths to find the MeloTTS.cpp directory
                juce::File modelsDir;
                bool found = false;
                
                // Path 1: Relative to current executable
                auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
                auto meloCppDir1 = appFile.getParentDirectory().getChildFile("../../vendor/MeloTTS.cpp");
                auto modelsDir1 = meloCppDir1.getChildFile("ov_models");
                
                DBG("[TTS Performer] Trying path 1: " + modelsDir1.getFullPathName());
                
                if (modelsDir1.exists())
                {
                    modelsDir = modelsDir1;
                    found = true;
                }
                else
                {
                    // Path 2: Alternative relative path
                    auto meloCppDir2 = appFile.getParentDirectory().getChildFile("../../../vendor/MeloTTS.cpp");
                    auto modelsDir2 = meloCppDir2.getChildFile("ov_models");
                    
                    DBG("[TTS Performer] Trying path 2: " + modelsDir2.getFullPathName());
                    
                    if (modelsDir2.exists())
                    {
                        modelsDir = modelsDir2;
                        found = true;
                    }
                    else
                    {
                        // Path 3: Absolute path fallback
                        auto absolutePath = juce::File("H:/0000_CODE/01_collider_pyo/vendor/MeloTTS.cpp/ov_models");
                        DBG("[TTS Performer] Trying absolute path: " + absolutePath.getFullPathName());
                        
                        if (absolutePath.exists())
                        {
                            modelsDir = absolutePath;
                            found = true;
                        }
                    }
                }
                
                if (!found)
                {
                    throw std::runtime_error("Could not find MeloTTS.cpp models directory in any expected location");
                }
                
                DBG("[TTS Performer] Using models directory: " + modelsDir.getFullPathName());

                juce::File ttsModelPath, bertPath;
                if (desiredLanguage == "English")
                {
                    ttsModelPath = modelsDir.getChildFile("tts_en_int8.xml");
                    bertPath = modelsDir.getChildFile("bert_EN_int8.xml");
                }
                else if (desiredLanguage == "Chinese")
                {
                    ttsModelPath = modelsDir.getChildFile("tts_zn_mix_en_int8.xml");
                    bertPath = modelsDir.getChildFile("bert_ZH_int8.xml");
                }
                
                auto vocabPath = modelsDir.getChildFile("vocab.txt");

                if (ttsModelPath.exists() && bertPath.exists() && vocabPath.exists())
                {
                    // Create OpenVINO Core
                    auto core = std::make_unique<ov::Core>();
                    
                    // Use the correct constructor with model directory and language
                    std::string languageCode = (desiredLanguage == "English") ? "EN" : "ZH";
                    ttsEngine = std::make_unique<melo::TTS>(
                        core,
                        std::filesystem::path(modelsDir.getFullPathName().toStdString()),
                        languageCode
                    );
                    currentLanguage = desiredLanguage;
                    DBG("[TTS Performer] Loaded " + desiredLanguage + " models successfully.");
                }
                else 
                { 
                    throw std::runtime_error("Required model files not found for " + desiredLanguage.toStdString()); 
                }
            }
            catch (const std::exception& e)
            {
                const juce::ScopedLock lock(owner.messageLock);
                owner.errorMessage = e.what();
                owner.currentStatus = Status::Error;
                ttsEngine.reset();
            }
        }
        
        // --- Synthesis ---
        std::cout << "[TTS Performer] Starting synthesis section..." << std::endl;
        std::cout << "[TTS Performer] ttsEngine != nullptr: " << (ttsEngine != nullptr) << std::endl;
        std::cout << "[TTS Performer] textToSynthesize.isEmpty(): " << textToSynthesize.isEmpty() << std::endl;
        
        if (ttsEngine != nullptr && !textToSynthesize.isEmpty())
        {
            try
            {
                std::cout << "[TTS Performer] Entering synthesis try block..." << std::endl;
                std::vector<float> audioData;
                std::cout << "[TTS Performer] Starting synthesis for: " << textToSynthesize.toStdString() << std::endl;
                std::cout << "[TTS Performer] Language: " << currentLanguage.toStdString() << std::endl;
                
                DBG("[TTS Performer] Starting synthesis for: " + textToSynthesize);
                DBG("[TTS Performer] Language: " + currentLanguage);
                
                // Use UTF-8 encoding for correct text handling
                std::cout << "[TTS Performer] Converting text to UTF-8..." << std::endl;
                const std::string textToSpeakUTF8 = textToSynthesize.toUTF8().getAddress();
                std::cout << "[TTS Performer] UTF-8 text: " << textToSpeakUTF8 << std::endl;
                
                std::cout << "[TTS Performer] Calling ttsEngine->tts_to_file()..." << std::endl;
                ttsEngine->tts_to_file(textToSpeakUTF8, audioData, 0);
                std::cout << "[TTS Performer] tts_to_file() completed successfully" << std::endl;

                int numSamples = (int)audioData.size();
                DBG("[TTS Performer] Generated " + juce::String(numSamples) + " audio samples");
                
                if (numSamples > 0)
                {
                    const juce::ScopedLock lock(owner.audioBufferLock);
                    owner.bakedAudioBuffer.setSize(1, numSamples);
                    owner.bakedAudioBuffer.copyFrom(0, 0, audioData.data(), numSamples);
                    owner.currentStatus = Status::Idle;
                    owner.isPlaying = true;  // FORCE PLAYBACK TO START
                    owner.playbackPosition = 0.0;
                    DBG("[TTS Performer] Audio buffer baked successfully - " + juce::String(numSamples) + " samples - FORCING PLAYBACK");
                    std::cout << "[TTS Performer] Audio buffer baked successfully - " << numSamples << " samples - FORCING PLAYBACK" << std::endl;
                }
                else 
                { 
                    owner.currentStatus = Status::Idle; 
                }
            }
            catch(const std::exception& e)
            {
                const juce::ScopedLock lock(owner.messageLock);
                owner.errorMessage = e.what();
                owner.currentStatus = Status::Error;
            }
        }
        else 
        { 
            owner.currentStatus = Status::Idle; 
        }
    }
}

// ==============================================================================
// MAIN PROCESSOR IMPLEMENTATION
// ==============================================================================

TTSPerformerModuleProcessor::TTSPerformerModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withInput("Gate In", juce::AudioChannelSet::mono(), true)
        .withOutput("Audio Output", juce::AudioChannelSet::stereo(), true)
        .withOutput("EOP Gate Out", juce::AudioChannelSet::mono(), true)),
      apvts(*this, nullptr, "TTSPerformerParams", createParameterLayout()),
      textFifoBuffer(16), // Initialize the vector with the same size as the FIFO
      synthesisThread(*this)
{
    DBG("[TTS Performer] Constructor called");
    
    languageParam = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("language"));
    volumeParam = apvts.getRawParameterValue("volume");
    speedParam = apvts.getRawParameterValue("speed");
    pitchParam = apvts.getRawParameterValue("pitch");
    startParam = apvts.getRawParameterValue("start");
    // Formant-related parameter initializations removed - no longer needed for simplified TTS Performer
    
    DBG("[TTS Performer] Parameters initialized");

    // Formant filter initialization removed - no longer needed for simplified TTS Performer
        
    DBG("[TTS Performer] Starting synthesis thread...");
    synthesisThread.startThread();
    DBG("[TTS Performer] Synthesis thread started");
}

TTSPerformerModuleProcessor::~TTSPerformerModuleProcessor() {}

void TTSPerformerModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Formant filter preparation removed - no longer needed for simplified TTS Performer
    
    // --- Time/Pitch DSP Setup ---
    timePitch.prepare(sampleRate, 2, samplesPerBlock); // Prepare for stereo output
    // Debug output disabled for performance
    interleavedCapacityFrames = samplesPerBlock;
    interleavedInput.allocate((size_t)(interleavedCapacityFrames * 2), true);
    interleavedOutput.allocate((size_t)(interleavedCapacityFrames * 2), true);
    
    // --- DC Blocking Filter Setup ---
    // Simple high-pass filter to remove DC offset and low-frequency artifacts
    dcBlockCoefficients = juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, 20.0f);
    dcBlockFilter.coefficients = dcBlockCoefficients;
    dcBlockFilter.reset();
    
    // Instability LFO preparation removed - no longer needed for simplified TTS Performer
}

// updateFilters() function removed - no longer needed for simplified TTS Performer

void TTSPerformerModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    buffer.clear();

    const int numSamples = buffer.getNumSamples();
    if (numSamples <= 0) return;

    auto* gateSignal = getBusBuffer(buffer, true, 0).getReadPointer(0);
    auto* eopGate = getBusBuffer(buffer, false, 1).getWritePointer(0);

    bool gateIsHigh = false;
    for (int i = 0; i < numSamples; ++i) if (gateSignal[i] > 0.5f) { gateIsHigh = true; break; }
    bool risingEdge = gateIsHigh && !lastGateState;
    lastGateState = gateIsHigh;

    if (risingEdge)
    {
        playbackPosition = bakedAudioBuffer.getNumSamples() * startParam->load();
        isPlaying = true;
        timePitch.reset();
    }

    if (isPlaying)
    {
        // Get buffer info with minimal lock time
        int sourceLength;
        const float* sourceData;
        {
            const juce::ScopedLock lock(audioBufferLock);
            sourceLength = bakedAudioBuffer.getNumSamples();
            if (sourceLength < 2)
            {
                isPlaying = false;
                sourceData = nullptr;
            }
            else
            {
                sourceData = bakedAudioBuffer.getReadPointer(0);
            }
        }
        
        if (sourceData != nullptr && sourceLength >= 2)
        {
            // Immediate parameter application (no smoothing) for real-time response
            const float speedCtl = speedParam->load(); // -2..2 mapped exponentially
            const float timeRatio = std::pow(2.0f, speedCtl); // 0.25 .. 4.0
            const float pitchSemis = pitchParam->load();
            timePitch.setTimeStretchRatio(timeRatio);
            timePitch.setPitchSemitones(pitchSemis);
            currentSpeedRatio = timeRatio;
            currentPitchSemitones = pitchSemis;

            if (numSamples > interleavedCapacityFrames)
            {
                interleavedCapacityFrames = numSamples;
                interleavedInput.allocate((size_t)(interleavedCapacityFrames * 2), true);
                interleavedOutput.allocate((size_t)(interleavedCapacityFrames * 2), true);
            }

            // sourceData already obtained above with lock
            float* inLR = interleavedInput.getData();
            int samplesReadFromSource = 0;
            
            // Feed contiguous raw frames to RubberBand; RB handles time/pitch
            const int framesToFeed = juce::jmax(1, (int) std::ceil((double) numSamples / (double) juce::jmax(0.0001f, timeRatio)));
            for (int i = 0; i < framesToFeed; ++i)
            {
                int p0 = static_cast<int>(playbackPosition);
                if (p0 >= sourceLength)
                {
                    isPlaying = false;
                    break;
                }
                inLR[2 * i] = sourceData[p0];
                inLR[2 * i + 1] = sourceData[p0];
                playbackPosition += 1.0;
                samplesReadFromSource++;
            }

            // Only process if we have valid samples
            if (samplesReadFromSource > 0)
            {
                // Debug logging removed for performance
                
                // NORMAL TIME PITCH PROCESSING
                timePitch.putInterleaved(inLR, samplesReadFromSource);
                float* outLR = interleavedOutput.getData();
                const int framesProduced = timePitch.receiveInterleaved(outLR, numSamples);

                if (framesProduced > 0)
                {
                    // Clear buffer first to prevent artifacts
                    buffer.clear();
                    auto* destL = buffer.getWritePointer(0);
                    auto* destR = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : destL;
                    for (int i = 0; i < framesProduced; ++i)
                    {
                        destL[i] = outLR[2 * i + 0];
                        if (destR) destR[i] = outLR[2 * i + 1];
                    }
                    buffer.applyGain(volumeParam->load());
                    // Apply DC blocking filter only if needed (reduces CPU usage)
                    if (currentSpeedRatio < 0.5f || currentPitchSemitones < -12.0f || currentPitchSemitones > 12.0f)
                    {
                        juce::dsp::AudioBlock<float> block(buffer);
                        juce::dsp::ProcessContextReplacing<float> context(block);
                        dcBlockFilter.process(context);
                    }
                    if (framesProduced < numSamples)
                    {
                        buffer.clear(0, framesProduced, numSamples - framesProduced);
                        if (buffer.getNumChannels() > 1) buffer.clear(1, framesProduced, numSamples - framesProduced);
                    }
                }
                else
                {
                    // No frames produced, clear buffer to prevent artifacts
                    buffer.clear();
                }
            }
            else
            {
                // No samples read, clear buffer
                buffer.clear();
            }
        }
    }

    // Set End-Of-Phrase gate
    bool wasPlaying = lastPlaybackState;
    lastPlaybackState = isPlaying;
    for (int i = 0; i < numSamples; ++i)
        eopGate[i] = (!isPlaying && wasPlaying) ? 1.0f : 0.0f;
}

void TTSPerformerModuleProcessor::startSynthesis(const juce::String& text)
{
    DBG("[TTS Performer] startSynthesis called with text: " + text);
    DBG("[TTS Performer] Current status: " + juce::String((int)currentStatus.load()));
    
    if (currentStatus == Status::Synthesizing) 
    {
        DBG("[TTS Performer] Already synthesizing, ignoring request");
        return;
    }
    
    DBG("[TTS Performer] Acquiring textBufferLock...");
    // Safely write the new text to the FIFO queue
    const juce::ScopedLock lock(textBufferLock);
    DBG("[TTS Performer] Lock acquired, preparing to write to FIFO...");
    
    int start1, size1, start2, size2;
    textFifo.prepareToWrite(1, start1, size1, start2, size2);
    
    if (size1 > 0)
    {
        textFifoBuffer[start1] = text;
        DBG("[TTS Performer] Text written to FIFO buffer at position " + juce::String(start1));
    }
    else
    {
        DBG("[TTS Performer] ERROR: No space in FIFO buffer!");
    }
    
    textFifo.finishedWrite(size1);
    DBG("[TTS Performer] FIFO write completed, notifying synthesis thread...");
    
    synthesisThread.notify(); // Wake up the thread
    DBG("[TTS Performer] Synthesis thread notified");
    DBG("[TTS Performer] Synthesis requested for: " + text);
}

void TTSPerformerModuleProcessor::cancelSynthesis() 
{
    synthesisThread.stopThread(1000);
    currentStatus = Status::Idle;
}

juce::AudioProcessorValueTreeState::ParameterLayout TTSPerformerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters;
    
    parameters.push_back(std::make_unique<juce::AudioParameterChoice>(
        "language", "Language", juce::StringArray { "English", "Chinese" }, 0));
    
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "volume", "Volume", 0.0f, 1.0f, 0.8f));
    
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "speed", "Speed", -2.0f, 2.0f, 1.0f));
    
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitch", "Pitch", -24.0f, 24.0f, 0.0f));
    
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "start", "Start", 0.0f, 1.0f, 0.0f));
    
    // Formant-related parameters removed - no longer needed for simplified TTS Performer
    
    return { parameters.begin(), parameters.end() };
}

void TTSPerformerModuleProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    auto state = apvts.copyState();
    const juce::ScopedLock lock(audioBufferLock); // Protect the buffer while reading

    if (bakedAudioBuffer.getNumSamples() > 0)
    {
        juce::ValueTree audioState("BakedAudioData");
        juce::MemoryBlock audioBlock(bakedAudioBuffer.getNumSamples() * sizeof(float));
        memcpy(audioBlock.getData(), bakedAudioBuffer.getReadPointer(0), audioBlock.getSize());
        
        audioState.setProperty("numSamples", bakedAudioBuffer.getNumSamples(), nullptr);
        audioState.setProperty("data", juce::Base64::toBase64(audioBlock.getData(), audioBlock.getSize()), nullptr);
        state.addChild(audioState, -1, nullptr);
    }

    std::unique_ptr<juce::XmlElement> xml(state.createXml());
    copyXmlToBinary(*xml, destData);
}

void TTSPerformerModuleProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    // Get the ValueTree from the XML
    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));

    if (xmlState != nullptr)
    {
        if (xmlState->hasTagName(apvts.state.getType()))
        {
            apvts.replaceState(juce::ValueTree::fromXml(*xmlState));

            // Deserialize the baked audio buffer
            auto audioState = apvts.state.getChildWithName("BakedAudioData");
            if (audioState.isValid())
            {
                int numSamples = audioState.getProperty("numSamples", 0);
                juce::String base64Data = audioState.getProperty("data").toString();
                
                if (numSamples > 0 && base64Data.isNotEmpty())
                {
                    juce::MemoryBlock audioBlock;
                    juce::MemoryOutputStream stream(audioBlock, false);
                    if (juce::Base64::convertFromBase64(stream, base64Data))
                    {
                        const juce::ScopedLock lock(audioBufferLock);
                        bakedAudioBuffer.setSize(1, numSamples);
                        memcpy(bakedAudioBuffer.getWritePointer(0), audioBlock.getData(), audioBlock.getSize());
                    }
                }
            }
        }
    }
}

#if defined(PRESET_CREATOR_UI)
void TTSPerformerModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    // Text input
    ImGui::PushItemWidth(itemWidth);
    if (ImGui::InputTextMultiline("Text", uiTextBuffer, sizeof(uiTextBuffer), ImVec2(itemWidth, 80), ImGuiInputTextFlags_None))
    {
        onModificationEnded();
    }
    ImGui::PopItemWidth();

    // Language selection
    ImGui::PushItemWidth(itemWidth);
    if (languageParam)
    {
        int langIndex = languageParam->getIndex();
        const char* currentLang = languageParam->getCurrentChoiceName().toRawUTF8();
        if (ImGui::BeginCombo("Language", currentLang))
        {
            for (int i = 0; i < languageParam->choices.size(); ++i)
            {
                const bool isSelected = (langIndex == i);
                if (ImGui::Selectable(languageParam->choices[i].toRawUTF8(), isSelected))
                {
                    *languageParam = i;
                    onModificationEnded();
                }
                if (isSelected) ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }
    }
    ImGui::PopItemWidth();

    // Status and synthesis button
    Status status = currentStatus.load();
    bool isBusy = (status == Status::Synthesizing);

    if (isBusy)
    {
        ImGui::BeginDisabled();
    }

    if (ImGui::Button("BAKE AUDIO", ImVec2(itemWidth, 0)))
    {
        DBG("[TTS Performer] BAKE AUDIO button clicked!");
        juce::String textToSpeak = juce::String(uiTextBuffer);
        DBG("[TTS Performer] Text from UI buffer: '" + textToSpeak + "'");
        DBG("[TTS Performer] Text is not empty: " + juce::String(textToSpeak.isNotEmpty()));
        
        if (textToSpeak.isNotEmpty())
        {
            DBG("[TTS Performer] Calling startSynthesis...");
            startSynthesis(textToSpeak);
        }
        else
        {
            DBG("[TTS Performer] Empty text, not starting synthesis");
        }
    }

    if (isBusy)
    {
        ImGui::EndDisabled();
    }
    
    // Status indicator
    switch (status)
    {
        case Status::Idle:
            ImGui::Text("Status: Ready");
            break;
        case Status::Synthesizing:
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: Baking...");
            break;
        case Status::Playing:
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: Playing");
            break;
        case Status::Error:
            ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), "Status: Error");
            break;
    }

    // Error message
    if (status == Status::Error)
    {
        const juce::ScopedLock lock(messageLock);
        if (errorMessage.isNotEmpty())
        {
            ImGui::TextWrapped("Error: %s", errorMessage.toRawUTF8());
        }
    }

    // Parameters in compact rows
    ImGui::PushItemWidth(itemWidth * 0.48f);
    
    // Volume and Speed in one row
    bool volumeModulated = isParamModulated("volume");
    if (volumeModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.5f, 0.0f, 0.3f));
    float volume = volumeParam->load();
    if (ImGui::SliderFloat("Vol", &volume, 0.0f, 1.0f))
    {
        *volumeParam = volume;
        onModificationEnded();
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (!volumeModulated) adjustParamOnWheel(apvts.getParameter("volume"), "volume", volume);
    if (volumeModulated) ImGui::PopStyleColor();
    
    ImGui::SameLine();
    bool speedModulated = isParamModulated("speed");
    if (speedModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.5f, 0.0f, 0.3f));
    float speed = speedParam->load();
    if (ImGui::SliderFloat("Speed", &speed, -2.0f, 2.0f))
    {
        *speedParam = speed;
        onModificationEnded();
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (!speedModulated) adjustParamOnWheel(apvts.getParameter("speed"), "speed", speed);
    if (speedModulated) ImGui::PopStyleColor();

    // Pitch and Start in one row
    bool pitchModulated = isParamModulated("pitch");
    if (pitchModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.5f, 0.0f, 0.3f));
    float pitch = pitchParam->load();
    if (ImGui::SliderFloat("Pitch", &pitch, -24.0f, 24.0f))
    {
        *pitchParam = pitch;
        onModificationEnded();
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (!pitchModulated) adjustParamOnWheel(apvts.getParameter("pitch"), "pitch", pitch);
    if (pitchModulated) ImGui::PopStyleColor();
    
    ImGui::SameLine();
    bool startModulated = isParamModulated("start");
    if (startModulated) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.5f, 0.0f, 0.3f));
    float start = startParam->load();
    if (ImGui::SliderFloat("Start", &start, 0.0f, 1.0f))
    {
        *startParam = start;
        onModificationEnded();
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (!startModulated) adjustParamOnWheel(apvts.getParameter("start"), "start", start);
    if (startModulated) ImGui::PopStyleColor();
    
    ImGui::PopItemWidth();

    // Formant-related UI controls removed - no longer needed for simplified TTS Performer

    // Chinese text presets
    ImGui::Text("Chinese Text Presets:");
    if (ImGui::Button("你好", ImVec2(itemWidth * 0.3f, 0)))
    {
        strncpy_s(uiTextBuffer, "你好", sizeof(uiTextBuffer) - 1);
        onModificationEnded();
    }
    ImGui::SameLine();
    if (ImGui::Button("世界", ImVec2(itemWidth * 0.3f, 0)))
    {
        strncpy_s(uiTextBuffer, "世界", sizeof(uiTextBuffer) - 1);
        onModificationEnded();
    }
    ImGui::SameLine();
    if (ImGui::Button("测试", ImVec2(itemWidth * 0.3f, 0)))
    {
        strncpy_s(uiTextBuffer, "测试", sizeof(uiTextBuffer) - 1);
        onModificationEnded();
    }
}

void TTSPerformerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // Audio inputs
    helpers.drawAudioInputPin("Gate In", 0);
    
    // Audio outputs
    helpers.drawAudioOutputPin("Audio L", 0);
    helpers.drawAudioOutputPin("Audio R", 1);
    helpers.drawAudioOutputPin("EOP Gate", 2);
    
    // Modulation inputs
    helpers.drawModulationInputPin("Speed", "speed");
    helpers.drawModulationInputPin("Pitch", "pitch");
    helpers.drawModulationInputPin("Start", "start");
}
#endif


================================================================================
FILE: juce\Source\audio\modules\TTSPerformerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "../dsp/TimePitchProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include <juce_core/juce_core.h>

namespace melo { class TTS; }

// FormantData struct removed - no longer needed for simplified TTS Performer

class TTSPerformerModuleProcessor : public ModuleProcessor
{
public:
    TTSPerformerModuleProcessor();
    ~TTSPerformerModuleProcessor() override;

    const juce::String getName() const override { return "TTS Performer"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    void getStateInformation(juce::MemoryBlock& destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;

    void startSynthesis(const juce::String& text);
    void cancelSynthesis();

    // updateFilters() method removed - no longer needed for simplified TTS Performer

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    class SynthesisThread : public juce::Thread
    {
    public:
        SynthesisThread(TTSPerformerModuleProcessor& owner);
        ~SynthesisThread() override;
        void run() override;
    private:
        TTSPerformerModuleProcessor& owner;
        std::unique_ptr<melo::TTS> ttsEngine;
        juce::String currentLanguage;
    };

    // --- Audio Storage and Playback ---
    juce::AudioBuffer<float> bakedAudioBuffer;
    double playbackPosition { 0.0 };
    bool isPlaying { false };
    bool lastGateState { false };

    // --- Text Input (Thread-Safe Queue) ---
    juce::AbstractFifo textFifo { 16 }; // A queue that can hold up to 16 strings
    std::vector<juce::String> textFifoBuffer;
    juce::CriticalSection textBufferLock; // A lock to protect the backing store
    juce::CriticalSection messageLock;
    juce::CriticalSection audioBufferLock; // A lock to protect the audio buffer

    // --- Status Tracking ---
    enum class Status { Idle, Synthesizing, Playing, Error };
    std::atomic<Status> currentStatus { Status::Idle };
    juce::String errorMessage;

    // --- APVTS and Parameters ---
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioParameterChoice* languageParam { nullptr };
    std::atomic<float>* volumeParam { nullptr };
    std::atomic<float>* speedParam { nullptr };
    std::atomic<float>* pitchParam { nullptr };
    std::atomic<float>* startParam { nullptr };
    // Formant-related parameters removed - no longer needed for simplified TTS Performer

    SynthesisThread synthesisThread;

    // Vowel data tables and formant DSP members removed - no longer needed for simplified TTS Performer
    
    // --- Time/Pitch DSP ---
    TimePitchProcessor timePitch;
    juce::HeapBlock<float> interleavedInput, interleavedOutput;
    int interleavedCapacityFrames { 0 };
    bool lastPlaybackState { false };
    
    // --- DC Blocking Filter ---
    juce::dsp::IIR::Filter<float> dcBlockFilter;
    juce::dsp::IIR::Coefficients<float>::Ptr dcBlockCoefficients;
    
    // --- Parameter Smoothing ---
    float currentSpeedRatio { 1.0f };
    float currentPitchSemitones { 0.0f };
    static constexpr float parameterSmoothingRate = 0.01f; // Smooth parameter changes
    
#if defined(PRESET_CREATOR_UI)
    char uiTextBuffer[2048] { "Hello, modular world." };
#endif
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(TTSPerformerModuleProcessor);
};


================================================================================
FILE: juce\Source\audio\modules\ValueModuleProcessor.cpp
================================================================================


#include "ValueModuleProcessor.h"

ValueModuleProcessor::ValueModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withOutput("Out", juce::AudioChannelSet::discreteChannels(4), true)), // 4 distinct outputs
      apvts(*this, nullptr, "ValueParams", createParameterLayout())
{
    valueParam = apvts.getRawParameterValue("value");

    // Initialize value tooltips for the four outputs
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

juce::AudioProcessorValueTreeState::ParameterLayout ValueModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    // UPDATE THIS LINE: Set the range from -20000 to 20000
    params.push_back(std::make_unique<juce::AudioParameterFloat>("value", "Value", -20000.0f, 20000.0f, 1.0f));
    return { params.begin(), params.end() };
}

void ValueModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    buffer.clear();

    const float rawValue = valueParam->load();
    auto* param = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("value"));
    const float normalizedValue = param->getNormalisableRange().convertTo0to1(rawValue);

    auto* outRaw = buffer.getWritePointer(0);
    auto* outNorm = buffer.getWritePointer(1);
    auto* outInv = buffer.getWritePointer(2);
    auto* outInt = buffer.getWritePointer(3);

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        // Output 0: The raw value entered by the user.
        outRaw[i] = rawValue;

        // Output 1: The value normalized from 0.0 to 1.0 across its defined range.
        outNorm[i] = normalizedValue;

        // Output 2: The inverted raw value.
        outInv[i] = -rawValue;

        // Output 3: The value rounded to the nearest integer.
        outInt[i] = std::round(rawValue);
    }

    // Update tooltips
    if (lastOutputValues.size() >= 4)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(outRaw[buffer.getNumSamples() - 1]);
        if (lastOutputValues[1]) lastOutputValues[1]->store(outNorm[buffer.getNumSamples() - 1]);
        if (lastOutputValues[2]) lastOutputValues[2]->store(outInv[buffer.getNumSamples() - 1]);
        if (lastOutputValues[3]) lastOutputValues[3]->store(outInt[buffer.getNumSamples() - 1]);
    }
}


================================================================================
FILE: juce\Source\audio\modules\ValueModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class ValueModuleProcessor : public ModuleProcessor
{
public:
    ValueModuleProcessor();
    ~ValueModuleProcessor() override = default;

    const juce::String getName() const override { return "Value"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override {}
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("value"));
        if (!p) return;

        float currentValue = *p;

        ImGui::PushItemWidth(itemWidth);
        if (ImGui::InputFloat("Value", &currentValue, 0.0f, 0.0f, "%.4f"))
        {
            *p = currentValue;
        }
        if (ImGui::IsItemDeactivatedAfterEdit())
        {
            onModificationEnded();
        }
        ImGui::PopItemWidth();

        // New Time-Based, Exponential Mouse Wheel Logic
        if (ImGui::IsItemHovered())
        {
            const float wheel = ImGui::GetIO().MouseWheel;
            if (wheel != 0.0f)
            {
                const double currentTime = ImGui::GetTime();
                const double timeDelta = currentTime - lastScrollTime;

                // 1. If user paused for > 0.2s, reset momentum
                if (timeDelta > 0.2)
                {
                    scrollMomentum = 1.0f;
                }

                // 2. Define the smallest step for precision
                const float baseStep = 0.01f;
                
                // 3. Calculate the final step using the momentum
                float finalStep = baseStep * scrollMomentum;

                // 4. Update the value
                float newValue = currentValue + (wheel > 0.0f ? finalStep : -finalStep);
                
                // Snap to the baseStep to keep numbers clean
                newValue = std::round(newValue / baseStep) * baseStep;

                // 5. Increase momentum for the *next* scroll event (exponential)
                // This makes continuous scrolling accelerate.
                scrollMomentum *= 1.08f;
                scrollMomentum = std::min(scrollMomentum, 2000.0f); // Cap momentum to prevent runaway

                // 6. Update the parameter and timestamp
                *p = juce::jlimit(p->range.start, p->range.end, newValue);
                lastScrollTime = currentTime;
            }
        }
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        // Draw the four output pins for the Value module
        helpers.drawAudioOutputPin("Raw", 0);
        helpers.drawAudioOutputPin("Normalized", 1);
        helpers.drawAudioOutputPin("Inverted", 2);
        helpers.drawAudioOutputPin("Integer", 3);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* valueParam { nullptr };

    // Add these two state variables for the new scroll logic
    double lastScrollTime { 0.0 };
    float scrollMomentum { 1.0f };
};


================================================================================
FILE: juce\Source\audio\modules\VCAModuleProcessor.cpp
================================================================================


#include "VCAModuleProcessor.h"

VCAModuleProcessor::VCAModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Audio In", juce::AudioChannelSet::stereo(), true)
                        .withInput("Mod In", juce::AudioChannelSet::mono(), true)
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "VCAParams", createParameterLayout())
{
    gainParam = apvts.getRawParameterValue("gain");
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

juce::AudioProcessorValueTreeState::ParameterLayout VCAModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gain", "Gain",
        juce::NormalisableRange<float>(-60.0f, 6.0f, 0.1f), 0.0f));

    return { params.begin(), params.end() };
}

void VCAModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32)samplesPerBlock, 2 };
    gain.prepare(spec);
}

void VCAModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    
    // Get the modulation input buffer (second input bus)
    auto modIn = getBusBuffer(buffer, true, 1);
    const float* modSignal = modIn.getReadPointer(0);
    
    // Process sample by sample to apply modulation
    for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
    {
        float* channelData = buffer.getWritePointer(channel);
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            // Get base gain from the dB parameter
            const float gainFromParam = juce::Decibels::decibelsToGain(gainParam->load());
            
            // The modulation signal is typically 0-1 for ADSRs/LFOs
            const float gainFromMod = modSignal[i];
            
            // Combine them: parameter acts as initial level, modulation controls final gain
            const float finalGain = gainFromParam * gainFromMod;
            channelData[i] *= finalGain;
        }
    }
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\VCAModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class VCAModuleProcessor : public ModuleProcessor
{
public:
    VCAModuleProcessor();
    ~VCAModuleProcessor() override = default;

    const juce::String getName() const override { return "VCA"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float gainDb = gainParam != nullptr ? gainParam->load() : 0.0f;
        ImGui::PushItemWidth (itemWidth);
        
        bool isGainModulated = isParamModulated("gain");
        if (isGainModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Gain dB", &gainDb, -60.0f, 6.0f)) if (!isGainModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("gain"))) *p = gainDb;
        if (!isGainModulated) adjustParamOnWheel(ap.getParameter("gain"), "gain", gainDb);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isGainModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("In L", 0);
        helpers.drawAudioInputPin("In R", 1);
        helpers.drawModulationInputPin("Gain", "gain");
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Gain<float> gain;

    std::atomic<float>* gainParam = nullptr;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VCAModuleProcessor)
};




================================================================================
FILE: juce\Source\audio\modules\VCFModuleProcessor.cpp
================================================================================


#include "VCFModuleProcessor.h"

VCFModuleProcessor::VCFModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Input", juce::AudioChannelSet::stereo(), true)
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "VCFParams", createParameterLayout())
{
    cutoffParam = apvts.getRawParameterValue(paramIdCutoff);
    resonanceParam = apvts.getRawParameterValue(paramIdResonance);
    typeParam = apvts.getRawParameterValue(paramIdType);
    typeModParam = apvts.getRawParameterValue(paramIdTypeMod);
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

juce::AudioProcessorValueTreeState::ParameterLayout VCFModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdCutoff, "Cutoff",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 1000.0f));
    
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdResonance, "Resonance",
        juce::NormalisableRange<float>(0.1f, 10.0f, 0.01f), 1.0f));

    params.push_back(std::make_unique<juce::AudioParameterChoice>(
        paramIdType, "Type",
        juce::StringArray { "Low-pass", "High-pass", "Band-pass" }, 0));
    
    // Add modulation parameter for filter type
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdTypeMod, "Type Mod", 0.0f, 1.0f, 0.0f));

    return { params.begin(), params.end() };
}

void VCFModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32)samplesPerBlock, 2 };
    filter.prepare(spec);
}

void VCFModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);

    float typeMod = typeModParam != nullptr ? typeModParam->load() : 0.0f; // 0..1
    int numChoices = 3;
    int modChoice = static_cast<int>(std::floor(typeMod * numChoices));
    int finalChoice = (static_cast<int>(typeParam->load()) + modChoice) % numChoices;
    auto currentType = finalChoice;
    switch (currentType)
    {
        case 0: filter.setType(juce::dsp::StateVariableTPTFilterType::lowpass); break;
        case 1: filter.setType(juce::dsp::StateVariableTPTFilterType::highpass); break;
        case 2: filter.setType(juce::dsp::StateVariableTPTFilterType::bandpass); break;
    }

    filter.setCutoffFrequency(cutoffParam->load());
    filter.setResonance(resonanceParam->load());

    juce::dsp::AudioBlock<float> block(buffer);
    juce::dsp::ProcessContextReplacing<float> context(block);
    filter.process(context);
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
    }
}




================================================================================
FILE: juce\Source\audio\modules\VCFModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class VCFModuleProcessor : public ModuleProcessor
{
public:
    // Parameter ID constants
    static constexpr auto paramIdCutoff = "cutoff";
    static constexpr auto paramIdResonance = "resonance";
    static constexpr auto paramIdType = "type";
    static constexpr auto paramIdTypeMod = "type_mod";

    VCFModuleProcessor();
    ~VCFModuleProcessor() override = default;

    const juce::String getName() const override { return "VCF"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float cutoff = cutoffParam != nullptr ? cutoffParam->load() : 1000.0f;
        float q = resonanceParam != nullptr ? resonanceParam->load() : 1.0f;
        int ftype = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdType))) ftype = p->getIndex();

        ImGui::PushItemWidth (itemWidth);

        bool isCutoffModulated = isParamModulated(paramIdCutoff);
        if (isCutoffModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Cutoff", &cutoff, 20.0f, 20000.0f, "%.1f Hz", ImGuiSliderFlags_Logarithmic)) if (!isCutoffModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdCutoff))) *p = cutoff;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (!isCutoffModulated) adjustParamOnWheel (ap.getParameter(paramIdCutoff), "cutoffHz", cutoff);
        if (isCutoffModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        bool isResoModulated = isParamModulated(paramIdResonance);
        if (isResoModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Resonance", &q, 0.1f, 10.0f)) if (!isResoModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdResonance))) *p = q;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (!isResoModulated) adjustParamOnWheel (ap.getParameter(paramIdResonance), "resonance", q);
        if (isResoModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
        
        bool isTypeModulated = isParamModulated(paramIdTypeMod);
        if (isTypeModulated) ImGui::BeginDisabled();
        if (ImGui::Combo ("Type", &ftype, "Low-pass\0High-pass\0Band-pass\0\0")) if (!isTypeModulated) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdType))) *p = ftype;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isTypeModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("In L", 0);
        helpers.drawAudioInputPin("In R", 1);
        helpers.drawModulationInputPin("Cutoff", paramIdCutoff);
        helpers.drawModulationInputPin("Resonance", paramIdResonance);
        helpers.drawModulationInputPin("Type", paramIdTypeMod);
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::StateVariableTPTFilter<float> filter;

    // Cached parameter pointers
    std::atomic<float>* cutoffParam = nullptr;
    std::atomic<float>* resonanceParam = nullptr;
    std::atomic<float>* typeParam = nullptr;
    std::atomic<float>* typeModParam = nullptr;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VCFModuleProcessor)
};




================================================================================
FILE: juce\Source\audio\modules\VCOModuleProcessor.cpp
================================================================================


#include "VCOModuleProcessor.h"

VCOModuleProcessor::VCOModuleProcessor()
    : ModuleProcessor (BusesProperties().withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "VCOParams", createParameterLayout())
{
    frequencyParam = apvts.getRawParameterValue(paramIdFrequency);
    waveformParam = apvts.getRawParameterValue(paramIdWaveform);
    waveformModParam = apvts.getRawParameterValue(paramIdWaveformMod);

    // CORRECTED INITIALIZATION:
    // Create unique_ptrs to heap-allocated atomics for each output channel.
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 0
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // Channel 1

    // Default waveform
    oscillator.initialise([](float x) { return std::sin(x); }, 128);
}

juce::AudioProcessorValueTreeState::ParameterLayout VCOModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdFrequency, "Frequency",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 440.0f));
    
    params.push_back(std::make_unique<juce::AudioParameterChoice>(
        paramIdWaveform, "Waveform",
        juce::StringArray { "Sine", "Sawtooth", "Square" }, 0));
    
    // Add modulation parameter for waveform
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdWaveformMod, "Waveform Mod", 0.0f, 1.0f, 0.0f));

    return { params.begin(), params.end() };
}

void VCOModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.maximumBlockSize = samplesPerBlock;
    spec.numChannels = 2;
    oscillator.prepare(spec);
}

void VCOModuleProcessor::releaseResources() {}

void VCOModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    buffer.clear(); // This module is a source, so it clears the buffer first.

    // Apply waveform modulation
    float waveformMod = waveformModParam != nullptr ? waveformModParam->load() : 0.0f; // 0..1
    int numChoices = 3;
    // Let the modulation signal select an offset from the base waveform
    int modChoice = static_cast<int>(std::floor(waveformMod * numChoices));
    int finalChoice = (static_cast<int>(waveformParam->load()) + modChoice) % numChoices;
    const int wf = finalChoice;
    if (wf == 0)
        oscillator.initialise([](float x) { return std::sin(x); }, 128);
    else if (wf == 1)
        oscillator.initialise([](float x) { return (x / juce::MathConstants<float>::pi); }, 128);
    else
        oscillator.initialise([](float x) { return x < 0.0f ? -1.0f : 1.0f; }, 128);

    // Set frequency from the parameter
    oscillator.setFrequency(frequencyParam->load(), true);

    juce::dsp::AudioBlock<float> block(buffer);
    juce::dsp::ProcessContextReplacing<float> context(block);
    oscillator.process(context);

    // CORRECTED UPDATE:
    // Check pointers and dereference before storing the new value.
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0] != nullptr)
            lastOutputValues[0]->store(buffer.getMagnitude(0, 0, buffer.getNumSamples()));
        
        if (lastOutputValues[1] != nullptr)
            lastOutputValues[1]->store(buffer.getMagnitude(1, 0, buffer.getNumSamples()));
    }
}




================================================================================
FILE: juce\Source\audio\modules\VCOModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

class VCOModuleProcessor : public ModuleProcessor
{
public:
    // Parameter ID constants
    static constexpr auto paramIdFrequency = "frequency";
    static constexpr auto paramIdWaveform = "waveform";
    static constexpr auto paramIdWaveformMod = "waveform_mod";

    VCOModuleProcessor();
    ~VCOModuleProcessor() override = default;

    const juce::String getName() const override { return "VCO"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override
    {
        auto& ap = getAPVTS();
        float freq = frequencyParam != nullptr ? frequencyParam->load() : 440.0f;
        int wave = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWaveform))) wave = p->getIndex();
        
        ImGui::PushItemWidth (itemWidth);

        // Frequency
        bool isFreqModulated = isParamModulated(paramIdFrequency);
        if (isFreqModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat ("Frequency", &freq, 20.0f, 20000.0f, "%.1f Hz", ImGuiSliderFlags_Logarithmic)) if (!isFreqModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdFrequency))) *p = freq;
        if (!isFreqModulated) adjustParamOnWheel (ap.getParameter(paramIdFrequency), "frequencyHz", freq);
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isFreqModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

        // Waveform
        bool isWaveModulated = isParamModulated(paramIdWaveformMod);
        if (isWaveModulated) ImGui::BeginDisabled();
        if (ImGui::Combo ("Waveform", &wave, "Sine\0Saw\0Square\0\0")) if (!isWaveModulated) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWaveform))) *p = wave;
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (isWaveModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
        
        ImGui::PopItemWidth();
    }

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawModulationInputPin("Frequency", paramIdFrequency);
        helpers.drawModulationInputPin("Waveform", paramIdWaveformMod);
        helpers.drawAudioOutputPin("Out L", 0);
        helpers.drawAudioOutputPin("Out R", 1);
    }
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Oscillator<float> oscillator;

    // Cached parameter pointers for real-time access
    std::atomic<float>* frequencyParam = nullptr;
    std::atomic<float>* waveformParam = nullptr;
    std::atomic<float>* waveformModParam = nullptr;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VCOModuleProcessor)
};




================================================================================
FILE: juce\Source\audio\modules\VocalTractFilterModuleProcessor.cpp
================================================================================


#include "VocalTractFilterModuleProcessor.h"
// standalone FormantData is defined in header now; no include required

#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/ImGuiNodeEditorComponent.h"
#endif

// --- Static Vowel Data Definitions ---
const FormantData VocalTractFilterModuleProcessor::VOWEL_A[4] = { { 700.0f, 1.0f, 6.0f}, {1220.0f, 0.5f, 8.0f}, {2600.0f, 0.2f, 12.0f}, {3800.0f, 0.15f, 15.0f} };
const FormantData VocalTractFilterModuleProcessor::VOWEL_E[4] = { { 500.0f, 1.0f, 7.0f}, {1800.0f, 0.6f, 9.0f}, {2800.0f, 0.3f, 13.0f}, {3900.0f, 0.2f, 16.0f} };
const FormantData VocalTractFilterModuleProcessor::VOWEL_I[4] = { { 270.0f, 1.0f, 8.0f}, {2300.0f, 0.4f, 10.0f}, {3000.0f, 0.2f, 14.0f}, {4000.0f, 0.1f, 18.0f} };
const FormantData VocalTractFilterModuleProcessor::VOWEL_O[4] = { { 450.0f, 1.0f, 6.0f}, { 800.0f, 0.7f, 8.0f}, {2830.0f, 0.15f,12.0f}, {3800.0f, 0.1f, 15.0f} };
const FormantData VocalTractFilterModuleProcessor::VOWEL_U[4] = { { 300.0f, 1.0f, 7.0f}, { 870.0f, 0.6f, 9.0f}, {2240.0f, 0.1f, 13.0f}, {3500.0f, 0.05f,16.0f} };

VocalTractFilterModuleProcessor::VocalTractFilterModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withInput("Audio In", juce::AudioChannelSet::stereo(), true)
        .withOutput("Audio Out", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "VocalTractParams", createParameterLayout())
{
    // Initialize parameter pointers with safety checks
    formantShiftParam = apvts.getRawParameterValue("formantShift");
    vowelShapeParam = apvts.getRawParameterValue("vowelShape");
    instabilityParam = apvts.getRawParameterValue("instability");
    formantGainParam = apvts.getRawParameterValue("formantGain");

    // Initialize formant filters
    formantFilters.reserve(4);
    for (int i = 0; i < 4; ++i)
        formantFilters.emplace_back();
        
    // Initialize formant gains
    formantGains.fill(1.0f);
}

void VocalTractFilterModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // Safety checks
    if (sampleRate <= 0.0 || samplesPerBlock <= 0)
        return;
        
    dspSpec.sampleRate = sampleRate;
    dspSpec.maximumBlockSize = samplesPerBlock;
    dspSpec.numChannels = 2; // Stereo processing

    // Ensure we have exactly 4 filters
    formantFilters.clear();
    formantFilters.resize(4);
    
    for (auto& filter : formantFilters)
    {
        filter.prepare(dspSpec);
        filter.reset();
    }
    
    // Initialize oscillators safely
    wowOscillator.prepare(dspSpec);
    wowOscillator.setFrequency(0.5f);
    wowOscillator.reset();
    
    flutterOscillator.prepare(dspSpec);
    flutterOscillator.setFrequency(7.5f);
    flutterOscillator.reset();
    
    // Initialize formant gains
    formantGains.fill(1.0f);
}

void VocalTractFilterModuleProcessor::updateFilters()
{
    // Safety checks for parameter pointers
    if (!vowelShapeParam || !instabilityParam || !formantShiftParam || !formantGainParam)
        return;
        
    // Safety check for DSP spec
    if (dspSpec.sampleRate <= 0.0 || dspSpec.maximumBlockSize <= 0)
        return;

    const FormantData* vowels[] = { VOWEL_A, VOWEL_E, VOWEL_I, VOWEL_O, VOWEL_U };
    float vowelShape = juce::jlimit(0.0f, 3.999f, vowelShapeParam->load()); // Clamp to prevent array bounds issues
    float instability = juce::jlimit(0.0f, 1.0f, instabilityParam->load());

    // Get instability modulation source
    float wowAmount = wowOscillator.processSample(0.0f) * 0.03f * instability;
    float flutterAmount = flutterOscillator.processSample(0.0f) * 0.01f * instability;
    float instabilityMultiplier = 1.0f + wowAmount + flutterAmount;

    int startIndex = static_cast<int>(std::floor(vowelShape));
    int endIndex = juce::jmin(4, startIndex + 1);
    float t = vowelShape - startIndex;

    // Safety check for array bounds
    if (startIndex < 0 || startIndex >= 5 || endIndex < 0 || endIndex >= 5)
        return;

    const FormantData* startVowel = vowels[startIndex];
    const FormantData* endVowel = vowels[endIndex];

    float shiftMultiplier = std::pow(2.0f, juce::jlimit(-1.0f, 1.0f, formantShiftParam->load()));

    for (int i = 0; i < 4; ++i)
    {
        float freq = juce::jmap(t, startVowel[i].frequency, endVowel[i].frequency);
        float gain = juce::jmap(t, startVowel[i].gain, endVowel[i].gain);
        float q = juce::jmap(t, startVowel[i].q, endVowel[i].q);

        float centerFreq = juce::jlimit(20.0f, (float)dspSpec.sampleRate / 2.0f - 1.0f, freq * shiftMultiplier * instabilityMultiplier);
        
        formantGains[i] = gain;
        
        // Safety check for filter coefficients
        if (centerFreq > 20.0f && centerFreq < dspSpec.sampleRate / 2.0f && q > 0.1f)
        {
            formantFilters[i].coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(dspSpec.sampleRate, centerFreq, q);
        }
    }
}

void VocalTractFilterModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Safety checks
    if (!formantGainParam || formantFilters.size() != 4)
    {
        buffer.clear();
        return;
    }

    updateFilters();

    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    if (&in != &out) out.copyFrom(0, 0, in, 0, 0, in.getNumSamples());

    const int numSamples = buffer.getNumSamples();
    const float gain = juce::Decibels::decibelsToGain(juce::jlimit(-24.0f, 24.0f, formantGainParam->load()));

    for (int ch = 0; ch < out.getNumChannels(); ++ch)
    {
        float* channelData = out.getWritePointer(ch);
        for (int i = 0; i < numSamples; ++i)
        {
            float inputSample = channelData[i];
            float filteredSample = 0.0f;
            
            // Safety check for filter array bounds
            for (size_t j = 0; j < formantFilters.size() && j < 4; ++j)
            {
                if (formantFilters[j].coefficients != nullptr)
                {
                    filteredSample += formantFilters[j].processSample(inputSample) * formantGains[j];
                }
            }
            channelData[i] = filteredSample * gain;
        }
    }
}

juce::AudioProcessorValueTreeState::ParameterLayout VocalTractFilterModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterFloat>("vowelShape", "Vowel Shape", 0.0f, 4.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>("formantShift", "Formant Shift", -1.0f, 1.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>("instability", "Instability", 0.0f, 1.0f, 0.0f));
    p.push_back(std::make_unique<juce::AudioParameterFloat>("formantGain", "Formant Gain", juce::NormalisableRange<float>(-24.0f, 24.0f, 0.1f), 0.0f));
    return { p.begin(), p.end() };
}

#if defined(PRESET_CREATOR_UI)
void VocalTractFilterModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    // Safety checks for parameter pointers
    if (!vowelShapeParam || !formantShiftParam || !instabilityParam || !formantGainParam)
        return;
        
    ImGui::PushItemWidth(itemWidth);
    
    // Vowel Shape slider
    float vowelShape = juce::jlimit(0.0f, 4.0f, vowelShapeParam->load());
    if (ImGui::SliderFloat("Vowel", &vowelShape, 0.0f, 4.0f, "%.1f"))
    {
        *vowelShapeParam = vowelShape;
        onModificationEnded();
    }
    
    // Formant Shift slider
    float formantShift = juce::jlimit(-1.0f, 1.0f, formantShiftParam->load());
    if (ImGui::SliderFloat("Formant", &formantShift, -1.0f, 1.0f, "%.2f"))
    {
        *formantShiftParam = formantShift;
        onModificationEnded();
    }
    
    // Instability slider
    float instability = juce::jlimit(0.0f, 1.0f, instabilityParam->load());
    if (ImGui::SliderFloat("Instability", &instability, 0.0f, 1.0f, "%.2f"))
    {
        *instabilityParam = instability;
        onModificationEnded();
    }
    
    // Formant Gain slider
    float formantGain = juce::jlimit(-24.0f, 24.0f, formantGainParam->load());
    if (ImGui::SliderFloat("Gain", &formantGain, -24.0f, 24.0f, "%.1f dB"))
    {
        *formantGainParam = formantGain;
        onModificationEnded();
    }
    
    ImGui::PopItemWidth();
}

void VocalTractFilterModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Audio In L", 0);
    helpers.drawAudioInputPin("Audio In R", 1);
    helpers.drawAudioOutputPin("Audio Out L", 0);
    helpers.drawAudioOutputPin("Audio Out R", 1);
    helpers.drawModulationInputPin("Vowel", "vowelShape");
    helpers.drawModulationInputPin("Formant", "formantShift");
    helpers.drawModulationInputPin("Instability", "instability");
    helpers.drawModulationInputPin("Gain", "formantGain");
}
#endif


================================================================================
FILE: juce\Source\audio\modules\VocalTractFilterModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>

// Forward declaration and definition source
struct FormantData { float frequency; float gain; float q; };

// --- Formant Data Structure ---
// Note: FormantData is already defined in TTSPerformerModuleProcessor.h
// We need to include it to use it

class VocalTractFilterModuleProcessor : public ModuleProcessor
{
public:
    VocalTractFilterModuleProcessor();
    ~VocalTractFilterModuleProcessor() override = default;

    const juce::String getName() const override { return "Vocal Tract Filter"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    void updateFilters();

    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    juce::AudioProcessorValueTreeState apvts;
    
    // --- Parameter Pointers ---
    std::atomic<float>* formantShiftParam { nullptr };
    std::atomic<float>* vowelShapeParam { nullptr };
    std::atomic<float>* instabilityParam { nullptr };
    std::atomic<float>* formantGainParam { nullptr };

    // --- Vowel Data Tables ---
    static const FormantData VOWEL_A[4];
    static const FormantData VOWEL_E[4];
    static const FormantData VOWEL_I[4];
    static const FormantData VOWEL_O[4];
    static const FormantData VOWEL_U[4];
    
    // --- DSP Members ---
    std::vector<juce::dsp::IIR::Filter<float>> formantFilters;
    std::array<float, 4> formantGains { 1.0f, 0.5f, 0.2f, 0.15f };
    juce::dsp::ProcessSpec dspSpec;
    juce::dsp::Oscillator<float> wowOscillator, flutterOscillator;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VocalTractFilterModuleProcessor);
};


================================================================================
FILE: juce\Source\audio\modules\WaveshaperModuleProcessor.cpp
================================================================================


#include "WaveshaperModuleProcessor.h"
#include <cmath> // For std::tanh

juce::AudioProcessorValueTreeState::ParameterLayout WaveshaperModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> p;
    p.push_back(std::make_unique<juce::AudioParameterFloat>("drive", "Drive", 
        juce::NormalisableRange<float>(1.0f, 100.0f, 0.01f, 0.3f), 1.0f));
    p.push_back(std::make_unique<juce::AudioParameterChoice>("type", "Type",
        juce::StringArray{ "Soft Clip (tanh)", "Hard Clip", "Foldback" }, 0));
    return { p.begin(), p.end() };
}

WaveshaperModuleProcessor::WaveshaperModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("In", juce::AudioChannelSet::stereo(), true)
                        .withOutput("Out", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "WaveshaperParams", createParameterLayout())
{
    driveParam = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("drive"));
    typeParam = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("type"));
    
    // Initialize output value tracking for tooltips
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out L
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f)); // For Out R
}

void WaveshaperModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    // This is a pass-through processor.
    // auto& in = getBusBuffer(buffer, true, 0);
    // auto& out = getBusBuffer(buffer, false, 0);
    // if (&in != &out) out.copyFrom(in);

    const float drive = driveParam->get();
    const int type = typeParam->getIndex();
    
    for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
    {
        float* data = buffer.getWritePointer(ch);
        for (int i = 0; i < buffer.getNumSamples(); ++i)
        {
            float s = data[i] * drive;
            
            switch (type)
            {
                case 0: // Soft Clip (tanh)
                    data[i] = std::tanh(s);
                    break;
                case 1: // Hard Clip
                    data[i] = juce::jlimit(-1.0f, 1.0f, s);
                    break;
                case 2: // Foldback
                    data[i] = std::abs(std::abs(std::fmod(s - 1.0f, 4.0f)) - 2.0f) - 1.0f;
                    break;
            }
        }
    }
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(buffer.getSample(0, buffer.getNumSamples() - 1));
        if (lastOutputValues[1]) lastOutputValues[1]->store(buffer.getSample(1, buffer.getNumSamples() - 1));
    }
}

#if defined(PRESET_CREATOR_UI)
void WaveshaperModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    float drive = 1.0f; if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("drive"))) drive = *p;
    int type = 0; if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("type"))) type = p->getIndex();

    ImGui::PushItemWidth(itemWidth);

    // Drive
    bool isDriveModulated = isParamModulated("drive");
    if (isDriveModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Drive", &drive, 1.0f, 100.0f, "%.2f", ImGuiSliderFlags_Logarithmic)) if (!isDriveModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("drive"))) *p = drive;
    if (!isDriveModulated) adjustParamOnWheel(ap.getParameter("drive"), "drive", drive);
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (isDriveModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    // Type (This module doesn't have a type_mod, so no disabling logic needed)
    if (ImGui::Combo("Type", &type, "Soft Clip\0Hard Clip\0Foldback\0\0")) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("type"))) *p = type;
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

    ImGui::PopItemWidth();
}

void WaveshaperModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In L", 0);
    helpers.drawAudioInputPin("In R", 1);
    helpers.drawModulationInputPin("Drive", "drive");
    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}
#endif


================================================================================
FILE: juce\Source\audio\modules\WaveshaperModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class WaveshaperModuleProcessor : public ModuleProcessor
{
public:
    WaveshaperModuleProcessor();
    ~WaveshaperModuleProcessor() override = default;

    const juce::String getName() const override { return "Waveshaper"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override {}
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioParameterFloat* driveParam { nullptr };
    juce::AudioParameterChoice* typeParam { nullptr };
};


================================================================================
FILE: juce\Source\audio\voices\ModularVoice.h
================================================================================


#pragma once

#include "../graph/VoiceProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include "../dsp/TimePitchProcessor.h"

// Adapter that lets ModularSynthProcessor be used as a VoiceProcessor in the harness
class ModularVoice : public VoiceProcessor
{
public:
    ModularVoice()
    {
        modularSynth = std::make_unique<ModularSynthProcessor>();
    }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override
    {
        VoiceProcessor::prepareToPlay (sampleRate, samplesPerBlock);
        if (modularSynth)
            modularSynth->prepareToPlay (sampleRate, samplesPerBlock);
            
        // Prepare time/pitch post-processing (copied from SynthVoiceProcessor)
        timePitch.prepare (sampleRate, 2, samplesPerBlock);
        interleavedCapacityFrames = samplesPerBlock;
        interleavedInput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
        interleavedOutput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
    }

    void renderBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi) override
    {
		// 1) Render raw modular synth output into the provided buffer
		buffer.clear();
		if (modularSynth)
			modularSynth->processBlock (buffer, midi);

		const int numSamples = buffer.getNumSamples();
		if (numSamples <= 0)
			return;

		// 2) Read time/pitch parameters
		const float apTime  = apvts.getRawParameterValue ("timeStretchRatio") ? apvts.getRawParameterValue ("timeStretchRatio")->load() : 1.0f;
		const float apPitch = apvts.getRawParameterValue ("pitchSemitones")  ? apvts.getRawParameterValue ("pitchSemitones")->load()  : 0.0f;
		timePitch.setTimeStretchRatio (apTime);
		timePitch.setPitchSemitones (apPitch);

		// 3) Ensure interleaved buffers are large enough
		const int requiredSamples = numSamples * 2; // stereo
		if (interleavedCapacityFrames < numSamples)
		{
			interleavedCapacityFrames = numSamples;
			interleavedInput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
			interleavedOutput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
		}

		// 4) Convert planar buffer to interleaved for processing
		auto* L = buffer.getReadPointer (0);
		auto* R = buffer.getNumChannels() > 1 ? buffer.getReadPointer (1) : L;
		for (int i = 0; i < numSamples; ++i)
		{
			interleavedInput[i * 2 + 0] = L[i];
			interleavedInput[i * 2 + 1] = R[i];
		}

		// 5) Process via time/pitch and write back to planar buffer
		timePitch.putInterleaved (interleavedInput.getData(), numSamples);
		const int framesOut = timePitch.receiveInterleaved (interleavedOutput.getData(), numSamples);
		buffer.clear();
		const int n = juce::jmin (framesOut, numSamples);
		auto* wL = buffer.getWritePointer (0);
		auto* wR = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : wL;
		for (int i = 0; i < n; ++i)
		{
			wL[i] = interleavedOutput[i * 2 + 0];
			wR[i] = interleavedOutput[i * 2 + 1];
		}
		if (n < numSamples)
		{
			if (buffer.getNumChannels() > 1)
			{
				buffer.clear (0, n, numSamples - n);
				buffer.clear (1, n, numSamples - n);
			}
			else
			{
				buffer.clear (n, numSamples - n);
			}
		}
    }

    ModularSynthProcessor* getModularSynth() { return modularSynth.get(); }

private:
    std::unique_ptr<ModularSynthProcessor> modularSynth;
    
    // Time/Pitch post-processing members (copied from SynthVoiceProcessor)
    TimePitchProcessor timePitch;
    juce::HeapBlock<float> interleavedInput, interleavedOutput;
    int interleavedCapacityFrames { 0 };
    // Stuttering members for time-stretch effect
    int stutterPos { 0 };
    double baseStutterMs { 80.0 }; // segment base length
    float stutterDuty { 0.35f };   // on-fraction of segment
};




================================================================================
FILE: juce\Source\audio\voices\NoiseVoiceProcessor.h
================================================================================


#pragma once
#include "../graph/VoiceProcessor.h"
#include <juce_dsp/juce_dsp.h>

class NoiseVoiceProcessor : public VoiceProcessor
{
public:
    NoiseVoiceProcessor() = default;
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void renderBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

private:
    juce::dsp::Oscillator<float> lfo { [] (float x) { return std::sin (x); } };
    juce::dsp::StateVariableTPTFilter<float> filter;
    juce::Random random;
};

================================================================================
FILE: juce\Source\audio\voices\NoiseVoiceProcessor.cpp
================================================================================


#include "NoiseVoiceProcessor.h"

void NoiseVoiceProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
	VoiceProcessor::prepareToPlay (sampleRate, samplesPerBlock);
	juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 2 };
	lfo.prepare (spec);
	lfo.setFrequency (0.3f);
	filter.reset();
	filter.prepare (spec);
	filter.setType (juce::dsp::StateVariableTPTFilterType::lowpass);
}

void NoiseVoiceProcessor::renderBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
	juce::ignoreUnused(midi);
	buffer.clear();
	const int n = buffer.getNumSamples();
	if (n <= 0) return;

	auto* L = buffer.getWritePointer(0);
	auto* R = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : L;
	for (int i = 0; i < n; ++i)
	{
		const float s = random.nextFloat() * 2.0f - 1.0f;
		L[i] = s;
		R[i] = s;
	}

	const float lfoSample = lfo.processSample (0.0f);
	const float cutoff = juce::jmap (lfoSample, -1.0f, 1.0f, 300.0f, 2000.0f);
	filter.setCutoffFrequency (cutoff);

	juce::dsp::AudioBlock<float> block (buffer);
	juce::dsp::ProcessContextReplacing<float> context (block);
	filter.process (context);
}


================================================================================
FILE: juce\Source\audio\voices\SampleVoiceProcessor.cpp
================================================================================


#include "SampleVoiceProcessor.h"
#include "../../utils/RtLogger.h"

SampleVoiceProcessor::SampleVoiceProcessor(std::shared_ptr<SampleBank::Sample> sampleToPlay)
    : sourceSample(std::move(sampleToPlay))
{
}

void SampleVoiceProcessor::prepareToPlay(double rate, int samplesPerBlock)
{
    // Prepare base FX chain, then set sample-rate specific state
    VoiceProcessor::prepareToPlay (rate, samplesPerBlock);
    juce::Logger::writeToLog("[SampleVoice] prepareToPlay sr=" + juce::String(rate) + ", block=" + juce::String(samplesPerBlock));
    outputSampleRate = rate;
    readPosition = 0.0;

    // Always run stretcher in stereo; duplicate mono content upstream
    timePitch.prepare (rate, 2, samplesPerBlock);
    interleavedCapacityFrames = samplesPerBlock;
    interleavedInput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
    interleavedOutput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
    // Reset smoothing state
    smoothedTimeRatio = 1.0f;
    smoothedPitchSemis = 0.0f;
    smoothingBlocksRemainingTime = 0;
    smoothingBlocksRemainingPitch = 0;

    // Defaults per current preferred settings
    setSmoothingEnabled (true);
    setSmoothingTimeMs (100.0f, 100.0f);
    setSmoothingAlpha (0.4f, 0.4f);
    setSmoothingMaxBlocks (1, 1);
    setSmoothingSnapThresholds (0.5f, 3.0f);
    setSmoothingResetPolicy (true, true);
}

void SampleVoiceProcessor::renderBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    RtLogger::postf("SVP render ns=%d", buffer.getNumSamples());
    buffer.clear();

    if (sourceSample == nullptr || sourceSample->stereo.getNumSamples() < 2 || outputSampleRate <= 0.0)
        return;

    const int numDestSamples = buffer.getNumSamples();
    auto& sourceBuffer = sourceSample->stereo;
    const int sourceLength = sourceBuffer.getNumSamples();

    // Apply UI smoothing toggle atomically at audio rate
    smoothingEnabled = requestedSmoothingEnabled.load(std::memory_order_relaxed);

    // Parameters to stretcher
    const float apTime = apvts.getRawParameterValue("timeStretchRatio") ? apvts.getRawParameterValue("timeStretchRatio")->load() : 1.0f;
    const float apPitch = apvts.getRawParameterValue("pitchSemitones") ? apvts.getRawParameterValue("pitchSemitones")->load() : 0.0f;
    const float effectiveTime = juce::jlimit(0.25f, 4.0f, apTime * zoneTimeStretchRatio);
    const float effectivePitchSemis = basePitchSemitones + apPitch;

    // If smoothing is disabled, apply parameters immediately
    if (!smoothingEnabled)
    { smoothedTimeRatio = effectiveTime; smoothedPitchSemis = effectivePitchSemis; if (resetOnChangeWhenNoSmoothing) timePitch.reset(); }
    else
    { smoothedTimeRatio = effectiveTime; smoothedPitchSemis = effectivePitchSemis; }

    timePitch.setTimeStretchRatio(smoothedTimeRatio);
    timePitch.setPitchSemitones(smoothedPitchSemis);

    // Branch engines cleanly: Naive vs RubberBand
    if (engine.load(std::memory_order_relaxed) == Engine::Naive)
    {
        auto* destL = buffer.getWritePointer(0);
        auto* destR = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : destL;
        auto* srcL = sourceBuffer.getReadPointer(0);
        auto* srcR = sourceBuffer.getNumChannels() > 1 ? sourceBuffer.getReadPointer(1) : srcL;
        const double pitchScale = std::pow(2.0, (double) effectivePitchSemis / 12.0);
        const double step = pitchScale / (double) juce::jmax(0.0001f, effectiveTime);
        for (int i = 0; i < numDestSamples; ++i)
        {
            int base = (int) readPosition;
            if (base >= sourceLength)
            {
                if (isLooping) { readPosition -= sourceLength; base -= sourceLength; }
                else { base = sourceLength - 1; }
            }
            const int next = juce::jmin(sourceLength - 1, base + 1);
            const float frac = (float) (readPosition - (double) base);
            const float l = srcL[base] + frac * (srcL[next] - srcL[base]);
            const float r = srcR[base] + frac * (srcR[next] - srcR[base]);
            destL[i] = l; if (destR) destR[i] = r; readPosition += step;
        }
        return;
    }

    // Ensure interleaved buffers large enough
    if (numDestSamples > interleavedCapacityFrames)
    {
        interleavedCapacityFrames = numDestSamples;
        interleavedInput.allocate((size_t)(interleavedCapacityFrames * 2), true);
        interleavedOutput.allocate((size_t)(interleavedCapacityFrames * 2), true);
    }

    float* inLR = interleavedInput.getData();
    auto* srcL = sourceBuffer.getReadPointer(0);
    auto* srcR = sourceBuffer.getNumChannels() > 1 ? sourceBuffer.getReadPointer(1) : srcL;

    // RubberBand path: feed contiguous raw frames equal to output block size
    int framesFed = 0;
    for (int i = 0; i < numDestSamples; ++i)
    {
        int pos = (int) readPosition;
        if (pos >= sourceLength)
        {
            if (isLooping)
            {
                readPosition -= sourceLength; pos -= sourceLength;
            }
            else break;
        }
        inLR[2 * i + 0] = srcL[pos];
        inLR[2 * i + 1] = srcR[pos];
        readPosition += 1.0;
        framesFed++;
    }

    if (framesFed > 0)
        timePitch.putInterleaved(inLR, framesFed);
    float* outLR = interleavedOutput.getData();
    int produced = timePitch.receiveInterleaved(outLR, numDestSamples);
    if (produced > 0)
    {
        auto* destL = buffer.getWritePointer(0);
        auto* destR = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : destL;
        for (int i = 0; i < produced; ++i)
        { destL[i] = outLR[2 * i + 0]; if (destR) destR[i] = outLR[2 * i + 1]; }
        if (produced < numDestSamples)
        { buffer.clear(0, produced, numDestSamples - produced); if (destR) buffer.clear(1, produced, numDestSamples - produced); }
    }
}




================================================================================
FILE: juce\Source\audio\voices\SampleVoiceProcessor.h
================================================================================


#pragma once
#include "../graph/VoiceProcessor.h"
#include <atomic>
#include "../assets/SampleBank.h"
#include "../dsp/TimePitchProcessor.h"

class SampleVoiceProcessor : public VoiceProcessor
{
public:
    SampleVoiceProcessor(std::shared_ptr<SampleBank::Sample> sampleToPlay);
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void renderBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void setLooping (bool shouldLoop) { isLooping = shouldLoop; }
    void setBasePitchSemitones (float semitones) { basePitchSemitones = semitones; }
    void setZoneTimeStretchRatio (float ratio) { zoneTimeStretchRatio = juce::jlimit (0.25f, 4.0f, ratio); }
    void setSourceName (const juce::String& name) { sourceName = name; }
    juce::String getSourceName () const { return sourceName; }

    // Smoothing controls
    void setSmoothingEnabled (bool enabled) { requestedSmoothingEnabled.store(enabled, std::memory_order_relaxed); }
    void setSmoothingTimeMs (float timeMs, float pitchMs) { smoothingTimeMsTime = timeMs; smoothingTimeMsPitch = pitchMs; }
    void setSmoothingAlpha (float alphaTime, float alphaPitch) { smoothingAlphaTime = alphaTime; smoothingAlphaPitch = alphaPitch; }
    void setSmoothingMaxBlocks (int maxBlocksTime, int maxBlocksPitch) { smoothingMaxBlocksTime = juce::jmax(1, maxBlocksTime); smoothingMaxBlocksPitch = juce::jmax(1, maxBlocksPitch); }
    void setSmoothingSnapThresholds (float timeRatioDelta, float pitchSemisDelta) { smoothingSnapThresholdTime = timeRatioDelta; smoothingSnapThresholdPitch = pitchSemisDelta; }
    void setSmoothingResetPolicy (bool resetOnLargeChange, bool resetWhenNoSmoothing) { resetOnSnap = resetOnLargeChange; resetOnChangeWhenNoSmoothing = resetWhenNoSmoothing; }

    // Engine selection
    enum class Engine { RubberBand = 0, Naive = 1 };
    void setEngine (Engine e)
    {
        Engine current = engine.load(std::memory_order_relaxed);
        if (current == e) return; // avoid resetting every block
        engine.store(e, std::memory_order_relaxed);
        timePitch.setMode(e==Engine::RubberBand? TimePitchProcessor::Mode::RubberBand : TimePitchProcessor::Mode::Fifo);
        timePitch.reset();
    }
    void setRubberBandOptions (bool windowShort, bool phaseIndependent) { timePitch.setOptions(windowShort, phaseIndependent); }

private:
    std::shared_ptr<SampleBank::Sample> sourceSample;
    juce::String sourceName;
    double readPosition { 0.0 };
    double outputSampleRate { 48000.0 };
    bool isLooping { true };
    float basePitchSemitones { 0.0f }; // grid-based pitch at spawn
    float zoneTimeStretchRatio { 1.0f }; // per-voice, dynamic (zones)
    float independentPitchRatio { 1.0f }; // pitch factor that does not affect tempo
    TimePitchProcessor timePitch; // placeholder; swap to SoundTouch impl later
    juce::HeapBlock<float> interleavedInput;
    juce::HeapBlock<float> interleavedOutput;
    int interleavedCapacityFrames { 0 };
    float lastEffectiveTime { 1.0f };
    float lastEffectivePitchSemis { 0.0f };
    // Smooth parameter transitions (independent for time & pitch)
    float smoothedTimeRatio { 1.0f };
    float smoothedPitchSemis { 0.0f };
    int   smoothingBlocksRemainingTime { 0 };
    int   smoothingBlocksRemainingPitch { 0 };
    float timeStepPerBlock { 0.0f };
    float pitchStepPerBlock { 0.0f };
    float smoothingTimeMsTime { 100.0f };  // defaults per user preference
    float smoothingTimeMsPitch { 100.0f };
    bool  smoothingEnabled { true };
    float smoothingAlphaTime { 0.4f };
    float smoothingAlphaPitch { 0.4f };
    int   smoothingMaxBlocksTime { 1 };
    int   smoothingMaxBlocksPitch { 1 };
    float smoothingSnapThresholdTime { 0.5f };    // time ratio delta to snap
    float smoothingSnapThresholdPitch { 3.0f };   // semitone delta to snap
    bool  resetOnSnap { true };
    bool  resetOnChangeWhenNoSmoothing { true };
    std::atomic<bool> requestedSmoothingEnabled { true };

    std::atomic<Engine> engine { Engine::RubberBand };
    // Fast handover state
    bool  inBypassHandover { false };
    int   handoverFramesRemaining { 0 };
    int   handoverCrossfadeFrames { 240 };
};

================================================================================
FILE: juce\Source\audio\voices\SynthVoiceProcessor.h
================================================================================


#pragma once
#include "../graph/VoiceProcessor.h"
#include "../dsp/TimePitchProcessor.h"

class SynthVoiceProcessor : public VoiceProcessor
{
public:
    SynthVoiceProcessor();
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void renderBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

private:
    double phase { 0.0 };
    double lastSampleRate { 48000.0 };
    TimePitchProcessor timePitch; // audio-level time/pitch like samples
    juce::HeapBlock<float> interleavedInput;
    juce::HeapBlock<float> interleavedOutput;
    int interleavedCapacityFrames { 0 };
    // Simple modulation so time-stretch is audible on synth
    double lfoPhase { 0.0 };
    double baseLfoRateHz { 3.0 }; // tremolo
    float tremoloDepth { 0.5f };   // 0..1
    // Stutter gate to strongly expose time scaling without changing pitch
    int stutterPos { 0 };
    double baseStutterMs { 80.0 }; // segment base length
    float stutterDuty { 0.35f };   // on-fraction of segment
};

================================================================================
FILE: juce\Source\audio\voices\SynthVoiceProcessor.cpp
================================================================================


#include "SynthVoiceProcessor.h"

SynthVoiceProcessor::SynthVoiceProcessor() = default;

void SynthVoiceProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
	// Ensure base class prepares FX chain and internal state
	VoiceProcessor::prepareToPlay (sampleRate, samplesPerBlock);
	lastSampleRate = sampleRate;
	phase = 0.0;
	// Prepare audio-level time/pitch like samples
	timePitch.prepare (sampleRate, 2, samplesPerBlock);
	interleavedCapacityFrames = samplesPerBlock;
	interleavedInput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
	interleavedOutput.allocate ((size_t) (interleavedCapacityFrames * 2), true);
}

void SynthVoiceProcessor::renderBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
	juce::ignoreUnused (midi);
    buffer.clear();

	const int numSamples = buffer.getNumSamples();
	if (numSamples <= 0)
		return;

	const float baseFreq = apvts.getRawParameterValue ("frequency") ? apvts.getRawParameterValue ("frequency")->load() : 440.0f;
	const float apPitch = apvts.getRawParameterValue ("pitchSemitones") ? apvts.getRawParameterValue ("pitchSemitones")->load() : 0.0f;
	const float apPitchRatio = apvts.getRawParameterValue ("pitchRatio") ? apvts.getRawParameterValue ("pitchRatio")->load() : 1.0f;
	const double oscPitchMul = (double) apPitchRatio * std::pow (2.0, (double) apPitch / 12.0);
	const double freq = juce::jlimit (20.0, 20000.0, (double) baseFreq * oscPitchMul);
	const double sr = lastSampleRate > 0.0 ? lastSampleRate : 48000.0;
	const double delta = juce::MathConstants<double>::twoPi * (double) freq / sr;

	auto* L = buffer.getWritePointer (0);
	auto* R = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : L;

    for (int i = 0; i < numSamples; ++i)
    {
        phase += delta;
        if (phase > juce::MathConstants<double>::twoPi)
            phase -= juce::MathConstants<double>::twoPi;
        const float s = std::sin ((float) phase);
        L[i] += s;
        R[i] += s;
    }
}




================================================================================
FILE: juce\Source\audio\dsp\TimePitchProcessor.h
================================================================================


// Facade exposing a unified API with two independent engines
#pragma once
#include <juce_core/juce_core.h>
#include <cmath>
#include <rubberband/RubberBandStretcher.h>

class TimePitchProcessor
{
public:
    enum class Mode { RubberBand, Fifo };

    void setMode(Mode m) { mode = m; }

    void prepare (double sampleRate, int numChannels, int blockSize)
    {
        rb.prepare (sampleRate, numChannels, blockSize, optWindowShort, optPhaseIndependent);
        fifo.prepare (sampleRate, numChannels);
    }

    void reset()
    {
        rb.reset();
        fifo.reset();
    }

    void setTimeStretchRatio (double ratio)
    {
        rb.setTimeStretchRatio (ratio);
        fifo.setTimeStretchRatio (ratio);
    }

    void setPitchSemitones (double semis)
    {
        rb.setPitchSemitones (semis);
        fifo.setPitchSemitones (semis);
    }

    int putInterleaved (const float* inputLR, int frames)
    {
        return (mode == Mode::RubberBand) ? rb.putInterleaved (inputLR, frames)
                                          : fifo.putInterleaved (inputLR, frames);
    }

    int receiveInterleaved (float* outLR, int framesRequested)
    {
        return (mode == Mode::RubberBand) ? rb.receiveInterleaved (outLR, framesRequested)
                                          : fifo.receiveInterleaved (outLR, framesRequested);
    }

    int availableFrames() const
    {
        return (mode == Mode::RubberBand) ? rb.availableFrames() : fifo.availableFrames();
    }

    void setOptions (bool windowShort, bool phaseIndependent)
    {
        optWindowShort = windowShort; optPhaseIndependent = phaseIndependent;
    }

private:
    // RubberBand engine
    struct RubberBandEngine {
        void prepare (double sampleRate, int numChannels, int blockSize, bool windowShort, bool phaseInd)
        {
            sr = sampleRate; channels = juce::jmax (1, numChannels);
            using RB = RubberBand::RubberBandStretcher;
            int opts = RB::OptionProcessRealTime | RB::OptionPitchHighQuality | RB::OptionFormantPreserved |
                       (windowShort ? RB::OptionWindowShort : RB::OptionWindowStandard) |
                       (phaseInd ? RB::OptionPhaseIndependent : 0);
            stretcher = std::make_unique<RB>((size_t) sr, (size_t) channels, (RB::Options) opts);
            stretcher->setPitchScale(1.0); stretcher->setTimeRatio(1.0);
            if (blockSize > 0) stretcher->setMaxProcessSize ((size_t) blockSize);
            planarInput.setSize (channels, juce::jmax (1, blockSize));
            planarOutput.setSize (channels, juce::jmax (1, blockSize * 2));
        }
        void reset() { if (stretcher) stretcher->reset(); }
        void setTimeStretchRatio (double ratio) { if (stretcher) stretcher->setTimeRatio (juce::jlimit(0.25,4.0,ratio)); }
        void setPitchSemitones (double semis) { if (stretcher) stretcher->setPitchScale (std::pow(2.0, juce::jlimit(-24.0,24.0,semis)/12.0)); }
        int putInterleaved (const float* inputLR, int frames)
        {
            if (!stretcher || frames<=0 || channels<=0) return 0;
            if (planarInput.getNumSamples() < frames) planarInput.setSize (channels, frames, false, true, true);
            for (int ch = 0; ch < channels; ++ch)
            {
                float* dest = planarInput.getWritePointer (ch);
                for (int i = 0; i < frames; ++i) dest[i] = inputLR[i * channels + ch];
            }
            stretcher->process (planarInput.getArrayOfReadPointers(), (size_t) frames, false);
            return frames;
        }
        int receiveInterleaved (float* outLR, int framesRequested)
        {
            if (!stretcher || framesRequested<=0 || channels<=0) return 0;
            const size_t avail = stretcher->available();
            const int toGet = (int) juce::jmin<size_t>((size_t) framesRequested, avail);
            if (toGet<=0) return 0;
            if (planarOutput.getNumSamples() < toGet) planarOutput.setSize (channels, toGet, false, true, true);
            stretcher->retrieve (planarOutput.getArrayOfWritePointers(), (size_t) toGet);
            for (int ch = 0; ch < channels; ++ch)
            {
                const float* src = planarOutput.getReadPointer (ch);
                for (int i = 0; i < toGet; ++i) outLR[i * channels + ch] = src[i];
            }
            return toGet;
        }
        int availableFrames() const { return stretcher ? (int) stretcher->available() : 0; }

        double sr { 48000.0 }; int channels { 2 };
        std::unique_ptr<RubberBand::RubberBandStretcher> stretcher;
        juce::AudioBuffer<float> planarInput, planarOutput;
    } rb;

    // FIFO naive engine
    struct FifoEngine {
        void prepare (double sampleRate, int numChannels) { sr = sampleRate; channels = juce::jmax(1,numChannels); reset(); }
        void reset() { fifo.clearQuick(); readFramePos = 0.0; }
        void setTimeStretchRatio (double ratio) { timeRatio = (float) juce::jlimit(0.25,4.0,ratio); }
        void setPitchSemitones (double semis) { pitchSemi = (float) juce::jlimit(-24.0,24.0,semis); }
        int putInterleaved (const float* inputLR, int frames)
        {
            const int samples = frames * channels; const int start = fifo.size();
            fifo.resize (start + samples);
            std::memcpy (fifo.getRawDataPointer() + start, inputLR, (size_t) samples * sizeof (float));
            return frames;
        }
        int receiveInterleaved (float* outLR, int framesRequested)
        {
            if (channels<=0) channels=2;
            const double pitchFactor = std::pow (2.0, (double) pitchSemi / 12.0);
            const double stepFrames  = (1.0 / (double) juce::jmax (0.001f, timeRatio)) * pitchFactor;
            const int availableFrames = (int) (fifo.size() / channels);
            int framesWritten = 0; float* out = outLR;
            while (framesWritten < framesRequested)
            {
                const int baseIdx = (int) std::floor (readFramePos);
                if (baseIdx + 1 >= availableFrames) break;
                const double frac = readFramePos - (double) baseIdx;
                const int idx0 = baseIdx * channels; const int idx1 = (baseIdx + 1) * channels;
                for (int ch = 0; ch < channels; ++ch)
                { const float s0 = fifo[idx0 + ch]; const float s1 = fifo[idx1 + ch]; out[ch] = (float)((1.0 - frac)*s0 + frac*s1); }
                out += channels; ++framesWritten; readFramePos += stepFrames;
            }
            const int framesConsumed = (int) std::floor (readFramePos);
            if (framesConsumed > 0)
            { const int samplesConsumed = framesConsumed * channels; const int remainingSamples = (int) fifo.size() - samplesConsumed;
              if (remainingSamples > 0) std::memmove (fifo.getRawDataPointer(), fifo.getRawDataPointer() + samplesConsumed, (size_t) remainingSamples * sizeof (float));
              fifo.resize (remainingSamples); readFramePos -= (double) framesConsumed; }
            return framesWritten;
        }
        int availableFrames() const { return (int) (fifo.size() / juce::jmax(1,channels)); }

        double sr { 48000.0 }; int channels { 2 }; float timeRatio { 1.0f }; float pitchSemi { 0.0f };
        juce::Array<float> fifo; double readFramePos { 0.0 };
    } fifo;

    Mode mode { Mode::RubberBand };
    bool optWindowShort { true }; bool optPhaseIndependent { true };
};



================================================================================
FILE: juce\Source\audio\utils\TapProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>

// Simple graph node that taps an audio signal and exposes its last block average
class TapProcessor : public juce::AudioProcessor
{
public:
    TapProcessor() : juce::AudioProcessor (BusesProperties().withInput ("In", juce::AudioChannelSet::mono(), true)) {}
    ~TapProcessor() override = default;

    const juce::String getName() const override { return "Tap"; }
    void prepareToPlay (double, int) override {}
    void releaseResources() override {}
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    bool hasEditor() const override { return false; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

    void processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override
    {
        if (buffer.getNumSamples() == 0) return;
        const float* d = buffer.getReadPointer (0);
        double sum = 0.0; for (int i = 0; i < buffer.getNumSamples(); ++i) sum += d[i];
        lastValue.store ((float) juce::jlimit (-1.0, 1.0, sum / (double) buffer.getNumSamples()));
    }

    float getLastValue() const { return lastValue.load(); }

private:
    std::atomic<float> lastValue { 0.0f };
};




================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_opengl/juce_opengl.h>
#include <unordered_map>
#include <tuple>
#include <imgui.h>

// Forward declarations from Dear ImGui / imnodes
struct ImGuiContext; struct ImGuiIO; struct ImNodesContext;
class ModularSynthProcessor;

// Forward declarations for pin database
struct AudioPin
{
    juce::String name;
    int channel;
};
struct ModPin;
struct ModulePinInfo
{
    std::vector<AudioPin> audioIns;
    std::vector<AudioPin> audioOuts;
    std::vector<ModPin> modIns;
};
extern std::map<juce::String, ModulePinInfo> modulePinDatabase;

class ImGuiNodeEditorComponent : public juce::Component,
                                 private juce::OpenGLRenderer
{
public:
    ImGuiNodeEditorComponent();
    ~ImGuiNodeEditorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    // Input is handled by imgui_juce backend; no JUCE overrides needed

    void setModel (ModularSynthProcessor* model) { synth = model; undoStack.clear(); redoStack.clear(); if (synth != nullptr) pushSnapshot(); }
    // UI state roundtrip
    juce::ValueTree getUiValueTree();
    // Thread-safe: queues UI state to be applied on next render frame
    void applyUiValueTree (const juce::ValueTree& uiState);

private:
    // OpenGLRenderer
    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;
    
    void handleRandomizePatch(); // Add this line
    void handleRandomizeConnections(); // Add this line

    void renderImGui();
    void handleDeletion();
    void startSaveDialog();
    void startLoadDialog();
    public: void applyUiValueTreeNow (const juce::ValueTree& uiState);
    // deprecated: parameters are now drawn inside nodes
    juce::String getTypeForLogical (juce::uint32 logicalId) const;
    void drawPendingModPopup();

    // --- New Bitmask-based Pin ID System ---
    struct PinID
    {
        juce::uint32 logicalId = 0;
        int channel = 0;
        bool isInput = false;
        bool isMod = false;
    };

    // Define how the 32 bits of an integer are allocated
    constexpr static int LOGICAL_ID_BITS = 16;
    constexpr static int CHANNEL_BITS = 8;
    constexpr static int IS_INPUT_BITS = 1;
    constexpr static int IS_MOD_BITS = 1;

    constexpr static int LOGICAL_ID_SHIFT = 0;
    constexpr static int CHANNEL_SHIFT = LOGICAL_ID_SHIFT + LOGICAL_ID_BITS;
    constexpr static int IS_INPUT_SHIFT = CHANNEL_SHIFT + CHANNEL_BITS;
    constexpr static int IS_MOD_SHIFT = IS_INPUT_SHIFT + IS_INPUT_BITS;

    // New encoder/decoder functions
    static int encodePinID(const PinID& id)
    {
        return (int)( (id.logicalId << LOGICAL_ID_SHIFT) |
                      (id.channel   << CHANNEL_SHIFT)   |
                      ((int)id.isInput  << IS_INPUT_SHIFT)   |
                      ((int)id.isMod    << IS_MOD_SHIFT) );
    }

    static PinID decodePinID(int attr)
    {
        PinID id;
        id.logicalId = (attr >> LOGICAL_ID_SHIFT) & ((1 << LOGICAL_ID_BITS) - 1);
        id.channel   = (attr >> CHANNEL_SHIFT)   & ((1 << CHANNEL_BITS) - 1);
        id.isInput   = (attr >> IS_INPUT_SHIFT)  & 1;
        id.isMod     = (attr >> IS_MOD_SHIFT)    & 1;
        return id;
    }


    juce::OpenGLContext glContext;
    ImGuiContext* imguiContext { nullptr };
    ImGuiIO* imguiIO { nullptr };
    ImNodesContext* editorContext { nullptr };
    double lastTime { 0.0 };

    ModularSynthProcessor* synth { nullptr };
    juce::ValueTree uiPending; // applied at next render before drawing nodes
    std::atomic<bool> graphNeedsRebuild { false };

    // Selection state
    int selectedLogicalId { 0 };

    std::unique_ptr<juce::FileChooser> saveChooser, loadChooser;

    // Map of linkId -> (srcAttr, dstAttr) populated each frame
    std::unordered_map<int, std::pair<int,int>> linkIdToAttrs;

    // Positions to apply for specific node IDs on the next render (grid space)
    std::unordered_map<int, ImVec2> pendingNodePositions;
    // Screen-space positions queued for just-created nodes (converted after draw)
    std::unordered_map<int, ImVec2> pendingNodeScreenPositions;
    // Modulation link id mapping to (srcLogicalId, srcChan, dstLogicalId)
    std::unordered_map<int, std::tuple<int,int,int>> modLinkIdToRoute;
    // Map of mod input attribute id -> (dstLogicalId, paramId)
    std::unordered_map<int, std::pair<int, juce::String>> modAttrToParam;

    struct PendingMod
    {
        bool open { false };
        int srcLogicalId { 0 };
        int srcChan { 0 };
        int dstLogicalId { 0 };
        int paramIndex { 0 };
        float depth { 50.0f };
        juce::StringArray params; // ids in order
    } pendingMod;

    // UI state / hover
    int lastHoveredNodeId { -1 };
    bool isDraggingNode { false };
    bool snapshotAfterEditor { false }; // arm when action requires node to exist (add/duplicate)
    // zoom/pan disabled

    // --- Undo/Redo (module ops) ---
    struct Snapshot
    {
        juce::MemoryBlock synthState;
        juce::ValueTree   uiState;
    };
    std::vector<Snapshot> undoStack;
    std::vector<Snapshot> redoStack;
    void pushSnapshot();
    void restoreSnapshot (const Snapshot& s);
};




================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.cpp
================================================================================


#include "ImGuiNodeEditorComponent.h"

#include <imgui.h>
#include <imnodes.h>
#include <unordered_map>
#include <unordered_set>
#include <cstdint>
#include <algorithm>
#include "../audio/graph/ModularSynthProcessor.h"
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>

// ADD ALL OF THIS CODE:

// --- Structs to define a module's connection points ---

struct ModPin
{
    juce::String name;
    juce::String paramId;
};


// --- A map to hold the pin info for every module type ---
std::map<juce::String, ModulePinInfo> modulePinDatabase;

// --- A function to populate the database ---
void populatePinDatabase()
{
    if (!modulePinDatabase.empty()) return; // Only run once

    modulePinDatabase["VCO"] = {
        {}, // No audio inputs
        { {"Out L", 0}, {"Out R", 1} },
        { {"Frequency", "frequency"}, {"Waveform", "waveform_mod"} }
    };
    modulePinDatabase["VCF"] = {
        { {"In L", 0}, {"In R", 1} },
        { {"Out L", 0}, {"Out R", 1} },
        { {"Cutoff", "cutoff"}, {"Resonance", "resonance"}, {"Type", "type_mod"} }
    };
    modulePinDatabase["VCA"] = {
        { {"In L", 0}, {"In R", 1} },
        { {"Out L", 0}, {"Out R", 1} },
        { {"Gain", "gain"} }
    };
    modulePinDatabase["Noise"] = {
        {},
        { {"Out L", 0}, {"Out R", 1} },
        { {"Level", "level"}, {"Colour", "colour_mod"} }
    };
    modulePinDatabase["LFO"] = {
        {},
        { {"Out L", 0}, {"Out R", 1} },
        { {"Rate Mod", "rate_mod"}, {"Depth Mod", "depth_mod"}, {"Wave Mod", "wave_mod"} }
    };
    modulePinDatabase["ADSR"] = {
        { {"Gate In", 0} },
        { {"Out L", 0}, {"Out R", 1}, {"EOR Gate", 2} },
        { {"Attack Mod", "attack_mod"}, {"Decay Mod", "decay_mod"}, {"Sustain Mod", "sustain_mod"}, {"Release Mod", "release_mod"} }
    };
    modulePinDatabase["Delay"] = {
        { {"In L", 0}, {"In R", 1} },
        { {"Out L", 0}, {"Out R", 1} },
        { {"Time", "timeMs"}, {"Feedback", "feedback"}, {"Mix", "mix"} }
    };
    modulePinDatabase["Reverb"] = {
        { {"In L", 0}, {"In R", 1} },
        { {"Out L", 0}, {"Out R", 1} },
        { {"Size", "size"}, {"Damp", "damp"}, {"Mix", "mix"} }
    };
    modulePinDatabase["Mixer"] = {
        { {"In A L", 0}, {"In A R", 1}, {"In B L", 2}, {"In B R", 3} },
        { {"Out L", 0}, {"Out R", 1} },
        { {"Gain", "gain"}, {"Pan", "pan"}, {"X-Fade", "crossfade"} }
    };
    modulePinDatabase["Sequencer"] = {
        {},
        { {"Pitch", 0}, {"Gate", 1}, {"Velocity", 2}, {"Mod", 3} },
        { {"Rate Mod", "rate_mod"}, {"Gate Mod", "gateLength_mod"}, {"Steps Mod", "numSteps_mod"} }
    };
    modulePinDatabase["Value"] = {
        {},
        { {"Raw", 0}, {"Normalized", 1}, {"Inverted", 2}, {"Integer", 3} },
        {}
    };
    modulePinDatabase["Random"] = {
        { {"Trigger In", 0} },
        { {"Norm Out", 0}, {"Raw Out", 1} },
        { {"Rate Mod", "rate_mod"} }
    };
    modulePinDatabase["tts"] = {
        { {"Gate In", 0} }, // Add this audio input
        { {"Audio L", 0}, {"Audio R", 1} },
        {}  // No modulation inputs
    };
    modulePinDatabase["TTS Performer"] = {
        { {"Gate In", 0} }, // Audio inputs
        { {"Audio L", 0}, {"Audio R", 1}, {"EOP Gate", 2} }, // Audio outputs
        { 
            {"Speed", "speed"}, {"Pitch", "pitch"}, {"Start", "start"}
        } // Modulation inputs
    };
    modulePinDatabase["Vocal Tract Filter"] = {
        { {"Audio In L", 0}, {"Audio In R", 1} }, // Audio inputs
        { {"Audio Out L", 0}, {"Audio Out R", 1} }, // Audio outputs
        { 
            {"Vowel", "vowelShape"}, {"Formant", "formantShift"}, 
            {"Instability", "instability"}, {"Gain", "formantGain"} 
        } // Modulation inputs
    };
    // Add other modules here if you have more...
}

ImGuiNodeEditorComponent::ImGuiNodeEditorComponent()
{
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    glContext.detach();
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}

// Input handled by imgui_juce backend

void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    ImGui::StyleColorsDark();

    // --- FONT LOADING FOR CHINESE CHARACTERS ---
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->AddFontDefault(); // Load default English font

    // Define the path to your new font file
    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
    auto fontFile = appFile.getParentDirectory().getChildFile("../../Source/assets/NotoSansSC-VariableFont_wght.ttf");

    if (fontFile.existsAsFile())
    {
        ImFontConfig config;
        config.MergeMode = true; // IMPORTANT: This merges the new font into the default one
        config.PixelSnapH = true;

        // Define the character ranges to load for Chinese
        static const ImWchar ranges[] = { 0x4e00, 0x9fbf, 0, }; // Basic CJK Unified Ideographs

        io.Fonts->AddFontFromFileTTF(fontFile.getFullPathName().toRawUTF8(), 16.0f, &config, ranges);
        juce::Logger::writeToLog("ImGuiNodeEditor: Chinese font loaded successfully");
    }
    else
    {
        juce::Logger::writeToLog("ImGuiNodeEditor: WARNING - Chinese font not found at: " + fontFile.getFullPathName());
    }
    
    // --- END OF FONT LOADING ---

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    
    // Build fonts after renderer is initialized
    io.Fonts->Build();

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);
}

void ImGuiNodeEditorComponent::renderImGui()
{
    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus);

    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            ImGui::Separator();
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }

    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, 260.0f);

    // Zoom removed

    // ADD THIS BLOCK:
    ImGui::Text("Module Browser");
    ImGui::Separator();
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
    };
    if (ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen)) {
    addModuleButton("VCO", "VCO");
    addModuleButton("Noise", "Noise");
        addModuleButton("Sequencer", "Sequencer");
        addModuleButton("Value", "Value");
        addModuleButton("Sample Loader", "sample loader");
    }
    if (ImGui::CollapsingHeader("TTS Family", ImGuiTreeNodeFlags_DefaultOpen)) {
        addModuleButton("TTS", "TTS");
        addModuleButton("TTS Performer", "TTS Performer");
        addModuleButton("Vocal Tract Filter", "Vocal Tract Filter");
    }
    if (ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen)) {
        addModuleButton("VCF", "VCF");
        // addModuleButton("Vocal Tract Filter", "Vocal Tract Filter");
        addModuleButton("Delay", "Delay");
        addModuleButton("Reverb", "Reverb");
        addModuleButton("Waveshaper", "Waveshaper");
    }
    if (ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen)) {
        addModuleButton("LFO", "LFO");
        addModuleButton("ADSR", "ADSR");
        addModuleButton("Random", "Random");
    addModuleButton("S&H", "S&H");
    }
    if (ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen)) {
        addModuleButton("VCA", "VCA");
        addModuleButton("Mixer", "Mixer");
    addModuleButton("Attenuverter", "Attenuverter");
        addModuleButton("Math", "Math");
        addModuleButton("Map Range", "MapRange");
        addModuleButton("Quantizer", "Quantizer");
        addModuleButton("Rate", "Rate");
        addModuleButton("Logic", "Logic");
        addModuleButton("Clock Divider", "ClockDivider");
        addModuleButton("Sequential Switch", "SequentialSwitch");
    }
    if (ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen)) {
    addModuleButton("Scope", "Scope");
    }


    ImGui::NextColumn();

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinID({c.srcLogicalId, c.srcChan, false, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinID({0, c.dstChan, true, false}) : 
                encodePinID({c.dstLogicalId, c.dstChan, true, false});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = IM_COL32(150, 150, 150, 255); // Grey for disconnected
    const ImU32 colPinConnected = IM_COL32(120, 255, 120, 255); // Green for connected
    // <<< END OF BLOCK >>>

    // Node canvas bound to the underlying model if available
    ImNodes::BeginNodeEditor();
    // Begin the editor

    linkIdToAttrs.clear();
    // Rebuild mod attribute mapping from currently drawn nodes only
    modAttrToParam.clear();
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    auto linkIdOf = [] (int srcAttr, int dstAttr) -> int
    {
        const int64_t key = ((int64_t) srcAttr << 32) ^ (int64_t) dstAttr;
        return (int) (key ^ (key >> 33));
    };

    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;

            ImNodes::BeginNode ((int) lid);
            ImNodes::BeginNodeTitleBar();
            ImGui::TextUnformatted (type.toRawUTF8());
            ImNodes::EndNodeTitleBar();

            // Constrain node content width for compact layout and predictable label placement
            const float nodeContentWidth = 240.0f;

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
            if (auto* mp = synth->getModuleForLogical (lid))
            {
                ImGui::PushID ((int) lid);

                // This new lambda function checks if a parameter is being modulated
                auto isParamModulated = [&](const juce::String& paramId) {
                    for (const auto& route : synth->getModRoutesInfo()) {
                        if (route.dstLogicalId == lid && route.paramId == paramId) {
                            return true;
                        }
                    }
                    return false;
                };

                // Create a new function that calls pushSnapshot
                auto onModificationEnded = [&](){ this->pushSnapshot(); };

                // Pass both functions to the module's drawing code
                mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);

                // Small spacing before IO pins
                ImGui::Spacing();
                ImGui::PopID();
                }
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
                auto rightLabelWithinWidth = [&](const char* txt)
                {
                    const float startX = ImGui::GetCursorPosX();
                    const ImVec2 ts = ImGui::CalcTextSize(txt);
                    float x = startX + juce::jmax (0.0f, nodeContentWidth - ts.x - 8.0f);
                    ImGui::SetCursorPosX(x);
                    ImGui::TextUnformatted(txt);
                };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinID({(juce::uint32)lid, channel, true, false});
                availableAttrs.insert(attr);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : colPin);
                
                ImNodes::BeginInputAttribute(attr); ImGui::TextUnformatted(label); ImNodes::EndInputAttribute();

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                {
                                    float value = srcMod->getOutputChannelValue(c.srcChan);
                                    ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                    ImGui::Text("Value: %.3f", value);
                                }
                                break; 
                            }
                        }
                    } else {
                        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                    }
                    ImGui::EndTooltip();
                }
            };
            helpers.drawAudioOutputPin = [&](const char* label, int channel)
            {
                int attr = encodePinID({(juce::uint32)lid, channel, false, false});
                availableAttrs.insert(attr);

                bool isConnected = connectedOutputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : colPin);

                ImNodes::BeginOutputAttribute(attr); rightLabelWithinWidth(label); ImNodes::EndOutputAttribute();
                
                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                    } else {
                        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                    }
                    // Show the existing value tooltip
                    if (auto* mp = synth->getModuleForLogical(lid))
                    {
                        float value = mp->getOutputChannelValue(channel);
                        ImGui::Text("Value: %.3f", value);
                    }
                    ImGui::EndTooltip();
                }
            };
            helpers.drawModulationInputPin = [&](const char* label, const juce::String& parameterID)
            {
                // Use parameter index in the processor to build a stable mod attr id
                int paramIndex = -1;
                if (auto* mp = synth->getModuleForLogical (lid))
                {
                    auto params = mp->getParameters();
                    for (int i = 0; i < params.size(); ++i)
                        if (auto* p = dynamic_cast<juce::AudioProcessorParameterWithID*>(params[i]))
                            if (p->paramID == parameterID) { paramIndex = i; break; }
                }
                if (paramIndex < 0) return;
                int attr = encodePinID({(juce::uint32)lid, paramIndex, true, true});
                availableAttrs.insert(attr);
                modAttrToParam[attr] = { (int) lid, parameterID };

                // Check if this parameter is being modulated using the new helper function
                bool isModulated = synth->isParameterModulated(lid, parameterID);
                ImNodes::PushColorStyle(ImNodesCol_Pin, isModulated ? colPinConnected : colPin);
                
                ImNodes::BeginInputAttribute(attr); ImGui::TextUnformatted(label); ImNodes::EndInputAttribute();

                ImNodes::PopColorStyle(); // Restore default color
            };

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                    mp->drawIoPins(helpers);

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
            if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
            {
                ImNodes::SetNodeGridSpacePos((int) lid, it->second);
                pendingNodePositions.erase(it);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0)
            {
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                // Post-state snapshot
                pushSnapshot();
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    // Post-state snapshot after duplication and position
                    pushSnapshot();
                }
            }
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted ("Output");
        ImNodes::EndNodeTitleBar();
        { int a = encodePinID({0, 0, true, false}); availableAttrs.insert(a); ImNodes::BeginInputAttribute (a);
        ImGui::Text ("In L");
        ImNodes::EndInputAttribute(); }
        { int a = encodePinID({0, 1, true, false}); availableAttrs.insert(a); ImNodes::BeginInputAttribute (a);
        ImGui::Text ("In R");
        ImNodes::EndInputAttribute(); }
        ImNodes::EndNode();
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            pendingNodePositions.erase(it);
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections
        for (const auto& c : synth->getConnectionsInfo())
        {
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) continue;
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) continue;
            const int srcAttr = encodePinID({c.srcLogicalId, c.srcChan, false, false});
            const int dstAttr = c.dstIsOutput ? encodePinID({0, c.dstChan, true, false}) : encodePinID({c.dstLogicalId, c.dstChan, true, false});
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
                continue;
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle (ImNodesCol_Link, IM_COL32(255, 255, 0, 255));
                ImNodes::PushColorStyle (ImNodesCol_LinkSelected, IM_COL32(255, 255, 0, 255));
            }
            ImNodes::Link (linkId, srcAttr, dstAttr);
            if (hl)
            {
                ImNodes::PopColorStyle();
                ImNodes::PopColorStyle();
            }
        }

        // Draw modulation links with distinct IDs and color
        const ImU32 modCol = IM_COL32 (255, 105, 180, 200); // hot pink
        const ImU32 modColSel = IM_COL32 (255, 165, 200, 255);
        int modBase = 1000000;
        modLinkIdToRoute.clear();
        for (const auto& r : synth->getModRoutesInfo())
        {
            if (r.srcLogicalId != 0 && ! drawnNodes.count((int) r.srcLogicalId)) continue;
            const int srcAttr = encodePinID({r.srcLogicalId, r.srcChan, false, false});
            int dstAttr = -1;
            for (const auto& kv : modAttrToParam)
            {
                if (kv.second.first == (int) r.dstLogicalId && kv.second.second == r.paramId)
                { dstAttr = kv.first; break; }
            }
            if (dstAttr == -1 || ! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr)) continue; // attributes not created this frame
            const int id = modBase++;
            const bool hl = (hoveredNodeId != -1) && ((int) r.srcLogicalId == hoveredNodeId || (int) r.dstLogicalId == hoveredNodeId);
            ImU32 useCol = hl ? IM_COL32(255, 255, 0, 255) : modCol;
            ImU32 useSel = hl ? IM_COL32(255, 255, 0, 255) : modColSel;
            ImNodes::PushColorStyle (ImNodesCol_Link, useCol);
            ImNodes::PushColorStyle (ImNodesCol_LinkSelected, useSel);
            ImNodes::Link (id, srcAttr, dstAttr);
            ImNodes::PopColorStyle();
            ImNodes::PopColorStyle();
            modLinkIdToRoute[id] = std::make_tuple ((int) r.srcLogicalId, r.srcChan, (int) r.dstLogicalId);
        }
        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    ImNodes::MiniMap (0.2f, ImNodesMiniMapLocation_BottomRight);
    ImNodes::EndNodeEditor();

    // Deferred graph rebuild (once per frame)
    if (graphNeedsRebuild.load())
    {
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false;
    }

    // Update hovered node id for next frame (must be called outside editor scope)
    {
        int hv = -1;
        if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }

    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered())
        {
                ImGui::OpenPopup("AddModulePopup");
        }

        if (ImGui::BeginPopup("AddModulePopup"))
        {
            auto addAtMouse = [this](const char* type) {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                snapshotAfterEditor = true;
            };

            if (ImGui::BeginMenu("Sources")) {
                if (ImGui::MenuItem("VCO")) addAtMouse("VCO");
            if (ImGui::MenuItem("Noise")) addAtMouse("Noise");
                if (ImGui::MenuItem("Sequencer")) addAtMouse("Sequencer");
                if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample loader");
                if (ImGui::MenuItem("TTS")) addAtMouse("TTS");
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("TTS")) {
                if (ImGui::MenuItem("TTS Performer")) addAtMouse("TTS Performer");
                if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("Vocal Tract Filter");
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Effects")) {
                if (ImGui::MenuItem("VCF")) addAtMouse("VCF");
            if (ImGui::MenuItem("Delay")) addAtMouse("Delay");
            if (ImGui::MenuItem("Reverb")) addAtMouse("Reverb");
                if (ImGui::MenuItem("Waveshaper")) addAtMouse("Waveshaper");
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Modulators")) {
                if (ImGui::MenuItem("LFO")) addAtMouse("LFO");
                if (ImGui::MenuItem("ADSR")) addAtMouse("ADSR");
                if (ImGui::MenuItem("Random")) addAtMouse("Random");
                if (ImGui::MenuItem("S&H")) addAtMouse("S&H");
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Utilities & Logic")) {
                if (ImGui::MenuItem("VCA")) addAtMouse("VCA");
                if (ImGui::MenuItem("Mixer")) addAtMouse("Mixer");
                if (ImGui::MenuItem("Attenuverter")) addAtMouse("Attenuverter");
                if (ImGui::MenuItem("Math")) addAtMouse("Math");
                if (ImGui::MenuItem("Map Range")) addAtMouse("MapRange");
                if (ImGui::MenuItem("Quantizer")) addAtMouse("Quantizer");
                if (ImGui::MenuItem("Rate")) addAtMouse("Rate");
                if (ImGui::MenuItem("Logic")) addAtMouse("Logic");
                if (ImGui::MenuItem("Clock Divider")) addAtMouse("ClockDivider");
                if (ImGui::MenuItem("Sequential Switch")) addAtMouse("SequentialSwitch");
                ImGui::EndMenu();
            }
            if (ImGui::BeginMenu("Analysis")) {
                if (ImGui::MenuItem("Scope")) addAtMouse("Scope");
                ImGui::EndMenu();
            }
            ImGui::EndPopup();
        }

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinID(startAttr);
            auto endPin = decodePinID(endAttr);

            // Determine which pin is the source (output) and which is the destination (input)
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // A valid connection must be from an output to an input
            if (srcPin.isInput || !dstPin.isInput) {
                // This is an invalid connection (e.g., input-to-input), so we do nothing.
            } else {
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                
                if (srcNode.uid != 0 && dstNode.uid != 0) {
                    // Check if the destination is a modulation pin
                    if (dstPin.isMod) {
                        int modAttrId = startPin.isInput ? startAttr : endAttr;
                        if (auto itP = modAttrToParam.find(modAttrId); itP != modAttrToParam.end()) {
                            const auto& [dstLid, param] = itP->second;
                            synth->addModulationRouteByLogical(srcPin.logicalId, srcPin.channel, (juce::uint32)dstLid, param);
                            pushSnapshot();
                        }
                    } else { // It's a standard audio/CV connection
                        if (synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel)) {
                            graphNeedsRebuild = true;
                            pushSnapshot();
                        }
                    }
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            // Try modulation map first
            if (auto itM = modLinkIdToRoute.find (linkId); itM != modLinkIdToRoute.end())
            {
                auto [sL, sC, dL] = itM->second;
                synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
                graphNeedsRebuild = true;
                pushSnapshot();
                // Remove from local map to avoid stale draw this frame
                modLinkIdToRoute.erase (itM);
                // Skip drawing pass will filter leftover
            }
            else if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinID(it->second.first);
                auto dstPin = decodePinID(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                graphNeedsRebuild = true;
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)

        // Keyboard shortcuts
        const bool ctrl = ImGui::GetIO().KeyCtrl;
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_S)) { startSaveDialog(); }
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_O)) { startLoadDialog(); }
        if (ctrl && ImGui::IsKeyPressed(ImGuiKey_P)) { handleRandomizePatch(); }
        if (ctrl && ImGui::IsKeyPressed(ImGuiKey_M)) { handleRandomizeConnections(); }

        // Undo / Redo (Ctrl+Z / Ctrl+Y)
    if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Z))
        {
            if (undoStack.size() > 1)
            {
                Snapshot current = undoStack.back();
                redoStack.push_back (current);
                undoStack.pop_back();
                restoreSnapshot (undoStack.back());
                // After a restore, clear transient link maps only; keep pending positions so they apply next frame
                linkIdToAttrs.clear();
                modLinkIdToRoute.clear();
            }
        }
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Y))
        {
            if (! redoStack.empty())
            {
                Snapshot s = redoStack.back(); redoStack.pop_back();
                restoreSnapshot (s);
                undoStack.push_back (s);
                linkIdToAttrs.clear();
                modLinkIdToRoute.clear();
            }
        }

        // Duplicate selected nodes (Ctrl+D)
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_D))
        {
            const int n = ImNodes::NumSelectedNodes();
            if (n > 0)
            {
                std::vector<int> sel((size_t) n);
                ImNodes::GetSelectedNodes(sel.data());
                for (int oldId : sel)
                {
                    if (oldId == 0) continue;
                    const juce::String type = getTypeForLogical ((juce::uint32) oldId);
                    if (type.isEmpty()) continue;
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    const juce::uint32 newLogical = synth->getLogicalIdForNode (newNodeId);
                    if (newLogical != 0)
                    {
                        if (auto* src = synth->getModuleForLogical ((juce::uint32) oldId))
                            if (auto* dst = synth->getModuleForLogical (newLogical))
                                dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                        // Position offset
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos (oldId);
                        pendingNodePositions[(int) newLogical] = ImVec2 (pos.x + 40.0f, pos.y + 40.0f);
                    }
                }
            }
        }

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }

    ImGui::End();
    drawPendingModPopup();

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed

void ImGuiNodeEditorComponent::drawPendingModPopup()
{
    if (! pendingMod.open) return;
    ImGui::OpenPopup ("Create Modulation");
    if (ImGui::BeginPopupModal ("Create Modulation", &pendingMod.open, ImGuiWindowFlags_AlwaysAutoResize))
    {
        const char* preview = pendingMod.params.size() > 0 ? pendingMod.params[pendingMod.paramIndex].toRawUTF8() : "param";
        if (ImGui::BeginCombo ("Target", preview))
        {
            for (int i = 0; i < pendingMod.params.size(); ++i)
            {
                const bool sel = (i == pendingMod.paramIndex);
                if (ImGui::Selectable (pendingMod.params[i].toRawUTF8(), sel)) pendingMod.paramIndex = i;
                if (sel) ImGui::SetItemDefaultFocus();
            }
            ImGui::EndCombo();
        }
        ImGui::SliderFloat ("Depth", &pendingMod.depth, -200.0f, 200.0f);
        if (ImGui::Button ("Add"))
        {
            if (pendingMod.paramIndex >= 0 && pendingMod.paramIndex < pendingMod.params.size())
                synth->addModulationRouteByLogical ((juce::uint32) pendingMod.srcLogicalId, pendingMod.srcChan, (juce::uint32) pendingMod.dstLogicalId, pendingMod.params[pendingMod.paramIndex], pendingMod.depth);
            pendingMod.open = false;
        }
        ImGui::SameLine();
        if (ImGui::Button ("Cancel")) pendingMod.open = false;
        ImGui::EndPopup();
    }
}

juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree()
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        const ImVec2 pos = ImNodes::GetNodeGridSpacePos(nid);
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        ui.addChild (n, -1, nullptr);
    }
    return ui;
}

void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid()) return;
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);
        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        pendingNodePositions[nid] = ImVec2(x, y);
    }
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    // Use new key query API (1.90+)
    if (! ImGui::IsKeyPressed(ImGuiKey_Delete))
        return;

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
                {
                    auto [sL, sC, dL] = itM->second;
                    synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            }
            else if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinID(it->second.first);
                auto dstPin = decodePinID(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
}

void ImGuiNodeEditorComponent::startSaveDialog()
{
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", juce::File(), "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (! f.exists() && ! f.getParentDirectory().exists()) return;
        if (synth == nullptr) return;
        juce::MemoryBlock mb; synth->getStateInformation (mb);
        auto xml = juce::XmlDocument::parse (mb.toString());
        if (! xml) return;
        juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
        presetVT.addChild (getUiValueTree(), -1, nullptr);
        f.replaceWithText (presetVT.createXml()->toString());
    });
}

void ImGuiNodeEditorComponent::startLoadDialog()
{
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", juce::File(), "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (! f.existsAsFile()) return;
        juce::MemoryBlock mb; f.loadFileAsData (mb);
        if (synth != nullptr)
            synth->setStateInformation (mb.getData(), (int) mb.getSize());
            juce::ValueTree ui;
            if (auto xml = juce::XmlDocument::parse (mb.toString()))
            {
                auto vt = juce::ValueTree::fromXml (*xml);
                ui = vt.getChildWithName ("NodeEditorUI");
                if (ui.isValid())
                    applyUiValueTree (ui);
        }
        // Post-state snapshot: capture loaded synth + the UI positions from file
        Snapshot s;
        if (synth != nullptr) synth->getStateInformation (s.synthState);
        s.uiState = ui.isValid() ? ui : getUiValueTree();
        undoStack.push_back (std::move (s));
        redoStack.clear();
    });
}

void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "VCO", "Noise", "Sequencer", "VCF", "Delay", "Reverb", "Waveshaper",
        "LFO", "ADSR", "Random", "S&H", "Math", "MapRange", "Quantizer", "ClockDivider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("Mixer"));
    addedModules.push_back({mixerId, "Mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("Scope"));
    addedModules.push_back({scopeId, "Scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = modulePinDatabase.find(mod.second);
        if (it != modulePinDatabase.end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "Mixer") finalMixerId = mod.first;
        if (mod.second == "Scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "Mixer") mixerId = mod.first;
        if (mod.second == "Scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("Mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("Scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = modulePinDatabase.find(mod.second);
        if (it != modulePinDatabase.end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}


================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "../audio/graph/ModularSynthProcessor.h"

class PresetCreatorComponent : public juce::Component,
                               private juce::Button::Listener,
                               private juce::Timer
{
public:
    PresetCreatorComponent();
    ~PresetCreatorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    bool keyPressed (const juce::KeyPress& key) override;
    bool keyStateChanged (bool isKeyDown) override;
    void visibilityChanged() override;

private:
    void buttonClicked (juce::Button*) override;
    void timerCallback() override;
    void refreshModulesList();
    void doConnect();
    void doSave();
    void doLoad();
    void startAudition();
    void stopAudition();

    juce::TextButton btnAddVCO { "Add VCO" };
    juce::TextButton btnAddVCF { "Add VCF" };
    juce::TextButton btnAddVCA { "Add VCA" };
    juce::TextButton btnConnect { "Connect" };
    juce::TextButton btnSave { "Save Preset" };
    juce::TextButton btnLoad { "Load Preset" };

    juce::ListBox listModules { "Modules", nullptr };
    struct ModulesModel : public juce::ListBoxModel
    {
        juce::StringArray rows;
        int getNumRows() override { return rows.size(); }
        void paintListBoxItem (int row, juce::Graphics& g, int w, int h, bool sel) override
        {
            g.fillAll (sel ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
            g.setColour (juce::Colours::white);
            if (row >= 0 && row < rows.size()) g.drawText (rows[row], 6, 0, w - 12, h, juce::Justification::centredLeft);
        }
    } modulesModel;

    juce::ComboBox cbSrc, cbDst, cbSrcChan, cbDstChan;
    juce::TextEditor log;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<class ImGuiNodeEditorComponent> editor;

    std::unique_ptr<ModularSynthProcessor> synth;
    double sampleRate { 48000.0 };
    int blockSize { 512 };

    std::unique_ptr<juce::FileChooser> saveChooser;
    std::unique_ptr<juce::FileChooser> loadChooser;

    juce::AudioDeviceManager deviceManager;
    juce::AudioProcessorPlayer processorPlayer;
    bool auditioning { false };
};




================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.cpp
================================================================================


// RtLogger flush integrated via timer in component
#include "PresetCreatorComponent.h"
#include "ImGuiNodeEditorComponent.h"
#include "../utils/RtLogger.h"

PresetCreatorComponent::PresetCreatorComponent()
{
    juce::Logger::writeToLog("PresetCreatorComponent constructor starting...");
    addAndMakeVisible (log);

    // Replace list/combos UI with ImGui node editor
    juce::Logger::writeToLog("Creating ImGuiNodeEditorComponent...");
    editor.reset (new ImGuiNodeEditorComponent());
    addAndMakeVisible (editor.get());
    log.setMultiLine (true); log.setReadOnly (true);

    juce::Logger::writeToLog("Creating ModularSynthProcessor...");
    synth = std::make_unique<ModularSynthProcessor>();
    juce::Logger::writeToLog("Setting model on editor...");
    if (editor != nullptr)
        editor->setModel (synth.get());
    synth->prepareToPlay (sampleRate, blockSize);

    // Audio audition setup
    deviceManager.initialise (0, 2, nullptr, true);
    if (auto* dev = deviceManager.getCurrentAudioDevice())
    {
        sampleRate = dev->getCurrentSampleRate();
        blockSize = dev->getCurrentBufferSizeSamples();
        synth->prepareToPlay (sampleRate, blockSize);
        juce::Logger::writeToLog ("Audio device: " + dev->getName() +
                                   ", sr=" + juce::String (sampleRate) +
                                   ", bs=" + juce::String (blockSize));
    }
    // AudioProcessorPlayer lives in juce_audio_utils namespace path include; type is juce::AudioSourcePlayer for routing
    // Use AudioProcessorPlayer via juce_audio_utils module
    processorPlayer.setProcessor (synth.get());
    setWantsKeyboardFocus (true);

    // Setup FileLogger at the same path the user checks: <exe>/juce/logs/preset_creator_*.log
    {
        auto exeDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory();
        auto juceLogsDir = exeDir.getChildFile ("juce").getChildFile ("logs");
        juceLogsDir.createDirectory();
        auto logName = juce::String ("preset_creator_") + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log";
        auto logFile = juceLogsDir.getChildFile (logName);
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 10 * 1024 * 1024);
        if (fileLogger != nullptr)
            juce::Logger::setCurrentLogger (fileLogger.get());
        juce::Logger::writeToLog ("PresetCreator log file: " + logFile.getFullPathName());
    }
    // Init RT logger and start periodic flush
    RtLogger::init (2048, 256);
    juce::Logger::writeToLog ("PresetCreator constructed");
    startTimerHz (30);
}

void PresetCreatorComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void PresetCreatorComponent::resized()
{
    for (auto* c : getChildren())
        if (dynamic_cast<ImGuiNodeEditorComponent*>(c) != nullptr)
            c->setBounds (0, 0, getWidth(), getHeight());
    // Keep log overlay minimal for now
    log.setBounds (10, getHeight() - 160, getWidth() - 20, 150);
}

PresetCreatorComponent::~PresetCreatorComponent()
{
    stopAudition();
    processorPlayer.setProcessor (nullptr);
    juce::Logger::writeToLog ("PresetCreator destroyed");
    RtLogger::shutdown();
    juce::Logger::setCurrentLogger (nullptr);
}

void PresetCreatorComponent::buttonClicked (juce::Button* b)
{
    if (b == &btnAddVCO) { synth->addModule ("VCO"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCF) { synth->addModule ("VCF"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCA) { synth->addModule ("VCA"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnConnect) { doConnect(); }
    else if (b == &btnSave) { doSave(); }
    else if (b == &btnLoad) { doLoad(); }
}

void PresetCreatorComponent::refreshModulesList()
{
    modulesModel.rows.clear();
    cbSrc.clear(); cbDst.clear();
    int idx = 1;
    for (auto [logicalId, type] : synth->getModulesInfo())
    {
        modulesModel.rows.add (juce::String ((int) logicalId) + " - " + type);
        cbSrc.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        cbDst.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        ++idx;
    }
    cbDst.addItem ("Output", 9999);
    listModules.updateContent();
}

void PresetCreatorComponent::doConnect()
{
    int selSrc = cbSrc.getSelectedId();
    int selDst = cbDst.getSelectedId();
    if (selSrc <= 0 || selDst <= 0) { log.insertTextAtCaret ("Select src/dst first\n"); return; }

    // Extract logical IDs from combo texts
    auto parseId = [] (const juce::String& s) -> juce::uint32 { return (juce::uint32) s.upToFirstOccurrenceOf(" ", false, false).getIntValue(); };
    juce::uint32 srcLogical = parseId (cbSrc.getText());
    juce::uint32 dstLogical = parseId (cbDst.getText());

    auto srcNode = synth->getNodeIdForLogical (srcLogical);
    juce::AudioProcessorGraph::NodeID dstNode;
    if (cbDst.getSelectedId() == 9999)
        dstNode = synth->getOutputNodeID();
    else
        dstNode = synth->getNodeIdForLogical (dstLogical);
    const int srcChan = cbSrcChan.getSelectedId() - 1;
    const int dstChan = cbDstChan.getSelectedId() - 1;
    if (srcNode.uid != 0 && dstNode.uid != 0)
    {
        if (synth->connect (srcNode, srcChan, dstNode, dstChan))
        {
            log.insertTextAtCaret ("Connected\n");
            synth->commitChanges();
        }
        else
        {
            log.insertTextAtCaret ("Connect failed\n");
        }
    }
}

void PresetCreatorComponent::doSave()
{
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", juce::File(), "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.exists() || f.getParentDirectory().exists())
        {
            juce::MemoryBlock mb;
            // Get synth state
            synth->getStateInformation (mb);
            auto xml = juce::XmlDocument::parse (mb.toString());
            if (! xml) return;
            juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
            // Attach UI state as child
            if (editor)
            {
                juce::ValueTree ui = editor->getUiValueTree();
                presetVT.addChild (ui, -1, nullptr);
            }
            // Write
            f.replaceWithText (presetVT.createXml()->toString());
            log.insertTextAtCaret ("Saved: " + f.getFullPathName() + "\n");
        }
    });
}

void PresetCreatorComponent::doLoad()
{
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", juce::File(), "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.existsAsFile())
        {
            juce::MemoryBlock mb;
            f.loadFileAsData (mb);
            // First set the synth state
            synth->setStateInformation (mb.getData(), (int) mb.getSize());
            // Then parse and queue UI state for next frame (ensures editor exists and nodes are created)
            if (editor)
            {
                if (auto xml = juce::XmlDocument::parse (mb.toString()))
                {
                    auto vt = juce::ValueTree::fromXml (*xml);
                    auto ui = vt.getChildWithName ("NodeEditorUI");
                    if (ui.isValid())
                        editor->applyUiValueTreeNow (ui);
                }
            }
            refreshModulesList();
            log.insertTextAtCaret ("Loaded: " + f.getFullPathName() + "\n");
        }
    });
}

bool PresetCreatorComponent::keyPressed (const juce::KeyPress& key)
{
    if (key.getKeyCode() == juce::KeyPress::spaceKey)
    {
        if (! auditioning)
            startAudition();
        return true;
    }
    return false;
}

bool PresetCreatorComponent::keyStateChanged (bool isKeyDown)
{
    juce::ignoreUnused (isKeyDown);
    if (! juce::KeyPress::isKeyCurrentlyDown (juce::KeyPress::spaceKey) && auditioning)
    {
        stopAudition();
        return true;
    }
    return false;
}

void PresetCreatorComponent::visibilityChanged()
{
    juce::Logger::writeToLog (juce::String ("Component visible? ") + (isShowing() ? "yes" : "no"));
}

void PresetCreatorComponent::startAudition()
{
    if (auditioning) return;
    deviceManager.addAudioCallback (&processorPlayer);
    auditioning = true;
    log.insertTextAtCaret ("[Audition] Start (hold space)\n");
}

void PresetCreatorComponent::stopAudition()
{
    if (! auditioning) return;
    deviceManager.removeAudioCallback (&processorPlayer);
    auditioning = false;
    log.insertTextAtCaret ("[Audition] Stop\n");
}

void PresetCreatorComponent::timerCallback()
{
    RtLogger::flushToFileLogger();
    // Keep a heartbeat to ensure log is alive
    static int counter = 0;
    if ((++counter % 60) == 0)
        juce::Logger::writeToLog ("[Heartbeat] UI alive");
}


================================================================================
FILE: juce\CMakeLists.txt
================================================================================


cmake_minimum_required(VERSION 3.22)
project(ColliderAudioEngine VERSION 0.1.0)

# --- TTS Integration ---

# 1. Set the path to the pre-downloaded OpenVINO SDK.
set(OpenVINO_DIR "${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64" CACHE PATH "Path to OpenVINO SDK")
if(NOT EXISTS "${OpenVINO_DIR}")
    message(FATAL_ERROR "OpenVINO SDK not found at ${OpenVINO_DIR}.")
endif()

# 2. Set the path to the pre-downloaded OpenVINO GenAI SDK.
set(OpenVINO_GENAI_DIR "${CMAKE_SOURCE_DIR}/../vendor/openvino_genai_windows_2025.3.0.0_x86_64" CACHE PATH "Path to OpenVINO GenAI SDK")
if(NOT EXISTS "${OpenVINO_GENAI_DIR}")
    message(FATAL_ERROR "OpenVINO GenAI SDK not found at ${OpenVINO_GENAI_DIR}.")
endif()

# 3. Set the environment variable that MeloTTS.cpp expects
set(ENV{INTEL_OPENVINO_DIR} "${OpenVINO_GENAI_DIR}")

# 4. Add the OpenVINO GenAI directory to CMAKE_PREFIX_PATH so find_package can locate it
list(APPEND CMAKE_PREFIX_PATH "${OpenVINO_GENAI_DIR}/runtime")

# 5. Find OpenVINO packages
find_package(OpenVINO REQUIRED)
find_package(OpenVINOGenAI REQUIRED)

# 6. Add the MeloTTS.cpp library using add_subdirectory.
add_subdirectory(${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp ${CMAKE_BINARY_DIR}/MeloTTS.cpp)

# 7. Add SoundTouch library
set(SOUNDTOUCH_SOURCE_DIR "${CMAKE_SOURCE_DIR}/../soundtouch/source")
add_library(soundtouch STATIC
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/AAFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/BPMDetect.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIFOSampleBuffer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIRFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateCubic.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateLinear.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateShannon.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/PeakFinder.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/RateTransposer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/SoundTouch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/TDStretch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/cpu_detect_x86.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/mmx_optimized.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/sse_optimized.cpp
)
target_include_directories(soundtouch PUBLIC 
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(FetchContent)

# ==============================================================================
# Third-Party Dependencies (Fetch Only)
# ==============================================================================

FetchContent_Declare(JUCE
    GIT_REPOSITORY https://github.com/juce-framework/JUCE.git
    GIT_TAG 7.0.9
)
set(JUCE_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(JUCE_BUILD_EXTRAS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(JUCE)

FetchContent_Declare(imgui_fc
    GIT_REPOSITORY https://github.com/ocornut/imgui.git
    GIT_TAG v1.92.0
)
FetchContent_MakeAvailable(imgui_fc)

# imnodes uses find_package(imgui) in its CMake; build as sources instead
FetchContent_Declare(imnodes_fc
    GIT_REPOSITORY https://github.com/Nelarius/imnodes.git
    GIT_TAG b2ec254ce576ac3d42dfb7aef61deadbff8e7211
)
FetchContent_GetProperties(imnodes_fc)
if(NOT imnodes_fc_POPULATED)
  FetchContent_Populate(imnodes_fc)
endif()

# imgui_juce backend (dedicated JUCE bridge for ImGui)
FetchContent_Declare(imgui_juce_fc
    GIT_REPOSITORY https://github.com/Krasjet/imgui_juce.git
    GIT_TAG master
)
FetchContent_MakeAvailable(imgui_juce_fc)

# --------------------------------------------------------------
# Rubber Band (optional, real-time timestretcher/pitch-shifter)
# --------------------------------------------------------------
set(USE_RUBBERBAND ON CACHE BOOL "Enable Rubber Band time/pitch processing")
if (USE_RUBBERBAND)
  FetchContent_Declare(rubberband_fc
    GIT_REPOSITORY https://github.com/breakfastquay/rubberband.git
    GIT_TAG v3.3.0
  )
  FetchContent_MakeAvailable(rubberband_fc)
  # Build from single-file amalgamation to avoid external link issues
  # Use official amalgamated single-file build (works cross-platform)
  add_library(rubberband_single STATIC
    ${rubberband_fc_SOURCE_DIR}/single/RubberBandSingle.cpp
  )
  target_include_directories(rubberband_single PUBLIC
    ${rubberband_fc_SOURCE_DIR}
    ${rubberband_fc_SOURCE_DIR}/single
  )
  target_compile_definitions(rubberband_single PUBLIC
    NOMINMAX
    _USE_MATH_DEFINES
    RUBBERBAND_USE_R3=1
    RUBBERBAND_BUILD_FFT=KISSFFT
    RUBBERBAND_BUILD_RESAMPLER=NONE
  )
  set(RUBBERBAND_TARGET rubberband_single)
  set(RUBBERBAND_INCLUDE_DIR "${rubberband_fc_SOURCE_DIR}")
endif()

# ==============================================================================
# Main Engine App Target (Unchanged)
# ==============================================================================
juce_add_gui_app(ColliderApp
    PRODUCT_NAME "Collider Audio Engine"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(ColliderApp PRIVATE
    Source/main.cpp
    Source/app/MainApplication.cpp
    Source/app/MainApplication.h
    Source/ui/MainComponent.cpp
    Source/ui/MainComponent.h
    Source/ui/TestHarnessComponent.cpp
    Source/ui/TestHarnessComponent.h
    Source/ui/VisualiserComponent.cpp
    Source/ui/VisualiserComponent.h
    Source/ui/DebugInfo.h
    Source/audio/AudioEngine.h
    Source/audio/AudioEngine.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/voices/SynthVoiceProcessor.h
    Source/audio/voices/SynthVoiceProcessor.cpp
    Source/audio/voices/NoiseVoiceProcessor.h
    Source/audio/voices/NoiseVoiceProcessor.cpp
    Source/audio/voices/ModularVoice.h
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/fx/FXChain.h
    Source/audio/fx/GainProcessor.h
    Source/audio/fx/GainProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
    Source/audio/modules/TTSModuleProcessor.h
    Source/audio/modules/TTSModuleProcessor.cpp
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/utils/TapProcessor.h
    Source/ipc/IpcServer.cpp
    Source/ipc/IpcServer.h
    Source/ipc/OscClient.h
    Source/ipc/CommandBus.cpp
    Source/ipc/CommandBus.h
    Source/audio/utils/VoiceDeletionUtils.h
    Source/audio/dsp/TimePitchProcessor.h
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
)

target_compile_definitions(ColliderApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:ColliderApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:ColliderApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
)

target_link_libraries(ColliderApp PRIVATE
    juce::juce_gui_extra
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    juce::juce_osc
    meloTTS_ov
    openvino::runtime
    soundtouch
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
)

# Add include directories for ColliderApp
target_include_directories(ColliderApp PRIVATE
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/src
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppjieba
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppjieba/include
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppjieba/deps/limonp/include
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppinyin/csrc
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# ==============================================================================
# Preset Creator App Target (Final Corrected Version)
# ==============================================================================

juce_add_gui_app(PresetCreatorApp
    PRODUCT_NAME "Preset Creator"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(PresetCreatorApp PRIVATE
    # Your application sources
    Source/preset_creator/PresetCreatorMain.cpp
    Source/preset_creator/ImGuiNodeEditorComponent.h
    Source/preset_creator/ImGuiNodeEditorComponent.cpp
    Source/preset_creator/PresetCreatorComponent.h
    Source/preset_creator/PresetCreatorComponent.cpp

    # Add ImGui, imnodes, and the backend DIRECTLY as source files
    ${imgui_fc_SOURCE_DIR}/imgui.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_widgets.cpp
    ${imgui_fc_SOURCE_DIR}/backends/imgui_impl_opengl2.cpp
    ${imnodes_fc_SOURCE_DIR}/imnodes.cpp

    # Your other reused engine modules
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
    Source/audio/modules/TTSModuleProcessor.h
    Source/audio/modules/TTSModuleProcessor.cpp
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
)

# This target now needs to know where to find all the headers
target_include_directories(PresetCreatorApp PRIVATE
    ${imgui_fc_SOURCE_DIR}
    ${imgui_fc_SOURCE_DIR}/backends
    ${imnodes_fc_SOURCE_DIR}
    ${imgui_juce_fc_SOURCE_DIR}
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/src
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppjieba
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppjieba/include
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppjieba/deps/limonp/include
    ${CMAKE_SOURCE_DIR}/../vendor/MeloTTS.cpp/thirdParty/cppinyin/csrc
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# This target also needs the compile definitions
target_compile_definitions(PresetCreatorApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:PresetCreatorApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:PresetCreatorApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    IMGUI_IMPL_JUCE_BEZEL=0
    IMGUI_DEFINE_MATH_OPERATORS
    IMNODES_NAMESPACE=ImNodes
    IMNODES_STATIC_DEFINE
    PRESET_CREATOR_UI=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
)

target_link_libraries(PresetCreatorApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_devices
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    imgui_impl_juce
    meloTTS_ov
    openvino::runtime
    soundtouch
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
)

if(WIN32)
    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${OpenVINO_GENAI_DIR}/runtime/bin/intel64/Release"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMENT "Copying OpenVINO runtime libraries to output directory"
    )
    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${OpenVINO_GENAI_DIR}/runtime/3rdparty/tbb/bin"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMENT "Copying TBB runtime libraries to output directory"
    )
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${OpenVINO_GENAI_DIR}/runtime/bin/intel64/Release"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMENT "Copying OpenVINO runtime libraries to ColliderApp output directory"
    )
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${OpenVINO_GENAI_DIR}/runtime/3rdparty/tbb/bin"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMENT "Copying TBB runtime libraries to ColliderApp output directory"
    )
elseif(APPLE)
    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${OpenVINO_GENAI_DIR}/runtime/lib/intel64"
                "$<TARGET_BUNDLE_CONTENT_DIR:PresetCreatorApp>/Frameworks"
        COMMENT "Copying OpenVINO runtime libraries to app bundle"
    )
endif()


================================================================================
FILE: juce\Source\preset_creator\PresetCreatorMain.cpp
================================================================================


#include <juce_gui_extra/juce_gui_extra.h>
#include "PresetCreatorComponent.h"
#include "../utils/RtLogger.h"

class PresetCreatorApplication : public juce::JUCEApplication
{
public:
    const juce::String getApplicationName() override { return "Preset Creator"; }
    const juce::String getApplicationVersion() override { return "0.1.0"; }
    void initialise (const juce::String&) override
    {
        DBG("[PresetCreator] initialise() starting"); RtLogger::init();
        // Crash handler to capture unexpected exceptions
        std::set_terminate([]{
            auto bt = juce::SystemStats::getStackBacktrace();
            juce::Logger::writeToLog("[PresetCreator][FATAL] terminate called. Backtrace:\n" + bt);
            std::abort();
        });
        // Set up file logger for diagnostics
        auto logsDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile)
                           .getParentDirectory().getChildFile ("juce").getChildFile ("logs");
        logsDir.createDirectory();
        auto logFile = logsDir.getChildFile ("preset_creator_" + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log");
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 0);
        juce::Logger::setCurrentLogger (fileLogger.get());
        DBG("[PresetCreator] Logger initialised at: " + logFile.getFullPathName());
        juce::Logger::writeToLog("PresetCreatorApplication::initialise called");
        mainWindow.reset (new MainWindow (getApplicationName()));
        juce::Logger::writeToLog("MainWindow created successfully");
    }
    void shutdown() override { RtLogger::shutdown(); mainWindow = nullptr; juce::Logger::setCurrentLogger (nullptr); fileLogger = nullptr; }

    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow (juce::String name)
            : DocumentWindow (name,
                              juce::Desktop::getInstance().getDefaultLookAndFeel()
                                  .findColour (ResizableWindow::backgroundColourId),
                              DocumentWindow::allButtons)
        {
            juce::Logger::writeToLog("MainWindow constructor starting...");
            setUsingNativeTitleBar (true);
            juce::Logger::writeToLog("Creating PresetCreatorComponent...");
            setContentOwned (new PresetCreatorComponent(), true);
            juce::Logger::writeToLog("PresetCreatorComponent created, setting up window...");
            centreWithSize (1200, 800);
            setVisible (true);
            toFront (true);
            juce::Logger::writeToLog("MainWindow setup complete");
        }
        void closeButtonPressed() override { juce::JUCEApplication::getInstance()->systemRequestedQuit(); }
    };

private:
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::FileLogger> fileLogger;
};

START_JUCE_APPLICATION (PresetCreatorApplication)




================================================================================
FILE: juce\Source\ui\TestHarnessComponent.cpp
================================================================================


#include "TestHarnessComponent.h"
#include "MainComponent.h"
#include "../audio/voices/NoiseVoiceProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include "../audio/voices/SynthVoiceProcessor.h"
#include "../audio/voices/SampleVoiceProcessor.h"
#include "../audio/voices/ModularVoice.h"
#include "../audio/utils/VoiceDeletionUtils.h"
#include "../audio/AudioEngine.h"
#include "../ipc/CommandBus.h"

static juce::TextEditor* gLoggerEditor = nullptr;

void OnScreenLogger::attach (juce::TextEditor* editor)
{
    gLoggerEditor = editor;
}

void OnScreenLogger::log (const juce::String& msg)
{
    if (gLoggerEditor != nullptr)
    {
        if (juce::MessageManager::getInstanceWithoutCreating() != nullptr
            && juce::MessageManager::getInstance()->isThisTheMessageThread())
        {
            gLoggerEditor->moveCaretToEnd();
            gLoggerEditor->insertTextAtCaret (msg + "\n");
        }
        else
        {
            juce::MessageManager::callAsync ([s = msg]
            {
                if (gLoggerEditor != nullptr)
                {
                    gLoggerEditor->moveCaretToEnd();
                    gLoggerEditor->insertTextAtCaret (s + "\n");
                }
            });
        }
    }
    juce::Logger::writeToLog (msg);
}

TestHarnessComponent::TestHarnessComponent()
{
    OnScreenLogger::attach (&logView);
    OnScreenLogger::log ("Harness: Constructor starting...");

    // Set initial harness window size once
    setSize (2600, 1800);


    addAndMakeVisible (btnCreateSynth);
    addAndMakeVisible (btnCreateSample);
    addAndMakeVisible (btnCreateNoise);
    addAndMakeVisible (btnCreateModular);
    addAndMakeVisible (btnLoadPreset);
    addAndMakeVisible (btnDestroy);
    addAndMakeVisible (btnDestroyRandom);
    addAndMakeVisible (btnDestroySelected);
    addAndMakeVisible (btnRandomPitch);
    addAndMakeVisible (btnRandomTime);
    addAndMakeVisible (btnResetFx);
    addAndMakeVisible (btnChaos);
    addAndMakeVisible (btnManualFx);
    addAndMakeVisible (lEngine);
    addAndMakeVisible (comboEngine);
    comboEngine.addItem ("RubberBand", 1);
    comboEngine.addItem ("Naive", 2);
    comboEngine.setSelectedId (1, juce::dontSendNotification);
    comboEngine.addListener (this);
    addAndMakeVisible (sliderGain);
    addAndMakeVisible (sliderPan);
    addAndMakeVisible (lblGain);
    addAndMakeVisible (lblPan);
    addAndMakeVisible (lblStatus);
    addAndMakeVisible (lblDevice);
    addAndMakeVisible (lblVoices);
    addAndMakeVisible (lblPeak);
    addAndMakeVisible (logView);
    addAndMakeVisible (listDirs);
    addAndMakeVisible (listSamples);
    addAndMakeVisible (listVoices);
    listDirs.setRowHeight (22);
    listSamples.setRowHeight (22);
    listVoices.setRowHeight (22);
    listDirs.setMultipleSelectionEnabled (false);
    listSamples.setMultipleSelectionEnabled (false);
    listVoices.setMultipleSelectionEnabled (false);
    listDirs.setModel (&dirModel);
    listSamples.setModel (&sampleModel);
    listVoices.setModel (&voiceModel);
    listDirs.getVerticalScrollBar().setAutoHide (false);
    listSamples.getVerticalScrollBar().setAutoHide (false);
    listVoices.getVerticalScrollBar().setAutoHide (false);
    auto initSlider = [] (juce::Slider& s, double min, double max, double def, double inc=0.001)
    {
        s.setRange (min, max, inc);
        s.setValue (def);
    };
    auto addL = [this] (juce::Label& l) { addAndMakeVisible (l); };
    auto addS = [this] (juce::Slider& s) { addAndMakeVisible (s); s.addListener (this); };

    // Initialize FX sliders, defaults to "dry" positions
    addL (lFilterCutoff); addS (sFilterCutoff); initSlider (sFilterCutoff, 20.0, 20000.0, 20000.0, 1.0);
    addL (lFilterRes);    addS (sFilterRes);    initSlider (sFilterRes, 1.0, 20.0, 1.0);

    addL (lChRate);  addS (sChRate);  initSlider (sChRate, 0.1, 10.0, 1.0);
    addL (lChDepth); addS (sChDepth); initSlider (sChDepth, 0.0, 1.0, 0.0);
    addL (lChMix);   addS (sChMix);   initSlider (sChMix, 0.0, 1.0, 0.0);

    addL (lPhRate);   addS (sPhRate);   initSlider (sPhRate, 0.01, 10.0, 0.5);
    addL (lPhDepth);  addS (sPhDepth);  initSlider (sPhDepth, 0.0, 1.0, 0.0);
    addL (lPhCentre); addS (sPhCentre); initSlider (sPhCentre, 20.0, 20000.0, 1000.0, 1.0);
    addL (lPhFb);     addS (sPhFb);     initSlider (sPhFb, -0.99, 0.99, 0.0);
    addL (lPhMix);    addS (sPhMix);    initSlider (sPhMix, 0.0, 1.0, 0.0);

    addL (lRvRoom); addS (sRvRoom); initSlider (sRvRoom, 0.0, 1.0, 0.0);
    addL (lRvDamp); addS (sRvDamp); initSlider (sRvDamp, 0.0, 1.0, 0.5);
    addL (lRvWidth);addS (sRvWidth);initSlider (sRvWidth,0.0, 1.0, 1.0);
    addL (lRvMix);  addS (sRvMix);  initSlider (sRvMix,  0.0, 1.0, 0.0);

    addL (lDlTime); addS (sDlTime); initSlider (sDlTime, 1.0, 2000.0, 0.0, 1.0);
    addL (lDlFb);   addS (sDlFb);   initSlider (sDlFb,   0.0, 0.95, 0.0);
    addL (lDlMix);  addS (sDlMix);  initSlider (sDlMix,  0.0, 1.0, 0.0);

    addL (lCpThresh); addS (sCpThresh); initSlider (sCpThresh, -60.0, 0.0, 0.0);
    addL (lCpRatio);  addS (sCpRatio);  initSlider (sCpRatio,  1.0, 20.0, 1.0);
    addL (lCpAtk);    addS (sCpAtk);    initSlider (sCpAtk,    0.1, 200.0, 10.0);
    addL (lCpRel);    addS (sCpRel);    initSlider (sCpRel,    5.0, 1000.0, 100.0);
    addL (lCpMake);   addS (sCpMake);   initSlider (sCpMake,  -12.0, 12.0, 0.0);

    addL (lLmThresh); addS (sLmThresh); initSlider (sLmThresh, -20.0, 0.0, 0.0);
    addL (lLmRel);    addS (sLmRel);    initSlider (sLmRel,     1.0, 200.0, 10.0);

    addL (lDrAmt); addS (sDrAmt); initSlider (sDrAmt, 0.0, 2.0, 0.0);
    addL (lDrMix); addS (sDrMix); initSlider (sDrMix, 0.0, 1.0, 0.0);

    addL (lGtThresh); addS (sGtThresh); initSlider (sGtThresh, -80.0, -20.0, -100.0);
    addL (lGtAtk);    addS (sGtAtk);    initSlider (sGtAtk,      0.1, 50.0, 1.0);
    addL (lGtRel);    addS (sGtRel);    initSlider (sGtRel,        5.0, 500.0, 50.0);

    addL (lTsRatio); addS (sTsRatio); initSlider (sTsRatio, 0.25, 6.0, 1.0);
    addL (lPtSemis); addS (sPtSemis); initSlider (sPtSemis, -24.0, 24.0, 0.0);
    addL (lPtRatio); addS (sPtRatio); initSlider (sPtRatio, 0.5, 2.0, 1.0);

    btnCreateSynth.addListener (this);
    btnCreateSample.addListener (this);
    btnCreateNoise.addListener (this);
    btnCreateModular.addListener (this);
    btnLoadPreset.addListener (this);
    btnDestroy.addListener (this);
    btnDestroyRandom.addListener (this);
    btnDestroySelected.addListener (this);
    btnRandomPitch.addListener (this);
    btnRandomTime.addListener (this);
    btnResetFx.addListener (this);

    sliderGain.setRange (0.0, 1.0, 0.001);
    sliderGain.setSkewFactor (0.7);
    sliderGain.setValue (0.7);
    sliderGain.addListener (this);

    sliderPan.setRange (-1.0, 1.0, 0.001);
    sliderPan.setValue (0.0);
    sliderPan.addListener (this);

    lblStatus.setText ("Controlling Voice ID: -", juce::dontSendNotification);
    logView.setMultiLine (true); logView.setReadOnly (true); logView.setScrollbarsShown (true); logView.setCaretVisible (false);
    logView.setText ("[Harness] Ready\n");
    startTimerHz (15);

    // (Removed VCO verification instantiation and slider)

    // Load samples by searching upwards for 'audio/samples' from exe and CWD
    auto findSamplesDir = []() -> juce::File
    {
        juce::Array<juce::File> starts;
        starts.add (juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory());
        starts.add (juce::File::getCurrentWorkingDirectory());
        for (auto s : starts)
        {
            juce::File cur = s;
            for (int i = 0; i < 8; ++i)
            {
                juce::File candidate = cur.getChildFile ("audio").getChildFile ("samples");
                if (candidate.isDirectory())
                    return candidate;
                cur = cur.getParentDirectory();
            }
        }
        return {};
    };

    juce::File root = findSamplesDir();
    if (root.isDirectory())
    {
        OnScreenLogger::log ("[SampleBank] Searching samples in: " + root.getFullPathName());
        sampleBank.loadSamplesFromDirectory (root);
        samplesRoot = root;
        refreshDirectories();
        refreshSamples();
    }
    else
    {
        OnScreenLogger::log ("[SampleBank][WARN] Could not locate 'audio/samples' relative to exe or CWD.");
    }

    OnScreenLogger::log ("Harness: Constructor finished.");
}

// ----------- ListBoxModel (shared for both lists) -----------
int TestHarnessComponent::DirListModel::getNumRows() { return owner.dirNames.size(); }
void TestHarnessComponent::DirListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowNumber < 0 || rowNumber >= owner.dirNames.size()) return;
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    g.setColour (juce::Colours::white);
    g.drawText (owner.dirNames[rowNumber], 6, 0, width - 12, height, juce::Justification::centredLeft);
}
void TestHarnessComponent::DirListModel::selectedRowsChanged (int /*lastRowSelected*/)
{
    owner.selectedDirIndex = owner.listDirs.getSelectedRow();
    owner.refreshSamples();
}
void TestHarnessComponent::DirListModel::listBoxItemClicked (int row, const juce::MouseEvent&)
{
    owner.selectedDirIndex = row;
    owner.listDirs.selectRow (row);
    owner.refreshSamples();
}
int TestHarnessComponent::SampleListModel::getNumRows() { return owner.sampleNames.size(); }
void TestHarnessComponent::SampleListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowNumber < 0 || rowNumber >= owner.sampleNames.size()) return;
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    g.setColour (juce::Colours::white);
    g.drawText (owner.sampleNames[rowNumber], 6, 0, width - 12, height, juce::Justification::centredLeft);
}
void TestHarnessComponent::SampleListModel::selectedRowsChanged (int lastRowSelected)
{
    owner.selectedSampleIndex = lastRowSelected;
}

// -------- Voices list model --------
// --- VoiceListModel Methods ---
int TestHarnessComponent::VoiceListModel::getNumRows() { return (int)owner.engineVoices.size(); }

void TestHarnessComponent::VoiceListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    if (rowNumber >= 0 && rowNumber < (int)owner.engineVoices.size())
    {
        const auto& voiceInfo = owner.engineVoices[rowNumber];
        juce::String text = juce::String((juce::int64)voiceInfo.voiceId) + " - " + voiceInfo.voiceType;
        if (voiceInfo.displayName.isNotEmpty())
            text += " (" + voiceInfo.displayName + ")";
        g.setColour (juce::Colours::white);
        g.drawText (text, 6, 0, width - 12, height, juce::Justification::centredLeft);
    }
}

void TestHarnessComponent::VoiceListModel::listBoxItemClicked (int row, const juce::MouseEvent&)
{
    owner.listVoices.selectRow(row);
}

void TestHarnessComponent::VoiceListModel::selectedRowsChanged(int lastRowSelected)
{
    owner.setControlledVoiceByIndex(lastRowSelected);
}

void TestHarnessComponent::refreshDirectories()
{
    dirNames.clear(); dirPaths.clear();
    if (! samplesRoot.isDirectory()) return;
    auto sub = samplesRoot.findChildFiles (juce::File::findDirectories, false);
    sub.sort();
    for (auto& d : sub)
    {
        dirNames.add (d.getFileName());
        dirPaths.add (d);
    }
    listDirs.updateContent();
    if (selectedDirIndex < 0 && dirNames.size() > 0)
    {
        selectedDirIndex = 0;
        listDirs.selectRow (0);
    }
}

void TestHarnessComponent::refreshSamples()
{
    sampleNames.clear(); samplePaths.clear();
    if (selectedDirIndex >= 0 && selectedDirIndex < dirPaths.size())
    {
        auto dir = dirPaths[(int) selectedDirIndex];
        juce::Array<juce::File> files;
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.wav"));
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.aif"));
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.aiff"));
        files.sort();
        for (auto& f : files)
        {
            sampleNames.add (f.getFileName());
            samplePaths.add (f);
        }
    }
    listSamples.updateContent();
}

TestHarnessComponent::~TestHarnessComponent()
{
}

void TestHarnessComponent::setAudioEngine(AudioEngine* engine)
{
    audioEngine = engine;
    OnScreenLogger::log ("Harness: Connected to AudioEngine.");
}




void TestHarnessComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (16.0f);
    g.drawFittedText ("Collider Audio Test Harness", getLocalBounds(), juce::Justification::centredTop, 1);
}

void TestHarnessComponent::resized()
{
	// Do not setSize() here; window size controlled in constructor and by host
	int x = 10, y = 40, w = juce::jmin (340, getWidth() - 20), h = 24, gap = 6;
	btnCreateSynth.setBounds (x, y, w, h); y += h + gap;
	btnCreateSample.setBounds (x, y, w, h); y += h + gap;
	btnCreateNoise.setBounds (x, y, w, h); y += h + gap;
	btnCreateModular.setBounds (x, y, w, h); y += h + gap;
	btnLoadPreset.setBounds(x, y, w, h); y += h + gap;
	btnDestroy.setBounds (x, y, w, h); y += h + gap;
	btnDestroyRandom.setBounds (x, y, w, h); y += h + gap;
	btnDestroySelected.setBounds (x, y, w, h); y += h + gap;
	btnRandomPitch.setBounds (x, y, w, h); y += h + gap;
	btnRandomTime.setBounds (x, y, w, h); y += h + gap;
	btnResetFx.setBounds (x, y, w, h); y += h + gap;
	btnManualFx.setBounds (x, y, w, h); btnManualFx.setToggleState (true, juce::dontSendNotification); y += h + gap * 2;
    lEngine.setBounds (x, y, 70, h); comboEngine.setBounds (x + 75, y, w - 80, h); y += h + gap;

	lblGain.setBounds (x, y, 70, h); sliderGain.setBounds (x + 75, y, w - 80, h); y += h + gap;
	lblPan.setBounds (x, y, 70, h); sliderPan.setBounds (x + 75, y, w - 80, h); y += h + gap;
	btnChaos.setBounds (x, y, w, h); y += h + gap;
	lblStatus.setBounds (x, y, w, h); y += h + gap;
	lblDevice.setBounds (x, y, w, h); y += h + gap;
	lblVoices.setBounds (x, y, w, h); y += h + gap;
	lblPeak.setBounds (x, y, w, h); y += h + gap;

	// FX grid to the right with column wrap
	int gx = x + w + 20;
	int gy = 40;
	const int gw = 300;
	auto place = [&] (juce::Label& l, juce::Slider& s)
	{
		if (gy + h > getHeight() - 40)
		{
			gx += gw + 30;
			gy = 40;
		}
		l.setBounds (gx, gy, 100, h); s.setBounds (gx + 105, gy, gw - 110, h); gy += h + gap;
	};
	place (lFilterCutoff, sFilterCutoff);
	place (lFilterRes,    sFilterRes);
	place (lChRate,       sChRate);
	place (lChDepth,      sChDepth);
	place (lChMix,        sChMix);
	place (lPhRate,       sPhRate);
	place (lPhDepth,      sPhDepth);
	place (lPhCentre,     sPhCentre);
	place (lPhFb,         sPhFb);
	place (lPhMix,        sPhMix);
	place (lRvRoom,       sRvRoom);
	place (lRvDamp,       sRvDamp);
	place (lRvWidth,      sRvWidth);
	place (lRvMix,        sRvMix);
	place (lDlTime,       sDlTime);
	place (lDlFb,         sDlFb);
	place (lDlMix,        sDlMix);
	place (lCpThresh,     sCpThresh);
	place (lCpRatio,      sCpRatio);
	place (lCpAtk,        sCpAtk);
	place (lCpRel,        sCpRel);
	place (lCpMake,       sCpMake);
	place (lLmThresh,     sLmThresh);
	place (lLmRel,        sLmRel);
	place (lDrAmt,        sDrAmt);
	place (lDrMix,        sDrMix);
	place (lGtThresh,     sGtThresh);
	place (lGtAtk,        sGtAtk);
	place (lGtRel,        sGtRel);
	place (lTsRatio,      sTsRatio);
	place (lPtSemis,      sPtSemis);
	place (lPtRatio,      sPtRatio);

	int rightX = gx + gw + 30;
	int panelAreaW = getWidth() - (rightX + 40);
	int panelW = juce::jmin (500, panelAreaW / 2);
	int voicesW = juce::jmin (500, panelAreaW - panelW - 20);
	int totalH = getHeight() - 60;
	int dirsH = totalH / 2;
	int samH  = totalH - dirsH - 10;
	listDirs.setBounds (rightX, 40, panelW, dirsH);
	listSamples.setBounds (rightX, 40 + dirsH + 10, panelW, samH);
	listVoices.setBounds (rightX + panelW + 20, 40, voicesW, totalH);
	logView.setBounds (rightX + panelW + 20 + voicesW + 20, 40, getWidth() - (rightX + panelW + 20 + voicesW + 30), getHeight() - 50);
}

void TestHarnessComponent::comboBoxChanged (juce::ComboBox* c)
{
    if (c != &comboEngine) return;
    if (!audioEngine || controlledVoiceId == 0) return;
    // Send engine selection as a dedicated Update param understood by SampleVoiceProcessor via APVTS
    Command cmd; cmd.type = Command::Type::Update; cmd.voiceId = controlledVoiceId;
    cmd.paramName = "engine"; // mirrored by SampleLoader in Preset Creator
    cmd.paramValue = (float) (comboEngine.getSelectedId() == 2 ? 1.0f : 0.0f); // 0=RB, 1=Naive
    audioEngine->getCommandBus().enqueueLatest (cmd);
    OnScreenLogger::log ("[UI] Engine set to: " + comboEngine.getText());
}

void TestHarnessComponent::buttonClicked (juce::Button* b)
{
    // Ensure the engine is connected before sending any commands
    if (audioEngine == nullptr) {
        OnScreenLogger::log("[UI] ERROR: No AudioEngine connected!");
        return;
    }

    // --- Create Logic ---
    if (b == &btnCreateSynth || b == &btnCreateSample || b == &btnCreateNoise || b == &btnCreateModular)
    {
        Command cmd;
        cmd.type = Command::Type::Create;
        cmd.voiceId = juce::Time::getMillisecondCounterHiRes();

        if (b == &btnCreateSynth) {
            cmd.voiceType = "synth";
            OnScreenLogger::log("[UI] Sending CREATE command for Synth voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateNoise) {
            cmd.voiceType = "noise";
            OnScreenLogger::log("[UI] Sending CREATE command for Noise voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateModular) {
            cmd.voiceType = "modular";
            OnScreenLogger::log("[UI] Sending CREATE command for Modular voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateSample) {
            if (selectedSampleIndex >= 0 && selectedSampleIndex < samplePaths.size()) {
                cmd.voiceType = "sample";
                cmd.resourceName = samplePaths[(int)selectedSampleIndex].getFullPathName();
                OnScreenLogger::log("[UI] Sending CREATE command for Sample voice: " + cmd.resourceName);
                audioEngine->getCommandBus().enqueue(cmd);
            } else {
                OnScreenLogger::log("[UI] No sample selected. Cannot create sample voice.");
            }
        }
    }
    // --- Load Preset for Modular ---
    else if (b == &btnLoadPreset)
    {
        // 1. Check if a voice is selected.
        if (controlledVoiceId == 0)
        {
            OnScreenLogger::log("[UI] ERROR: No voice selected to load preset into.");
            return;
        }

        // 2. Verify that the selected voice is a Modular voice.
        bool isModular = false;
        for (const auto& voiceInfo : engineVoices)
        {
            if (voiceInfo.voiceId == controlledVoiceId && voiceInfo.voiceType == "Modular")
            {
                isModular = true;
                break;
            }
        }

        if (!isModular)
        {
            OnScreenLogger::log("[UI] ERROR: The selected voice is not a Modular Synth.");
            return;
        }

        // 3. Launch the file chooser.
        loadChooser = std::make_unique<juce::FileChooser>("Load Modular Preset", juce::File{}, "*.xml");
        auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

        loadChooser->launchAsync(chooserFlags, [this](const juce::FileChooser& fc)
        {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                // 4. Read file content and create the command.
                Command cmd;
                cmd.type = Command::Type::LoadPreset;
                cmd.voiceId = controlledVoiceId;
                cmd.presetData = f.loadFileAsString();

                // 5. Send the command to the engine.
                if (audioEngine)
                {
                    audioEngine->getCommandBus().enqueue(cmd);
                    OnScreenLogger::log("[UI] Sent LoadPreset command for voice " + juce::String((juce::int64)controlledVoiceId));
                }
            }
        });
    }

    // --- Destroy Logic ---
    else if (b == &btnDestroySelected || b == &btnDestroy) // Treat "Destroy" and "Destroy Selected" as the same action
    {
        if (controlledVoiceId != 0) {
            Command cmd;
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = controlledVoiceId;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI] Sending DESTROY command for selected voice ID: " + juce::String((juce::int64)controlledVoiceId));
            controlledVoiceId = 0; // De-select the voice since it's being deleted
        } else {
            OnScreenLogger::log("[UI] No voice selected to destroy.");
        }
    }
    else if (b == &btnDestroyRandom)
    {
        if (!engineVoices.empty()) {
            auto& rng = juce::Random::getSystemRandom();
            const int index = rng.nextInt((int)engineVoices.size());
            const juce::uint64 idToDestroy = engineVoices[index].voiceId;
            
            Command cmd;
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = idToDestroy;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI] Sending DESTROY command for random voice ID: " + juce::String((juce::int64)idToDestroy));
            
            if (controlledVoiceId == idToDestroy) {
                controlledVoiceId = 0; // De-select if it was the one deleted
            }
        } else {
            OnScreenLogger::log("[UI] No voices to destroy at random.");
        }
    }
    else
    {
        OnScreenLogger::log("[UI] Button '" + b->getButtonText() + "' is not yet wired to the AudioEngine.");
    }
}

void TestHarnessComponent::sliderValueChanged (juce::Slider* s)
{
    if (isSyncingSliders) return;
    // Ensure the engine is connected before sending any commands
    if (audioEngine == nullptr) {
        OnScreenLogger::log("[UI] ERROR: No AudioEngine connected!");
        return;
    }

    // Create a lambda for sending update commands
    auto set = [this] (const char* id, double v)
    {
        OnScreenLogger::log("[UI LOG] Slider for '" + juce::String(id) + "' was moved.");
        
        if (audioEngine && controlledVoiceId != 0)
        {
            Command cmd;
            cmd.type = Command::Type::Update;
            cmd.voiceId = controlledVoiceId;
            cmd.paramName = id;
            cmd.paramValue = (float)v;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI LOG] Sent UPDATE command for '" + juce::String(id) + "' to AudioEngine.");
        }
        else
        {
            OnScreenLogger::log("[UI LOG] ERROR: No voice selected!");
        }
    };

    if (s == &sliderGain)
    {
        set("gain", sliderGain.getValue());
    }
    else if (s == &sliderPan)
    {
        set("pan", sliderPan.getValue());
    }
    else if (btnManualFx.getToggleState())
    {
        if (s == &sFilterCutoff) set ("filterCutoff", s->getValue());
        else if (s == &sFilterRes) set ("filterResonance", s->getValue());
        else if (s == &sChRate) set ("chorusRate", s->getValue());
        else if (s == &sChDepth) set ("chorusDepth", s->getValue());
        else if (s == &sChMix) set ("chorusMix", s->getValue());
        else if (s == &sPhRate) set ("phaserRate", s->getValue());
        else if (s == &sPhDepth) set ("phaserDepth", s->getValue());
        else if (s == &sPhCentre) set ("phaserCentre", s->getValue());
        else if (s == &sPhFb) set ("phaserFeedback", s->getValue());
        else if (s == &sPhMix) set ("phaserMix", s->getValue());
        else if (s == &sRvRoom) set ("reverbRoom", s->getValue());
        else if (s == &sRvDamp) set ("reverbDamp", s->getValue());
        else if (s == &sRvWidth) set ("reverbWidth", s->getValue());
        else if (s == &sRvMix) set ("reverbMix", s->getValue());
        else if (s == &sDlTime) set ("delayTimeMs", s->getValue());
        else if (s == &sDlFb) set ("delayFeedback", s->getValue());
        else if (s == &sDlMix) set ("delayMix", s->getValue());
        else if (s == &sCpThresh) set ("compThreshold", s->getValue());
        else if (s == &sCpRatio) set ("compRatio", s->getValue());
        else if (s == &sCpAtk) set ("compAttackMs", s->getValue());
        else if (s == &sCpRel) set ("compReleaseMs", s->getValue());
        else if (s == &sCpMake) set ("compMakeup", s->getValue());
        else if (s == &sLmThresh) set ("limitThreshold", s->getValue());
        else if (s == &sLmRel) set ("limitReleaseMs", s->getValue());
        else if (s == &sDrAmt) set ("driveAmount", s->getValue());
        else if (s == &sDrMix) set ("driveMix", s->getValue());
        else if (s == &sGtThresh) set ("gateThreshold", s->getValue());
        else if (s == &sGtAtk) set ("gateAttackMs", s->getValue());
        else if (s == &sGtRel) set ("gateReleaseMs", s->getValue());
        else if (s == &sTsRatio) set ("timeStretchRatio", s->getValue());
        else if (s == &sPtSemis) set ("pitchSemitones", s->getValue());
        else if (s == &sPtRatio) set ("pitchRatio", s->getValue());
    }
}

// --- Sync Timer ---
void TestHarnessComponent::timerCallback()
{
    if (audioEngine)
    {
        auto currentEngineVoices = audioEngine->getActiveVoicesInfo();
        // Check if the list has changed before updating the UI to prevent flickering
        if (currentEngineVoices.size() != engineVoices.size()) // A simple check is enough for now
        {
            engineVoices.clear();
            for (const auto& voice : currentEngineVoices)
            {
                AudioEngine::VoiceInfo info;
                info.voiceId = voice.voiceId;
                info.voiceType = voice.voiceType;
                info.displayName = voice.displayName;
                engineVoices.push_back(info);
            }
            listVoices.updateContent();
            lblVoices.setText("Voices: " + juce::String((int)engineVoices.size()), juce::dontSendNotification);
        }
        
        // Update peak level display
        auto stats = audioEngine->getRuntimeStats();
        lblPeak.setText("Peak: " + juce::String(stats.lastPeak, 3), juce::dontSendNotification);
        
        // Update device info display
        lblDevice.setText("Device: " + juce::String(stats.sampleRate, 0) + "Hz, " + 
                         juce::String(stats.blockSize) + " samples", juce::dontSendNotification);
        
        // Route engine logs to UI
        auto engineLogs = audioEngine->drainLogs();
        for (const auto& log : engineLogs) {
            OnScreenLogger::log(log);
        }
    }
}

void TestHarnessComponent::refreshVoicesList()
{
    listVoices.updateContent();
}

void TestHarnessComponent::syncSlidersWithSelectedVoice()
{
    if (!audioEngine || controlledVoiceId == 0) return;

    isSyncingSliders = true;

    auto syncSlider = [&](juce::Slider& slider, const juce::String& paramId)
    {
        float value = audioEngine->getVoiceParameterValue(controlledVoiceId, paramId);
        slider.setValue(value, juce::dontSendNotification);
    };

    // Core & Time/Pitch
    syncSlider(sliderGain, "gain");
    syncSlider(sliderPan, "pan");
    syncSlider(sTsRatio, "timeStretchRatio");
    syncSlider(sPtSemis, "pitchSemitones");
    syncSlider(sPtRatio, "pitchRatio");

    // Filter
    syncSlider(sFilterCutoff, "filterCutoff");
    syncSlider(sFilterRes,    "filterResonance");

    // Chorus
    syncSlider(sChRate,  "chorusRate");
    syncSlider(sChDepth, "chorusDepth");
    syncSlider(sChMix,   "chorusMix");

    // Phaser
    syncSlider(sPhRate,   "phaserRate");
    syncSlider(sPhDepth,  "phaserDepth");
    syncSlider(sPhCentre, "phaserCentre");
    syncSlider(sPhFb,     "phaserFeedback");
    syncSlider(sPhMix,    "phaserMix");

    // Reverb
    syncSlider(sRvRoom,  "reverbRoom");
    syncSlider(sRvDamp,  "reverbDamp");
    syncSlider(sRvWidth, "reverbWidth");
    syncSlider(sRvMix,   "reverbMix");

    // Delay
    syncSlider(sDlTime, "delayTimeMs");
    syncSlider(sDlFb,   "delayFeedback");
    syncSlider(sDlMix,  "delayMix");

    // Compressor
    syncSlider(sCpThresh, "compThreshold");
    syncSlider(sCpRatio,  "compRatio");
    syncSlider(sCpAtk,    "compAttackMs");
    syncSlider(sCpRel,    "compReleaseMs");
    syncSlider(sCpMake,   "compMakeup");

    // Limiter
    syncSlider(sLmThresh, "limitThreshold");
    syncSlider(sLmRel,    "limitReleaseMs");

    // Drive
    syncSlider(sDrAmt, "driveAmount");
    syncSlider(sDrMix, "driveMix");

    // Gate
    syncSlider(sGtThresh, "gateThreshold");
    syncSlider(sGtAtk,    "gateAttackMs");
    syncSlider(sGtRel,    "gateReleaseMs");

    isSyncingSliders = false;
}

// --- Control Logic ---
void TestHarnessComponent::setControlledVoiceByIndex (int index)
{
    if (index >= 0 && index < (int)engineVoices.size())
    {
        controlledVoiceId = engineVoices[index].voiceId;
        OnScreenLogger::log("[UI] Selected voice ID: " + juce::String((juce::int64)controlledVoiceId));
        syncSlidersWithSelectedVoice(); // Sync UI with voice parameters
    }
    else
    {
        controlledVoiceId = 0;
    }
    lblStatus.setText("Controlling Voice ID: " + (controlledVoiceId != 0 ? juce::String((juce::int64)controlledVoiceId) : "-"), juce::dontSendNotification);
}



================================================================================
FILE: juce\Source\ui\MainComponent.cpp
================================================================================


#include "MainComponent.h"
#include "../audio/AudioEngine.h"

struct ConnTimer : public juce::Timer {
    MainComponent& mc;
    ConnTimer (MainComponent& m) : mc (m) { startTimerHz (10); }
    void timerCallback() override {
        mc.connLabel.setText ("OSC: listening", juce::dontSendNotification);
    }
};

MainComponent::MainComponent()
{
    // Create audio engine (OSC + graph, acts as AudioSource)
    audioEngine = std::make_unique<AudioEngine>();
    
    // Create the UI and make it visible
    addAndMakeVisible(testHarness);
    
    // THIS IS THE CRITICAL CONNECTION:
    // Pass the engine pointer to the UI component.
    testHarness.setAudioEngine(audioEngine.get());

    // Open default audio device on this MainComponent (the AudioAppComponent)
    setAudioChannels (0, 2);

    setSize(1600, 900); // Set a default size for the main window
}

MainComponent::~MainComponent()
{
    // Close audio device on MainComponent
    shutdownAudio();
}

void MainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (16.0f);
    g.drawFittedText ("Collider Audio Engine (JUCE)", getLocalBounds(), juce::Justification::centredTop, 1);
}

void MainComponent::resized()
{
    // Make the TestHarnessComponent fill the entire window.
    testHarness.setBounds(getLocalBounds());
}

void MainComponent::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    juce::Logger::writeToLog ("[APP] MainComponent::prepareToPlay called");
    if (audioEngine)
        audioEngine->prepareToPlay (samplesPerBlockExpected, sampleRate);
}

void MainComponent::getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill)
{
    if (audioEngine)
        audioEngine->getNextAudioBlock (bufferToFill);
    else if (bufferToFill.buffer != nullptr)
        bufferToFill.buffer->clear();
}

void MainComponent::releaseResources()
{
    juce::Logger::writeToLog ("[APP] MainComponent::releaseResources called");
    if (audioEngine)
        audioEngine->releaseResources();
}




================================================================================
FILE: juce\Source\ui\MainComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "VisualiserComponent.h"
#include "TestHarnessComponent.h" // Add this include

// Forward declarations for audio stubs
class AudioEngine;
class CommandProcessor;

class MainComponent : public juce::AudioAppComponent
{
public:
    MainComponent();
    ~MainComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;

    // AudioAppComponent hooks (pass-through to AudioEngine)
    void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override;
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override;
    void releaseResources() override;

private:
    juce::Label statusLabel;
    juce::Slider masterVolumeSlider;
public:
    juce::Label connLabel;
    juce::Timer* timerHook { nullptr };
    std::unique_ptr<AudioEngine> audioEngine;
    TestHarnessComponent testHarness; // ADD THIS
    std::unique_ptr<VisualiserComponent> visualiser;
};




================================================================================
FILE: juce\Source\ui\VisualiserComponent.h
================================================================================


// Rationale: VisualiserComponent renders a minimal debug dashboard of the
// listener and active voices using the VisualiserState from AudioEngine.
#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include "DebugInfo.h"

class AudioEngine;

class VisualiserComponent : public juce::Component, private juce::Timer
{
public:
    explicit VisualiserComponent (AudioEngine& engineRef);
    ~VisualiserComponent() override;

    void paint (juce::Graphics& g) override;
    void resized() override;

private:
    void timerCallback() override;
    juce::Point<int> worldToScreen (juce::Point<float> p) const;
    void drawLegend (juce::Graphics& g) const;

    AudioEngine& engine;
    // World coordinate bounds (from Python game): origin at (0,0), width=1920, height=1080
    juce::Rectangle<float> worldBounds { 0.0f, 0.0f, 1920.0f, 1080.0f };
};




================================================================================
FILE: juce\Source\ui\VisualiserComponent.cpp
================================================================================


#include "VisualiserComponent.h"
#include "DebugInfo.h"
#include "../audio/AudioEngine.h"

VisualiserComponent::VisualiserComponent (AudioEngine& engineRef)
    : engine (engineRef)
{
    startTimerHz (30);
}

VisualiserComponent::~VisualiserComponent()
{
    stopTimer();
}

void VisualiserComponent::timerCallback()
{
    repaint();
}

void VisualiserComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);

    auto state = engine.getVisualiserState();

    // Draw listener
    g.setColour (juce::Colours::white);
    auto lp = worldToScreen (state.listenerPosition);
    g.fillEllipse ((float) lp.x - 6.0f, (float) lp.y - 6.0f, 12.0f, 12.0f);

    // Draw voices
    for (auto& v : state.voices)
    {
        juce::Colour c = juce::Colours::grey;
        switch (v.state)
        {
            case VoiceDebugState::Playing:  c = juce::Colours::yellow; break;
            case VoiceDebugState::Stopping: c = juce::Colours::orange; break;
            case VoiceDebugState::Clipping: c = juce::Colours::red;    break;
            case VoiceDebugState::Prepared: c = juce::Colours::cornflowerblue; break;
            case VoiceDebugState::Silent:   c = juce::Colours::darkgrey; break;
            case VoiceDebugState::Error:    c = juce::Colours::deeppink; break;
            case VoiceDebugState::Created:  c = juce::Colours::lightblue; break;
        }
        g.setColour (c);
        auto p = worldToScreen (v.position);
        g.fillEllipse ((float) p.x - 4.0f, (float) p.y - 4.0f, 8.0f, 8.0f);
    }

    drawLegend (g);
}

void VisualiserComponent::resized()
{
}

juce::Point<int> VisualiserComponent::worldToScreen (juce::Point<float> p) const
{
    auto screen = getLocalBounds();
    const float wx0 = worldBounds.getX();
    const float wy0 = worldBounds.getY();
    const float wx1 = worldBounds.getRight();
    const float wy1 = worldBounds.getBottom();

    // Map X: [wx0, wx1] -> [screen.getX(), screen.getRight()]
    const float sx = juce::jmap (p.x, wx0, wx1, (float) screen.getX(), (float) screen.getRight());

    // Map Y (invert): game Y increases up, screen Y increases down
    // World Y=wy0 (bottom) should map to screen.getBottom()
    // World Y=wy1 (top)    should map to screen.getY()
    const float sy = juce::jmap (p.y, wy0, wy1, (float) screen.getBottom(), (float) screen.getY());

    const int ix = juce::jlimit (screen.getX(), screen.getRight(), (int) std::lround (sx));
    const int iy = juce::jlimit (screen.getY(), screen.getBottom(), (int) std::lround (sy));
    return { ix, iy };
}

void VisualiserComponent::drawLegend (juce::Graphics& g) const
{
    juce::Rectangle<int> panel (10, getHeight() - 110, 260, 100);
    g.setColour (juce::Colours::black.withAlpha (0.6f));
    g.fillRoundedRectangle (panel.toFloat(), 6.0f);
    g.setColour (juce::Colours::white);
    g.drawText ("Legend:", panel.removeFromTop (18), juce::Justification::left);

    auto row = [&](juce::Colour col, const juce::String& text, int y) {
        g.setColour (col); g.fillEllipse (14.0f, (float) y + 4.0f, 8.0f, 8.0f);
        g.setColour (juce::Colours::white); g.drawText (text, 30, y, 220, 16, juce::Justification::left);
    };
    int baseY = getHeight() - 88;
    row (juce::Colours::yellow, "Playing", baseY);
    row (juce::Colours::orange, "Stopping", baseY + 16);
    row (juce::Colours::red,    "Clipping", baseY + 32);
    row (juce::Colours::cornflowerblue, "Prepared", baseY + 48);
    row (juce::Colours::darkgrey, "Silent", baseY + 64);
}




================================================================================
FILE: juce\Source\ui\TestHarnessComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_dsp/juce_dsp.h>
#include "../audio/graph/VoiceProcessor.h"
#include "../audio/assets/SampleBank.h"

// Forward declaration
class AudioEngine;
#include "../audio/AudioEngine.h"

// Simple on-screen logger used by the harness
struct OnScreenLogger
{
    static void attach (juce::TextEditor* editor);
    static void log (const juce::String& msg);
};

class TestHarnessComponent : public juce::Component, // Changed from AudioAppComponent
                             private juce::Button::Listener,
                             private juce::Slider::Listener,
                             private juce::ComboBox::Listener,
                             private juce::Timer
{
public:
    TestHarnessComponent();
    ~TestHarnessComponent() override;

    void prepareToPlay (int samplesPerBlockExpected, double sampleRate);
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill);
    void releaseResources();

    void paint (juce::Graphics&) override;
    void resized() override;
    void timerCallback() override;
    
    // Connection to AudioEngine
    void setAudioEngine(AudioEngine* engine);
    // List models (nested types)
    struct DirListModel : public juce::ListBoxModel {
        DirListModel(TestHarnessComponent& ownerRef) : owner(ownerRef) {}
        int getNumRows() override;
        void paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected) override;
        void selectedRowsChanged (int lastRowSelected) override;
        void listBoxItemClicked (int row, const juce::MouseEvent&) override;
        TestHarnessComponent& owner;
    };
    struct SampleListModel : public juce::ListBoxModel {
        SampleListModel(TestHarnessComponent& ownerRef) : owner(ownerRef) {}
        int getNumRows() override;
        void paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected) override;
        void selectedRowsChanged (int lastRowSelected) override;
        TestHarnessComponent& owner;
    };

    struct VoiceListModel : public juce::ListBoxModel {
        VoiceListModel(TestHarnessComponent& ownerRef) : owner(ownerRef) {}
        int getNumRows() override;
        void paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected) override;
        void selectedRowsChanged (int lastRowSelected) override;
        void listBoxItemClicked (int row, const juce::MouseEvent&) override;
        TestHarnessComponent& owner;
    };

private:
    void buttonClicked (juce::Button* b) override;
    void sliderValueChanged (juce::Slider* s) override;
    void comboBoxChanged (juce::ComboBox* c) override;

    // AudioEngine connection
    AudioEngine* audioEngine = nullptr;
    
    // This vector will hold the synced voice list from the engine
    std::vector<AudioEngine::VoiceInfo> engineVoices;
    juce::uint64 controlledVoiceId { 0 };
    bool isSyncingSliders = false;

    juce::AudioBuffer<float> tempMixBuffer; // For manual mixing
    SampleBank sampleBank; // To provide samples
    juce::TextButton btnCreateSynth { "Create Synth" };
    juce::TextButton btnCreateSample { "Create Sample" };
    juce::TextButton btnCreateNoise { "Create Noise" };
    juce::TextButton btnCreateModular { "Create Modular" };
    juce::TextButton btnLoadPreset { "Load Preset for Modular" };
    juce::TextButton btnDestroy { "Destroy Last Voice" };
    juce::TextButton btnDestroyRandom { "Destroy Random Voice" };
    juce::TextButton btnDestroySelected { "Destroy Selected Voice" };
    juce::TextButton btnRandomPitch { "Random Pitch" };
    juce::TextButton btnRandomTime { "Random Time" };
    juce::TextButton btnResetFx { "Reset FX Defaults" };
    juce::ToggleButton btnChaos { "Enable Chaos Mode" };
    juce::Slider sliderGain, sliderPan;
    juce::Label lblGain { {}, "Gain" }, lblPan { {}, "Pan" }, lblStatus;
    juce::Label lblDevice { {}, "Device: -" }, lblVoices { {}, "Voices: 0" }, lblPeak { {}, "Peak: 0.0" };
    juce::TextEditor logView;
    juce::ToggleButton btnManualFx { "Manual FX Control" };
    juce::Label lEngine { {}, "Engine" };
    juce::ComboBox comboEngine;

    // FX sliders
    juce::Slider sFilterCutoff, sFilterRes, sChRate, sChDepth, sChMix;
    juce::Slider sPhRate, sPhDepth, sPhCentre, sPhFb, sPhMix;
    juce::Slider sRvRoom, sRvDamp, sRvWidth, sRvMix;
    juce::Slider sDlTime, sDlFb, sDlMix;
    juce::Slider sCpThresh, sCpRatio, sCpAtk, sCpRel, sCpMake;
    juce::Slider sLmThresh, sLmRel;
    juce::Slider sDrAmt, sDrMix;
    juce::Slider sGtThresh, sGtAtk, sGtRel;
    juce::Slider sTsRatio, sPtSemis;

    juce::Label lFilterCutoff { {}, "Filt Cutoff" }, lFilterRes { {}, "Filt Q" }, lChRate { {}, "Ch Rate" }, lChDepth { {}, "Ch Depth" }, lChMix { {}, "Ch Mix" };
    juce::Label lPhRate { {}, "Ph Rate" }, lPhDepth { {}, "Ph Depth" }, lPhCentre { {}, "Ph Ctr" }, lPhFb { {}, "Ph FB" }, lPhMix { {}, "Ph Mix" };
    juce::Label lRvRoom { {}, "Rv Room" }, lRvDamp { {}, "Rv Damp" }, lRvWidth { {}, "Rv Width" }, lRvMix { {}, "Rv Mix" };
    juce::Label lDlTime { {}, "Dly ms" }, lDlFb { {}, "Dly FB" }, lDlMix { {}, "Dly Mix" };
    juce::Label lCpThresh { {}, "Cp Thr" }, lCpRatio { {}, "Cp Ratio" }, lCpAtk { {}, "Cp Atk" }, lCpRel { {}, "Cp Rel" }, lCpMake { {}, "Cp Make" };
    juce::Label lLmThresh { {}, "Lm Thr" }, lLmRel { {}, "Lm Rel" };
    juce::Label lDrAmt { {}, "Drv Amt" }, lDrMix { {}, "Drv Mix" };
    juce::Label lGtThresh { {}, "Gate Thr" }, lGtAtk { {}, "Gate Atk" }, lGtRel { {}, "Gate Rel" };
    juce::Label lTsRatio { {}, "Time" }, lPtSemis { {}, "Pitch" };
    juce::Slider sPtRatio; juce::Label lPtRatio { {}, "Pitch x" };

    // Sample loader UI
    juce::ListBox listDirs { "Folders" };
    juce::ListBox listSamples { "Samples" };
    juce::ListBox listVoices { "Voices" };
    DirListModel dirModel { *this };
    SampleListModel sampleModel { *this };
    VoiceListModel voiceModel { *this };
    juce::StringArray dirNames;
    juce::Array<juce::File> dirPaths;
    juce::StringArray sampleNames;
    juce::Array<juce::File> samplePaths;
    int selectedDirIndex { -1 };
    int selectedSampleIndex { -1 };
    juce::File samplesRoot;
    std::unique_ptr<juce::FileChooser> loadChooser;

    void refreshDirectories();
    void refreshSamples();
    void refreshVoicesList();
    void syncSlidersWithSelectedVoice();
    void setControlledVoiceByIndex (int index);

    juce::uint64 lastVoiceId { 0 };
    bool hasEngineConfirmedReady { false };
    double harnessStartMs { 0.0 };
    // (Adapter handles modular voices as normal VoiceProcessor instances)

    // (Removed VCO verification fields)
};



