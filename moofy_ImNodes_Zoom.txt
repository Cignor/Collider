================================================================================
TOPIC: ImNodes Zoom Integration (Dual ImGui Context, IO Mirroring, Copy-Back)

Goal:
- Implement smooth zooming for the node editor using a second ImGui context to
  render at scale, mirroring IO to ensure correct hover/selection, and copying
  transformed draw data back into the primary context.

Key APIs expected:
- EditorContextGetZoom()
- EditorContextSetZoom(float zoom_scale, ImVec2 zoom_center)
- IsEditorHovered()

Critical invariants:
- Stroke thickness divided by ZoomScale for visual consistency
- Zoom centered at mouse: adjust panning by (p/zoom_new - p/zoom_old)
- IO mirroring: DisplaySize, DeltaTime, MousePos, MouseWheel, KeyMods, flags
- AppendDrawData: translate + scale positions when copying draw lists back

Primary reference (must-read):
- Add zoom functionality ‚Äî 0cda3b8
  https://github.com/Nelarius/imnodes/pull/192/commits/0cda3b818e9bc4ede43b094796ec95792bf5fbb7

Testing checklist:
- Hover/select/drag works at fractional zooms
- Link thickness stable across zoom
- Panning unaffected by zoom level
- Overlays/tooltips align with canvas at all zoom levels
================================================================================

================================================================================
FILE: guides\IMNODES_ZOOM_INTEGRATION_GUIDE.md
================================================================================


# üîç ImNodes Zoom Integration Guide

**Version**: 1.0  
**Last Updated**: 2025-11-05  
**Purpose**: Explain the architecture and integration steps for adding smooth zooming to the node editor using the approach introduced in the imnodes PR commit "Add zoom functionality".

Reference: [Add zoom functionality to node editor (commit 0cda3b8)](https://github.com/Nelarius/imnodes/pull/192/commits/0cda3b818e9bc4ede43b094796ec95792bf5fbb7)

---

## üìã Overview

The referenced change implements node editor zoom by introducing a second ImGui context specifically used to render the imnodes canvas at a different scale. All editor interactions (mouse, hover, selection, links) remain fully functional because input state is mirrored into the zoom context and draw data is projected back into the original context.

High-level:
- **Two ImGui contexts**: the app's original context, and a zoom context used only during node editor rendering.
- **Scaled rendering**: Nodes, pins, links, and grid are rendered at `editor.ZoomScale` inside the zoom context.
- **Input mirroring**: Relevant `ImGuiIO` fields are copied into the zoom context each frame so hit-testing matches the scaled rendering.
- **Draw data copy-back**: Command lists produced in the zoom context are transformed and appended to the original context draw list at the correct canvas origin.
- **Camera invariants**: Panning and zoom are coordinated to maintain cursor-centered zooming.

---

## üèóÔ∏è Architecture

### 1) Dual-context rendering pipeline

- A new `ZoomImgCtx` is created and owned by the imnodes editor context.
- When rendering the editor, code switches to `ZoomImgCtx`, copies IO and style as needed, and renders imnodes UI at scale.
- After rendering, code switches back to the original context and appends transformed draw data.

Key responsibilities (from the commit):
- Copy IO config into the zoom context each frame to ensure all input state (mouse pos, buttons, key mods, delta time, display size, font scale, etc.) is consistent with scaled rendering.
- Compute `CanvasOriginalOrigin` in original context coordinates; use it to position the zoomed draw data correctly when copying back.
- Transform primitives when appending draw data so thickness and positions look correct under zoom.

### 2) Coordinate systems and transforms

- `editor.ZoomScale` scales all canvas-space rendering within `ZoomImgCtx`.
- `editor.Panning` remains in canvas units; zoom changes reposition panning to keep zoom centered under the cursor.
- Thickness-sensitive drawing (e.g., link thickness) is adjusted by dividing by `ZoomScale` so perceived thickness remains visually stable when zooming:
  - Example: link thickness uses `GImNodes->Style.LinkThickness / editor.ZoomScale`.

### 3) Hover/interaction correctness

- Hover detection and click targeting are evaluated in the zoom context to match the scaled geometry.
- The helper `MouseInCanvas()` returns editor hover state considering the canvas rect and window focus. The commit adjusts hover logic to rely on internal `GImNodes->IsHovered` populated via the zoom-aware path.

### 4) Zoom centering math

To zoom around a position `zoom_centering_pos` (usually mouse position on canvas), the panning is adjusted so the point remains stationary on screen across zoom levels:

```
zoom_centering_pos -= GImNodes->CanvasOriginalOrigin;
editor.Panning += zoom_centering_pos / new_zoom - zoom_centering_pos / editor.ZoomScale;
```

Mouse pos is also rescaled inside the zoom context so interaction maps correctly:

```
GImNodes->ZoomImgCtx->IO.MousePos *= editor.ZoomScale / new_zoom;
```

---

## üß© Public API Additions/Changes

As per the commit:
- `float EditorContextGetZoom();`
- `void EditorContextSetZoom(float zoom_scale, ImVec2 zoom_center);`
- `bool IsEditorHovered(); // returns MouseInCanvas()`

Zoom constraints: clamped to `[0.1, 10.0]` in the patch.

Usage patterns:
- Read current zoom to display a HUD or minimap scale.
- Set new zoom on mouse wheel with Ctrl, trackpad pinch, or UI buttons; pass the mouse position (in screen space) as `zoom_center` for intuitive zoom.

---

## üîß Key Internal Implementation Points

This section maps notable changes from the commit to concepts you must replicate or respect when integrating.

- **IO mirroring to zoom context**
  - Copy relevant `ImGuiIO` fields each frame before rendering imnodes inside `ZoomImgCtx` (the commit "Copy all of the ImGui IO config section into zoom context").
  - Ensure `DisplaySize`, `DeltaTime`, `MousePos`, `MouseWheel`, `KeyMods`, backend flags, etc., reflect the current frame.

- **Draw data copy-back**
  - After rendering, obtain `ImGui::GetDrawData()` from `ZoomImgCtx` and, back in the original context, append via an `AppendDrawData(cmd_list, CanvasOriginalOrigin, ZoomScale)` routine.
  - This function translates vertices and scales thickness so visual output matches the intended zoom.

- **Thickness scaling**
  - Where applicable, divide stroke widths by `ZoomScale` so lines look consistently thick across zoom levels (links, outlines, grid lines if needed).

- **Grid rendering**
  - Grid steps and origin markers should respect zoom; larger scales show denser lines, smaller scales thin out or fade minor lines.
  - The commit routes grid drawing through the zoomed context so it naturally scales; consider LOD/fade for minor lines at extreme zooms.

- **Hover detection**
  - Replace ad-hoc `IsWindowHovered` checks with the editor‚Äôs internal hover flag updated during zoomed rendering. The commit evolves `MouseInCanvas()` and internal hover to avoid desync.

- **Minimap and editor-space conversions**
  - The commit later adds helpers `ConvertToEditorContextSpace` and `ConvertFromEditorContextSpace` (another commit in the PR) to convert between screen and editor space with zoom/pan taken into account. Replicate equivalents if needed in our codebase.

---

## üß≠ Integration Strategy for Our Codebase (JUCE + ImGui + ImNodes)

Follow these steps to adopt the zoom model without invasive rewrites.

### 1) Extend editor context

- Add `ZoomScale` (default `1.0f`) and keep `Panning` in canvas units.
- Add storage for a secondary ImGui context pointer: `ZoomImgCtx`.
- Add `CanvasOriginalOrigin` in screen space for placing appended draw data.

### 2) Create and manage the zoom ImGui context

- On editor initialization (after ImGui backend setup), create a new `ImGuiContext` dedicated to zoomed rendering.
- Share fonts/styles as appropriate; you may need to rebuild fonts for the zoom context to match the primary.
- On each frame when rendering the node editor:
  - Save original context; set current to `ZoomImgCtx`.
  - Copy IO state from original context (display size, delta, mouse state, key mods, backend flags, etc.).
  - Adjust `IO.MousePos` for the current `ZoomScale` if you are changing zoom this frame.
  - Render the editor (nodes, links, grid) inside this context, applying `ZoomScale` to canvas transforms.
  - Capture draw data.
  - Restore original context.
  - Append transformed draw lists into the original draw list using `CanvasOriginalOrigin` and `ZoomScale`.

### 3) Implement API surface

- Provide `EditorContextGetZoom()` and `EditorContextSetZoom(zoom, center)`. In `SetZoom`:
  - Clamp zoom to `[0.1, 10.0]`.
  - Convert `zoom_center` to canvas-relative (`zoom_center -= CanvasOriginalOrigin`).
  - Apply panning compensation: `Panning += zoom_center / new_zoom - zoom_center / old_zoom`.
  - Rescale `ZoomImgCtx->IO.MousePos` by `old_zoom / new_zoom` to keep interaction under the cursor.

### 4) Input handling

- Bind zoom controls:
  - Ctrl + Mouse Wheel to zoom at mouse position.
  - Optional: trackpad pinch gesture mapping to `SetZoom`.
  - Optional: `+`/`-` hotkeys and a fit-to-content button.
- Ensure panning (middle drag or space+drag) remains in canvas units; do not scale panning deltas by `ZoomScale`.

### 5) Drawing adjustments

- For stroke widths (links, outlines), divide by `ZoomScale` so visual width remains constant.
- If labels or text look off at extreme zoom, you may choose to keep font size constant and only scale geometry; the PR keeps regular ImGui text sizing, relying on geometric scale.

### 6) Hover and selection

- Evaluate hover in the zoom context so geometry and hit-testing agree.
- Update any helper like `MouseInCanvas()` to rely on the editor‚Äôs hover state computed during zoomed rendering.

### 7) Persistence

- Persist `ZoomScale` in user settings and restore per-session.
- Consider per-editor-instance zoom if multiple editors can be open.

---

## üß™ Testing Checklist

- Zoom in/out around cursor preserves the point under cursor.
- Panning behaves identically at all zoom levels.
- Selection/hover of nodes, pins, and links works at all zoom levels.
- Link thickness and outlines remain visually consistent across zoom.
- Grid density/visibility behaves sensibly at extreme zoom in/out.
- Minimap (if present) uses correct transforms and reflects zoom.
- No assertion failures switching ImGui contexts mid-frame.
- No input desyncs (dragging, rubber-band selection) at fractional zooms.

---

## ‚ö†Ô∏è Edge Cases & Pitfalls

- Forgetting to copy `ImGuiIO` fields leads to hover/drag mismatch.
- Not adjusting panning when zooming will cause jumpy zoom focus.
- Double-scaling thickness will make links look too thin/thick.
- Failing to restore original ImGui context after zoom pass will corrupt subsequent UI rendering.
- If your backend uses multiple viewports, ensure the correct viewport/display size is mirrored to the zoom context.

---

## üß± Minimal Pseudocode (Frame Render)

```cpp
void renderEditorFrame(EditorContext& editor) {
    // 1) Compute canvas origin in original context
    editor.CanvasOriginalOrigin = ImGui::GetCursorScreenPos();

    // 2) Switch to zoom context and mirror IO
    ImGuiContext* original = ImGui::GetCurrentContext();
    ImGui::SetCurrentContext(editor.ZoomImgCtx);
    mirrorIOFrom(original, editor.ZoomImgCtx);

    // 3) Begin scaled group and render
    ImGui::BeginGroup();
    ImGui::PushID("NodeEditorZoomed");
    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0,0));
    // ... render nodes/links/grid using editor.ZoomScale ...
    ImGui::PopStyleVar();
    ImGui::PopID();

    // 4) Capture draw data from zoom context
    ImDrawData* zoomDrawData = ImGui::GetDrawData();

    // 5) Restore original context
    ImGui::SetCurrentContext(original);

    // 6) Append transformed draw data into original context
    for (int i = 0; i < zoomDrawData->CmdListsCount; ++i) {
        AppendDrawData(zoomDrawData->CmdLists[i], editor.CanvasOriginalOrigin, editor.ZoomScale);
    }

    ImGui::EndGroup();
}
```

---

## üîå API Usage Examples

```cpp
// Get current zoom for UI
const float z = ImNodes::EditorContextGetZoom();
ImGui::Text("Zoom: %.2fx", z);

// Ctrl+Wheel zoom handler
if (ImGui::GetIO().KeyCtrl && ImGui::GetIO().MouseWheel != 0.0f) {
    const float step = 1.0f + (ImGui::GetIO().MouseWheel > 0.0f ? 0.1f : -0.1f);
    const float newZoom = z * step;
    ImNodes::EditorContextSetZoom(newZoom, ImGui::GetMousePos());
}
```

---

## üß© Migration Notes for Existing Code

- Replace any manual canvas scaling hacks with the dual-context approach for correctness.
- Audit any absolute pixel widths in link/node drawing; convert to thickness divided by `ZoomScale`.
- If you previously cached mouse positions in screen space, reconvert where necessary after zoom changes.
- Ensure any overlays drawn outside imnodes (e.g., tooltips/labels) use the original context coordinates; convert between editor and screen space as needed.

---

## üìö References

- PR commit introducing zoom and APIs: [Add zoom functionality ‚Äî 0cda3b8](https://github.com/Nelarius/imnodes/pull/192/commits/0cda3b818e9bc4ede43b094796ec95792bf5fbb7)

---

## üß≠ Summary

- Zoom is implemented by rendering the node editor in a dedicated ImGui context at a scale, then copying draw data back to the original context with transformed coordinates.
- Input is mirrored so hit-testing matches the scaled scene; panning is compensated to keep zoom centered under the cursor.
- A small public API (`GetZoom`, `SetZoom`) enables app-level controls; a set of careful adjustments (thickness scaling, IO mirroring, context switching) delivers a robust, artifact-free zoom.

---

End of Guide | Version 1.0 | 2025-11-05




================================================================================
FILE: guides\THEME_MANAGER_INTEGRATION_GUIDE.md
================================================================================


# üé® Theme Manager Integration Guide

**Version**: 1.0  
**Last Updated**: 2025-01-27  
**Purpose**: Comprehensive documentation of all UI elements (colors, fonts, sizes, spacing) in the Preset Creator to prepare for theme manager implementation.

---

## üìã Overview

This guide documents **every UI-related element** in the Preset Creator that should be managed by a future theme system. The goal is to identify all hardcoded values so they can be centralized in a theme manager.

**Scope**: All visual elements including:
- Colors (ImGui, ImNodes, custom drawing)
- Font sizes and families
- Spacing and padding values
- Window dimensions and positions
- Border widths and rounding
- Alpha/opacity values
- Button sizes and styles

---

## üé® 1. ImGui Core Colors

### 1.1 Base Style Colors

**Location**: `ImGuiNodeEditorComponent.cpp:244`

```cpp
ImGui::StyleColorsDark();
```

**Current**: Uses ImGui's default dark theme. This should be replaced with custom theme colors.

**Theme Manager Integration**: 
- Replace `StyleColorsDark()` with theme-aware color application
- All `ImGuiCol_*` enums should be configurable

### 1.2 Status Overlay Colors

**Location**: `ImGuiNodeEditorComponent.cpp:430-432`

```cpp
// Status: EDITED
ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");

// Status: SAVED  
ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
```

**Colors**:
- Edited: Yellow `(1.0, 1.0, 0.0, 1.0)`
- Saved: Green `(0.0, 1.0, 0.0, 1.0)`

**Also Used**: `ImGuiNodeEditorComponent.cpp:1055-1057` (duplicate)

**Theme Keys Needed**:
- `theme.status.edited`
- `theme.status.saved`

---

### 1.3 Text Colors - General

**Location**: Multiple locations

```cpp
// Section headers (gray)
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Section Name");

// Warning/Info (yellow)
ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Warning Text");

// Success (green)
ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Success Text");

// Error (red/orange)
ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "Error Text");

// Disabled text
ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));

// Active/Connected indicators
ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255)); // Green active
```

**Theme Keys Needed**:
- `theme.text.section_header`
- `theme.text.warning`
- `theme.text.success`
- `theme.text.error`
- `theme.text.disabled`
- `theme.text.active`

---

### 1.4 Module Category Header Colors

**Location**: `ImGuiNodeEditorComponent.cpp:1134-1144, 1266-1324, 1445-1449`

**Category Colors** (with hover/active variants):

```cpp
// Gold (for "Recent" section)
ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(218, 165, 32, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(238, 185, 52, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(255, 205, 72, 255));

// Cyan (for Samples section)
ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(0, 180, 180, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(20, 200, 200, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(40, 220, 220, 255));

// Purple (for Presets section)
ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(180, 120, 255, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(200, 140, 255, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(220, 160, 255, 255));

// Neutral Grey (for System section)
ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(80, 80, 80, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(100, 100, 100, 255));
ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(120, 120, 120, 255));
```

**Theme Keys Needed**:
- `theme.header.recent` (base, hovered, active)
- `theme.header.samples` (base, hovered, active)
- `theme.header.presets` (base, hovered, active)
- `theme.header.system` (base, hovered, active)

---

## üéØ 2. ImNodes Colors

### 2.1 Node Title Bar Colors by Category

**Location**: `ImGuiNodeEditorComponent.cpp:8293-8322`

**Function**: `getImU32ForCategory(ModuleCategory category, bool hovered)`

**Category Colors**:

```cpp
Source:      IM_COL32(50, 120, 50, 255)     // Green
Effect:      IM_COL32(130, 60, 60, 255)     // Red
Modulator:   IM_COL32(50, 50, 130, 255)     // Blue
Utility:     IM_COL32(110, 80, 50, 255)     // Orange
Seq:         IM_COL32(90, 140, 90, 255)     // Light Green
MIDI:        IM_COL32(180, 120, 255, 255)   // Vibrant Purple
Analysis:    IM_COL32(100, 50, 110, 255)    // Purple
TTS_Voice:   IM_COL32(255, 180, 100, 255)   // Peach/Coral
Special_Exp: IM_COL32(50, 200, 200, 255)    // Cyan
OpenCV:      IM_COL32(255, 140, 0, 255)     // Bright Orange
Sys:         IM_COL32(120, 100, 140, 255)   // Lavender
Comment:     IM_COL32(80, 80, 80, 255)      // Grey
Plugin:      IM_COL32(50, 110, 110, 255)    // Teal
Default:     IM_COL32(70, 70, 70, 255)      // Grey
```

**Hovered Multiplier**: `1.3x` brightness increase

**Usage**: `ImGuiNodeEditorComponent.cpp:1903-1905`
```cpp
ImNodes::PushColorStyle(ImNodesCol_TitleBar, getImU32ForCategory(moduleCategory));
ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));
```

**Theme Keys Needed**:
- `theme.nodes.category.{category_name}` (base, hovered, selected)

---

### 2.2 Special Node States

**Location**: `ImGuiNodeEditorComponent.cpp:1910-1918`

```cpp
// Hovered link highlight (overrides category color)
ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255)); // Yellow

// Muted node (overrides category color and hover)
ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(80, 80, 80, 255)); // Grey
ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f); // 50% opacity
ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
```

**Theme Keys Needed**:
- `theme.nodes.hovered_link_highlight`
- `theme.nodes.muted`
- `theme.nodes.muted_alpha`
- `theme.nodes.muted_padding`

---

### 2.3 Pin Colors by Data Type

**Location**: `ImGuiNodeEditorComponent.cpp:7875-7886`

**Function**: `getImU32ForType(PinDataType type)`

```cpp
CV:    IM_COL32(100, 150, 255, 255)  // Blue
Audio: IM_COL32(100, 255, 150, 255)  // Green
Gate:  IM_COL32(255, 220, 100, 255)  // Yellow
Raw:   IM_COL32(255, 100, 100, 255)  // Red
Video: IM_COL32(0, 200, 255, 255)    // Cyan
Default: IM_COL32(150, 150, 150, 255) // Grey
```

**Usage**: `ImGuiNodeEditorComponent.cpp:2631, 2705, 2776, 2805`
```cpp
ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
```

**Theme Keys Needed**:
- `theme.pins.{type}` (CV, Audio, Gate, Raw, Video, Default)

---

### 2.4 Pin Connection States

**Location**: `ImGuiNodeEditorComponent.cpp:1776-1777`

```cpp
const ImU32 colPin = IM_COL32(150, 150, 150, 255);        // Grey for disconnected
const ImU32 colPinConnected = IM_COL32(120, 255, 120, 255); // Green for connected
```

**Theme Keys Needed**:
- `theme.pins.disconnected`
- `theme.pins.connected`

---

### 2.5 Link Colors

**Location**: `ImGuiNodeEditorComponent.cpp:3304-3312`

```cpp
// Normal link color (based on pin type)
ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);

// Hovered link
ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(255, 255, 0, 255)); // Yellow

// Selected link
ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(255, 255, 0, 255)); // Yellow

// Highlighted link (when hovering over connection)
ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(255, 255, 0, 255)); // Yellow
```

**Theme Keys Needed**:
- `theme.links.normal` (derived from pin type)
- `theme.links.hovered`
- `theme.links.selected`
- `theme.links.highlighted`

---

## üñºÔ∏è 3. Canvas & Grid Colors

### 3.1 Grid Colors

**Location**: `ImGuiNodeEditorComponent.cpp:1721-1722`

```cpp
const ImU32 GRID_COLOR = IM_COL32(50, 50, 50, 255);        // Dark grey grid lines
const ImU32 GRID_ORIGIN_COLOR = IM_COL32(80, 80, 80, 255);  // Lighter grey for origin lines
```

**Grid Size**: `64.0f` pixels (line 287)

**Theme Keys Needed**:
- `theme.canvas.grid.color`
- `theme.canvas.grid.origin_color`
- `theme.canvas.grid.size`

---

### 3.2 Scale Marker Colors

**Location**: `ImGuiNodeEditorComponent.cpp:1801`

```cpp
const ImU32 SCALE_TEXT_COLOR = IM_COL32(150, 150, 150, 80); // Reduced opacity
```

**Scale Interval**: `400.0f` grid units

**Theme Keys Needed**:
- `theme.canvas.scale.text_color`
- `theme.canvas.scale.interval`

---

### 3.3 Preset Drop Target Overlay

**Location**: `ImGuiNodeEditorComponent.cpp:1740`

```cpp
drawList->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(218, 165, 32, 80)); // Preset Gold color
```

**Theme Keys Needed**:
- `theme.canvas.drop_target_overlay`

---

### 3.4 Mouse Position Display

**Location**: `ImGuiNodeEditorComponent.cpp:1853`

```cpp
ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), 
                                         IM_COL32(200, 200, 200, 150), posStr);
```

**Theme Keys Needed**:
- `theme.canvas.mouse_position_text`

---

## üìè 4. Spacing & Layout

### 4.1 Window Padding

**Location**: Multiple locations

```cpp
// Status overlay padding
const float padding = 10.0f;

// Probe scope window padding
ImGui::SetNextWindowPos(ImVec2((float)getWidth() - 270.0f, menuBarHeight + padding), ...);

// Notification padding
const float padding = 10.0f; // NotificationManager.cpp:72
```

**Theme Keys Needed**:
- `theme.layout.window_padding`
- `theme.layout.status_overlay_padding`
- `theme.layout.notification_padding`

---

### 4.2 Node Padding

**Location**: `ImGuiNodeEditorComponent.cpp:1916`

```cpp
// Muted nodes
ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));

// Default node padding (from ImNodes style)
// Currently uses ImNodes default
```

**Theme Keys Needed**:
- `theme.nodes.default_padding`
- `theme.nodes.muted_padding`

---

### 4.3 Item Spacing

**Location**: `ImGuiNodeEditorComponent.cpp:2752`

```cpp
const float spacing = ImGui::GetStyle().ItemSpacing.x;
```

**Usage**: Used for pin label alignment calculations

**Theme Keys Needed**:
- `theme.layout.item_spacing.x`
- `theme.layout.item_spacing.y`

---

### 4.4 Node Vertical Padding (Layout)

**Location**: `ImGuiNodeEditorComponent.cpp:6039`

```cpp
const float NODE_VERTICAL_PADDING = 50.0f;
```

Used when arranging nodes in columns.

**Theme Keys Needed**:
- `theme.layout.node_vertical_padding`

---

### 4.5 Vertical Spacing (Preset Loading)

**Location**: `ImGuiNodeEditorComponent.cpp:8927`

```cpp
const float verticalPadding = 100.0f;
```

**Theme Keys Needed**:
- `theme.layout.preset_vertical_padding`

---

## üî§ 5. Fonts & Text Sizing

### 5.1 Font Loading

**Location**: `ImGuiNodeEditorComponent.cpp:10025-10048`

```cpp
// Default English font
io.Fonts->AddFontDefault();

// Chinese font (NotoSansSC)
auto fontFile = appFile.getParentDirectory().getChildFile("../../Source/assets/NotoSansSC-VariableFont_wght.ttf");
io.Fonts->AddFontFromFileTTF(fontFile.getFullPathName().toRawUTF8(), 16.0f, &config, ranges);
```

**Font Size**: `16.0f` pixels

**Theme Keys Needed**:
- `theme.fonts.default.size`
- `theme.fonts.default.path`
- `theme.fonts.chinese.size`
- `theme.fonts.chinese.path`

---

### 5.2 Text Wrap Width

**Location**: Multiple locations

```cpp
// Standard tooltip wrap
ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);

// Compact tooltip wrap
ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
```

**Theme Keys Needed**:
- `theme.text.tooltip_wrap_multiplier.standard` (35.0)
- `theme.text.tooltip_wrap_multiplier.compact` (25.0)

---

### 5.3 Text Size Calculations

**Location**: Multiple locations

```cpp
// Text size calculations for layout
const ImVec2 textSize = ImGui::CalcTextSize(txt);
const float label_width = ImGui::CalcTextSize(label).x;
```

These are dynamic calculations, but font size affects them.

---

## üéõÔ∏è 6. Module-Specific UI Colors

### 6.1 VideoFX Module

**Location**: `VideoFXModule.cpp:699-878`

```cpp
// Section headers
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Source ID In: %d");
ImGui::TextColored(ImVec4(0.9f, 0.9f, 0.5f, 1.0f), "Color Adjustments");
ImGui::TextColored(ImVec4(0.9f, 0.9f, 0.5f, 1.0f), "Filters & Effects");
ImGui::TextColored(ImVec4(0.9f, 0.9f, 0.5f, 1.0f), "More Filters");
ImGui::TextColored(ImVec4(0.9f, 0.9f, 0.5f, 1.0f), "Advanced Effects");
```

**Theme Keys Needed**:
- `theme.modules.videofx.section_header`
- `theme.modules.videofx.section_subheader`

---

### 6.2 Scope Module

**Location**: `ScopeModuleProcessor.cpp:100-193`

```cpp
// Section headers
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Scope Settings");
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Live Waveform");
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Signal Statistics");

// Plot colors
const ImU32 bg = IM_COL32(30, 30, 30, 255);      // Background
const ImU32 fg = IM_COL32(100, 200, 255, 255);  // Foreground (cyan)
const ImU32 colMax = IM_COL32(255, 80, 80, 255); // Red (max)
const ImU32 colMin = IM_COL32(255, 220, 80, 255); // Yellow (min)

// Text colors
ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.3f, 0.3f, 1.0f)); // Red for max
ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.86f, 0.31f, 1.0f)); // Yellow for min
```

**Theme Keys Needed**:
- `theme.modules.scope.section_header`
- `theme.modules.scope.plot.background`
- `theme.modules.scope.plot.foreground`
- `theme.modules.scope.plot.max_color`
- `theme.modules.scope.plot.min_color`
- `theme.modules.scope.text.max`
- `theme.modules.scope.text.min`

---

### 6.3 Stroke Sequencer Module

**Location**: `StrokeSequencerModuleProcessor.cpp:556-738`

```cpp
// 80s LCD Yellow theme
draw_list->AddRect(canvas_p0, canvas_p1, IM_COL32(60, 55, 20, 255), 0.0f, 0, 3.0f); // Dark border

// Frame backgrounds
ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.3f, 0.28f, 0.1f, 0.7f)); // Dark yellow-brown
ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, ImVec4(0.4f, 0.38f, 0.15f, 0.8f));
ImGui::PushStyleColor(ImGuiCol_FrameBgActive, ImVec4(0.5f, 0.48f, 0.2f, 0.9f));
```

**Theme Keys Needed**:
- `theme.modules.stroke_sequencer.border`
- `theme.modules.stroke_sequencer.frame_bg`
- `theme.modules.stroke_sequencer.frame_bg_hovered`
- `theme.modules.stroke_sequencer.frame_bg_active`

---

## üé® 7. Window Backgrounds & Alpha

### 7.1 Window Background Alpha

**Location**: Multiple locations

```cpp
// Status overlay
ImGui::SetNextWindowBgAlpha(0.5f);  // 50% opacity

// Probe scope
ImGui::SetNextWindowBgAlpha(0.85f); // 85% opacity

// Preset status overlay
ImGui::SetNextWindowBgAlpha(0.7f);  // 70% opacity

// Notifications
ImGui::SetNextWindowBgAlpha(0.92f); // 92% opacity (NotificationManager.cpp:107)
```

**Theme Keys Needed**:
- `theme.windows.status_overlay.alpha`
- `theme.windows.probe_scope.alpha`
- `theme.windows.preset_status.alpha`
- `theme.windows.notifications.alpha`

---

### 7.2 Muted Node Alpha

**Location**: `ImGuiNodeEditorComponent.cpp:1917`

```cpp
ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f); // 50% opacity
```

**Theme Keys Needed**:
- `theme.nodes.muted_alpha`

---

## üìê 8. Window Dimensions & Positions

### 8.1 Sidebar Width

**Location**: `ImGuiNodeEditorComponent.cpp:413`

```cpp
const float sidebarWidth = 260.0f;
```

**Theme Keys Needed**:
- `theme.layout.sidebar_width`

---

### 8.2 Probe Scope Window

**Location**: `ImGuiNodeEditorComponent.cpp:444-445`

```cpp
ImGui::SetNextWindowPos(ImVec2((float)getWidth() - 270.0f, menuBarHeight + padding), ImGuiCond_FirstUseEver);
ImGui::SetNextWindowSize(ImVec2(260, 180), ImGuiCond_FirstUseEver);
```

**Theme Keys Needed**:
- `theme.windows.probe_scope.width`
- `theme.windows.probe_scope.height`
- `theme.windows.probe_scope.offset_x`

---

### 8.3 Node Default Width

**Location**: `ImGuiNodeEditorComponent.cpp:1927`

```cpp
float nodeContentWidth = 240.0f; // Default width
```

**Theme Keys Needed**:
- `theme.nodes.default_width`

---

## üîò 9. Button & Control Styles

### 9.1 Button Sizes

**Location**: Various module processors

Most buttons use default ImGui button sizes, but some have custom widths calculated from `itemWidth`.

**Theme Keys Needed**:
- `theme.controls.button.default_height`
- `theme.controls.button.min_width`

---

### 9.2 Slider Colors (Modulation States)

**Location**: Various module processors (e.g., `VCOModuleProcessor.h:97-106`)

```cpp
// CV modulation color (cyan)
ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
```

**Color Scheme** (from IMGUI_NODE_DESIGN_GUIDE.md):
- **Cyan** (0.4, 0.8, 1.0): Frequency/Pitch modulation
- **Orange** (1.0, 0.8, 0.4): Timbre/Waveform modulation
- **Magenta** (1.0, 0.4, 1.0): Amplitude/Level modulation
- **Green** (0.4, 1.0, 0.4): Filter/EQ modulation

**Theme Keys Needed**:
- `theme.modulation.frequency`
- `theme.modulation.timbre`
- `theme.modulation.amplitude`
- `theme.modulation.filter`

---

### 9.3 Progress Bar Colors

**Location**: Various module processors

```cpp
// Green (safe level)
ImVec4(0.2f, 0.8f, 0.2f, 1.0f)

// Yellow (hot level)
ImVec4(0.9f, 0.7f, 0.0f, 1.0f)

// Red (clipping)
ImVec4(0.9f, 0.2f, 0.2f, 1.0f)
```

**Theme Keys Needed**:
- `theme.meters.safe`
- `theme.meters.warning`
- `theme.meters.clipping`

---

## üéØ 10. Special Visual Effects

### 10.1 Link Hover Preview

**Location**: `ImGuiNodeEditorComponent.cpp:3692`

```cpp
ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, IM_COL32(255, 255, 0, 200), 3.0f);
```

**Theme Keys Needed**:
- `theme.links.preview.color`
- `theme.links.preview.width`

---

### 10.2 Timeline Markers

**Location**: `ImGuiNodeEditorComponent.cpp:2096-2097, 2211-2215`

```cpp
// Start/End markers
drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);

// Gate/Trigger lines
draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);
draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
```

**Theme Keys Needed**:
- `theme.timeline.marker.start_end`
- `theme.timeline.marker.gate`
- `theme.timeline.marker.trigger`

---

### 10.3 Connection Text Labels

**Location**: `ImGuiNodeEditorComponent.cpp:3518-3520`

```cpp
// Background
IM_COL32(50, 50, 50, 200)

// Text
IM_COL32(255, 255, 100, 255) // Yellow
```

**Theme Keys Needed**:
- `theme.links.label.background`
- `theme.links.label.text`

---

## üìä 11. Color Tracker Module

**Location**: `ColorTrackerModule.cpp` (multiple locations)

**Note**: This module displays actual video frames with color swatches, but the UI around it uses standard theme colors.

**Theme Keys Needed**:
- `theme.modules.color_tracker.swatch_size` (22x22 pixels, line 2454)

---

## üé® 12. ImGui Style Variables

### 12.1 Current Style Access

**Location**: Multiple locations

```cpp
// Accessing current style
const float spacing = ImGui::GetStyle().ItemSpacing.x;
float btnWidth = itemWidth * 0.45f - ImGui::GetStyle().ItemSpacing.x;
```

**All ImGuiStyle members should be themeable**:
- `WindowPadding`
- `FramePadding`
- `ItemSpacing`
- `ItemInnerSpacing`
- `TouchExtraPadding`
- `IndentSpacing`
- `ScrollbarSize`
- `GrabMinSize`
- `WindowBorderSize`
- `ChildBorderSize`
- `PopupBorderSize`
- `FrameBorderSize`
- `TabBorderSize`
- `WindowRounding`
- `ChildRounding`
- `FrameRounding`
- `PopupRounding`
- `ScrollbarRounding`
- `GrabRounding`
- `TabRounding`
- `WindowTitleAlign`
- `ButtonTextAlign`
- `SelectableTextAlign`
- `DisplayWindowPadding`
- `DisplaySafeAreaPadding`
- `MouseCursorScale`
- `AntiAliasedLines`
- `AntiAliasedLinesUseTex`
- `AntiAliasedFill`
- `CurveTessellationTol`
- `CircleSegmentMaxError`

**Theme Keys Needed**:
- `theme.style.{property_name}` for all ImGuiStyle properties

---

## üîÑ 13. Integration Points

### 13.1 Initialization Point

**Location**: `ImGuiNodeEditorComponent.cpp:newOpenGLContextCreated()`

**Current**:
```cpp
ImGui::StyleColorsDark();
```

**Should Become**:
```cpp
ThemeManager::getInstance().applyTheme();
```

---

### 13.2 Module Category Color Function

**Location**: `ImGuiNodeEditorComponent.cpp:8293-8322`

**Function**: `getImU32ForCategory(ModuleCategory category, bool hovered)`

**Should Query Theme**:
```cpp
return ThemeManager::getInstance().getCategoryColor(category, hovered);
```

---

### 13.3 Pin Type Color Function

**Location**: `ImGuiNodeEditorComponent.cpp:7875-7886`

**Function**: `getImU32ForType(PinDataType type)`

**Should Query Theme**:
```cpp
return ThemeManager::getInstance().getPinColor(type);
```

---

### 13.4 Node Drawing

**Location**: `ImGuiNodeEditorComponent.cpp:1903-1918`

All `ImNodes::PushColorStyle()` calls should use theme colors.

---

### 13.5 Module-Specific Drawing

**Location**: Individual module processors

Each module's `drawParametersInNode()` function uses hardcoded colors. These should be replaced with theme lookups.

---

## üì¶ 14. Theme Manager Structure (Proposed)

### 14.1 Theme Data Structure

```cpp
struct Theme {
    // ImGui Core Colors
    struct ImGuiColors {
        ImVec4 text;
        ImVec4 text_disabled;
        ImVec4 window_bg;
        ImVec4 child_bg;
        ImVec4 popup_bg;
        // ... all ImGuiCol_* colors
    } imgui;
    
    // ImNodes Colors
    struct ImNodesColors {
        // Node colors by category
        std::map<ModuleCategory, ImU32> category_colors;
        std::map<ModuleCategory, ImU32> category_hovered;
        std::map<ModuleCategory, ImU32> category_selected;
        
        // Pin colors by type
        std::map<PinDataType, ImU32> pin_colors;
        ImU32 pin_connected;
        ImU32 pin_disconnected;
        
        // Link colors
        ImU32 link_hovered;
        ImU32 link_selected;
        ImU32 link_highlighted;
        
        // Special states
        ImU32 node_muted;
        ImU32 node_hovered_link;
    } imnodes;
    
    // Canvas & Grid
    struct Canvas {
        ImU32 grid_color;
        ImU32 grid_origin_color;
        float grid_size;
        ImU32 scale_text_color;
        float scale_interval;
        ImU32 drop_target_overlay;
        ImU32 mouse_position_text;
    } canvas;
    
    // Layout
    struct Layout {
        float sidebar_width;
        float window_padding;
        float item_spacing_x;
        float item_spacing_y;
        float node_vertical_padding;
        float node_default_width;
        float node_padding_x;
        float node_padding_y;
    } layout;
    
    // Fonts
    struct Fonts {
        float default_size;
        juce::String default_path;
        float chinese_size;
        juce::String chinese_path;
    } fonts;
    
    // Text
    struct Text {
        ImVec4 section_header;
        ImVec4 warning;
        ImVec4 success;
        ImVec4 error;
        ImVec4 disabled;
        ImVec4 active;
        float tooltip_wrap_standard;
        float tooltip_wrap_compact;
    } text;
    
    // Status
    struct Status {
        ImVec4 edited;
        ImVec4 saved;
    } status;
    
    // Windows
    struct Windows {
        float status_overlay_alpha;
        float probe_scope_alpha;
        float probe_scope_width;
        float probe_scope_height;
        float preset_status_alpha;
        float notifications_alpha;
    } windows;
    
    // Modulation colors
    struct Modulation {
        ImVec4 frequency;
        ImVec4 timbre;
        ImVec4 amplitude;
        ImVec4 filter;
    } modulation;
    
    // Meters
    struct Meters {
        ImVec4 safe;
        ImVec4 warning;
        ImVec4 clipping;
    } meters;
    
    // Module-specific colors (can be extended)
    struct Modules {
        // VideoFX
        ImVec4 videofx_section_header;
        ImVec4 videofx_section_subheader;
        
        // Scope
        ImVec4 scope_section_header;
        ImU32 scope_plot_bg;
        ImU32 scope_plot_fg;
        ImU32 scope_plot_max;
        ImU32 scope_plot_min;
        ImVec4 scope_text_max;
        ImVec4 scope_text_min;
        
        // Stroke Sequencer
        ImU32 stroke_seq_border;
        ImVec4 stroke_seq_frame_bg;
        ImVec4 stroke_seq_frame_bg_hovered;
        ImVec4 stroke_seq_frame_bg_active;
    } modules;
    
    // ImGui Style
    ImGuiStyle style;
};
```

---

### 14.2 Theme Manager Class (Proposed Interface)

```cpp
class ThemeManager {
public:
    static ThemeManager& getInstance();
    
    // Load theme from file
    bool loadTheme(const juce::File& themeFile);
    
    // Save current theme to file
    bool saveTheme(const juce::File& themeFile);
    
    // Apply theme to ImGui/ImNodes
    void applyTheme();
    
    // Get colors
    ImU32 getCategoryColor(ModuleCategory cat, bool hovered = false);
    ImU32 getPinColor(PinDataType type);
    ImU32 getPinConnectedColor();
    ImU32 getPinDisconnectedColor();
    
    // Get layout values
    float getSidebarWidth() const;
    float getNodeDefaultWidth() const;
    float getItemSpacingX() const;
    
    // Get current theme
    const Theme& getCurrentTheme() const;
    
    // Theme switching
    void setTheme(const Theme& theme);
    void resetToDefault();
    
private:
    Theme currentTheme;
    Theme defaultTheme;
    
    void loadDefaultTheme();
    void applyImGuiColors();
    void applyImNodesColors();
    void applyFonts();
};
```

---

## üìù 15. Implementation Checklist

### Phase 1: Core Infrastructure
- [ ] Create `Theme` struct
- [ ] Create `ThemeManager` singleton class
- [ ] Implement default theme (current values)
- [ ] Implement `applyTheme()` method
- [ ] Replace `ImGui::StyleColorsDark()` with theme application

### Phase 2: Color System
- [ ] Migrate all `IM_COL32()` and `ImVec4()` hardcoded colors to theme
- [ ] Update `getImU32ForCategory()` to use theme
- [ ] Update `getImU32ForType()` to use theme
- [ ] Replace all `ImNodes::PushColorStyle()` calls with theme lookups
- [ ] Replace all `ImGui::PushStyleColor()` calls with theme lookups

### Phase 3: Layout & Spacing
- [ ] Migrate all spacing/padding constants to theme
- [ ] Update window dimension calculations
- [ ] Migrate font loading to theme system

### Phase 4: Module-Specific
- [ ] Create module-specific color sections in theme
- [ ] Update VideoFX module colors
- [ ] Update Scope module colors
- [ ] Update Stroke Sequencer module colors
- [ ] Update other module-specific colors

### Phase 5: Serialization
- [ ] Implement theme JSON/XML serialization
- [ ] Implement theme loading from file
- [ ] Implement theme saving to file
- [ ] Add theme selection UI

### Phase 6: Theme Presets
- [ ] Create "Dark" theme (current)
- [ ] Create "Light" theme variant
- [ ] Create "High Contrast" theme variant
- [ ] Create "Colorblind Friendly" theme variant

---

## üîç 16. Code Search Patterns

Use these patterns to find additional UI elements:

```bash
# Find all color definitions
grep -r "IM_COL32\|ImVec4\|ImColor\|Colour" --include="*.cpp" --include="*.h"

# Find all font references
grep -r "FontSize\|AddFont\|GetFont\|SetFont" --include="*.cpp" --include="*.h"

# Find all spacing/padding
grep -r "Spacing\|Padding\|ItemSpacing\|WindowPadding" --include="*.cpp" --include="*.h"

# Find all alpha/opacity
grep -r "Alpha\|Opacity\|BgAlpha" --include="*.cpp" --include="*.h"

# Find all size/dimension constants
grep -r "SetNextWindowSize\|SetNextItemWidth\|Dummy(ImVec2" --include="*.cpp" --include="*.h"
```

---

## üìö 17. Reference Files

**Main UI Component**:
- `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp` (9015 lines)

**Module Processors** (with UI):
- `juce/Source/audio/modules/VideoFXModule.cpp`
- `juce/Source/audio/modules/ScopeModuleProcessor.cpp`
- `juce/Source/audio/modules/StrokeSequencerModuleProcessor.cpp`
- All other module processors with `drawParametersInNode()` implementations

**Supporting Files**:
- `juce/Source/preset_creator/NotificationManager.cpp`

**Design Guide**:
- `guides/IMGUI_NODE_DESIGN_GUIDE.md` (contains modulation color scheme)

---

## üéØ 18. Summary

**Total UI Elements Identified**:
- **Colors**: ~100+ distinct color values
- **Layout Constants**: ~20 spacing/padding/dimension values
- **Font Settings**: 2 fonts (default + Chinese)
- **Style Variables**: All ImGuiStyle properties (~60+)
- **Module-Specific**: ~10 modules with custom colors

**Priority Areas**:
1. **High Priority**: ImNodes colors (nodes, pins, links) - most visible
2. **High Priority**: Category colors - affects all node identification
3. **Medium Priority**: Text colors and status indicators
4. **Medium Priority**: Layout and spacing values
5. **Low Priority**: Module-specific colors (can be done incrementally)

**Estimated Effort**:
- **Phase 1-3**: 2-3 days (core infrastructure + color system)
- **Phase 4**: 1-2 days (module-specific)
- **Phase 5**: 1 day (serialization)
- **Phase 6**: 2-3 days (theme presets)

**Total**: ~1-2 weeks for complete implementation

---

## üìù 19. Notes

- Many colors are duplicated across multiple files (e.g., status colors appear twice)
- Some modules use hardcoded colors that could use standard theme colors
- Font path is hardcoded relative to executable - should be configurable
- Grid size and spacing are currently constants but could be user-configurable
- Some special effects (like muted node alpha) are hardcoded but could be themeable

---

**End of Guide** | Version 1.0 | 2025-01-27



================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_opengl/juce_opengl.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <unordered_map>
#include <tuple>
#include <deque>
#include <atomic>
#include <imgui.h>
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/graph/ModularSynthProcessor.h"
#include "PresetManager.h"
#include "SampleManager.h"
#include "MidiManager.h"
#include "ControllerPresetManager.h"
#include "NotificationManager.h"
#include "theme/ThemeEditorComponent.h"

// Forward declarations from Dear ImGui / imnodes
struct ImGuiContext; struct ImGuiIO; struct ImNodesContext;
class MIDIPlayerModuleProcessor;
class MultiSequencerModuleProcessor;
class StrokeSequencerModuleProcessor;
class AnimationModuleProcessor;
class ColorTrackerModule;

// Forward declaration (SavePresetJob is now in its own file to avoid circular dependencies)
class SavePresetJob;

// === NODE SIZING SYSTEM ===
// Standardized node width categories for consistent visual layout
enum class NodeWidth 
{ 
    Small,      // 240px - Basic modules (VCO, VCA, simple utilities)
    Medium,     // 360px - Effects with visualizations (Reverb, Chorus, Phaser)
    Big,        // 480px - Complex modules (PolyVCO, advanced effects)
    ExtraWide,  // 840px - Timeline/grid modules (MultiSequencer, MIDI Player)
    Exception   // Custom size - Module defines its own dimensions via getCustomNodeSize()
};

// Helper function to convert NodeWidth category to pixel width
inline float getWidthForCategory(NodeWidth width)
{
    switch (width)
    {
        case NodeWidth::Medium:    return 360.0f;
        case NodeWidth::Big:       return 480.0f;
        case NodeWidth::ExtraWide: return 840.0f;
        case NodeWidth::Exception: return 0.0f;  // Signals that module provides custom size
        case NodeWidth::Small:
        default:                   return 360.0f;
    }
}

// Pin information struct for node editor
struct PinInfo {
    uint32_t id;      // The unique ID of the pin
    juce::String type; // The parsed type ("Pitch", "Gate", "Trig", etc.)
};

class ImGuiNodeEditorComponent : public juce::Component,
                                 private juce::OpenGLRenderer
{
public:
    ImGuiNodeEditorComponent(juce::AudioDeviceManager& deviceManager);
    ~ImGuiNodeEditorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    // Input is handled by imgui_juce backend; no JUCE overrides needed
    
    void setMidiActivityFrames(int frames) { midiActivityFrames = frames; }
    
    void setModel (ModularSynthProcessor* model)
    { 
        synth = model; 
        if (synth)
        {
            synth->setOnModuleCreated([](const juce::String& pretty){
                NotificationManager::post(NotificationManager::Type::Info, "Created " + pretty + " node");
            });
        }
        undoStack.clear(); 
        redoStack.clear(); 
    }
    
    // ADD: Callback for showing audio settings dialog
    std::function<void()> onShowAudioSettings;
    
    // UI state roundtrip
    juce::ValueTree getUiValueTree() const;
    // Thread-safe: queues UI state to be applied on next render frame
    void applyUiValueTree (const juce::ValueTree& uiState);
    void applyUiValueTreeNow (const juce::ValueTree& uiState);

    // --- Helper structs ---
    struct Range { float min; float max; };
    
    // --- Pin ID System Struct (declare before any usage) ---
    struct PinID
    {
        juce::uint32 logicalId = 0;
        int channel = 0;
        bool isInput = false;
        bool isMod = false;
        juce::String paramId; // used for mod pins
    };

    // OpenGLRenderer
    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;

    // Helper functions for pin type checking and UI
    PinDataType getPinDataTypeForPin(const PinID& pin);
    unsigned int getImU32ForType(PinDataType type);
    const char* pinDataTypeToString(PinDataType type);
    
    void handleRandomizePatch();
    void handleRandomizeConnections();
    void handleConnectSelectedToTrackMixer();
    void handleBeautifyLayout();
    void handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleInsertNodeOnSelectedLinks(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin);
    void drawInsertNodeOnLinkPopup();
    struct LinkInfo;
    void drawLinkInspectorTooltip(const LinkInfo& link);

    // New intelligent auto-connection system
    void parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex);
    
    // Helper functions to get pins from modules
    std::vector<AudioPin> getOutputPins(const juce::String& moduleType);
    std::vector<AudioPin> getInputPins(const juce::String& moduleType);
    AudioPin* findInputPin(const juce::String& moduleType, const juce::String& pinName);
    AudioPin* findOutputPin(const juce::String& moduleType, const juce::String& pinName);
    std::vector<juce::uint32> findNodesOfType(const juce::String& moduleType);
    
    // New dynamic pin-fetching helper
    std::vector<PinInfo> getDynamicOutputPins(ModuleProcessor* module);
    
    template<typename TargetProcessorType>
    void connectToMonophonicTargets(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping, const std::vector<juce::uint32>& targetLids);
    template<typename TargetProcessorType>
    void connectToPolyphonicTarget(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping);
    void handleAutoConnectionRequests();
    
    // MIDI Player Quick Connect handler
    void handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType);
    
    // StrokeSequencer specific handler
    void handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid);
    
    // AnimationModule specific handlers
    void handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid);
    
    // MultiSequencer specific handlers
    void handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    void handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    
    // Color Tracker auto-connect handlers
    void handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid);
    void handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid);

    void renderImGui();
    void handleDeletion();
    void bypassDeleteSelectedNodes();
    void bypassDeleteNode(juce::uint32 logicalId);
    void startSaveDialog();
    void savePresetToFile(const juce::File& file);
    void startLoadDialog();
    std::vector<juce::uint32> getMutedNodeIds() const;
    juce::String getTypeForLogical (juce::uint32 logicalId) const;

    // --- Collision-Proof Pin ID System ---
    // 32-bit ID with guaranteed separation from node IDs:
    // Bit 31: PIN_ID_FLAG (always 1 for pins, 0 for nodes)
    // Bit 30: IS_INPUT_FLAG (1 for input, 0 for output)
    // Bits 16-29: Channel Index (14 bits, up to 16384 channels)
    // Bits 0-15: Node Logical ID (16 bits, up to 65535 nodes)
    // This ensures pin IDs can never collide with node IDs
    
    static int encodePinId(const PinID& pinId)
    {
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);
        
        juce::uint32 encoded = PIN_ID_FLAG |
                               (pinId.isInput ? IS_INPUT_FLAG : 0) |
                               (((juce::uint32)pinId.channel & 0x3FFF) << 16) |
                               (pinId.logicalId & 0xFFFF);
        
        return (int)encoded;
    }

    static PinID decodePinId(int id)
    {
        PinID pinId;
        const juce::uint32 uid = (juce::uint32)id;
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);

        // Only decode if this is actually a pin ID (has the flag set)
        if ((uid & PIN_ID_FLAG) == 0)
        {
            // This is not a pin ID! Return invalid pin
            juce::Logger::writeToLog("[ERROR] decodePinId called with non-pin ID: " + juce::String((int)id));
            pinId.logicalId = 0;
            pinId.channel = 0;
            pinId.isInput = false;
            pinId.isMod = false;
            return pinId;
        }

        pinId.logicalId = uid & 0xFFFF;
        pinId.channel   = (int)((uid >> 16) & 0x3FFF); // 14-bit mask
        pinId.isInput   = (uid & IS_INPUT_FLAG) != 0;
        pinId.isMod     = false; // handled contextually, not in the bitmask
        return pinId;
    }


    juce::OpenGLContext glContext;
    ImGuiContext* imguiContext { nullptr };
    ImGuiIO* imguiIO { nullptr };
    ImNodesContext* editorContext { nullptr };
    double lastTime { 0.0 };

    juce::AudioDeviceManager& deviceManager;
    ModularSynthProcessor* synth { nullptr };
    juce::ValueTree uiPending; // applied at next render before drawing nodes
    std::atomic<bool> graphNeedsRebuild { false };
    int midiActivityFrames = 0; // For MIDI activity indicator
    
    // Preset and sample management
    PresetManager m_presetManager;
    SampleManager m_sampleManager;
    juce::String m_presetSearchTerm;
    juce::String m_sampleSearchTerm;
    juce::File m_presetScanPath;
    juce::File m_sampleScanPath;
    std::unique_ptr<juce::FileChooser> presetPathChooser;
    std::unique_ptr<juce::FileChooser> samplePathChooser;
    
    // MIDI file management
    MidiManager m_midiManager;
    juce::File m_midiScanPath;
    juce::String m_midiSearchTerm;
    std::unique_ptr<juce::FileChooser> midiPathChooser;
    
    // Meta module editing state
    juce::uint32 metaModuleToEditLid = 0;
    
    // Cache of last-known valid node positions (used when graphNeedsRebuild prevents rendering)
    std::unordered_map<int, ImVec2> lastKnownNodePositions;

    // Selection state
    int selectedLogicalId { 0 };

    std::unique_ptr<juce::FileChooser> saveChooser, loadChooser;

    // Map of linkId -> (srcAttr, dstAttr) populated each frame
    std::unordered_map<int, std::pair<int,int>> linkIdToAttrs;
    
    // Link ID registry (cleared each frame for stateless rendering)
    struct LinkKey { int srcAttr; int dstAttr; };
    struct LinkKeyHash { size_t operator()(const LinkKey& k) const noexcept { return ((size_t)k.srcAttr << 32) ^ (size_t)k.dstAttr; } };
    struct LinkKeyEq { bool operator()(const LinkKey& a, const LinkKey& b) const noexcept { return a.srcAttr==b.srcAttr && a.dstAttr==b.dstAttr; } };
    std::unordered_map<LinkKey, int, LinkKeyHash, LinkKeyEq> linkToId;
    int nextLinkId { 1000 };
    int getLinkId(int srcAttr, int dstAttr)
    {
        LinkKey k{ srcAttr, dstAttr };
        auto it = linkToId.find(k);
        if (it != linkToId.end()) return it->second;
        const int id = nextLinkId++;
        linkToId.emplace(k, id);
        return id;
    }

    // Cable inspector highlight state (updated once per frame after EndNodeEditor)
    juce::uint32 hoveredLinkSrcId { 0 };
    juce::uint32 hoveredLinkDstId { 0 };
    static constexpr juce::uint32 kOutputHighlightId = 0xFFFFFFFFu; // sentinel for main output node highlight
    int lastHoveredLinkId { -1 }; // cache inside-editor hovered link id for post-editor use

    // Positions to apply for specific node IDs on the next render (grid space)
    std::unordered_map<int, ImVec2> pendingNodePositions;
    // Screen-space positions queued for just-created nodes (converted after draw)
    std::unordered_map<int, ImVec2> pendingNodeScreenPositions;
    // Sizes to apply for specific node IDs on the next render (for Comment nodes)
    std::unordered_map<int, ImVec2> pendingNodeSizes;

    // Cable inspector rolling stats (last N seconds) for quick visual validation
    struct ChannelHistory 
    { 
        std::deque<std::pair<double, float>> samples; 
        double lastAccessTime = 0.0; // Track when this history was last accessed
    };
    std::map<std::pair<juce::uint32,int>, ChannelHistory> inspectorHistory; // key: (logicalId, channel)
    float inspectorWindowSeconds { 5.0f };

    // --- NEW STATE FOR CABLE SPLITTING ---
    // Stores the attribute ID of the pin we are splitting from.
    // -1 means no split operation is active.
    int splittingFromAttrId = -1;

    // A map to cache the screen position of every pin attribute ID each frame.
    // This is a necessary workaround as ImNodes doesn't provide a public API
    // to get a pin's position by its ID.
    std::unordered_map<int, ImVec2> attrPositions;


    // UI state / hover
    int lastHoveredNodeId { -1 };
    bool isDraggingNode { false };
    bool snapshotAfterEditor { false }; // arm when action requires node to exist (add/duplicate)
    // zoom/pan disabled

    // --- Undo/Redo (module ops) ---
    struct Snapshot
    {
        juce::MemoryBlock synthState;
        juce::ValueTree   uiState;
    };
    std::vector<Snapshot> undoStack;
    std::vector<Snapshot> redoStack;
    void pushSnapshot();
    void restoreSnapshot (const Snapshot& s);
    
    // SampleLoader texture management (use JUCE OpenGLTexture to avoid raw GL includes)
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> sampleLoaderTextureIds;
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> visionModuleTextures;
    
    // Accessor for modules that need to render their own preview with interaction
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>>& getVisionModuleTextures() { return visionModuleTextures; }

    // Preset status tracking
    juce::File currentPresetFile;  // Full file path for save operations
    bool isPatchDirty { false };
    
    // Background save/load operations
    std::atomic<bool> isSaveInProgress { false }; // Debouncing flag for save operations
    juce::ThreadPool threadPool { 2 };

    // Help window
    bool showShortcutsWindow { false };

    // Shortcut debounce
    bool mixerShortcutCooldown { false };
    bool insertNodeShortcutCooldown { false };
    bool showInsertNodePopup { false };
    bool showDebugMenu { false };
    bool showMidiDeviceManager { false };
    ThemeEditorComponent themeEditor;
    int pendingInsertLinkId { -1 };
    
    // Probe tool state
    bool isProbeModeActive { false };
    bool showProbeScope { true };
    
    // Insert node on link state
    struct LinkInfo
    {
        int linkId = -1;
        bool isMod = false;
        // For Audio links:
        PinID srcPin;
        PinID dstPin;
        // For Mod links:
        juce::uint32 srcLogicalId;
        int srcChan;
        juce::uint32 dstLogicalId;
        juce::String paramId;
        // For inspector/probe tooltip:
        juce::uint32 srcNodeId = 0;
        juce::String pinName;
        juce::String sourceNodeName;
        int srcChannel = -1;
        juce::uint32 srcLogicalNodeId = 0;
    };
    LinkInfo linkToInsertOn;
    
    // Mute/Bypass state management (non-destructive)
    struct MutedNodeState {
        std::vector<ModularSynthProcessor::ConnectionInfo> incomingConnections;
        std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
    };
    std::map<juce::uint32, MutedNodeState> mutedNodeStates;
    
    void muteNodeSilent(juce::uint32 logicalId);  // Store mute state without modifying graph (for loading presets)
    void muteNode(juce::uint32 logicalId);
    void unmuteNode(juce::uint32 logicalId);
    void handleMuteToggle();

    // Copy/Paste settings clipboard
    juce::ValueTree nodeSettingsClipboard;
    juce::String clipboardModuleType;

    // Helper functions
    void insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position);
    void insertNodeOnLinkStereo(const juce::String& nodeType, const LinkInfo& linkLeft, const LinkInfo& linkRight, const ImVec2& position);
    juce::File findPresetsDirectory();

    // --- NEW: Handler for node chaining shortcut ---
    void handleNodeChaining();

    // --- NEW: Handlers for color-coded chaining ---
    void handleColorCodedChaining(PinDataType targetType);
    std::vector<AudioPin> getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType);
    
    // --- Recorder Output Shortcut ---
    void handleRecordOutput();
    
    // --- Unified Preset Loading ---
    void loadPresetFromFile(const juce::File& file);
    void mergePresetFromFile(const juce::File& file, ImVec2 dropPosition);
    
    // --- Meta Module (Sub-Patching) Support ---
    void handleCollapseToMetaModule();
    
    // --- Module Category Color Coding ---
    enum class ModuleCategory { Source, Effect, Modulator, Utility, Seq, MIDI, Analysis, TTS_Voice, Special_Exp, OpenCV, Sys, Comment, Plugin };
    ModuleCategory getModuleCategory(const juce::String& moduleType);
    unsigned int getImU32ForCategory(ModuleCategory category, bool hovered = false);
    
    // --- Quick Add Menu ---
    std::map<juce::String, std::pair<const char*, const char*>> getModuleRegistry();
    std::vector<std::pair<juce::String, const char*>> getModuleDescriptions();
    
    // --- VST Plugin Support ---
    void addPluginModules();
    
    // --- Global GPU/CPU Settings ---
    static bool getGlobalGpuEnabled() { return s_globalGpuEnabled; }
    static void setGlobalGpuEnabled(bool enabled) { s_globalGpuEnabled = enabled; }
    
    // --- Eyedropper API ---
public:
    void startColorPicking(std::function<void(ImU32)> onPicked)
    {
        m_isPickingColor = true;
        m_onColorPicked = std::move(onPicked);
    }

private:
    static bool s_globalGpuEnabled; // Global preference for GPU acceleration

    // Eyedropper state
    bool m_isPickingColor { false };
    std::function<void(ImU32)> m_onColorPicked;
};


================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.cpp
================================================================================


#include "ImGuiNodeEditorComponent.h"
#include "PinDatabase.h"
#include "SavePresetJob.h"
#include "NotificationManager.h"
#include "PresetValidator.h"
#include "PresetAutoHealer.h"

#include <imgui.h>
#include <imnodes.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <unordered_map>
#include <unordered_set>
#include <cstdint>
#include <algorithm>
#include <limits>
#include "theme/ThemeManager.h"

// Lightweight theme change toast state
static double s_themeToastEndTime = 0.0;
static juce::String s_themeToastText;

// ============================================================================
// Global GPU/CPU Settings (default: GPU enabled for best performance)
// ============================================================================
bool ImGuiNodeEditorComponent::s_globalGpuEnabled = true;
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/modules/AudioInputModuleProcessor.h"
#include "../audio/modules/AttenuverterModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/RandomModuleProcessor.h"
#include "../audio/modules/ValueModuleProcessor.h"
#include "../audio/modules/SampleLoaderModuleProcessor.h"
#include "../audio/modules/MIDIPlayerModuleProcessor.h"
#include "../audio/modules/PolyVCOModuleProcessor.h"
#include "../audio/modules/TrackMixerModuleProcessor.h"
#include "../audio/modules/MathModuleProcessor.h"
#include "../audio/modules/StepSequencerModuleProcessor.h"
#include "../audio/modules/MultiSequencerModuleProcessor.h"
#include "../audio/modules/StrokeSequencerModuleProcessor.h"
#include "../audio/modules/AnimationModuleProcessor.h"
#include "../audio/modules/TempoClockModuleProcessor.h"
#include "../audio/modules/WebcamLoaderModule.h"
#include "../audio/modules/VideoFileLoaderModule.h"
#include "../audio/modules/MovementDetectorModule.h"
#include "../audio/modules/HumanDetectorModule.h"
#include "../audio/modules/PoseEstimatorModule.h"
#include "../audio/modules/ColorTrackerModule.h"
#include "../audio/modules/ContourDetectorModule.h"
#include "../audio/modules/SemanticSegmentationModule.h"
#include "../audio/modules/ObjectDetectorModule.h"
#include "../audio/modules/HandTrackerModule.h"
#include "../audio/modules/FaceTrackerModule.h"
#include "../audio/modules/VideoFXModule.h"
#include "../audio/modules/CropVideoModule.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/LagProcessorModuleProcessor.h"
#include "../audio/modules/DeCrackleModuleProcessor.h"
#include "../audio/modules/GraphicEQModuleProcessor.h"
#include "../audio/modules/FrequencyGraphModuleProcessor.h"
#include "../audio/modules/ChorusModuleProcessor.h"
#include "../audio/modules/PhaserModuleProcessor.h"
#include "../audio/modules/CompressorModuleProcessor.h"
#include "../audio/modules/RecordModuleProcessor.h"
#include "../audio/modules/CommentModuleProcessor.h"
#include "../audio/modules/LimiterModuleProcessor.h"
#include "../audio/modules/GateModuleProcessor.h"
#include "../audio/modules/DriveModuleProcessor.h"
#include "../audio/modules/VstHostModuleProcessor.h"
// #include "../audio/modules/SnapshotSequencerModuleProcessor.h"  // Commented out - causing build errors
#include "../audio/modules/MIDICVModuleProcessor.h"
#include "../audio/modules/ScopeModuleProcessor.h"
#include "../audio/modules/MetaModuleProcessor.h"
#include "../audio/modules/InletModuleProcessor.h"
#include "../audio/modules/OutletModuleProcessor.h"
#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include <juce_audio_processors/juce_audio_processors.h>
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>
#include <juce_opengl/juce_opengl.h>

#define NODE_DEBUG 1

// --- Module Descriptions for Tooltips ---
static const char* toString(PinDataType t)
{
    switch (t)
    {
        case PinDataType::Audio: return "Audio";
        case PinDataType::CV: return "CV";
        case PinDataType::Gate: return "Gate";
        case PinDataType::Raw: return "Raw";
        case PinDataType::Video: return "Video";
        default: return "Unknown";
    }
}

#define LOG_LINK(msg) do { if (NODE_DEBUG) juce::Logger::writeToLog("[LINK] " + juce::String(msg)); } while(0)

struct Range { float min; float max; };

// Forward declarations
class ModularSynthProcessor;
class RandomModuleProcessor;
class ValueModuleProcessor;
class StepSequencerModuleProcessor;
class MapRangeModuleProcessor;

// Helper methods for MapRange configuration
ImGuiNodeEditorComponent::Range getSourceRange(const ImGuiNodeEditorComponent::PinID& srcPin, ModularSynthProcessor* synth)
{
    if (synth == nullptr) return {0.0f, 1.0f};
    
    auto* module = synth->getModuleForLogical(srcPin.logicalId);
    if (auto* random = dynamic_cast<RandomModuleProcessor*>(module))
    {
        auto& ap = random->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* value = dynamic_cast<ValueModuleProcessor*>(module))
    {
        auto& ap = value->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* stepSeq = dynamic_cast<StepSequencerModuleProcessor*>(module))
    {
        // StepSequencer outputs CV range
        return {0.0f, 1.0f};
    }
    // Fallback: estimate from source's lastOutputValues
    // TODO: implement fallback estimation
    return {0.0f, 1.0f};
}

void configureMapRangeFor(PinDataType srcType, PinDataType dstType, MapRangeModuleProcessor& m, ImGuiNodeEditorComponent::Range inRange)
{
    auto& ap = m.getAPVTS();
    
    // Set input range
    if (auto* inMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin")))
        *inMinParam = inRange.min;
    if (auto* inMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax")))
        *inMaxParam = inRange.max;
    
    // Set output range based on destination type
    if (dstType == PinDataType::Audio)
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = -1.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
    else // CV or Gate
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = 0.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
}




ImGuiNodeEditorComponent::ImGuiNodeEditorComponent(juce::AudioDeviceManager& dm)
    : deviceManager(dm)
{
    juce::Logger::writeToLog("ImGuiNodeEditorComponent constructor starting...");
    
    // --- THIS WILL BE THE SMOKING GUN ---
    juce::Logger::writeToLog("About to populate pin database...");
    populatePinDatabase(); // Initialize the pin database for color coding
    juce::Logger::writeToLog("Pin database populated.");
    
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
    
    // Wire Theme Editor to use framebuffer-based eyedropper
    themeEditor.setStartPicker([this](std::function<void(ImU32)> onPicked){ this->startColorPicking(std::move(onPicked)); });
    
    // Initialize browser paths (load from saved settings or use defaults)
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        // Load the last used paths, providing defaults if they don't exist
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultPresetPath = appFile.getParentDirectory().getChildFile("Presets");
        juce::File defaultSamplePath = appFile.getParentDirectory().getChildFile("Samples");

        m_presetScanPath = juce::File(props->getValue("presetScanPath", defaultPresetPath.getFullPathName()));
        m_sampleScanPath = juce::File(props->getValue("sampleScanPath", defaultSamplePath.getFullPathName()));
    }
    
    // Create these directories if they don't already exist
    if (!m_presetScanPath.exists())
        m_presetScanPath.createDirectory();
    if (!m_sampleScanPath.exists())
        m_sampleScanPath.createDirectory();
    
    juce::Logger::writeToLog("[UI] Preset path set to: " + m_presetScanPath.getFullPathName());
    juce::Logger::writeToLog("[UI] Sample path set to: " + m_sampleScanPath.getFullPathName());
    
    // --- MIDI BROWSER PATH INITIALIZATION ---
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultMidiPath = appFile.getParentDirectory().getChildFile("audio").getChildFile("MIDI");
        m_midiScanPath = juce::File(props->getValue("midiScanPath", defaultMidiPath.getFullPathName()));
    }
    if (!m_midiScanPath.exists())
        m_midiScanPath.createDirectory();
    juce::Logger::writeToLog("[UI] MIDI path set to: " + m_midiScanPath.getFullPathName());
    // --- END OF MIDI INITIALIZATION ---
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    glContext.detach();
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}

// Input handled by imgui_juce backend

void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    
    // Try to load user's saved theme preference, otherwise use default
    if (!ThemeManager::getInstance().loadUserThemePreference())
    {
        // No preference found or failed to load, apply default theme
        ThemeManager::getInstance().applyTheme();
    }
    // If preference was loaded successfully, loadUserThemePreference() already called applyTheme()

    // --- FONT LOADING FOR CHINESE CHARACTERS ---
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->AddFontDefault(); // Load default English font

    // Define the path to your new font file
    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
    auto fontFile = appFile.getParentDirectory().getChildFile("../../Source/assets/NotoSansSC-VariableFont_wght.ttf");

    if (fontFile.existsAsFile())
    {
        ImFontConfig config;
        config.MergeMode = true; // IMPORTANT: This merges the new font into the default one
        config.PixelSnapH = true;

        // Define the character ranges to load for Chinese
        static const ImWchar ranges[] = { 0x4e00, 0x9fbf, 0, }; // Basic CJK Unified Ideographs

        io.Fonts->AddFontFromFileTTF(fontFile.getFullPathName().toRawUTF8(), 16.0f, &config, ranges);
        juce::Logger::writeToLog("ImGuiNodeEditor: Chinese font loaded successfully");
    }
    else
    {
        juce::Logger::writeToLog("ImGuiNodeEditor: WARNING - Chinese font not found at: " + fontFile.getFullPathName());
    }
    
    // --- END OF FONT LOADING ---

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    
    // Build fonts after renderer is initialized
    io.Fonts->Build();

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    
    // Enable grid snapping
    ImNodes::GetStyle().GridSpacing = 64.0f;
    
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    themeEditor.render();  // Render theme editor if open
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);

    // --- Eyedropper sampling after rendering (framebuffer has ImGui drawn) ---
    if (m_isPickingColor)
    {
        ImGuiIO& io = ImGui::GetIO();
        ImVec2 mousePos = ImGui::GetMousePos();

        // Convert to framebuffer Y
        const int fbH = (int) io.DisplaySize.y;
        const int px = juce::jlimit(0, (int)io.DisplaySize.x - 1, (int)mousePos.x);
        const int py = juce::jlimit(0, fbH - 1, fbH - (int)mousePos.y - 1);

        unsigned char rgba[4] { 0, 0, 0, 255 };
        juce::gl::glReadPixels(px, py, 1, 1, juce::gl::GL_RGBA, juce::gl::GL_UNSIGNED_BYTE, rgba);
        ImU32 picked = IM_COL32(rgba[0], rgba[1], rgba[2], 255);

        // Draw cursor overlay
        ImDrawList* fg = ImGui::GetForegroundDrawList();
        const float s = 16.0f;
        ImVec2 tl(mousePos.x + 12, mousePos.y + 12);
        ImVec2 br(tl.x + s, tl.y + s);
        fg->AddRectFilled(tl, br, picked, 3.0f);
        fg->AddRect(tl, br, IM_COL32(0,0,0,255), 3.0f, 0, 1.0f);
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);

        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            if (m_onColorPicked) m_onColorPicked(picked);
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
        else if (ImGui::IsKeyPressed(ImGuiKey_Escape) || ImGui::IsMouseClicked(ImGuiMouseButton_Right))
        {
            m_isPickingColor = false;
            m_onColorPicked = nullptr;
        }
    }
}
void ImGuiNodeEditorComponent::renderImGui()
{
    // Ensure the synth always has the creation notification hook registered
    if (synth != nullptr)
    {
        synth->setOnModuleCreated([](const juce::String& pretty){
            NotificationManager::post(NotificationManager::Type::Info, "Created " + pretty + " node");
        });
    }
    static int frameCounter = 0;
    frameCounter++;

    // ========================= THE DEFINITIVE FIX =========================
    //
    // Rebuild the audio graph at the START of the frame if a change is pending.
    // This ensures that the synth model is in a consistent state BEFORE we try
    // to draw the UI, eliminating the "lost frame" that caused nodes to jump.
    //
    if (graphNeedsRebuild.load())
    {
        juce::Logger::writeToLog("[GraphSync] Rebuild flag is set. Committing changes now...");
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false; // Reset the flag immediately after committing.
        
        // CRITICAL: Invalidate hover state to prevent cable inspector from accessing
        // modules that were just deleted/recreated during commitChanges()
        lastHoveredLinkId = -1;
        lastHoveredNodeId = -1;
        hoveredLinkSrcId = 0;
        hoveredLinkDstId = 0;
        
        juce::Logger::writeToLog("[GraphSync] Graph rebuild complete.");
    }
    // ========================== END OF FIX ==========================

    // Frame start
    
    // --- Stateless Frame Rendering ---
    // Clear link registries at start of each frame for fully stateless rendering.
    // Pin IDs are now generated directly via bitmasking, no maps needed.
    linkIdToAttrs.clear();
    linkToId.clear();
    nextLinkId = 1000;

    // Handle F1 key for shortcuts window
    if (ImGui::IsKeyPressed(ImGuiKey_F1, false))
    {
        showShortcutsWindow = !showShortcutsWindow;
    }

    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_MenuBar);

    // --- DEFINITIVE STATUS OVERLAY ---
    // This code creates the small, semi-transparent window for the preset status.
    const float sidebarWidth = 260.0f;
    const float menuBarHeight = ImGui::GetFrameHeight();
    const float padding = 10.0f;

    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(0.5f);
    ImGui::Begin("Preset Status Overlay", nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize);

    // Display the preset name or "Unsaved Patch"
    if (currentPresetFile.getFullPathName().isNotEmpty()) { // Check if the file path is valid
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8()); // Display just the filename
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    // Display the "Saved" or "Edited" status
    if (isPatchDirty) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");
    } else {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
    }

    ImGui::End();
    // --- END OF OVERLAY ---

    
    // === PROBE SCOPE OVERLAY ===
    if (synth != nullptr && showProbeScope)
    {
        if (auto* scope = synth->getProbeScopeProcessor())
        {
            ImGui::SetNextWindowPos(ImVec2((float)getWidth() - 270.0f, menuBarHeight + padding), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowSize(ImVec2(260, 180), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowBgAlpha(0.85f);
            
            if (ImGui::Begin("üî¨ Probe Scope", &showProbeScope, ImGuiWindowFlags_NoFocusOnAppearing))
            {
                ImGui::Text("Signal Probe");
                ImGui::Separator();
                
                // Get scope buffer
                const auto& buffer = scope->getScopeBuffer();
                
                // Get statistics
                float minVal = 0.0f, maxVal = 0.0f;
                scope->getStatistics(minVal, maxVal);
                
                if (buffer.getNumSamples() > 0 && maxVal - minVal > 0.0001f)
                {
                    // Display stats
                    ImGui::Text("Min: %.3f  Max: %.3f", minVal, maxVal);
                    ImGui::Text("Peak: %.3f", juce::jmax(std::abs(minVal), std::abs(maxVal)));
                    
                    // Draw waveform with explicit width to avoid node expansion feedback
                    ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
                    const int numSamples = buffer.getNumSamples();
                    if (buffer.getNumChannels() > 0)
                    {
                        const float* samples = buffer.getReadPointer(0);
                        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
                    }
                    
                    // Button to clear probe connection
                    if (ImGui::Button("Clear Probe"))
                    {
                        synth->clearProbeConnection();
                    }
                }
                else
                {
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No signal probed");
                    ImGui::Text("Right-click > Probe Signal");
                    ImGui::Text("Then click any output pin");
                }
            }
            ImGui::End();
        }
    }
    // === END OF PROBE SCOPE OVERLAY ===

    // Clean up textures for deleted sample loaders
    if (synth != nullptr)
    {
        auto infos = synth->getModulesInfo();
        std::unordered_set<int> activeSampleLoaderIds;
        for (const auto& info : infos)
        {
            if (info.second.equalsIgnoreCase("sample loader"))
            {
                activeSampleLoaderIds.insert((int)info.first);
            }
        }

        for (auto it = sampleLoaderTextureIds.begin(); it != sampleLoaderTextureIds.end(); )
        {
            if (activeSampleLoaderIds.find(it->first) == activeSampleLoaderIds.end())
            {
                if (it->second)
                    it->second.reset();
                it = sampleLoaderTextureIds.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { 
                if (currentPresetFile.existsAsFile()) {
                    savePresetToFile(currentPresetFile);
                } else {
                    startSaveDialog();
                }
            }
            if (ImGui::MenuItem("Save Preset As...", "Ctrl+Alt+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            
            ImGui::Separator();
            
            // Plugin scanning menu item
            if (ImGui::MenuItem("Scan for Plugins..."))
            {
                // Get the application instance to access plugin management
                auto& app = PresetCreatorApplication::getApp();
                auto& formatManager = app.getPluginFormatManager();
                auto& knownPluginList = app.getKnownPluginList();

                // 1. Find the VST3 format
                juce::VST3PluginFormat* vst3Format = nullptr;
                for (int i = 0; i < formatManager.getNumFormats(); ++i)
                {
                    if (auto* format = formatManager.getFormat(i); format->getName() == "VST3")
                    {
                        vst3Format = dynamic_cast<juce::VST3PluginFormat*>(format);
                        break;
                    }
                }

                if (vst3Format != nullptr)
                {
                    // 2. Define the specific folder to scan
                    juce::File vstDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile)
                                            .getParentDirectory().getChildFile("VST");

                    juce::FileSearchPath searchPath;
                    if (vstDir.isDirectory())
                    {
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Starting scan in: " + vstDir.getFullPathName());
                    }
                    else
                    {
                        vstDir.createDirectory();
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Created VST directory at: " + vstDir.getFullPathName());
                    }

                    // 3. Scan for plugins
                    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                        .getChildFile(app.getApplicationName());
                    
                    juce::PluginDirectoryScanner scanner(knownPluginList, *vst3Format, searchPath, true,
                                                         appDataDir.getChildFile("dead_plugins.txt"), true);

                    // 4. Perform the scan
                    juce::String pluginBeingScanned;
                    int numFound = 0;
                    while (scanner.scanNextFile(true, pluginBeingScanned))
                    {
                        juce::Logger::writeToLog("[VST Scan] Scanning: " + pluginBeingScanned);
                        ++numFound;
                    }
                    
                    juce::Logger::writeToLog("[VST Scan] Scan complete. Found " + juce::String(numFound) + " plugin(s).");
                    juce::Logger::writeToLog("[VST Scan] Total plugins in list: " + juce::String(knownPluginList.getNumTypes()));
                    
                    // 5. Save the updated plugin list
                    auto pluginListFile = appDataDir.getChildFile("known_plugins.xml");
                    if (auto pluginListXml = knownPluginList.createXml())
                    {
                        if (pluginListXml->writeTo(pluginListFile))
                        {
                            juce::Logger::writeToLog("[VST Scan] Saved plugin list to: " + pluginListFile.getFullPathName());
                        }
                    }
                }
                else
                {
                    juce::Logger::writeToLog("[VST Scan] ERROR: VST3 format not found in format manager.");
                }
            }
            
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }
        
        // ========================================================================
        // SETTINGS MENU - Global GPU/CPU Configuration, Audio, and MIDI
        // ========================================================================
        if (ImGui::BeginMenu("Settings"))
        {
            // Audio Settings
            if (ImGui::MenuItem("Audio Settings..."))
            {
                if (onShowAudioSettings)
                    onShowAudioSettings();
            }
            
            // MIDI Device Manager
            if (ImGui::MenuItem("MIDI Device Manager..."))
            {
                showMidiDeviceManager = !showMidiDeviceManager;
            }
            
            ImGui::Separator();

                if (ImGui::BeginMenu("Theme"))
                {
                    if (ImGui::MenuItem("Edit Current Theme..."))
                    {
                        themeEditor.open();
                    }
                    ImGui::Separator();
                    
                    // Simple static theme list for now - will add dynamic scanning later
                    auto loadThemePreset = [&](const char* label, const char* filename)
                    {
                        if (ImGui::MenuItem(label))
                        {
                            juce::File presetFile;
                            auto exeFile = juce::File::getSpecialLocation(juce::File::currentExecutableFile);
                            auto exeDir = exeFile.getParentDirectory();
                            auto themesDir = exeDir.getChildFile("themes");
                            auto candidate = themesDir.getChildFile(filename);
                            
                            if (candidate.existsAsFile())
                            {
                                if (ThemeManager::getInstance().loadTheme(candidate))
                                {
                                    // Save user preference
                                    ThemeManager::getInstance().saveUserThemePreference(filename);
                                    juce::Logger::writeToLog("[Theme] Loaded: " + juce::String(label));
                                    s_themeToastText = "Theme Loaded: " + juce::String(label);
                                    s_themeToastEndTime = ImGui::GetTime() + 2.0;
                                }
                            }
                        }
                    };
                    
                    loadThemePreset("Moofy Dark (Default)", "MoofyDark.json");
                    loadThemePreset("Classic", "ClassicTheme.json");
                    loadThemePreset("Light", "LightTheme.json");
                    loadThemePreset("Electric Grey", "ElectricGrey.json");
                    loadThemePreset("Solarized Light", "SolarizedLight.json");
                    loadThemePreset("Solarized Dark", "SolarizedDark.json");
                    loadThemePreset("Dracula", "Dracula.json");
                    loadThemePreset("Nord", "Nord.json");
                    loadThemePreset("Monokai Pro", "MonokaiPro.json");
                    loadThemePreset("One Dark Pro", "OneDarkPro.json");
                    loadThemePreset("Gruvbox Dark", "GruvboxDark.json");
                    loadThemePreset("Tokyo Night", "TokyoNight.json");
                    loadThemePreset("High Contrast Neon", "HighContrastNeon.json");
                    loadThemePreset("Retro Terminal Green", "RetroTerminalGreen.json");
                    loadThemePreset("Retro Terminal Amber", "RetroTerminalAmber.json");
                    loadThemePreset("Paper White", "PaperWhite.json");
                    loadThemePreset("Cyberpunk", "Cyberpunk.json");

                    ImGui::EndMenu();
                }
            
            ImGui::Separator();
            
            #if WITH_CUDA_SUPPORT
                bool gpuEnabled = getGlobalGpuEnabled();
                if (ImGui::Checkbox("Enable GPU Acceleration (CUDA)", &gpuEnabled))
                {
                    setGlobalGpuEnabled(gpuEnabled);
                    juce::Logger::writeToLog("[Settings] Global GPU: " + juce::String(gpuEnabled ? "ENABLED" : "DISABLED"));
                }
                
                ImGui::TextDisabled("This setting controls all vision nodes:");
                ImGui::TextDisabled("  - Pose Estimator");
                ImGui::TextDisabled("  - Hand Tracker");
                ImGui::TextDisabled("  - Face Tracker");
                ImGui::TextDisabled("  - Object Detector");
                ImGui::TextDisabled("  - Human Detector");
                ImGui::TextDisabled("  - Color Tracker");
                ImGui::TextDisabled("  - Contour Detector");
                ImGui::TextDisabled("  - Movement Detector");
                ImGui::TextDisabled("  - Semantic Segmentation");
                
                ImGui::Separator();
                
                // Show CUDA device info
                #if WITH_CUDA_SUPPORT
                    int deviceCount = cv::cuda::getCudaEnabledDeviceCount();
                    if (deviceCount > 0)
                    {
                        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "CUDA Available");
                        ImGui::Text("GPU Devices: %d", deviceCount);
                    }
                    else
                    {
                        ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "CUDA compiled but no devices found");
                    }
                #endif
            #else
                ImGui::TextDisabled("GPU Acceleration: Not Compiled");
                ImGui::TextDisabled("Rebuild with CUDA support to enable");
            #endif
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Actions"))
        {
            // This item should only be enabled if at least one node is selected
            bool anyNodesSelected = ImNodes::NumSelectedNodes() > 0;
            bool multipleNodesSelected = ImNodes::NumSelectedNodes() > 1;
            
            if (ImGui::MenuItem("Connect Selected to Track Mixer", nullptr, false, anyNodesSelected))
            {
                handleConnectSelectedToTrackMixer();
            }
            
            // Meta Module: Collapse selected nodes into a reusable sub-patch
            if (ImGui::MenuItem("Collapse to Meta Module", "Ctrl+Shift+M", false, multipleNodesSelected))
            {
                handleCollapseToMetaModule();
            }
            
            if (ImGui::MenuItem("Record Output", "Ctrl+R"))
            {
                handleRecordOutput();
            }
            
            if (ImGui::MenuItem("Beautify Layout", "Ctrl+B"))
            {
                handleBeautifyLayout();
            }
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Recording"))
        {
            if (synth != nullptr)
            {
                bool isAnyRecording = synth->isAnyModuleRecording();
                const char* label = isAnyRecording ? "Stop All Recordings" : "Start All Recordings";
                if (ImGui::MenuItem(label))
                {
                    if (isAnyRecording)
                    {
                        synth->stopAllRecorders();
                    }
                    else
                    {
                        synth->startAllRecorders();
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Insert Node"))
        {
            bool isNodeSelected = (selectedLogicalId != 0);
            
            if (ImGui::BeginMenu("Effects", isNodeSelected))
            {
                if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); }
                if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); }
                if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); }
                if (ImGui::MenuItem("Chorus")) { insertNodeBetween("chorus"); }
                if (ImGui::MenuItem("Phaser")) { insertNodeBetween("phaser"); }
                if (ImGui::MenuItem("Compressor")) { insertNodeBetween("compressor"); }
                if (ImGui::MenuItem("Limiter")) { insertNodeBetween("limiter"); }
                if (ImGui::MenuItem("Noise Gate")) { insertNodeBetween("gate"); }
                if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
                if (ImGui::MenuItem("Graphic EQ")) { insertNodeBetween("graphic_eq"); }
                if (ImGui::MenuItem("Waveshaper")) { insertNodeBetween("waveshaper"); }
                if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); }
                if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); }
                if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); }
                if (ImGui::MenuItem("Time/Pitch Shifter")) { insertNodeBetween("timepitch"); }
                if (ImGui::MenuItem("De-Crackle")) { insertNodeBetween("de_crackle"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Modulators", isNodeSelected))
            {
                if (ImGui::MenuItem("LFO")) { insertNodeBetween("lfo"); }
                if (ImGui::MenuItem("ADSR")) { insertNodeBetween("adsr"); }
                if (ImGui::MenuItem("Random")) { insertNodeBetween("random"); }
                if (ImGui::MenuItem("S&H")) { insertNodeBetween("s_and_h"); }
                if (ImGui::MenuItem("Function Generator")) { insertNodeBetween("function_generator"); }
                if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Utilities & Logic", isNodeSelected))
            {
                if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); }
                if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); }
                if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); }
                if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); }
                if (ImGui::MenuItem("Lag Processor")) { insertNodeBetween("lag_processor"); }
                if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); }
                if (ImGui::MenuItem("Map Range")) { insertNodeBetween("map_range"); }
                if (ImGui::MenuItem("Quantizer")) { insertNodeBetween("quantizer"); }
                if (ImGui::MenuItem("Rate")) { insertNodeBetween("rate"); }
                if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); }
                if (ImGui::MenuItem("Logic")) { insertNodeBetween("logic"); }
                if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Computer Vision", isNodeSelected))
            {
                if (ImGui::MenuItem("Video FX")) { insertNodeBetween("video_fx"); }
                if (ImGui::MenuItem("Crop Video")) { insertNodeBetween("crop_video"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("TTS", isNodeSelected))
            {
                if (ImGui::MenuItem("TTS Performer")) { insertNodeBetween("tts_performer"); }
                if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Analysis", isNodeSelected))
            {
                if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); }
                if (ImGui::MenuItem("Frequency Graph")) { insertNodeBetween("frequency_graph"); }
                ImGui::EndMenu();
            }
            
            ImGui::EndMenu();
        }
        // === DEBUG MENU ===
        if (ImGui::BeginMenu("Debug"))
        {
            if (ImGui::MenuItem("Show System Diagnostics", "Ctrl+Shift+D")) 
            {
                showDebugMenu = !showDebugMenu;
            }
            
            
            if (ImGui::MenuItem("Log System State"))
            {
                if (synth != nullptr)
                {
                    juce::Logger::writeToLog("=== SYSTEM DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getSystemDiagnostics());
                }
            }
            
            if (ImGui::MenuItem("Log Selected Module Diagnostics"))
            {
                if (synth != nullptr && selectedLogicalId != 0)
                {
                    juce::Logger::writeToLog("=== MODULE DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getModuleDiagnostics(selectedLogicalId));
                }
            }
            
            ImGui::EndMenu();
        }
        
        // === TRANSPORT CONTROLS ===
        if (synth != nullptr)
        {
            // Get current transport state
            auto transportState = synth->getTransportState();
            
            // Add some spacing before transport controls
            ImGui::Separator();
            ImGui::Spacing();
            
            // Play/Pause button
            if (transportState.isPlaying)
            {
                if (ImGui::Button("Pause"))
                    synth->setPlaying(false);
            }
            else
            {
                if (ImGui::Button("Play"))
                    synth->setPlaying(true);
            }
            
            ImGui::SameLine();
            
            // Stop button (resets position)
            if (ImGui::Button("Stop"))
            {
                synth->setPlaying(false);
                synth->resetTransportPosition();
            }
            
            ImGui::SameLine();
            
            // BPM control (greyed out if controlled by Tempo Clock module)
            float bpm = static_cast<float>(transportState.bpm);
            ImGui::SetNextItemWidth(80.0f);
            
            bool isControlled = transportState.isTempoControlledByModule.load();
            if (isControlled)
                ImGui::BeginDisabled();
                
            if (ImGui::DragFloat("BPM", &bpm, 0.1f, 20.0f, 999.0f, "%.1f"))
                synth->setBPM(static_cast<double>(bpm));
                
            if (isControlled)
            {
                ImGui::EndDisabled();
                if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
                {
                    ImGui::BeginTooltip();
                    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                    ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Module Active");
                    ImGui::TextUnformatted("A Tempo Clock node with 'Sync to Host' disabled is controlling the global BPM.");
                    ImGui::PopTextWrapPos();
                    ImGui::EndTooltip();
                }
            }
            
            ImGui::SameLine();
            
            // Position display
            ImGui::Text("%.2f beats", transportState.songPositionBeats);
        }
        
        // === MULTI-MIDI DEVICE ACTIVITY INDICATOR ===
        ImGui::SameLine();
        ImGui::Separator();
        ImGui::SameLine();
        
        if (synth != nullptr)
        {
            auto activityState = synth->getMidiActivityState();
            
            if (activityState.deviceNames.empty())
            {
                // No MIDI devices connected
                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                ImGui::Text("MIDI: No Devices");
                ImGui::PopStyleColor();
            }
            else
            {
                ImGui::Text("MIDI:");
                ImGui::SameLine();
                
                // Display each device with active channels
                for (const auto& [deviceIndex, deviceName] : activityState.deviceNames)
                {
                    ImGui::SameLine();
                    
                    bool hasActivity = false;
                    if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                    {
                        const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                        for (bool active : channels)
                        {
                            if (active)
                            {
                                hasActivity = true;
                                break;
                            }
                        }
                    }
                    
                    // Abbreviated device name (max 12 chars)
                    juce::String abbrevName = deviceName;
                    if (abbrevName.length() > 12)
                        abbrevName = abbrevName.substring(0, 12) + "...";
                    
                    // Color: bright green if active, dim gray if inactive
                    if (hasActivity)
                        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255));
                    else
                        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                    
                    ImGui::Text("[%s]", abbrevName.toRawUTF8());
                    ImGui::PopStyleColor();
                    
                    // Tooltip with full name and active channels
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("%s", deviceName.toRawUTF8());
                        ImGui::Separator();
                        
                        if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                        {
                            const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                            ImGui::Text("Active Channels:");
                            juce::String activeChannels;
                            for (int ch = 0; ch < 16; ++ch)
                            {
                                if (channels[ch])
                                {
                                    if (activeChannels.isNotEmpty())
                                        activeChannels += ", ";
                                    activeChannels += juce::String(ch + 1);
                                }
                            }
                            if (activeChannels.isEmpty())
                                activeChannels = "None";
                            ImGui::Text("%s", activeChannels.toRawUTF8());
                        }
                        
                        ImGui::EndTooltip();
                    }
                }
            }
        }
        else
        {
            ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
            ImGui::Text("MIDI: ---");
            ImGui::PopStyleColor();
        }
        // === END OF MULTI-MIDI INDICATOR ===
        
        ImGui::EndMainMenuBar();
    }

    // --- PRESET STATUS OVERLAY ---
    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(0.7f);
    ImGui::Begin("Preset Status", nullptr, 
                 ImGuiWindowFlags_NoDecoration | 
                 ImGuiWindowFlags_NoMove | 
                 ImGuiWindowFlags_NoFocusOnAppearing | 
                 ImGuiWindowFlags_NoNav | 
                 ImGuiWindowFlags_AlwaysAutoResize);

    if (currentPresetFile.existsAsFile()) {
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    if (isPatchDirty) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");
    } else {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
    }
    ImGui::End();
    // --- END OF PRESET STATUS OVERLAY ---
    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, 260.0f);
    // Zoom removed
    // ADD THIS BLOCK:
    ImGui::Text("Browser");
    // Create a scrolling child window to contain the entire browser
    ImGui::BeginChild("BrowserScrollRegion", ImVec2(0, 0), true);
    // Helper lambda to recursively draw the directory tree for presets
    std::function<void(const PresetManager::DirectoryNode*)> drawPresetTree = 
        [&](const PresetManager::DirectoryNode* node)
    {
        if (!node || (node->presets.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawPresetTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw presets in this directory with drag-and-drop support
        for (const auto& preset : node->presets)
        {
            if (m_presetSearchTerm.isEmpty() || preset.name.containsIgnoreCase(m_presetSearchTerm))
            {
                // Draw the selectable item and capture its return value
                bool clicked = ImGui::Selectable(preset.name.toRawUTF8());

                // --- THIS IS THE FIX ---
                // Check if this item is the source of a drag operation
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload type and data (the preset's file path)
                    const juce::String path = preset.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_PRESET_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback while dragging
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Merge Preset: %s", preset.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // If a drag did NOT occur, and the item was clicked, load the preset
                else if (clicked)
                {
                    loadPresetFromFile(preset.file);
                }
                // --- END OF FIX ---
                
                // Tooltip (only shown when hovering, not dragging)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0) && preset.description.isNotEmpty())
                {
                    ImGui::BeginTooltip();
                    ImGui::TextUnformatted(preset.description.toRawUTF8());
                    if (!preset.tags.isEmpty())
                        ImGui::Text("Tags: %s", preset.tags.joinIntoString(", ").toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // Helper to push category colors (used for all module category headers)
    auto pushCategoryColor = [&](ModuleCategory cat) {
        ImU32 color = getImU32ForCategory(cat);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        ImGui::PushStyleColor(ImGuiCol_Header, color);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
    };
    // === PRESET BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(218, 165, 32, 255)); // Gold
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(238, 185, 52, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(255, 205, 72, 255));
    bool presetsExpanded = ImGui::CollapsingHeader("Presets");
    ImGui::PopStyleColor(3);
    if (presetsExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_presetScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##presetpath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##preset"))
        {
            presetPathChooser = std::make_unique<juce::FileChooser>("Select Preset Directory", m_presetScanPath);
            presetPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_presetScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("presetScanPath", m_presetScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##preset"))
        {
            m_presetManager.clearCache();
            m_presetManager.scanDirectory(m_presetScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_presetSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##preset", searchBuf, sizeof(searchBuf)))
            m_presetSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical preset tree
        drawPresetTree(m_presetManager.getRootNode());
    }
    
    // Helper lambda to recursively draw the directory tree for samples
    std::function<void(const SampleManager::DirectoryNode*)> drawSampleTree = 
        [&](const SampleManager::DirectoryNode* node)
    {
        if (!node || (node->samples.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawSampleTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw samples in this directory with drag-and-drop support
        for (const auto& sample : node->samples)
        {
            if (m_sampleSearchTerm.isEmpty() || sample.name.containsIgnoreCase(m_sampleSearchTerm))
            {
                // --- THIS IS THE HEROIC FIX ---

                // A. Draw the selectable item and capture its return value (which is true on mouse release).
                bool clicked = ImGui::Selectable(sample.name.toRawUTF8());

                // B. Check if this item is the source of a drag operation. This takes priority.
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload (the data we are transferring is the sample's file path).
                    const juce::String path = sample.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_SAMPLE_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback during the drag.
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Dragging: %s", sample.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // C. If a drag did NOT occur, and the item was clicked (mouse released on it), then create the node.
                else if (clicked)
                {
                    if (synth != nullptr)
                    {
                        auto newNodeId = synth->addModule("sample_loader");
                        auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                        pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                        if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                        {
                            sampleLoader->loadSample(sample.file);
                        }
                        snapshotAfterEditor = true;
                    }
                }
                
                // --- END OF FIX ---

                // (Existing tooltip for sample info remains the same)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Duration: %.2f s", sample.durationSeconds);
                    ImGui::Text("Rate: %d Hz", sample.sampleRate);
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // === SAMPLE BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(0, 180, 180, 255)); // Cyan
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(20, 200, 200, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(40, 220, 220, 255));
    bool samplesExpanded = ImGui::CollapsingHeader("Samples");
    ImGui::PopStyleColor(3);
    
    if (samplesExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_sampleScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##samplepath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##sample"))
        {
            samplePathChooser = std::make_unique<juce::FileChooser>("Select Sample Directory", m_sampleScanPath);
            samplePathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_sampleScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("sampleScanPath", m_sampleScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##sample"))
        {
            m_sampleManager.clearCache();
            m_sampleManager.scanDirectory(m_sampleScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_sampleSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##sample", searchBuf, sizeof(searchBuf)))
            m_sampleSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical sample tree
        drawSampleTree(m_sampleManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MIDI BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(180, 120, 255, 255)); // Purple
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(200, 140, 255, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(220, 160, 255, 255));
    bool midiExpanded = ImGui::CollapsingHeader("MIDI Files");
    ImGui::PopStyleColor(3);
    
    if (midiExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_midiScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##midipath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##midi"))
        {
            midiPathChooser = std::make_unique<juce::FileChooser>("Select MIDI Directory", m_midiScanPath);
            midiPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_midiScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("midiScanPath", m_midiScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##midi"))
        {
            m_midiManager.clearCache();
            m_midiManager.scanDirectory(m_midiScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_midiSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##midi", searchBuf, sizeof(searchBuf)))
            m_midiSearchTerm = juce::String(searchBuf);

        ImGui::Separator();
        
        // 5. Display hierarchical MIDI tree
        std::function<void(const MidiManager::DirectoryNode*)> drawMidiTree = 
            [&](const MidiManager::DirectoryNode* node)
        {
            if (!node || (node->midiFiles.empty() && node->subdirectories.empty())) return;

            // Draw subdirectories first
            for (const auto& subdir : node->subdirectories)
            {
                if (ImGui::TreeNode(subdir->name.toRawUTF8()))
                {
                    drawMidiTree(subdir.get());
                    ImGui::TreePop();
                }
            }
            
            // Then draw MIDI files in this directory with drag-and-drop support
            for (const auto& midi : node->midiFiles)
            {
                if (m_midiSearchTerm.isEmpty() || midi.name.containsIgnoreCase(m_midiSearchTerm))
                {
                    // Draw the selectable item and capture its return value
                    bool clicked = ImGui::Selectable(midi.name.toRawUTF8());

                    // Check if this item is the source of a drag operation
                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                    {
                        // Set the payload (the MIDI file path)
                        const juce::String path = midi.file.getFullPathName();
                        const std::string pathStr = path.toStdString();
                        ImGui::SetDragDropPayload("DND_MIDI_PATH", pathStr.c_str(), pathStr.length() + 1);
                        
                        // Provide visual feedback during the drag
                        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                        ImGui::Text("Dragging: %s", midi.name.toRawUTF8());
                        
                        ImGui::EndDragDropSource();
                    }
                    // If a drag did NOT occur, and the item was clicked, create a new MIDI Player node
                    else if (clicked)
                    {
                        if (synth != nullptr)
                        {
                            auto newNodeId = synth->addModule("midi_player");
                            auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                            pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                            
                            // Load the MIDI file into the new player
                            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                            {
                                midiPlayer->loadMIDIFile(midi.file);
                            }
                            
                            snapshotAfterEditor = true;
                        }
                    }
                    
                    // Tooltip for MIDI info (only shown when hovering, not dragging)
                    if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("MIDI File: %s", midi.file.getFileName().toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
            }
        };
        
        drawMidiTree(m_midiManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MODULE BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(80, 80, 80, 255)); // Neutral Grey
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(100, 100, 100, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(120, 120, 120, 255));
    bool modulesExpanded = ImGui::CollapsingHeader("Modules", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    
    if (modulesExpanded)
    {
    
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
        
        // --- FIX: Show tooltip with module description on hover ---
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            
            // Find the description in our list using the module's internal 'type'
            bool found = false;
            for (const auto& pair : getModuleDescriptions())
            {
                if (pair.first.equalsIgnoreCase(type))
                {
                    // If found, display it
                    ImGui::TextUnformatted(pair.second);
                    found = true;
                    break;
                }
            }
            if (!found)
            {
                // Fallback text if a description is missing
                ImGui::TextUnformatted("No description available.");
            }
            
            ImGui::EndTooltip();
        }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODULE NAMING CONVENTION:
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
    // ALL module type names MUST follow this strict naming convention:
    //   ‚Ä¢ Use ONLY lowercase letters (a-z)
    //   ‚Ä¢ Use ONLY numbers (0-9) where appropriate
    //   ‚Ä¢ Replace ALL spaces with underscores (_)
    //   ‚Ä¢ NO capital letters allowed
    //   ‚Ä¢ NO hyphens or other special characters
    //
    // Examples:
    //   ‚úì CORRECT:   "midi_player", "sample_loader", "graphic_eq", "vco"
    //   ‚úó INCORRECT: "MIDI Player", "Sample Loader", "Graphic EQ", "VCO"
    //
    // This ensures consistent module identification across the system.
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. SOURCES - Signal generators and inputs
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Source);
    bool sourcesExpanded = ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (sourcesExpanded) {
        addModuleButton("VCO", "vco");
        addModuleButton("Polyphonic VCO", "polyvco");
        addModuleButton("Noise", "noise");
        addModuleButton("Audio Input", "audio_input");
        addModuleButton("Sample Loader", "sample_loader");
        addModuleButton("Value", "value");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. EFFECTS - Audio processing and tone shaping
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Effect);
    bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (effectsExpanded) {
        addModuleButton("VCF", "vcf");
        addModuleButton("Delay", "delay");
        addModuleButton("Reverb", "reverb");
        addModuleButton("Chorus", "chorus");
        addModuleButton("Phaser", "phaser");
        addModuleButton("Compressor", "compressor");
        addModuleButton("Limiter", "limiter");
        addModuleButton("Noise Gate", "gate");
        addModuleButton("Drive", "drive");
        addModuleButton("Graphic EQ", "graphic_eq");
        addModuleButton("Waveshaper", "waveshaper");
        addModuleButton("8-Band Shaper", "8bandshaper");
        addModuleButton("Granulator", "granulator");
        addModuleButton("Harmonic Shaper", "harmonic_shaper");
        addModuleButton("Time/Pitch Shifter", "timepitch");
        addModuleButton("De-Crackle", "de_crackle");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. MODULATORS - CV generation and modulation sources
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Modulator);
    bool modulatorsExpanded = ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (modulatorsExpanded) {
        addModuleButton("LFO", "lfo");
        addModuleButton("ADSR", "adsr");
        addModuleButton("Random", "random");
        addModuleButton("S&H", "s_and_h");
        addModuleButton("Function Generator", "function_generator");
        addModuleButton("Shaping Oscillator", "shaping_oscillator");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. UTILITIES & LOGIC - Signal processing and routing
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Utility);
    bool utilitiesExpanded = ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (utilitiesExpanded) {
        addModuleButton("VCA", "vca");
        addModuleButton("Mixer", "mixer");
        addModuleButton("CV Mixer", "cv_mixer");
        addModuleButton("Track Mixer", "track_mixer");
        addModuleButton("Attenuverter", "attenuverter");
        addModuleButton("Lag Processor", "lag_processor");
        addModuleButton("Math", "math");
        addModuleButton("Map Range", "map_range");
        addModuleButton("Quantizer", "quantizer");
        addModuleButton("Rate", "rate");
        addModuleButton("Comparator", "comparator");
        addModuleButton("Logic", "logic");
        addModuleButton("Clock Divider", "clock_divider");
        addModuleButton("Sequential Switch", "sequential_switch");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. SEQUENCERS - Pattern and rhythm generation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Seq);
    bool sequencersExpanded = ImGui::CollapsingHeader("Sequencers", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (sequencersExpanded) {
        addModuleButton("Sequencer", "sequencer");
        addModuleButton("Multi Sequencer", "multi_sequencer");
        addModuleButton("Tempo Clock", "tempo_clock");
        addModuleButton("Snapshot Sequencer", "snapshot_sequencer");
        addModuleButton("Stroke Sequencer", "stroke_sequencer");
        addModuleButton("Timeline", "timeline");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. MIDI - MIDI input/output and controllers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::MIDI);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (midiExpanded) {
        addModuleButton("MIDI CV", "midi_cv");
        addModuleButton("MIDI Player", "midi_player");
        ImGui::Separator();
        addModuleButton("MIDI Faders", "midi_faders");
        addModuleButton("MIDI Knobs", "midi_knobs");
        addModuleButton("MIDI Buttons", "midi_buttons");
        addModuleButton("MIDI Jog Wheel", "midi_jog_wheel");
        addModuleButton("MIDI Pads", "midi_pads");
        ImGui::Separator();
        addModuleButton("MIDI Logger", "midi_logger");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 7. ANALYSIS - Signal visualization and debugging
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Analysis);
    bool analysisExpanded = ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (analysisExpanded) {
        addModuleButton("Scope", "scope");
        addModuleButton("Debug", "debug");
        addModuleButton("Input Debug", "input_debug");
        addModuleButton("Frequency Graph", "frequency_graph");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 8. TTS - Text-to-Speech and vocal synthesis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::TTS_Voice);
    bool ttsExpanded = ImGui::CollapsingHeader("TTS", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (ttsExpanded) {
        addModuleButton("TTS Performer", "tts_performer");
        addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 9. SPECIAL - Physics, animation, and experimental
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Special_Exp);
    bool specialExpanded = ImGui::CollapsingHeader("Special", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (specialExpanded) {
        addModuleButton("Physics", "physics");
        addModuleButton("Animation", "animation");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 10. COMPUTER VISION - Video processing and analysis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::OpenCV);
    bool openCVExpanded = ImGui::CollapsingHeader("Computer Vision", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (openCVExpanded) {
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Sources:");
        addModuleButton("Webcam Loader", "webcam_loader");
        addModuleButton("Video File Loader", "video_file_loader");
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Processors:");
        addModuleButton("Video FX", "video_fx");
        addModuleButton("Movement Detector", "movement_detector");
        addModuleButton("Human Detector", "human_detector");
        addModuleButton("Object Detector", "object_detector");
        addModuleButton("Pose Estimator", "pose_estimator");
        addModuleButton("Hand Tracker", "hand_tracker");
        addModuleButton("Face Tracker", "face_tracker");
        addModuleButton("Color Tracker", "color_tracker");
        addModuleButton("Contour Detector", "contour_detector");
        addModuleButton("Semantic Segmentation", "semantic_segmentation");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 11. PLUGINS / VST - Third-party audio plugins
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Plugin);
    bool pluginsExpanded = ImGui::CollapsingHeader("Plugins / VST", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (pluginsExpanded) {
        addPluginModules();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 12. SYSTEM - Patch organization and system utilities
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Sys);
    bool systemExpanded = ImGui::CollapsingHeader("System", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (systemExpanded) {
        addModuleButton("Meta", "meta");
        addModuleButton("Inlet", "inlet");
        addModuleButton("Outlet", "outlet");
        addModuleButton("Comment", "comment");
        addModuleButton("Recorder", "recorder");
        addModuleButton("VST Host", "vst_host");
        ImGui::Separator();
        addModuleButton("Best Practice", "best_practice");
    }
    
    } // End of Modules collapsing header

    // End the scrolling region
    ImGui::EndChild();

    ImGui::NextColumn();

    // --- DEFINITIVE FIX FOR PRESET DRAG-AND-DROP WITH VISUAL FEEDBACK ---
    // Step 1: Define canvas dimensions first (needed for the drop target)
    // Get grid/canvas colors from theme
    auto& themeMgr = ThemeManager::getInstance();
    const ImU32 GRID_COLOR = themeMgr.getGridColor();
    const ImU32 GRID_ORIGIN_COLOR = themeMgr.getGridOriginColor();
    const float GRID_SIZE = themeMgr.getGridSize();
    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Step 2: Create a full-canvas invisible button to act as our drop area
    ImGui::SetCursorScreenPos(canvas_p0);
    ImGui::InvisibleButton("##canvas_drop_target", canvas_sz);

    // Step 3: Make this area a drop target with visual feedback
    if (ImGui::BeginDragDropTarget())
    {
        // Check if a preset payload is being hovered over the canvas
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_PRESET_PATH", ImGuiDragDropFlags_AcceptBeforeDelivery))
        {
            // Draw a semi-transparent overlay to show the canvas is a valid drop zone
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            drawList->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getDropTargetOverlay());
            
            // Check if the mouse button was released to complete the drop
            if (payload->IsDelivery())
            {
                const char* path = (const char*)payload->Data;
                ImVec2 dropPos = ImGui::GetMousePos(); // Get the exact drop position
                mergePresetFromFile(juce::File(path), dropPos);
            }
        }
        ImGui::EndDragDropTarget();
    }
    // --- END OF DEFINITIVE FIX ---

    // Reset cursor position for subsequent drawing
    ImGui::SetCursorScreenPos(canvas_p0);

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinId({0, c.dstChan, true}) : 
                encodePinId({c.dstLogicalId, c.dstChan, true});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = IM_COL32(150, 150, 150, 255); // Grey for disconnected
    const ImU32 colPinConnected = IM_COL32(120, 255, 120, 255); // Green for connected
    // <<< END OF BLOCK >>>

    // Pre-register is no longer needed - stateless encoding generates IDs on-the-fly
    // (Removed the old pre-registration loop)

    // --- BACKGROUND GRID AND COORDINATE DISPLAY ---
    // (Canvas dimensions already defined above in the drop target code)
    // Draw into the window draw list so colors aren't obscured by window bg
    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    // Note: EditorContextGetPanning() can only be called AFTER BeginNodeEditor()
    // Since we draw the grid before BeginNodeEditor, we use zero panning here
    // The grid will be drawn correctly after BeginNodeEditor is called
    ImVec2 panning(0.0f, 0.0f);

    // Draw canvas background (behind everything)
    draw_list->AddRectFilled(canvas_p0, canvas_p1, themeMgr.getCanvasBackground());

    // Draw grid lines
    for (float x = fmodf(panning.x, GRID_SIZE); x < canvas_sz.x; x += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p0.y + canvas_sz.y), GRID_COLOR);
    for (float y = fmodf(panning.y, GRID_SIZE); y < canvas_sz.y; y += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + y), GRID_COLOR);

    // Draw thicker lines for the origin (0,0)
    ImVec2 origin_on_screen = ImVec2(canvas_p0.x + panning.x, canvas_p0.y + panning.y);
    draw_list->AddLine(ImVec2(origin_on_screen.x, canvas_p0.y), ImVec2(origin_on_screen.x, canvas_p1.y), GRID_ORIGIN_COLOR, 2.0f);
    draw_list->AddLine(ImVec2(canvas_p0.x, origin_on_screen.y), ImVec2(canvas_p1.x, origin_on_screen.y), GRID_ORIGIN_COLOR, 2.0f);

    // Draw scale markers every SCALE_INTERVAL grid units as a grid (not a cross)
    const float SCALE_INTERVAL = themeMgr.getScaleInterval();
    const ImU32 SCALE_TEXT_COLOR = themeMgr.getScaleTextColor();
    ImDrawList* fg_draw_list = ImGui::GetForegroundDrawList();
    
    // X-axis scale markers - always at the bottom edge
    float gridLeft = -panning.x;
    float gridRight = canvas_sz.x - panning.x;
    int startX = (int)std::floor(gridLeft / SCALE_INTERVAL);
    int endX = (int)std::ceil(gridRight / SCALE_INTERVAL);
    
    for (int i = startX; i <= endX; ++i)
    {
        float gridX = i * SCALE_INTERVAL;
        float screenX = canvas_p0.x + panning.x + gridX;
        
        // Only draw if visible on screen
        if (screenX >= canvas_p0.x && screenX <= canvas_p1.x)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridX);
            // Always draw at bottom edge
            fg_draw_list->AddText(ImVec2(screenX + 2, canvas_p1.y - 45), SCALE_TEXT_COLOR, label);
        }
    }
    
    // Y-axis scale markers - always at the left edge
    float gridTop = -panning.y;
    float gridBottom = canvas_sz.y - panning.y;
    int startY = (int)std::floor(gridTop / SCALE_INTERVAL);
    int endY = (int)std::ceil(gridBottom / SCALE_INTERVAL);
    
    for (int i = startY; i <= endY; ++i)
    {
        float gridY = i * SCALE_INTERVAL;
        float screenY = canvas_p0.y + panning.y + gridY;
        
        // Only draw if visible on screen
        if (screenY >= canvas_p0.y && screenY <= canvas_p1.y)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridY);
            // Always draw at left edge
            fg_draw_list->AddText(ImVec2(canvas_p0.x + 5, screenY + 2), SCALE_TEXT_COLOR, label);
        }
    }
    // Mouse coordinate display overlay (bottom-left)
    ImVec2 mouseScreenPos = ImGui::GetMousePos();
    ImVec2 mouseGridPos = ImVec2(mouseScreenPos.x - canvas_p0.x - panning.x, mouseScreenPos.y - canvas_p0.y - panning.y);
    char posStr[32];
    snprintf(posStr, sizeof(posStr), "%.0f, %.0f", mouseGridPos.x, mouseGridPos.y);
    // Use the foreground draw list to ensure text is on top of everything
    // Position at bottom-left: canvas_p1.y is bottom edge, subtract text height plus padding
    ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), themeMgr.getMousePositionText(), posStr);
    // --- END OF BACKGROUND GRID AND COORDINATE DISPLAY ---
    // Node canvas bound to the underlying model if available
    ImNodes::BeginNodeEditor();
    // Now we can safely get the actual panning for any future use
    // (Grid is already drawn with zero panning above, which is fine for background)
    // Begin the editor
    // +++ ADD THIS LINE AT THE START OF THE RENDER LOOP +++
    attrPositions.clear(); // Clear the cache at the beginning of each frame.
    // Rebuild mod attribute mapping from currently drawn nodes only
    // modAttrToParam.clear(); // TODO: Remove when fully migrated
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    // Track duplicates to diagnose disappearing pins
    std::unordered_set<int> seenAttrs;
    auto linkIdOf = [this] (int srcAttr, int dstAttr) -> int
    {
        return getLinkId(srcAttr, dstAttr);
    };
    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                if (!(x == 0.0f && y == 0.0f))
                    pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        // Graph is now always in consistent state since we rebuild at frame start
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;

            // Color-code modules by category (base colors)
            const auto moduleCategory = getModuleCategory(type);
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, getImU32ForCategory(moduleCategory));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));

            // Highlight nodes participating in the hovered link (overrides category color)
            const bool isHoveredSource = (hoveredLinkSrcId != 0 && hoveredLinkSrcId == (juce::uint32) lid);
            const bool isHoveredDest   = (hoveredLinkDstId != 0 && hoveredLinkDstId == (juce::uint32) lid);
            if (isHoveredSource || isHoveredDest)
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));

            // Visual feedback for muted nodes (overrides category color and hover)
            const bool isMuted = mutedNodeStates.count(lid) > 0;
            if (isMuted) {
                ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(80, 80, 80, 255));
            }

            ImNodes::BeginNode ((int) lid);
            ImNodes::BeginNodeTitleBar();
            ImGui::TextUnformatted (type.toRawUTF8());
            ImNodes::EndNodeTitleBar();

            // Get node content width - check if module has custom size, otherwise use default
            float nodeContentWidth = 240.0f; // Default width
            if (auto* mp = synth->getModuleForLogical(lid))
            {
                ImVec2 customSize = mp->getCustomNodeSize();
                if (customSize.x > 0.0f) // Module specified a custom width
                {
                    nodeContentWidth = customSize.x;
                }
            }

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
if (auto* mp = synth->getModuleForLogical (lid))
{
    ImGui::PushID ((int) lid);

    // This new lambda function checks if a parameter is being modulated
    auto isParamModulated = [&](const juce::String& paramId) -> bool {
        if (!synth) return false;
        if (auto* mp = synth->getModuleForLogical(lid))
        {
            int busIdx = -1, chInBus = -1;
            // Use the new standardized routing API on the module itself
            if (!mp->getParamRouting(paramId, busIdx, chInBus)) 
                return false;

            // Calculate the absolute channel index that the graph uses for this bus/channel pair
            const int absoluteChannelIndex = mp->getChannelIndexInProcessBlockBuffer(true, busIdx, chInBus);
            if (absoluteChannelIndex < 0) return false;
            
            // Scan the simple graph connections for a match
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == lid && c.dstChan == absoluteChannelIndex)
                    return true;
            }
        }
        return false;
    };

    // Helper to read a live, modulated value if available (respects _mod alias)
    auto getLiveValueOr = [&](const juce::String& paramId, float fallback) -> float
    {
        if (!synth) return fallback;
        if (auto* mp = synth->getModuleForLogical(lid))
            return mp->getLiveParamValueFor(paramId + "_mod", paramId + "_live", fallback);
        return fallback;
    };

    // Create a new function that calls pushSnapshot
    auto onModificationEnded = [&](){ this->pushSnapshot(); };

    // --- SPECIAL RENDERING FOR SAMPLE LOADER ---
    if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (buttons, sliders, etc.)
        // We pass a modified onModificationEnded to avoid creating undo states while dragging.
        sampleLoader->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);

        // Now, handle the spectrogram texture and drawing
        juce::OpenGLTexture* texturePtr = nullptr;
        if (auto it = sampleLoaderTextureIds.find((int)lid); it != sampleLoaderTextureIds.end())
            texturePtr = it->second.get();

        juce::Image spectrogram = sampleLoader->getSpectrogramImage();
        if (spectrogram.isValid())
        {
            if (texturePtr == nullptr)
            {
                auto tex = std::make_unique<juce::OpenGLTexture>();
                texturePtr = tex.get();
                sampleLoaderTextureIds[(int)lid] = std::move(tex);
            }
            // Upload or update texture from JUCE image (handles format & parameters internally)
            texturePtr->loadImage(spectrogram);

            ImGui::Image((void*)(intptr_t) texturePtr->getTextureID(), ImVec2(nodeContentWidth, 100.0f));

            // Drag state is tracked per Sample Loader node to avoid cross-node interference
            static std::unordered_map<int,int> draggedHandleByNode; // lid -> -1,0,1
            int& draggedHandle = draggedHandleByNode[(int) lid];
            if (draggedHandle != 0 && draggedHandle != 1) draggedHandle = -1;
            ImGui::SetCursorScreenPos(ImGui::GetItemRectMin());
            ImGui::InvisibleButton("##spectrogram_interaction", ImVec2(nodeContentWidth, 100.0f));

            auto* drawList = ImGui::GetWindowDrawList();
            const ImVec2 rectMin = ImGui::GetItemRectMin();
            const ImVec2 rectMax = ImGui::GetItemRectMax();

            float startNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeStart")->load();
            float endNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeEnd")->load();

            // Use live telemetry values when modulated
            startNorm = sampleLoader->getLiveParamValueFor("rangeStart_mod", "rangeStart_live", startNorm);
            endNorm = sampleLoader->getLiveParamValueFor("rangeEnd_mod", "rangeEnd_live", endNorm);

            // Visual guard even when modulated
            const float kMinGap = 0.001f;
            startNorm = juce::jlimit(0.0f, 1.0f, startNorm);
            endNorm   = juce::jlimit(0.0f, 1.0f, endNorm);
            if (startNorm >= endNorm)
            {
                if (startNorm <= 1.0f - kMinGap)
                    endNorm = juce::jmin(1.0f, startNorm + kMinGap);
                else
                    startNorm = juce::jmax(0.0f, endNorm - kMinGap);
            }

            // --- FIX FOR BUG 1: Separate modulation checks for each handle ---
            bool startIsModulated = isParamModulated("rangeStart_mod");
            bool endIsModulated = isParamModulated("rangeEnd_mod");

            const bool itemHovered = ImGui::IsItemHovered();
            const bool itemActive  = ImGui::IsItemActive();
            if (itemHovered)
            {
                ImVec2 mousePos = ImGui::GetMousePos();
                float startHandleX = rectMin.x + startNorm * nodeContentWidth;
                float endHandleX = rectMin.x + endNorm * nodeContentWidth;

                bool canDragStart = !startIsModulated && (std::abs(mousePos.x - startHandleX) < 5);
                bool canDragEnd = !endIsModulated && (std::abs(mousePos.x - endHandleX) < 5);

                if (draggedHandle == -1 && (canDragStart || canDragEnd))
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                }

                if (ImGui::IsItemClicked())
                {
                    // Only allow dragging to start if the corresponding handle is not modulated
                    if (canDragStart && canDragEnd)
                        draggedHandle = (std::abs(mousePos.x - startHandleX) < std::abs(mousePos.x - endHandleX)) ? 0 : 1;
                    else if (canDragStart)
                        draggedHandle = 0;
                    else if (canDragEnd)
                        draggedHandle = 1;
                }
            }

            if (itemActive && ImGui::IsMouseReleased(0))
            {
                if (draggedHandle != -1) onModificationEnded();
                draggedHandle = -1;
            }

            // Handle the drag update, checking the specific modulation flag for the active handle
            if (itemActive && draggedHandle != -1 && ImGui::IsMouseDragging(0))
            {
                float newNormX = juce::jlimit(0.0f, 1.0f, (ImGui::GetMousePos().x - rectMin.x) / nodeContentWidth);
                if (draggedHandle == 0 && !startIsModulated)
                {
                    // Guard: start cannot be >= end
                    startNorm = juce::jmin(newNormX, endNorm - 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeStart")->setValueNotifyingHost(startNorm);
                }
                else if (draggedHandle == 1 && !endIsModulated)
                {
                    // Guard: end cannot be <= start
                    endNorm = juce::jmax(newNormX, startNorm + 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeEnd")->setValueNotifyingHost(endNorm);
                }
            }

            float startX = rectMin.x + startNorm * nodeContentWidth;
            float endX = rectMin.x + endNorm * nodeContentWidth;
            drawList->AddRectFilled(rectMin, ImVec2(startX, rectMax.y), IM_COL32(0, 0, 0, 120));
            drawList->AddRectFilled(ImVec2(endX, rectMin.y), rectMax, IM_COL32(0, 0, 0, 120));
            drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
            drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
        }
    }
    // --- SPECIAL RENDERING FOR AUDIO INPUT (MULTI-CHANNEL) ---
    else if (auto* audioIn = dynamic_cast<AudioInputModuleProcessor*>(mp))
    {
        auto& apvts = audioIn->getAPVTS();

        // --- Device Selectors ---
        juce::AudioDeviceManager::AudioDeviceSetup setup;
        deviceManager.getAudioDeviceSetup(setup);
        
        // Input Device
        juce::StringArray availableInputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableInputDevices = deviceType->getDeviceNames(true);
        }
        std::vector<const char*> inputDeviceItems;
        for (const auto& name : availableInputDevices) inputDeviceItems.push_back(name.toRawUTF8());
        int currentInputDeviceIndex = availableInputDevices.indexOf(setup.inputDeviceName);
        if (currentInputDeviceIndex < 0) currentInputDeviceIndex = 0;

        ImGui::PushItemWidth(nodeContentWidth);
        if (ImGui::Combo("Input Device", &currentInputDeviceIndex, inputDeviceItems.data(), (int)inputDeviceItems.size())) {
            if (currentInputDeviceIndex < availableInputDevices.size()) {
                setup.inputDeviceName = availableInputDevices[currentInputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }

        // Output Device
        juce::StringArray availableOutputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableOutputDevices = deviceType->getDeviceNames(false);
        }
        std::vector<const char*> outputDeviceItems;
        for (const auto& name : availableOutputDevices) outputDeviceItems.push_back(name.toRawUTF8());
        int currentOutputDeviceIndex = availableOutputDevices.indexOf(setup.outputDeviceName);
        if (currentOutputDeviceIndex < 0) currentOutputDeviceIndex = 0;
        
        if (ImGui::Combo("Output Device", &currentOutputDeviceIndex, outputDeviceItems.data(), (int)outputDeviceItems.size())) {
            if (currentOutputDeviceIndex < availableOutputDevices.size()) {
                setup.outputDeviceName = availableOutputDevices[currentOutputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }
        
        // --- Channel Count ---
        auto* numChannelsParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("numChannels"));
        int numChannels = numChannelsParam->get();
        if (ImGui::SliderInt("Channels", &numChannels, 1, AudioInputModuleProcessor::MAX_CHANNELS)) {
            *numChannelsParam = numChannels;
            onModificationEnded();
        }
        
        // --- Threshold Sliders ---
        auto* gateThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"));
        float gateThresh = gateThreshParam->get();
        if (ImGui::SliderFloat("Gate Threshold", &gateThresh, 0.0f, 1.0f, "%.3f")) {
            *gateThreshParam = gateThresh;
            onModificationEnded();
        }
        
        auto* trigThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("triggerThreshold"));
        float trigThresh = trigThreshParam->get();
        if (ImGui::SliderFloat("Trigger Threshold", &trigThresh, 0.0f, 1.0f, "%.3f")) {
            *trigThreshParam = trigThresh;
            onModificationEnded();
        }
        
        ImGui::PopItemWidth();

        // --- Dynamic Channel Selectors & VU Meters ---
        auto hardwareChannels = deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getInputChannelNames() : juce::StringArray{};
        if (!hardwareChannels.isEmpty())
        {
            std::vector<const char*> hwChannelItems;
            for (const auto& name : hardwareChannels) hwChannelItems.push_back(name.toRawUTF8());
            
            for (int i = 0; i < numChannels; ++i) {
                auto* mappingParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(i)));
                int selectedHwChannel = mappingParam->get();
                selectedHwChannel = juce::jlimit(0, (int)hwChannelItems.size() - 1, selectedHwChannel);

                ImGui::PushID(i);
                ImGui::PushItemWidth(nodeContentWidth * 0.6f);
                if (ImGui::Combo(("Input for Out " + juce::String(i + 1)).toRawUTF8(), &selectedHwChannel, hwChannelItems.data(), (int)hwChannelItems.size())) {
                    *mappingParam = selectedHwChannel;
                    std::vector<int> newMapping(numChannels);
                    for (int j = 0; j < numChannels; ++j) {
                        auto* p = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(j)));
                        newMapping[j] = p->get();
                    }
                    synth->setAudioInputChannelMapping(synth->getNodeIdForLogical(lid), newMapping);
                    onModificationEnded();
                }
                ImGui::PopItemWidth();

                ImGui::SameLine();
                
                // --- VU Meter with Threshold Lines ---
                float level = (i < (int)audioIn->channelLevels.size() && audioIn->channelLevels[i]) ? audioIn->channelLevels[i]->load() : 0.0f;
                ImVec2 meterSize(nodeContentWidth * 0.38f, ImGui::GetTextLineHeightWithSpacing() * 0.8f);
                ImGui::ProgressBar(level, meterSize, "");

                // Draw threshold lines on top of the progress bar
                ImVec2 p_min = ImGui::GetItemRectMin();
                ImVec2 p_max = ImGui::GetItemRectMax();
                ImDrawList* draw_list = ImGui::GetWindowDrawList();

                // Gate Threshold (Yellow)
                float gateLineX = p_min.x + gateThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);

                // Trigger Threshold (Orange)
                float trigLineX = p_min.x + trigThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
                
                ImGui::PopID();
            }
        }
    }
    // --- SPECIAL RENDERING FOR OPENCV MODULES (WITH VIDEO FEED) ---
    else if (auto* webcamModule = dynamic_cast<WebcamLoaderModule*>(mp))
    {
        juce::Image frame = webcamModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        webcamModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* videoFileModule = dynamic_cast<VideoFileLoaderModule*>(mp))
    {
        juce::Image frame = videoFileModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        videoFileModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* movementModule = dynamic_cast<MovementDetectorModule*>(mp))
    {
        juce::Image frame = movementModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        movementModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* humanModule = dynamic_cast<HumanDetectorModule*>(mp))
    {
        juce::Image frame = humanModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        humanModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* poseModule = dynamic_cast<PoseEstimatorModule*>(mp))
    {
        juce::Image frame = poseModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        poseModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* colorModule = dynamic_cast<ColorTrackerModule*>(mp))
    {
        juce::Image frame = colorModule->getLatestFrame();
        if (!frame.isNull())
        {
            static std::map<int, int> hoverRadiusByNode; // logicalId -> radius (half-size), default 2 => 5x5
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));

                // Handle color picker clicks when active
                if (colorModule->isPickerActive() && ImGui::IsItemHovered())
                {
                    ImGui::SetTooltip("Click to pick a color from the video");
                    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
                    {
                        ImVec2 mousePos = ImGui::GetMousePos();
                        ImVec2 itemMin = ImGui::GetItemRectMin();
                        ImVec2 itemSize = ImGui::GetItemRectSize();
                        float nx = (mousePos.x - itemMin.x) / itemSize.x;
                        float ny = (mousePos.y - itemMin.y) / itemSize.y;
                        nx = juce::jlimit(0.0f, 1.0f, nx);
                        ny = juce::jlimit(0.0f, 1.0f, ny);
                        // Use ny directly (no flip) to align clicks with displayed image
                        int px = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                        int py = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());
                        juce::Logger::writeToLog(juce::String("[ColorTracker][UI] nx=") + juce::String(nx, 3) + ", ny=" + juce::String(ny, 3) +
                                                  ", px=" + juce::String(px) + ", py=" + juce::String(py));
                        colorModule->addColorAt(px, py);
                        colorModule->exitPickerMode();
                    }
                }

                // Hover preview: median/average color swatch and scroll-wheel radius control
                if (ImGui::IsItemHovered())
                {
                    // Update radius by mouse wheel
                    int& rad = hoverRadiusByNode[(int)lid]; if (rad <= 0) rad = 2;
                    float wheel = ImGui::GetIO().MouseWheel;
                    if (wheel != 0.0f)
                    {
                        rad += (wheel > 0) ? 1 : -1;
                        rad = juce::jlimit(1, 30, rad); // (2*rad+1)^2 window, max 61x61
                    }

                    // Map mouse to pixel
                    ImVec2 mousePos = ImGui::GetMousePos();
                    ImVec2 itemMin = ImGui::GetItemRectMin();
                    ImVec2 itemSize = ImGui::GetItemRectSize();
                    float nx = (mousePos.x - itemMin.x) / itemSize.x;
                    float ny = (mousePos.y - itemMin.y) / itemSize.y;
                    nx = juce::jlimit(0.0f, 1.0f, nx);
                    ny = juce::jlimit(0.0f, 1.0f, ny);
                    int cx = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                    int cy = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());

                    // Sample ROI from juce::Image
                    std::vector<int> vr, vg, vb; vr.reserve((2*rad+1)*(2*rad+1)); vg.reserve(vr.capacity()); vb.reserve(vr.capacity());
                    juce::Image::BitmapData bd(frame, juce::Image::BitmapData::readOnly);
                    auto clampi = [](int v, int lo, int hi){ return (v < lo) ? lo : (v > hi ? hi : v); };
                    for (int y = cy - rad; y <= cy + rad; ++y)
                    {
                        int yy = clampi(y, 0, frame.getHeight()-1);
                        const juce::PixelARGB* row = (const juce::PixelARGB*)(bd.getLinePointer(yy));
                        for (int x = cx - rad; x <= cx + rad; ++x)
                        {
                            int xx = clampi(x, 0, frame.getWidth()-1);
                            const juce::PixelARGB& p = row[xx];
                            vr.push_back(p.getRed());
                            vg.push_back(p.getGreen());
                            vb.push_back(p.getBlue());
                        }
                    }
                    auto median = [](std::vector<int>& v){ std::nth_element(v.begin(), v.begin()+v.size()/2, v.end()); return v[v.size()/2]; };
                    int mr = median(vr), mg = median(vg), mb = median(vb);
                    juce::Colour mc((juce::uint8)mr, (juce::uint8)mg, (juce::uint8)mb);
                    float h = mc.getHue(), s = mc.getSaturation(), b = mc.getBrightness();

                    // Tooltip near cursor with swatch and numbers
                    ImGui::BeginTooltip();
                    ImGui::Text("(%d,%d) rad=%d", cx, cy, rad);
                    ImGui::ColorButton("##hoverSwatch", ImVec4(mc.getFloatRed(), mc.getFloatGreen(), mc.getFloatBlue(), 1.0f), 0, ImVec2(22,22));
                    ImGui::SameLine();
                    ImGui::Text("RGB %d,%d,%d\nHSV %d,%d,%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f));
                    ImGui::EndTooltip();

                    // Textual summary under the image (lightweight)
                    ImGui::TextDisabled("Hover RGB %d,%d,%d  HSV %d,%d,%d  rad=%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f), rad);
                }
            }
        }
        colorModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* contourModule = dynamic_cast<ContourDetectorModule*>(mp))
    {
        juce::Image frame = contourModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        contourModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* segModule = dynamic_cast<SemanticSegmentationModule*>(mp))
    {
        juce::Image frame = segModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        segModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* objModule = dynamic_cast<ObjectDetectorModule*>(mp))
    {
        juce::Image frame = objModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        objModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* handModule = dynamic_cast<HandTrackerModule*>(mp))
    {
        juce::Image frame = handModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        handModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* faceModule = dynamic_cast<FaceTrackerModule*>(mp))
    {
        juce::Image frame = faceModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        faceModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* fxModule = dynamic_cast<VideoFXModule*>(mp))
    {
        juce::Image frame = fxModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                // Flip Y-coords for correct orientation
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        // Now draw the regular parameters below the video
        fxModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* cropVideoModule = dynamic_cast<CropVideoModule*>(mp))
    {
        // CropVideoModule handles its own preview rendering with interaction in drawParametersInNode
        cropVideoModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else
    {
        mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);
    }
    ImGui::Spacing();
    ImGui::PopID();
}
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
            
            // Helper to draw right-aligned text within a node's content width
            // From imnodes examples (color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73):
            // Use ImGui::Indent() for right-alignment - this is the CORRECT ImNodes pattern!
            auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
            {
                const ImVec2 textSize = ImGui::CalcTextSize(txt);
                
                // Indent by (nodeWidth - textWidth) to right-align the text
                // CRITICAL: Must call Unindent() to prevent indent from persisting!
                const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
                ImGui::Indent(indentAmount);
                ImGui::TextUnformatted(txt);
                ImGui::Unindent(indentAmount);  // Reset indent!
            };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinId({lid, channel, true});
                seenAttrs.insert(attr);
                availableAttrs.insert(attr);

                // Get pin data type for color coding
                PinID pinId = { lid, channel, true, false, "" };
                PinDataType pinType = this->getPinDataTypeForPin(pinId);
                unsigned int pinColor = this->getImU32ForType(pinType);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                ImNodes::BeginInputAttribute(attr); ImGui::TextUnformatted(label); ImNodes::EndInputAttribute();

                // --- THIS IS THE DEFINITIVE FIX ---
                // Get the bounding box of the pin circle that was just drawn.
                ImVec2 pinMin = ImGui::GetItemRectMin();
                ImVec2 pinMax = ImGui::GetItemRectMax();
                // Calculate the exact center and cache it.
                float centerX = (pinMin.x + pinMax.x) * 0.5f;
                float centerY = (pinMin.y + pinMax.y) * 0.5f;
                attrPositions[attr] = ImVec2(centerX, centerY);
                // --- END OF FIX ---

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                // CRASH FIX: Verify module exists before accessing it
                                if (c.srcLogicalId != 0 && synth != nullptr)
                                {
                                    bool moduleExists = false;
                                    for (const auto& modInfo : synth->getModulesInfo())
                                    {
                                        if (modInfo.first == c.srcLogicalId)
                                        {
                                            moduleExists = true;
                                            break;
                                        }
                                    }
                                    
                                    if (moduleExists)
                                    {
                                        if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                        {
                                            float value = srcMod->getOutputChannelValue(c.srcChan);
                                            ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                            ImGui::Text("Value: %.3f", value);
                                        }
                                    }
                                }
                                break; 
                            }
                        }
                    } else {
                        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                    }
                    // Show pin data type
                    ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                    ImGui::EndTooltip();
                }
            };

                // NEW CLEAN OUTPUT PIN TEXT FUNCTION - FIXED SPACING
                helpers.drawAudioOutputPin = [&](const char* label, int channel)
                {
                    const int attr = encodePinId({(juce::uint32)lid, channel, false});
                    seenAttrs.insert(attr);
                    availableAttrs.insert(attr);

                    PinID pinId = {(juce::uint32)lid, channel, false, false, ""};
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(attr) > 0;

                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                    // EXACT OFFICIAL PATTERN: Text right-aligned, pin touches text edge
                    ImNodes::BeginOutputAttribute(attr);
                    const float label_width = ImGui::CalcTextSize(label).x;
                    ImGui::Indent(nodeContentWidth - label_width);  // Right-align to content width
                    ImGui::TextUnformatted(label);
                    ImGui::Unindent(nodeContentWidth - label_width);
                    ImNodes::EndOutputAttribute();

                    // Cache pin center
                    {
                        ImVec2 pinMin = ImGui::GetItemRectMin();
                        ImVec2 pinMax = ImGui::GetItemRectMax();
                        float centerY = (pinMin.y + pinMax.y) * 0.5f;
                        float x_pos   = pinMax.x;
                        attrPositions[attr] = ImVec2(x_pos, centerY);
                    }

                    ImNodes::PopColorStyle();

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        if (isConnected) {
                            ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        } else {
                            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                        }
                        ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                        if (auto* mp = synth->getModuleForLogical(lid))
                        {
                            float value = mp->getOutputChannelValue(channel);
                            ImGui::Text("Value: %.3f", value);
                        }
                        ImGui::EndTooltip();
                    }
                };

            // ADD THE NEW drawParallelPins HELPER
            helpers.drawParallelPins = [&](const char* inLabel, int inChannel, const char* outLabel, int outChannel)
            {
                // 3-column layout: [InputPin] [Right-aligned Output Label] [Output Pin]
                ImGui::PushID((inChannel << 16) ^ outChannel ^ lid);
                ImGui::Columns(3, "parallel_io_layout", false);

                const float pinW = 18.0f;
                const float spacing = ImGui::GetStyle().ItemSpacing.x;
                // CRITICAL FIX: Use stable nodeContentWidth to set ALL column widths explicitly
                // This prevents the feedback loop that causes position-dependent node scaling
                
                // Calculate column widths to fill exactly nodeContentWidth
                float inTextW = inLabel ? ImGui::CalcTextSize(inLabel).x : 0.0f;
                float inColW = inLabel ? (inTextW + pinW + spacing) : 0.0f;  // Input label + pin + spacing
                float outPinColW = 20.0f;  // Output pin column (fixed narrow width)
                float labelColW = nodeContentWidth - inColW - outPinColW - spacing;  // Middle fills remaining space

                ImGui::SetColumnWidth(0, inColW);
                ImGui::SetColumnWidth(1, labelColW);
                ImGui::SetColumnWidth(2, outPinColW);

                // Column 0: Input pin with label
                if (inLabel != nullptr)
                {
                    int inAttr = encodePinId({lid, inChannel, true});
                    seenAttrs.insert(inAttr);
                    availableAttrs.insert(inAttr);
                    PinID pinId = { lid, inChannel, true, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedInputAttrs.count(inAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginInputAttribute(inAttr);
                    ImGui::TextUnformatted(inLabel);
                    ImNodes::EndInputAttribute();
                    ImNodes::PopColorStyle();
                }

                // Column 1: Output label (right-aligned within this column)
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    // EXACT OFFICIAL PATTERN: Same as regular output pins
                    const float textW = ImGui::CalcTextSize(outLabel).x;
                    ImGui::Indent(labelColW - textW);  // Right-align to column width
                    ImGui::TextUnformatted(outLabel);
                    ImGui::Unindent(labelColW - textW);
                }

                // Column 2: Output pin
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    int outAttr = encodePinId({lid, outChannel, false});
                    seenAttrs.insert(outAttr);
                    availableAttrs.insert(outAttr);
                    PinID pinId = { lid, outChannel, false, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(outAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginOutputAttribute(outAttr);
                    ImGui::Dummy(ImVec2(1.0f, ImGui::GetTextLineHeight()));
                    ImNodes::EndOutputAttribute();

                    // Cache pin center
                    ImVec2 pinMin = ImGui::GetItemRectMin();
                    ImVec2 pinMax = ImGui::GetItemRectMax();
                    float yCenter = pinMin.y + (pinMax.y - pinMin.y) * 0.5f;
                    float xPos = pinMax.x;
                    attrPositions[outAttr] = ImVec2(xPos, yCenter);
                    ImNodes::PopColorStyle();
                }

                // Restore to single column for the next row
                ImGui::Columns(1);
                ImGui::PopID();
            };

            // --- DYNAMIC PIN FIX ---
            // Add a new helper that uses dynamic pin information from modules
            helpers.drawIoPins = [&](ModuleProcessor* module) {
                if (!module) return;
                const auto logicalId = module->getLogicalId();
                const auto moduleType = synth->getModuleTypeForLogical(logicalId);

                // 1. Get dynamic pins from the module itself.
                auto dynamicInputs = module->getDynamicInputPins();
                auto dynamicOutputs = module->getDynamicOutputPins();

                // 2. Get static pins from the database as a fallback.
                const auto& pinDb = getModulePinDatabase();
                auto pinInfoIt = pinDb.find(moduleType.toLowerCase());
                const bool hasStaticPinInfo = (pinInfoIt != pinDb.end());
                const auto& staticPinInfo = hasStaticPinInfo ? pinInfoIt->second : ModulePinInfo{};

                // 3. If the module has dynamic pins, use the new system
                const bool hasDynamicPins = !dynamicInputs.empty() || !dynamicOutputs.empty();
                
                if (hasDynamicPins)
                {
                    // Draw inputs (dynamic if available, otherwise static)
                    if (!dynamicInputs.empty())
                    {
                        for (const auto& pin : dynamicInputs)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioIns)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    
                    // Draw outputs (dynamic if available, otherwise static)
                    if (!dynamicOutputs.empty())
                    {
                        for (const auto& pin : dynamicOutputs)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioOuts)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                }
                else
                {
                    // 4. Otherwise, fall back to the module's custom drawIoPins implementation
                    module->drawIoPins(helpers);
                }
            };
            // --- END OF DYNAMIC PIN FIX ---

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                    helpers.drawIoPins(mp);

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
            
            // Cache position for snapshot safety
            // Graph is always in consistent state since we rebuild at frame start
            lastKnownNodePositions[(int)lid] = ImNodes::GetNodeGridSpacePos((int)lid);
            
            // Pop muted node styles (in reverse order of push)
            if (isMuted) {
                ImNodes::PopColorStyle();      // Mute TitleBar
                ImGui::PopStyleVar();          // Alpha
                ImNodes::PopStyleVar();        // NodePadding
            }
            
            // Pop hover highlight color
            if (isHoveredSource || isHoveredDest)
                ImNodes::PopColorStyle();      // Hover TitleBar
            
            // Pop category colors (in reverse order of push)
            ImNodes::PopColorStyle();          // TitleBarSelected
            ImNodes::PopColorStyle();          // TitleBarHovered
            ImNodes::PopColorStyle();          // TitleBar
            
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
        if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
        {
            // Apply saved position once; do not write (0,0) defaults
            const ImVec2 p = it->second;
            if (!(p.x == 0.0f && p.y == 0.0f))
            {
                ImNodes::SetNodeGridSpacePos((int) lid, p);
                juce::Logger::writeToLog("[PositionRestore] Applied pending position for node " + juce::String((int)lid) + ": (" + juce::String(p.x) + ", " + juce::String(p.y) + ")");
            }
            pendingNodePositions.erase(it);
        }
            // Apply pending size if queued (for Comment nodes to prevent feedback loop)
            if (auto itSize = pendingNodeSizes.find((int) lid); itSize != pendingNodeSizes.end())
            {
                // Store the desired size in the Comment module itself
                if (auto* comment = dynamic_cast<CommentModuleProcessor*>(synth->getModuleForLogical((juce::uint32)lid)))
                {
                    comment->nodeWidth = itSize->second.x;
                    comment->nodeHeight = itSize->second.y;
                }
                pendingNodeSizes.erase(itSize);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        bool triggerInsertMixer = false;
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0 && selectedLogicalId != 999)
            {
                mutedNodeStates.erase((juce::uint32)selectedLogicalId); // Clean up muted state if exists
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                pushSnapshot();
                NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(1) + " node(s)");
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    pushSnapshot();
                }
            }
            if (ImGui::MenuItem("Insert Mixer", "Ctrl+T") && selectedLogicalId != 0) { triggerInsertMixer = true; }
            ImGui::EndPopup();
        }

        // Shortcut: Ctrl+T to insert a Mixer after selected node and reroute
        // Debounced Ctrl+T
        const bool ctrlDown = ImGui::GetIO().KeyCtrl;
        if (!ctrlDown) {
            mixerShortcutCooldown = false;
            insertNodeShortcutCooldown = false;
        }
        // Ctrl+R: Record Output
        if (ctrlDown && ImGui::IsKeyPressed(ImGuiKey_R, false))
        {
            handleRecordOutput();
        }
        
        if ((triggerInsertMixer || (selectedLogicalId != 0 && ctrlDown && ImGui::IsKeyPressed(ImGuiKey_T))) && !mixerShortcutCooldown)
        {
            mixerShortcutCooldown = true; // Prevent re-triggering in the same frame
            const juce::uint32 srcLid = (juce::uint32) selectedLogicalId;

            juce::Logger::writeToLog("--- [InsertMixer] Start ---");
            juce::Logger::writeToLog("[InsertMixer] Selected Node Logical ID: " + juce::String(srcLid));

            auto srcNodeId = synth->getNodeIdForLogical(srcLid);
            if (srcNodeId.uid == 0) 
            {
                juce::Logger::writeToLog("[InsertMixer] ABORT: Source node with logical ID " + juce::String(srcLid) + " is invalid or could not be found.");
            } 
            else 
            {
                // 1. Collect all outgoing connections from the selected node
                std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
                for (const auto& c : synth->getConnectionsInfo()) {
                    if (c.srcLogicalId == srcLid) {
                        outgoingConnections.push_back(c);
                    }
                }
                juce::Logger::writeToLog("[InsertMixer] Found " + juce::String(outgoingConnections.size()) + " outgoing connections to reroute.");
                for (const auto& c : outgoingConnections) {
                    juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                    juce::Logger::writeToLog("  - Stored connection: [Src: " + juce::String(c.srcLogicalId) + ":" + juce::String(c.srcChan) + "] -> [Dst: " + destStr + ":" + juce::String(c.dstChan) + "]");
                }

                // 2. Create and position the new mixer node intelligently
                auto mixNodeIdGraph = synth->addModule("mixer");
                const juce::uint32 mixLid = synth->getLogicalIdForNode(mixNodeIdGraph);
                
                ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(selectedLogicalId);
                ImVec2 avgDestPos = srcPos; // Default to source pos if no outputs
                
                if (!outgoingConnections.empty())
                {
                    float totalX = 0.0f, totalY = 0.0f;
                    for (const auto& c : outgoingConnections)
                    {
                        int destId = c.dstIsOutput ? 0 : (int)c.dstLogicalId;
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(destId);
                        totalX += pos.x;
                        totalY += pos.y;
                    }
                    avgDestPos = ImVec2(totalX / outgoingConnections.size(), totalY / outgoingConnections.size());
                }
                else
                {
                    // If there are no outgoing connections, place it to the right
                    avgDestPos.x += 600.0f;
                }
                
                // Place the new mixer halfway between the source and the average destination
                pendingNodePositions[(int)mixLid] = ImVec2((srcPos.x + avgDestPos.x) * 0.5f, (srcPos.y + avgDestPos.y) * 0.5f);
                juce::Logger::writeToLog("[InsertMixer] Added new Mixer. Logical ID: " + juce::String(mixLid) + ", Node ID: " + juce::String(mixNodeIdGraph.uid));

                // 3. Disconnect all original outgoing links
                juce::Logger::writeToLog("[InsertMixer] Disconnecting original links...");
                for (const auto& c : outgoingConnections) {
                    auto currentSrcNodeId = synth->getNodeIdForLogical(c.srcLogicalId);
                    auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);

                    if (currentSrcNodeId.uid != 0 && dstNodeId.uid != 0) {
                        bool success = synth->disconnect(currentSrcNodeId, c.srcChan, dstNodeId, c.dstChan);
                        juce::Logger::writeToLog("  - Disconnecting [" + juce::String(currentSrcNodeId.uid) + ":" + juce::String(c.srcChan) + "] -> [" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                    } else {
                        juce::Logger::writeToLog("  - SKIPPING Disconnect due to invalid node ID.");
                    }
                }

                // 4. Connect the source node to the new mixer's first input
                juce::Logger::writeToLog("[InsertMixer] Connecting source node to new mixer...");
                bool c1 = synth->connect(srcNodeId, 0, mixNodeIdGraph, 0); // L to In A L
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":0] -> [" + juce::String(mixNodeIdGraph.uid) + ":0]... " + (c1 ? "SUCCESS" : "FAILED"));
                bool c2 = synth->connect(srcNodeId, 1, mixNodeIdGraph, 1); // R to In A R
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":1] -> [" + juce::String(mixNodeIdGraph.uid) + ":1]... " + (c2 ? "SUCCESS" : "FAILED"));


                // 5. Connect the mixer's output to all the original destinations (maintaining the chain)
                juce::Logger::writeToLog("[InsertMixer] Connecting mixer to original destinations to maintain chain...");
                if (outgoingConnections.empty()) {
                    juce::Logger::writeToLog("  - No original outgoing connections. Connecting mixer to Main Output by default.");
                    auto outNode = synth->getOutputNodeID();
                    if (outNode.uid != 0) {
                        bool o1 = synth->connect(mixNodeIdGraph, 0, outNode, 0);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":0] -> [Output:0]... " + (o1 ? "SUCCESS" : "FAILED"));
                        bool o2 = synth->connect(mixNodeIdGraph, 1, outNode, 1);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":1] -> [Output:1]... " + (o2 ? "SUCCESS" : "FAILED"));
                    }
                } else {
                    for (const auto& c : outgoingConnections) {
                        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                        if (dstNodeId.uid != 0) {
                            // Connect mixer output to the same destination the original node was connected to
                            // This maintains the chain: original -> mixer -> destination
                            bool success = synth->connect(mixNodeIdGraph, c.srcChan, dstNodeId, c.dstChan);
                            juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                            juce::Logger::writeToLog("  - Maintaining chain: Mixer [" + juce::String(mixNodeIdGraph.uid) + ":" + juce::String(c.srcChan) + "] -> " + destStr + "[" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                        } else {
                            juce::Logger::writeToLog("  - SKIPPING Reconnect due to invalid destination node ID for original logical ID " + juce::String(c.dstLogicalId));
                        }
                    }
                }

                graphNeedsRebuild = true;
                pushSnapshot(); // Make the entire operation undoable
                juce::Logger::writeToLog("[InsertMixer] Rerouting complete. Flagging for graph rebuild.");
            }
            juce::Logger::writeToLog("--- [InsertMixer] End ---");
        }

        // Shortcut: Ctrl+I to show Insert Node popup menu
        if (selectedLogicalId != 0 && ctrlDown && ImGui::IsKeyPressed(ImGuiKey_I) && !insertNodeShortcutCooldown)
        {
            insertNodeShortcutCooldown = true;
            showInsertNodePopup = true;
        }

        // Insert Node popup menu
        if (showInsertNodePopup)
        {
            ImGui::OpenPopup("InsertNodePopup");
            showInsertNodePopup = false;
        }

        if (ImGui::BeginPopup("InsertNodePopup"))
        {
            ImGui::Text("Insert Node Between Connections");
            
            // Audio Path
            if (ImGui::MenuItem("VCF")) { insertNodeBetween("VCF"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("VCA")) { insertNodeBetween("VCA"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Delay")) { insertNodeBetween("Delay"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Reverb")) { insertNodeBetween("Reverb"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Mixer")) { insertNodeBetween("Mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping oscillator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Granulator")) { insertNodeBetween("Granulator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic shaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("Vocal Tract Filter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Scope")) { insertNodeBetween("Scope"); ImGui::CloseCurrentPopup(); }
            
            ImGui::Separator();
            
            // Modulation Path
            if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("Attenuverter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Math")) { insertNodeBetween("Math"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Comparator")) { insertNodeBetween("Comparator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("CV Mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("Sequential Switch"); ImGui::CloseCurrentPopup(); }
            
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        const bool isOutputHovered = (hoveredLinkDstId == kOutputHighlightId);
        if (isOutputHovered)
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted ("Output");
        ImNodes::EndNodeTitleBar();
        if (isOutputHovered)
            ImNodes::PopColorStyle();
        
        // In L pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 0, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 0, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
            ImGui::Text ("In L");
            ImNodes::EndInputAttribute();
            ImNodes::PopColorStyle();
        }
        
        // In R pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 1, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 1, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
            ImGui::Text ("In R");
            ImNodes::EndInputAttribute();
            ImNodes::PopColorStyle();
        }
        
        ImNodes::EndNode();
        
        // Cache output node position for snapshot safety
        // Graph is always in consistent state since we rebuild at frame start
        lastKnownNodePositions[0] = ImNodes::GetNodeGridSpacePos(0);
        
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            juce::Logger::writeToLog("[PositionRestore] Applied pending position for output node 0: (" + juce::String(it->second.x) + ", " + juce::String(it->second.y) + ")");
            pendingNodePositions.erase(it);
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections (IDs stable via bitmasking)
        int cableIdx = 0;
        for (const auto& c : synth->getConnectionsInfo())
        {
            
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) {
                continue;
            }
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) {
                continue;
            }
            
            const int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            const int dstAttr = c.dstIsOutput ? encodePinId({0, c.dstChan, true}) : encodePinId({c.dstLogicalId, c.dstChan, true});
            
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
            {
                static std::unordered_set<std::string> skipOnce;
                const std::string key = std::to_string((int)c.srcLogicalId) + ":" + std::to_string(c.srcChan) + "->" +
                                         (c.dstIsOutput? std::string("0") : std::to_string((int)c.dstLogicalId)) + ":" + std::to_string(c.dstChan);
                if (skipOnce.insert(key).second)
                {
                    juce::Logger::writeToLog(
                        juce::String("[ImNodes][SKIP] missing attr: srcPresent=") + (availableAttrs.count(srcAttr)?"1":"0") +
                        " dstPresent=" + (availableAttrs.count(dstAttr)?"1":"0") +
                        " srcKey=(lid=" + juce::String((int)c.srcLogicalId) + ",ch=" + juce::String(c.srcChan) + ")" +
                        " dstKey=(lid=" + juce::String(c.dstIsOutput?0:(int)c.dstLogicalId) + ",ch=" + juce::String(c.dstChan) + ",in=1) id(s)=" +
                        juce::String(srcAttr) + "," + juce::String(dstAttr));
                }
                continue;
            }
            
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            
            // --- THIS IS THE DEFINITIVE FIX ---
            // 1. Determine the base color and check for signal activity.
            auto srcPin = decodePinId(srcAttr);
            PinDataType linkDataType = getPinDataTypeForPin(srcPin);
            ImU32 linkColor = getImU32ForType(linkDataType);
            float magnitude = 0.0f;
            bool hasThicknessModification = false;

            // CRASH FIX: Verify module still exists before accessing it.
            // During preset loading, modules may be destroyed while we're iterating connections.
            if (synth != nullptr && srcPin.logicalId != 0)
            {
                // First verify the module exists in the current module list
                bool moduleExists = false;
                for (const auto& modInfo : synth->getModulesInfo())
                {
                    if (modInfo.first == srcPin.logicalId)
                    {
                        moduleExists = true;
                        break;
                    }
                }
                
                // Only access if module still exists
                if (moduleExists)
                {
                    if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
                    {
                        magnitude = srcModule->getOutputChannelValue(srcPin.channel);
                    }
                }
            }

            // 2. If the signal is active, calculate a glowing/blinking color.
            if (magnitude > 0.01f)
            {
                const float blinkSpeed = 8.0f;
                float blinkFactor = (std::sin((float)ImGui::GetTime() * blinkSpeed) + 1.0f) * 0.5f;
                float glowIntensity = juce::jlimit(0.0f, 1.0f, blinkFactor * magnitude * 2.0f);

                // Brighten the base color and modulate alpha for glow effect
                ImVec4 colorVec = ImGui::ColorConvertU32ToFloat4(linkColor);
                colorVec.x = juce::jmin(1.0f, colorVec.x + glowIntensity * 0.4f);
                colorVec.y = juce::jmin(1.0f, colorVec.y + glowIntensity * 0.4f);
                colorVec.z = juce::jmin(1.0f, colorVec.z + glowIntensity * 0.4f);
                colorVec.w = juce::jlimit(0.5f, 1.0f, 0.5f + glowIntensity * 0.5f);
                linkColor = ImGui::ColorConvertFloat4ToU32(colorVec);

                // Make active cables slightly thicker
                ImNodes::PushStyleVar(ImNodesStyleVar_LinkThickness, 3.0f);
                hasThicknessModification = true;
            }

            // 3. Push the chosen color (either normal or glowing) to the style stack.
            ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);
            ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(255, 255, 0, 255));
            ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(255, 255, 0, 255));

            // 4. Check for node hover highlight (this should override the glow).
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(255, 255, 0, 255));
            }
            
            // 5. Tell imnodes to draw the link. It will use the color we just pushed.
            ImNodes::Link(linkId, srcAttr, dstAttr);
            
            // 6. Pop ALL style modifications to restore the defaults for the next link.
            if (hl) ImNodes::PopColorStyle();
            ImNodes::PopColorStyle(); // LinkSelected
            ImNodes::PopColorStyle(); // LinkHovered
            ImNodes::PopColorStyle(); // Link
            if (hasThicknessModification) ImNodes::PopStyleVar(); // LinkThickness
            
            // --- END OF FIX ---
        }

        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    // --- Handle Auto-Connect Requests from MIDI Players ---
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
        {
            // Check for initial button presses
            if (midiPlayer->autoConnectTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Samplers;
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO;
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Hybrid;
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            // --- THIS IS THE NEW LOGIC ---
            // Check if an update was requested after a new file was loaded
            else if (midiPlayer->connectionUpdateRequested.exchange(false))
            {
                // Re-run the correct handler based on the saved state
                switch (midiPlayer->lastAutoConnectState.load())
                {
                    case MIDIPlayerModuleProcessor::AutoConnectState::Samplers:
                        handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO:
                        handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::Hybrid:
                        handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::None:
                    default:
                        // Do nothing if it wasn't auto-connected before
                        break;
                }
            }
            // --- END OF NEW LOGIC ---
        }
    }
    // --- Handle Auto-Connect Requests using new intelligent system ---
    handleAutoConnectionRequests();
    ImNodes::MiniMap (0.2f, ImNodesMiniMapLocation_BottomRight);
    ImNodes::EndNodeEditor();
    // ================== MIDI PLAYER QUICK CONNECT LOGIC ==================
    // Poll all MIDI Player modules for connection requests
    if (synth != nullptr)
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                int requestType = midiPlayer->getAndClearConnectionRequest();
                if (requestType > 0)
                {
                    handleMIDIPlayerConnectionRequest(modInfo.first, midiPlayer, requestType);
                    break; // Only handle one request per frame
                }
            }
        }
    }
    // ================== END MIDI PLAYER QUICK CONNECT ==================
    // ================== META MODULE EDITING LOGIC ==================
    // Check if any Meta Module has requested to be edited
    if (synth != nullptr && metaModuleToEditLid == 0) // Only check if not already editing one
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                // Atomically check and reset the flag
                if (metaModule->editRequested.exchange(false))
                {
                    metaModuleToEditLid = modInfo.first;
                    juce::Logger::writeToLog("[MetaEdit] Opening editor for Meta Module L-ID " + juce::String((int)metaModuleToEditLid));
                    ImGui::OpenPopup("Edit Meta Module");
                    break; // Only handle one request per frame
                }
            }
        }
    }
    
    // Draw the modal popup for the internal editor if one is selected
    if (metaModuleToEditLid != 0)
    {
        ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
        if (ImGui::BeginPopupModal("Edit Meta Module", nullptr, ImGuiWindowFlags_MenuBar))
        {
            // Get the internal synth processor from the meta module
            auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaModuleToEditLid));
            if (metaModule && metaModule->getInternalGraph())
            {
                // Display a placeholder for now
                // TODO: Full recursive editor implementation would go here
                ImGui::Text("Editing internal graph of Meta Module %d", (int)metaModuleToEditLid);
                ImGui::Separator();
                
                auto* internalGraph = metaModule->getInternalGraph();
                auto modules = internalGraph->getModulesInfo();
                
                ImGui::Text("Internal modules: %d", (int)modules.size());
                if (ImGui::BeginChild("ModuleList", ImVec2(0, -30), true))
                {
                    for (const auto& [lid, type] : modules)
                    {
                        ImGui::Text("  [%d] %s", (int)lid, type.toRawUTF8());
                    }
                }
                ImGui::EndChild();
                
                ImGui::Text("NOTE: Full nested editor UI is a TODO");
                ImGui::Text("For now, you can inspect the internal graph structure above.");
            }
            
            if (ImGui::Button("Close"))
            {
                ImGui::CloseCurrentPopup();
                metaModuleToEditLid = 0;
                // When closing, the meta module might have new/removed inlets/outlets,
                // so we need to rebuild the main graph to update its pins
                graphNeedsRebuild = true;
            }
            ImGui::EndPopup();
        }
        else
        {
            // If the popup was closed by the user (e.g., pressing ESC)
            metaModuleToEditLid = 0;
            graphNeedsRebuild = true;
        }
    }
    // ======================= END OF META MODULE LOGIC =======================

    // --- CONSOLIDATED HOVERED LINK DETECTION ---
    // Declare these variables ONCE, immediately after the editor has ended.
    // All subsequent features that need to know about hovered links can now
    // safely reuse these results without causing redefinition or scope errors.
    // Graph is always in consistent state since we rebuild at frame start
    int hoveredLinkId = -1;
    bool isLinkHovered = ImNodes::IsLinkHovered(&hoveredLinkId);
    // --- END OF CONSOLIDATED DECLARATION ---
    
    // Smart cable visualization is now integrated directly into the link drawing loop above.
    // No separate overlay needed - cables glow by modifying their own color.
    
    // === PROBE TOOL MODE HANDLING ===
    if (isProbeModeActive)
    {
        // Change cursor to indicate probe mode is active
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        
        // Draw "PROBE ACTIVE" indicator at mouse position
        auto* drawList = ImGui::GetForegroundDrawList();
        ImVec2 mousePos = ImGui::GetMousePos();
        const char* text = "PROBE MODE: Click output pin";
        auto textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImVec2(mousePos.x + 20, mousePos.y - 20);
        drawList->AddRectFilled(
            ImVec2(textPos.x - 5, textPos.y - 2),
            ImVec2(textPos.x + textSize.x + 5, textPos.y + textSize.y + 2),
            IM_COL32(50, 50, 50, 200)
        );
        drawList->AddText(textPos, IM_COL32(255, 255, 100, 255), text);
        
        // Check for pin clicks
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                auto pinId = decodePinId(hoveredPinId);
                // Check if it's an output pin (not input, not mod)
                if (!pinId.isInput && !pinId.isMod && pinId.logicalId != 0)
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on valid output pin. LogicalID: " + juce::String(pinId.logicalId) + ", Channel: " + juce::String(pinId.channel));
                    auto nodeId = synth->getNodeIdForLogical(pinId.logicalId);
                    synth->setProbeConnection(nodeId, pinId.channel);
                    isProbeModeActive = false; // Deactivate after probing
                }
                else
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on an invalid pin (input or output node). Cancelling.");
                    isProbeModeActive = false;
                }
            }
            else
            {
                // Clicked on empty space, cancel probe mode
                juce::Logger::writeToLog("[PROBE_UI] Probe clicked on empty space. Cancelling.");
                isProbeModeActive = false;
            }
        }
        
        // Allow ESC to cancel probe mode
        if (ImGui::IsKeyPressed(ImGuiKey_Escape))
        {
            isProbeModeActive = false;
            juce::Logger::writeToLog("[PROBE_UI] Cancelled with ESC");
        }
    }

    // --- CONTEXTUAL RIGHT-CLICK HANDLER ---
    // A cable was right-clicked. Store its info and open the insert popup.
    if (isLinkHovered && hoveredLinkId != -1 && ImGui::IsMouseClicked(ImGuiMouseButton_Right))
    {
        juce::Logger::writeToLog("[InsertNode][RC] Hovered link id=" + juce::String(hoveredLinkId));
        // A cable was right-clicked. Store its info and open the insert popup.
        linkToInsertOn = {}; // Reset previous info
        linkToInsertOn.linkId = hoveredLinkId;

        bool captured = false;
        // TODO: Implement modulation link detection for new bus-based system
        // if (modLinkIdToRoute.count(hoveredLinkId))
        // {
        //     linkToInsertOn.isMod = true;
        //     auto& route = modLinkIdToRoute[hoveredLinkId];
        //     linkToInsertOn.srcLogicalId = std::get<0>(route);
        //     linkToInsertOn.srcChan = std::get<1>(route);
        //     linkToInsertOn.dstLogicalId = std::get<2>(route);
        //     linkToInsertOn.paramId = std::get<3>(route);
        //     juce::Logger::writeToLog("[InsertNode][RC] Mod link captured: srcLID=" + juce::String((int)linkToInsertOn.srcLogicalId) +
        //                               " srcChan=" + juce::String(linkToInsertOn.srcChan) +
        //                               " dstLID=" + juce::String((int)linkToInsertOn.dstLogicalId) +
        //                               " param='" + linkToInsertOn.paramId + "'");
        //     captured = true;
        // }
        if (linkIdToAttrs.count(hoveredLinkId))
        {
            linkToInsertOn.isMod = false;
            auto& attrs = linkIdToAttrs[hoveredLinkId];
            juce::Logger::writeToLog("[InsertNode][RC] Audio link attrs: srcAttr=" + juce::String(attrs.first) +
                                      " dstAttr=" + juce::String(attrs.second));
            linkToInsertOn.srcPin = decodePinId(attrs.first);
            linkToInsertOn.dstPin = decodePinId(attrs.second);
            // Decide list based on pin data types
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            juce::Logger::writeToLog("[InsertNode][RC] Audio pins: src(lid=" + juce::String((int)linkToInsertOn.srcPin.logicalId) +
                                      ",ch=" + juce::String(linkToInsertOn.srcPin.channel) +
                                      ",in=" + juce::String((int)linkToInsertOn.srcPin.isInput) + ") -> dst(lid=" +
                                      juce::String((int)linkToInsertOn.dstPin.logicalId) + ",ch=" +
                                      juce::String(linkToInsertOn.dstPin.channel) + ",in=" +
                                      juce::String((int)linkToInsertOn.dstPin.isInput) + ")");
            captured = true;
        }
        else
        {
            juce::Logger::writeToLog("[InsertNode][RC] Link id not found in maps");
        }

        if (captured)
        {
            showInsertNodePopup = true; // defer opening until after EndNodeEditor
            pendingInsertLinkId = hoveredLinkId;
            juce::Logger::writeToLog("[InsertNode][RC] Will open popup after EndNodeEditor");
        }
        else
        {
            linkToInsertOn.linkId = -1; // nothing recognized; do not open
        }
    }

    // --- Keyboard Shortcuts for Node Chaining ---
    // Check if multiple nodes are selected and no modifiers are held
    if (ImNodes::NumSelectedNodes() > 1 && !ImGui::GetIO().KeyCtrl && !ImGui::GetIO().KeyShift && !ImGui::GetIO().KeyAlt)
    {
        // C: Standard stereo chaining (channels 0->0, 1->1)
        if (ImGui::IsKeyPressed(ImGuiKey_C))
        {
            handleNodeChaining();
        }
        // G: Audio type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_G))
        {
            handleColorCodedChaining(PinDataType::Audio);
        }
        // B: CV type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_B))
        {
            handleColorCodedChaining(PinDataType::CV);
        }
        // R: Raw type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_R))
        {
            handleColorCodedChaining(PinDataType::Raw);
        }
        // Y: Gate type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_Y))
        {
            handleColorCodedChaining(PinDataType::Gate);
        }
        // V: Video type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_V))
        {
            handleColorCodedChaining(PinDataType::Video);
        }
    }
    // --- END OF KEYBOARD SHORTCUTS ---

    // --- Cable Splitting (Ctrl+Middle-Click) ---
    if (isLinkHovered && hoveredLinkId != -1)
    {
        if (ImGui::GetIO().KeyCtrl && ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            // User initiated a split. Find the source pin of the hovered link.
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                splittingFromAttrId = it->second.first; // The source attribute ID
                juce::Logger::writeToLog("[CableSplit] Starting split from attr ID: " + juce::String(splittingFromAttrId));
            }
        }
    }
    // --- END OF CABLE SPLITTING ---

    // 2. If a split-drag is active, handle drawing and completion.
    if (splittingFromAttrId != -1)
    {
        // Draw a line from the source pin to the mouse cursor for visual feedback.
        if (auto it = attrPositions.find(splittingFromAttrId); it != attrPositions.end())
        {
            ImVec2 sourcePos = it->second;
            ImVec2 mousePos = ImGui::GetMousePos();
            ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, IM_COL32(255, 255, 0, 200), 3.0f);
        }

        // 3. Handle completion or cancellation of the drag.
        // We use Left-click to complete the link, matching ImNodes' default behavior.
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                // User dropped the link on a pin.
                auto srcPin = decodePinId(splittingFromAttrId);
                auto dstPin = decodePinId(hoveredPinId);

                // Ensure the connection is valid (Output -> Input).
                if (!srcPin.isInput && dstPin.isInput)
                {
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    graphNeedsRebuild = true;
                    pushSnapshot(); // Make it undoable
                }
            }

            // ALWAYS reset the state, whether the connection was successful or not.
            splittingFromAttrId = -1;
        }
        // Also allow cancellation with a right-click.
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            splittingFromAttrId = -1; // Cancel the operation.
        }
    }
    // --- END OF NEW LOGIC ---

    // Open popup now (outside editor) if requested this frame
    if (showInsertNodePopup)
    {
        showInsertNodePopup = false;
        // Validate the link still exists
        if (pendingInsertLinkId != -1)
        {
            bool stillValid = (/* modLinkIdToRoute.count(pendingInsertLinkId) || */ linkIdToAttrs.count(pendingInsertLinkId));
            if (!stillValid)
            {
                juce::Logger::writeToLog("[InsertNode] Skipping popup: link disappeared this frame");
                pendingInsertLinkId = -1;
            }
        }
        if (pendingInsertLinkId != -1)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            // Consume the mouse release/click so the popup stays open
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode] Opened popup (post-editor)");
        }
        else
        {
            linkToInsertOn = {}; // safety
        }
        pendingInsertLinkId = -1;
    }

    // Fallback: If user right-clicked and a link was hovered this frame, open popup using cached hover
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Right)
        && lastHoveredLinkId != -1
        && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        int id = lastHoveredLinkId;
        linkToInsertOn = {}; linkToInsertOn.linkId = id;
        bool captured = false;
        // TODO: Handle modulation link deletion for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(id); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][RC-Fallback] Mod link captured id=" + juce::String(id));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            // Infer modulation vs audio vs video list from pin data types
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Link captured id=" + juce::String(id));
        }
        if (captured)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Opened popup");
        }
        else
        {
            linkToInsertOn.linkId = -1;
        }
    }
    // This function draws the popup if the popup is open.
    drawInsertNodeOnLinkPopup();

    // --- Cable Inspector: Stateless, rebuild-safe implementation ---
    hoveredLinkSrcId = 0;
    hoveredLinkDstId = 0;

    // Skip inspector if popups are open (graph is always in consistent state now)
    const bool anyPopupOpen = ImGui::IsPopupOpen("InsertNodeOnLinkPopup") || ImGui::IsPopupOpen("AddModulePopup");
    // Do not early-return here; we still need to finish the frame and close any ImGui scopes.

    if (!anyPopupOpen && isLinkHovered && hoveredLinkId != -1 && synth != nullptr)
    {
        // Safety: Re-verify link still exists in our mapping
        auto it = linkIdToAttrs.find(hoveredLinkId);
        if (it != linkIdToAttrs.end())
        {
            auto srcPin = decodePinId(it->second.first);
            auto dstPin = decodePinId(it->second.second);

            // Set highlight IDs for this frame only
            hoveredLinkSrcId = srcPin.logicalId;
            hoveredLinkDstId = (dstPin.logicalId == 0) ? kOutputHighlightId : dstPin.logicalId;

            // Query source module (no caching - stateless)
            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
            {
                // Validate channel index
                const int numOutputs = srcModule->getTotalNumOutputChannels();
                if (srcPin.channel >= 0 && srcPin.channel < numOutputs)
                {
                    // Tell the audio thread WHAT to probe via setProbeConnection
                    auto sourceNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
                    synth->setProbeConnection(sourceNodeId, srcPin.channel);
                    
                    // Create link info for the tooltip
                    LinkInfo linkInfo;
                    linkInfo.srcLogicalNodeId = srcPin.logicalId;
                    linkInfo.srcNodeId = srcPin.logicalId;
                    linkInfo.srcChannel = srcPin.channel;
                    linkInfo.sourceNodeName = srcModule->getName();
                    linkInfo.pinName = srcModule->getAudioOutputLabel(srcPin.channel);
                    if (linkInfo.pinName.isEmpty())
                        linkInfo.pinName = "Channel " + juce::String(srcPin.channel);

                    // Draw our new, advanced tooltip
                    ImGui::BeginTooltip();
                    drawLinkInspectorTooltip(linkInfo);
                    ImGui::EndTooltip();
                }
            }
        }
    }
    else
    {
        // If no link is hovered, tell the probe to stop.
        int hoveredNodeId = -1;
        bool isNodeHovered = ImNodes::IsNodeHovered(&hoveredNodeId);
        
        int hoveredPinId = -1;
        bool isPinHovered = ImNodes::IsPinHovered(&hoveredPinId);
        
        // Only stop probing if we aren't hovering a node, pin, or link
        if (!isLinkHovered && !isNodeHovered && !isPinHovered && synth != nullptr)
        {
            synth->clearProbeConnection();
        }
    }
    

    // Update hovered node/link id for next frame (must be called outside editor scope)
    // Graph is always in consistent state since we rebuild at frame start
    int hv = -1;
    if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    
    int hl = -1;
    if (ImNodes::IsLinkHovered(&hl)) lastHoveredLinkId = hl; else lastHoveredLinkId = -1;
    

    // Shortcut: press 'I' while hovering a link to open Insert-on-Link popup (bypasses mouse handling)
    if (ImGui::IsKeyPressed(ImGuiKey_I) && lastHoveredLinkId != -1 && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        linkToInsertOn = {}; // reset
        linkToInsertOn.linkId = lastHoveredLinkId;
        bool captured = false;
        // TODO: Handle modulation link hover end for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(lastHoveredLinkId); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][KeyI] Mod link captured id=" + juce::String(lastHoveredLinkId));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(lastHoveredLinkId); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            // Check if this is a Video cable (both src and dst are Video)
            if (srcType == PinDataType::Video && dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = false; // Video cables get their own menu, not audio or mod
            }
            // Check if this is CV/Gate/Raw (but not Video - handled above)
            else if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][KeyI] Link captured id=" + juce::String(lastHoveredLinkId));
        }
        if (captured)
        {
            pendingInsertLinkId = lastHoveredLinkId;
            showInsertNodePopup = true; // will open next lines
        }
        else
        {
            linkToInsertOn.linkId = -1;
            juce::Logger::writeToLog("[InsertNode][KeyI] No link data found for id=" + juce::String(lastHoveredLinkId));
        }
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }
    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        // Avoid passing nullptr to ImNodes::IsLinkHovered; some builds may write to the pointer
        int dummyHoveredLinkId = -1;
        const bool anyLinkHovered = ImNodes::IsLinkHovered(&dummyHoveredLinkId);
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered()
            && !anyLinkHovered
            && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup")
            && linkToInsertOn.linkId == -1) // avoid conflict with insert-on-link popup
        {
                ImGui::OpenPopup("AddModulePopup");
        }

        // --- REVISED AND IMPROVED "QUICK ADD" POPUP ---
        if (ImGui::BeginPopup("AddModulePopup"))
        {
            static char searchQuery[128] = "";
            static int selectedIndex = 0;  // Track keyboard navigation

            // Auto-focus the search bar when the popup opens and clear any previous search
            if (ImGui::IsWindowAppearing()) {
                ImGui::SetKeyboardFocusHere(0);
                ImGui::SetWindowFocus();  // Ensure immediate keyboard input capture
                searchQuery[0] = '\0';
                selectedIndex = 0;  // Reset selection
            }
            
            ImGui::Text("Add Module");
            ImGui::PushItemWidth(250.0f);
            
            // Enable Enter key detection for instant module creation
            bool enterPressed = ImGui::InputText("Search##addmodule", searchQuery, sizeof(searchQuery), 
                                                  ImGuiInputTextFlags_EnterReturnsTrue);
            
            ImGui::PopItemWidth();
            ImGui::Separator();
            
            // --- PROBE TOOL ---
            if (ImGui::MenuItem("üî¨ Probe Signal (Click any output pin)"))
            {
                isProbeModeActive = true;
                ImGui::CloseCurrentPopup();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Activate probe mode to instantly visualize any signal without manual patching.\nClick on any output pin to route it to the probe scope.");
            }
            ImGui::Separator();

            auto addAtMouse = [this](const char* type) {
                auto nodeId = synth->addModule(type);
                juce::String nodeName = juce::String(type).replaceCharacter('_', ' ');
                // Capitalize first letter of each word
                nodeName = nodeName.toLowerCase();
                bool capitalizeNext = true;
                for (int i = 0; i < nodeName.length(); ++i)
                {
                    if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
                    {
                        nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                        capitalizeNext = false;
                    }
                    else if (nodeName[i] == ' ')
                        capitalizeNext = true;
                }
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                // This places the new node exactly where the user right-clicked
                pendingNodeScreenPositions[logicalId] = ImGui::GetMousePosOnOpeningCurrentPopup();
                
                // Special handling for recorder module
                if (juce::String(type).equalsIgnoreCase("recorder"))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical((juce::uint32)logicalId)))
                    {
                        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
                    }
                }
                
                // Give comment nodes a default size to prevent feedback loop
                if (juce::String(type).equalsIgnoreCase("comment"))
                {
                    pendingNodeSizes[logicalId] = ImVec2(250.f, 150.f);
                }
                
                snapshotAfterEditor = true;
                ImGui::CloseCurrentPopup();
            };
            
            juce::String filter(searchQuery);

            ImGui::BeginChild("ModuleList", ImVec2(280, 350), true);

            if (filter.isEmpty())
            {
                // --- BROWSE MODE (No text in search bar) ---
                // Reorganized to match the new category structure
                
                if (ImGui::BeginMenu("Sources")) {
                    if (ImGui::MenuItem("VCO")) addAtMouse("vco");
                    if (ImGui::MenuItem("Polyphonic VCO")) addAtMouse("polyvco");
                    if (ImGui::MenuItem("Noise")) addAtMouse("noise");
                    if (ImGui::MenuItem("Audio Input")) addAtMouse("audio_input");
                    if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample_loader");
                    if (ImGui::MenuItem("Value")) addAtMouse("value");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Effects")) {
                    if (ImGui::MenuItem("VCF")) addAtMouse("vcf");
                    if (ImGui::MenuItem("Delay")) addAtMouse("delay");
                    if (ImGui::MenuItem("Reverb")) addAtMouse("reverb");
                    if (ImGui::MenuItem("Chorus")) addAtMouse("chorus");
                    if (ImGui::MenuItem("Phaser")) addAtMouse("phaser");
                    if (ImGui::MenuItem("Compressor")) addAtMouse("compressor");
                    if (ImGui::MenuItem("Limiter")) addAtMouse("limiter");
                    if (ImGui::MenuItem("Noise Gate")) addAtMouse("gate");
                    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
                    if (ImGui::MenuItem("Graphic EQ")) addAtMouse("graphic_eq");
                    if (ImGui::MenuItem("Waveshaper")) addAtMouse("waveshaper");
                    if (ImGui::MenuItem("8-Band Shaper")) addAtMouse("8bandshaper");
                    if (ImGui::MenuItem("Granulator")) addAtMouse("granulator");
                    if (ImGui::MenuItem("Harmonic Shaper")) addAtMouse("harmonic_shaper");
                    if (ImGui::MenuItem("Time/Pitch Shifter")) addAtMouse("timepitch");
                    if (ImGui::MenuItem("De-Crackle")) addAtMouse("de_crackle");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Modulators")) {
                    if (ImGui::MenuItem("LFO")) addAtMouse("lfo");
                    if (ImGui::MenuItem("ADSR")) addAtMouse("adsr");
                    if (ImGui::MenuItem("Random")) addAtMouse("random");
                    if (ImGui::MenuItem("S&H")) addAtMouse("s_and_h");
                    if (ImGui::MenuItem("Function Generator")) addAtMouse("function_generator");
                    if (ImGui::MenuItem("Shaping Oscillator")) addAtMouse("shaping_oscillator");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Utilities & Logic")) {
                    if (ImGui::MenuItem("VCA")) addAtMouse("vca");
                    if (ImGui::MenuItem("Mixer")) addAtMouse("mixer");
                    if (ImGui::MenuItem("CV Mixer")) addAtMouse("cv_mixer");
                    if (ImGui::MenuItem("Track Mixer")) addAtMouse("track_mixer");
                    if (ImGui::MenuItem("Attenuverter")) addAtMouse("attenuverter");
                    if (ImGui::MenuItem("Lag Processor")) addAtMouse("lag_processor");
                    if (ImGui::MenuItem("Math")) addAtMouse("math");
                    if (ImGui::MenuItem("Map Range")) addAtMouse("map_range");
                    if (ImGui::MenuItem("Quantizer")) addAtMouse("quantizer");
                    if (ImGui::MenuItem("Rate")) addAtMouse("rate");
                    if (ImGui::MenuItem("Comparator")) addAtMouse("comparator");
                    if (ImGui::MenuItem("Logic")) addAtMouse("logic");
                    if (ImGui::MenuItem("Clock Divider")) addAtMouse("clock_divider");
                    if (ImGui::MenuItem("Sequential Switch")) addAtMouse("sequential_switch");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Sequencers")) {
                    if (ImGui::MenuItem("Sequencer")) addAtMouse("sequencer");
                    if (ImGui::MenuItem("Multi Sequencer")) addAtMouse("multi_sequencer");
                    if (ImGui::MenuItem("Tempo Clock")) addAtMouse("tempo_clock");
                    if (ImGui::MenuItem("Snapshot Sequencer")) addAtMouse("snapshot_sequencer");
                    if (ImGui::MenuItem("Stroke Sequencer")) addAtMouse("stroke_sequencer");
                    if (ImGui::MenuItem("Timeline")) addAtMouse("timeline");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("MIDI")) {
                    if (ImGui::MenuItem("MIDI CV")) addAtMouse("midi_cv");
                    if (ImGui::MenuItem("MIDI Player")) addAtMouse("midi_player");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Faders")) addAtMouse("midi_faders");
                    if (ImGui::MenuItem("MIDI Knobs")) addAtMouse("midi_knobs");
                    if (ImGui::MenuItem("MIDI Buttons")) addAtMouse("midi_buttons");
                    if (ImGui::MenuItem("MIDI Jog Wheel")) addAtMouse("midi_jog_wheel");
                    if (ImGui::MenuItem("MIDI Pads")) addAtMouse("midi_pads");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Logger")) addAtMouse("midi_logger");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Analysis")) {
                    if (ImGui::MenuItem("Scope")) addAtMouse("scope");
                    if (ImGui::MenuItem("Debug")) addAtMouse("debug");
                    if (ImGui::MenuItem("Input Debug")) addAtMouse("input_debug");
                    if (ImGui::MenuItem("Frequency Graph")) addAtMouse("frequency_graph");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("TTS")) {
                    if (ImGui::MenuItem("TTS Performer")) addAtMouse("tts_performer");
                    if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("vocal_tract_filter");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Special")) {
                    if (ImGui::MenuItem("Physics")) addAtMouse("physics");
                    if (ImGui::MenuItem("Animation")) addAtMouse("animation");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Computer Vision")) {
                    if (ImGui::MenuItem("Webcam Loader")) addAtMouse("webcam_loader");
                    if (ImGui::MenuItem("Video File Loader")) addAtMouse("video_file_loader");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Video FX")) addAtMouse("video_fx");
                    if (ImGui::MenuItem("Crop Video")) addAtMouse("crop_video");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Movement Detector")) addAtMouse("movement_detector");
                    if (ImGui::MenuItem("Human Detector")) addAtMouse("human_detector");
                    if (ImGui::MenuItem("Object Detector")) addAtMouse("object_detector");
                    if (ImGui::MenuItem("Pose Estimator")) addAtMouse("pose_estimator");
                    if (ImGui::MenuItem("Hand Tracker")) addAtMouse("hand_tracker");
                    if (ImGui::MenuItem("Face Tracker")) addAtMouse("face_tracker");
                    if (ImGui::MenuItem("Color Tracker")) addAtMouse("color_tracker");
                    if (ImGui::MenuItem("Contour Detector")) addAtMouse("contour_detector");
                    if (ImGui::MenuItem("Semantic Segmentation")) addAtMouse("semantic_segmentation");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Plugins / VST")) {
                    addPluginModules(); // Re-use your existing plugin menu logic
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("System")) {
                    if (ImGui::MenuItem("Meta")) addAtMouse("meta");
                    if (ImGui::MenuItem("Inlet")) addAtMouse("inlet");
                    if (ImGui::MenuItem("Outlet")) addAtMouse("outlet");
                    if (ImGui::MenuItem("Comment")) addAtMouse("comment");
                    if (ImGui::MenuItem("Recorder")) addAtMouse("recorder");
                    if (ImGui::MenuItem("VST Host")) addAtMouse("vst_host");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Best Practice")) addAtMouse("best_practice");
                    ImGui::EndMenu();
                }
            }
            else
            {
                // --- SEARCH MODE (Text has been entered) ---
                // Build list of matching modules first for keyboard navigation
                struct MatchedModule {
                    juce::String displayName;
                    const char* internalType;
                    const char* description;
                };
                std::vector<MatchedModule> matches;
                
                for (const auto& entry : getModuleRegistry())
                {
                    const juce::String& displayName = entry.first;
                    const char* internalType = entry.second.first;
                    const char* description = entry.second.second;
                    
                    if (displayName.containsIgnoreCase(filter))
                    {
                        matches.push_back({displayName, internalType, description});
                    }
                }
                
                // Handle keyboard navigation (arrow keys)
                if (ImGui::IsKeyPressed(ImGuiKey_DownArrow)) 
                {
                    selectedIndex++;
                    if (selectedIndex >= (int)matches.size()) 
                        selectedIndex = (int)matches.size() - 1;
                }
                if (ImGui::IsKeyPressed(ImGuiKey_UpArrow)) 
                {
                    selectedIndex--;
                    if (selectedIndex < 0) 
                        selectedIndex = 0;
                }
                
                // Handle Enter key to create selected module
                if (enterPressed && !matches.empty())
                {
                    if (selectedIndex >= 0 && selectedIndex < (int)matches.size())
                    {
                        addAtMouse(matches[selectedIndex].internalType);
                    }
                }
                
                // Display the matching modules with selection highlight
                for (int i = 0; i < (int)matches.size(); ++i)
                {
                    const auto& match = matches[i];
                    bool isSelected = (i == selectedIndex);
                    
                    if (ImGui::Selectable(match.displayName.toRawUTF8(), isSelected))
                    {
                        addAtMouse(match.internalType);
                    }
                    
                    // Auto-scroll to keep selected item visible
                    if (isSelected && ImGui::IsItemVisible() == false)
                    {
                        ImGui::SetScrollHereY(0.5f);
                    }
                    
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::TextUnformatted(match.description);
                        ImGui::EndTooltip();
                    }
                }
                
                // Reset selection if out of bounds
                if (selectedIndex >= (int)matches.size())
                    selectedIndex = (int)matches.size() - 1;
                if (selectedIndex < 0)
                    selectedIndex = 0;
            }

            ImGui::EndChild();
            ImGui::EndPopup();
        }

        // Helper functions are now class methods

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinId(startAttr);
            auto endPin = decodePinId(endAttr);
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // Ensure connection is always Output -> Input
            if (!srcPin.isInput && dstPin.isInput)
            {
                PinDataType srcType = getPinDataTypeForPin(srcPin);
                PinDataType dstType = getPinDataTypeForPin(dstPin);

                bool conversionHandled = false;

                // Determine if a converter is needed based on pin types
                if (srcType == PinDataType::Audio && dstType == PinDataType::CV)
                {
                    insertNodeBetween("Attenuverter", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::CV && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("Comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Audio && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("Comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Raw && dstType != PinDataType::Raw)
                {
                    insertNodeBetween("MapRange", srcPin, dstPin);
                    conversionHandled = true;
                }

                if (conversionHandled)
                {
                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
                else
                {
                    // All other combinations are considered directly compatible.
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    // Immediate commit for RecordModuleProcessor filename update
                    synth->commitChanges();

                    if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId)) {
                        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule)) {
                            juce::String sourceName;
                            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId)) {
                                sourceName = srcModule->getName();
                            }
                            recorder->updateSuggestedFilename(sourceName);
                        }
                    }

                    pushSnapshot();
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                // Debug log disconnect intent
                juce::Logger::writeToLog(
                    juce::String("[LinkDelete] src(lid=") + juce::String((int)srcPin.logicalId) + ",ch=" + juce::String(srcPin.channel) +
                    ") -> dst(lid=" + juce::String((int)dstPin.logicalId) + ",ch=" + juce::String(dstPin.channel) + ")");

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                
                // Immediate commit for RecordModuleProcessor filename update
                synth->commitChanges();
                
                // After disconnecting, tell the recorder to update (pass empty string for unconnected)
                if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule))
                    {
                        recorder->updateSuggestedFilename(""); // Empty = unconnected
                    }
                }
                
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)

        // Keyboard shortcuts
        // Only process global keyboard shortcuts if no ImGui widget wants the keyboard
        if (!ImGui::GetIO().WantCaptureKeyboard)
        {
            const bool ctrl = ImGui::GetIO().KeyCtrl;
            const bool shift = ImGui::GetIO().KeyShift;
            const bool alt = ImGui::GetIO().KeyAlt;
            
            // Save As (Ctrl+Alt+S) - Always opens dialog
            if (ctrl && alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
            {
                startSaveDialog();
            }
            // Save (Ctrl+S) - Quick save if file exists, otherwise Save As
            else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
            {
                if (currentPresetFile.existsAsFile())
                {
                    // File already exists, so save directly without a dialog
                    savePresetToFile(currentPresetFile);
                }
                else
                {
                    // This is a new, unsaved patch, so "Save" should act like "Save As"
                    startSaveDialog();
                }
            }
            if (ctrl && ImGui::IsKeyPressed (ImGuiKey_O)) { startLoadDialog(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_P)) { handleRandomizePatch(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_M)) { handleRandomizeConnections(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_B)) { handleBeautifyLayout(); }
            if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_R, false)) { handleRecordOutput(); }
        
        // M: Mute/Bypass selected nodes (without Ctrl modifier)
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_M, false) && ImNodes::NumSelectedNodes() > 0)
        {
            handleMuteToggle();
        }
        
        // Ctrl + A: Select All
        if (ctrl && !shift && ImGui::IsKeyPressed(ImGuiKey_A, false))
        {
            if (synth != nullptr)
            {
                const auto& modules = synth->getModulesInfo();
                std::vector<int> allNodeIds;
                allNodeIds.push_back(0); // Include output node
                for (const auto& mod : modules)
                {
                    allNodeIds.push_back((int)mod.first);
                }
                ImNodes::ClearNodeSelection();
                for (int id : allNodeIds)
                {
                    ImNodes::SelectNode(id);
                }
            }
        }
        
        // Ctrl + R: Reset selected node(s) to default parameters
        if (ctrl && ImGui::IsKeyPressed(ImGuiKey_R, false))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0 && synth != nullptr)
            {
                // Create a single undo state for the entire operation
                pushSnapshot();
                
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());

                for (int lid : selectedNodeIds)
                {
                    if (auto* module = synth->getModuleForLogical((juce::uint32)lid))
                    {
                        // Get all parameters for this module
                        auto& params = module->getParameters();
                        for (auto* paramBase : params)
                        {
                            // Cast to a ranged parameter to access default values
                            if (auto* param = dynamic_cast<juce::RangedAudioParameter*>(paramBase))
                            {
                                // Get the default value (normalized 0-1) and apply it
                                param->setValueNotifyingHost(param->getDefaultValue());
                            }
                        }
                        juce::Logger::writeToLog("[Reset] Reset parameters for node " + juce::String(lid));
                    }
                }
            }
        }
        
        // O: Connect selected to Output
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_O, false) && ImNodes::NumSelectedNodes() == 1)
        {
            if (synth != nullptr)
            {
                int selectedId;
                ImNodes::GetSelectedNodes(&selectedId);
                if (selectedId != 0)
                {
                    synth->connect(synth->getNodeIdForLogical(selectedId), 0, synth->getOutputNodeID(), 0);
                    synth->connect(synth->getNodeIdForLogical(selectedId), 1, synth->getOutputNodeID(), 1);
                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
            }
        }
        
        // Alt + D: Disconnect selected nodes
        if (alt && ImGui::IsKeyPressed(ImGuiKey_D, false) && ImNodes::NumSelectedNodes() > 0)
        {
            if (synth != nullptr)
            {
                std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                for (int id : selectedNodeIds)
                {
                    synth->clearConnectionsForNode(synth->getNodeIdForLogical(id));
                }
                graphNeedsRebuild = true;
                pushSnapshot();
            }
        }
        
        // --- REVISED 'F' and 'Home' KEY LOGIC ---
        auto frameNodes = [&](const std::vector<int>& nodeIds) {
            if (nodeIds.empty() || synth == nullptr) return;

            juce::Rectangle<float> bounds;
            bool foundAny = false;
            
            // Build a set of valid node IDs for checking
            std::unordered_set<int> validNodes;
            validNodes.insert(0); // Output node
            for (const auto& mod : synth->getModulesInfo())
                validNodes.insert((int)mod.first);
            
            for (size_t i = 0; i < nodeIds.size(); ++i)
            {
                // Ensure the node exists before getting its position
                if (validNodes.find(nodeIds[i]) != validNodes.end())
                {
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeIds[i]);
                    if (!foundAny)
                    {
                        bounds = juce::Rectangle<float>(pos.x, pos.y, 1, 1);
                        foundAny = true;
                    }
                    else
                    {
                        bounds = bounds.getUnion(juce::Rectangle<float>(pos.x, pos.y, 1, 1));
                    }
                }
            }

            if (!foundAny) return;

            // Add some padding to the bounds
            if (!nodeIds.empty() && validNodes.find(nodeIds[0]) != validNodes.end())
                bounds = bounds.expanded(ImNodes::GetNodeDimensions(nodeIds[0]).x, ImNodes::GetNodeDimensions(nodeIds[0]).y);
            
            ImVec2 center((bounds.getX() + bounds.getRight()) * 0.5f, (bounds.getY() + bounds.getBottom()) * 0.5f);
            ImNodes::EditorContextResetPanning(center);
        };

        // F: Frame Selected
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_F, false))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                frameNodes(selectedNodeIds);
            }
        }

        // Home and Ctrl+Home: Frame All / Reset to Origin
        if (ImGui::IsKeyPressed(ImGuiKey_Home, false))
        {
            if (ctrl) // Ctrl+Home: Reset to origin
            {
                ImNodes::EditorContextResetPanning(ImVec2(0, 0));
            }
            else // Home: Frame all
            {
                if (synth != nullptr)
                {
                    auto modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0); // Include output node
                    for (const auto& mod : modules)
                    {
                        allNodeIds.push_back((int)mod.first);
                    }
                    frameNodes(allNodeIds);
                }
            }
        }
        
        // Debug menu (Ctrl+Shift+D)
        if (ctrl && shift && ImGui::IsKeyPressed(ImGuiKey_D)) { showDebugMenu = !showDebugMenu; }

        // Undo / Redo (Ctrl+Z / Ctrl+Y)
    if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Z))
        {
            if (undoStack.size() > 1)
            {
                Snapshot current = undoStack.back();
                redoStack.push_back (current);
                undoStack.pop_back();
                restoreSnapshot (undoStack.back());
                // After a restore, clear transient link maps only; keep pending positions so they apply next frame
                linkIdToAttrs.clear();
                // modLinkIdToRoute.clear(); // TODO: Remove when fully migrated

                NotificationManager::post(NotificationManager::Type::Info, "Undo");
            }
        }
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Y))
        {
            if (! redoStack.empty())
            {
                Snapshot s = redoStack.back(); redoStack.pop_back();
                restoreSnapshot (s);
                undoStack.push_back (s);
                linkIdToAttrs.clear();
                // modLinkIdToRoute.clear(); // TODO: Remove when fully migrated
                NotificationManager::post(NotificationManager::Type::Info, "Redo");
            }
        }

        // Duplicate selected nodes (Ctrl+D) and Duplicate with connections (Shift+D)
        if ((ctrl || ImGui::GetIO().KeyShift) && ImGui::IsKeyPressed (ImGuiKey_D))
        {
            const int n = ImNodes::NumSelectedNodes();
            if (n > 0)
            {
                std::vector<int> sel((size_t) n);
                ImNodes::GetSelectedNodes(sel.data());
                for (int oldId : sel)
                {
                    if (oldId == 0) continue;
                    const juce::String type = getTypeForLogical ((juce::uint32) oldId);
                    if (type.isEmpty()) continue;
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    const juce::uint32 newLogical = synth->getLogicalIdForNode (newNodeId);
                    if (newLogical != 0)
                    {
                        if (auto* src = synth->getModuleForLogical ((juce::uint32) oldId))
                            if (auto* dst = synth->getModuleForLogical (newLogical))
                                dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                        // Position offset
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos (oldId);
                        pendingNodePositions[(int) newLogical] = ImVec2 (pos.x + 40.0f, pos.y + 40.0f);

                        // If Shift is held: duplicate connections into and out of this node
                        if (!ctrl && ImGui::GetIO().KeyShift)
                        {
                            const auto oldNode = synth->getNodeIdForLogical ((juce::uint32) oldId);
                            const auto newNode = newNodeId;
                            // Duplicate audio/CV connections
                            for (const auto& c : synth->getConnectionsInfo())
                            {
                                // Outgoing from old -> someone
                                if ((int) c.srcLogicalId == oldId)
                                {
                                    auto dstNode = (c.dstLogicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical (c.dstLogicalId);
                                    synth->connect (newNode, c.srcChan, dstNode, c.dstChan);
                                }
                                // Incoming from someone -> old
                                if ((int) c.dstLogicalId == oldId)
                                {
                                    auto srcNode = synth->getNodeIdForLogical (c.srcLogicalId);
                                    synth->connect (srcNode, c.srcChan, newNode, c.dstChan);
                                }
                            }
                            // TODO: Implement modulation route duplication for new bus-based system
                        }
                    }
                }
                pushSnapshot();
                NotificationManager::post(NotificationManager::Type::Info, "Duplicated " + juce::String(n) + " node(s)");
            }
        }
        
        } // End of keyboard shortcuts (WantCaptureKeyboard check)

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }
    // === MIDI DEVICE MANAGER WINDOW ===
    if (showMidiDeviceManager)
    {
        if (ImGui::Begin("MIDI Device Manager", &showMidiDeviceManager, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::TextColored(ImVec4(0.6f, 0.8f, 1.0f, 1.0f), "MIDI Input Devices");
            ImGui::Separator();
            
            // Access MidiDeviceManager from PresetCreatorComponent
            auto* presetCreator = dynamic_cast<PresetCreatorComponent*>(getParentComponent());
            if (presetCreator && presetCreator->midiDeviceManager)
            {
                auto& midiMgr = *presetCreator->midiDeviceManager;
                const auto& devices = midiMgr.getDevices();
                
                if (devices.empty())
                {
                    ImGui::TextDisabled("No MIDI devices found");
                }
                else
                {
                    ImGui::Text("Found %d device(s):", (int)devices.size());
                    ImGui::Spacing();
                    
                    // Display each device
                    for (const auto& device : devices)
                    {
                        ImGui::PushID(device.identifier.toRawUTF8());
                        
                        // Checkbox to enable/disable device
                        bool enabled = device.enabled;
                        if (ImGui::Checkbox("##enabled", &enabled))
                        {
                            if (enabled)
                                midiMgr.enableDevice(device.identifier);
                            else
                                midiMgr.disableDevice(device.identifier);
                        }
                        
                        ImGui::SameLine();
                        
                        // Device name
                        ImGui::Text("%s", device.name.toRawUTF8());
                        
                        // Activity indicator
                        auto activity = midiMgr.getDeviceActivity(device.identifier);
                        if (activity.lastMessageTime > 0)
                        {
                            ImGui::SameLine();
                            float timeSinceMessage = (juce::Time::getMillisecondCounter() - activity.lastMessageTime) / 1000.0f;
                            if (timeSinceMessage < 1.0f)
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255));
                                ImGui::Text("ACTIVE");
                                ImGui::PopStyleColor();
                            }
                            else
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                                ImGui::Text("idle");
                                ImGui::PopStyleColor();
                            }
                        }
                        
                        ImGui::PopID();
                    }
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                // Rescan button
                if (ImGui::Button("Rescan Devices"))
                {
                    midiMgr.scanDevices();
                }
                
                ImGui::SameLine();
                
                // Enable/Disable all buttons
                if (ImGui::Button("Enable All"))
                {
                    midiMgr.enableAllDevices();
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Disable All"))
                {
                    midiMgr.disableAllDevices();
                }
            }
            else
            {
                ImGui::TextDisabled("MIDI Manager not available");
            }
        }
        ImGui::End();
    }

    // === DEBUG WINDOW ===
    if (showDebugMenu)
    {
        if (ImGui::Begin("System Diagnostics", &showDebugMenu))
        {
            if (synth != nullptr)
            {
                ImGui::Text("=== SYSTEM OVERVIEW ===");
                if (ImGui::Button("Refresh"))
                {
                    // Force refresh of diagnostics
                }
                
                
                // System diagnostics
                ImGui::Text("System State:");
                juce::String systemDiag = synth->getSystemDiagnostics();
                ImGui::TextWrapped("%s", systemDiag.toUTF8());
                
                
                // Module selector
                ImGui::Text("Module Diagnostics:");
                auto modules = synth->getModulesInfo();
                if (!modules.empty())
                {
                    static int selectedModuleIndex = 0;
                    if (selectedModuleIndex >= (int)modules.size()) selectedModuleIndex = 0;
                    
                    juce::String moduleList = "";
                    for (size_t i = 0; i < modules.size(); ++i)
                    {
                        if (i > 0) moduleList += "\0";
                        moduleList += "Logical " + juce::String((int)modules[i].first) + ": " + modules[i].second;
                    }
                    moduleList += "\0";
                    
                    if (ImGui::Combo("Select Module", &selectedModuleIndex, moduleList.toUTF8()))
                    {
                        if (selectedModuleIndex < (int)modules.size())
                        {
                            juce::String moduleDiag = synth->getModuleDiagnostics(modules[selectedModuleIndex].first);
                            ImGui::TextWrapped("%s", moduleDiag.toUTF8());
                        }
                    }
                }
                else
                {
                    ImGui::Text("No modules found.");
                }
            }
            else
            {
                ImGui::Text("No synth processor available.");
            }
        }
        ImGui::End();
    }

    // Keyboard Shortcuts Help Window (F1)
    if (showShortcutsWindow)
    {
        ImGui::Begin("Keyboard Shortcuts", &showShortcutsWindow, ImGuiWindowFlags_AlwaysAutoResize);
        
        // --- NEW, COMPREHENSIVE SHORTCUT LIST ---

        ImGui::Text("Patch & File Management");
        ImGui::Separator();
        ImGui::BulletText("Ctrl + S: Save Preset.");
        ImGui::BulletText("Ctrl + O: Load Preset.");
        ImGui::BulletText("Ctrl + Z: Undo last action.");
        ImGui::BulletText("Ctrl + Y: Redo last action.");
        ImGui::BulletText("Ctrl + P: Generate a new random patch.");

        ImGui::Spacing();
        ImGui::Text("Node Creation & Deletion");
        ImGui::Separator();
        ImGui::BulletText("Right-click canvas: Open Quick Add menu to create a node.");
        ImGui::BulletText("Delete: Delete selected nodes and links.");
        ImGui::BulletText("Shift + Delete: Bypass-delete selected node(s), preserving signal chain.");
        ImGui::BulletText("Ctrl + D: Duplicate selected node(s).");
        ImGui::BulletText("Shift + D: Duplicate selected node(s) with their connections.");
        ImGui::BulletText("Ctrl + Shift + M: Collapse selected nodes into a new 'Meta Module'.");

        ImGui::Spacing();
        ImGui::Text("Connections & Signal Flow");
        ImGui::Separator();
        ImGui::BulletText("Right-click canvas -> Probe Signal: Enter Probe Mode.");
        ImGui::BulletText("  (In Probe Mode) Left-click output pin: Instantly view signal in the Probe Scope.");
        ImGui::BulletText("Right-click link: Open menu to insert a node on that cable.");
        ImGui::BulletText("I key (while hovering link): Open 'Insert Node' menu for that cable.");
        ImGui::BulletText("Ctrl + Middle-click link: Split a new cable from a connected output pin.");
        ImGui::BulletText("O key (with one node selected): Connect node's output to the Main Output.");
        ImGui::BulletText("Alt + D: Disconnect all cables from selected node(s).");
        ImGui::BulletText("Ctrl + M: Randomize connections between existing nodes.");
        ImGui::BulletText("C key (multi-select): Chain selected nodes (L->L, R->R).");
        ImGui::BulletText("G, B, Y, R keys (multi-select): Chain pins by type (Audio, CV, Gate, Raw).");
        
        ImGui::Spacing();
        ImGui::Text("Navigation & View");
        ImGui::Separator();
        ImGui::BulletText("F: Frame (zoom to fit) selected nodes.");
        ImGui::BulletText("Home: Frame all nodes in the patch.");
        ImGui::BulletText("Ctrl + Home: Reset view panning to the origin (0,0).");
        ImGui::BulletText("Ctrl + B: Automatically arrange nodes for a clean layout ('Beautify').");
        ImGui::BulletText("Ctrl + A: Select all nodes.");

        ImGui::Spacing();
        ImGui::Text("Parameter & Settings");
        ImGui::Separator();
        ImGui::BulletText("M key (with node(s) selected): Mute or Bypass the selected node(s).");
        ImGui::BulletText("Ctrl + R (with node(s) selected): Reset parameters of selected node(s) to default.");
        ImGui::BulletText("Ctrl + Shift + C: Copy selected node's settings to clipboard.");
        ImGui::BulletText("Ctrl + Shift + V: Paste settings to selected node (must be same type).");
        ImGui::BulletText("Mouse Wheel (on slider): Fine-tune parameter value.");

        ImGui::Spacing();
        ImGui::Text("General & Debugging");
        ImGui::Separator();
        ImGui::BulletText("Ctrl + R (no node selected): Insert a Recorder tapped into the Main Output.");
        ImGui::BulletText("Ctrl + Shift + D: Show System Diagnostics window.");
        ImGui::BulletText("F1: Toggle this help window.");
        
        ImGui::End();
    }

    ImGui::End();
    // drawPendingModPopup(); // TODO: Remove when fully migrated

    // Render notification system (must be called at the end to appear on top)
    NotificationManager::render();

    // --- Phase 5: Periodic Stale History Cleanup ---
    static double lastCleanupTime = 0.0;
    const double currentTimeSec = juce::Time::getMillisecondCounterHiRes() / 1000.0;
    
    if (currentTimeSec - lastCleanupTime > 10.0) // Run every 10 seconds
    {
        lastCleanupTime = currentTimeSec;
        // Set cutoff for "stale" entries (2x the max window size = 40 seconds)
        const double staleCutoffTime = currentTimeSec - (20.0 * 2.0);
        
        for (auto it = inspectorHistory.begin(); it != inspectorHistory.end(); /* no increment */)
        {
            if (it->second.lastAccessTime < staleCutoffTime)
            {
                it = inspectorHistory.erase(it); // Erase stale entry
            }
            else
            {
                ++it;
            }
        }
    }

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        // Temporarily mask rebuild flag to avoid ImNodes queries during capture
        const bool rebuilding = graphNeedsRebuild.load();
        if (rebuilding) {
            // getUiValueTree will still avoid ImNodes now, but assert safety
        }
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        // Do not commit pending positions of (0,0) which are placeholders
        for (int i = 0; i < applied.getNumChildren(); ++i)
        {
            auto n = applied.getChild(i);
            if (! n.hasType("node")) continue;
            const float x = (float) n.getProperty("x", 0.0f);
            const float y = (float) n.getProperty("y", 0.0f);
            if (x == 0.0f && y == 0.0f) {
                // Try to recover from last-known or pending
                const int nid = (int) n.getProperty("id", -1);
                auto itL = lastKnownNodePositions.find(nid);
                if (itL != lastKnownNodePositions.end()) { n.setProperty("x", itL->second.x, nullptr); n.setProperty("y", itL->second.y, nullptr); }
                else if (auto itP = pendingNodePositions.find(nid); itP != pendingNodePositions.end()) { n.setProperty("x", itP->second.x, nullptr); n.setProperty("y", itP->second.y, nullptr); }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        isPatchDirty = true; // Mark patch as dirty
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
    
    // Mark patch as dirty whenever a change is made
    isPatchDirty = true;
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed


juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        
        // Prefer cached position if available; never query ImNodes while rebuilding
        ImVec2 pos;
        if (lastKnownNodePositions.count(nid) > 0)
        {
            pos = lastKnownNodePositions.at(nid);
        }
        else if (graphNeedsRebuild.load())
        {
            // Fallback to any pending position queued for this node
            auto it = pendingNodePositions.find(nid);
            pos = (it != pendingNodePositions.end()) ? it->second : ImVec2(0.0f, 0.0f);
        }
        else
        {
            pos = ImNodes::GetNodeGridSpacePos(nid);
        }
        
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        
        // --- FIX: Save muted/bypassed state ---
        // If this node's ID is in our map of muted nodes, add the property to the XML
        if (mutedNodeStates.count(nid) > 0)
        {
            n.setProperty("muted", true, nullptr);
        }
        
        ui.addChild (n, -1, nullptr);
    }
    
    // --- FIX: Explicitly save the output node position (ID 0) ---
    // The main output node is not part of getModulesInfo(), so we need to save it separately
    
    // Prefer cached output position; avoid ImNodes when rebuilding
    ImVec2 outputPos;
    if (lastKnownNodePositions.count(0) > 0)
        outputPos = lastKnownNodePositions.at(0);
    else if (graphNeedsRebuild.load())
    {
        auto it0 = pendingNodePositions.find(0);
        outputPos = (it0 != pendingNodePositions.end()) ? it0->second : ImVec2(0.0f, 0.0f);
    }
    else
        outputPos = ImNodes::GetNodeGridSpacePos(0);
    
    juce::ValueTree outputNode("node");
    outputNode.setProperty("id", 0, nullptr);
    outputNode.setProperty("x", outputPos.x, nullptr);
    outputNode.setProperty("y", outputPos.y, nullptr);
    ui.addChild(outputNode, -1, nullptr);
    // --- END OF FIX ---
    
    return ui;
}

void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid() || synth == nullptr) return;
    
    juce::Logger::writeToLog("[UI_RESTORE] Applying UI ValueTree now...");

    // This is the core of the crash: the synth graph has already been rebuilt by setStateInformation.
    // We must clear our stale UI data (like muted nodes) before applying the new state from the preset.
    mutedNodeStates.clear();
    
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);

        // ========================= THE FIX STARTS HERE =========================
        //
        // Before applying any property, VERIFY that this node ID actually exists
        // in the synth. This prevents crashes when loading presets that contain
        // modules which are not available in the current build.
        //
        bool nodeExistsInSynth = (nid == 0); // Node 0 is always the output node.
        if (!nodeExistsInSynth) {
            for (const auto& modInfo : synth->getModulesInfo()) {
                if ((int)modInfo.first == nid) {
                    nodeExistsInSynth = true;
                    break;
                }
            }
        }

        if (!nodeExistsInSynth)
        {
            juce::Logger::writeToLog("[UI_RESTORE] WARNING: Skipping UI properties for non-existent node ID " + juce::String(nid) + ". The module may be missing or failed to load.");
            continue; // Skip to the next node in the preset.
        }
        // ========================== END OF FIX ==========================

        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        if (!(x == 0.0f && y == 0.0f))
        {
            pendingNodePositions[nid] = ImVec2(x, y);
            juce::Logger::writeToLog("[UI_RESTORE] Queued position for node " + juce::String(nid) + ": (" + juce::String(x) + ", " + juce::String(y) + ")");
        }
        
        // Read and apply muted state from preset for existing nodes.
        if ((bool) n.getProperty("muted", false))
        {
            // Use muteNodeSilent to store the original connections first,
            // then apply the mute (which creates bypass connections)
            muteNodeSilent(nid);
            muteNode(nid);
        }
    }
    
    // Muting/unmuting modifies graph connections, so we must tell the
    // synth to rebuild its processing order.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[UI_RESTORE] UI state applied. Flagging for graph rebuild.");
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    // Shift+Delete => bypass delete (keep chain intact)
    if ((ImGui::GetIO().KeyShift) && ImGui::IsKeyPressed(ImGuiKey_Delete))
    {
        bypassDeleteSelectedNodes();
        return;
    }

    // Use new key query API (1.90+) for normal delete
    if (! ImGui::IsKeyPressed(ImGuiKey_Delete))
        return;

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            // TODO: Handle modulation link deletion for new bus-based system
            // if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
            // {
            //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
            //     // TODO: Handle modulation route removal
            //     // if (paramId.isNotEmpty())
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL, paramId);
            //     // else
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            // }
            // else 
            if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            
            // Clean up vision module textures if exists
            if (visionModuleTextures.count(nid))
            {
                visionModuleTextures.erase(nid);
            }
            
            // Clean up sample loader textures if exists
            if (sampleLoaderTextureIds.count(nid))
            {
                sampleLoaderTextureIds.erase(nid);
            }
            
            mutedNodeStates.erase((juce::uint32)nid); // Clean up muted state if exists
            lastKnownNodePositions.erase(nid); // Clean up position cache
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}

void ImGuiNodeEditorComponent::bypassDeleteSelectedNodes()
{
    const int numSelNodes = ImNodes::NumSelectedNodes();
    if (numSelNodes <= 0 || synth == nullptr) return;

    // Snapshot positions first if dragging
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    std::vector<int> nodeIds((size_t) numSelNodes);
    ImNodes::GetSelectedNodes(nodeIds.data());

    for (int nid : nodeIds)
    {
        if (nid == 0) continue; // don't bypass-delete the output sink
        bypassDeleteNode((juce::uint32) nid);
    }
    graphNeedsRebuild = true;
    pushSnapshot();
    NotificationManager::post(NotificationManager::Type::Info, "Deleted " + juce::String(numSelNodes) + " node(s)");
}

void ImGuiNodeEditorComponent::bypassDeleteNode(juce::uint32 logicalId)
{
    // Collect all incoming/outgoing audio links for this node
    std::vector<decltype(synth->getConnectionsInfo())::value_type> inputs, outputs;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) inputs.push_back(c);
        if (c.srcLogicalId == logicalId) outputs.push_back(c);
    }

    // For each output channel, find matching input channel to splice
    for (const auto& out : outputs)
    {
        // Try to find input with same channel index, else fallback to first input
        const auto* inPtr = (const decltype(inputs)::value_type*) nullptr;
        for (const auto& in : inputs) { if (in.dstChan == out.srcChan) { inPtr = &in; break; } }
        if (inPtr == nullptr && !inputs.empty()) inPtr = &inputs.front();

        // Disconnect out link first
        auto srcNode = synth->getNodeIdForLogical(out.srcLogicalId);
        auto dstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
        synth->disconnect(srcNode, out.srcChan, dstNode, out.dstChan);

        if (inPtr != nullptr)
        {
            // Disconnect incoming link from the node
            auto inSrcNode = synth->getNodeIdForLogical(inPtr->srcLogicalId);
            auto inDstNode = synth->getNodeIdForLogical(inPtr->dstLogicalId);
            synth->disconnect(inSrcNode, inPtr->srcChan, inDstNode, inPtr->dstChan);

            // Connect source of incoming directly to destination of outgoing
            auto finalDstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
            synth->connect(inSrcNode, inPtr->srcChan, finalDstNode, out.dstChan);
        }
    }

    // TODO: Remove modulation routes targeting or originating this node using new bus-based system

    // Finally remove the node itself
    mutedNodeStates.erase(logicalId); // Clean up muted state if exists
    synth->removeModule(synth->getNodeIdForLogical(logicalId));
}

// === Non-Destructive Mute/Bypass Implementation ===

void ImGuiNodeEditorComponent::muteNodeSilent(juce::uint32 logicalId)
{
    // This function is used when loading presets. It records the connections that were
    // loaded from the XML without modifying the graph or creating bypass connections.
    // This preserves the original "unmuted" connections for later use.
    
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // Store all connections attached to this node
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // Store the state, but DON'T modify the graph or create bypass connections
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[MuteSilent] Node " + juce::String(logicalId) + 
                            " marked as muted, stored " + juce::String(state.incomingConnections.size()) + 
                            " incoming and " + juce::String(state.outgoingConnections.size()) + 
                            " outgoing connections.");
}

void ImGuiNodeEditorComponent::muteNode(juce::uint32 logicalId)
{
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // 1. Find and store all connections attached to this node.
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // 2. Disconnect all of them.
    for (const auto& c : state.incomingConnections) {
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }
    
    // --- FIX: More robust bypass splicing logic ---
    // 3. Splice the connections to bypass the node.
    // Connect the FIRST input source to ALL output destinations.
    // This correctly handles cases where input channel != output channel (e.g., Mixer input 3 ‚Üí output 0).
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Connect the primary input's source directly to the original output's destination
            synth->connect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Mute] Splicing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 4. Store the original state.
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " muted and bypassed.");
}

void ImGuiNodeEditorComponent::unmuteNode(juce::uint32 logicalId)
{
    if (!synth || mutedNodeStates.find(logicalId) == mutedNodeStates.end()) return;

    MutedNodeState state = mutedNodeStates[logicalId];

    // --- FIX: Remove bypass connections matching the new mute logic ---
    // 1. Find and remove the bypass connections.
    // The bypass connected the first input source to all output destinations.
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Disconnect the bypass connection
            synth->disconnect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Unmute] Removing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 2. Restore the original connections.
    for (const auto& c : state.incomingConnections) {
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }

    // 3. Remove from muted state.
    mutedNodeStates.erase(logicalId);
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " unmuted.");
}

void ImGuiNodeEditorComponent::handleMuteToggle()
{
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected == 0) return;

    pushSnapshot(); // Create a single undo state for the whole operation.

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    for (int lid : selectedNodeIds) {
        if (mutedNodeStates.count(lid)) {
            unmuteNode(lid);
        } else {
            muteNode(lid);
        }
    }

    graphNeedsRebuild = true;
}
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    bool wasAlreadyInProgress = isSaveInProgress.exchange(true); // Atomically check and set
    if (wasAlreadyInProgress)
    {
        juce::Logger::writeToLog("[SaveWorkflow] Save action ignored (already in progress). Current flag state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Flag set to TRUE. Starting save workflow for: " + file.getFullPathName());

    if (synth == nullptr) {
        juce::Logger::writeToLog("[SaveWorkflow] ERROR: Synth is null! Resetting flag and aborting.");
        NotificationManager::post(NotificationManager::Type::Error, "ERROR: Synth not ready!");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after synth null check.");
        return;
    }

    juce::Logger::writeToLog("--- [Save Workflow] Initiated for: " + file.getFullPathName() + " ---");
    
    // Post status notification (long duration since it will be replaced by Success/Error when complete)
    NotificationManager::post(NotificationManager::Type::Status, "Saving: " + file.getFileNameWithoutExtension(), 1000.0f);
    
    // --- All fast operations now happen on the UI thread BEFORE the job is launched ---
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Capturing state...");
    auto mutedNodeIDs = getMutedNodeIds();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Found " + juce::String((int)mutedNodeIDs.size()) + " muted nodes.");

    // Temporarily unmute to get correct connections
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Temporarily unmuting nodes for state capture...");
    for (auto lid : mutedNodeIDs) unmuteNode(lid);
    synth->commitChanges();

    // Capture state while unmuted
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling synth->getStateInformation()...");
    juce::MemoryBlock synthState;
    try {
        synth->getStateInformation(synthState);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Synth state captured (" + juce::String(synthState.getSize()) + " bytes).");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION in getStateInformation: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION in getStateInformation");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to capture synth state!");
        return;
    }
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Calling editor->getUiValueTree()...");
    juce::ValueTree uiState = getUiValueTree();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UI state captured (valid: " + juce::String(uiState.isValid() ? 1 : 0) + ").");

    // Immediately re-mute to restore visual state
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Re-muting nodes to restore visual state...");
    for (auto lid : mutedNodeIDs) muteNode(lid);
    synth->commitChanges();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] State captured. Offloading to background thread.");

    // Launch the background job with the captured data
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Creating SavePresetJob...");
    auto* job = new SavePresetJob(synthState, uiState, file);

    job->onSaveComplete = [this, filePath = file.getFullPathName()](const juce::File& savedFile, bool success) {
        juce::Logger::writeToLog("[SaveWorkflow] onSaveComplete callback called (success: " + juce::String(success ? 1 : 0) + ") for: " + savedFile.getFullPathName());
        
        if (success) {
            NotificationManager::post(NotificationManager::Type::Success, "Saved: " + savedFile.getFileNameWithoutExtension());
            isPatchDirty = false;
            currentPresetFile = savedFile;
            juce::Logger::writeToLog("[SaveWorkflow] Save completed successfully. Flag will be reset.");
        } else {
            juce::Logger::writeToLog("[SaveWorkflow] Save FAILED. Flag will be reset.");
            NotificationManager::post(NotificationManager::Type::Error, "Failed to save preset!");
        }
        
        juce::Logger::writeToLog("[SaveWorkflow] Resetting isSaveInProgress flag to FALSE.");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset complete. Current state: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    };

    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Adding job to thread pool...");
    try {
        threadPool.addJob(job, true);
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Job added to thread pool successfully.");
    } catch (const std::exception& e) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] EXCEPTION adding job to thread pool: " + juce::String(e.what()));
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    } catch (...) {
        juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] UNKNOWN EXCEPTION adding job to thread pool");
        isSaveInProgress.store(false);
        juce::Logger::writeToLog("[SaveWorkflow] Flag reset to FALSE after unknown thread pool exception.");
        NotificationManager::post(NotificationManager::Type::Error, "Failed to start save job!");
        delete job; // Clean up the job we created
    }
}

void ImGuiNodeEditorComponent::startSaveDialog()
{
    juce::Logger::writeToLog("[SaveWorkflow] startSaveDialog() called. isSaveInProgress: " + juce::String(isSaveInProgress.load() ? "TRUE" : "FALSE"));
    
    // Check if a save is already in progress to avoid opening multiple dialogs
    if (isSaveInProgress.load()) {
        juce::Logger::writeToLog("[SaveWorkflow] 'Save As' action ignored (a save is already in progress).");
        NotificationManager::post(NotificationManager::Type::Warning, "A save operation is already in progress. Please wait...", 3.0f);
        return;
    }

    juce::Logger::writeToLog("[SaveWorkflow] Opening file chooser dialog...");
    auto presetsDir = findPresetsDirectory();
    juce::Logger::writeToLog("[SaveWorkflow] Presets directory: " + presetsDir.getFullPathName());
    
    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      presetsDir, 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        juce::Logger::writeToLog("[SaveWorkflow] File chooser callback invoked.");
        auto fileToSave = fc.getResult();
        
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            juce::Logger::writeToLog("[SaveWorkflow] User selected file: " + fileToSave.getFullPathName());
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
        else
        {
            juce::Logger::writeToLog("[SaveWorkflow] User cancelled file chooser dialog.");
        }
    });
    juce::Logger::writeToLog("[SaveWorkflow] File chooser launched (async).");
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::getMutedNodeIds() const
{
    std::vector<juce::uint32> ids;
    // MutedNodeState is a map, so we don't need a lock if we're just reading keys
    for (const auto& pair : mutedNodeStates)
    {
        ids.push_back(pair.first);
    }
    return ids;
}


void ImGuiNodeEditorComponent::startLoadDialog()
{
    NotificationManager::post(NotificationManager::Type::Info, "Opening Load Preset dialog...", 3.0f);
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", findPresetsDirectory(), "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto file = fc.getResult();
        if (!file.existsAsFile()) return;
        NotificationManager::post(NotificationManager::Type::Info, "Loading: " + file.getFileName(), 5.0f);

        auto xml = juce::XmlDocument::parse(file);
        if (!xml)
        {
            NotificationManager::post(NotificationManager::Type::Error, "Preset failed to load: Not a valid XML file.");
            return;
        }
        juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);

        // === STAGE 1 & 2: HEAL THE PRESET (RULE-BASED) ===
        PresetAutoHealer healer;
        auto healingMessages = healer.heal(presetVT);

        // === STAGE 3: VALIDATE THE (NOW HEALED) PRESET ===
        PresetValidator validator;
        auto issues = validator.validate(presetVT);
        int errorCount = 0;
        int warningCount = 0;
        for (const auto& issue : issues)
        {
            if (issue.severity == PresetValidator::Issue::Error) errorCount++; else warningCount++;
        }

        // Report errors/warnings but proceed to load to match built-in loader behavior
        if (errorCount > 0)
        {
            juce::String summary = "Validation found " + juce::String(errorCount) + " error(s). Attempting load anyway.";
            if (!healingMessages.empty()) summary += " (" + juce::String((int)healingMessages.size()) + " issue(s) auto-healed).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 12.0f);
            for (const auto& issue : issues)
            {
                if (issue.severity == PresetValidator::Issue::Error)
                    NotificationManager::post(NotificationManager::Type::Warning, issue.message, 12.0f);
            }
        }

        // === STAGE 4: LOAD THE HEALED DATA ===
        juce::MemoryBlock mb;
        juce::MemoryOutputStream mos(mb, false);
        if (auto healedXml = presetVT.createXml()) healedXml->writeTo(mos);
        synth->setStateInformation(mb.getData(), (int)mb.getSize());
        auto uiState = presetVT.getChildWithName("NodeEditorUI");
        if (uiState.isValid()) applyUiValueTree(uiState);
        isPatchDirty = false;
        currentPresetFile = file;
        pushSnapshot();

        // === STAGE 5: NOTIFY ===
        if (!healingMessages.empty() || warningCount > 0 || errorCount > 0)
        {
            juce::String summary = "Loaded with " + juce::String(warningCount + errorCount) + " issue(s).";
            NotificationManager::post(NotificationManager::Type::Warning, summary, 8.0f);
            for (const auto& msg : healingMessages)
                NotificationManager::post(NotificationManager::Type::Info, msg, 8.0f);
            for (const auto& issue : issues)
                NotificationManager::post(
                    issue.severity == PresetValidator::Issue::Warning ? NotificationManager::Type::Warning
                                                                       : NotificationManager::Type::Warning,
                    issue.message, 8.0f);
        }
        else
        {
            NotificationManager::post(NotificationManager::Type::Success, "Loaded: " + file.getFileNameWithoutExtension());
        }
    });
}

void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "VCO", "Noise", "Sequencer", "VCF", "Delay", "Reverb", "Waveshaper",
        "LFO", "ADSR", "Random", "S&H", "Math", "MapRange", "Quantizer", "ClockDivider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    addedModules.push_back({mixerId, "Mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));
    addedModules.push_back({scopeId, "Scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "Mixer") finalMixerId = mod.first;
        if (mod.second == "Scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "Mixer") mixerId = mod.first;
        if (mod.second == "Scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleBeautifyLayout()
{
    if (synth == nullptr) return;

    // Graph is always in consistent state since we rebuild at frame start
    // Create an undo state so the action can be reversed
    pushSnapshot();
    juce::Logger::writeToLog("--- [Beautify Layout] Starting ---");

    // --- STEP 1: Build Graph Representation ---
    // Adjacency list: map<source_lid, vector<destination_lid>>
    std::map<juce::uint32, std::vector<juce::uint32>> adjacencyList;
    std::map<juce::uint32, int> inDegree; // Counts incoming connections for each node
    std::vector<juce::uint32> sourceNodes;

    auto modules = synth->getModulesInfo();
    for (const auto& mod : modules)
    {
        inDegree[mod.first] = 0;
        adjacencyList[mod.first] = {};
    }
    // Include the output node in the graph
    inDegree[0] = 0; // Output node ID is 0
    adjacencyList[0] = {}; // Output node has no outgoing connections

    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput)
        {
            adjacencyList[conn.srcLogicalId].push_back(0); // Connect to output node
            inDegree[0]++;
        }
        else
        {
            adjacencyList[conn.srcLogicalId].push_back(conn.dstLogicalId);
            inDegree[conn.dstLogicalId]++;
        }
    }

    for (const auto& mod : modules)
    {
        if (inDegree[mod.first] == 0)
        {
            sourceNodes.push_back(mod.first);
        }
    }

    juce::Logger::writeToLog("[Beautify] Found " + juce::String(sourceNodes.size()) + " source nodes");

    // --- STEP 2: Assign Nodes to Columns (Topological Sort) ---
    std::map<juce::uint32, int> nodeColumn;
    std::vector<std::vector<juce::uint32>> columns;
    int maxColumn = 0;

    // Initialize source nodes in column 0
    for (juce::uint32 nodeId : sourceNodes)
    {
        nodeColumn[nodeId] = 0;
    }
    columns.push_back(sourceNodes);

    // Process each column and assign children to appropriate columns
    std::queue<juce::uint32> processQueue;
    for (juce::uint32 srcNode : sourceNodes)
        processQueue.push(srcNode);

    while (!processQueue.empty())
    {
        juce::uint32 u = processQueue.front();
        processQueue.pop();

        for (juce::uint32 v : adjacencyList[u])
        {
            // The column for node 'v' is the maximum of its predecessors' columns + 1
            int newColumn = nodeColumn[u] + 1;
            if (nodeColumn.count(v) == 0 || newColumn > nodeColumn[v])
            {
                nodeColumn[v] = newColumn;
                maxColumn = std::max(maxColumn, newColumn);
                processQueue.push(v);
            }
        }
    }

    // Re-populate columns based on assignments
    columns.assign(maxColumn + 1, {});
    for (const auto& pair : nodeColumn)
    {
        columns[pair.second].push_back(pair.first);
    }

    juce::Logger::writeToLog("[Beautify] Arranged nodes into " + juce::String(maxColumn + 1) + " columns");

    // --- STEP 3: Optimize Node Ordering Within Columns ---
    // Sort nodes in each column based on median position of their parents
    for (int c = 1; c <= maxColumn; ++c)
    {
        std::map<juce::uint32, float> medianPositions;
        
        for (juce::uint32 nodeId : columns[c])
        {
            std::vector<float> parentPositions;
            
            // Find all parents in previous columns
            for (const auto& pair : adjacencyList)
            {
                for (juce::uint32 dest : pair.second)
                {
                    if (dest == nodeId)
                    {
                        // Find the vertical index of the parent node
                        int parentColumn = nodeColumn[pair.first];
                        auto& parentColVec = columns[parentColumn];
                        auto it = std::find(parentColVec.begin(), parentColVec.end(), pair.first);
                        if (it != parentColVec.end())
                        {
                            parentPositions.push_back((float)std::distance(parentColVec.begin(), it));
                        }
                    }
                }
            }
            
            if (!parentPositions.empty())
            {
                std::sort(parentPositions.begin(), parentPositions.end());
                medianPositions[nodeId] = parentPositions[parentPositions.size() / 2];
            }
            else
            {
                medianPositions[nodeId] = 0.0f;
            }
        }
        
        // Sort the column based on median positions
        std::sort(columns[c].begin(), columns[c].end(), [&](juce::uint32 a, juce::uint32 b) {
            return medianPositions[a] < medianPositions[b];
        });
    }

    // --- STEP 4: Calculate Final Coordinates ---
    const float COLUMN_WIDTH = 400.0f;
    const float NODE_VERTICAL_PADDING = 50.0f;

    // Find the tallest column to center shorter ones
    float tallestColumnHeight = 0.0f;
    for (const auto& col : columns)
    {
        float height = 0.0f;
        for (juce::uint32 lid : col)
        {
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            height += nodeSize.y + NODE_VERTICAL_PADDING;
        }
        tallestColumnHeight = std::max(tallestColumnHeight, height);
    }

    // --- STEP 5: Apply Positions ---
    for (int c = 0; c <= maxColumn; ++c)
    {
        // Calculate column height for centering
        float columnHeight = 0.0f;
        for (juce::uint32 lid : columns[c])
        {
            columnHeight += ImNodes::GetNodeDimensions((int)lid).y + NODE_VERTICAL_PADDING;
        }
        
        // Start Y position (centered vertically)
        float currentY = (tallestColumnHeight - columnHeight) / 2.0f;

        for (juce::uint32 lid : columns[c])
        {
            float x = c * COLUMN_WIDTH;
            pendingNodePositions[(int)lid] = ImVec2(x, currentY);
            
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            currentY += nodeSize.y + NODE_VERTICAL_PADDING;
        }
    }

    // Position the output node to the right of all other modules
    float finalX = (maxColumn + 1) * COLUMN_WIDTH;
    float outputNodeY = (tallestColumnHeight - ImNodes::GetNodeDimensions(0).y) / 2.0f;
    pendingNodePositions[0] = ImVec2(finalX, outputNodeY);
    juce::Logger::writeToLog("[Beautify] Applied position to Output Node");
    
    juce::Logger::writeToLog("[Beautify] Applied positions to " + juce::String(modules.size()) + " nodes");
    juce::Logger::writeToLog("--- [Beautify Layout] Complete ---");
}

void ImGuiNodeEditorComponent::handleConnectSelectedToTrackMixer()
{
    if (synth == nullptr || ImNodes::NumSelectedNodes() <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: No synth or no nodes selected.");
        return;
    }

    // This is a significant action, so create an undo state first.
    pushSnapshot();
    juce::Logger::writeToLog("--- [Connect to Mixer] Starting routine ---");

    // 1. Get all selected node IDs.
    const int numSelectedNodes = ImNodes::NumSelectedNodes();
    std::vector<int> selectedNodeLids(numSelectedNodes);
    ImNodes::GetSelectedNodes(selectedNodeLids.data());

    // 2. Find the geometric center of the selected nodes to position our new modules.
    float totalX = 0.0f, maxX = 0.0f, totalY = 0.0f;
    for (int lid : selectedNodeLids)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(lid);
        totalX += pos.x;
        totalY += pos.y;
        if (pos.x > maxX) {
            maxX = pos.x;
        }
    }
    ImVec2 centerPos = ImVec2(totalX / numSelectedNodes, totalY / numSelectedNodes);
    
    // 3. Create the Value node and set its value to the number of selected nodes.
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    if (auto* valueProc = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(valueProc->getAPVTS().getParameter("value")))
        {
            *p = (float)numSelectedNodes;
            juce::Logger::writeToLog("[AutoConnect] Created Value node " + juce::String(valueLid) + " and set its value to " + juce::String(numSelectedNodes));
        }
    }
    // Position it slightly to the right of the center of the selection.
    pendingNodePositions[(int)valueLid] = ImVec2(centerPos.x + 400.0f, centerPos.y);

    // 4. Create the Track Mixer node.
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    // Position it to the right of the right-most selected node for a clean signal flow.
    pendingNodePositions[(int)mixerLid] = ImVec2(maxX + 800.0f, centerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 5. Connect the Value node to the Track Mixer's "Num Tracks Mod" input.
    // The Value module's "Raw" output is channel 0 (provides the exact value entered by the user).
    // The Track Mixer's "Num Tracks Mod" is on Bus 1, Channel 0, which is absolute channel 64.
    synth->connect(valueNodeId, 0, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected Value node 'Raw' output to Track Mixer's Num Tracks Mod input.");

    // 6. Connect the primary audio output of each selected node to a unique input on the Track Mixer.
    int mixerInputChannel = 0;
    for (int lid : selectedNodeLids)
    {
        if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;

        auto sourceNodeId = synth->getNodeIdForLogical((juce::uint32)lid);
        
        // We will connect the first audio output (channel 0) of the source to the next available mixer input.
        synth->connect(sourceNodeId, 0, mixerNodeId, mixerInputChannel);
        juce::Logger::writeToLog("[AutoConnect] Connected node " + juce::String(lid) + " (Out 0) to Track Mixer (In " + juce::String(mixerInputChannel + 1) + ")");
        
        mixerInputChannel++;
    }

    // 7. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [Connect to Mixer] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: MIDI Player not ready.");
        return;
    }

    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);

    // --- FIX: Create and position the Track Mixer first ---
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 1200.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // --- FIX: Connect MIDI Player "Num Tracks" output to Track Mixer "Num Tracks Mod" input ---
    // This ensures the Track Mixer automatically adjusts its track count based on the MIDI file content
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected MIDI Player Num Tracks to Track Mixer Num Tracks Mod");

    // 2. Create and connect a Sample Loader for each active MIDI track.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnect] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks.");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= MIDIPlayerModuleProcessor::kMaxTracks) break;

        // A. Create and position the new modules.
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y + (i * 350.0f));

        auto mapRangeNodeId = synth->addModule("map_range");
        auto mapRangeLid = synth->getLogicalIdForNode(mapRangeNodeId);
        pendingNodePositions[(int)mapRangeLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y + (i * 350.0f));
        
        // B. Configure the MapRange module for Pitch CV conversion.
        if (auto* mapRangeProc = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(mapRangeLid)))
        {
            auto& ap = mapRangeProc->getAPVTS();
            // MIDI Player Pitch Out (0..1) -> Sample Loader Pitch Mod (-24..+24 semitones)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = 0.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = 1.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = -24.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = 24.0f;
        }

        // C. Connect the outputs for this track.
        const int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        const int gateChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 1;
        const int trigChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 3;

        // Pitch: MIDI Player -> MapRange -> Sample Loader
        synth->connect(midiPlayerNodeId, pitchChan, mapRangeNodeId, 0); // Pitch Out -> MapRange In
        synth->connect(mapRangeNodeId, 1, samplerNodeId, 0);             // MapRange Raw Out -> SampleLoader Pitch Mod In

        // Gate: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, gateChan, samplerNodeId, 2);    // Gate Out -> SampleLoader Gate Mod In

        // Trigger: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, trigChan, samplerNodeId, 3);    // Trigger Out -> SampleLoader Trigger Mod In

        // --- FIX: Connect the Sample Loader's audio output to the Track Mixer ---
        // The Sample Loader's main audio output is channel 0.
        // The Track Mixer's inputs are mono channels 0, 1, 2...
        synth->connect(samplerNodeId, 0, mixerNodeId, i);
    }

    // --- FIX: Connect the mixer to the main output so you can hear it! ---
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R

    // 3. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnectVCO] Aborted: MIDI Player not ready.");
        return;
    }
    
    juce::Logger::writeToLog("--- [AutoConnectVCO] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear all existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);
    
    // 2. Create and position the PolyVCO and Track Mixer.
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created PolyVCO with logical ID " + juce::String(polyVcoLid));

    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 3. Connect the track count outputs to control both new modules.
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, polyVcoNodeId, 0); // Raw Num Tracks -> PolyVCO Num Voices Mod
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS); // Raw Num Tracks -> Mixer Num Tracks Mod
    juce::Logger::writeToLog("[AutoConnectVCO] Connected MIDI Player raw track counts to PolyVCO and Track Mixer modulation inputs.");
    
    // 4. Loop through active MIDI tracks to connect CV routes and audio.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnectVCO] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks. Patching voices...");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= PolyVCOModuleProcessor::MAX_VOICES) break; // Don't try to connect more voices than the PolyVCO has

        int sourceTrackIndex = activeTrackIndices[i];

        // A. Connect CV modulation routes from MIDI Player to the corresponding PolyVCO voice.
        int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        int velChan   = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 2;
        
        // Connect MIDI CV to the corresponding PolyVCO voice inputs
        synth->connect(midiPlayerNodeId, pitchChan, polyVcoNodeId, 1 + i); // Pitch -> Freq Mod
        synth->connect(midiPlayerNodeId, velChan,   polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Velocity -> Gate Mod

        // B. Connect the PolyVCO voice's audio output to the Track Mixer's input.
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // 5. Connect the Track Mixer to the main audio output.
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R
    
    // 6. Flag the graph for a rebuild.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnectVCO] Routine complete. ---");
}
void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer) return;

    pushSnapshot();

    const int numTracks = midiPlayer->getNumTracks();
    if (numTracks == 0) return;

    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);

    // --- THIS IS THE NEW "FIND-BY-TRACING" LOGIC ---

    juce::uint32 polyVcoLid = 0;
    juce::uint32 trackMixerLid = 0;

    // 1. Scan existing connections to find modules to reuse by tracing backwards.
    // First, find a TrackMixer connected to the output.
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("trackmixer"))
        {
            trackMixerLid = conn.srcLogicalId; // Found a TrackMixer to reuse!
            break;
        }
    }
    // If we found a TrackMixer, now find a PolyVCO connected to it.
    if (trackMixerLid != 0)
    {
        for (const auto& conn : synth->getConnectionsInfo())
        {
            if (conn.dstLogicalId == trackMixerLid && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("polyvco"))
            {
                polyVcoLid = conn.srcLogicalId; // Found a PolyVCO to reuse!
                break;
            }
        }
    }

    // 2. Clear all old Pitch/Gate/Velocity connections from the MIDI Player.
    std::vector<ModularSynthProcessor::ConnectionInfo> oldConnections;
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.srcLogicalId == midiPlayerLid && conn.srcChan < 16 * 3)
            oldConnections.push_back(conn);
    }
    for (const auto& conn : oldConnections)
    {
        synth->disconnect(synth->getNodeIdForLogical(conn.srcLogicalId), conn.srcChan,
                          synth->getNodeIdForLogical(conn.dstLogicalId), conn.dstChan);
    }

    // 3. If we didn't find a PolyVCO to reuse after tracing, create a new one.
    if (polyVcoLid == 0)
    {
        auto polyVcoNodeId = synth->addModule("polyvco", false);
        polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
        pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPos.x + 400.0f, midiPos.y);
    }

    // 4. If we didn't find a TrackMixer to reuse after tracing, create a new one.
    if (trackMixerLid == 0)
    {
        auto trackMixerNodeId = synth->addModule("track_mixer", false);
        trackMixerLid = synth->getLogicalIdForNode(trackMixerNodeId);
        pendingNodePositions[(int)trackMixerLid] = ImVec2(midiPos.x + 800.0f, midiPos.y);
    }
    // --- END OF NEW LOGIC ---

    auto polyVcoNodeId = synth->getNodeIdForLogical(polyVcoLid);
    auto trackMixerNodeId = synth->getNodeIdForLogical(trackMixerLid);

    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numTracks;
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(trackMixerLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numTracks;

    int voicesToConnect = std::min({numTracks, PolyVCOModuleProcessor::MAX_VOICES, 64});
    for (int i = 0; i < voicesToConnect; ++i)
    {
        synth->connect(midiPlayerNodeId, i, polyVcoNodeId, 1 + i);
        synth->connect(midiPlayerNodeId, i + 16, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2 + 1);
    }
    
    synth->connect(trackMixerNodeId, 0, synth->getOutputNodeID(), 0);
    synth->connect(trackMixerNodeId, 1, synth->getOutputNodeID(), 1);

    synth->commitChanges();
}

void ImGuiNodeEditorComponent::handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid)
{
    if (!synth || !strokeSeq) return;

    juce::Logger::writeToLog("ü•Å BUILD DRUM KIT handler called! Creating modules...");

    // 1. Get Stroke Sequencer position
    auto seqNodeId = synth->getNodeIdForLogical(strokeSeqLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)strokeSeqLid);

    // 2. Create 3 Sample Loaders (for Floor, Mid, Ceiling triggers)
    auto sampler1NodeId = synth->addModule("sample_loader");
    auto sampler2NodeId = synth->addModule("sample_loader");
    auto sampler3NodeId = synth->addModule("sample_loader");
    
    auto sampler1Lid = synth->getLogicalIdForNode(sampler1NodeId);
    auto sampler2Lid = synth->getLogicalIdForNode(sampler2NodeId);
    auto sampler3Lid = synth->getLogicalIdForNode(sampler3NodeId);
    
    // Position samplers in a vertical stack to the right
    pendingNodePositions[(int)sampler1Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    pendingNodePositions[(int)sampler2Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 220.0f);
    pendingNodePositions[(int)sampler3Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 440.0f);

    // 3. Create Track Mixer (will be set to 6 tracks by Value node)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 200.0f);

    // 4. Create Value node set to 6.0 (for 3 stereo tracks = 6 channels)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(seqPos.x + 600.0f, seqPos.y + 550.0f);
    
    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = 6.0f;
    }

    // 5. Connect Stroke Sequencer TRIGGERS to Sample Loader TRIGGER MOD inputs (channel 3)
    synth->connect(seqNodeId, 0, sampler1NodeId, 3); // Floor Trig   -> Sampler 1 Trigger Mod
    synth->connect(seqNodeId, 1, sampler2NodeId, 3); // Mid Trig     -> Sampler 2 Trigger Mod
    synth->connect(seqNodeId, 2, sampler3NodeId, 3); // Ceiling Trig -> Sampler 3 Trigger Mod

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    // Sampler 1 (L+R) -> Mixer Audio 1+2
    synth->connect(sampler1NodeId, 0, mixerNodeId, 0); // Sampler 1 L -> Mixer Audio 1
    synth->connect(sampler1NodeId, 1, mixerNodeId, 1); // Sampler 1 R -> Mixer Audio 2
    
    // Sampler 2 (L+R) -> Mixer Audio 3+4
    synth->connect(sampler2NodeId, 0, mixerNodeId, 2); // Sampler 2 L -> Mixer Audio 3
    synth->connect(sampler2NodeId, 1, mixerNodeId, 3); // Sampler 2 R -> Mixer Audio 4
    
    // Sampler 3 (L+R) -> Mixer Audio 5+6
    synth->connect(sampler3NodeId, 0, mixerNodeId, 4); // Sampler 3 L -> Mixer Audio 5
    synth->connect(sampler3NodeId, 1, mixerNodeId, 5); // Sampler 3 R -> Mixer Audio 6

    // 7. Connect Value node (6.0) to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value (6) -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid)
{
    if (!synth || !animModule) return;

    // Query the dynamic output pins to determine how many bones are tracked
    auto dynamicPins = animModule->getDynamicOutputPins();
    
    // Each bone has 3 outputs: Vel X, Vel Y, Hit
    // So number of bones = number of pins / 3
    int numTrackedBones = (int)dynamicPins.size() / 3;
    
    if (numTrackedBones == 0)
    {
        juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO: No tracked bones! Add bones first.");
        return;
    }

    juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO handler called! Creating modules for " + 
                             juce::String(numTrackedBones) + " tracked bones...");

    // 1. Get Animation Module position
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    ImVec2 animPos = ImNodes::GetNodeGridSpacePos((int)animModuleLid);

    // 2. Create one Sample Loader per tracked bone
    std::vector<juce::AudioProcessorGraph::NodeID> samplerNodeIds;
    std::vector<juce::uint32> samplerLids;
    
    for (int i = 0; i < numTrackedBones; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        samplerNodeIds.push_back(samplerNodeId);
        samplerLids.push_back(synth->getLogicalIdForNode(samplerNodeId));
        
        // Position samplers in a vertical stack to the right
        pendingNodePositions[(int)samplerLids[i]] = ImVec2(animPos.x + 400.0f, animPos.y + i * 220.0f);
    }

    // 3. Create Track Mixer (num_bones * 2 for stereo pairs)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(animPos.x + 800.0f, animPos.y + (numTrackedBones * 110.0f));

    // 4. Create Value node for mixer track count
    int numMixerTracks = numTrackedBones * 2; // 2 channels per sampler (stereo)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(animPos.x + 600.0f, animPos.y + (numTrackedBones * 220.0f));

    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = (float)numMixerTracks;
    }

    // 5. Connect Animation Module TRIGGERS to Sample Loader TRIGGER MOD inputs
    // Animation Module Output Channels (per bone):
    //   i*3 + 0: Bone Vel X
    //   i*3 + 1: Bone Vel Y
    //   i*3 + 2: Bone Hit (trigger) ‚Üê Connect this to sampler
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int triggerChannel = i * 3 + 2; // Every 3rd channel starting at 2 (2, 5, 8, 11, ...)
        synth->connect(animNodeId, triggerChannel, samplerNodeIds[i], 3); // Bone Hit -> Sampler Trigger Mod
    }

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int mixerChannelL = i * 2;       // 0, 2, 4, 6, ...
        int mixerChannelR = i * 2 + 1;   // 1, 3, 5, 7, ...
        
        synth->connect(samplerNodeIds[i], 0, mixerNodeId, mixerChannelL); // Sampler L -> Mixer Audio L
        synth->connect(samplerNodeIds[i], 1, mixerNodeId, mixerChannelR); // Sampler R -> Mixer Audio R
    }

    // 7. Connect Value node to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
    
    juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO complete! " + juce::String(numTrackedBones) + 
                             " samplers + mixer + wiring created.");
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. Create the necessary Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 100.0f);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        *dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")) = numSteps;
    }

    // 3. CREATE a Sample Loader for each step and connect its audio to the mixer
    for (int i = 0; i < numSteps; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(seqPos.x + 400.0f, seqPos.y + (i * 220.0f));

        // Connect this sampler's audio output to the mixer's input
        synth->connect(samplerNodeId, 0 /*Audio Output*/, mixerNodeId, i);
        
        // Connect the Sequencer's CV/Trig for this step directly to the new sampler
        synth->connect(seqNodeId, 7 + i * 3 + 0, samplerNodeId, 0); // Pitch N -> Pitch Mod
        synth->connect(seqNodeId, 1, samplerNodeId, 2); // Main Gate -> Gate Mod
        synth->connect(seqNodeId, 7 + i * 3 + 2, samplerNodeId, 3); // Trig N  -> Trigger Mod
    }
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod

    // 4. Connect the mixer to the main output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. CREATE the PolyVCO and Track Mixer
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numSteps;
    }
    
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numSteps;
    }

    // 3. Connect CV, Audio, and Main Output
    for (int i = 0; i < numSteps; ++i)
    {
        // Connect CV: Sequencer -> PolyVCO
        synth->connect(seqNodeId, 7 + i * 3 + 0, polyVcoNodeId, 1 + i);                                  // Pitch N -> Freq N Mod
        synth->connect(seqNodeId, 1, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Main Gate -> Gate N Mod

        // Connect Audio: PolyVCO -> Mixer
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // Connect Num Steps output (channel 6) to PolyVCO's Num Voices Mod input (channel 0)
    synth->connect(seqNodeId, 6, polyVcoNodeId, 0); // Num Steps -> Num Voices Mod
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod
    
    // Connect Mixer -> Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info and get number of tracked colors
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count using the new helper method
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create PolyVCO with matching number of voices
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y);
    
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices")))
            *p = numColors;
    }
    
    // 3. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 4. Connect Num Colors output to PolyVCO's NumVoices Mod and TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, polyVcoNodeId, 0); // Num Colors -> NumVoices Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64);  // Num Colors -> Num Tracks Mod
    
    // 5. Connect ColorTracker outputs to PolyVCO inputs
    for (int i = 0; i < numColors; ++i)
    {
        // Map X position to pitch/frequency for voice i
        synth->connect(colorTrackerNodeId, i * 3 + 0, polyVcoNodeId, 1 + i); // X -> Freq Mod
        
        // Map Area to gate level for voice i
        const int gateModChannel = 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i;
        synth->connect(colorTrackerNodeId, i * 3 + 2, polyVcoNodeId, gateModChannel); // Area -> Gate Mod
    }
    
    // 6. Connect PolyVCO audio outputs to Track Mixer inputs
    for (int i = 0; i < numColors; ++i)
    {
        synth->connect(polyVcoNodeId, i, mixerNodeId, i); // Voice i -> Mixer Track i
    }
    
    // 7. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to PolyVCO.");
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y + 100.0f);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 3. Connect Num Colors output to TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64); // Num Colors -> Num Tracks Mod

    // 4. Create a Sample Loader for each tracked color
    for (int i = 0; i < numColors; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y + (i * 220.0f));

        // Connect Sample Loader audio output to mixer
        synth->connect(samplerNodeId, 0, mixerNodeId, i); // Audio -> Mixer Track i
        
        // Connect ColorTracker CV outputs to Sample Loader modulation inputs
        synth->connect(colorTrackerNodeId, i * 3 + 0, samplerNodeId, 0); // X -> Pitch Mod
        synth->connect(colorTrackerNodeId, i * 3 + 2, samplerNodeId, 2); // Area -> Gate Mod
    }
    
    // 5. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to Sample Loaders.");
}

// Add this exact helper function to the class
void ImGuiNodeEditorComponent::parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex)
{
    outIndex = -1; // Default to no index
    outType = fullName;

    if (fullName.contains(" "))
    {
        const juce::String lastWord = fullName.substring(fullName.lastIndexOfChar(' ') + 1);
        if (lastWord.containsOnly("0123456789"))
        {
            outIndex = lastWord.getIntValue();
            outType = fullName.substring(0, fullName.lastIndexOfChar(' '));
        }
    }
}

// Helper functions to get pins from modules
std::vector<AudioPin> ImGuiNodeEditorComponent::getOutputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioOuts;
    return {};
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getInputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioIns;
    return {};
}

AudioPin* ImGuiNodeEditorComponent::findInputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getInputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

AudioPin* ImGuiNodeEditorComponent::findOutputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getOutputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::findNodesOfType(const juce::String& moduleType)
{
    std::vector<juce::uint32> result;
    if (!synth) return result;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleTypeForLogical(modInfo.first) == moduleType)
        {
            result.push_back(modInfo.first);
        }
    }
    return result;
}

// New dynamic pin-fetching helper
std::vector<PinInfo> ImGuiNodeEditorComponent::getDynamicOutputPins(ModuleProcessor* module)
{
    std::vector<PinInfo> pins;
    if (!module) return pins;

    const int numOutputChannels = module->getBus(false, 0)->getNumberOfChannels();
    for (int i = 0; i < numOutputChannels; ++i)
    {
        juce::String pinName = module->getAudioOutputLabel(i);
        if (pinName.isNotEmpty())
        {
            pins.push_back({(uint32_t)i, pinName}); // Store the full pin name in the type field
        }
    }
    return pins;
}

// Template function implementations
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToMonophonicTargets(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping,
    const std::vector<juce::uint32>& targetLids)
{
    if (!synth || !sourceNode || targetLids.empty()) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToMonophonicTargets called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    // Use provided target logical IDs explicitly
    auto targetNodes = targetLids;

    int currentTargetIndex = 0;

    // First, group all of the source node's output pins by their index number.
    // For example, "Pitch 1" and "Trig 1" will both be in the group for index 1.
    std::map<int, std::vector<PinInfo>> pinsByIndex;
    
    // THE FIX: Get pins directly from the module instance.
    auto outputPins = getDynamicOutputPins(sourceNode);
    
    for (const auto& pin : outputPins)
    {
        juce::String type;
        int index = -1;
        parsePinName(pin.type, type, index); // Use pin.type instead of pin.name
        if (index != -1) {
            // Store channel ID as the pin's ID
            pinsByIndex[index].push_back({(uint32_t)pin.id, type}); 
        }
    }

    // Now, loop through each group of pins (each voice).
    for (auto const& [index, pinsInGroup] : pinsByIndex)
    {
        if (currentTargetIndex >= (int)targetNodes.size()) break; // Stop if we run out of targets
        auto targetNodeId = targetNodes[currentTargetIndex];

        // For each pin in the group (e.g., for "Pitch 1" and "Trig 1")...
        for (const auto& pinInfo : pinsInGroup)
        {
            // Check if we have a connection rule for this pin type (e.g., "Pitch").
            if (pinNameMapping.count(pinInfo.type))
            {
                juce::String targetPinName = pinNameMapping.at(pinInfo.type);
                auto* targetPin = findInputPin("sample loader", targetPinName);

                // If the target pin exists, create the connection.
                if (targetPin)
                {
                    juce::uint32 sourceLogicalId = 0;
                    for (const auto& modInfo : synth->getModulesInfo())
                    {
                        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
                        {
                            sourceLogicalId = modInfo.first;
                            break;
                        }
                    }
                    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);
                    synth->connect(sourceNodeId, pinInfo.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
                }
            }
        }
        // IMPORTANT: Move to the next target module for the next voice.
        currentTargetIndex++;
    }
}

template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToPolyphonicTarget(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping)
{
    if (!synth || !sourceNode) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToPolyphonicTarget called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    juce::uint32 sourceLogicalId = 0;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            sourceLogicalId = modInfo.first;
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    auto targetNodes = findNodesOfType("polyvco");
    if (targetNodes.empty()) return;
    auto targetNodeId = targetNodes[0]; // Use the first available PolyVCO

    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);

    // THE FIX: Get pins directly from the module instance, not the database.
    auto outputPins = getDynamicOutputPins(sourceNode);

    // Loop through every output pin on the source module.
    for (const auto& sourcePin : outputPins)
    {
        // Parse the source pin's name to get its type and index.
        juce::String sourceType;
        int sourceIndex = -1;
        parsePinName(sourcePin.type, sourceType, sourceIndex); // Use pin.type instead of pin.name

        if (sourceIndex == -1) continue; // Skip pins that aren't numbered.

        // Check if we have a rule for this pin type (e.g., "Pitch" maps to "Freq").
        if (pinNameMapping.count(sourceType))
        {
            juce::String targetType = pinNameMapping.at(sourceType);
            // PolyVCO inputs use the format "Freq 1 Mod", "Gate 1 Mod", etc.
            juce::String targetPinName = targetType + " " + juce::String(sourceIndex) + " Mod";

            // Find that pin on the target and connect it if available.
            auto* targetPin = findInputPin("polyvco", targetPinName);
            if (targetPin)
            {
                synth->connect(sourceNodeId, sourcePin.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleAutoConnectionRequests()
{
    if (!synth) return;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* module = synth->getModuleForLogical(modInfo.first);
        if (!module) continue;

        // --- Check MultiSequencer Flags ---
        if (auto* multiSeq = dynamic_cast<MultiSequencerModuleProcessor*>(module))
        {
            if (multiSeq->autoConnectSamplersTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectSamplers(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
            if (multiSeq->autoConnectVCOTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectVCO(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
        }
        
        // --- Check ColorTracker Flags ---
        if (auto* colorTracker = dynamic_cast<ColorTrackerModule*>(module))
        {
            if (colorTracker->autoConnectPolyVCOTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectPolyVCO(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
            if (colorTracker->autoConnectSamplersTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectSamplers(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check StrokeSequencer Flags ---
        if (auto* strokeSeq = dynamic_cast<StrokeSequencerModuleProcessor*>(module))
        {
            if (strokeSeq->autoBuildDrumKitTriggered.exchange(false))
            {
                handleStrokeSeqBuildDrumKit(strokeSeq, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check AnimationModule Flags ---
        if (auto* animModule = dynamic_cast<AnimationModuleProcessor*>(module))
        {
            if (animModule->autoBuildTriggersAudioTriggered.exchange(false))
            {
                handleAnimationBuildTriggersAudio(animModule, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check MIDIPlayer Flags ---
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(module))
        {
            if (midiPlayer->autoConnectTriggered.exchange(false)) // Samplers
            {
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
        }
    }
}
void ImGuiNodeEditorComponent::handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType)
{
    if (!synth || !midiPlayer) return;
    
    juce::Logger::writeToLog("[MIDI Player Quick Connect] Request type: " + juce::String(requestType));
    
    // Get ALL tracks (don't filter by whether they have notes)
    const auto& notesByTrack = midiPlayer->getNotesByTrack();
    int numTracks = (int)notesByTrack.size();
    
    if (numTracks == 0)
    {
        juce::Logger::writeToLog("[MIDI Player Quick Connect] No tracks in MIDI file");
        return;
    }
    
    // Get MIDI Player position for positioning new nodes
    ImVec2 playerPos = ImNodes::GetNodeEditorSpacePos(static_cast<int>(midiPlayerLid));
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    
    // Request Type: 1=PolyVCO, 2=Samplers, 3=Both
    juce::uint32 polyVCOLid = 0;
    juce::uint32 mixerLid = 0;
    
    if (requestType == 1 || requestType == 3) // PolyVCO or Both
    {
        // 1. Create PolyVCO
        auto polyVCONodeId = synth->addModule("polyvco");
        polyVCOLid = synth->getLogicalIdForNode(polyVCONodeId);
        pendingNodeScreenPositions[(int)polyVCOLid] = ImVec2(playerPos.x + 400.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created PolyVCO at LID " + juce::String((int)polyVCOLid));
        
        // 2. Create Track Mixer
        auto mixerNodeId = synth->addModule("track_mixer");
        mixerLid = synth->getLogicalIdForNode(mixerNodeId);
        pendingNodeScreenPositions[(int)mixerLid] = ImVec2(playerPos.x + 700.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        
        // 3. Connect MIDI Player tracks to PolyVCO
        // Connect ALL tracks, regardless of whether they have notes
        int trackIdx = 0;
        for (size_t i = 0; i < notesByTrack.size() && trackIdx < 32; ++i)
        {
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiVeloPin = trackIdx * 4 + 2;
            
            const int vcoFreqPin = trackIdx + 1;
            const int vcoWavePin = 32 + trackIdx + 1;
            const int vcoGatePin = 64 + trackIdx + 1;
            
            synth->connect(midiPlayerNodeId, midiPitchPin, polyVCONodeId, vcoFreqPin);
            synth->connect(midiPlayerNodeId, midiGatePin, polyVCONodeId, vcoGatePin);
            synth->connect(midiPlayerNodeId, midiVeloPin, polyVCONodeId, vcoWavePin);
            trackIdx++;
        }
        
        // 4. Connect Num Tracks to PolyVCO (Num Voices Mod on channel 0)
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       polyVCONodeId, 0);
        
        // 5. Connect PolyVCO outputs to Track Mixer inputs
        for (int i = 0; i < trackIdx; ++i)
        {
            synth->connect(polyVCONodeId, i, mixerNodeId, i);
        }
        
        // 6. Connect Num Tracks output to mixer's Num Tracks Mod input
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
        
        // 7. Connect Track Mixer to main output
        auto outputNodeId = synth->getOutputNodeID();
        synth->connect(mixerNodeId, 0, outputNodeId, 0); // L
        synth->connect(mixerNodeId, 1, outputNodeId, 1); // R
        
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                " tracks: MIDI Player ‚Üí PolyVCO ‚Üí Track Mixer ‚Üí Output");
    }
    
    if (requestType == 2 || requestType == 3) // Samplers or Both
    {
        float samplerX = playerPos.x + 400.0f;
        float mixerX = playerPos.x + 700.0f;
        
        // If PolyVCO mode (Both), offset samplers and use same mixer
        if (requestType == 3)
        {
            samplerX += 300.0f; // Offset samplers if PolyVCO exists
            // Reuse existing mixer created in PolyVCO section
        }
        else
        {
            // 1. Create Track Mixer for Samplers-only mode
            auto mixerNodeId = synth->addModule("track_mixer");
            mixerLid = synth->getLogicalIdForNode(mixerNodeId);
            pendingNodeScreenPositions[(int)mixerLid] = ImVec2(mixerX, playerPos.y);
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        }
        
        // 2. Create samplers and connect
        // Connect ALL tracks, regardless of whether they have notes
        auto mixerNodeId = synth->getNodeIdForLogical(mixerLid);
        int trackIdx = 0;
        int totalTracks = (int)notesByTrack.size();
        int mixerStartChannel = (requestType == 3) ? totalTracks : 0; // Offset for "Both" mode
        
        for (size_t i = 0; i < notesByTrack.size(); ++i)
        {
            // Create SampleLoader
            float samplerY = playerPos.y + (trackIdx * 150.0f);
            auto samplerNodeId = synth->addModule("sample_loader");
            juce::uint32 samplerLid = synth->getLogicalIdForNode(samplerNodeId);
            pendingNodeScreenPositions[(int)samplerLid] = ImVec2(samplerX, samplerY);
            
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiTrigPin = trackIdx * 4 + 3;
            
            // Connect MIDI Player to Sampler
            synth->connect(midiPlayerNodeId, midiPitchPin, samplerNodeId, 0);
            synth->connect(midiPlayerNodeId, midiGatePin, samplerNodeId, 2);
            synth->connect(midiPlayerNodeId, midiTrigPin, samplerNodeId, 3);
            
            // Connect Sampler output to Track Mixer input
            synth->connect(samplerNodeId, 0, mixerNodeId, mixerStartChannel + trackIdx);
            
            trackIdx++;
        }
        
        // 3. Connect Num Tracks to mixer and route to output (only if not already done in PolyVCO mode)
        if (requestType != 3)
        {
            synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                           mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
            
            // 4. Connect Track Mixer to output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(mixerNodeId, 0, outputNodeId, 0);
            synth->connect(mixerNodeId, 1, outputNodeId, 1);
            
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Complete chain: " + juce::String(trackIdx) + 
                                    " SampleLoaders ‚Üí Track Mixer (with Num Tracks) ‚Üí Stereo Output");
        }
        else
        {
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                    " SampleLoaders ‚Üí Track Mixer (channels " + juce::String(mixerStartChannel) + 
                                    "-" + juce::String(mixerStartChannel + trackIdx - 1) + 
                                    ") [Mixer already connected in PolyVCO section]");
        }
    }
    
    // Commit changes
    if (synth)
    {
        synth->commitChanges();
        graphNeedsRebuild = true;
    }
    
    pushSnapshot();
}

void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        const int numSelected = ImNodes::NumSelectedLinks();
        const bool isMultiInsert = numSelected > 1;

        // --- Module Insertion on Cables (Organized by Category) ---
        // Map format: {Display Name, Internal Type}
        // Internal types use lowercase with underscores for spaces
        const std::map<const char*, const char*> audioInsertable = {
            // Effects
            {"VCF", "vcf"}, {"Delay", "delay"}, {"Reverb", "reverb"},
            {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
            {"Limiter", "limiter"}, {"Noise Gate", "gate"}, {"Drive", "drive"},
            {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"}, 
            {"8-Band Shaper", "8bandshaper"}, {"Granulator", "granulator"}, 
            {"Harmonic Shaper", "harmonic_shaper"}, {"Time/Pitch Shifter", "timepitch"},
            {"De-Crackle", "de_crackle"},
            // Utilities
            {"VCA", "vca"}, {"Mixer", "mixer"}, {"Attenuverter", "attenuverter"},
            // Modulators
            {"Function Generator", "function_generator"}, {"Shaping Oscillator", "shaping_oscillator"},
            // TTS
            {"Vocal Tract Filter", "vocal_tract_filter"},
            // Analysis
            {"Scope", "scope"}, {"Frequency Graph", "frequency_graph"}
        };
        const std::map<const char*, const char*> modInsertable = {
            // Utilities
            {"Attenuverter", "attenuverter"}, {"Lag Processor", "lag_processor"}, 
            {"Math", "math"}, {"Map Range", "map_range"}, {"Quantizer", "quantizer"},
            {"Rate", "rate"}, {"Comparator", "comparator"}, {"Logic", "logic"},
            {"CV Mixer", "cv_mixer"}, {"Sequential Switch", "sequential_switch"},
            // Modulators
            {"S&H", "s_and_h"}, {"Function Generator", "function_generator"},
            // Sequencers
            {"Timeline", "timeline"}
        };
        const std::map<const char*, const char*> videoInsertable = {
            // Computer Vision (Video processing)
            // Passthrough nodes (Video In ‚Üí Video Out)
            {"Video FX", "video_fx"}, {"Crop Video", "crop_video"},
            {"Movement Detector", "movement_detector"},
            {"Human Detector", "human_detector"}, {"Object Detector", "object_detector"},
            {"Pose Estimator", "pose_estimator"}, {"Hand Tracker", "hand_tracker"},
            {"Face Tracker", "face_tracker"}, {"Color Tracker", "color_tracker"},
            {"Contour Detector", "contour_detector"}, {"Semantic Segmentation", "semantic_segmentation"}
        };
        
        // Determine which list to show based on cable type
        const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
        const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
        const bool isVideoCable = (srcType == PinDataType::Video && dstType == PinDataType::Video);
        const auto& listToShow = isVideoCable ? videoInsertable : (linkToInsertOn.isMod ? modInsertable : audioInsertable);

        if (isMultiInsert)
            ImGui::Text("Insert Node on %d Cables", numSelected);
        else
            ImGui::Text("Insert Node on Cable");

        // --- FIX: Iterate over map pairs instead of simple strings ---
        for (const auto& pair : listToShow)
        {
            // pair.first = display label, pair.second = internal type
            if (ImGui::MenuItem(pair.first))
            {
                if (isMultiInsert)
                {
                    handleInsertNodeOnSelectedLinks(pair.second);
                }
                else
                {
                    insertNodeBetween(pair.second);
                }
                ImGui::CloseCurrentPopup();
            }
        }
        
        // VST Plugins submenu (only for audio cables, not video cables)
        if (!linkToInsertOn.isMod && !isVideoCable)
        {
            ImGui::Separator();
            if (ImGui::BeginMenu("VST"))
            {
                auto& app = PresetCreatorApplication::getApp();
                auto& knownPluginList = app.getKnownPluginList();
                
                for (const auto& desc : knownPluginList.getTypes())
                {
                    if (ImGui::MenuItem(desc.name.toRawUTF8()))
                    {
                        if (isMultiInsert)
                        {
                            handleInsertNodeOnSelectedLinks(desc.name);
                        }
                        else
                        {
                            insertNodeBetween(desc.name);
                        }
                        ImGui::CloseCurrentPopup();
                    }
                    
                    // Show tooltip with plugin info
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
                        ImGui::Text("Version: %s", desc.version.toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
                ImGui::EndMenu();
            }
        }
        
        ImGui::EndPopup();
    }
    else
    {
        // --- FIX: Reset state when popup is closed ---
        // If the popup is not open (i.e., it was closed or the user clicked away),
        // we must reset the state variable. This ensures that the application
        // is no longer "stuck" in the insert-on-link mode and right-click on
        // empty canvas will work again.
        linkToInsertOn.linkId = -1;
    }
}

void ImGuiNodeEditorComponent::drawLinkInspectorTooltip(const LinkInfo& link)
{
    if (synth == nullptr) return;
    
    // Get the probe scope processor
    auto* scope = synth->getProbeScopeProcessor();
    if (scope == nullptr) return;

    // Get the statistics from the scope module
    float minVal, maxVal;
    scope->getStatistics(minVal, maxVal);

    // Get the scope buffer for waveform
    const auto& scopeBuffer = scope->getScopeBuffer();

    // Draw the text info
    ImGui::Text("Inspecting: %s", link.pinName.toRawUTF8());
    ImGui::Text("From: %s (ID %d)", link.sourceNodeName.toRawUTF8(), (int)link.srcNodeId);
    ImGui::Text("Pin: %s", link.pinName.toRawUTF8());
    
    ImGui::Separator();
    
    ImGui::TextColored(ImVec4(1.0f, 0.3f, 0.3f, 1.0f), "Peak Max: %.3f", maxVal);
    ImGui::TextColored(ImVec4(1.0f, 0.86f, 0.31f, 1.0f), "Peak Min: %.3f", minVal);
    
    float peakToPeak = maxVal - minVal;
    ImGui::Text("P-P: %.3f", peakToPeak);
    
    float dBMax = maxVal > 0.0001f ? 20.0f * std::log10(maxVal) : -100.0f;
    ImGui::Text("Max dBFS: %.1f", dBMax);

    ImGui::Separator();

    // Draw the waveform using ImGui PlotLines
    const int numSamples = scopeBuffer.getNumSamples();
    if (scopeBuffer.getNumChannels() > 0 && numSamples > 0)
    {
        const float* samples = scopeBuffer.getReadPointer(0);
        ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 80.0f);
        ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
    }
}

// --- NEW HELPER FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position)
{
    if (synth == nullptr) return;

    PinDataType srcType = getPinDataTypeForPin(linkInfo.srcPin);
    PinDataType dstType = getPinDataTypeForPin(linkInfo.dstPin);

    // 1. Create and Position the New Node
    // Check if this is a VST plugin by checking against known plugins
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // This is a VST plugin - use addVstModule
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        // Regular module - use addModule
        newNodeId = synth->addModule(nodeType);
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points
    auto originalSrcNodeId = synth->getNodeIdForLogical(linkInfo.srcPin.logicalId);
    auto originalDstNodeId = (linkInfo.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkInfo.dstPin.logicalId);

    // 3. Disconnect the Original Link
    synth->disconnect(originalSrcNodeId, linkInfo.srcPin.channel, originalDstNodeId, linkInfo.dstPin.channel);

    // 4. Configure newly inserted node if necessary (e.g., MapRange)
    int newNodeOutputChannel = 0;
    if (nodeType == "MapRange")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(linkInfo.srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    // 5. Reconnect through the New Node
    synth->connect(originalSrcNodeId, linkInfo.srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, linkInfo.dstPin.channel);
}

void ImGuiNodeEditorComponent::insertNodeOnLinkStereo(const juce::String& nodeType, 
                                                       const LinkInfo& linkLeft, 
                                                       const LinkInfo& linkRight, 
                                                       const ImVec2& position)
{
    if (synth == nullptr) return;

    juce::Logger::writeToLog("[InsertStereo] Inserting stereo node: " + nodeType);
    juce::Logger::writeToLog("[InsertStereo] Left cable: " + juce::String(linkLeft.srcPin.logicalId) + 
                            " ch" + juce::String(linkLeft.srcPin.channel) + " -> " + 
                            juce::String(linkLeft.dstPin.logicalId) + " ch" + juce::String(linkLeft.dstPin.channel));
    juce::Logger::writeToLog("[InsertStereo] Right cable: " + juce::String(linkRight.srcPin.logicalId) + 
                            " ch" + juce::String(linkRight.srcPin.channel) + " -> " + 
                            juce::String(linkRight.dstPin.logicalId) + " ch" + juce::String(linkRight.dstPin.channel));

    // 1. Create ONE node for both channels
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    juce::String nodeName = isVst ? nodeType : juce::String(nodeType).replaceCharacter('_', ' ');
    if (!isVst)
    {
        nodeName = nodeName.toLowerCase();
        bool capitalizeNext = true;
        for (int i = 0; i < nodeName.length(); ++i)
        {
            if (capitalizeNext && juce::CharacterFunctions::isLetter(nodeName[i]))
            {
                nodeName = nodeName.substring(0, i) + juce::String::charToString(nodeName[i]).toUpperCase() + nodeName.substring(i + 1);
                capitalizeNext = false;
            }
            else if (nodeName[i] == ' ')
                capitalizeNext = true;
        }
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points for LEFT cable (first cable)
    auto leftSrcNodeId = synth->getNodeIdForLogical(linkLeft.srcPin.logicalId);
    auto leftDstNodeId = (linkLeft.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkLeft.dstPin.logicalId);

    // 3. Get Original Connection Points for RIGHT cable (second cable)
    auto rightSrcNodeId = synth->getNodeIdForLogical(linkRight.srcPin.logicalId);
    auto rightDstNodeId = (linkRight.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkRight.dstPin.logicalId);

    // 4. Disconnect BOTH Original Links (using their actual source/dest channels)
    synth->disconnect(leftSrcNodeId, linkLeft.srcPin.channel, leftDstNodeId, linkLeft.dstPin.channel);
    synth->disconnect(rightSrcNodeId, linkRight.srcPin.channel, rightDstNodeId, linkRight.dstPin.channel);

    // 5. Reconnect Through the New Node
    // Left cable -> new node's LEFT input (ch0)
    synth->connect(leftSrcNodeId, linkLeft.srcPin.channel, newNodeId, 0);
    
    // Right cable -> new node's RIGHT input (ch1)
    synth->connect(rightSrcNodeId, linkRight.srcPin.channel, newNodeId, 1);
    
    // New node's outputs -> original destinations
    // Note: We'll connect both outputs to their respective destinations
    synth->connect(newNodeId, 0, leftDstNodeId, linkLeft.dstPin.channel);
    synth->connect(newNodeId, 1, rightDstNodeId, linkRight.dstPin.channel);

    juce::Logger::writeToLog("[InsertStereo] Successfully inserted stereo node with separate sources/destinations");
}

// --- REFACTORED OLD FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin)
{
    if (synth == nullptr) return;

    // 1. Get positions to place the new node between the source and destination
    ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(srcPin.logicalId);
    ImVec2 dstPos = ImNodes::GetNodeGridSpacePos(dstPin.logicalId == 0 ? 0 : dstPin.logicalId);
    ImVec2 newNodePos = ImVec2((srcPos.x + dstPos.x) * 0.5f, (srcPos.y + dstPos.y) * 0.5f);

    // 2. Create and position the new converter node
    // Check if this is a VST plugin
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodePositions[(int)newNodeLid] = newNodePos;

    // 3. Get original node IDs
    auto originalSrcNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
    auto originalDstNodeId = (dstPin.logicalId == 0)
        ? synth->getOutputNodeID()
        : synth->getNodeIdForLogical(dstPin.logicalId);

    // 4. Configure the new node if it's a MapRange or Attenuverter
    int newNodeOutputChannel = 0;
    if (nodeType == "MapRange") {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid))) {
            PinDataType srcType = getPinDataTypeForPin(srcPin);
            PinDataType dstType = getPinDataTypeForPin(dstPin);
            Range inRange = getSourceRange(srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0; // Use Raw Out for Audio, Norm Out for CV
        }
    } else if (nodeType == "Attenuverter") {
        // You might want to pre-configure the Attenuverter here if needed
    }

    // 5. Connect the signal chain: Original Source -> New Node -> Original Destination
    synth->connect(originalSrcNodeId, srcPin.channel, newNodeId, 0); // Source -> New Node's first input
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, dstPin.channel); // New Node -> Destination

    juce::Logger::writeToLog("[AutoConvert] Inserted '" + nodeType + "' between " + juce::String(srcPin.logicalId) + " and " + juce::String(dstPin.logicalId));
}

void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType)
{
    // This function is now just a wrapper that calls the helper
    // with the stored link info and the current mouse position.
    if (linkToInsertOn.linkId != -1)
    {
        insertNodeOnLink(nodeType, linkToInsertOn, ImGui::GetMousePos());
        graphNeedsRebuild = true;
        pushSnapshot();
        linkToInsertOn.linkId = -1; // Reset state
    }
}

void ImGuiNodeEditorComponent::handleInsertNodeOnSelectedLinks(const juce::String& nodeType)
{
    if (synth == nullptr || ImNodes::NumSelectedLinks() == 0) return;

    pushSnapshot(); // Create one undo state for the entire batch operation.

    const int numSelectedLinks = ImNodes::NumSelectedLinks();
    std::vector<int> selectedLinkIds(numSelectedLinks);
    ImNodes::GetSelectedLinks(selectedLinkIds.data());

    ImVec2 basePosition = ImGui::GetMousePos();
    float x_offset = 0.0f;

    // === OPTION A: If exactly 2 audio cables are selected, insert ONE stereo node ===
    if (numSelectedLinks == 2)
    {
        // Get info for both cables
        auto it0 = linkIdToAttrs.find(selectedLinkIds[0]);
        auto it1 = linkIdToAttrs.find(selectedLinkIds[1]);
        
        if (it0 != linkIdToAttrs.end() && it1 != linkIdToAttrs.end())
        {
            LinkInfo link0, link1;
            link0.linkId = selectedLinkIds[0];
            link0.srcPin = decodePinId(it0->second.first);
            link0.dstPin = decodePinId(it0->second.second);
            link0.isMod = link0.srcPin.isMod || link0.dstPin.isMod;
            
            link1.linkId = selectedLinkIds[1];
            link1.srcPin = decodePinId(it1->second.first);
            link1.dstPin = decodePinId(it1->second.second);
            link1.isMod = link1.srcPin.isMod || link1.dstPin.isMod;
            
            // Check if BOTH are audio cables (not mod cables)
            if (!link0.isMod && !link1.isMod)
            {
                // Create ONE stereo node with link0 -> Left (ch0), link1 -> Right (ch1)
                insertNodeOnLinkStereo(nodeType, link0, link1, basePosition);
                juce::Logger::writeToLog("[InsertNode] Inserted STEREO node for 2 selected audio cables");
                graphNeedsRebuild = true;
                return; // Done - we've handled both cables with one node
            }
        }
    }

    // === FALLBACK: Multiple cables or mixed mod/audio - insert separate nodes ===
    std::set<int> processedLinks; // Track which links we've already handled
    
    for (size_t i = 0; i < selectedLinkIds.size(); ++i)
    {
        int linkId = selectedLinkIds[i];
        if (processedLinks.count(linkId)) continue;

        auto it = linkIdToAttrs.find(linkId);
        if (it == linkIdToAttrs.end()) continue;

        LinkInfo currentLink;
        currentLink.linkId = linkId;
        currentLink.srcPin = decodePinId(it->second.first);
        currentLink.dstPin = decodePinId(it->second.second);
        currentLink.isMod = currentLink.srcPin.isMod || currentLink.dstPin.isMod;

        ImVec2 newPosition = ImVec2(basePosition.x + x_offset, basePosition.y);
        
        // === MONO INSERT: Create separate node for each cable ===
        insertNodeOnLink(nodeType, currentLink, newPosition);
        processedLinks.insert(linkId);
        juce::Logger::writeToLog("[InsertNode] Inserted MONO node for link " + juce::String(linkId));

        x_offset += 40.0f;
    }

    graphNeedsRebuild = true;
    // The single pushSnapshot at the beginning handles the undo state.
}

juce::File ImGuiNodeEditorComponent::findPresetsDirectory()
{
    // Search upwards from the executable's location for a sibling directory
    // named "Synth_presets". This is robust to different build configurations.
    juce::File dir = juce::File::getSpecialLocation(juce::File::currentExecutableFile);

    for (int i = 0; i < 8; ++i) // Limit search depth to 8 levels
    {
        dir = dir.getParentDirectory();
        if (!dir.exists()) break;

        juce::File candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.isDirectory())
        {
            return candidate;
        }
    }
    
    // Fallback to an empty file (system default) if not found
    return {};
}
// Helper function implementations
PinDataType ImGuiNodeEditorComponent::getPinDataTypeForPin(const PinID& pin)
{
    if (synth == nullptr) return PinDataType::Raw;

    // Handle the main output node as a special case
    if (pin.logicalId == 0)
    {
        return PinDataType::Audio;
    }

    juce::String moduleType = getTypeForLogical(pin.logicalId);
    if (moduleType.isEmpty()) return PinDataType::Raw;

    // *** NEW: Check dynamic pins FIRST ***
    if (auto* module = synth->getModuleForLogical(pin.logicalId))
    {
        // Check dynamic input pins
        if (pin.isInput && !pin.isMod)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            for (const auto& dynPin : dynamicInputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
        // Check dynamic output pins
        else if (!pin.isInput && !pin.isMod)
        {
            auto dynamicOutputs = module->getDynamicOutputPins();
            for (const auto& dynPin : dynamicOutputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
    }
    // *** END NEW CODE ***

    auto it = getModulePinDatabase().find(moduleType);
    if (it == getModulePinDatabase().end())
    {
        // Fallback: case-insensitive lookup (module registry may use different casing)
        juce::String moduleTypeLower = moduleType.toLowerCase();
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0 || kv.first.toLowerCase() == moduleTypeLower)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
        if (it == getModulePinDatabase().end())
        {
            // If the module type is not in our static database, it's likely a VST plugin.
            // A safe assumption is that its pins are for audio.
            if (auto* module = synth->getModuleForLogical(pin.logicalId))
            {
                if (dynamic_cast<VstHostModuleProcessor*>(module))
                {
                    return PinDataType::Audio; // Green for VST pins
                }
            }
            return PinDataType::Raw;
        }
    }

    const auto& pinInfo = it->second;

    if (pin.isMod)
    {
        for (const auto& modPin : pinInfo.modIns)
        {
            if (modPin.paramId == pin.paramId)
            {
                return modPin.type;
            }
        }
    }
    else // It's an audio pin
    {
        const auto& pins = pin.isInput ? pinInfo.audioIns : pinInfo.audioOuts;
        for (const auto& audioPin : pins)
        {
            if (audioPin.channel == pin.channel)
            {
                return audioPin.type;
            }
        }
    }
    return PinDataType::Raw; // Fallback
}

unsigned int ImGuiNodeEditorComponent::getImU32ForType(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return IM_COL32(100, 150, 255, 255); // Blue
        case PinDataType::Audio: return IM_COL32(100, 255, 150, 255); // Green
        case PinDataType::Gate:  return IM_COL32(255, 220, 100, 255); // Yellow
        case PinDataType::Raw:   return IM_COL32(255, 100, 100, 255); // Red
        case PinDataType::Video: return IM_COL32(0, 200, 255, 255);   // Cyan
        default:                 return IM_COL32(150, 150, 150, 255); // Grey
    }
}

const char* ImGuiNodeEditorComponent::pinDataTypeToString(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return "CV (0 to 1)";
        case PinDataType::Audio: return "Audio (-1 to 1)";
        case PinDataType::Gate:  return "Gate/Trigger";
        case PinDataType::Raw:   return "Raw";
        case PinDataType::Video: return "Video Source";
        default:                 return "Unknown";
    }
}
void ImGuiNodeEditorComponent::handleNodeChaining()
{
    if (synth == nullptr) return;

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1) return;

    juce::Logger::writeToLog("[Node Chaining] Initiated for " + juce::String(numSelected) + " nodes.");

    // 1. Get all selected nodes and their horizontal positions.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        // Don't include the main output node in the chaining logic.
        if (nodeId == 0) continue;
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    // 2. Sort the nodes from left to right based on their X position.
    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    // 3. Connect the nodes in sequence.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid != 0 && destNodeId.uid != 0)
        {
            // Standard stereo connection: Out L -> In L, Out R -> In R
            synth->connect(sourceNodeId, 0, destNodeId, 0); // Connect channel 0
            synth->connect(sourceNodeId, 1, destNodeId, 1); // Connect channel 1

            juce::Logger::writeToLog("[Node Chaining] Connected " + getTypeForLogical(sourceLid) + " (" + juce::String(sourceLid) + ") to " + getTypeForLogical(destLid) + " (" + juce::String(destLid) + ")");
            
            // Check if the destination is a recorder and update its filename
            if (auto* destModule = synth->getModuleForLogical(destLid))
            {
                if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                {
                    if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                    {
                        recorder->updateSuggestedFilename(sourceModule->getName());
                    }
                }
            }
        }
    }

    // 4. Apply all the new connections to the audio graph.
    graphNeedsRebuild = true;
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType)
{
    std::vector<AudioPin> matchingPins;
    juce::String moduleType = getTypeForLogical(logicalId);

    if (moduleType.isEmpty())
    {
        return matchingPins;
    }

    auto it = getModulePinDatabase().find(moduleType);

    // --- CASE-INSENSITIVE LOOKUP ---
    if (it == getModulePinDatabase().end())
    {
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
    }

    if (it != getModulePinDatabase().end())
    {
        // --- Standard path for built-in modules ---
        const auto& pins = isInput ? it->second.audioIns : it->second.audioOuts;
        for (const auto& pin : pins)
        {
            if (pin.type == targetType)
            {
                matchingPins.push_back(pin);
            }
        }
    }

    // If no static pins matched (or none defined), fall back to dynamic pins from the module
    if (matchingPins.empty())
    {
        if (auto* module = synth->getModuleForLogical(logicalId))
        {
            // --- DYNAMIC PATH FOR MODULES WITH getDynamicInputPins/getDynamicOutputPins ---
            auto dynamicPins = isInput ? module->getDynamicInputPins() : module->getDynamicOutputPins();
            
            if (!dynamicPins.empty())
            {
                // Module provides dynamic pins - filter by type
                for (const auto& pin : dynamicPins)
                {
                    if (pin.type == targetType)
                    {
                        matchingPins.emplace_back(pin.name, pin.channel, pin.type);
                    }
                }
            }
            else if (auto* vst = dynamic_cast<VstHostModuleProcessor*>(module))
            {
                // For VSTs without dynamic pins, assume all pins are 'Audio' type for chaining.
                if (targetType == PinDataType::Audio)
                {
                    const int numChannels = isInput ? vst->getTotalNumInputChannels() : vst->getTotalNumOutputChannels();
                    for (int i = 0; i < numChannels; ++i)
                    {
                        juce::String pinName = isInput ? vst->getAudioInputLabel(i) : vst->getAudioOutputLabel(i);
                        if (pinName.isNotEmpty())
                        {
                            matchingPins.emplace_back(pinName, i, PinDataType::Audio);
                        }
                    }
                }
            }
        }
    }

    return matchingPins;
}

void ImGuiNodeEditorComponent::handleRecordOutput()
{
    if (!synth) return;

    pushSnapshot();
    juce::Logger::writeToLog("[Record Output] Initiated.");

    // 1. Find connections going to the main output node.
    std::vector<ModularSynthProcessor::ConnectionInfo> outputFeeds;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstIsOutput)
        {
            outputFeeds.push_back(c);
        }
    }

    if (outputFeeds.empty())
    {
        juce::Logger::writeToLog("[Record Output] No connections to main output found.");
        return;
    }

    // 2. Create and position the recorder.
    auto recorderNodeId = synth->addModule("recorder");
    auto recorderLid = synth->getLogicalIdForNode(recorderNodeId);
    ImVec2 outPos = ImNodes::GetNodeGridSpacePos(0);
    pendingNodePositions[(int)recorderLid] = ImVec2(outPos.x - 400.0f, outPos.y);
    
    auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical(recorderLid));
    if (recorder)
    {
        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
    }

    // 3. "Tap" the signals by connecting the original sources to the recorder.
    juce::String sourceName;
    for (const auto& feed : outputFeeds)
    {
        auto srcNodeId = synth->getNodeIdForLogical(feed.srcLogicalId);
        synth->connect(srcNodeId, feed.srcChan, recorderNodeId, feed.dstChan); // dstChan will be 0 or 1
        
        // Get the name of the first source for the filename prefix
        if (sourceName.isEmpty())
        {
            if (auto* srcModule = synth->getModuleForLogical(feed.srcLogicalId))
            {
                sourceName = srcModule->getName();
            }
        }
    }
    
    if (recorder)
    {
        recorder->updateSuggestedFilename(sourceName);
    }

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[Record Output] Recorder added and connected.");
}

void ImGuiNodeEditorComponent::handleColorCodedChaining(PinDataType targetType)
{
    if (synth == nullptr)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: synth is nullptr");
        return;
    }

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: numSelected <= 1 (" + juce::String(numSelected) + ")");
        return;
    }

    juce::Logger::writeToLog("[Color Chaining] Started for " + juce::String(toString(targetType)) + " with " + juce::String(numSelected) + " nodes");

    // 1. Get and sort selected nodes by their horizontal position.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0) continue; // Exclude the output node.
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    if (sortedNodes.empty())
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: No valid nodes after filtering");
        return;
    }

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    int totalConnectionsMade = 0;
    int totalConnectionAttempts = 0;

    // 2. Iterate through sorted nodes and connect matching pins.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[Color Chaining] Skipping invalid node pair: " + juce::String(sourceLid) + " -> " + juce::String(destLid));
            continue;
        }

        // Find all matching output pins on the source and input pins on the destination.
        auto sourcePins = getPinsOfType(sourceLid, false, targetType);
        auto destPins   = getPinsOfType(destLid, true, targetType);

        if (sourcePins.empty() || destPins.empty())
        {
            juce::Logger::writeToLog("[Color Chaining] No matching pins: " + juce::String(sourcePins.size()) + " src, " + juce::String(destPins.size()) + " dst");
            continue;
        }

        // Connect them one-to-one until we run out of available pins on either side.
        int connectionsToMake = std::min((int)sourcePins.size(), (int)destPins.size());

        for (int j = 0; j < connectionsToMake; ++j)
        {
            totalConnectionAttempts++;
            bool connectResult = synth->connect(sourceNodeId, sourcePins[j].channel, destNodeId, destPins[j].channel);
            if (connectResult)
            {
                totalConnectionsMade++;
                juce::Logger::writeToLog("[Color Chaining] Connected " + getTypeForLogical(sourceLid) + " -> " + getTypeForLogical(destLid));

                // Check if the destination is a recorder and update its filename
                if (auto* destModule = synth->getModuleForLogical(destLid))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                    {
                        if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                        {
                            recorder->updateSuggestedFilename(sourceModule->getName());
                        }
                    }
                }
            }
        }
    }

    juce::Logger::writeToLog("[Color Chaining] Completed: " + juce::String(totalConnectionsMade) + "/" + juce::String(totalConnectionAttempts) + " connections made");

    // 3. Apply all new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Module Category Color Coding
ImGuiNodeEditorComponent::ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleType)
{
    juce::String lower = moduleType.toLowerCase();
    
    // === CATEGORY CLASSIFICATION (Following Dictionary Structure) ===
    
    // --- 1. SOURCES (Green) ---
    if (lower.contains("vco") || lower.contains("polyvco") ||
        lower.contains("noise") || lower == "audio_input" || 
        lower.contains("sample") || lower == "value")
        return ModuleCategory::Source;
    
    // --- 2. EFFECTS (Red) ---
    // Note: Recorder moved to System, Vocal Tract Filter moved to TTS
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("reverb") || lower.contains("chorus") || 
        lower.contains("phaser") || lower.contains("compressor") || 
        lower.contains("limiter") || lower == "gate" ||
        lower.contains("drive") || lower.contains("eq") ||
        lower.contains("waveshaper") || lower.contains("8bandshaper") ||
        lower.contains("granulator") || lower.contains("harmonic_shaper") ||
        lower.contains("timepitch") || lower.contains("crackle"))
        return ModuleCategory::Effect;
    
    // --- 3. MODULATORS (Blue) ---
    if (lower.contains("lfo") || lower.contains("adsr") || 
        lower.contains("random") || lower.contains("s&h") || 
        lower.contains("function_generator") || lower.contains("shaping_oscillator"))
        return ModuleCategory::Modulator;
    
    // --- 4. UTILITIES & LOGIC (Orange) ---
    if (lower.contains("vca") || lower.contains("mixer") || 
        lower.contains("attenuverter") || lower.contains("lag_processor") ||
        lower.contains("math") || lower.contains("map_range") ||
        lower.contains("quantizer") || lower.contains("rate") ||
        lower.contains("comparator") || lower.contains("logic") ||
        lower.contains("clock_divider") || lower.contains("sequential_switch"))
        return ModuleCategory::Utility;
    
    // --- 5. SEQUENCERS (Light Green) ---
    if (lower.contains("sequencer") || lower.contains("tempo_clock") || lower == "timeline")
        return ModuleCategory::Seq;
    
    // --- 6. MIDI (Vibrant Purple) ---
    if (lower.contains("midi"))
        return ModuleCategory::MIDI;
    
    // --- 7. ANALYSIS (Purple) ---
    if (lower.contains("scope") || lower.contains("debug") || 
        lower.contains("frequency_graph"))
        return ModuleCategory::Analysis;
    
    // --- 8. TTS (Peach/Coral) ---
    if (lower.contains("tts") || lower.contains("vocal_tract"))
        return ModuleCategory::TTS_Voice;
    
    // --- 9. SPECIAL (Cyan) - Physics & Animation ---
    if (lower.contains("physics") || lower.contains("animation"))
        return ModuleCategory::Special_Exp;
    
    // --- 10. COMPUTER VISION (Bright Orange) ---
    if (lower.contains("webcam") || lower.contains("video_file") ||
        lower == "video_fx" || lower == "crop_video" ||
        lower.contains("movement") || lower.contains("detector") || 
        lower.contains("opencv") || lower.contains("vision") ||
        lower.contains("tracker") || lower.contains("segmentation") ||
        lower.contains("pose_estimator"))
        return ModuleCategory::OpenCV;
    
    // --- 11. SYSTEM (Lavender) ---
    if (lower.contains("meta") || lower.contains("inlet") || 
        lower.contains("outlet") || lower.contains("comment") ||
        lower.contains("recorder") || lower.contains("vst_host") ||
        lower.contains("best_practice") || lower == "bpm_monitor" || lower.contains("bpm monitor"))
        return ModuleCategory::Sys;
    
    // --- 12. PLUGINS (Teal) ---
    if (lower.contains("vst") || lower.contains("plugin"))
        return ModuleCategory::Plugin;
    
    // --- Default: Utility ---
    return ModuleCategory::Utility;
}

unsigned int ImGuiNodeEditorComponent::getImU32ForCategory(ModuleCategory category, bool hovered)
{
    ImU32 color;
    switch (category)
    {
        case ModuleCategory::Source:      color = IM_COL32(50, 120, 50, 255); break;     // Green
        case ModuleCategory::Effect:      color = IM_COL32(130, 60, 60, 255); break;     // Red
        case ModuleCategory::Modulator:   color = IM_COL32(50, 50, 130, 255); break;     // Blue
        case ModuleCategory::Utility:     color = IM_COL32(110, 80, 50, 255); break;     // Orange
        case ModuleCategory::Seq:         color = IM_COL32(90, 140, 90, 255); break;     // Light Green
        case ModuleCategory::MIDI:        color = IM_COL32(180, 120, 255, 255); break;   // Vibrant Purple
        case ModuleCategory::Analysis:    color = IM_COL32(100, 50, 110, 255); break;    // Purple
        case ModuleCategory::TTS_Voice:   color = IM_COL32(255, 180, 100, 255); break;   // Peach/Coral
        case ModuleCategory::Special_Exp: color = IM_COL32(50, 200, 200, 255); break;    // Cyan
        case ModuleCategory::OpenCV:      color = IM_COL32(255, 140, 0, 255); break;     // Bright Orange
        case ModuleCategory::Sys:         color = IM_COL32(120, 100, 140, 255); break;   // Lavender
        case ModuleCategory::Comment:     color = IM_COL32(80, 80, 80, 255); break;      // Grey
        case ModuleCategory::Plugin:      color = IM_COL32(50, 110, 110, 255); break;    // Teal
        default:                         color = IM_COL32(70, 70, 70, 255); break;
    }
    
    if (hovered) 
    { 
        // Brighten on hover
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        c.x *= 1.3f; c.y *= 1.3f; c.z *= 1.3f;
        return ImGui::ColorConvertFloat4ToU32(c);
    }
    return color;
}

// Quick Add Menu - Module Registry - Dictionary
// Maps Display Name -> { Internal Type, Description }
std::map<juce::String, std::pair<const char*, const char*>> ImGuiNodeEditorComponent::getModuleRegistry()
{
    return {
        // Sources
        {"Audio Input", {"audio_input", "Records audio from your audio interface"}},
        {"VCO", {"vco", "Voltage Controlled Oscillator - generates waveforms"}},
        {"Polyphonic VCO", {"polyvco", "Polyphonic VCO with multiple voices"}},
        {"Noise", {"noise", "White, pink, or brown noise generator"}},
        {"Sequencer", {"sequencer", "Step sequencer for creating patterns"}},
        {"Multi Sequencer", {"multi_sequencer", "Multi-track step sequencer"}},
        {"Stroke Sequencer", {"stroke_sequencer", "Freeform visual rhythmic and CV generator"}},
        {"MIDI Player", {"midi_player", "Plays MIDI files"}},
        {"MIDI CV", {"midi_cv", "Converts MIDI Note/CC messages to CV signals. (Monophonic)"}},
        {"MIDI Faders", {"midi_faders", "Up to 16 MIDI faders with CC learning"}},
        {"MIDI Knobs", {"midi_knobs", "Up to 16 MIDI knobs/rotary encoders with CC learning"}},
        {"MIDI Buttons", {"midi_buttons", "Up to 32 MIDI buttons with Gate/Toggle/Trigger modes"}},
        {"MIDI Jog Wheel", {"midi_jog_wheel", "Single MIDI jog wheel/rotary encoder"}},
        {"MIDI Pads", {"midi_pads", "16-pad MIDI controller with polyphonic triggers and velocity outputs"}},
        {"MIDI Logger", {"midi_logger", "Records CV/Gate to MIDI events with piano roll editor and .mid export"}},
        {"Value", {"value", "Constant CV value output"}},
        {"Sample Loader", {"sample_loader", "Loads and plays audio samples"}},
        
        // TTS
        {"TTS Performer", {"tts_performer", "Text-to-speech synthesizer"}},
        {"Vocal Tract Filter", {"vocal_tract_filter", "Physical model vocal tract filter"}},
        
        // Physics & Animation
        {"Physics", {"physics", "2D physics simulation for audio modulation"}},
        {"Animation", {"animation", "Skeletal animation system with glTF file support"}},
        
        // OpenCV (Computer Vision)
        {"Webcam Loader", {"webcam_loader", "Captures video from a webcam and publishes it as a source for vision processing modules"}},
        {"Video File Loader", {"video_file_loader", "Loads and plays a video file, publishes it as a source for vision processing modules"}},
        {"Video FX", {"video_fx", "Applies real-time video effects (brightness, contrast, saturation, blur, sharpen, etc.) to video sources, chainable"}},
        {"Crop Video", {"crop_video", "Crops and resizes video frames to a specified region, chainable video processor"}},
        {"Movement Detector", {"movement_detector", "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV"}},
        {"Human Detector", {"human_detector", "Detects faces or bodies in video source via Haar Cascades or HOG, outputs position and size as CV"}},
        {"Object Detector", {"object_detector", "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV"}},
        {"Pose Estimator", {"pose_estimator", "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals"}},
        {"Hand Tracker", {"hand_tracker", "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels)"}},
        {"Face Tracker", {"face_tracker", "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels)"}},
        {"Color Tracker", {"color_tracker", "Tracks multiple colors in video and outputs their positions and sizes as CV"}},
        {"Contour Detector", {"contour_detector", "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV"}},
        {"Semantic Segmentation", {"semantic_segmentmentation", "Uses deep learning to segment video into semantic regions and outputs detected areas as CV"}},
        
        // Effects
        {"VCF", {"vcf", "Voltage Controlled Filter"}},
        {"Delay", {"delay", "Echo/delay effect"}},
        {"Reverb", {"reverb", "Reverb effect"}},
        {"Chorus", {"chorus", "Chorus effect for thickening sound"}},
        {"Phaser", {"phaser", "Phaser modulation effect"}},
        {"Compressor", {"compressor", "Dynamic range compressor"}},
        {"Recorder", {"recorder", "Records audio to disk"}},
        {"Limiter", {"limiter", "Peak limiter"}},
        {"Noise Gate", {"gate", "Noise gate"}},
        {"Drive", {"drive", "Distortion/overdrive"}},
        {"Graphic EQ", {"graphic_eq", "Graphic equalizer"}},
        {"Waveshaper", {"waveshaper", "Waveshaping distortion"}},
        {"8-Band Shaper", {"8bandshaper", "8-band spectral shaper"}},
        {"Granulator", {"granulator", "Granular synthesis effect"}},
        {"Harmonic Shaper", {"harmonic_shaper", "Harmonic content shaper"}},
        {"Time/Pitch Shifter", {"timepitch", "Time stretching and pitch shifting"}},
        {"De-Crackle", {"de_crackle", "Removes clicks and pops"}},
        
        // Modulators
        {"LFO", {"lfo", "Low Frequency Oscillator for modulation"}},
        {"ADSR", {"adsr", "Attack Decay Sustain Release envelope"}},
        {"Random", {"random", "Random value generator"}},
        {"S&H", {"s_and_h", "Sample and Hold"}},
        {"Tempo Clock", {"tempo_clock", "Global clock with BPM control, transport (play/stop/reset), division, swing, and clock/gate outputs. Use External Takeover to drive the master transport."}},
        {"Function Generator", {"function_generator", "Custom function curves"}},
        {"Shaping Oscillator", {"shaping_oscillator", "Oscillator with waveshaping"}},
        
        // Utilities
        {"VCA", {"vca", "Voltage Controlled Amplifier"}},
        {"Mixer", {"mixer", "Audio/CV mixer"}},
        {"CV Mixer", {"cv_mixer", "CV signal mixer"}},
        {"Track Mixer", {"track_mixer", "Multi-track mixer with panning"}},
        {"Attenuverter", {"attenuverter", "Attenuate and invert signals"}},
        {"Lag Processor", {"lag_processor", "Slew rate limiter/smoother"}},
        {"Math", {"math", "Mathematical operations"}},
        {"Map Range", {"map_range", "Map values from one range to another"}},
        {"Quantizer", {"quantizer", "Quantize CV to scales"}},
        {"Rate", {"rate", "Rate/frequency divider"}},
        {"Comparator", {"comparator", "Compare and threshold signals"}},
        {"Logic", {"logic", "Boolean logic operations"}},
        {"Clock Divider", {"clock_divider", "Clock division and multiplication"}},
        {"Sequential Switch", {"sequential_switch", "Sequential signal router"}},
        {"Comment", {"comment", "Text comment box"}},
        {"Best Practice", {"best_practice", "Best practice node template"}},
        {"Snapshot Sequencer", {"snapshot_sequencer", "Snapshot sequencer for parameter automation"}},
        {"Timeline", {"timeline", "Transport-synchronized automation recorder for CV, Gate, Trigger, and Raw signals"}},
        {"BPM Monitor", {"bpm_monitor", "Hybrid rhythm detection and BPM reporting from sequencers and audio inputs"}},
        
        // Analysis
        {"Scope", {"scope", "Oscilloscope display"}},
        {"Debug", {"debug", "Debug value display"}},
        {"Input Debug", {"input_debug", "Input signal debugger"}},
        {"Frequency Graph", {"frequency_graph", "Spectrum analyzer display"}}
    };
}

// Legacy function for backwards compatibility with tooltip display
std::vector<std::pair<juce::String, const char*>> ImGuiNodeEditorComponent::getModuleDescriptions()
{
    std::vector<std::pair<juce::String, const char*>> result;
    for (const auto& entry : getModuleRegistry())
    {
        // Return {internal type, description} for compatibility
        result.push_back({entry.second.first, entry.second.second});
    }
    return result;
}

// VST Plugin Support
void ImGuiNodeEditorComponent::addPluginModules()
{
    if (synth == nullptr)
        return;
    
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    auto& formatManager = app.getPluginFormatManager();
    
    // Set the plugin format manager and known plugin list on the synth if not already set
    synth->setPluginFormatManager(&formatManager);
    synth->setKnownPluginList(&knownPluginList);
    
    // Display each known plugin as a button
    const auto& plugins = knownPluginList.getTypes();
    
    if (plugins.isEmpty())
    {
        ImGui::TextDisabled("No plugins found.");
        ImGui::TextDisabled("Use 'Scan for Plugins...' in the File menu.");
        return;
    }
    
    for (const auto& desc : plugins)
    {
        juce::String buttonLabel = desc.name;
        if (desc.manufacturerName.isNotEmpty())
        {
            buttonLabel += " (" + desc.manufacturerName + ")";
        }
        
        if (ImGui::Selectable(buttonLabel.toRawUTF8()))
        {
            auto nodeId = synth->addVstModule(formatManager, desc);
            if (nodeId.uid != 0)
            {
                const ImVec2 mouse = ImGui::GetMousePos();
                const auto logicalId = synth->getLogicalIdForNode(nodeId);
                pendingNodeScreenPositions[(int)logicalId] = mouse;
                snapshotAfterEditor = true;
                juce::Logger::writeToLog("[VST] Added plugin: " + desc.name);
            }
            else
            {
                juce::Logger::writeToLog("[VST] ERROR: Failed to add plugin: " + desc.name);
            }
        }
        
        // Show tooltip with plugin info on hover
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("Name: %s", desc.name.toRawUTF8());
            ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
            ImGui::Text("Version: %s", desc.version.toRawUTF8());
            ImGui::Text("Format: %s", desc.pluginFormatName.toRawUTF8());
            ImGui::Text("Type: %s", desc.isInstrument ? "Instrument" : "Effect");
            ImGui::Text("Inputs: %d", desc.numInputChannels);
            ImGui::Text("Outputs: %d", desc.numOutputChannels);
            ImGui::EndTooltip();
        }
    }
}
void ImGuiNodeEditorComponent::handleCollapseToMetaModule()
{
    if (!synth)
        return;
    
    juce::Logger::writeToLog("[Meta Module] Starting collapse operation...");
    
    // 1. Get selected nodes
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected < 2)
    {
        juce::Logger::writeToLog("[Meta Module] ERROR: Need at least 2 nodes selected");
        return;
    }
    
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());
    
    // Convert to logical IDs
    std::set<juce::uint32> selectedLogicalIds;
    for (int nodeId : selectedNodeIds)
    {
        selectedLogicalIds.insert((juce::uint32)nodeId);
    }
    
    juce::Logger::writeToLog("[Meta Module] Selected " + juce::String(numSelected) + " nodes");
    
    // 2. Analyze boundary connections
    struct BoundaryConnection
    {
        juce::uint32 externalLogicalId;
        int externalChannel;
        juce::uint32 internalLogicalId;
        int internalChannel;
        bool isInput; // true = external -> internal, false = internal -> external
    };
    
    std::vector<BoundaryConnection> boundaries;
    auto allConnections = synth->getConnectionsInfo();
    
    for (const auto& conn : allConnections)
    {
        bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
        bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0 && !conn.dstIsOutput;
        bool dstIsOutput = conn.dstIsOutput;
        
        // Inlet: external -> selected
        if (!srcIsSelected && dstIsSelected)
        {
            BoundaryConnection bc;
            bc.externalLogicalId = conn.srcLogicalId;
            bc.externalChannel = conn.srcChan;
            bc.internalLogicalId = conn.dstLogicalId;
            bc.internalChannel = conn.dstChan;
            bc.isInput = true;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found inlet: " + juce::String(bc.externalLogicalId) + 
                                    " -> " + juce::String(bc.internalLogicalId));
        }
        // Outlet: selected -> external or output
        else if (srcIsSelected && (!dstIsSelected || dstIsOutput))
        {
            BoundaryConnection bc;
            bc.externalLogicalId = dstIsOutput ? 0 : conn.dstLogicalId;
            bc.externalChannel = conn.dstChan;
            bc.internalLogicalId = conn.srcLogicalId;
            bc.internalChannel = conn.srcChan;
            bc.isInput = false;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found outlet: " + juce::String(bc.internalLogicalId) + 
                                    " -> " + (dstIsOutput ? "OUTPUT" : juce::String(bc.externalLogicalId)));
        }
    }
    
    // Count inlets and outlets
    int numInlets = 0;
    int numOutlets = 0;
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            numInlets++;
        else
            numOutlets++;
    }
    
    juce::Logger::writeToLog("[META] Boundary Detection: Found " + juce::String(numInlets) + " inlets and " + juce::String(numOutlets) + " outlets.");
    juce::Logger::writeToLog("[META] Found " + juce::String(boundaries.size()) + " boundary connections");
    
    if (boundaries.empty())
    {
        juce::Logger::writeToLog("[META] WARNING: No boundary connections - creating isolated meta module");
    }
    
    // 3. Create the internal graph state
    pushSnapshot(); // Make undoable
    
    // Save the state of selected nodes
    juce::MemoryBlock internalState;
    {
        // Create a temporary state containing only selected nodes
        juce::ValueTree internalRoot("ModularSynthPreset");
        internalRoot.setProperty("version", 1, nullptr);
        
        juce::ValueTree modsVT("modules");
        juce::ValueTree connsVT("connections");
        
        // Add selected modules
        std::map<juce::uint32, juce::uint32> oldToNewLogicalId;
        juce::uint32 newLogicalId = 1;
        
        for (juce::uint32 oldId : selectedLogicalIds)
        {
            oldToNewLogicalId[oldId] = newLogicalId++;
            
            auto* module = synth->getModuleForLogical(oldId);
            if (!module)
                continue;
            
            juce::String moduleType = synth->getModuleTypeForLogical(oldId);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)oldToNewLogicalId[oldId], nullptr);
            mv.setProperty("type", moduleType, nullptr);
            
            // Save parameters
            juce::ValueTree params = module->getAPVTS().copyState();
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(params, -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            // Save extra state
            if (auto extra = module->getExtraStateTree(); extra.isValid())
            {
                juce::ValueTree extraWrapper("extra");
                extraWrapper.addChild(extra, -1, nullptr);
                mv.addChild(extraWrapper, -1, nullptr);
            }
            
            modsVT.addChild(mv, -1, nullptr);
        }
        
        // Add inlet modules for each unique input
        std::map<std::pair<juce::uint32, int>, juce::uint32> inletMap; // (extId, extCh) -> inletLogicalId
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                auto key = std::make_pair(bc.externalLogicalId, bc.externalChannel);
                if (inletMap.find(key) == inletMap.end())
                {
                    juce::uint32 inletId = newLogicalId++;
                    inletMap[key] = inletId;
                    
                    juce::ValueTree mv("module");
                    mv.setProperty("logicalId", (int)inletId, nullptr);
                    mv.setProperty("type", "inlet", nullptr);
                    modsVT.addChild(mv, -1, nullptr);
                    
                    juce::Logger::writeToLog("[Meta Module] Created inlet node ID=" + juce::String(inletId));
                }
            }
        }
        
        // Add outlet modules for each unique output
        std::map<std::pair<juce::uint32, int>, juce::uint32> outletMap; // (intId, intCh) -> outletLogicalId
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                auto key = std::make_pair(bc.internalLogicalId, bc.internalChannel);
                if (outletMap.find(key) == outletMap.end())
                {
                    juce::uint32 outletId = newLogicalId++;
                    outletMap[key] = outletId;
                    
                    juce::ValueTree mv("module");
                    mv.setProperty("logicalId", (int)outletId, nullptr);
                    mv.setProperty("type", "outlet", nullptr);
                    modsVT.addChild(mv, -1, nullptr);
                    
                    juce::Logger::writeToLog("[Meta Module] Created outlet node ID=" + juce::String(outletId));
                }
            }
        }
        
        // Add internal connections (between selected nodes)
        for (const auto& conn : allConnections)
        {
            bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
            bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0;
            
            if (srcIsSelected && dstIsSelected)
            {
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[conn.srcLogicalId], nullptr);
                cv.setProperty("srcChan", conn.srcChan, nullptr);
                cv.setProperty("dstId", (int)oldToNewLogicalId[conn.dstLogicalId], nullptr);
                cv.setProperty("dstChan", conn.dstChan, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from inlets to internal nodes
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                auto key = std::make_pair(bc.externalLogicalId, bc.externalChannel);
                juce::uint32 inletId = inletMap[key];
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)inletId, nullptr);
                cv.setProperty("srcChan", 0, nullptr); // Inlets output on channel 0
                cv.setProperty("dstId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("dstChan", bc.internalChannel, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from internal nodes to outlets
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                auto key = std::make_pair(bc.internalLogicalId, bc.internalChannel);
                juce::uint32 outletId = outletMap[key];
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("srcChan", bc.internalChannel, nullptr);
                cv.setProperty("dstId", (int)outletId, nullptr);
                cv.setProperty("dstChan", 0, nullptr); // Outlets input on channel 0
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        internalRoot.addChild(modsVT, -1, nullptr);
        internalRoot.addChild(connsVT, -1, nullptr);
        
        // Serialize to memory block
        if (auto xml = internalRoot.createXml())
        {
            juce::MemoryOutputStream mos(internalState, false);
            xml->writeTo(mos);
            juce::Logger::writeToLog("[META] Generated state for sub-patch.");
        }
    }
    
    // 4. Calculate average position for the meta module
    ImVec2 avgPos(0.0f, 0.0f);
    int posCount = 0;
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos((int)logicalId);
        avgPos.x += pos.x;
        avgPos.y += pos.y;
        posCount++;
    }
    if (posCount > 0)
    {
        avgPos.x /= posCount;
        avgPos.y /= posCount;
    }
    
    // 5. Delete selected nodes
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        auto nodeId = synth->getNodeIdForLogical(logicalId);
        synth->removeModule(nodeId);
    }
    
    // 6. Create meta module
    auto metaNodeId = synth->addModule("meta module");
    auto metaLogicalId = synth->getLogicalIdForNode(metaNodeId);
    pendingNodePositions[(int)metaLogicalId] = avgPos;
    
    juce::Logger::writeToLog("[META] Created new MetaModule with logical ID: " + juce::String((int)metaLogicalId));
    
    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule)
    {
        // Load the internal state
        metaModule->setStateInformation(internalState.getData(), (int)internalState.getSize());
        juce::Logger::writeToLog("[META] Loaded internal state into meta module");
    }
    else
    {
        juce::Logger::writeToLog("[META] ERROR: Failed to create meta module");
        return;
    }
    
    // 7. Reconnect external connections
    // Note: This is a simplified implementation - in production, you'd need to map
    // inlet/outlet indices to meta module input/output channels properly
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
        {
            // Connect external source to meta module input
            auto extNodeId = synth->getNodeIdForLogical(bc.externalLogicalId);
            synth->connect(extNodeId, bc.externalChannel, metaNodeId, 0);
        }
        else if (bc.externalLogicalId != 0)
        {
            // Connect meta module output to external destination
            auto extNodeId = synth->getNodeIdForLogical(bc.externalLogicalId);
            synth->connect(metaNodeId, 0, extNodeId, bc.externalChannel);
        }
        else
        {
            // Connect meta module output to main output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(metaNodeId, 0, outputNodeId, bc.externalChannel);
        }
    }
    
    graphNeedsRebuild = true;
    synth->commitChanges();
    
    juce::Logger::writeToLog("[META] Reconnected external cables. Collapse complete!");
    NotificationManager::post(NotificationManager::Type::Info, "Collapsed to Meta Module");
}

void ImGuiNodeEditorComponent::loadPresetFromFile(const juce::File& file)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    // 1. Load the file content.
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);

    // 2. Set the synthesizer's state. This rebuilds the audio graph.
    synth->setStateInformation(mb.getData(), (int)mb.getSize());

    // 3. Parse the XML to find the UI state.
    juce::ValueTree uiState;
    if (auto xml = juce::XmlDocument::parse(mb.toString()))
    {
        auto vt = juce::ValueTree::fromXml(*xml);
        uiState = vt.getChildWithName("NodeEditorUI");
        if (uiState.isValid())
        {
            // 4. Apply the UI state (node positions, muted status, etc.).
            // This queues the changes to be applied on the next frame.
            applyUiValueTree(uiState);
        }
    }

    // 5. Create an undo snapshot for this action.
    Snapshot s;
    synth->getStateInformation(s.synthState);
    s.uiState = uiState.isValid() ? uiState : getUiValueTree();
    undoStack.push_back(std::move(s));
    redoStack.clear();

    // 5. Update the UI status trackers.
    isPatchDirty = false;
    currentPresetFile = file; // Store full file path
    
    // No notification here; the calling function will handle it.
}

void ImGuiNodeEditorComponent::mergePresetFromFile(const juce::File& file, ImVec2 dropPosition)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    auto xml = juce::XmlDocument::parse(file);
    if (xml == nullptr) return;

    juce::ValueTree preset = juce::ValueTree::fromXml(*xml);
    auto modulesVT = preset.getChildWithName("modules");
    auto connectionsVT = preset.getChildWithName("connections");
    auto uiVT = preset.getChildWithName("NodeEditorUI");

    if (!modulesVT.isValid()) return;

    pushSnapshot(); // Create an undo state before we start merging.

    // --- THIS IS THE NEW LOGIC ---
    // 1. Find the top-most Y coordinate of all existing nodes on the canvas.
    float topMostY = FLT_MAX;
    auto currentUiState = getUiValueTree();
    bool canvasHasNodes = false;
    for (int i = 0; i < currentUiState.getNumChildren(); ++i)
    {
        auto nodePosVT = currentUiState.getChild(i);
        if (nodePosVT.hasType("node"))
        {
            canvasHasNodes = true;
            float y = (float)nodePosVT.getProperty("y");
            if (y < topMostY)
            {
                topMostY = y;
            }
        }
    }
    // If the canvas is empty, use the drop position as the reference.
    if (!canvasHasNodes)
    {
        topMostY = dropPosition.y;
    }

    // 2. Find the bounding box of the nodes within the preset we are dropping.
    float presetMinX = FLT_MAX;
    float presetMaxY = -FLT_MAX;
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                float x = (float)nodePosVT.getProperty("x");
                float y = (float)nodePosVT.getProperty("y");
                if (x < presetMinX) presetMinX = x;
                if (y > presetMaxY) presetMaxY = y; // We need the lowest point (max Y) of the preset group.
            }
        }
    }
    
    // 3. Calculate the necessary offsets.
    const float verticalPadding = 100.0f;
    const float yOffset = topMostY - presetMaxY - verticalPadding;
    const float xOffset = dropPosition.x - presetMinX;
    // --- END OF NEW LOGIC ---

    // This map will track how we remap old IDs from the file to new, unique IDs on the canvas.
    std::map<juce::uint32, juce::uint32> oldIdToNewId;

    // First pass: create all the new modules from the preset.
    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleNode = modulesVT.getChild(i);
        if (moduleNode.hasType("module"))
        {
            juce::uint32 oldLogicalId = (juce::uint32)(int)moduleNode.getProperty("logicalId");
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Add the module without committing the graph changes yet.
            auto newNodeId = synth->addModule(type, false);
            juce::uint32 newLogicalId = synth->getLogicalIdForNode(newNodeId);

            oldIdToNewId[oldLogicalId] = newLogicalId; // Store the mapping

            // Restore the new module's parameters and extra state.
            if (auto* proc = synth->getModuleForLogical(newLogicalId))
            {
                auto paramsWrapper = moduleNode.getChildWithName("params");
                if (paramsWrapper.isValid()) proc->getAPVTS().replaceState(paramsWrapper.getChild(0));
                
                auto extraWrapper = moduleNode.getChildWithName("extra");
                if (extraWrapper.isValid()) proc->setExtraStateTree(extraWrapper.getChild(0));
            }
        }
    }

    // Second pass: recreate the internal connections between the new modules.
    if (connectionsVT.isValid())
    {
        for (int i = 0; i < connectionsVT.getNumChildren(); ++i)
        {
            auto connNode = connectionsVT.getChild(i);
            if (connNode.hasType("connection"))
            {
                juce::uint32 oldSrcId = (juce::uint32)(int)connNode.getProperty("srcId");
                int srcChan = (int)connNode.getProperty("srcChan");
                juce::uint32 oldDstId = (juce::uint32)(int)connNode.getProperty("dstId");
                int dstChan = (int)connNode.getProperty("dstChan");

                // Only connect if both source and destination are part of the preset we're merging.
                if (oldIdToNewId.count(oldSrcId) && oldIdToNewId.count(oldDstId))
                {
                    auto newSrcNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldSrcId]);
                    auto newDstNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldDstId]);
                    synth->connect(newSrcNodeId, srcChan, newDstNodeId, dstChan);
                }
            }
        }
    }
    
    // Third pass: Apply UI positions using our new calculated offsets.
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                juce::uint32 oldId = (juce::uint32)(int)nodePosVT.getProperty("id");
                if (oldIdToNewId.count(oldId)) // Check if it's one of our new nodes
                {
                    ImVec2 pos = ImVec2((float)nodePosVT.getProperty("x"), (float)nodePosVT.getProperty("y"));
                    
                    // Apply the smart offsets
                    ImVec2 newPos = ImVec2(pos.x + xOffset, pos.y + yOffset);
                    
                    pendingNodeScreenPositions[(int)oldIdToNewId[oldId]] = newPos;
                }
            }
        }
    }

    // Finally, commit all the changes to the audio graph at once.
    synth->commitChanges();
    isPatchDirty = true; // Mark the patch as edited.
    
    juce::Logger::writeToLog("[Preset] Successfully merged preset: " + file.getFullPathName() + 
                             " above existing nodes with offsets (" + juce::String(xOffset) + ", " + juce::String(yOffset) + ")");
    NotificationManager::post(NotificationManager::Type::Success, "Merged: " + file.getFileNameWithoutExtension());
}

================================================================================
FILE: juce\Source\app\MainApplication.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>

namespace juce { class ApplicationProperties; }

class MainApplication : public juce::JUCEApplication
{
public:
    const juce::String getApplicationName() override { return "Collider Audio Engine"; }
    const juce::String getApplicationVersion() override { return "0.1.0"; }
    bool moreThanOneInstanceAllowed() override { return true; }

    void initialise (const juce::String& commandLine) override;
    void shutdown() override;
    void systemRequestedQuit() override;
    void anotherInstanceStarted (const juce::String& commandLine) override;

    struct StartupPolicy
    {
        enum class Mode
        {
            Default,
            LastUsed,
            CustomSize,
            Maximized,
            Fullscreen
        };

        Mode mode = Mode::LastUsed;
        int width = 0;
        int height = 0;
        bool forcePolicy = false;
    };

private:
    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow (juce::String name,
                    juce::ApplicationProperties& props,
                    const StartupPolicy& policy);
        void closeButtonPressed() override;
        bool keyPressed (const juce::KeyPress& key) override;

    private:
        // Track a manual "maximized-like" state (covers work area) and last normal bounds
        bool isMaximizedLike = false;
        juce::Rectangle<int> lastNormalBounds;

        void applyMaximizeLike();
        void restoreFromMaximizeLike();
    };

    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::ApplicationProperties> appProperties;
    StartupPolicy m_startupPolicy;
};




================================================================================
FILE: juce\Source\app\MainApplication.cpp
================================================================================


#include "MainApplication.h"
#include "../ui/MainComponent.h"
#include <juce_data_structures/juce_data_structures.h>

void MainApplication::initialise (const juce::String& commandLine)
{
    // Install a file logger so logs are visible on disk
    auto logDir = juce::File::getCurrentWorkingDirectory().getChildFile ("juce").getChildFile ("logs");
    logDir.createDirectory();
    auto* fileLogger = juce::FileLogger::createDateStampedLogger (logDir.getFullPathName(), "engine", ".log", "[JUCE] Logger started");
    juce::Logger::setCurrentLogger (fileLogger);
    juce::Logger::writeToLog ("[JUCE] Log file: " + (fileLogger != nullptr ? fileLogger->getLogFile().getFullPathName() : juce::String("<none>")));

    // Initialize ApplicationProperties
    appProperties = std::make_unique<juce::ApplicationProperties>();
    juce::PropertiesFile::Options opts;
    opts.applicationName     = getApplicationName();
    opts.filenameSuffix      = ".settings";
    opts.osxLibrarySubFolder = "Application Support";
    opts.storageFormat       = juce::PropertiesFile::storeAsXML;

    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                .getChildFile(getApplicationName());
    appDataDir.createDirectory();
    opts.folderName = appDataDir.getFullPathName();
    appProperties->setStorageParameters (opts);

    // Parse command line for startup policy
    {
        juce::StringArray args;
        args.addTokens (commandLine, " ", "\"");
        args.removeEmptyStrings();
        m_startupPolicy.mode = StartupPolicy::Mode::LastUsed;

        for (int i = 0; i < args.size(); ++i)
        {
            if (args[i] == "--window" && i + 1 < args.size())
            {
                auto parts = juce::StringArray::fromTokens (args[++i], "x", "");
                if (parts.size() == 2)
                {
                    m_startupPolicy.mode = StartupPolicy::Mode::CustomSize;
                    m_startupPolicy.width = parts[0].getIntValue();
                    m_startupPolicy.height = parts[1].getIntValue();
                    m_startupPolicy.forcePolicy = true;
                }
            }
            else if (args[i] == "--preset" && i + 1 < args.size())
            {
                auto preset = args[++i].toLowerCase();
                if (preset == "small") { m_startupPolicy.mode = StartupPolicy::Mode::CustomSize; m_startupPolicy.width = 1280; m_startupPolicy.height = 800; }
                else if (preset == "medium") { m_startupPolicy.mode = StartupPolicy::Mode::CustomSize; m_startupPolicy.width = 1600; m_startupPolicy.height = 900; }
                else if (preset == "large") { m_startupPolicy.mode = StartupPolicy::Mode::CustomSize; m_startupPolicy.width = 1920; m_startupPolicy.height = 1080; }
                m_startupPolicy.forcePolicy = true;
            }
            else if (args[i] == "--maximized")
            {
                m_startupPolicy.mode = StartupPolicy::Mode::Maximized;
                m_startupPolicy.forcePolicy = true;
            }
            else if (args[i] == "--fullscreen")
            {
                m_startupPolicy.mode = StartupPolicy::Mode::Fullscreen;
                m_startupPolicy.forcePolicy = true;
            }
            else if (args[i] == "--ignore-last")
            {
                m_startupPolicy.forcePolicy = true;
                if (m_startupPolicy.mode == StartupPolicy::Mode::LastUsed)
                    m_startupPolicy.mode = StartupPolicy::Mode::Default;
            }
        }
    }

    // Create main window with properties and policy
    mainWindow = std::make_unique<MainWindow> (getApplicationName(), *appProperties, m_startupPolicy);
}

void MainApplication::shutdown()
{
    juce::Logger::writeToLog ("[JUCE] Shutting down");

    if (mainWindow != nullptr && appProperties != nullptr)
    {
        if (auto* props = appProperties->getUserSettings())
        {
            if (! mainWindow->isFullScreen())
            {
                props->setValue ("mainWindowState", mainWindow->getWindowStateAsString());
                appProperties->saveIfNeeded();
                juce::Logger::writeToLog ("[JUCE] Saved window state.");
            }
        }
    }

    juce::Logger::setCurrentLogger (nullptr);
    mainWindow.reset();
    appProperties.reset();
}

void MainApplication::systemRequestedQuit()
{
    quit();
}

void MainApplication::anotherInstanceStarted (const juce::String&)
{
}

MainApplication::MainWindow::MainWindow (juce::String name,
                                         juce::ApplicationProperties& props,
                                         const StartupPolicy& policy)
    : DocumentWindow (name,
                      juce::Desktop::getInstance().getDefaultLookAndFeel()
                        .findColour (juce::ResizableWindow::backgroundColourId),
                      DocumentWindow::allButtons)
{
    setUsingNativeTitleBar (true);
    setContentOwned (new MainComponent(), true);
    setResizable (true, true);
    setResizeLimits (900, 600, 8192, 8192);

    bool restored = false;
    if (policy.mode == StartupPolicy::Mode::LastUsed && ! policy.forcePolicy)
    {
        if (auto* userSettings = props.getUserSettings())
        {
            auto savedState = userSettings->getValue ("mainWindowState");
            if (savedState.isNotEmpty())
            {
                restored = restoreWindowStateFromString (savedState);
                juce::Logger::writeToLog ("[JUCE] Restored window state from settings.");
            }
        }
    }

    if (! restored)
    {
        juce::Logger::writeToLog ("[JUCE] No saved state found or policy forced. Applying startup policy.");
        switch (policy.mode)
        {
            case StartupPolicy::Mode::CustomSize:
                if (policy.width > 0 && policy.height > 0)
                    centreWithSize (policy.width, policy.height);
                else
                    centreWithSize (2600, 1800);
                break;
            case StartupPolicy::Mode::Maximized:
                centreWithSize (2600, 1800);
                break;
            case StartupPolicy::Mode::Fullscreen:
                centreWithSize (2600, 1800);
                break;
            case StartupPolicy::Mode::Default:
            case StartupPolicy::Mode::LastUsed:
            default:
                centreWithSize (2600, 1800);
                break;
        }
    }

    setVisible (true);

    if (! restored)
    {
        if (policy.mode == StartupPolicy::Mode::Maximized)
            applyMaximizeLike();
        else if (policy.mode == StartupPolicy::Mode::Fullscreen)
            setFullScreen (true);
    }

    auto& displays = juce::Desktop::getInstance().getDisplays();
    auto* display = displays.getDisplayForRect (getBounds());
    if (display == nullptr)
        display = displays.getPrimaryDisplay();
    if (display != nullptr)
        setBounds (getBounds().constrainedWithin (display->userArea));
}

void MainApplication::MainWindow::closeButtonPressed()
{
    juce::JUCEApplication::getInstance()->systemRequestedQuit();
}

bool MainApplication::MainWindow::keyPressed (const juce::KeyPress& key)
{
    // F11 toggles fullscreen
    if (key.getKeyCode() == juce::KeyPress::F11Key)
    {
        setFullScreen (! isFullScreen());
        return true;
    }

    // Alt+Enter toggles maximized-like state (avoid interfering when in fullscreen)
    if (key.getKeyCode() == juce::KeyPress::returnKey && key.getModifiers().isAltDown())
    {
        if (isFullScreen())
            setFullScreen (false);
        else if (! isMaximizedLike)
            applyMaximizeLike();
        else
            restoreFromMaximizeLike();
        return true;
    }

    return DocumentWindow::keyPressed (key);
}

void MainApplication::MainWindow::applyMaximizeLike()
{
    if (! isMaximizedLike)
    {
        lastNormalBounds = getBounds();
        auto& displays = juce::Desktop::getInstance().getDisplays();
        if (auto* display = displays.getDisplayForRect (getBounds()))
            setBounds (display->userArea);
        else if (auto* primary = displays.getPrimaryDisplay())
            setBounds (primary->userArea);
        isMaximizedLike = true;
    }
}

void MainApplication::MainWindow::restoreFromMaximizeLike()
{
    if (isMaximizedLike)
    {
        if (! lastNormalBounds.isEmpty())
            setBounds (lastNormalBounds);
        isMaximizedLike = false;
    }
}




================================================================================
FILE: guides\THEME_EDITOR_DESIGN.md
================================================================================


# üé® Theme Editor Design Document

**Version**: 1.0  
**Purpose**: Foundation and architecture for a visual theme editor that allows users to modify and save custom themes.

---

## üìã Overview

The Theme Editor will provide a comprehensive UI for modifying all themeable properties in real-time, with the ability to save custom themes to the `exe/themes/` directory.

---

## üèóÔ∏è Architecture

### 1. Core Components

#### **ThemeEditorComponent**
- **Type**: ImGui-based modal/dockable window
- **Location**: `juce/Source/preset_creator/theme/ThemeEditorComponent.h/cpp`
- **Responsibilities**:
  - Render the theme editor UI
  - Handle user input for all theme properties
  - Apply changes in real-time
  - Save/load custom themes

#### **ThemeManager Extensions**
- **New Methods**:
  - `getEditableTheme()` - Returns mutable reference to current theme
  - `setProperty()` - Set individual theme properties
  - `applyChanges()` - Apply pending changes to the UI
  - `resetToDefault()` - Reset current section to defaults
  - `saveCustomTheme(const juce::String& name)` - Save as new theme

---

## üé® UI Design

### Window Layout

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Theme Editor                                [√ó]         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [Apply] [Reset] [Save As...] [Close]                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇTab  ‚îÇ ‚îÇ Content Area (scrollable)                   ‚îÇ ‚îÇ
‚îÇ ‚îÇImGui‚îÇ ‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îÇStyle‚îÇ ‚îÇ ‚Ä¢ Padding: [8.0] [8.0]                     ‚îÇ ‚îÇ
‚îÇ ‚îÇ     ‚îÇ ‚îÇ ‚Ä¢ Rounding: [4.0]                           ‚îÇ ‚îÇ
‚îÇ ‚îÇ     ‚îÇ ‚îÇ ‚Ä¢ Border: [1.0]                             ‚îÇ ‚îÇ
‚îÇ ‚îÇText ‚îÇ ‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îÇ     ‚îÇ ‚îÇ Colors:                                     ‚îÇ ‚îÇ
‚îÇ ‚îÇImGui‚îÇ ‚îÇ [Color Picker] Text                        ‚îÇ ‚îÇ
‚îÇ ‚îÇColor‚îÇ ‚îÇ [Color Picker] TextDisabled                 ‚îÇ ‚îÇ
‚îÇ ‚îÇ     ‚îÇ ‚îÇ ...                                         ‚îÇ ‚îÇ
‚îÇ ‚îÇImNodes‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îÇLinks‚îÇ ‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îÇCanvas‚îÇ ‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îÇLayout‚îÇ ‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îÇModules‚îÇ                                             ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Tab Organization

1. **ImGui Style** - Padding, rounding, borders, spacing
2. **ImGui Colors** - All ImGuiCol_* colors (organized by category)
3. **Accent Color** - Global accent color
4. **Text Colors** - Section headers, warnings, errors, etc.
5. **Status Colors** - Edited, saved indicators
6. **Header Colors** - Recent, Samples, Presets, System (TriState)
7. **ImNodes** - Category colors, pin colors, node states
8. **Links** - Link colors, preview, labels
9. **Canvas** - Grid, scale, drop target
10. **Layout** - Sizes, padding, spacing
11. **Fonts** - Font sizes and paths
12. **Windows** - Alpha values, dimensions
13. **Modulation** - Frequency, timbre, amplitude, filter colors
14. **Meters** - Safe, warning, clipping colors
15. **Timeline** - Marker colors
16. **Modules** - Module-specific colors (Scope, VideoFX, StrokeSeq)

---

## üîß Implementation Plan

### Phase 1: Foundation (Current Task)
- [x] Create `ThemeEditorComponent` class structure
- [x] Add getter/setter methods to `ThemeManager`
- [x] Create basic window structure
- [x] Implement tab system

### Phase 2: Core Editors
- [ ] Color picker helpers (ImGui ColorEdit4)
- [ ] Float/drag editors for numeric values
- [ ] Vec2 editors for padding/spacing
- [ ] TriStateColor editor component

### Phase 3: Section Editors
- [ ] ImGui Style editor
- [ ] ImGui Colors editor (organized by category)
- [ ] Text/Status/Header editors
- [ ] ImNodes editor (category/pin color maps)
- [ ] Link/Canvas/Layout editors
- [ ] Module-specific editors

### Phase 4: Save/Load
- [ ] Save dialog (name input)
- [ ] Validation (prevent overwriting built-ins)
- [ ] Custom theme management
- [ ] Load custom themes in theme menu

### Phase 5: Polish
- [ ] Real-time preview
- [ ] Reset section to default
- [ ] Import/export
- [ ] Preset quick adjustments

---

## üìù API Design

### ThemeManager Extensions

```cpp
class ThemeManager {
public:
    // Get mutable reference for editing
    Theme& getEditableTheme();
    
    // Apply changes immediately
    void applyTheme();
    
    // Save current theme as custom theme
    bool saveCustomTheme(const juce::String& themeName);
    
    // Reset to default
    void resetToDefault();
    
    // Get list of custom themes
    juce::StringArray getCustomThemeNames();
};
```

### ThemeEditorComponent

```cpp
class ThemeEditorComponent {
public:
    void render();  // Main render function
    
private:
    void renderTabs();
    void renderImGuiStyleTab();
    void renderImGuiColorsTab();
    void renderAccentTab();
    void renderTextColorsTab();
    // ... other tab renderers
    
    // Helper components
    bool colorEdit4(const char* label, ImVec4& color);
    bool dragFloat(const char* label, float& value, ...);
    bool dragFloat2(const char* label, ImVec2& value, ...);
    bool triStateColorEdit(const char* label, TriStateColor& tsc);
    
    // State
    bool m_isOpen = false;
    Theme m_workingCopy;  // Working copy of theme
    bool m_hasChanges = false;
};
```

---

## üéØ Key Features

### Real-Time Preview
- Changes apply immediately to the UI
- No "Apply" button needed (optional confirmation)
- Visual feedback on all changes

### Organization
- Tabs for logical grouping
- Collapsible sections within tabs
- Search/filter (future enhancement)

### Save System
- Custom themes saved to `exe/themes/Custom_*.json`
- Built-in themes protected from overwrite
- Name validation (no spaces, special chars)
- Auto-save option (future)

### User Experience
- Clear labels and tooltips
- Color previews
- Reset to default per section
- Undo/redo (future enhancement)

---

## üìÅ File Structure

```
juce/Source/preset_creator/theme/
‚îú‚îÄ‚îÄ Theme.h                    (existing)
‚îú‚îÄ‚îÄ ThemeManager.h/cpp        (existing + extensions)
‚îú‚îÄ‚îÄ ThemeEditorComponent.h    (NEW)
‚îú‚îÄ‚îÄ ThemeEditorComponent.cpp  (NEW)
‚îî‚îÄ‚îÄ presets/
    ‚îú‚îÄ‚îÄ *.json                (existing presets)
    ‚îî‚îÄ‚îÄ Custom_*.json         (user-created themes)
```

---

## üîÑ Integration Points

1. **Menu Entry**: Add "Edit Current Theme..." to Settings ‚Üí Theme menu
2. **Window Management**: Use ImGui window flags for modal/docking
3. **Theme Manager**: Extend with editable access methods
4. **File System**: Custom themes saved alongside presets

---

## üöÄ Next Steps

1. Create `ThemeEditorComponent` class files
2. Add editable access methods to `ThemeManager`
3. Implement basic window structure with tabs
4. Add first complete tab (ImGui Style) as proof of concept
5. Extend to other tabs incrementally

---

## üí° Future Enhancements

- **Theme Presets**: Quick adjustment presets (darker, brighter, higher contrast)
- **Import/Export**: Share themes between users
- **Color Harmony**: Automatic color scheme generation
- **Preview Window**: Mini preview of node editor
- **Undo/Redo**: History of changes
- **Theme Marketplace**: Download community themes



================================================================================
FILE: juce\Source\preset_creator\theme\ThemeEditorComponent.cpp
================================================================================


#include "ThemeEditorComponent.h"
#include <juce_core/juce_core.h>
#include <imgui.h>
#include <juce_opengl/juce_opengl.h>
#if defined(_WIN32)
  #include <windows.h>
  #include <GL/gl.h>
#else
  #include <GL/gl.h>
#endif
#ifndef GL_RGBA
  #define GL_RGBA 0x1908
#endif
#ifndef GL_UNSIGNED_BYTE
  #define GL_UNSIGNED_BYTE 0x1401
#endif

ThemeEditorComponent::ThemeEditorComponent()
{
    // Initialize working copy with current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
}

void ThemeEditorComponent::open()
{
    m_isOpen = true;
    // Refresh working copy from current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_hasChanges = false;
    m_currentTab = 0;
    m_showSaveDialog = false;
    memset(m_saveThemeName, 0, sizeof(m_saveThemeName));
}

void ThemeEditorComponent::close()
{
    if (m_hasChanges)
    {
        // TODO: Ask for confirmation if there are unsaved changes
        // For now, just discard
    }
    m_isOpen = false;
    m_showSaveDialog = false;
}

void ThemeEditorComponent::render()
{
    if (!m_isOpen)
        return;

    // Window flags
    ImGuiWindowFlags flags = ImGuiWindowFlags_None;
    
    // Set window size and position
    ImGui::SetNextWindowSize(ImVec2(900, 700), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowPos(ImVec2(100, 100), ImGuiCond_FirstUseEver);

    if (ImGui::Begin("Theme Editor", &m_isOpen, flags))
    {
        // Toolbar
        if (ImGui::Button("Apply Changes"))
        {
            applyChanges();
        }
        ImGui::SameLine();
        if (ImGui::Button("Reset Tab"))
        {
            resetCurrentTab();
        }
        ImGui::SameLine();
        if (ImGui::Button("Save As..."))
        {
            m_showSaveDialog = true;
            strncpy(m_saveThemeName, "CustomTheme", sizeof(m_saveThemeName) - 1);
        }
        ImGui::SameLine();
        if (m_hasChanges)
        {
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "* Unsaved changes");
        }

        ImGui::Separator();

        // Tabs
        renderTabs();

        // Save dialog (modal)
        if (m_showSaveDialog)
        {
            renderSaveDialog();
        }

        // Eyedropper overlay if active
        renderPickerOverlay();
    }
    ImGui::End();

    // Close if window X clicked (m_isOpen was set to false by ImGui::Begin)
    if (!m_isOpen)
        close();
}

// ---- Eyedropper utilities ----
void ThemeEditorComponent::beginPickColor(ImU32* target)
{
    m_pickerActive = true;
    m_pickTargetU32 = target;
    m_pickTargetVec4 = nullptr;
}

void ThemeEditorComponent::beginPickColor(ImVec4* target)
{
    m_pickerActive = true;
    m_pickTargetU32 = nullptr;
    m_pickTargetVec4 = target;
}

bool ThemeEditorComponent::sampleScreenPixel(int, int, unsigned char outRGBA[4])
{
    // Disabled: pixel picking handled by ImGuiNodeEditorComponent.
    outRGBA[0]=outRGBA[1]=outRGBA[2]=0; outRGBA[3]=255;
    return false;
}

void ThemeEditorComponent::renderPickerOverlay()
{
    // Disabled: handled by node editor (we keep function for compatibility)
    juce::ignoreUnused(m_pickerActive);
}

void ThemeEditorComponent::renderTabs()
{
    if (ImGui::BeginTabBar("ThemeEditorTabs"))
    {
        // Tab buttons
        const char* tabNames[] = {
            "Style", "Colors", "Accent", "Text", "Status", "Headers",
            "ImNodes", "Links", "Canvas", "Layout", "Fonts", "Windows",
            "Modulation", "Meters", "Timeline", "Modules"
        };

        for (int i = 0; i < s_numTabs; ++i)
        {
            if (ImGui::BeginTabItem(tabNames[i]))
            {
                m_currentTab = i;
                
                // Render tab content
                switch (i)
                {
                    case 0: renderImGuiStyleTab(); break;
                    case 1: renderImGuiColorsTab(); break;
                    case 2: renderAccentTab(); break;
                    case 3: renderTextColorsTab(); break;
                    case 4: renderStatusColorsTab(); break;
                    case 5: renderHeaderColorsTab(); break;
                    case 6: renderImNodesTab(); break;
                    case 7: renderLinksTab(); break;
                    case 8: renderCanvasTab(); break;
                    case 9: renderLayoutTab(); break;
                    case 10: renderFontsTab(); break;
                    case 11: renderWindowsTab(); break;
                    case 12: renderModulationTab(); break;
                    case 13: renderMetersTab(); break;
                    case 14: renderTimelineTab(); break;
                    case 15: renderModulesTab(); break;
                }
                
                ImGui::EndTabItem();
            }
        }
        ImGui::EndTabBar();
    }
}

// Helper implementations
bool ThemeEditorComponent::colorEdit4(const char* label, ImVec4& color, ImGuiColorEditFlags flags)
{
    bool changed = ImGui::ColorEdit4(label, &color.x, flags | ImGuiColorEditFlags_NoSidePreview);
    ImGui::SameLine();
    ImGui::PushID(label);
    if (ImGui::SmallButton("Pick \xF0\x9F\x8E\xA8"))
    {
        if (m_startPicker)
        {
            m_startPicker([this, &color](ImU32 picked){ color = ImGui::ColorConvertU32ToFloat4(picked); m_hasChanges = true; });
        }
    }
    ImGui::SameLine();
    if (ImGui::SmallButton("From UI"))
        ImGui::OpenPopup("pick_ui");
    if (ImGui::BeginPopup("pick_ui"))
    {
        ImGuiStyle& st = ImGui::GetStyle();
        struct Entry { const char* name; ImGuiCol idx; } entries[] = {
            {"Text", ImGuiCol_Text}, {"WindowBg", ImGuiCol_WindowBg}, {"ChildBg", ImGuiCol_ChildBg},
            {"FrameBg", ImGuiCol_FrameBg}, {"FrameHovered", ImGuiCol_FrameBgHovered}, {"FrameActive", ImGuiCol_FrameBgActive},
            {"Button", ImGuiCol_Button}, {"ButtonHovered", ImGuiCol_ButtonHovered}, {"ButtonActive", ImGuiCol_ButtonActive},
            {"Header", ImGuiCol_Header}, {"HeaderHovered", ImGuiCol_HeaderHovered}, {"HeaderActive", ImGuiCol_HeaderActive},
            {"Separator", ImGuiCol_Separator}, {"Tab", ImGuiCol_Tab}, {"TabActive", ImGuiCol_TabActive}
        };
        for (const auto& e : entries)
        {
            ImGui::PushID((int)e.idx);
            if (ImGui::ColorButton("##sw", st.Colors[e.idx], ImGuiColorEditFlags_NoTooltip, ImVec2(20, 20)))
            {
                color = st.Colors[e.idx];
                m_hasChanges = true;
                ImGui::CloseCurrentPopup();
            }
            ImGui::SameLine();
            ImGui::TextUnformatted(e.name);
            ImGui::PopID();
        }
        ImGui::EndPopup();
    }
    ImGui::PopID();
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::colorEditU32(const char* label, ImU32& color, ImGuiColorEditFlags flags)
{
    ImVec4 col = ImGui::ColorConvertU32ToFloat4(color);
    bool changed = ImGui::ColorEdit4(label, &col.x, flags | ImGuiColorEditFlags_NoSidePreview);
    ImGui::SameLine();
    ImGui::PushID(label);
    if (ImGui::SmallButton("Pick \xF0\x9F\x8E\xA8"))
    {
        if (m_startPicker)
        {
            m_startPicker([this, &col, &color](ImU32 picked){ col = ImGui::ColorConvertU32ToFloat4(picked); color = picked; m_hasChanges = true; });
        }
    }
    ImGui::SameLine();
    if (ImGui::SmallButton("From UI"))
        ImGui::OpenPopup("pick_ui");
    if (ImGui::BeginPopup("pick_ui"))
    {
        ImGuiStyle& st = ImGui::GetStyle();
        struct Entry { const char* name; ImGuiCol idx; } entries[] = {
            {"Text", ImGuiCol_Text}, {"WindowBg", ImGuiCol_WindowBg}, {"ChildBg", ImGuiCol_ChildBg},
            {"FrameBg", ImGuiCol_FrameBg}, {"FrameHovered", ImGuiCol_FrameBgHovered}, {"FrameActive", ImGuiCol_FrameBgActive},
            {"Button", ImGuiCol_Button}, {"ButtonHovered", ImGuiCol_ButtonHovered}, {"ButtonActive", ImGuiCol_ButtonActive},
            {"Header", ImGuiCol_Header}, {"HeaderHovered", ImGuiCol_HeaderHovered}, {"HeaderActive", ImGuiCol_HeaderActive},
            {"Separator", ImGuiCol_Separator}, {"Tab", ImGuiCol_Tab}, {"TabActive", ImGuiCol_TabActive}
        };
        for (const auto& e : entries)
        {
            ImGui::PushID((int)e.idx);
            if (ImGui::ColorButton("##sw", st.Colors[e.idx], ImGuiColorEditFlags_NoTooltip, ImVec2(20, 20)))
            {
                col = st.Colors[e.idx];
                color = ImGui::ColorConvertFloat4ToU32(col);
                m_hasChanges = true;
                ImGui::CloseCurrentPopup();
            }
            ImGui::SameLine();
            ImGui::TextUnformatted(e.name);
            ImGui::PopID();
        }
        ImGui::EndPopup();
    }
    ImGui::PopID();
    if (changed)
        color = ImGui::ColorConvertFloat4ToU32(col);
    return changed;
}

bool ThemeEditorComponent::dragFloat(const char* label, float& value, float speed, float min, float max, const char* format)
{
    bool changed = ImGui::DragFloat(label, &value, speed, min, max, format);
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::dragFloat2(const char* label, ImVec2& value, float speed, float min, float max, const char* format)
{
    bool changed = ImGui::DragFloat2(label, &value.x, speed, min, max, format);
    if (changed)
        m_hasChanges = true;
    return changed;
}

bool ThemeEditorComponent::triStateColorEdit(const char* label, TriStateColor& tsc)
{
    bool changed = false;
    if (ImGui::TreeNode(label))
    {
        changed |= colorEditU32("Base", tsc.base);
        changed |= colorEditU32("Hovered", tsc.hovered);
        changed |= colorEditU32("Active", tsc.active);
        ImGui::TreePop();
    }
    return changed;
}

// Tab implementations (stubs for now)
void ThemeEditorComponent::renderImGuiStyleTab()
{
    ImGui::Text("ImGui Style Settings");
    ImGui::Separator();
    
    // Split into two columns: controls on left, preview on right
    ImGui::Columns(2, "StyleColumns", true);
    
    // Left column: Controls
    if (ImGui::CollapsingHeader("Padding & Spacing"))
    {
        dragFloat2("Window Padding", m_workingCopy.style.WindowPadding, 1.0f, 0.0f, 50.0f);
        dragFloat2("Frame Padding", m_workingCopy.style.FramePadding, 1.0f, 0.0f, 50.0f);
        dragFloat2("Item Spacing", m_workingCopy.style.ItemSpacing, 1.0f, 0.0f, 50.0f);
        dragFloat2("Item Inner Spacing", m_workingCopy.style.ItemInnerSpacing, 1.0f, 0.0f, 50.0f);
    }
    
    if (ImGui::CollapsingHeader("Rounding"))
    {
        dragFloat("Window Rounding", m_workingCopy.style.WindowRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Child Rounding", m_workingCopy.style.ChildRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Frame Rounding", m_workingCopy.style.FrameRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Popup Rounding", m_workingCopy.style.PopupRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Scrollbar Rounding", m_workingCopy.style.ScrollbarRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Grab Rounding", m_workingCopy.style.GrabRounding, 0.5f, 0.0f, 20.0f);
        dragFloat("Tab Rounding", m_workingCopy.style.TabRounding, 0.5f, 0.0f, 20.0f);
    }
    
    if (ImGui::CollapsingHeader("Borders"))
    {
        dragFloat("Window Border Size", m_workingCopy.style.WindowBorderSize, 0.1f, 0.0f, 5.0f);
        dragFloat("Frame Border Size", m_workingCopy.style.FrameBorderSize, 0.1f, 0.0f, 5.0f);
        dragFloat("Popup Border Size", m_workingCopy.style.PopupBorderSize, 0.1f, 0.0f, 5.0f);
    }
    
    ImGui::NextColumn();
    
    // Right column: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Apply working copy style temporarily for preview
    ImGuiStyle& style = ImGui::GetStyle();
    ImGuiStyle backup = style;
    
    style.WindowPadding = m_workingCopy.style.WindowPadding;
    style.FramePadding = m_workingCopy.style.FramePadding;
    style.ItemSpacing = m_workingCopy.style.ItemSpacing;
    style.ItemInnerSpacing = m_workingCopy.style.ItemInnerSpacing;
    style.WindowRounding = m_workingCopy.style.WindowRounding;
    style.ChildRounding = m_workingCopy.style.ChildRounding;
    style.FrameRounding = m_workingCopy.style.FrameRounding;
    style.PopupRounding = m_workingCopy.style.PopupRounding;
    style.ScrollbarRounding = m_workingCopy.style.ScrollbarRounding;
    style.GrabRounding = m_workingCopy.style.GrabRounding;
    style.TabRounding = m_workingCopy.style.TabRounding;
    style.WindowBorderSize = m_workingCopy.style.WindowBorderSize;
    style.FrameBorderSize = m_workingCopy.style.FrameBorderSize;
    style.PopupBorderSize = m_workingCopy.style.PopupBorderSize;
    
    // Preview window
    if (ImGui::BeginChild("StylePreview", ImVec2(0, 0), true))
    {
        ImGui::Text("Preview Window");
        ImGui::Separator();
        
        // Button preview
        if (ImGui::Button("Sample Button"))
        {
            // Button clicked
        }
        ImGui::SameLine();
        if (ImGui::Button("Another Button"))
        {
            // Button clicked
        }
        
        ImGui::Spacing();
        
        // Frame preview
        ImGui::Text("Frame with border:");
        ImGui::BeginChildFrame(ImGui::GetID("preview_frame"), ImVec2(0, 60));
        ImGui::Text("Content inside frame");
        ImGui::Button("Button in Frame");
        ImGui::EndChildFrame();
        
        ImGui::Spacing();
        
        // Tab preview
        if (ImGui::BeginTabBar("PreviewTabs"))
        {
            if (ImGui::BeginTabItem("Tab 1"))
            {
                ImGui::Text("Tab 1 content");
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Tab 2"))
            {
                ImGui::Text("Tab 2 content");
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }
        
        ImGui::Spacing();
        
        // Slider preview
        static float sliderValue = 0.5f;
        ImGui::SliderFloat("Preview Slider", &sliderValue, 0.0f, 1.0f);
        
        ImGui::Spacing();
        
        // Checkbox preview
        static bool check1 = true, check2 = false;
        ImGui::Checkbox("Checkbox 1", &check1);
        ImGui::Checkbox("Checkbox 2", &check2);
        
        ImGui::Spacing();
        
        // Input preview
        static char text[64] = "Sample text";
        ImGui::InputText("Text Input", text, sizeof(text));
    }
    ImGui::EndChild();
    
    // Restore original style
    style = backup;
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderImGuiColorsTab()
{
    ImGui::Text("ImGui Colors");
    ImGui::Separator();
    ImGui::TextWrapped("Edit core ImGui colors. These affect all ImGui windows and widgets.");
    
    ImGui::Columns(2, "ImGuiColorsColumns", true);
    
    // Left: Controls organized by category
    if (ImGui::CollapsingHeader("Window Colors"))
    {
        ImVec4& windowBg = m_workingCopy.style.Colors[ImGuiCol_WindowBg];
        ImVec4& childBg = m_workingCopy.style.Colors[ImGuiCol_ChildBg];
        ImVec4& popupBg = m_workingCopy.style.Colors[ImGuiCol_PopupBg];
        ImVec4& titleBg = m_workingCopy.style.Colors[ImGuiCol_TitleBg];
        ImVec4& titleBgActive = m_workingCopy.style.Colors[ImGuiCol_TitleBgActive];
        ImVec4& titleBgCollapsed = m_workingCopy.style.Colors[ImGuiCol_TitleBgCollapsed];
        
        colorEdit4("Window Background", windowBg);
        colorEdit4("Child Background", childBg);
        colorEdit4("Popup Background", popupBg);
        colorEdit4("Title Background", titleBg);
        colorEdit4("Title Active", titleBgActive);
        colorEdit4("Title Collapsed", titleBgCollapsed);
    }
    
    if (ImGui::CollapsingHeader("Text Colors"))
    {
        ImVec4& text = m_workingCopy.style.Colors[ImGuiCol_Text];
        ImVec4& textDisabled = m_workingCopy.style.Colors[ImGuiCol_TextDisabled];
        ImVec4& textSelectedBg = m_workingCopy.style.Colors[ImGuiCol_TextSelectedBg];
        
        colorEdit4("Text", text);
        colorEdit4("Text Disabled", textDisabled);
        colorEdit4("Text Selected Background", textSelectedBg);
    }
    
    if (ImGui::CollapsingHeader("Button & Frame Colors"))
    {
        ImVec4& button = m_workingCopy.style.Colors[ImGuiCol_Button];
        ImVec4& buttonHovered = m_workingCopy.style.Colors[ImGuiCol_ButtonHovered];
        ImVec4& buttonActive = m_workingCopy.style.Colors[ImGuiCol_ButtonActive];
        ImVec4& frameBg = m_workingCopy.style.Colors[ImGuiCol_FrameBg];
        ImVec4& frameBgHovered = m_workingCopy.style.Colors[ImGuiCol_FrameBgHovered];
        ImVec4& frameBgActive = m_workingCopy.style.Colors[ImGuiCol_FrameBgActive];
        
        colorEdit4("Button", button);
        colorEdit4("Button Hovered", buttonHovered);
        colorEdit4("Button Active", buttonActive);
        colorEdit4("Frame Background", frameBg);
        colorEdit4("Frame Hovered", frameBgHovered);
        colorEdit4("Frame Active", frameBgActive);
    }
    
    if (ImGui::CollapsingHeader("Slider & Scrollbar"))
    {
        ImVec4& sliderGrab = m_workingCopy.style.Colors[ImGuiCol_SliderGrab];
        ImVec4& sliderGrabActive = m_workingCopy.style.Colors[ImGuiCol_SliderGrabActive];
        ImVec4& scrollbarBg = m_workingCopy.style.Colors[ImGuiCol_ScrollbarBg];
        ImVec4& scrollbarGrab = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrab];
        ImVec4& scrollbarGrabHovered = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrabHovered];
        ImVec4& scrollbarGrabActive = m_workingCopy.style.Colors[ImGuiCol_ScrollbarGrabActive];
        
        colorEdit4("Slider Grab", sliderGrab);
        colorEdit4("Slider Grab Active", sliderGrabActive);
        colorEdit4("Scrollbar Background", scrollbarBg);
        colorEdit4("Scrollbar Grab", scrollbarGrab);
        colorEdit4("Scrollbar Grab Hovered", scrollbarGrabHovered);
        colorEdit4("Scrollbar Grab Active", scrollbarGrabActive);
    }
    
    if (ImGui::CollapsingHeader("Border & Separator"))
    {
        ImVec4& border = m_workingCopy.style.Colors[ImGuiCol_Border];
        ImVec4& borderShadow = m_workingCopy.style.Colors[ImGuiCol_BorderShadow];
        ImVec4& separator = m_workingCopy.style.Colors[ImGuiCol_Separator];
        ImVec4& separatorHovered = m_workingCopy.style.Colors[ImGuiCol_SeparatorHovered];
        ImVec4& separatorActive = m_workingCopy.style.Colors[ImGuiCol_SeparatorActive];
        
        colorEdit4("Border", border);
        colorEdit4("Border Shadow", borderShadow);
        colorEdit4("Separator", separator);
        colorEdit4("Separator Hovered", separatorHovered);
        colorEdit4("Separator Active", separatorActive);
    }
    
    if (ImGui::CollapsingHeader("Tab & Menu"))
    {
        ImVec4& tab = m_workingCopy.style.Colors[ImGuiCol_Tab];
        ImVec4& tabHovered = m_workingCopy.style.Colors[ImGuiCol_TabHovered];
        ImVec4& tabActive = m_workingCopy.style.Colors[ImGuiCol_TabActive];
        ImVec4& tabUnfocused = m_workingCopy.style.Colors[ImGuiCol_TabUnfocused];
        ImVec4& tabUnfocusedActive = m_workingCopy.style.Colors[ImGuiCol_TabUnfocusedActive];
        ImVec4& menuBarBg = m_workingCopy.style.Colors[ImGuiCol_MenuBarBg];
        
        colorEdit4("Tab", tab);
        colorEdit4("Tab Hovered", tabHovered);
        colorEdit4("Tab Active", tabActive);
        colorEdit4("Tab Unfocused", tabUnfocused);
        colorEdit4("Tab Unfocused Active", tabUnfocusedActive);
        colorEdit4("Menu Bar Background", menuBarBg);
    }
    
    if (ImGui::CollapsingHeader("Other"))
    {
        ImVec4& checkMark = m_workingCopy.style.Colors[ImGuiCol_CheckMark];
        ImVec4& dragDropTarget = m_workingCopy.style.Colors[ImGuiCol_DragDropTarget];
        ImVec4& header = m_workingCopy.style.Colors[ImGuiCol_Header];
        ImVec4& headerHovered = m_workingCopy.style.Colors[ImGuiCol_HeaderHovered];
        ImVec4& headerActive = m_workingCopy.style.Colors[ImGuiCol_HeaderActive];
        ImVec4& resizeGrip = m_workingCopy.style.Colors[ImGuiCol_ResizeGrip];
        ImVec4& resizeGripHovered = m_workingCopy.style.Colors[ImGuiCol_ResizeGripHovered];
        ImVec4& resizeGripActive = m_workingCopy.style.Colors[ImGuiCol_ResizeGripActive];
        
        colorEdit4("Check Mark", checkMark);
        colorEdit4("Drag Drop Target", dragDropTarget);
        colorEdit4("Header", header);
        colorEdit4("Header Hovered", headerHovered);
        colorEdit4("Header Active", headerActive);
        colorEdit4("Resize Grip", resizeGrip);
        colorEdit4("Resize Grip Hovered", resizeGripHovered);
        colorEdit4("Resize Grip Active", resizeGripActive);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Apply working copy colors temporarily for preview
    ImGuiStyle& style = ImGui::GetStyle();
    ImGuiStyle backup = style;
    style = m_workingCopy.style;
    
    if (ImGui::BeginChild("ImGuiColorsPreview", ImVec2(0, 0), true))
    {
        // Window preview
        ImGui::Text("Window Preview");
        ImGui::Separator();
        
        if (ImGui::Button("Sample Button"))
        {
            // Button clicked
        }
        ImGui::SameLine();
        if (ImGui::Button("Another Button"))
        {
            // Button clicked
        }
        
        ImGui::Spacing();
        
        // Frame preview
        ImGui::Text("Frame with border:");
        ImGui::BeginChildFrame(ImGui::GetID("preview_frame2"), ImVec2(0, 60));
        ImGui::Text("Content inside frame");
        ImGui::Button("Button in Frame");
        ImGui::EndChildFrame();
        
        ImGui::Spacing();
        
        // Slider preview
        static float sliderValue = 0.5f;
        ImGui::SliderFloat("Preview Slider", &sliderValue, 0.0f, 1.0f);
        
        ImGui::Spacing();
        
        // Checkbox preview
        static bool check1 = true, check2 = false;
        ImGui::Checkbox("Checkbox 1", &check1);
        ImGui::Checkbox("Checkbox 2", &check2);
        
        ImGui::Spacing();
        
        // Input preview
        static char text[64] = "Sample text";
        ImGui::InputText("Text Input", text, sizeof(text));
        
        ImGui::Spacing();
        
        // Tab preview
        if (ImGui::BeginTabBar("PreviewTabs2"))
        {
            if (ImGui::BeginTabItem("Tab 1"))
            {
                ImGui::Text("Tab 1 content");
                ImGui::EndTabItem();
            }
            if (ImGui::BeginTabItem("Tab 2"))
            {
                ImGui::Text("Tab 2 content");
                ImGui::EndTabItem();
            }
            ImGui::EndTabBar();
        }
    }
    ImGui::EndChild();
    
    // Restore original style
    style = backup;
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderAccentTab()
{
    ImGui::Text("Accent Color");
    ImGui::Separator();
    ImGui::TextWrapped("The accent color is used throughout the UI for highlights and interactive elements.");
    
    ImGui::Columns(2, "AccentColumns", true);
    
    // Left: Color picker
    colorEdit4("Accent", m_workingCopy.accent);
    
    ImGui::Spacing();
    ImGui::Text("RGB Values:");
    ImGui::Text("R: %.3f", m_workingCopy.accent.x);
    ImGui::Text("G: %.3f", m_workingCopy.accent.y);
    ImGui::Text("B: %.3f", m_workingCopy.accent.z);
    ImGui::Text("A: %.3f", m_workingCopy.accent.w);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Large color swatch
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.accent));
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + ImGui::GetStyle().ItemSpacing.y));
    
    ImGui::Spacing();
    
    // Preview accent in UI elements
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_CheckMark, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_SliderGrabActive, m_workingCopy.accent);
    ImGui::PushStyleColor(ImGuiCol_TabHovered, ImVec4(m_workingCopy.accent.x, m_workingCopy.accent.y, m_workingCopy.accent.z, 0.8f));
    
    if (ImGui::Button("Button (hovered color)"))
    {
        // Button clicked
    }
    
    static bool previewCheck = true;
    ImGui::Checkbox("Checkbox (checkmark color)", &previewCheck);
    
    static float previewSlider = 0.5f;
    ImGui::SliderFloat("Slider (grab color)", &previewSlider, 0.0f, 1.0f);
    
    if (ImGui::BeginTabBar("AccentTabs"))
    {
        if (ImGui::BeginTabItem("Tab (hover)"))
        {
            ImGui::Text("Tab content");
            ImGui::EndTabItem();
        }
        ImGui::EndTabBar();
    }
    
    ImGui::PopStyleColor(4);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderTextColorsTab()
{
    ImGui::Text("Text Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "TextColorsColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Text Colors"))
    {
        colorEdit4("Section Header", m_workingCopy.text.section_header);
        colorEdit4("Warning", m_workingCopy.text.warning);
        colorEdit4("Success", m_workingCopy.text.success);
        colorEdit4("Error", m_workingCopy.text.error);
        colorEdit4("Disabled", m_workingCopy.text.disabled);
        colorEdit4("Active", m_workingCopy.text.active);
    }
    
    if (ImGui::CollapsingHeader("Tooltip Settings"))
    {
        dragFloat("Tooltip Wrap (Standard)", m_workingCopy.text.tooltip_wrap_standard, 1.0f, 10.0f, 100.0f);
        dragFloat("Tooltip Wrap (Compact)", m_workingCopy.text.tooltip_wrap_compact, 1.0f, 10.0f, 100.0f);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImGui::TextColored(m_workingCopy.text.section_header, "Section Header Text");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.warning, "‚ö† Warning Message");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.success, "‚úì Success Message");
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.error, "‚úó Error Message");
    ImGui::Spacing();
    
    ImGui::PushStyleColor(ImGuiCol_Text, m_workingCopy.text.disabled);
    ImGui::Text("Disabled Text (grayed out)");
    ImGui::PopStyleColor();
    ImGui::Spacing();
    
    ImGui::TextColored(m_workingCopy.text.active, "‚óè Active/Enabled Text");
    ImGui::Spacing();
    
    ImGui::Separator();
    ImGui::Text("Tooltip Preview:");
    ImGui::TextDisabled("(Hover over this text)");
    if (ImGui::IsItemHovered())
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * m_workingCopy.text.tooltip_wrap_standard);
        ImGui::Text("This is a tooltip with the wrap width you set. It demonstrates how tooltips will wrap at the specified character count.");
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderStatusColorsTab()
{
    ImGui::Text("Status Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "StatusColumns", true);
    
    // Left: Controls
    colorEdit4("Edited", m_workingCopy.status.edited);
    colorEdit4("Saved", m_workingCopy.status.saved);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImGui::Text("Status: ");
    ImGui::SameLine();
    ImGui::TextColored(m_workingCopy.status.edited, "EDITED");
    
    ImGui::Spacing();
    
    ImGui::Text("Status: ");
    ImGui::SameLine();
    ImGui::TextColored(m_workingCopy.status.saved, "SAVED");
    
    ImGui::Spacing();
    ImGui::Separator();
    
    // Preview as overlay-style status indicator
    ImGui::BeginChild("StatusPreview", ImVec2(0, 80), true);
    ImGui::SetCursorPos(ImVec2(10, 10));
    ImGui::TextColored(m_workingCopy.status.edited, "Status: EDITED");
    
    ImGui::SetCursorPos(ImVec2(10, 40));
    ImGui::TextColored(m_workingCopy.status.saved, "Status: SAVED");
    ImGui::EndChild();
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderHeaderColorsTab()
{
    ImGui::Text("Header Colors (TriState)");
    ImGui::Separator();
    
    ImGui::Columns(2, "HeaderColumns", true);
    
    // Left: Controls
    triStateColorEdit("Recent", m_workingCopy.headers.recent);
    triStateColorEdit("Samples", m_workingCopy.headers.samples);
    triStateColorEdit("Presets", m_workingCopy.headers.presets);
    triStateColorEdit("System", m_workingCopy.headers.system);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    // Preview Recent header
    ImVec2 pos = ImGui::GetCursorScreenPos();
    ImVec2 size = ImVec2(ImGui::GetContentRegionAvail().x, 30);
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview Samples header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.samples.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Samples (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview Presets header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.presets.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Presets (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    // Preview System header
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.system.base);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("System (Base)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Text("Hover states:");
    
    // Hover preview
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.hovered);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Hovered)");
    ImGui::SetCursorScreenPos(ImVec2(pos.x, pos.y + size.y + 5));
    
    pos = ImGui::GetCursorScreenPos();
    drawList->AddRectFilled(pos, ImVec2(pos.x + size.x, pos.y + size.y), m_workingCopy.headers.recent.active);
    ImGui::SetCursorScreenPos(ImVec2(pos.x + 5, pos.y + 8));
    ImGui::Text("Recent (Active)");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderImNodesTab()
{
    ImGui::Text("ImNodes Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ImNodesColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Category Colors"))
    {
        // Module categories
        const char* categoryNames[] = {
            "Source", "Effect", "Modulator", "Utility", "Seq", "MIDI",
            "Analysis", "TTS_Voice", "Special_Exp", "OpenCV", "Sys", "Comment", "Plugin", "Default"
        };
        
        ModuleCategory categories[] = {
            ModuleCategory::Source, ModuleCategory::Effect, ModuleCategory::Modulator,
            ModuleCategory::Utility, ModuleCategory::Seq, ModuleCategory::MIDI,
            ModuleCategory::Analysis, ModuleCategory::TTS_Voice, ModuleCategory::Special_Exp,
            ModuleCategory::OpenCV, ModuleCategory::Sys, ModuleCategory::Comment,
            ModuleCategory::Plugin, ModuleCategory::Default
        };
        
        for (int i = 0; i < 14; ++i)
        {
            ImU32& color = m_workingCopy.imnodes.category_colors[categories[i]];
            if (colorEditU32(categoryNames[i], color))
            {
                m_hasChanges = true;
            }
        }
    }
    
    if (ImGui::CollapsingHeader("Pin Colors"))
    {
        // Pin data types
        const char* pinTypeNames[] = { "CV", "Audio", "Gate", "Raw", "Video" };
        PinDataType pinTypes[] = {
            PinDataType::CV, PinDataType::Audio, PinDataType::Gate,
            PinDataType::Raw, PinDataType::Video
        };
        
        for (int i = 0; i < 5; ++i)
        {
            ImU32& color = m_workingCopy.imnodes.pin_colors[pinTypes[i]];
            if (colorEditU32(pinTypeNames[i], color))
            {
                m_hasChanges = true;
            }
        }
        
        ImGui::Separator();
        colorEditU32("Pin Connected", m_workingCopy.imnodes.pin_connected);
        colorEditU32("Pin Disconnected", m_workingCopy.imnodes.pin_disconnected);
    }
    
    if (ImGui::CollapsingHeader("Node States"))
    {
        colorEditU32("Node Muted", m_workingCopy.imnodes.node_muted);
        dragFloat("Node Muted Alpha", m_workingCopy.imnodes.node_muted_alpha, 0.01f, 0.0f, 1.0f);
        colorEditU32("Node Hovered Link Highlight", m_workingCopy.imnodes.node_hovered_link_highlight);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 300);
    
    // Draw category color previews
    ImGui::Text("Category Colors:");
    float y = canvasPos.y + 20;
    float boxSize = 20.0f;
    float spacing = 5.0f;
    
    const char* categoryNames[] = {
        "Source", "Effect", "Modulator", "Utility", "Seq", "MIDI",
        "Analysis", "TTS_Voice", "Special_Exp", "OpenCV", "Sys", "Comment", "Plugin", "Default"
    };
    
    ModuleCategory categories[] = {
        ModuleCategory::Source, ModuleCategory::Effect, ModuleCategory::Modulator,
        ModuleCategory::Utility, ModuleCategory::Seq, ModuleCategory::MIDI,
        ModuleCategory::Analysis, ModuleCategory::TTS_Voice, ModuleCategory::Special_Exp,
        ModuleCategory::OpenCV, ModuleCategory::Sys, ModuleCategory::Comment,
        ModuleCategory::Plugin, ModuleCategory::Default
    };
    
    for (int i = 0; i < 14; ++i)
    {
        float x = canvasPos.x + (i % 7) * (boxSize + spacing + 60);
        float rowY = y + (i / 7) * (boxSize + spacing + 15);
        
        ImU32 color = m_workingCopy.imnodes.category_colors[categories[i]];
        drawList->AddRectFilled(ImVec2(x, rowY), ImVec2(x + boxSize, rowY + boxSize), color);
        drawList->AddRect(ImVec2(x, rowY), ImVec2(x + boxSize, rowY + boxSize), IM_COL32(100, 100, 100, 255));
        ImGui::SetCursorScreenPos(ImVec2(x + boxSize + 5, rowY));
        ImGui::Text("%s", categoryNames[i]);
    }
    
    y += 80;
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, y));
    ImGui::Text("Pin Colors:");
    y += 20;
    
    // Draw pin color previews
    const char* pinTypeNames[] = { "CV", "Audio", "Gate", "Raw", "Video" };
    PinDataType pinTypes[] = {
        PinDataType::CV, PinDataType::Audio, PinDataType::Gate,
        PinDataType::Raw, PinDataType::Video
    };
    
    for (int i = 0; i < 5; ++i)
    {
        float x = canvasPos.x + i * 80;
        ImU32 color = m_workingCopy.imnodes.pin_colors[pinTypes[i]];
        
        // Draw pin circle
        ImVec2 center = ImVec2(x + 15, y + 10);
        drawList->AddCircleFilled(center, 8.0f, color, 0);
        drawList->AddCircle(center, 8.0f, IM_COL32(100, 100, 100, 255), 0, 1.0f);
        
        ImGui::SetCursorScreenPos(ImVec2(x, y + 25));
        ImGui::Text("%s", pinTypeNames[i]);
    }
    
    y += 60;
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, y));
    
    // Node muted preview
    ImGui::Text("Node Muted Preview:");
    ImVec2 nodePos = ImVec2(canvasPos.x, y + 20);
    ImVec2 nodeSize = ImVec2(150, 60);
    ImU32 nodeColor = m_workingCopy.imnodes.node_muted;
    ImU32 nodeColorAlpha = IM_COL32(
        (int)((nodeColor & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        (int)(((nodeColor >> 8) & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        (int)(((nodeColor >> 16) & 0xFF) * m_workingCopy.imnodes.node_muted_alpha),
        255
    );
    drawList->AddRectFilled(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), nodeColorAlpha);
    drawList->AddRect(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), IM_COL32(100, 100, 100, 255));
    ImGui::SetCursorScreenPos(ImVec2(nodePos.x + 5, nodePos.y + 20));
    ImGui::Text("Muted Node");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderLinksTab()
{
    ImGui::Text("Link Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "LinksColumns", true);
    
    // Left: Controls
    colorEditU32("Link Hovered", m_workingCopy.links.link_hovered);
    colorEditU32("Link Selected", m_workingCopy.links.link_selected);
    colorEditU32("Link Highlighted", m_workingCopy.links.link_highlighted);
    colorEditU32("Preview Color", m_workingCopy.links.preview_color);
    dragFloat("Preview Width", m_workingCopy.links.preview_width, 0.1f, 1.0f, 10.0f);
    colorEditU32("Label Background", m_workingCopy.links.label_background);
    colorEditU32("Label Text", m_workingCopy.links.label_text);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    
    // Draw link previews
    float y = canvasPos.y;
    float x = canvasPos.x + 20;
    
    // Hovered link
    ImVec2 p1 = ImVec2(x, y + 20);
    ImVec2 p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_hovered, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Hovered Link");
    
    // Selected link
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_selected, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Selected Link");
    
    // Highlighted link
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.link_highlighted, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Highlighted Link");
    
    // Preview color
    y += 50;
    p1 = ImVec2(x, y + 20);
    p2 = ImVec2(x + 100, y + 40);
    drawList->AddBezierCubic(p1, ImVec2(p1.x + 30, p1.y), ImVec2(p2.x - 30, p2.y), p2, 
                            m_workingCopy.links.preview_color, m_workingCopy.links.preview_width);
    ImGui::SetCursorScreenPos(ImVec2(x, y));
    ImGui::Text("Preview Color");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    // Label preview
    ImGui::Text("Link Label Preview:");
    ImVec2 labelPos = ImGui::GetCursorScreenPos();
    ImVec2 labelSize = ImVec2(120, 30);
    drawList->AddRectFilled(labelPos, ImVec2(labelPos.x + labelSize.x, labelPos.y + labelSize.y), 
                           m_workingCopy.links.label_background);
    ImGui::SetCursorScreenPos(ImVec2(labelPos.x + 5, labelPos.y + 8));
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(m_workingCopy.links.label_text));
    ImGui::Text("Link Label");
    ImGui::PopStyleColor();
    ImGui::SetCursorScreenPos(ImVec2(labelPos.x, labelPos.y + labelSize.y + 5));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderCanvasTab()
{
    ImGui::Text("Canvas Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "CanvasColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("Canvas Background"))
    {
        colorEditU32("Canvas Background", m_workingCopy.canvas.canvas_background);
    }
    
    if (ImGui::CollapsingHeader("Grid Settings"))
    {
        colorEditU32("Grid Color", m_workingCopy.canvas.grid_color);
        colorEditU32("Grid Origin Color", m_workingCopy.canvas.grid_origin_color);
        dragFloat("Grid Size", m_workingCopy.canvas.grid_size, 1.0f, 10.0f, 200.0f);
        colorEditU32("Scale Text Color", m_workingCopy.canvas.scale_text_color);
        dragFloat("Scale Interval", m_workingCopy.canvas.scale_interval, 10.0f, 50.0f, 1000.0f);
    }
    
    if (ImGui::CollapsingHeader("Overlays & UI"))
    {
        colorEditU32("Drop Target Overlay", m_workingCopy.canvas.drop_target_overlay);
        colorEditU32("Mouse Position Text", m_workingCopy.canvas.mouse_position_text);
    }
    
    if (ImGui::CollapsingHeader("Node Styling"))
    {
        colorEditU32("Node Background", m_workingCopy.canvas.node_background);
        colorEditU32("Node Frame", m_workingCopy.canvas.node_frame);
        colorEditU32("Node Frame Hovered", m_workingCopy.canvas.node_frame_hovered);
        colorEditU32("Node Frame Selected", m_workingCopy.canvas.node_frame_selected);
        dragFloat("Node Rounding", m_workingCopy.canvas.node_rounding, 0.1f, 0.0f, 20.0f);
        dragFloat("Node Border Width", m_workingCopy.canvas.node_border_width, 0.1f, 0.0f, 10.0f);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 300);
    
    // Draw canvas background
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           m_workingCopy.canvas.canvas_background);
    
    // Draw grid preview
    float gridSize = m_workingCopy.canvas.grid_size;
    float scaleInterval = m_workingCopy.canvas.scale_interval;
    
    // Draw grid lines
    for (float x = canvasPos.x; x < canvasPos.x + canvasSize.x; x += gridSize)
    {
        drawList->AddLine(ImVec2(x, canvasPos.y), ImVec2(x, canvasPos.y + canvasSize.y), 
                         m_workingCopy.canvas.grid_color);
    }
    for (float y = canvasPos.y; y < canvasPos.y + canvasSize.y; y += gridSize)
    {
        drawList->AddLine(ImVec2(canvasPos.x, y), ImVec2(canvasPos.x + canvasSize.x, y), 
                         m_workingCopy.canvas.grid_color);
    }
    
    // Draw origin (center)
    ImVec2 center = ImVec2(canvasPos.x + canvasSize.x * 0.5f, canvasPos.y + canvasSize.y * 0.5f);
    drawList->AddCircle(center, 3.0f, m_workingCopy.canvas.grid_origin_color, 0, 2.0f);
    drawList->AddLine(ImVec2(center.x - 10, center.y), ImVec2(center.x + 10, center.y), 
                     m_workingCopy.canvas.grid_origin_color, 2.0f);
    drawList->AddLine(ImVec2(center.x, center.y - 10), ImVec2(center.x, center.y + 10), 
                     m_workingCopy.canvas.grid_origin_color, 2.0f);
    
    // Draw scale markers
    for (float x = canvasPos.x; x < canvasPos.x + canvasSize.x; x += scaleInterval)
    {
        ImVec2 textPos = ImVec2(x, canvasPos.y + 5);
        char label[32];
        snprintf(label, sizeof(label), "%.0f", (x - canvasPos.x));
        drawList->AddText(textPos, m_workingCopy.canvas.scale_text_color, label);
    }
    
    // Draw drop target overlay preview
    ImVec2 dropPos = ImVec2(canvasPos.x + canvasSize.x * 0.3f, canvasPos.y + canvasSize.y * 0.3f);
    ImVec2 dropSize = ImVec2(80, 60);
    drawList->AddRectFilled(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), 
                           m_workingCopy.canvas.drop_target_overlay);
    drawList->AddRect(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), 
                     m_workingCopy.canvas.drop_target_overlay, 0.0f, 0, 2.0f);
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    // Mouse position text preview
    ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertU32ToFloat4(m_workingCopy.canvas.mouse_position_text));
    ImGui::Text("Mouse: 1234, 567");
    ImGui::PopStyleColor();
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    // Node preview
    ImGui::Text("Node Preview");
    ImVec2 nodePreviewPos = ImGui::GetCursorScreenPos();
    ImVec2 nodeSize = ImVec2(150, 80);
    ImVec2 nodeMin = ImVec2(nodePreviewPos.x + 20, nodePreviewPos.y + 20);
    ImVec2 nodeMax = ImVec2(nodeMin.x + nodeSize.x, nodeMin.y + nodeSize.y);
    
    // Draw node background
    drawList->AddRectFilled(nodeMin, nodeMax, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    
    // Draw node frame (normal state)
    drawList->AddRect(nodeMin, nodeMax, m_workingCopy.canvas.node_frame, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    
    // Draw node title bar
    ImVec2 titleBarMin = nodeMin;
    ImVec2 titleBarMax = ImVec2(nodeMax.x, nodeMin.y + 25);
    drawList->AddRectFilled(titleBarMin, titleBarMax, m_workingCopy.canvas.node_frame, m_workingCopy.canvas.node_rounding);
    
    drawList->AddText(ImVec2(nodeMin.x + 8, nodeMin.y + 5), IM_COL32(255, 255, 255, 255), "Example Node");
    
    // Draw hovered state preview (second node)
    ImVec2 node2Min = ImVec2(nodePreviewPos.x + 200, nodePreviewPos.y + 20);
    ImVec2 node2Max = ImVec2(node2Min.x + nodeSize.x, node2Min.y + nodeSize.y);
    drawList->AddRectFilled(node2Min, node2Max, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    drawList->AddRect(node2Min, node2Max, m_workingCopy.canvas.node_frame_hovered, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    drawList->AddRectFilled(node2Min, ImVec2(node2Max.x, node2Min.y + 25), m_workingCopy.canvas.node_frame_hovered, m_workingCopy.canvas.node_rounding);
    drawList->AddText(ImVec2(node2Min.x + 8, node2Min.y + 5), IM_COL32(255, 255, 255, 255), "Hovered");
    
    // Draw selected state preview (third node)
    ImVec2 node3Min = ImVec2(nodePreviewPos.x + 380, nodePreviewPos.y + 20);
    ImVec2 node3Max = ImVec2(node3Min.x + nodeSize.x, node3Min.y + nodeSize.y);
    drawList->AddRectFilled(node3Min, node3Max, m_workingCopy.canvas.node_background, m_workingCopy.canvas.node_rounding);
    drawList->AddRect(node3Min, node3Max, m_workingCopy.canvas.node_frame_selected, m_workingCopy.canvas.node_rounding, 0, m_workingCopy.canvas.node_border_width);
    drawList->AddRectFilled(node3Min, ImVec2(node3Max.x, node3Min.y + 25), m_workingCopy.canvas.node_frame_selected, m_workingCopy.canvas.node_rounding);
    drawList->AddText(ImVec2(node3Min.x + 8, node3Min.y + 5), IM_COL32(255, 255, 255, 255), "Selected");
    
    ImGui::SetCursorScreenPos(ImVec2(nodePreviewPos.x, nodePreviewPos.y + nodeSize.y + 40));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderLayoutTab()
{
    ImGui::Text("Layout Settings");
    ImGui::Separator();
    
    ImGui::Columns(2, "LayoutColumns", true);
    
    // Left: Controls
    dragFloat("Sidebar Width", m_workingCopy.layout.sidebar_width, 1.0f, 100.0f, 500.0f);
    dragFloat("Window Padding", m_workingCopy.layout.window_padding, 1.0f, 0.0f, 50.0f);
    dragFloat("Node Vertical Padding", m_workingCopy.layout.node_vertical_padding, 1.0f, 0.0f, 200.0f);
    dragFloat("Preset Vertical Padding", m_workingCopy.layout.preset_vertical_padding, 1.0f, 0.0f, 300.0f);
    dragFloat("Node Default Width", m_workingCopy.layout.node_default_width, 1.0f, 100.0f, 1000.0f);
    dragFloat2("Node Default Padding", m_workingCopy.layout.node_default_padding, 1.0f, 0.0f, 50.0f);
    dragFloat2("Node Muted Padding", m_workingCopy.layout.node_muted_padding, 1.0f, 0.0f, 50.0f);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 250);
    
    // Draw sidebar
    float sidebarWidth = m_workingCopy.layout.sidebar_width;
    if (sidebarWidth > canvasSize.x * 0.4f) sidebarWidth = canvasSize.x * 0.4f; // Limit for preview
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + sidebarWidth, canvasPos.y + canvasSize.y), 
                           IM_COL32(40, 40, 40, 255));
    drawList->AddLine(ImVec2(canvasPos.x + sidebarWidth, canvasPos.y), 
                     ImVec2(canvasPos.x + sidebarWidth, canvasPos.y + canvasSize.y), 
                     IM_COL32(60, 60, 60, 255), 1.0f);
    
    // Draw main area with padding
    float padding = m_workingCopy.layout.window_padding;
    ImVec2 mainAreaStart = ImVec2(canvasPos.x + sidebarWidth + padding, canvasPos.y + padding);
    ImVec2 mainAreaSize = ImVec2(canvasSize.x - sidebarWidth - padding * 2, canvasSize.y - padding * 2);
    
    // Draw node preview
    float nodeWidth = m_workingCopy.layout.node_default_width;
    if (nodeWidth > mainAreaSize.x * 0.8f) nodeWidth = mainAreaSize.x * 0.8f;
    float nodeHeight = 60.0f;
    ImVec2 nodePos = ImVec2(mainAreaStart.x + m_workingCopy.layout.node_default_padding.x, 
                           mainAreaStart.y + m_workingCopy.layout.node_default_padding.y);
    ImVec2 nodeSize = ImVec2(nodeWidth, nodeHeight);
    
    drawList->AddRectFilled(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), 
                           IM_COL32(50, 50, 50, 255));
    drawList->AddRect(nodePos, ImVec2(nodePos.x + nodeSize.x, nodePos.y + nodeSize.y), 
                     IM_COL32(100, 100, 100, 255), 0.0f, 0, 1.0f);
    
    // Draw second node with vertical padding
    ImVec2 node2Pos = ImVec2(nodePos.x, 
                             nodePos.y + nodeHeight + m_workingCopy.layout.node_vertical_padding);
    drawList->AddRectFilled(node2Pos, ImVec2(node2Pos.x + nodeSize.x, node2Pos.y + nodeSize.y), 
                           IM_COL32(50, 50, 50, 255));
    drawList->AddRect(node2Pos, ImVec2(node2Pos.x + nodeSize.x, node2Pos.y + nodeSize.y), 
                     IM_COL32(100, 100, 100, 255), 0.0f, 0, 1.0f);
    
    // Labels
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x + 5, canvasPos.y + 5));
    ImGui::Text("Sidebar");
    
    ImGui::SetCursorScreenPos(ImVec2(nodePos.x + 5, nodePos.y + 5));
    ImGui::Text("Node");
    
    ImGui::SetCursorScreenPos(ImVec2(node2Pos.x + 5, node2Pos.y + 5));
    ImGui::Text("Node");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    ImGui::Text("Sidebar: %.0fpx | Node Width: %.0fpx | Padding: %.0fpx", 
                m_workingCopy.layout.sidebar_width, 
                m_workingCopy.layout.node_default_width,
                m_workingCopy.layout.window_padding);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderFontsTab()
{
    ImGui::Text("Font Settings");
    ImGui::Separator();
    ImGui::TextWrapped("Font settings are managed through the application's font loading system. "
                       "Currently, font paths are configured in the application initialization code.");
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    ImGui::Text("Font Size Settings:");
    dragFloat("Default Font Size", m_workingCopy.fonts.default_size, 0.5f, 8.0f, 72.0f);
    
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();
    
    ImGui::Text("Note:");
    ImGui::BulletText("Font file paths are configured in the application initialization.");
    ImGui::BulletText("To change fonts, modify the font loading code in ImGuiNodeEditorComponent.");
    ImGui::BulletText("Font size can be adjusted here and will affect text rendering.");
    
    ImGui::Spacing();
    
    // Preview font sizes
    ImGui::Text("Font Size Preview:");
    ImGui::BeginChild("FontPreview", ImVec2(0, 200), true);
    
    ImGui::Text("Default Font Size (%.1f):", m_workingCopy.fonts.default_size);
    ImGui::Text("The quick brown fox jumps over the lazy dog.");
    ImGui::Text("0123456789 !@#$%%^&*()");
    
    ImGui::EndChild();
}

void ThemeEditorComponent::renderWindowsTab()
{
    ImGui::Text("Window Settings");
    ImGui::Separator();
    
    ImGui::Columns(2, "WindowsColumns", true);
    
    // Left: Controls
    dragFloat("Status Overlay Alpha", m_workingCopy.windows.status_overlay_alpha, 0.01f, 0.0f, 1.0f);
    dragFloat("Probe Scope Alpha", m_workingCopy.windows.probe_scope_alpha, 0.01f, 0.0f, 1.0f);
    dragFloat("Preset Status Alpha", m_workingCopy.windows.preset_status_alpha, 0.01f, 0.0f, 1.0f);
    dragFloat("Notifications Alpha", m_workingCopy.windows.notifications_alpha, 0.01f, 0.0f, 1.0f);
    dragFloat("Probe Scope Width", m_workingCopy.windows.probe_scope_width, 1.0f, 100.0f, 500.0f);
    dragFloat("Probe Scope Height", m_workingCopy.windows.probe_scope_height, 1.0f, 50.0f, 500.0f);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 250);
    
    // Draw background
    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), 
                           IM_COL32(10, 10, 10, 255));
    
    // Status overlay preview
    ImVec2 statusPos = ImVec2(canvasPos.x + 10, canvasPos.y + 10);
    ImVec2 statusSize = ImVec2(150, 40);
    ImU32 statusColor = IM_COL32(255, 255, 255, (int)(m_workingCopy.windows.status_overlay_alpha * 255));
    drawList->AddRectFilled(statusPos, ImVec2(statusPos.x + statusSize.x, statusPos.y + statusSize.y), 
                           statusColor);
    drawList->AddRect(statusPos, ImVec2(statusPos.x + statusSize.x, statusPos.y + statusSize.y), 
                     IM_COL32(200, 200, 200, 255), 0.0f, 0, 1.0f);
    ImGui::SetCursorScreenPos(ImVec2(statusPos.x + 5, statusPos.y + 12));
    ImGui::Text("Status Overlay");
    ImGui::SetCursorScreenPos(ImVec2(statusPos.x, statusPos.y + statusSize.y + 5));
    
    // Probe scope preview
    float scopeWidth = m_workingCopy.windows.probe_scope_width;
    float scopeHeight = m_workingCopy.windows.probe_scope_height;
    if (scopeWidth > canvasSize.x * 0.8f) scopeWidth = canvasSize.x * 0.8f;
    if (scopeHeight > canvasSize.y * 0.5f) scopeHeight = canvasSize.y * 0.5f;
    
    ImVec2 scopePos = ImVec2(canvasPos.x + 10, ImGui::GetCursorScreenPos().y);
    ImVec2 scopeSize = ImVec2(scopeWidth, scopeHeight);
    ImU32 scopeColor = IM_COL32(0, 200, 255, (int)(m_workingCopy.windows.probe_scope_alpha * 255));
    drawList->AddRectFilled(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                           IM_COL32(20, 20, 20, 255));
    drawList->AddRect(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                     scopeColor, 0.0f, 0, 2.0f);
    
    // Draw scope waveform
    for (int i = 0; i < (int)scopeSize.x - 4; i += 2)
    {
        float x = scopePos.x + 2 + i;
        float y = scopePos.y + scopeSize.y * 0.5f + sinf(i * 0.1f) * scopeSize.y * 0.3f;
        drawList->AddLine(ImVec2(x, y), ImVec2(x + 2, y + sinf((i + 2) * 0.1f) * scopeSize.y * 0.3f), 
                         scopeColor, 1.5f);
    }
    
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + 5));
    ImGui::Text("Probe Scope");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y + 10));
    
    ImGui::Text("Scope: %.0fx%.0fpx | Alpha: %.2f", 
                m_workingCopy.windows.probe_scope_width,
                m_workingCopy.windows.probe_scope_height,
                m_workingCopy.windows.probe_scope_alpha);
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderModulationTab()
{
    ImGui::Text("Modulation Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ModulationColumns", true);
    
    // Left: Controls
    colorEdit4("Frequency", m_workingCopy.modulation.frequency);
    colorEdit4("Timbre", m_workingCopy.modulation.timbre);
    colorEdit4("Amplitude", m_workingCopy.modulation.amplitude);
    colorEdit4("Filter", m_workingCopy.modulation.filter);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 200);
    
    // Draw waveform previews for each modulation type
    float waveHeight = 30.0f;
    float ySpacing = 40.0f;
    
    // Frequency
    ImVec2 freqStart = ImVec2(canvasPos.x, canvasPos.y);
    ImGui::SetCursorScreenPos(freqStart);
    ImGui::Text("Frequency:");
    for (int i = 0; i < 50; ++i)
    {
        float x = freqStart.x + i * 5.0f;
        float y = freqStart.y + 20.0f + sinf(i * 0.2f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.frequency), 0);
    }
    
    // Timbre
    ImVec2 timbreStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing);
    ImGui::SetCursorScreenPos(timbreStart);
    ImGui::Text("Timbre:");
    for (int i = 0; i < 50; ++i)
    {
        float x = timbreStart.x + i * 5.0f;
        float y = timbreStart.y + 20.0f + sinf(i * 0.15f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.timbre), 0);
    }
    
    // Amplitude
    ImVec2 ampStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing * 2);
    ImGui::SetCursorScreenPos(ampStart);
    ImGui::Text("Amplitude:");
    for (int i = 0; i < 50; ++i)
    {
        float x = ampStart.x + i * 5.0f;
        float y = ampStart.y + 20.0f + sinf(i * 0.3f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.amplitude), 0);
    }
    
    // Filter
    ImVec2 filterStart = ImVec2(canvasPos.x, canvasPos.y + ySpacing * 3);
    ImGui::SetCursorScreenPos(filterStart);
    ImGui::Text("Filter:");
    for (int i = 0; i < 50; ++i)
    {
        float x = filterStart.x + i * 5.0f;
        float y = filterStart.y + 20.0f + sinf(i * 0.1f) * waveHeight * 0.5f;
        drawList->AddCircleFilled(ImVec2(x, y), 2.0f, 
                                  ImGui::ColorConvertFloat4ToU32(m_workingCopy.modulation.filter), 0);
    }
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderMetersTab()
{
    ImGui::Text("Meter Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "MetersColumns", true);
    
    // Left: Controls
    colorEdit4("Safe", m_workingCopy.meters.safe);
    colorEdit4("Warning", m_workingCopy.meters.warning);
    colorEdit4("Clipping", m_workingCopy.meters.clipping);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    
    // Draw meter bars
    float meterWidth = ImGui::GetContentRegionAvail().x;
    float meterHeight = 20.0f;
    float spacing = 5.0f;
    
    // Safe level meter
    ImVec2 safePos = canvasPos;
    float safeLevel = 0.6f; // 60% full
    drawList->AddRectFilled(safePos, ImVec2(safePos.x + meterWidth, safePos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(safePos, ImVec2(safePos.x + meterWidth * safeLevel, safePos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    ImGui::SetCursorScreenPos(ImVec2(safePos.x, safePos.y));
    ImGui::Text("Safe (60%):");
    ImGui::SetCursorScreenPos(ImVec2(safePos.x, safePos.y + meterHeight + spacing));
    
    // Warning level meter
    ImVec2 warnPos = ImGui::GetCursorScreenPos();
    float warnLevel = 0.85f; // 85% full
    drawList->AddRectFilled(warnPos, ImVec2(warnPos.x + meterWidth, warnPos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(warnPos, ImVec2(warnPos.x + meterWidth * 0.8f, warnPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    drawList->AddRectFilled(ImVec2(warnPos.x + meterWidth * 0.8f, warnPos.y), 
                           ImVec2(warnPos.x + meterWidth * warnLevel, warnPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.warning));
    ImGui::SetCursorScreenPos(ImVec2(warnPos.x, warnPos.y));
    ImGui::Text("Warning (85%):");
    ImGui::SetCursorScreenPos(ImVec2(warnPos.x, warnPos.y + meterHeight + spacing));
    
    // Clipping level meter
    ImVec2 clipPos = ImGui::GetCursorScreenPos();
    float clipLevel = 1.0f; // 100% full (clipping)
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + meterWidth, clipPos.y + meterHeight), 
                           IM_COL32(30, 30, 30, 255));
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + meterWidth * 0.8f, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.safe));
    drawList->AddRectFilled(ImVec2(clipPos.x + meterWidth * 0.8f, clipPos.y), 
                           ImVec2(clipPos.x + meterWidth * 0.95f, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.warning));
    drawList->AddRectFilled(ImVec2(clipPos.x + meterWidth * 0.95f, clipPos.y), 
                           ImVec2(clipPos.x + meterWidth * clipLevel, clipPos.y + meterHeight), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.meters.clipping));
    ImGui::SetCursorScreenPos(ImVec2(clipPos.x, clipPos.y));
    ImGui::Text("Clipping (100%):");
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderTimelineTab()
{
    ImGui::Text("Timeline Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "TimelineColumns", true);
    
    // Left: Controls
    colorEditU32("Marker Start/End", m_workingCopy.timeline.marker_start_end);
    colorEditU32("Marker Gate", m_workingCopy.timeline.marker_gate);
    colorEditU32("Marker Trigger", m_workingCopy.timeline.marker_trigger);
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    ImVec2 canvasSize = ImVec2(ImGui::GetContentRegionAvail().x, 150);
    
    // Draw timeline preview
    float timelineHeight = 40.0f;
    ImVec2 timelineStart = ImVec2(canvasPos.x, canvasPos.y + 20);
    
    // Draw timeline background
    drawList->AddRectFilled(timelineStart, 
                           ImVec2(timelineStart.x + canvasSize.x, timelineStart.y + timelineHeight), 
                           IM_COL32(20, 20, 20, 255));
    
    // Draw markers
    // Start marker
    ImVec2 startMarker = ImVec2(timelineStart.x + 20, timelineStart.y);
    drawList->AddLine(ImVec2(startMarker.x, startMarker.y), 
                     ImVec2(startMarker.x, startMarker.y + timelineHeight), 
                     m_workingCopy.timeline.marker_start_end, 3.0f);
    drawList->AddTriangleFilled(ImVec2(startMarker.x, startMarker.y), 
                                ImVec2(startMarker.x - 5, startMarker.y - 8), 
                                ImVec2(startMarker.x + 5, startMarker.y - 8), 
                                m_workingCopy.timeline.marker_start_end);
    ImGui::SetCursorScreenPos(ImVec2(startMarker.x - 10, startMarker.y - 20));
    ImGui::Text("Start");
    
    // End marker
    ImVec2 endMarker = ImVec2(timelineStart.x + canvasSize.x - 20, timelineStart.y);
    drawList->AddLine(ImVec2(endMarker.x, endMarker.y), 
                     ImVec2(endMarker.x, endMarker.y + timelineHeight), 
                     m_workingCopy.timeline.marker_start_end, 3.0f);
    drawList->AddTriangleFilled(ImVec2(endMarker.x, endMarker.y), 
                                ImVec2(endMarker.x - 5, endMarker.y - 8), 
                                ImVec2(endMarker.x + 5, endMarker.y - 8), 
                                m_workingCopy.timeline.marker_start_end);
    ImGui::SetCursorScreenPos(ImVec2(endMarker.x - 10, endMarker.y - 20));
    ImGui::Text("End");
    
    // Gate markers
    float gateY = timelineStart.y + timelineHeight * 0.3f;
    for (int i = 0; i < 3; ++i)
    {
        float x = timelineStart.x + 60 + i * 40;
        drawList->AddRectFilled(ImVec2(x, gateY), ImVec2(x + 20, gateY + 15), 
                               m_workingCopy.timeline.marker_gate);
    }
    ImGui::SetCursorScreenPos(ImVec2(timelineStart.x + 60, gateY - 15));
    ImGui::Text("Gates");
    
    // Trigger markers
    float triggerY = timelineStart.y + timelineHeight * 0.7f;
    for (int i = 0; i < 5; ++i)
    {
        float x = timelineStart.x + 80 + i * 25;
        drawList->AddLine(ImVec2(x, triggerY), ImVec2(x, triggerY + 10), 
                         m_workingCopy.timeline.marker_trigger, 2.0f);
    }
    ImGui::SetCursorScreenPos(ImVec2(timelineStart.x + 80, triggerY - 15));
    ImGui::Text("Triggers");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, canvasPos.y + canvasSize.y));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderModulesTab()
{
    ImGui::Text("Module-Specific Colors");
    ImGui::Separator();
    
    ImGui::Columns(2, "ModulesColumns", true);
    
    // Left: Controls
    if (ImGui::CollapsingHeader("VideoFX Module"))
    {
        colorEdit4("Section Header", m_workingCopy.modules.videofx_section_header);
        colorEdit4("Section Subheader", m_workingCopy.modules.videofx_section_subheader);
    }
    
    if (ImGui::CollapsingHeader("Scope Module"))
    {
        colorEdit4("Section Header", m_workingCopy.modules.scope_section_header);
        colorEditU32("Plot Background", m_workingCopy.modules.scope_plot_bg);
        colorEditU32("Plot Foreground", m_workingCopy.modules.scope_plot_fg);
        colorEditU32("Plot Max", m_workingCopy.modules.scope_plot_max);
        colorEditU32("Plot Min", m_workingCopy.modules.scope_plot_min);
        colorEdit4("Text Max", m_workingCopy.modules.scope_text_max);
        colorEdit4("Text Min", m_workingCopy.modules.scope_text_min);
    }
    
    if (ImGui::CollapsingHeader("Stroke Sequencer"))
    {
        colorEditU32("Border", m_workingCopy.modules.stroke_seq_border);
        colorEditU32("Canvas Background", m_workingCopy.modules.stroke_seq_canvas_bg);
        colorEditU32("Line Inactive", m_workingCopy.modules.stroke_seq_line_inactive);
        colorEditU32("Line Active", m_workingCopy.modules.stroke_seq_line_active);
        colorEditU32("Playhead", m_workingCopy.modules.stroke_seq_playhead);
        colorEditU32("Threshold Floor", m_workingCopy.modules.stroke_seq_thresh_floor);
        colorEditU32("Threshold Mid", m_workingCopy.modules.stroke_seq_thresh_mid);
        colorEditU32("Threshold Ceil", m_workingCopy.modules.stroke_seq_thresh_ceil);
        colorEdit4("Frame Background", m_workingCopy.modules.stroke_seq_frame_bg);
        colorEdit4("Frame Hovered", m_workingCopy.modules.stroke_seq_frame_bg_hovered);
        colorEdit4("Frame Active", m_workingCopy.modules.stroke_seq_frame_bg_active);
    }
    
    ImGui::NextColumn();
    
    // Right: Live Preview
    ImGui::Text("Live Preview");
    ImGui::Separator();
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    ImVec2 canvasPos = ImGui::GetCursorScreenPos();
    
    // VideoFX Preview
    ImGui::TextColored(m_workingCopy.modules.videofx_section_header, "VideoFX Section Header");
    ImGui::TextColored(m_workingCopy.modules.videofx_section_subheader, "VideoFX Section Subheader");
    ImGui::Spacing();
    
    // Scope Preview
    ImGui::TextColored(m_workingCopy.modules.scope_section_header, "Scope Section Header");
    ImVec2 scopePos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 10);
    ImVec2 scopeSize = ImVec2(200, 100);
    
    // Draw scope background
    drawList->AddRectFilled(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                           m_workingCopy.modules.scope_plot_bg);
    drawList->AddRect(scopePos, ImVec2(scopePos.x + scopeSize.x, scopePos.y + scopeSize.y), 
                     IM_COL32(100, 100, 100, 255));
    
    // Draw scope waveform
    for (int i = 0; i < (int)scopeSize.x - 4; i += 2)
    {
        float x = scopePos.x + 2 + i;
        float y = scopePos.y + scopeSize.y * 0.5f + sinf(i * 0.1f) * scopeSize.y * 0.3f;
        drawList->AddLine(ImVec2(x, y), ImVec2(x + 2, y + sinf((i + 2) * 0.1f) * scopeSize.y * 0.3f), 
                         m_workingCopy.modules.scope_plot_fg, 1.5f);
    }
    
    // Draw max/min markers
    drawList->AddLine(ImVec2(scopePos.x + 5, scopePos.y + 5), 
                     ImVec2(scopePos.x + scopeSize.x - 5, scopePos.y + 5), 
                     m_workingCopy.modules.scope_plot_max, 2.0f);
    drawList->AddLine(ImVec2(scopePos.x + 5, scopePos.y + scopeSize.y - 5), 
                     ImVec2(scopePos.x + scopeSize.x - 5, scopePos.y + scopeSize.y - 5), 
                     m_workingCopy.modules.scope_plot_min, 2.0f);
    
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + 5));
    ImGui::TextColored(m_workingCopy.modules.scope_text_max, "MAX");
    ImGui::SetCursorScreenPos(ImVec2(scopePos.x + 5, scopePos.y + scopeSize.y - 20));
    ImGui::TextColored(m_workingCopy.modules.scope_text_min, "MIN");
    
    ImGui::SetCursorScreenPos(ImVec2(canvasPos.x, scopePos.y + scopeSize.y + 20));
    ImGui::Spacing();
    
    // Stroke Sequencer Preview
    ImGui::Text("Stroke Sequencer Preview:");
    ImVec2 seqPos = ImVec2(canvasPos.x, ImGui::GetCursorScreenPos().y + 5);
    ImVec2 seqSize = ImVec2(250, 120);
    
    // Draw canvas background
    drawList->AddRectFilled(seqPos, ImVec2(seqPos.x + seqSize.x, seqPos.y + seqSize.y), 
                           m_workingCopy.modules.stroke_seq_canvas_bg);
    drawList->AddRect(seqPos, ImVec2(seqPos.x + seqSize.x, seqPos.y + seqSize.y), 
                     m_workingCopy.modules.stroke_seq_border, 0.0f, 0, 2.0f);
    
    // Draw lines
    float lineY = seqPos.y + 20;
    for (int i = 0; i < 5; ++i)
    {
        float x1 = seqPos.x + 10 + i * 20;
        float x2 = seqPos.x + 10 + (i + 1) * 20;
        ImU32 lineColor = (i == 2) ? m_workingCopy.modules.stroke_seq_line_active : 
                                     m_workingCopy.modules.stroke_seq_line_inactive;
        drawList->AddLine(ImVec2(x1, lineY + i * 15), ImVec2(x2, lineY + i * 15), lineColor, 2.0f);
    }
    
    // Draw playhead
    float playheadX = seqPos.x + 100;
    drawList->AddLine(ImVec2(playheadX, seqPos.y), ImVec2(playheadX, seqPos.y + seqSize.y), 
                     m_workingCopy.modules.stroke_seq_playhead, 2.0f);
    
    // Draw threshold markers
    float threshY1 = seqPos.y + seqSize.y * 0.3f;
    float threshY2 = seqPos.y + seqSize.y * 0.5f;
    float threshY3 = seqPos.y + seqSize.y * 0.7f;
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY1), ImVec2(seqPos.x + seqSize.x - 5, threshY1), 
                     m_workingCopy.modules.stroke_seq_thresh_floor, 1.0f);
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY2), ImVec2(seqPos.x + seqSize.x - 5, threshY2), 
                     m_workingCopy.modules.stroke_seq_thresh_mid, 1.0f);
    drawList->AddLine(ImVec2(seqPos.x + 5, threshY3), ImVec2(seqPos.x + seqSize.x - 5, threshY3), 
                     m_workingCopy.modules.stroke_seq_thresh_ceil, 1.0f);
    
    // Draw frame preview
    ImVec2 framePos = ImVec2(seqPos.x + seqSize.x - 60, seqPos.y + 10);
    ImVec2 frameSize = ImVec2(50, 30);
    drawList->AddRectFilled(framePos, ImVec2(framePos.x + frameSize.x, framePos.y + frameSize.y), 
                           ImGui::ColorConvertFloat4ToU32(m_workingCopy.modules.stroke_seq_frame_bg));
    drawList->AddRect(framePos, ImVec2(framePos.x + frameSize.x, framePos.y + frameSize.y), 
                     IM_COL32(100, 100, 100, 255));
    
    ImGui::Columns(1);
}

void ThemeEditorComponent::renderSaveDialog()
{
    ImGui::OpenPopup("Save Theme");
    if (ImGui::BeginPopupModal("Save Theme", nullptr, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("Enter theme name:");
        ImGui::InputText("##ThemeName", m_saveThemeName, sizeof(m_saveThemeName));
        
        ImGui::Separator();
        
        if (ImGui::Button("Save"))
        {
            saveTheme();
            m_showSaveDialog = false;
            ImGui::CloseCurrentPopup();
        }
        ImGui::SameLine();
        if (ImGui::Button("Cancel"))
        {
            m_showSaveDialog = false;
            ImGui::CloseCurrentPopup();
        }
        
        ImGui::EndPopup();
    }
}

void ThemeEditorComponent::saveTheme()
{
    juce::String themeName(m_saveThemeName);
    if (themeName.isEmpty())
    {
        return;
    }
    
    themeName = themeName.replaceCharacter(' ', '_');
    
    auto themeFile = juce::File::getSpecialLocation(juce::File::userDocumentsDirectory)
                        .getChildFile("Preset Creator Themes")
                        .getChildFile(themeName + ".json");
    themeFile.getParentDirectory().createDirectory();
    
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    ThemeManager::getInstance().saveTheme(themeFile);
    m_hasChanges = false;
}

void ThemeEditorComponent::resetCurrentTab()
{
    // TODO: Reset current tab to default values
    // For now, just reload from current theme
    m_workingCopy = ThemeManager::getInstance().getCurrentTheme();
    m_hasChanges = false;
}

void ThemeEditorComponent::applyChanges()
{
    // Apply working copy to ThemeManager
    ThemeManager::getInstance().getEditableTheme() = m_workingCopy;
    ThemeManager::getInstance().applyTheme();
    m_hasChanges = false;
    juce::Logger::writeToLog("[ThemeEditor] Applied theme changes");
    
    // Also save user preference if they want persistence
    // (Theme preference is saved when selecting from menu, not when editing)
}



================================================================================
FILE NOT FOUND: _deps\imnodes_fc-src\imnodes.cpp
================================================================================



================================================================================
FILE NOT FOUND: _deps\imnodes_fc-src\imnodes.h
================================================================================



================================================================================
FILE NOT FOUND: _deps\imnodes_fc-src\imnodes_internal.h
================================================================================



================================================================================
FILE NOT FOUND: ..\build\_deps\imnodes_fc-src\imnodes.cpp
================================================================================



================================================================================
FILE NOT FOUND: ..\build\_deps\imnodes_fc-src\imnodes.h
================================================================================



================================================================================
FILE NOT FOUND: ..\build\_deps\imnodes_fc-src\imnodes_internal.h
================================================================================



================================================================================
FILE NOT FOUND: third_party\imnodes\imnodes.cpp
================================================================================



================================================================================
FILE NOT FOUND: third_party\imnodes\imnodes.h
================================================================================



================================================================================
FILE NOT FOUND: third_party\imnodes\imnodes_internal.h
================================================================================



================================================================================
FILE NOT FOUND: vendor\imnodes\imnodes.cpp
================================================================================



================================================================================
FILE NOT FOUND: vendor\imnodes\imnodes.h
================================================================================



================================================================================
FILE NOT FOUND: vendor\imnodes\imnodes_internal.h
================================================================================



================================================================================
FILE: juce\build\_deps\imnodes_fc-src\imnodes.cpp
================================================================================


// the structure of this file:
//
// [SECTION] bezier curve helpers
// [SECTION] draw list helper
// [SECTION] ui state logic
// [SECTION] render helpers
// [SECTION] API implementation

#include "imnodes_internal.h"

// Check minimum ImGui version
#define MINIMUM_COMPATIBLE_IMGUI_VERSION 17400
#if IMGUI_VERSION_NUM < MINIMUM_COMPATIBLE_IMGUI_VERSION
#error "Minimum ImGui version requirement not met -- please use a newer version!"
#endif

#include <limits.h>
#include <math.h>
#include <new>
#include <stdint.h>
#include <stdio.h> // for fwrite, ssprintf, sscanf
#include <stdlib.h>
#include <string.h> // strlen, strncmp

// Use secure CRT function variants to avoid MSVC compiler errors
#ifdef _MSC_VER
#define sscanf sscanf_s
#endif

ImNodesContext* GImNodes = NULL;

namespace IMNODES_NAMESPACE
{
namespace
{
// [SECTION] bezier curve helpers

struct CubicBezier
{
    ImVec2 P0, P1, P2, P3;
    int    NumSegments;
};

inline ImVec2 EvalCubicBezier(
    const float   t,
    const ImVec2& P0,
    const ImVec2& P1,
    const ImVec2& P2,
    const ImVec2& P3)
{
    // B(t) = (1-t)**3 p0 + 3(1 - t)**2 t P1 + 3(1-t)t**2 P2 + t**3 P3

    const float u = 1.0f - t;
    const float b0 = u * u * u;
    const float b1 = 3 * u * u * t;
    const float b2 = 3 * u * t * t;
    const float b3 = t * t * t;
    return ImVec2(
        b0 * P0.x + b1 * P1.x + b2 * P2.x + b3 * P3.x,
        b0 * P0.y + b1 * P1.y + b2 * P2.y + b3 * P3.y);
}

// Calculates the closest point along each bezier curve segment.
ImVec2 GetClosestPointOnCubicBezier(const int num_segments, const ImVec2& p, const CubicBezier& cb)
{
    IM_ASSERT(num_segments > 0);
    ImVec2 p_last = cb.P0;
    ImVec2 p_closest;
    float  p_closest_dist = FLT_MAX;
    float  t_step = 1.0f / (float)num_segments;
    for (int i = 1; i <= num_segments; ++i)
    {
        ImVec2 p_current = EvalCubicBezier(t_step * i, cb.P0, cb.P1, cb.P2, cb.P3);
        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
        float  dist = ImLengthSqr(p - p_line);
        if (dist < p_closest_dist)
        {
            p_closest = p_line;
            p_closest_dist = dist;
        }
        p_last = p_current;
    }
    return p_closest;
}

inline float GetDistanceToCubicBezier(
    const ImVec2&      pos,
    const CubicBezier& cubic_bezier,
    const int          num_segments)
{
    const ImVec2 point_on_curve = GetClosestPointOnCubicBezier(num_segments, pos, cubic_bezier);

    const ImVec2 to_curve = point_on_curve - pos;
    return ImSqrt(ImLengthSqr(to_curve));
}

inline ImRect GetContainingRectForCubicBezier(const CubicBezier& cb)
{
    const ImVec2 min = ImVec2(ImMin(cb.P0.x, cb.P3.x), ImMin(cb.P0.y, cb.P3.y));
    const ImVec2 max = ImVec2(ImMax(cb.P0.x, cb.P3.x), ImMax(cb.P0.y, cb.P3.y));

    const float hover_distance = GImNodes->Style.LinkHoverDistance;

    ImRect rect(min, max);
    rect.Add(cb.P1);
    rect.Add(cb.P2);
    rect.Expand(ImVec2(hover_distance, hover_distance));

    return rect;
}

inline CubicBezier GetCubicBezier(
    ImVec2                     start,
    ImVec2                     end,
    const ImNodesAttributeType start_type,
    const float                line_segments_per_length)
{
    IM_ASSERT(
        (start_type == ImNodesAttributeType_Input) || (start_type == ImNodesAttributeType_Output));
    if (start_type == ImNodesAttributeType_Input)
    {
        ImSwap(start, end);
    }

    const float  link_length = ImSqrt(ImLengthSqr(end - start));
    const ImVec2 offset = ImVec2(0.25f * link_length, 0.f);
    CubicBezier  cubic_bezier;
    cubic_bezier.P0 = start;
    cubic_bezier.P1 = start + offset;
    cubic_bezier.P2 = end - offset;
    cubic_bezier.P3 = end;
    cubic_bezier.NumSegments = ImMax(static_cast<int>(link_length * line_segments_per_length), 1);
    return cubic_bezier;
}

inline float EvalImplicitLineEq(const ImVec2& p1, const ImVec2& p2, const ImVec2& p)
{
    return (p2.y - p1.y) * p.x + (p1.x - p2.x) * p.y + (p2.x * p1.y - p1.x * p2.y);
}

inline int Sign(float val) { return int(val > 0.0f) - int(val < 0.0f); }

inline bool RectangleOverlapsLineSegment(const ImRect& rect, const ImVec2& p1, const ImVec2& p2)
{
    // Trivial case: rectangle contains an endpoint
    if (rect.Contains(p1) || rect.Contains(p2))
    {
        return true;
    }

    // Flip rectangle if necessary
    ImRect flip_rect = rect;

    if (flip_rect.Min.x > flip_rect.Max.x)
    {
        ImSwap(flip_rect.Min.x, flip_rect.Max.x);
    }

    if (flip_rect.Min.y > flip_rect.Max.y)
    {
        ImSwap(flip_rect.Min.y, flip_rect.Max.y);
    }

    // Trivial case: line segment lies to one particular side of rectangle
    if ((p1.x < flip_rect.Min.x && p2.x < flip_rect.Min.x) ||
        (p1.x > flip_rect.Max.x && p2.x > flip_rect.Max.x) ||
        (p1.y < flip_rect.Min.y && p2.y < flip_rect.Min.y) ||
        (p1.y > flip_rect.Max.y && p2.y > flip_rect.Max.y))
    {
        return false;
    }

    const int corner_signs[4] = {
        Sign(EvalImplicitLineEq(p1, p2, flip_rect.Min)),
        Sign(EvalImplicitLineEq(p1, p2, ImVec2(flip_rect.Max.x, flip_rect.Min.y))),
        Sign(EvalImplicitLineEq(p1, p2, ImVec2(flip_rect.Min.x, flip_rect.Max.y))),
        Sign(EvalImplicitLineEq(p1, p2, flip_rect.Max))};

    int sum = 0;
    int sum_abs = 0;

    for (int i = 0; i < 4; ++i)
    {
        sum += corner_signs[i];
        sum_abs += abs(corner_signs[i]);
    }

    // At least one corner of rectangle lies on a different side of line segment
    return abs(sum) != sum_abs;
}

inline bool RectangleOverlapsBezier(const ImRect& rectangle, const CubicBezier& cubic_bezier)
{
    ImVec2 current =
        EvalCubicBezier(0.f, cubic_bezier.P0, cubic_bezier.P1, cubic_bezier.P2, cubic_bezier.P3);
    const float dt = 1.0f / cubic_bezier.NumSegments;
    for (int s = 0; s < cubic_bezier.NumSegments; ++s)
    {
        ImVec2 next = EvalCubicBezier(
            static_cast<float>((s + 1) * dt),
            cubic_bezier.P0,
            cubic_bezier.P1,
            cubic_bezier.P2,
            cubic_bezier.P3);
        if (RectangleOverlapsLineSegment(rectangle, current, next))
        {
            return true;
        }
        current = next;
    }
    return false;
}

inline bool RectangleOverlapsLink(
    const ImRect&              rectangle,
    const ImVec2&              start,
    const ImVec2&              end,
    const ImNodesAttributeType start_type)
{
    // First level: simple rejection test via rectangle overlap:

    ImRect lrect = ImRect(start, end);
    if (lrect.Min.x > lrect.Max.x)
    {
        ImSwap(lrect.Min.x, lrect.Max.x);
    }

    if (lrect.Min.y > lrect.Max.y)
    {
        ImSwap(lrect.Min.y, lrect.Max.y);
    }

    if (rectangle.Overlaps(lrect))
    {
        // First, check if either one or both endpoinds are trivially contained
        // in the rectangle

        if (rectangle.Contains(start) || rectangle.Contains(end))
        {
            return true;
        }

        // Second level of refinement: do a more expensive test against the
        // link

        const CubicBezier cubic_bezier =
            GetCubicBezier(start, end, start_type, GImNodes->Style.LinkLineSegmentsPerLength);
        return RectangleOverlapsBezier(rectangle, cubic_bezier);
    }

    return false;
}

// [SECTION] coordinate space conversion helpers

inline ImVec2 ScreenSpaceToGridSpace(const ImNodesEditorContext& editor, const ImVec2& v)
{
    return v - GImNodes->CanvasOriginScreenSpace - editor.Panning;
}

inline ImRect ScreenSpaceToGridSpace(const ImNodesEditorContext& editor, const ImRect& r)
{
    return ImRect(ScreenSpaceToGridSpace(editor, r.Min), ScreenSpaceToGridSpace(editor, r.Max));
}

inline ImVec2 GridSpaceToScreenSpace(const ImNodesEditorContext& editor, const ImVec2& v)
{
    return v + GImNodes->CanvasOriginScreenSpace + editor.Panning;
}

inline ImVec2 GridSpaceToEditorSpace(const ImNodesEditorContext& editor, const ImVec2& v)
{
    return v + editor.Panning;
}

inline ImVec2 EditorSpaceToGridSpace(const ImNodesEditorContext& editor, const ImVec2& v)
{
    return v - editor.Panning;
}

inline ImVec2 EditorSpaceToScreenSpace(const ImVec2& v)
{
    return GImNodes->CanvasOriginScreenSpace + v;
}

inline ImVec2 MiniMapSpaceToGridSpace(const ImNodesEditorContext& editor, const ImVec2& v)
{
    return (v - editor.MiniMapContentScreenSpace.Min) / editor.MiniMapScaling +
           editor.GridContentBounds.Min;
}

inline ImVec2 ScreenSpaceToMiniMapSpace(const ImNodesEditorContext& editor, const ImVec2& v)
{
    return (ScreenSpaceToGridSpace(editor, v) - editor.GridContentBounds.Min) *
               editor.MiniMapScaling +
           editor.MiniMapContentScreenSpace.Min;
}

inline ImRect ScreenSpaceToMiniMapSpace(const ImNodesEditorContext& editor, const ImRect& r)
{
    return ImRect(
        ScreenSpaceToMiniMapSpace(editor, r.Min), ScreenSpaceToMiniMapSpace(editor, r.Max));
}

// [SECTION] draw list helper

void ImDrawListGrowChannels(ImDrawList* draw_list, const int num_channels)
{
    ImDrawListSplitter& splitter = draw_list->_Splitter;

    if (splitter._Count == 1)
    {
        splitter.Split(draw_list, num_channels + 1);
        return;
    }

    // NOTE: this logic has been lifted from ImDrawListSplitter::Split with slight modifications
    // to allow nested splits. The main modification is that we only create new ImDrawChannel
    // instances after splitter._Count, instead of over the whole splitter._Channels array like
    // the regular ImDrawListSplitter::Split method does.

    const int old_channel_capacity = splitter._Channels.Size;
    // NOTE: _Channels is not resized down, and therefore _Count <= _Channels.size()!
    const int old_channel_count = splitter._Count;
    const int requested_channel_count = old_channel_count + num_channels;
    if (old_channel_capacity < old_channel_count + num_channels)
    {
        splitter._Channels.resize(requested_channel_count);
    }

    splitter._Count = requested_channel_count;

    for (int i = old_channel_count; i < requested_channel_count; ++i)
    {
        ImDrawChannel& channel = splitter._Channels[i];

        // If we're inside the old capacity region of the array, we need to reuse the existing
        // memory of the command and index buffers.
        if (i < old_channel_capacity)
        {
            channel._CmdBuffer.resize(0);
            channel._IdxBuffer.resize(0);
        }
        // Else, we need to construct new draw channels.
        else
        {
            IM_PLACEMENT_NEW(&channel) ImDrawChannel();
        }

        {
            ImDrawCmd draw_cmd;
            draw_cmd.ClipRect = draw_list->_ClipRectStack.back();
#if IMGUI_VERSION_NUM < 19200
            draw_cmd.TextureId = draw_list->_TextureIdStack.back();
#else
            draw_cmd.TexRef = draw_list->_TextureStack.back();
#endif
            channel._CmdBuffer.push_back(draw_cmd);
        }
    }
}

void ImDrawListSplitterSwapChannels(
    ImDrawListSplitter& splitter,
    const int           lhs_idx,
    const int           rhs_idx)
{
    if (lhs_idx == rhs_idx)
    {
        return;
    }

    IM_ASSERT(lhs_idx >= 0 && lhs_idx < splitter._Count);
    IM_ASSERT(rhs_idx >= 0 && rhs_idx < splitter._Count);

    ImDrawChannel& lhs_channel = splitter._Channels[lhs_idx];
    ImDrawChannel& rhs_channel = splitter._Channels[rhs_idx];
    lhs_channel._CmdBuffer.swap(rhs_channel._CmdBuffer);
    lhs_channel._IdxBuffer.swap(rhs_channel._IdxBuffer);

    const int current_channel = splitter._Current;

    if (current_channel == lhs_idx)
    {
        splitter._Current = rhs_idx;
    }
    else if (current_channel == rhs_idx)
    {
        splitter._Current = lhs_idx;
    }
}

void DrawListSet(ImDrawList* window_draw_list)
{
    GImNodes->CanvasDrawList = window_draw_list;
    GImNodes->NodeIdxToSubmissionIdx.Clear();
    GImNodes->NodeIdxSubmissionOrder.clear();
}

// The draw list channels are structured as follows. First we have our base channel, the canvas grid
// on which we render the grid lines in BeginNodeEditor(). The base channel is the reason
// draw_list_submission_idx_to_background_channel_idx offsets the index by one. Each BeginNode()
// call appends two new draw channels, for the node background and foreground. The node foreground
// is the channel into which the node's ImGui content is rendered. Finally, in EndNodeEditor() we
// append one last draw channel for rendering the selection box and the incomplete link on top of
// everything else.
//
// +----------+----------+----------+----------+----------+----------+
// |          |          |          |          |          |          |
// |canvas    |node      |node      |...       |...       |click     |
// |grid      |background|foreground|          |          |interaction
// |          |          |          |          |          |          |
// +----------+----------+----------+----------+----------+----------+
//            |                     |
//            |   submission idx    |
//            |                     |
//            -----------------------

void DrawListAddNode(const int node_idx)
{
    GImNodes->NodeIdxToSubmissionIdx.SetInt(
        static_cast<ImGuiID>(node_idx), GImNodes->NodeIdxSubmissionOrder.Size);
    GImNodes->NodeIdxSubmissionOrder.push_back(node_idx);
    ImDrawListGrowChannels(GImNodes->CanvasDrawList, 2);
}

void DrawListAppendClickInteractionChannel()
{
    // NOTE: don't use this function outside of EndNodeEditor. Using this before all nodes have been
    // added will screw up the node draw order.
    ImDrawListGrowChannels(GImNodes->CanvasDrawList, 1);
}

int DrawListSubmissionIdxToBackgroundChannelIdx(const int submission_idx)
{
    // NOTE: the first channel is the canvas background, i.e. the grid
    return 1 + 2 * submission_idx;
}

int DrawListSubmissionIdxToForegroundChannelIdx(const int submission_idx)
{
    return DrawListSubmissionIdxToBackgroundChannelIdx(submission_idx) + 1;
}

void DrawListActivateClickInteractionChannel()
{
    GImNodes->CanvasDrawList->_Splitter.SetCurrentChannel(
        GImNodes->CanvasDrawList, GImNodes->CanvasDrawList->_Splitter._Count - 1);
}

void DrawListActivateCurrentNodeForeground()
{
    const int foreground_channel_idx =
        DrawListSubmissionIdxToForegroundChannelIdx(GImNodes->NodeIdxSubmissionOrder.Size - 1);
    GImNodes->CanvasDrawList->_Splitter.SetCurrentChannel(
        GImNodes->CanvasDrawList, foreground_channel_idx);
}

void DrawListActivateNodeBackground(const int node_idx)
{
    const int submission_idx =
        GImNodes->NodeIdxToSubmissionIdx.GetInt(static_cast<ImGuiID>(node_idx), -1);
    // There is a discrepancy in the submitted node count and the rendered node count! Did you call
    // one of the following functions
    // * EditorContextMoveToNode
    // * SetNodeScreenSpacePos
    // * SetNodeGridSpacePos
    // * SetNodeDraggable
    // after the BeginNode/EndNode function calls?
    IM_ASSERT(submission_idx != -1);
    const int background_channel_idx = DrawListSubmissionIdxToBackgroundChannelIdx(submission_idx);
    GImNodes->CanvasDrawList->_Splitter.SetCurrentChannel(
        GImNodes->CanvasDrawList, background_channel_idx);
}

void DrawListSwapSubmissionIndices(const int lhs_idx, const int rhs_idx)
{
    IM_ASSERT(lhs_idx != rhs_idx);

    const int lhs_foreground_channel_idx = DrawListSubmissionIdxToForegroundChannelIdx(lhs_idx);
    const int lhs_background_channel_idx = DrawListSubmissionIdxToBackgroundChannelIdx(lhs_idx);
    const int rhs_foreground_channel_idx = DrawListSubmissionIdxToForegroundChannelIdx(rhs_idx);
    const int rhs_background_channel_idx = DrawListSubmissionIdxToBackgroundChannelIdx(rhs_idx);

    ImDrawListSplitterSwapChannels(
        GImNodes->CanvasDrawList->_Splitter,
        lhs_background_channel_idx,
        rhs_background_channel_idx);
    ImDrawListSplitterSwapChannels(
        GImNodes->CanvasDrawList->_Splitter,
        lhs_foreground_channel_idx,
        rhs_foreground_channel_idx);
}

void DrawListSortChannelsByDepth(const ImVector<int>& node_idx_depth_order)
{
    if (GImNodes->NodeIdxToSubmissionIdx.Data.Size < 2)
    {
        return;
    }

    IM_ASSERT(node_idx_depth_order.Size == GImNodes->NodeIdxSubmissionOrder.Size);

    int start_idx = node_idx_depth_order.Size - 1;

    while (node_idx_depth_order[start_idx] == GImNodes->NodeIdxSubmissionOrder[start_idx])
    {
        if (--start_idx == 0)
        {
            // early out if submission order and depth order are the same
            return;
        }
    }

    // TODO: this is an O(N^2) algorithm. It might be worthwhile revisiting this to see if the time
    // complexity can be reduced.

    for (int depth_idx = start_idx; depth_idx > 0; --depth_idx)
    {
        const int node_idx = node_idx_depth_order[depth_idx];

        // Find the current index of the node_idx in the submission order array
        int submission_idx = -1;
        for (int i = 0; i < GImNodes->NodeIdxSubmissionOrder.Size; ++i)
        {
            if (GImNodes->NodeIdxSubmissionOrder[i] == node_idx)
            {
                submission_idx = i;
                break;
            }
        }
        IM_ASSERT(submission_idx >= 0);

        if (submission_idx == depth_idx)
        {
            continue;
        }

        for (int j = submission_idx; j < depth_idx; ++j)
        {
            DrawListSwapSubmissionIndices(j, j + 1);
            ImSwap(GImNodes->NodeIdxSubmissionOrder[j], GImNodes->NodeIdxSubmissionOrder[j + 1]);
        }
    }
}

// [SECTION] ui state logic

ImVec2 GetScreenSpacePinCoordinates(
    const ImRect&              node_rect,
    const ImRect&              attribute_rect,
    const ImNodesAttributeType type)
{
    IM_ASSERT(type == ImNodesAttributeType_Input || type == ImNodesAttributeType_Output);
    const float x = type == ImNodesAttributeType_Input
                        ? (node_rect.Min.x - GImNodes->Style.PinOffset)
                        : (node_rect.Max.x + GImNodes->Style.PinOffset);
    return ImVec2(x, 0.5f * (attribute_rect.Min.y + attribute_rect.Max.y));
}

ImVec2 GetScreenSpacePinCoordinates(const ImNodesEditorContext& editor, const ImPinData& pin)
{
    const ImRect& parent_node_rect = editor.Nodes.Pool[pin.ParentNodeIdx].Rect;
    return GetScreenSpacePinCoordinates(parent_node_rect, pin.AttributeRect, pin.Type);
}

bool MouseInCanvas()
{
    // This flag should be true either when hovering or clicking something in the canvas.
    const bool is_window_hovered_or_focused = ImGui::IsWindowHovered() || ImGui::IsWindowFocused();

    return is_window_hovered_or_focused &&
           GImNodes->CanvasRectScreenSpace.Contains(ImGui::GetMousePos());
}

void BeginNodeSelection(ImNodesEditorContext& editor, const int node_idx)
{
    // Don't start selecting a node if we are e.g. already creating and dragging
    // a new link! New link creation can happen when the mouse is clicked over
    // a node, but within the hover radius of a pin.
    if (editor.ClickInteraction.Type != ImNodesClickInteractionType_None)
    {
        return;
    }

    editor.ClickInteraction.Type = ImNodesClickInteractionType_Node;
    // If the node is not already contained in the selection, then we want only
    // the interaction node to be selected, effective immediately.
    //
    // If the multiple selection modifier is active, we want to add this node
    // to the current list of selected nodes.
    //
    // Otherwise, we want to allow for the possibility of multiple nodes to be
    // moved at once.
    if (!editor.SelectedNodeIndices.contains(node_idx))
    {
        editor.SelectedLinkIndices.clear();
        if (!GImNodes->MultipleSelectModifier)
        {
            editor.SelectedNodeIndices.clear();
        }
        editor.SelectedNodeIndices.push_back(node_idx);

        // Ensure that individually selected nodes get rendered on top
        ImVector<int>&   depth_stack = editor.NodeDepthOrder;
        const int* const elem = depth_stack.find(node_idx);
        IM_ASSERT(elem != depth_stack.end());
        depth_stack.erase(elem);
        depth_stack.push_back(node_idx);
    }
    // Deselect a previously-selected node
    else if (GImNodes->MultipleSelectModifier)
    {
        const int* const node_ptr = editor.SelectedNodeIndices.find(node_idx);
        editor.SelectedNodeIndices.erase(node_ptr);

        // Don't allow dragging after deselecting
        editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
    }

    // To support snapping of multiple nodes, we need to store the offset of
    // each node in the selection to the origin of the dragged node.
    const ImVec2 ref_origin = editor.Nodes.Pool[node_idx].Origin;
    editor.PrimaryNodeOffset =
        ref_origin + GImNodes->CanvasOriginScreenSpace + editor.Panning - GImNodes->MousePos;

    editor.SelectedNodeOffsets.clear();
    for (int idx = 0; idx < editor.SelectedNodeIndices.Size; idx++)
    {
        const int    node = editor.SelectedNodeIndices[idx];
        const ImVec2 node_origin = editor.Nodes.Pool[node].Origin - ref_origin;
        editor.SelectedNodeOffsets.push_back(node_origin);
    }
}

void BeginLinkSelection(ImNodesEditorContext& editor, const int link_idx)
{
    editor.ClickInteraction.Type = ImNodesClickInteractionType_Link;
    // When a link is selected, clear all other selections, and insert the link
    // as the sole selection.
    editor.SelectedNodeIndices.clear();
    editor.SelectedLinkIndices.clear();
    editor.SelectedLinkIndices.push_back(link_idx);
}

void BeginLinkDetach(ImNodesEditorContext& editor, const int link_idx, const int detach_pin_idx)
{
    const ImLinkData&        link = editor.Links.Pool[link_idx];
    ImClickInteractionState& state = editor.ClickInteraction;
    state.Type = ImNodesClickInteractionType_LinkCreation;
    state.LinkCreation.EndPinIdx.Reset();
    state.LinkCreation.StartPinIdx =
        detach_pin_idx == link.StartPinIdx ? link.EndPinIdx : link.StartPinIdx;
    GImNodes->DeletedLinkIdx = link_idx;
}

void BeginLinkCreation(ImNodesEditorContext& editor, const int hovered_pin_idx)
{
    editor.ClickInteraction.Type = ImNodesClickInteractionType_LinkCreation;
    editor.ClickInteraction.LinkCreation.StartPinIdx = hovered_pin_idx;
    editor.ClickInteraction.LinkCreation.EndPinIdx.Reset();
    editor.ClickInteraction.LinkCreation.Type = ImNodesLinkCreationType_Standard;
    GImNodes->ImNodesUIState |= ImNodesUIState_LinkStarted;
}

void BeginLinkInteraction(
    ImNodesEditorContext& editor,
    const int             link_idx,
    const ImOptionalIndex pin_idx = ImOptionalIndex())
{
    // Check if we are clicking the link with the modifier pressed.
    // This will in a link detach via clicking.

    const bool modifier_pressed = GImNodes->Io.LinkDetachWithModifierClick.Modifier == NULL
                                      ? false
                                      : *GImNodes->Io.LinkDetachWithModifierClick.Modifier;

    if (modifier_pressed)
    {
        const ImLinkData& link = editor.Links.Pool[link_idx];
        const ImPinData&  start_pin = editor.Pins.Pool[link.StartPinIdx];
        const ImPinData&  end_pin = editor.Pins.Pool[link.EndPinIdx];
        const ImVec2&     mouse_pos = GImNodes->MousePos;
        const float       dist_to_start = ImLengthSqr(start_pin.Pos - mouse_pos);
        const float       dist_to_end = ImLengthSqr(end_pin.Pos - mouse_pos);
        const int closest_pin_idx = dist_to_start < dist_to_end ? link.StartPinIdx : link.EndPinIdx;

        editor.ClickInteraction.Type = ImNodesClickInteractionType_LinkCreation;
        BeginLinkDetach(editor, link_idx, closest_pin_idx);
        editor.ClickInteraction.LinkCreation.Type = ImNodesLinkCreationType_FromDetach;
    }
    else
    {
        if (pin_idx.HasValue())
        {
            const int hovered_pin_flags = editor.Pins.Pool[pin_idx.Value()].Flags;

            // Check the 'click and drag to detach' case.
            if (hovered_pin_flags & ImNodesAttributeFlags_EnableLinkDetachWithDragClick)
            {
                BeginLinkDetach(editor, link_idx, pin_idx.Value());
                editor.ClickInteraction.LinkCreation.Type = ImNodesLinkCreationType_FromDetach;
            }
            else
            {
                BeginLinkCreation(editor, pin_idx.Value());
            }
        }
        else
        {
            BeginLinkSelection(editor, link_idx);
        }
    }
}

static inline bool IsMiniMapHovered();

void BeginCanvasInteraction(ImNodesEditorContext& editor)
{
    const bool any_ui_element_hovered =
        GImNodes->HoveredNodeIdx.HasValue() || GImNodes->HoveredLinkIdx.HasValue() ||
        GImNodes->HoveredPinIdx.HasValue() || ImGui::IsAnyItemHovered();

    const bool mouse_not_in_canvas = !MouseInCanvas();

    if (editor.ClickInteraction.Type != ImNodesClickInteractionType_None ||
        any_ui_element_hovered || mouse_not_in_canvas)
    {
        return;
    }

    const bool started_panning = GImNodes->AltMouseClicked;

    if (started_panning)
    {
        editor.ClickInteraction.Type = ImNodesClickInteractionType_Panning;
    }
    else if (GImNodes->LeftMouseClicked)
    {
        editor.ClickInteraction.Type = ImNodesClickInteractionType_BoxSelection;
        editor.ClickInteraction.BoxSelector.Rect.Min =
            ScreenSpaceToGridSpace(editor, GImNodes->MousePos);
    }
}

void BoxSelectorUpdateSelection(ImNodesEditorContext& editor, ImRect box_rect)
{
    // Invert box selector coordinates as needed

    if (box_rect.Min.x > box_rect.Max.x)
    {
        ImSwap(box_rect.Min.x, box_rect.Max.x);
    }

    if (box_rect.Min.y > box_rect.Max.y)
    {
        ImSwap(box_rect.Min.y, box_rect.Max.y);
    }

    // Update node selection

    editor.SelectedNodeIndices.clear();

    // Test for overlap against node rectangles

    for (int node_idx = 0; node_idx < editor.Nodes.Pool.size(); ++node_idx)
    {
        if (editor.Nodes.InUse[node_idx])
        {
            ImNodeData& node = editor.Nodes.Pool[node_idx];
            if (box_rect.Overlaps(node.Rect))
            {
                editor.SelectedNodeIndices.push_back(node_idx);
            }
        }
    }

    // Update link selection

    editor.SelectedLinkIndices.clear();

    // Test for overlap against links

    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)
    {
        if (editor.Links.InUse[link_idx])
        {
            const ImLinkData& link = editor.Links.Pool[link_idx];

            const ImPinData& pin_start = editor.Pins.Pool[link.StartPinIdx];
            const ImPinData& pin_end = editor.Pins.Pool[link.EndPinIdx];
            const ImRect&    node_start_rect = editor.Nodes.Pool[pin_start.ParentNodeIdx].Rect;
            const ImRect&    node_end_rect = editor.Nodes.Pool[pin_end.ParentNodeIdx].Rect;

            const ImVec2 start = GetScreenSpacePinCoordinates(
                node_start_rect, pin_start.AttributeRect, pin_start.Type);
            const ImVec2 end =
                GetScreenSpacePinCoordinates(node_end_rect, pin_end.AttributeRect, pin_end.Type);

            // Test
            if (RectangleOverlapsLink(box_rect, start, end, pin_start.Type))
            {
                editor.SelectedLinkIndices.push_back(link_idx);
            }
        }
    }
}

ImVec2 SnapOriginToGrid(ImVec2 origin)
{
    if (GImNodes->Style.Flags & ImNodesStyleFlags_GridSnapping)
    {
        const float spacing = GImNodes->Style.GridSpacing;
        const float spacing2 = spacing * 0.5f;

        // Snap the origin to the nearest grid point in any direction
        float modx = fmodf(fabsf(origin.x) + spacing2, spacing) - spacing2;
        float mody = fmodf(fabsf(origin.y) + spacing2, spacing) - spacing2;
        origin.x += (origin.x < 0.f) ? modx : -modx;
        origin.y += (origin.y < 0.f) ? mody : -mody;
    }

    return origin;
}

void TranslateSelectedNodes(ImNodesEditorContext& editor)
{
    if (GImNodes->LeftMouseDragging)
    {
        // If we have grid snap enabled, don't start moving nodes until we've moved the mouse
        // slightly
        const bool shouldTranslate = (GImNodes->Style.Flags & ImNodesStyleFlags_GridSnapping)
                                         ? ImGui::GetIO().MouseDragMaxDistanceSqr[0] > 5.0
                                         : true;

        const ImVec2 origin = SnapOriginToGrid(
            GImNodes->MousePos - GImNodes->CanvasOriginScreenSpace - editor.Panning +
            editor.PrimaryNodeOffset);
        for (int i = 0; i < editor.SelectedNodeIndices.size(); ++i)
        {
            const ImVec2 node_rel = editor.SelectedNodeOffsets[i];
            const int    node_idx = editor.SelectedNodeIndices[i];
            ImNodeData&  node = editor.Nodes.Pool[node_idx];
            if (node.Draggable && shouldTranslate)
            {
                node.Origin = origin + node_rel + editor.AutoPanningDelta;
            }
        }
    }
}

struct LinkPredicate
{
    bool operator()(const ImLinkData& lhs, const ImLinkData& rhs) const
    {
        // Do a unique compare by sorting the pins' addresses.
        // This catches duplicate links, whether they are in the
        // same direction or not.
        // Sorting by pin index should have the uniqueness guarantees as sorting
        // by id -- each unique id will get one slot in the link pool array.

        int lhs_start = lhs.StartPinIdx;
        int lhs_end = lhs.EndPinIdx;
        int rhs_start = rhs.StartPinIdx;
        int rhs_end = rhs.EndPinIdx;

        if (lhs_start > lhs_end)
        {
            ImSwap(lhs_start, lhs_end);
        }

        if (rhs_start > rhs_end)
        {
            ImSwap(rhs_start, rhs_end);
        }

        return lhs_start == rhs_start && lhs_end == rhs_end;
    }
};

ImOptionalIndex FindDuplicateLink(
    const ImNodesEditorContext& editor,
    const int                   start_pin_idx,
    const int                   end_pin_idx)
{
    ImLinkData test_link(0);
    test_link.StartPinIdx = start_pin_idx;
    test_link.EndPinIdx = end_pin_idx;
    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)
    {
        const ImLinkData& link = editor.Links.Pool[link_idx];
        if (LinkPredicate()(test_link, link) && editor.Links.InUse[link_idx])
        {
            return ImOptionalIndex(link_idx);
        }
    }

    return ImOptionalIndex();
}

bool ShouldLinkSnapToPin(
    const ImNodesEditorContext& editor,
    const ImPinData&            start_pin,
    const int                   hovered_pin_idx,
    const ImOptionalIndex       duplicate_link)
{
    const ImPinData& end_pin = editor.Pins.Pool[hovered_pin_idx];

    // The end pin must be in a different node
    if (start_pin.ParentNodeIdx == end_pin.ParentNodeIdx)
    {
        return false;
    }

    // The end pin must be of a different type
    if (start_pin.Type == end_pin.Type)
    {
        return false;
    }

    // The link to be created must not be a duplicate, unless it is the link which was created on
    // snap. In that case we want to snap, since we want it to appear visually as if the created
    // link remains snapped to the pin.
    if (duplicate_link.HasValue() && !(duplicate_link == GImNodes->SnapLinkIdx))
    {
        return false;
    }

    return true;
}

void ClickInteractionUpdate(ImNodesEditorContext& editor)
{
    switch (editor.ClickInteraction.Type)
    {
    case ImNodesClickInteractionType_BoxSelection:
    {
        editor.ClickInteraction.BoxSelector.Rect.Max =
            ScreenSpaceToGridSpace(editor, GImNodes->MousePos);

        ImRect box_rect = editor.ClickInteraction.BoxSelector.Rect;
        box_rect.Min = GridSpaceToScreenSpace(editor, box_rect.Min);
        box_rect.Max = GridSpaceToScreenSpace(editor, box_rect.Max);

        BoxSelectorUpdateSelection(editor, box_rect);

        const ImU32 box_selector_color = GImNodes->Style.Colors[ImNodesCol_BoxSelector];
        const ImU32 box_selector_outline = GImNodes->Style.Colors[ImNodesCol_BoxSelectorOutline];
        GImNodes->CanvasDrawList->AddRectFilled(box_rect.Min, box_rect.Max, box_selector_color);
        GImNodes->CanvasDrawList->AddRect(box_rect.Min, box_rect.Max, box_selector_outline);

        if (GImNodes->LeftMouseReleased)
        {
            ImVector<int>&       depth_stack = editor.NodeDepthOrder;
            const ImVector<int>& selected_idxs = editor.SelectedNodeIndices;

            // Bump the selected node indices, in order, to the top of the depth stack.
            // NOTE: this algorithm has worst case time complexity of O(N^2), if the node selection
            // is ~ N (due to selected_idxs.contains()).

            if ((selected_idxs.Size > 0) && (selected_idxs.Size < depth_stack.Size))
            {
                int num_moved = 0; // The number of indices moved. Stop after selected_idxs.Size
                for (int i = 0; i < depth_stack.Size - selected_idxs.Size; ++i)
                {
                    for (int node_idx = depth_stack[i]; selected_idxs.contains(node_idx);
                         node_idx = depth_stack[i])
                    {
                        depth_stack.erase(depth_stack.begin() + static_cast<size_t>(i));
                        depth_stack.push_back(node_idx);
                        ++num_moved;
                    }

                    if (num_moved == selected_idxs.Size)
                    {
                        break;
                    }
                }
            }

            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
        }
    }
    break;
    case ImNodesClickInteractionType_Node:
    {
        TranslateSelectedNodes(editor);

        if (GImNodes->LeftMouseReleased)
        {
            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
        }
    }
    break;
    case ImNodesClickInteractionType_Link:
    {
        if (GImNodes->LeftMouseReleased)
        {
            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
        }
    }
    break;
    case ImNodesClickInteractionType_LinkCreation:
    {
        const ImPinData& start_pin =
            editor.Pins.Pool[editor.ClickInteraction.LinkCreation.StartPinIdx];

        const ImOptionalIndex maybe_duplicate_link_idx =
            GImNodes->HoveredPinIdx.HasValue()
                ? FindDuplicateLink(
                      editor,
                      editor.ClickInteraction.LinkCreation.StartPinIdx,
                      GImNodes->HoveredPinIdx.Value())
                : ImOptionalIndex();

        const bool should_snap =
            GImNodes->HoveredPinIdx.HasValue() &&
            ShouldLinkSnapToPin(
                editor, start_pin, GImNodes->HoveredPinIdx.Value(), maybe_duplicate_link_idx);

        // If we created on snap and the hovered pin is empty or changed, then we need signal that
        // the link's state has changed.
        const bool snapping_pin_changed =
            editor.ClickInteraction.LinkCreation.EndPinIdx.HasValue() &&
            !(GImNodes->HoveredPinIdx == editor.ClickInteraction.LinkCreation.EndPinIdx);

        // Detach the link that was created by this link event if it's no longer in snap range
        if (snapping_pin_changed && GImNodes->SnapLinkIdx.HasValue())
        {
            BeginLinkDetach(
                editor,
                GImNodes->SnapLinkIdx.Value(),
                editor.ClickInteraction.LinkCreation.EndPinIdx.Value());
        }

        const ImVec2 start_pos = GetScreenSpacePinCoordinates(editor, start_pin);
        // If we are within the hover radius of a receiving pin, snap the link
        // endpoint to it
        const ImVec2 end_pos = should_snap
                                   ? GetScreenSpacePinCoordinates(
                                         editor, editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()])
                                   : GImNodes->MousePos;

        const CubicBezier cubic_bezier = GetCubicBezier(
            start_pos, end_pos, start_pin.Type, GImNodes->Style.LinkLineSegmentsPerLength);
#if IMGUI_VERSION_NUM < 18000
        GImNodes->CanvasDrawList->AddBezierCurve(
#else
        GImNodes->CanvasDrawList->AddBezierCubic(
#endif
            cubic_bezier.P0,
            cubic_bezier.P1,
            cubic_bezier.P2,
            cubic_bezier.P3,
            GImNodes->Style.Colors[ImNodesCol_Link],
            GImNodes->Style.LinkThickness,
            cubic_bezier.NumSegments);

        const bool link_creation_on_snap =
            GImNodes->HoveredPinIdx.HasValue() &&
            (editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()].Flags &
             ImNodesAttributeFlags_EnableLinkCreationOnSnap);

        if (!should_snap)
        {
            editor.ClickInteraction.LinkCreation.EndPinIdx.Reset();
        }

        const bool create_link =
            should_snap && (GImNodes->LeftMouseReleased || link_creation_on_snap);

        if (create_link && !maybe_duplicate_link_idx.HasValue())
        {
            // Avoid send OnLinkCreated() events every frame if the snap link is not saved
            // (only applies for EnableLinkCreationOnSnap)
            if (!GImNodes->LeftMouseReleased &&
                editor.ClickInteraction.LinkCreation.EndPinIdx == GImNodes->HoveredPinIdx)
            {
                break;
            }

            GImNodes->ImNodesUIState |= ImNodesUIState_LinkCreated;
            editor.ClickInteraction.LinkCreation.EndPinIdx = GImNodes->HoveredPinIdx.Value();
        }

        if (GImNodes->LeftMouseReleased)
        {
            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
            if (!create_link)
            {
                GImNodes->ImNodesUIState |= ImNodesUIState_LinkDropped;
            }
        }
    }
    break;
    case ImNodesClickInteractionType_Panning:
    {
        const bool dragging = GImNodes->AltMouseDragging;

        if (dragging)
        {
            editor.Panning += ImGui::GetIO().MouseDelta;
        }
        else
        {
            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
        }
    }
    break;
    case ImNodesClickInteractionType_ImGuiItem:
    {
        if (GImNodes->LeftMouseReleased)
        {
            editor.ClickInteraction.Type = ImNodesClickInteractionType_None;
        }
    }
    case ImNodesClickInteractionType_None:
        break;
    default:
        IM_ASSERT(!"Unreachable code!");
        break;
    }
}

void ResolveOccludedPins(const ImNodesEditorContext& editor, ImVector<int>& occluded_pin_indices)
{
    const ImVector<int>& depth_stack = editor.NodeDepthOrder;

    occluded_pin_indices.resize(0);

    if (depth_stack.Size < 2)
    {
        return;
    }

    // For each node in the depth stack
    for (int depth_idx = 0; depth_idx < (depth_stack.Size - 1); ++depth_idx)
    {
        const ImNodeData& node_below = editor.Nodes.Pool[depth_stack[depth_idx]];

        // Iterate over the rest of the depth stack to find nodes overlapping the pins
        for (int next_depth_idx = depth_idx + 1; next_depth_idx < depth_stack.Size;
             ++next_depth_idx)
        {
            const ImRect& rect_above = editor.Nodes.Pool[depth_stack[next_depth_idx]].Rect;

            // Iterate over each pin
            for (int idx = 0; idx < node_below.PinIndices.Size; ++idx)
            {
                const int     pin_idx = node_below.PinIndices[idx];
                const ImVec2& pin_pos = editor.Pins.Pool[pin_idx].Pos;

                if (rect_above.Contains(pin_pos))
                {
                    occluded_pin_indices.push_back(pin_idx);
                }
            }
        }
    }
}

ImOptionalIndex ResolveHoveredPin(
    const ImObjectPool<ImPinData>& pins,
    const ImVector<int>&           occluded_pin_indices)
{
    float           smallest_distance = FLT_MAX;
    ImOptionalIndex pin_idx_with_smallest_distance;

    const float hover_radius_sqr = GImNodes->Style.PinHoverRadius * GImNodes->Style.PinHoverRadius;

    for (int idx = 0; idx < pins.Pool.Size; ++idx)
    {
        if (!pins.InUse[idx])
        {
            continue;
        }

        if (occluded_pin_indices.contains(idx))
        {
            continue;
        }

        const ImVec2& pin_pos = pins.Pool[idx].Pos;
        const float   distance_sqr = ImLengthSqr(pin_pos - GImNodes->MousePos);

        // TODO: GImNodes->Style.PinHoverRadius needs to be copied into pin data and the pin-local
        // value used here. This is no longer called in BeginAttribute/EndAttribute scope and the
        // detected pin might have a different hover radius than what the user had when calling
        // BeginAttribute/EndAttribute.
        if (distance_sqr < hover_radius_sqr && distance_sqr < smallest_distance)
        {
            smallest_distance = distance_sqr;
            pin_idx_with_smallest_distance = idx;
        }
    }

    return pin_idx_with_smallest_distance;
}

ImOptionalIndex ResolveHoveredNode(const ImVector<int>& depth_stack)
{
    if (GImNodes->NodeIndicesOverlappingWithMouse.size() == 0)
    {
        return ImOptionalIndex();
    }

    if (GImNodes->NodeIndicesOverlappingWithMouse.size() == 1)
    {
        return ImOptionalIndex(GImNodes->NodeIndicesOverlappingWithMouse[0]);
    }

    int largest_depth_idx = -1;
    int node_idx_on_top = -1;

    for (int i = 0; i < GImNodes->NodeIndicesOverlappingWithMouse.size(); ++i)
    {
        const int node_idx = GImNodes->NodeIndicesOverlappingWithMouse[i];
        for (int depth_idx = 0; depth_idx < depth_stack.size(); ++depth_idx)
        {
            if (depth_stack[depth_idx] == node_idx && (depth_idx > largest_depth_idx))
            {
                largest_depth_idx = depth_idx;
                node_idx_on_top = node_idx;
            }
        }
    }

    IM_ASSERT(node_idx_on_top != -1);
    return ImOptionalIndex(node_idx_on_top);
}

ImOptionalIndex ResolveHoveredLink(
    const ImObjectPool<ImLinkData>& links,
    const ImObjectPool<ImPinData>&  pins)
{
    float           smallest_distance = FLT_MAX;
    ImOptionalIndex link_idx_with_smallest_distance;

    // There are two ways a link can be detected as "hovered".
    // 1. The link is within hover distance to the mouse. The closest such link is selected as being
    // hovered over.
    // 2. If the link is connected to the currently hovered pin.
    //
    // The latter is a requirement for link detaching with drag click to work, as both a link and
    // pin are required to be hovered over for the feature to work.

    for (int idx = 0; idx < links.Pool.Size; ++idx)
    {
        if (!links.InUse[idx])
        {
            continue;
        }

        const ImLinkData& link = links.Pool[idx];
        const ImPinData&  start_pin = pins.Pool[link.StartPinIdx];
        const ImPinData&  end_pin = pins.Pool[link.EndPinIdx];

        // If there is a hovered pin links can only be considered hovered if they use that pin
        if (GImNodes->HoveredPinIdx.HasValue())
        {
            if (GImNodes->HoveredPinIdx == link.StartPinIdx ||
                GImNodes->HoveredPinIdx == link.EndPinIdx)
            {
                return idx;
            }
            continue;
        }

        // TODO: the calculated CubicBeziers could be cached since we generate them again when
        // rendering the links

        const CubicBezier cubic_bezier = GetCubicBezier(
            start_pin.Pos, end_pin.Pos, start_pin.Type, GImNodes->Style.LinkLineSegmentsPerLength);

        // The distance test
        {
            const ImRect link_rect = GetContainingRectForCubicBezier(cubic_bezier);

            // First, do a simple bounding box test against the box containing the link
            // to see whether calculating the distance to the link is worth doing.
            if (link_rect.Contains(GImNodes->MousePos))
            {
                const float distance = GetDistanceToCubicBezier(
                    GImNodes->MousePos, cubic_bezier, cubic_bezier.NumSegments);

                // TODO: GImNodes->Style.LinkHoverDistance could be also copied into ImLinkData,
                // since we're not calling this function in the same scope as ImNodes::Link(). The
                // rendered/detected link might have a different hover distance than what the user
                // had specified when calling Link()
                if (distance < GImNodes->Style.LinkHoverDistance && distance < smallest_distance)
                {
                    smallest_distance = distance;
                    link_idx_with_smallest_distance = idx;
                }
            }
        }
    }

    return link_idx_with_smallest_distance;
}

// [SECTION] render helpers

inline ImRect GetItemRect() { return ImRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax()); }

inline ImVec2 GetNodeTitleBarOrigin(const ImNodeData& node)
{
    return node.Origin + node.LayoutStyle.Padding;
}

inline ImVec2 GetNodeContentOrigin(const ImNodeData& node)
{
    const ImVec2 title_bar_height =
        ImVec2(0.f, node.TitleBarContentRect.GetHeight() + 2.0f * node.LayoutStyle.Padding.y);
    return node.Origin + title_bar_height + node.LayoutStyle.Padding;
}

inline ImRect GetNodeTitleRect(const ImNodeData& node)
{
    ImRect expanded_title_rect = node.TitleBarContentRect;
    expanded_title_rect.Expand(node.LayoutStyle.Padding);

    return ImRect(
        expanded_title_rect.Min,
        expanded_title_rect.Min + ImVec2(node.Rect.GetWidth(), 0.f) +
            ImVec2(0.f, expanded_title_rect.GetHeight()));
}

void DrawGrid(ImNodesEditorContext& editor, const ImVec2& canvas_size)
{
    const ImVec2 offset = editor.Panning;
    ImU32        line_color = GImNodes->Style.Colors[ImNodesCol_GridLine];
    ImU32        line_color_prim = GImNodes->Style.Colors[ImNodesCol_GridLinePrimary];
    bool         draw_primary = GImNodes->Style.Flags & ImNodesStyleFlags_GridLinesPrimary;

    for (float x = fmodf(offset.x, GImNodes->Style.GridSpacing); x < canvas_size.x;
         x += GImNodes->Style.GridSpacing)
    {
        GImNodes->CanvasDrawList->AddLine(
            EditorSpaceToScreenSpace(ImVec2(x, 0.0f)),
            EditorSpaceToScreenSpace(ImVec2(x, canvas_size.y)),
            offset.x - x == 0.f && draw_primary ? line_color_prim : line_color);
    }

    for (float y = fmodf(offset.y, GImNodes->Style.GridSpacing); y < canvas_size.y;
         y += GImNodes->Style.GridSpacing)
    {
        GImNodes->CanvasDrawList->AddLine(
            EditorSpaceToScreenSpace(ImVec2(0.0f, y)),
            EditorSpaceToScreenSpace(ImVec2(canvas_size.x, y)),
            offset.y - y == 0.f && draw_primary ? line_color_prim : line_color);
    }
}

struct QuadOffsets
{
    ImVec2 TopLeft, BottomLeft, BottomRight, TopRight;
};

QuadOffsets CalculateQuadOffsets(const float side_length)
{
    const float half_side = 0.5f * side_length;

    QuadOffsets offset;

    offset.TopLeft = ImVec2(-half_side, half_side);
    offset.BottomLeft = ImVec2(-half_side, -half_side);
    offset.BottomRight = ImVec2(half_side, -half_side);
    offset.TopRight = ImVec2(half_side, half_side);

    return offset;
}

struct TriangleOffsets
{
    ImVec2 TopLeft, BottomLeft, Right;
};

TriangleOffsets CalculateTriangleOffsets(const float side_length)
{
    // Calculates the Vec2 offsets from an equilateral triangle's midpoint to
    // its vertices. Here is how the left_offset and right_offset are
    // calculated.
    //
    // For an equilateral triangle of side length s, the
    // triangle's height, h, is h = s * sqrt(3) / 2.
    //
    // The length from the base to the midpoint is (1 / 3) * h. The length from
    // the midpoint to the triangle vertex is (2 / 3) * h.
    const float sqrt_3 = sqrtf(3.0f);
    const float left_offset = -0.1666666666667f * sqrt_3 * side_length;
    const float right_offset = 0.333333333333f * sqrt_3 * side_length;
    const float vertical_offset = 0.5f * side_length;

    TriangleOffsets offset;
    offset.TopLeft = ImVec2(left_offset, vertical_offset);
    offset.BottomLeft = ImVec2(left_offset, -vertical_offset);
    offset.Right = ImVec2(right_offset, 0.f);

    return offset;
}

void DrawPinShape(const ImVec2& pin_pos, const ImPinData& pin, const ImU32 pin_color)
{
    static const int CIRCLE_NUM_SEGMENTS = 8;

    switch (pin.Shape)
    {
    case ImNodesPinShape_Circle:
    {
        GImNodes->CanvasDrawList->AddCircle(
            pin_pos,
            GImNodes->Style.PinCircleRadius,
            pin_color,
            CIRCLE_NUM_SEGMENTS,
            GImNodes->Style.PinLineThickness);
    }
    break;
    case ImNodesPinShape_CircleFilled:
    {
        GImNodes->CanvasDrawList->AddCircleFilled(
            pin_pos, GImNodes->Style.PinCircleRadius, pin_color, CIRCLE_NUM_SEGMENTS);
    }
    break;
    case ImNodesPinShape_Quad:
    {
        const QuadOffsets offset = CalculateQuadOffsets(GImNodes->Style.PinQuadSideLength);
        GImNodes->CanvasDrawList->AddQuad(
            pin_pos + offset.TopLeft,
            pin_pos + offset.BottomLeft,
            pin_pos + offset.BottomRight,
            pin_pos + offset.TopRight,
            pin_color,
            GImNodes->Style.PinLineThickness);
    }
    break;
    case ImNodesPinShape_QuadFilled:
    {
        const QuadOffsets offset = CalculateQuadOffsets(GImNodes->Style.PinQuadSideLength);
        GImNodes->CanvasDrawList->AddQuadFilled(
            pin_pos + offset.TopLeft,
            pin_pos + offset.BottomLeft,
            pin_pos + offset.BottomRight,
            pin_pos + offset.TopRight,
            pin_color);
    }
    break;
    case ImNodesPinShape_Triangle:
    {
        const TriangleOffsets offset =
            CalculateTriangleOffsets(GImNodes->Style.PinTriangleSideLength);
        GImNodes->CanvasDrawList->AddTriangle(
            pin_pos + offset.TopLeft,
            pin_pos + offset.BottomLeft,
            pin_pos + offset.Right,
            pin_color,
            // NOTE: for some weird reason, the line drawn by AddTriangle is
            // much thinner than the lines drawn by AddCircle or AddQuad.
            // Multiplying the line thickness by two seemed to solve the
            // problem at a few different thickness values.
            2.f * GImNodes->Style.PinLineThickness);
    }
    break;
    case ImNodesPinShape_TriangleFilled:
    {
        const TriangleOffsets offset =
            CalculateTriangleOffsets(GImNodes->Style.PinTriangleSideLength);
        GImNodes->CanvasDrawList->AddTriangleFilled(
            pin_pos + offset.TopLeft,
            pin_pos + offset.BottomLeft,
            pin_pos + offset.Right,
            pin_color);
    }
    break;
    default:
        IM_ASSERT(!"Invalid PinShape value!");
        break;
    }
}

void DrawPin(ImNodesEditorContext& editor, const int pin_idx)
{
    ImPinData&    pin = editor.Pins.Pool[pin_idx];
    const ImRect& parent_node_rect = editor.Nodes.Pool[pin.ParentNodeIdx].Rect;

    pin.Pos = GetScreenSpacePinCoordinates(parent_node_rect, pin.AttributeRect, pin.Type);

    ImU32 pin_color = pin.ColorStyle.Background;

    if (GImNodes->HoveredPinIdx == pin_idx)
    {
        pin_color = pin.ColorStyle.Hovered;
    }

    DrawPinShape(pin.Pos, pin, pin_color);
}

void DrawNode(ImNodesEditorContext& editor, const int node_idx)
{
    const ImNodeData& node = editor.Nodes.Pool[node_idx];
    ImGui::SetCursorPos(node.Origin + editor.Panning);

    const bool node_hovered =
        GImNodes->HoveredNodeIdx == node_idx &&
        editor.ClickInteraction.Type != ImNodesClickInteractionType_BoxSelection;

    ImU32 node_background = node.ColorStyle.Background;
    ImU32 titlebar_background = node.ColorStyle.Titlebar;

    if (editor.SelectedNodeIndices.contains(node_idx))
    {
        node_background = node.ColorStyle.BackgroundSelected;
        titlebar_background = node.ColorStyle.TitlebarSelected;
    }
    else if (node_hovered)
    {
        node_background = node.ColorStyle.BackgroundHovered;
        titlebar_background = node.ColorStyle.TitlebarHovered;
    }

    {
        // node base
        GImNodes->CanvasDrawList->AddRectFilled(
            node.Rect.Min, node.Rect.Max, node_background, node.LayoutStyle.CornerRounding);

        // title bar:
        if (node.TitleBarContentRect.GetHeight() > 0.f)
        {
            ImRect title_bar_rect = GetNodeTitleRect(node);

#if IMGUI_VERSION_NUM < 18200
            GImNodes->CanvasDrawList->AddRectFilled(
                title_bar_rect.Min,
                title_bar_rect.Max,
                titlebar_background,
                node.LayoutStyle.CornerRounding,
                ImDrawCornerFlags_Top);
#else
            GImNodes->CanvasDrawList->AddRectFilled(
                title_bar_rect.Min,
                title_bar_rect.Max,
                titlebar_background,
                node.LayoutStyle.CornerRounding,
                ImDrawFlags_RoundCornersTop);

#endif
        }

        if ((GImNodes->Style.Flags & ImNodesStyleFlags_NodeOutline) != 0)
        {
#if IMGUI_VERSION_NUM < 18200
            GImNodes->CanvasDrawList->AddRect(
                node.Rect.Min,
                node.Rect.Max,
                node.ColorStyle.Outline,
                node.LayoutStyle.CornerRounding,
                ImDrawCornerFlags_All,
                node.LayoutStyle.BorderThickness);
#else
            GImNodes->CanvasDrawList->AddRect(
                node.Rect.Min,
                node.Rect.Max,
                node.ColorStyle.Outline,
                node.LayoutStyle.CornerRounding,
                ImDrawFlags_RoundCornersAll,
                node.LayoutStyle.BorderThickness);
#endif
        }
    }

    for (int i = 0; i < node.PinIndices.size(); ++i)
    {
        DrawPin(editor, node.PinIndices[i]);
    }

    if (node_hovered)
    {
        GImNodes->HoveredNodeIdx = node_idx;
    }
}

void DrawLink(ImNodesEditorContext& editor, const int link_idx)
{
    const ImLinkData& link = editor.Links.Pool[link_idx];
    const ImPinData&  start_pin = editor.Pins.Pool[link.StartPinIdx];
    const ImPinData&  end_pin = editor.Pins.Pool[link.EndPinIdx];

    const CubicBezier cubic_bezier = GetCubicBezier(
        start_pin.Pos, end_pin.Pos, start_pin.Type, GImNodes->Style.LinkLineSegmentsPerLength);

    const bool link_hovered =
        GImNodes->HoveredLinkIdx == link_idx &&
        editor.ClickInteraction.Type != ImNodesClickInteractionType_BoxSelection;

    if (link_hovered)
    {
        GImNodes->HoveredLinkIdx = link_idx;
    }

    // It's possible for a link to be deleted in begin_link_interaction. A user
    // may detach a link, resulting in the link wire snapping to the mouse
    // position.
    //
    // In other words, skip rendering the link if it was deleted.
    if (GImNodes->DeletedLinkIdx == link_idx)
    {
        return;
    }

    ImU32 link_color = link.ColorStyle.Base;
    if (editor.SelectedLinkIndices.contains(link_idx))
    {
        link_color = link.ColorStyle.Selected;
    }
    else if (link_hovered)
    {
        link_color = link.ColorStyle.Hovered;
    }

#if IMGUI_VERSION_NUM < 18000
    GImNodes->CanvasDrawList->AddBezierCurve(
#else
    GImNodes->CanvasDrawList->AddBezierCubic(
#endif
        cubic_bezier.P0,
        cubic_bezier.P1,
        cubic_bezier.P2,
        cubic_bezier.P3,
        link_color,
        GImNodes->Style.LinkThickness,
        cubic_bezier.NumSegments);
}

void BeginPinAttribute(
    const int                  id,
    const ImNodesAttributeType type,
    const ImNodesPinShape      shape,
    const int                  node_idx)
{
    // Make sure to call BeginNode() before calling
    // BeginAttribute()
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);
    GImNodes->CurrentScope = ImNodesScope_Attribute;

    ImGui::BeginGroup();
    ImGui::PushID(id);

    ImNodesEditorContext& editor = EditorContextGet();

    GImNodes->CurrentAttributeId = id;

    const int pin_idx = ObjectPoolFindOrCreateIndex(editor.Pins, id);
    GImNodes->CurrentPinIdx = pin_idx;
    ImPinData& pin = editor.Pins.Pool[pin_idx];
    pin.Id = id;
    pin.ParentNodeIdx = node_idx;
    pin.Type = type;
    pin.Shape = shape;
    pin.Flags = GImNodes->CurrentAttributeFlags;
    pin.ColorStyle.Background = GImNodes->Style.Colors[ImNodesCol_Pin];
    pin.ColorStyle.Hovered = GImNodes->Style.Colors[ImNodesCol_PinHovered];
}

void EndPinAttribute()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Attribute);
    GImNodes->CurrentScope = ImNodesScope_Node;

    ImGui::PopID();
    ImGui::EndGroup();

    if (ImGui::IsItemActive())
    {
        GImNodes->ActiveAttribute = true;
        GImNodes->ActiveAttributeId = GImNodes->CurrentAttributeId;
    }

    ImNodesEditorContext& editor = EditorContextGet();
    ImPinData&            pin = editor.Pins.Pool[GImNodes->CurrentPinIdx];
    ImNodeData&           node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];
    pin.AttributeRect = GetItemRect();
    node.PinIndices.push_back(GImNodes->CurrentPinIdx);
}

void Initialize(ImNodesContext* context)
{
    context->CanvasOriginScreenSpace = ImVec2(0.0f, 0.0f);
    context->CanvasRectScreenSpace = ImRect(ImVec2(0.f, 0.f), ImVec2(0.f, 0.f));
    context->CurrentScope = ImNodesScope_None;

    context->CurrentPinIdx = INT_MAX;
    context->CurrentNodeIdx = INT_MAX;

    context->DefaultEditorCtx = EditorContextCreate();
    context->EditorCtx = context->DefaultEditorCtx;

    context->CurrentAttributeFlags = ImNodesAttributeFlags_None;
    context->AttributeFlagStack.push_back(GImNodes->CurrentAttributeFlags);

    StyleColorsDark(&context->Style);
}

void Shutdown(ImNodesContext* ctx) { EditorContextFree(ctx->DefaultEditorCtx); }

// [SECTION] minimap

static inline bool IsMiniMapActive()
{
    ImNodesEditorContext& editor = EditorContextGet();
    return editor.MiniMapEnabled && editor.MiniMapSizeFraction > 0.0f;
}

static inline bool IsMiniMapHovered()
{
    ImNodesEditorContext& editor = EditorContextGet();
    return IsMiniMapActive() &&
           ImGui::IsMouseHoveringRect(
               editor.MiniMapRectScreenSpace.Min, editor.MiniMapRectScreenSpace.Max);
}

static inline void CalcMiniMapLayout()
{
    ImNodesEditorContext& editor = EditorContextGet();
    const ImVec2          offset = GImNodes->Style.MiniMapOffset;
    const ImVec2          border = GImNodes->Style.MiniMapPadding;
    const ImRect          editor_rect = GImNodes->CanvasRectScreenSpace;

    // Compute the size of the mini-map area
    ImVec2 mini_map_size;
    float  mini_map_scaling;
    {
        const ImVec2 max_size =
            ImFloor(editor_rect.GetSize() * editor.MiniMapSizeFraction - border * 2.0f);
        const float  max_size_aspect_ratio = max_size.x / max_size.y;
        const ImVec2 grid_content_size = editor.GridContentBounds.IsInverted()
                                             ? max_size
                                             : ImFloor(editor.GridContentBounds.GetSize());
        const float  grid_content_aspect_ratio = grid_content_size.x / grid_content_size.y;
        mini_map_size = ImFloor(
            grid_content_aspect_ratio > max_size_aspect_ratio
                ? ImVec2(max_size.x, max_size.x / grid_content_aspect_ratio)
                : ImVec2(max_size.y * grid_content_aspect_ratio, max_size.y));
        mini_map_scaling = mini_map_size.x / grid_content_size.x;
    }

    // Compute location of the mini-map
    ImVec2 mini_map_pos;
    {
        ImVec2 align;

        switch (editor.MiniMapLocation)
        {
        case ImNodesMiniMapLocation_BottomRight:
            align.x = 1.0f;
            align.y = 1.0f;
            break;
        case ImNodesMiniMapLocation_BottomLeft:
            align.x = 0.0f;
            align.y = 1.0f;
            break;
        case ImNodesMiniMapLocation_TopRight:
            align.x = 1.0f;
            align.y = 0.0f;
            break;
        case ImNodesMiniMapLocation_TopLeft: // [[fallthrough]]
        default:
            align.x = 0.0f;
            align.y = 0.0f;
            break;
        }

        const ImVec2 top_left_pos = editor_rect.Min + offset + border;
        const ImVec2 bottom_right_pos = editor_rect.Max - offset - border - mini_map_size;
        mini_map_pos = ImFloor(ImLerp(top_left_pos, bottom_right_pos, align));
    }

    editor.MiniMapRectScreenSpace =
        ImRect(mini_map_pos - border, mini_map_pos + mini_map_size + border);
    editor.MiniMapContentScreenSpace = ImRect(mini_map_pos, mini_map_pos + mini_map_size);
    editor.MiniMapScaling = mini_map_scaling;
}

static void MiniMapDrawNode(ImNodesEditorContext& editor, const int node_idx)
{
    const ImNodeData& node = editor.Nodes.Pool[node_idx];

    const ImRect node_rect = ScreenSpaceToMiniMapSpace(editor, node.Rect);

    // Round to near whole pixel value for corner-rounding to prevent visual glitches
    const float mini_map_node_rounding =
        floorf(node.LayoutStyle.CornerRounding * editor.MiniMapScaling);

    ImU32 mini_map_node_background;

    if (editor.ClickInteraction.Type == ImNodesClickInteractionType_None &&
        ImGui::IsMouseHoveringRect(node_rect.Min, node_rect.Max))
    {
        mini_map_node_background = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundHovered];

        // Run user callback when hovering a mini-map node
        if (editor.MiniMapNodeHoveringCallback)
        {
            editor.MiniMapNodeHoveringCallback(node.Id, editor.MiniMapNodeHoveringCallbackUserData);
        }
    }
    else if (editor.SelectedNodeIndices.contains(node_idx))
    {
        mini_map_node_background = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackgroundSelected];
    }
    else
    {
        mini_map_node_background = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeBackground];
    }

    const ImU32 mini_map_node_outline = GImNodes->Style.Colors[ImNodesCol_MiniMapNodeOutline];

    GImNodes->CanvasDrawList->AddRectFilled(
        node_rect.Min, node_rect.Max, mini_map_node_background, mini_map_node_rounding);

    GImNodes->CanvasDrawList->AddRect(
        node_rect.Min, node_rect.Max, mini_map_node_outline, mini_map_node_rounding);
}

static void MiniMapDrawLink(ImNodesEditorContext& editor, const int link_idx)
{
    const ImLinkData& link = editor.Links.Pool[link_idx];
    const ImPinData&  start_pin = editor.Pins.Pool[link.StartPinIdx];
    const ImPinData&  end_pin = editor.Pins.Pool[link.EndPinIdx];

    const CubicBezier cubic_bezier = GetCubicBezier(
        ScreenSpaceToMiniMapSpace(editor, start_pin.Pos),
        ScreenSpaceToMiniMapSpace(editor, end_pin.Pos),
        start_pin.Type,
        GImNodes->Style.LinkLineSegmentsPerLength / editor.MiniMapScaling);

    // It's possible for a link to be deleted in begin_link_interaction. A user
    // may detach a link, resulting in the link wire snapping to the mouse
    // position.
    //
    // In other words, skip rendering the link if it was deleted.
    if (GImNodes->DeletedLinkIdx == link_idx)
    {
        return;
    }

    const ImU32 link_color =
        GImNodes->Style.Colors
            [editor.SelectedLinkIndices.contains(link_idx) ? ImNodesCol_MiniMapLinkSelected
                                                           : ImNodesCol_MiniMapLink];

#if IMGUI_VERSION_NUM < 18000
    GImNodes->CanvasDrawList->AddBezierCurve(
#else
    GImNodes->CanvasDrawList->AddBezierCubic(
#endif
        cubic_bezier.P0,
        cubic_bezier.P1,
        cubic_bezier.P2,
        cubic_bezier.P3,
        link_color,
        GImNodes->Style.LinkThickness * editor.MiniMapScaling,
        cubic_bezier.NumSegments);
}

static void MiniMapUpdate()
{
    ImNodesEditorContext& editor = EditorContextGet();

    ImU32 mini_map_background;

    if (IsMiniMapHovered())
    {
        mini_map_background = GImNodes->Style.Colors[ImNodesCol_MiniMapBackgroundHovered];
    }
    else
    {
        mini_map_background = GImNodes->Style.Colors[ImNodesCol_MiniMapBackground];
    }

    // Create a child window bellow mini-map, so it blocks all mouse interaction on canvas.
    int flags = ImGuiWindowFlags_NoBackground;
    ImGui::SetCursorScreenPos(editor.MiniMapRectScreenSpace.Min);
    ImGui::BeginChild("minimap", editor.MiniMapRectScreenSpace.GetSize(), false, flags);

    const ImRect& mini_map_rect = editor.MiniMapRectScreenSpace;

    // Draw minimap background and border
    GImNodes->CanvasDrawList->AddRectFilled(
        mini_map_rect.Min, mini_map_rect.Max, mini_map_background);

    GImNodes->CanvasDrawList->AddRect(
        mini_map_rect.Min, mini_map_rect.Max, GImNodes->Style.Colors[ImNodesCol_MiniMapOutline]);

    // Clip draw list items to mini-map rect (after drawing background/outline)
    GImNodes->CanvasDrawList->PushClipRect(
        mini_map_rect.Min, mini_map_rect.Max, true /* intersect with editor clip-rect */);

    // Draw links first so they appear under nodes, and we can use the same draw channel
    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)
    {
        if (editor.Links.InUse[link_idx])
        {
            MiniMapDrawLink(editor, link_idx);
        }
    }

    for (int node_idx = 0; node_idx < editor.Nodes.Pool.size(); ++node_idx)
    {
        if (editor.Nodes.InUse[node_idx])
        {
            MiniMapDrawNode(editor, node_idx);
        }
    }

    // Draw editor canvas rect inside mini-map
    {
        const ImU32  canvas_color = GImNodes->Style.Colors[ImNodesCol_MiniMapCanvas];
        const ImU32  outline_color = GImNodes->Style.Colors[ImNodesCol_MiniMapCanvasOutline];
        const ImRect rect = ScreenSpaceToMiniMapSpace(editor, GImNodes->CanvasRectScreenSpace);

        GImNodes->CanvasDrawList->AddRectFilled(rect.Min, rect.Max, canvas_color);
        GImNodes->CanvasDrawList->AddRect(rect.Min, rect.Max, outline_color);
    }

    // Have to pop mini-map clip rect
    GImNodes->CanvasDrawList->PopClipRect();

    bool mini_map_is_hovered = ImGui::IsWindowHovered();

    ImGui::EndChild();

    bool center_on_click = mini_map_is_hovered && ImGui::IsMouseDown(ImGuiMouseButton_Left) &&
                           editor.ClickInteraction.Type == ImNodesClickInteractionType_None &&
                           !GImNodes->NodeIdxSubmissionOrder.empty();
    if (center_on_click)
    {
        ImVec2 target = MiniMapSpaceToGridSpace(editor, ImGui::GetMousePos());
        ImVec2 center = GImNodes->CanvasRectScreenSpace.GetSize() * 0.5f;
        editor.Panning = ImFloor(center - target);
    }

    // Reset callback info after use
    editor.MiniMapNodeHoveringCallback = NULL;
    editor.MiniMapNodeHoveringCallbackUserData = NULL;
}

// [SECTION] selection helpers

template<typename T>
void SelectObject(const ImObjectPool<T>& objects, ImVector<int>& selected_indices, const int id)
{
    const int idx = ObjectPoolFind(objects, id);
    IM_ASSERT(idx >= 0);
    IM_ASSERT(selected_indices.find(idx) == selected_indices.end());
    selected_indices.push_back(idx);
}

template<typename T>
void ClearObjectSelection(
    const ImObjectPool<T>& objects,
    ImVector<int>&         selected_indices,
    const int              id)
{
    const int idx = ObjectPoolFind(objects, id);
    IM_ASSERT(idx >= 0);
    IM_ASSERT(selected_indices.find(idx) != selected_indices.end());
    selected_indices.find_erase_unsorted(idx);
}

template<typename T>
bool IsObjectSelected(const ImObjectPool<T>& objects, ImVector<int>& selected_indices, const int id)
{
    const int idx = ObjectPoolFind(objects, id);
    return selected_indices.find(idx) != selected_indices.end();
}

} // namespace
} // namespace IMNODES_NAMESPACE

// [SECTION] API implementation

ImNodesIO::EmulateThreeButtonMouse::EmulateThreeButtonMouse() : Modifier(NULL) {}

ImNodesIO::LinkDetachWithModifierClick::LinkDetachWithModifierClick() : Modifier(NULL) {}

ImNodesIO::MultipleSelectModifier::MultipleSelectModifier() : Modifier(NULL) {}

ImNodesIO::ImNodesIO()
    : EmulateThreeButtonMouse(), LinkDetachWithModifierClick(),
      AltMouseButton(ImGuiMouseButton_Middle), AutoPanningSpeed(1000.0f)
{
}

ImNodesStyle::ImNodesStyle()
    : GridSpacing(24.f), NodeCornerRounding(4.f), NodePadding(8.f, 8.f), NodeBorderThickness(1.f),
      LinkThickness(3.f), LinkLineSegmentsPerLength(0.1f), LinkHoverDistance(10.f),
      PinCircleRadius(4.f), PinQuadSideLength(7.f), PinTriangleSideLength(9.5),
      PinLineThickness(1.f), PinHoverRadius(10.f), PinOffset(0.f), MiniMapPadding(8.0f, 8.0f),
      MiniMapOffset(4.0f, 4.0f), Flags(ImNodesStyleFlags_NodeOutline | ImNodesStyleFlags_GridLines),
      Colors()
{
}

namespace IMNODES_NAMESPACE
{
ImNodesContext* CreateContext()
{
    ImNodesContext* ctx = IM_NEW(ImNodesContext)();
    if (GImNodes == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void DestroyContext(ImNodesContext* ctx)
{
    if (ctx == NULL)
        ctx = GImNodes;
    Shutdown(ctx);
    if (GImNodes == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

ImNodesContext* GetCurrentContext() { return GImNodes; }

void SetCurrentContext(ImNodesContext* ctx) { GImNodes = ctx; }

ImNodesEditorContext* EditorContextCreate()
{
    void* mem = ImGui::MemAlloc(sizeof(ImNodesEditorContext));
    new (mem) ImNodesEditorContext();
    return (ImNodesEditorContext*)mem;
}

void EditorContextFree(ImNodesEditorContext* ctx)
{
    ctx->~ImNodesEditorContext();
    ImGui::MemFree(ctx);
}

void EditorContextSet(ImNodesEditorContext* ctx) { GImNodes->EditorCtx = ctx; }

ImVec2 EditorContextGetPanning()
{
    const ImNodesEditorContext& editor = EditorContextGet();
    return editor.Panning;
}

void EditorContextResetPanning(const ImVec2& pos)
{
    ImNodesEditorContext& editor = EditorContextGet();
    editor.Panning = pos;
}

void EditorContextMoveToNode(const int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);

    editor.Panning.x = -node.Origin.x;
    editor.Panning.y = -node.Origin.y;
}

void SetImGuiContext(ImGuiContext* ctx) { ImGui::SetCurrentContext(ctx); }

ImNodesIO& GetIO() { return GImNodes->Io; }

ImNodesStyle& GetStyle() { return GImNodes->Style; }

void StyleColorsDark(ImNodesStyle* dest)
{
    if (dest == nullptr)
    {
        dest = &GImNodes->Style;
    }

    dest->Colors[ImNodesCol_NodeBackground] = IM_COL32(50, 50, 50, 255);
    dest->Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(75, 75, 75, 255);
    dest->Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(75, 75, 75, 255);
    dest->Colors[ImNodesCol_NodeOutline] = IM_COL32(100, 100, 100, 255);
    // title bar colors match ImGui's titlebg colors
    dest->Colors[ImNodesCol_TitleBar] = IM_COL32(41, 74, 122, 255);
    dest->Colors[ImNodesCol_TitleBarHovered] = IM_COL32(66, 150, 250, 255);
    dest->Colors[ImNodesCol_TitleBarSelected] = IM_COL32(66, 150, 250, 255);
    // link colors match ImGui's slider grab colors
    dest->Colors[ImNodesCol_Link] = IM_COL32(61, 133, 224, 200);
    dest->Colors[ImNodesCol_LinkHovered] = IM_COL32(66, 150, 250, 255);
    dest->Colors[ImNodesCol_LinkSelected] = IM_COL32(66, 150, 250, 255);
    // pin colors match ImGui's button colors
    dest->Colors[ImNodesCol_Pin] = IM_COL32(53, 150, 250, 180);
    dest->Colors[ImNodesCol_PinHovered] = IM_COL32(53, 150, 250, 255);

    dest->Colors[ImNodesCol_BoxSelector] = IM_COL32(61, 133, 224, 30);
    dest->Colors[ImNodesCol_BoxSelectorOutline] = IM_COL32(61, 133, 224, 150);

    dest->Colors[ImNodesCol_GridBackground] = IM_COL32(40, 40, 50, 200);
    dest->Colors[ImNodesCol_GridLine] = IM_COL32(200, 200, 200, 40);
    dest->Colors[ImNodesCol_GridLinePrimary] = IM_COL32(240, 240, 240, 60);

    // minimap colors
    dest->Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 150);
    dest->Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);
    dest->Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);
    dest->Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);
    dest->Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);
    dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered] = IM_COL32(200, 200, 200, 255);
    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] =
        dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered];
    dest->Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);
    dest->Colors[ImNodesCol_MiniMapLink] = dest->Colors[ImNodesCol_Link];
    dest->Colors[ImNodesCol_MiniMapLinkSelected] = dest->Colors[ImNodesCol_LinkSelected];
    dest->Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);
    dest->Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);
}

void StyleColorsClassic(ImNodesStyle* dest)
{
    if (dest == nullptr)
    {
        dest = &GImNodes->Style;
    }

    dest->Colors[ImNodesCol_NodeBackground] = IM_COL32(50, 50, 50, 255);
    dest->Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(75, 75, 75, 255);
    dest->Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(75, 75, 75, 255);
    dest->Colors[ImNodesCol_NodeOutline] = IM_COL32(100, 100, 100, 255);
    dest->Colors[ImNodesCol_TitleBar] = IM_COL32(69, 69, 138, 255);
    dest->Colors[ImNodesCol_TitleBarHovered] = IM_COL32(82, 82, 161, 255);
    dest->Colors[ImNodesCol_TitleBarSelected] = IM_COL32(82, 82, 161, 255);
    dest->Colors[ImNodesCol_Link] = IM_COL32(255, 255, 255, 100);
    dest->Colors[ImNodesCol_LinkHovered] = IM_COL32(105, 99, 204, 153);
    dest->Colors[ImNodesCol_LinkSelected] = IM_COL32(105, 99, 204, 153);
    dest->Colors[ImNodesCol_Pin] = IM_COL32(89, 102, 156, 170);
    dest->Colors[ImNodesCol_PinHovered] = IM_COL32(102, 122, 179, 200);
    dest->Colors[ImNodesCol_BoxSelector] = IM_COL32(82, 82, 161, 100);
    dest->Colors[ImNodesCol_BoxSelectorOutline] = IM_COL32(82, 82, 161, 255);
    dest->Colors[ImNodesCol_GridBackground] = IM_COL32(40, 40, 50, 200);
    dest->Colors[ImNodesCol_GridLine] = IM_COL32(200, 200, 200, 40);
    dest->Colors[ImNodesCol_GridLinePrimary] = IM_COL32(240, 240, 240, 60);

    // minimap colors
    dest->Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 100);
    dest->Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);
    dest->Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);
    dest->Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);
    dest->Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);
    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] =
        dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered];
    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] = IM_COL32(200, 200, 240, 255);
    dest->Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);
    dest->Colors[ImNodesCol_MiniMapLink] = dest->Colors[ImNodesCol_Link];
    dest->Colors[ImNodesCol_MiniMapLinkSelected] = dest->Colors[ImNodesCol_LinkSelected];
    dest->Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);
    dest->Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);
}

void StyleColorsLight(ImNodesStyle* dest)
{
    if (dest == nullptr)
    {
        dest = &GImNodes->Style;
    }

    dest->Colors[ImNodesCol_NodeBackground] = IM_COL32(240, 240, 240, 255);
    dest->Colors[ImNodesCol_NodeBackgroundHovered] = IM_COL32(240, 240, 240, 255);
    dest->Colors[ImNodesCol_NodeBackgroundSelected] = IM_COL32(240, 240, 240, 255);
    dest->Colors[ImNodesCol_NodeOutline] = IM_COL32(100, 100, 100, 255);
    dest->Colors[ImNodesCol_TitleBar] = IM_COL32(248, 248, 248, 255);
    dest->Colors[ImNodesCol_TitleBarHovered] = IM_COL32(209, 209, 209, 255);
    dest->Colors[ImNodesCol_TitleBarSelected] = IM_COL32(209, 209, 209, 255);
    // original imgui values: 66, 150, 250
    dest->Colors[ImNodesCol_Link] = IM_COL32(66, 150, 250, 100);
    // original imgui values: 117, 138, 204
    dest->Colors[ImNodesCol_LinkHovered] = IM_COL32(66, 150, 250, 242);
    dest->Colors[ImNodesCol_LinkSelected] = IM_COL32(66, 150, 250, 242);
    // original imgui values: 66, 150, 250
    dest->Colors[ImNodesCol_Pin] = IM_COL32(66, 150, 250, 160);
    dest->Colors[ImNodesCol_PinHovered] = IM_COL32(66, 150, 250, 255);
    dest->Colors[ImNodesCol_BoxSelector] = IM_COL32(90, 170, 250, 30);
    dest->Colors[ImNodesCol_BoxSelectorOutline] = IM_COL32(90, 170, 250, 150);
    dest->Colors[ImNodesCol_GridBackground] = IM_COL32(225, 225, 225, 255);
    dest->Colors[ImNodesCol_GridLine] = IM_COL32(180, 180, 180, 100);
    dest->Colors[ImNodesCol_GridLinePrimary] = IM_COL32(120, 120, 120, 100);

    // minimap colors
    dest->Colors[ImNodesCol_MiniMapBackground] = IM_COL32(25, 25, 25, 100);
    dest->Colors[ImNodesCol_MiniMapBackgroundHovered] = IM_COL32(25, 25, 25, 200);
    dest->Colors[ImNodesCol_MiniMapOutline] = IM_COL32(150, 150, 150, 100);
    dest->Colors[ImNodesCol_MiniMapOutlineHovered] = IM_COL32(150, 150, 150, 200);
    dest->Colors[ImNodesCol_MiniMapNodeBackground] = IM_COL32(200, 200, 200, 100);
    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] =
        dest->Colors[ImNodesCol_MiniMapNodeBackgroundHovered];
    dest->Colors[ImNodesCol_MiniMapNodeBackgroundSelected] = IM_COL32(200, 200, 240, 255);
    dest->Colors[ImNodesCol_MiniMapNodeOutline] = IM_COL32(200, 200, 200, 100);
    dest->Colors[ImNodesCol_MiniMapLink] = dest->Colors[ImNodesCol_Link];
    dest->Colors[ImNodesCol_MiniMapLinkSelected] = dest->Colors[ImNodesCol_LinkSelected];
    dest->Colors[ImNodesCol_MiniMapCanvas] = IM_COL32(200, 200, 200, 25);
    dest->Colors[ImNodesCol_MiniMapCanvasOutline] = IM_COL32(200, 200, 200, 200);
}

void BeginNodeEditor()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    GImNodes->CurrentScope = ImNodesScope_Editor;

    // Reset state from previous pass

    ImNodesEditorContext& editor = EditorContextGet();
    editor.AutoPanningDelta = ImVec2(0, 0);
    editor.GridContentBounds = ImRect(FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX);
    editor.MiniMapEnabled = false;
    ObjectPoolReset(editor.Nodes);
    ObjectPoolReset(editor.Pins);
    ObjectPoolReset(editor.Links);

    GImNodes->HoveredNodeIdx.Reset();
    GImNodes->HoveredLinkIdx.Reset();
    GImNodes->HoveredPinIdx.Reset();
    GImNodes->DeletedLinkIdx.Reset();
    GImNodes->SnapLinkIdx.Reset();

    GImNodes->NodeIndicesOverlappingWithMouse.clear();

    GImNodes->ImNodesUIState = ImNodesUIState_None;

    GImNodes->MousePos = ImGui::GetIO().MousePos;
    GImNodes->LeftMouseClicked = ImGui::IsMouseClicked(0);
    GImNodes->LeftMouseReleased = ImGui::IsMouseReleased(0);
    GImNodes->LeftMouseDragging = ImGui::IsMouseDragging(0, 0.0f);
    GImNodes->AltMouseClicked =
        (GImNodes->Io.EmulateThreeButtonMouse.Modifier != NULL &&
         *GImNodes->Io.EmulateThreeButtonMouse.Modifier && GImNodes->LeftMouseClicked) ||
        ImGui::IsMouseClicked(GImNodes->Io.AltMouseButton);
    GImNodes->AltMouseDragging =
        (GImNodes->Io.EmulateThreeButtonMouse.Modifier != NULL && GImNodes->LeftMouseDragging &&
         (*GImNodes->Io.EmulateThreeButtonMouse.Modifier)) ||
        ImGui::IsMouseDragging(GImNodes->Io.AltMouseButton, 0.0f);
    GImNodes->AltMouseScrollDelta = ImGui::GetIO().MouseWheel;
    GImNodes->MultipleSelectModifier =
        (GImNodes->Io.MultipleSelectModifier.Modifier != NULL
             ? *GImNodes->Io.MultipleSelectModifier.Modifier
             : ImGui::GetIO().KeyCtrl);

    GImNodes->ActiveAttribute = false;

    ImGui::BeginGroup();
    {
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(1.f, 1.f));
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.f, 0.f));
        ImGui::PushStyleColor(ImGuiCol_ChildBg, GImNodes->Style.Colors[ImNodesCol_GridBackground]);
        ImGui::BeginChild(
            "scrolling_region",
            ImVec2(0.f, 0.f),
            true,
            ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoMove |
                ImGuiWindowFlags_NoScrollWithMouse);
        GImNodes->CanvasOriginScreenSpace = ImGui::GetCursorScreenPos();

        // NOTE: we have to fetch the canvas draw list *after* we call
        // BeginChild(), otherwise the ImGui UI elements are going to be
        // rendered into the parent window draw list.
        DrawListSet(ImGui::GetWindowDrawList());

        {
            const ImVec2 canvas_size = ImGui::GetWindowSize();
            GImNodes->CanvasRectScreenSpace = ImRect(
                EditorSpaceToScreenSpace(ImVec2(0.f, 0.f)), EditorSpaceToScreenSpace(canvas_size));

            if (GImNodes->Style.Flags & ImNodesStyleFlags_GridLines)
            {
                DrawGrid(editor, canvas_size);
            }
        }
    }
}

void EndNodeEditor()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);
    GImNodes->CurrentScope = ImNodesScope_None;

    ImNodesEditorContext& editor = EditorContextGet();

    bool no_grid_content = editor.GridContentBounds.IsInverted();
    if (no_grid_content)
    {
        editor.GridContentBounds = ScreenSpaceToGridSpace(editor, GImNodes->CanvasRectScreenSpace);
    }

    // Detect ImGui interaction first, because it blocks interaction with the rest of the UI

    if (GImNodes->LeftMouseClicked && ImGui::IsAnyItemActive())
    {
        editor.ClickInteraction.Type = ImNodesClickInteractionType_ImGuiItem;
    }

    // Detect which UI element is being hovered over. Detection is done in a hierarchical fashion,
    // because a UI element being hovered excludes any other as being hovered over.

    // Don't do hovering detection for nodes/links/pins when interacting with the mini-map, since
    // its an *overlay* with its own interaction behavior and must have precedence during mouse
    // interaction.

    if ((editor.ClickInteraction.Type == ImNodesClickInteractionType_None ||
         editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation) &&
        MouseInCanvas() && !IsMiniMapHovered())
    {
        // Pins needs some special care. We need to check the depth stack to see which pins are
        // being occluded by other nodes.
        ResolveOccludedPins(editor, GImNodes->OccludedPinIndices);

        GImNodes->HoveredPinIdx = ResolveHoveredPin(editor.Pins, GImNodes->OccludedPinIndices);

        if (!GImNodes->HoveredPinIdx.HasValue())
        {
            // Resolve which node is actually on top and being hovered using the depth stack.
            GImNodes->HoveredNodeIdx = ResolveHoveredNode(editor.NodeDepthOrder);
        }

        // We don't check for hovered pins here, because if we want to detach a link by clicking and
        // dragging, we need to have both a link and pin hovered.
        if (!GImNodes->HoveredNodeIdx.HasValue())
        {
            GImNodes->HoveredLinkIdx = ResolveHoveredLink(editor.Links, editor.Pins);
        }
    }

    for (int node_idx = 0; node_idx < editor.Nodes.Pool.size(); ++node_idx)
    {
        if (editor.Nodes.InUse[node_idx])
        {
            DrawListActivateNodeBackground(node_idx);
            DrawNode(editor, node_idx);
        }
    }

    // In order to render the links underneath the nodes, we want to first select the bottom draw
    // channel.
    GImNodes->CanvasDrawList->ChannelsSetCurrent(0);

    for (int link_idx = 0; link_idx < editor.Links.Pool.size(); ++link_idx)
    {
        if (editor.Links.InUse[link_idx])
        {
            DrawLink(editor, link_idx);
        }
    }

    // Render the click interaction UI elements (partial links, box selector) on top of everything
    // else.

    DrawListAppendClickInteractionChannel();
    DrawListActivateClickInteractionChannel();

    if (IsMiniMapActive())
    {
        CalcMiniMapLayout();
        MiniMapUpdate();
    }

    // Handle node graph interaction

    if (!IsMiniMapHovered())
    {
        if (GImNodes->LeftMouseClicked && GImNodes->HoveredLinkIdx.HasValue())
        {
            BeginLinkInteraction(editor, GImNodes->HoveredLinkIdx.Value(), GImNodes->HoveredPinIdx);
        }

        else if (GImNodes->LeftMouseClicked && GImNodes->HoveredPinIdx.HasValue())
        {
            BeginLinkCreation(editor, GImNodes->HoveredPinIdx.Value());
        }

        else if (GImNodes->LeftMouseClicked && GImNodes->HoveredNodeIdx.HasValue())
        {
            BeginNodeSelection(editor, GImNodes->HoveredNodeIdx.Value());
        }

        else if (
            GImNodes->LeftMouseClicked || GImNodes->LeftMouseReleased ||
            GImNodes->AltMouseClicked || GImNodes->AltMouseScrollDelta != 0.f)
        {
            BeginCanvasInteraction(editor);
        }

        bool should_auto_pan =
            editor.ClickInteraction.Type == ImNodesClickInteractionType_BoxSelection ||
            editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation ||
            editor.ClickInteraction.Type == ImNodesClickInteractionType_Node;
        if (should_auto_pan && !MouseInCanvas())
        {
            ImVec2 mouse = ImGui::GetMousePos();
            ImVec2 center = GImNodes->CanvasRectScreenSpace.GetCenter();
            ImVec2 direction = (center - mouse);
            direction = direction * ImInvLength(direction, 0.0);

            editor.AutoPanningDelta =
                direction * ImGui::GetIO().DeltaTime * GImNodes->Io.AutoPanningSpeed;
            editor.Panning += editor.AutoPanningDelta;
        }
    }
    ClickInteractionUpdate(editor);

    // At this point, draw commands have been issued for all nodes (and pins). Update the node pool
    // to detect unused node slots and remove those indices from the depth stack before sorting the
    // node draw commands by depth.
    ObjectPoolUpdate(editor.Nodes);
    ObjectPoolUpdate(editor.Pins);

    DrawListSortChannelsByDepth(editor.NodeDepthOrder);

    // After the links have been rendered, the link pool can be updated as well.
    ObjectPoolUpdate(editor.Links);

    // Finally, merge the draw channels
    GImNodes->CanvasDrawList->ChannelsMerge();

    // pop style
    ImGui::EndChild();      // end scrolling region
    ImGui::PopStyleColor(); // pop child window background color
    ImGui::PopStyleVar();   // pop window padding
    ImGui::PopStyleVar();   // pop frame padding
    ImGui::EndGroup();
}

void MiniMap(
    const float                                      minimap_size_fraction,
    const ImNodesMiniMapLocation                     location,
    const ImNodesMiniMapNodeHoveringCallback         node_hovering_callback,
    const ImNodesMiniMapNodeHoveringCallbackUserData node_hovering_callback_data)
{
    // Check that editor size fraction is sane; must be in the range (0, 1]
    IM_ASSERT(minimap_size_fraction > 0.f && minimap_size_fraction <= 1.f);

    // Remember to call before EndNodeEditor
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);

    ImNodesEditorContext& editor = EditorContextGet();

    editor.MiniMapEnabled = true;
    editor.MiniMapSizeFraction = minimap_size_fraction;
    editor.MiniMapLocation = location;

    // Set node hovering callback information
    editor.MiniMapNodeHoveringCallback = node_hovering_callback;
    editor.MiniMapNodeHoveringCallbackUserData = node_hovering_callback_data;

    // Actual drawing/updating of the MiniMap is done in EndNodeEditor so that
    // mini map is draw over everything and all pin/link positions are updated
    // correctly relative to their respective nodes. Hence, we must store some of
    // of the state for the mini map in GImNodes for the actual drawing/updating
}

void BeginNode(const int node_id)
{
    // Remember to call BeginNodeEditor before calling BeginNode
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);
    GImNodes->CurrentScope = ImNodesScope_Node;

    ImNodesEditorContext& editor = EditorContextGet();

    const int node_idx = ObjectPoolFindOrCreateIndex(editor.Nodes, node_id);
    GImNodes->CurrentNodeIdx = node_idx;

    ImNodeData& node = editor.Nodes.Pool[node_idx];
    node.ColorStyle.Background = GImNodes->Style.Colors[ImNodesCol_NodeBackground];
    node.ColorStyle.BackgroundHovered = GImNodes->Style.Colors[ImNodesCol_NodeBackgroundHovered];
    node.ColorStyle.BackgroundSelected = GImNodes->Style.Colors[ImNodesCol_NodeBackgroundSelected];
    node.ColorStyle.Outline = GImNodes->Style.Colors[ImNodesCol_NodeOutline];
    node.ColorStyle.Titlebar = GImNodes->Style.Colors[ImNodesCol_TitleBar];
    node.ColorStyle.TitlebarHovered = GImNodes->Style.Colors[ImNodesCol_TitleBarHovered];
    node.ColorStyle.TitlebarSelected = GImNodes->Style.Colors[ImNodesCol_TitleBarSelected];
    node.LayoutStyle.CornerRounding = GImNodes->Style.NodeCornerRounding;
    node.LayoutStyle.Padding = GImNodes->Style.NodePadding;
    node.LayoutStyle.BorderThickness = GImNodes->Style.NodeBorderThickness;

    // ImGui::SetCursorPos sets the cursor position, local to the current widget
    // (in this case, the child object started in BeginNodeEditor). Use
    // ImGui::SetCursorScreenPos to set the screen space coordinates directly.
    ImGui::SetCursorPos(GridSpaceToEditorSpace(editor, GetNodeTitleBarOrigin(node)));

    DrawListAddNode(node_idx);
    DrawListActivateCurrentNodeForeground();

    ImGui::PushID(node.Id);
    ImGui::BeginGroup();
}

void EndNode()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);
    GImNodes->CurrentScope = ImNodesScope_Editor;

    ImNodesEditorContext& editor = EditorContextGet();

    // The node's rectangle depends on the ImGui UI group size.
    ImGui::EndGroup();
    ImGui::PopID();

    ImNodeData& node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];
    node.Rect = GetItemRect();
    node.Rect.Expand(node.LayoutStyle.Padding);

    editor.GridContentBounds.Add(node.Origin);
    editor.GridContentBounds.Add(node.Origin + node.Rect.GetSize());

    if (node.Rect.Contains(GImNodes->MousePos))
    {
        GImNodes->NodeIndicesOverlappingWithMouse.push_back(GImNodes->CurrentNodeIdx);
    }
}

ImVec2 GetNodeDimensions(int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);
    IM_ASSERT(node_idx != -1); // invalid node_id
    const ImNodeData& node = editor.Nodes.Pool[node_idx];
    return node.Rect.GetSize();
}

void BeginNodeTitleBar()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);
    ImGui::BeginGroup();
}

void EndNodeTitleBar()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);
    ImGui::EndGroup();

    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];
    node.TitleBarContentRect = GetItemRect();

    ImGui::ItemAdd(GetNodeTitleRect(node), ImGui::GetID("title_bar"));

    ImGui::SetCursorPos(GridSpaceToEditorSpace(editor, GetNodeContentOrigin(node)));
}

void BeginInputAttribute(const int id, const ImNodesPinShape shape)
{
    BeginPinAttribute(id, ImNodesAttributeType_Input, shape, GImNodes->CurrentNodeIdx);
}

void EndInputAttribute() { EndPinAttribute(); }

void BeginOutputAttribute(const int id, const ImNodesPinShape shape)
{
    BeginPinAttribute(id, ImNodesAttributeType_Output, shape, GImNodes->CurrentNodeIdx);
}

void EndOutputAttribute() { EndPinAttribute(); }

void BeginStaticAttribute(const int id)
{
    // Make sure to call BeginNode() before calling BeginAttribute()
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Node);
    GImNodes->CurrentScope = ImNodesScope_Attribute;

    GImNodes->CurrentAttributeId = id;

    ImGui::BeginGroup();
    ImGui::PushID(id);
}

void EndStaticAttribute()
{
    // Make sure to call BeginNode() before calling BeginAttribute()
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Attribute);
    GImNodes->CurrentScope = ImNodesScope_Node;

    ImGui::PopID();
    ImGui::EndGroup();

    if (ImGui::IsItemActive())
    {
        GImNodes->ActiveAttribute = true;
        GImNodes->ActiveAttributeId = GImNodes->CurrentAttributeId;
    }
}

void PushAttributeFlag(const ImNodesAttributeFlags flag)
{
    GImNodes->CurrentAttributeFlags |= flag;
    GImNodes->AttributeFlagStack.push_back(GImNodes->CurrentAttributeFlags);
}

void PopAttributeFlag()
{
    // PopAttributeFlag called without a matching PushAttributeFlag!
    // The bottom value is always the default value, pushed in Initialize().
    IM_ASSERT(GImNodes->AttributeFlagStack.size() > 1);

    GImNodes->AttributeFlagStack.pop_back();
    GImNodes->CurrentAttributeFlags = GImNodes->AttributeFlagStack.back();
}

void Link(const int id, const int start_attr_id, const int end_attr_id)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_Editor);

    ImNodesEditorContext& editor = EditorContextGet();
    ImLinkData&           link = ObjectPoolFindOrCreateObject(editor.Links, id);
    link.Id = id;
    link.StartPinIdx = ObjectPoolFindOrCreateIndex(editor.Pins, start_attr_id);
    link.EndPinIdx = ObjectPoolFindOrCreateIndex(editor.Pins, end_attr_id);
    link.ColorStyle.Base = GImNodes->Style.Colors[ImNodesCol_Link];
    link.ColorStyle.Hovered = GImNodes->Style.Colors[ImNodesCol_LinkHovered];
    link.ColorStyle.Selected = GImNodes->Style.Colors[ImNodesCol_LinkSelected];

    // Check if this link was created by the current link event
    if ((editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation &&
         editor.Pins.Pool[link.EndPinIdx].Flags & ImNodesAttributeFlags_EnableLinkCreationOnSnap &&
         editor.ClickInteraction.LinkCreation.StartPinIdx == link.StartPinIdx &&
         editor.ClickInteraction.LinkCreation.EndPinIdx == link.EndPinIdx) ||
        (editor.ClickInteraction.LinkCreation.StartPinIdx == link.EndPinIdx &&
         editor.ClickInteraction.LinkCreation.EndPinIdx == link.StartPinIdx))
    {
        GImNodes->SnapLinkIdx = ObjectPoolFindOrCreateIndex(editor.Links, id);
    }
}

void PushColorStyle(const ImNodesCol item, unsigned int color)
{
    GImNodes->ColorModifierStack.push_back(ImNodesColElement(GImNodes->Style.Colors[item], item));
    GImNodes->Style.Colors[item] = color;
}

void PopColorStyle()
{
    IM_ASSERT(GImNodes->ColorModifierStack.size() > 0);
    const ImNodesColElement elem = GImNodes->ColorModifierStack.back();
    GImNodes->Style.Colors[elem.Item] = elem.Color;
    GImNodes->ColorModifierStack.pop_back();
}

struct ImNodesStyleVarInfo
{
    ImGuiDataType Type;
    ImU32         Count;
    ImU32         Offset;
    void* GetVarPtr(ImNodesStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImNodesStyleVarInfo GStyleVarInfo[] = {
    // ImNodesStyleVar_GridSpacing
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, GridSpacing)},
    // ImNodesStyleVar_NodeCornerRounding
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, NodeCornerRounding)},
    // ImNodesStyleVar_NodePadding
    {ImGuiDataType_Float, 2, (ImU32)offsetof(ImNodesStyle, NodePadding)},
    // ImNodesStyleVar_NodeBorderThickness
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, NodeBorderThickness)},
    // ImNodesStyleVar_LinkThickness
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, LinkThickness)},
    // ImNodesStyleVar_LinkLineSegmentsPerLength
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, LinkLineSegmentsPerLength)},
    // ImNodesStyleVar_LinkHoverDistance
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, LinkHoverDistance)},
    // ImNodesStyleVar_PinCircleRadius
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinCircleRadius)},
    // ImNodesStyleVar_PinQuadSideLength
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinQuadSideLength)},
    // ImNodesStyleVar_PinTriangleSideLength
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinTriangleSideLength)},
    // ImNodesStyleVar_PinLineThickness
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinLineThickness)},
    // ImNodesStyleVar_PinHoverRadius
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinHoverRadius)},
    // ImNodesStyleVar_PinOffset
    {ImGuiDataType_Float, 1, (ImU32)offsetof(ImNodesStyle, PinOffset)},
    // ImNodesStyleVar_MiniMapPadding
    {ImGuiDataType_Float, 2, (ImU32)offsetof(ImNodesStyle, MiniMapPadding)},
    // ImNodesStyleVar_MiniMapOffset
    {ImGuiDataType_Float, 2, (ImU32)offsetof(ImNodesStyle, MiniMapOffset)},
};

static const ImNodesStyleVarInfo* GetStyleVarInfo(ImNodesStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < ImNodesStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImNodesStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void PushStyleVar(const ImNodesStyleVar item, const float value)
{
    const ImNodesStyleVarInfo* var_info = GetStyleVarInfo(item);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        float& style_var = *(float*)var_info->GetVarPtr(&GImNodes->Style);
        GImNodes->StyleModifierStack.push_back(ImNodesStyleVarElement(item, style_var));
        style_var = value;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() float variant but variable is not a float!");
}

void PushStyleVar(const ImNodesStyleVar item, const ImVec2& value)
{
    const ImNodesStyleVarInfo* var_info = GetStyleVarInfo(item);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImVec2& style_var = *(ImVec2*)var_info->GetVarPtr(&GImNodes->Style);
        GImNodes->StyleModifierStack.push_back(ImNodesStyleVarElement(item, style_var));
        style_var = value;
        return;
    }
    IM_ASSERT(0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!");
}

void PopStyleVar(int count)
{
    while (count > 0)
    {
        IM_ASSERT(GImNodes->StyleModifierStack.size() > 0);
        const ImNodesStyleVarElement style_backup = GImNodes->StyleModifierStack.back();
        GImNodes->StyleModifierStack.pop_back();
        const ImNodesStyleVarInfo* var_info = GetStyleVarInfo(style_backup.Item);
        void*                      style_var = var_info->GetVarPtr(&GImNodes->Style);
        if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
        {
            ((float*)style_var)[0] = style_backup.FloatValue[0];
        }
        else if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
        {
            ((float*)style_var)[0] = style_backup.FloatValue[0];
            ((float*)style_var)[1] = style_backup.FloatValue[1];
        }
        count--;
    }
}

void SetNodeScreenSpacePos(const int node_id, const ImVec2& screen_space_pos)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);
    node.Origin = ScreenSpaceToGridSpace(editor, screen_space_pos);
}

void SetNodeEditorSpacePos(const int node_id, const ImVec2& editor_space_pos)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);
    node.Origin = EditorSpaceToGridSpace(editor, editor_space_pos);
}

void SetNodeGridSpacePos(const int node_id, const ImVec2& grid_pos)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);
    node.Origin = grid_pos;
}

void SetNodeDraggable(const int node_id, const bool draggable)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);
    node.Draggable = draggable;
}

ImVec2 GetNodeScreenSpacePos(const int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);
    IM_ASSERT(node_idx != -1);
    ImNodeData& node = editor.Nodes.Pool[node_idx];
    return GridSpaceToScreenSpace(editor, node.Origin);
}

ImVec2 GetNodeEditorSpacePos(const int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);
    IM_ASSERT(node_idx != -1);
    ImNodeData& node = editor.Nodes.Pool[node_idx];
    return GridSpaceToEditorSpace(editor, node.Origin);
}

ImVec2 GetNodeGridSpacePos(const int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    const int             node_idx = ObjectPoolFind(editor.Nodes, node_id);
    IM_ASSERT(node_idx != -1);
    ImNodeData& node = editor.Nodes.Pool[node_idx];
    return node.Origin;
}

void SnapNodeToGrid(int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ImNodeData&           node = ObjectPoolFindOrCreateObject(editor.Nodes, node_id);
    node.Origin = SnapOriginToGrid(node.Origin);
}

bool IsEditorHovered() { return MouseInCanvas(); }

bool IsNodeHovered(int* const node_id)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    IM_ASSERT(node_id != NULL);

    const bool is_hovered = GImNodes->HoveredNodeIdx.HasValue();
    if (is_hovered)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        *node_id = editor.Nodes.Pool[GImNodes->HoveredNodeIdx.Value()].Id;
    }
    return is_hovered;
}

bool IsLinkHovered(int* const link_id)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    IM_ASSERT(link_id != NULL);

    const bool is_hovered = GImNodes->HoveredLinkIdx.HasValue();
    if (is_hovered)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        *link_id = editor.Links.Pool[GImNodes->HoveredLinkIdx.Value()].Id;
    }
    return is_hovered;
}

bool IsPinHovered(int* const attr)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    IM_ASSERT(attr != NULL);

    const bool is_hovered = GImNodes->HoveredPinIdx.HasValue();
    if (is_hovered)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        *attr = editor.Pins.Pool[GImNodes->HoveredPinIdx.Value()].Id;
    }
    return is_hovered;
}

int NumSelectedNodes()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    const ImNodesEditorContext& editor = EditorContextGet();
    return editor.SelectedNodeIndices.size();
}

int NumSelectedLinks()
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    const ImNodesEditorContext& editor = EditorContextGet();
    return editor.SelectedLinkIndices.size();
}

void GetSelectedNodes(int* node_ids)
{
    IM_ASSERT(node_ids != NULL);

    const ImNodesEditorContext& editor = EditorContextGet();
    for (int i = 0; i < editor.SelectedNodeIndices.size(); ++i)
    {
        const int node_idx = editor.SelectedNodeIndices[i];
        node_ids[i] = editor.Nodes.Pool[node_idx].Id;
    }
}

void GetSelectedLinks(int* link_ids)
{
    IM_ASSERT(link_ids != NULL);

    const ImNodesEditorContext& editor = EditorContextGet();
    for (int i = 0; i < editor.SelectedLinkIndices.size(); ++i)
    {
        const int link_idx = editor.SelectedLinkIndices[i];
        link_ids[i] = editor.Links.Pool[link_idx].Id;
    }
}

void ClearNodeSelection()
{
    ImNodesEditorContext& editor = EditorContextGet();
    editor.SelectedNodeIndices.clear();
}

void ClearNodeSelection(int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ClearObjectSelection(editor.Nodes, editor.SelectedNodeIndices, node_id);
}

void ClearLinkSelection()
{
    ImNodesEditorContext& editor = EditorContextGet();
    editor.SelectedLinkIndices.clear();
}

void ClearLinkSelection(int link_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    ClearObjectSelection(editor.Links, editor.SelectedLinkIndices, link_id);
}

void SelectNode(int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    SelectObject(editor.Nodes, editor.SelectedNodeIndices, node_id);
}

void SelectLink(int link_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    SelectObject(editor.Links, editor.SelectedLinkIndices, link_id);
}

bool IsNodeSelected(int node_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    return IsObjectSelected(editor.Nodes, editor.SelectedNodeIndices, node_id);
}

bool IsLinkSelected(int link_id)
{
    ImNodesEditorContext& editor = EditorContextGet();
    return IsObjectSelected(editor.Links, editor.SelectedLinkIndices, link_id);
}

bool IsAttributeActive()
{
    IM_ASSERT((GImNodes->CurrentScope & ImNodesScope_Node) != 0);

    if (!GImNodes->ActiveAttribute)
    {
        return false;
    }

    return GImNodes->ActiveAttributeId == GImNodes->CurrentAttributeId;
}

bool IsAnyAttributeActive(int* const attribute_id)
{
    IM_ASSERT((GImNodes->CurrentScope & (ImNodesScope_Node | ImNodesScope_Attribute)) == 0);

    if (!GImNodes->ActiveAttribute)
    {
        return false;
    }

    if (attribute_id != NULL)
    {
        *attribute_id = GImNodes->ActiveAttributeId;
    }

    return true;
}

bool IsLinkStarted(int* const started_at_id)
{
    // Call this function after EndNodeEditor()!
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    IM_ASSERT(started_at_id != NULL);

    const bool is_started = (GImNodes->ImNodesUIState & ImNodesUIState_LinkStarted) != 0;
    if (is_started)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        const int                   pin_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;
        *started_at_id = editor.Pins.Pool[pin_idx].Id;
    }

    return is_started;
}

bool IsLinkDropped(int* const started_at_id, const bool including_detached_links)
{
    // Call this function after EndNodeEditor()!
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);

    const ImNodesEditorContext& editor = EditorContextGet();

    const bool link_dropped =
        (GImNodes->ImNodesUIState & ImNodesUIState_LinkDropped) != 0 &&
        (including_detached_links ||
         editor.ClickInteraction.LinkCreation.Type != ImNodesLinkCreationType_FromDetach);

    if (link_dropped && started_at_id)
    {
        const int pin_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;
        *started_at_id = editor.Pins.Pool[pin_idx].Id;
    }

    return link_dropped;
}

bool IsLinkCreated(
    int* const  started_at_pin_id,
    int* const  ended_at_pin_id,
    bool* const created_from_snap)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    IM_ASSERT(started_at_pin_id != NULL);
    IM_ASSERT(ended_at_pin_id != NULL);

    const bool is_created = (GImNodes->ImNodesUIState & ImNodesUIState_LinkCreated) != 0;

    if (is_created)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        const int                   start_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;
        const int        end_idx = editor.ClickInteraction.LinkCreation.EndPinIdx.Value();
        const ImPinData& start_pin = editor.Pins.Pool[start_idx];
        const ImPinData& end_pin = editor.Pins.Pool[end_idx];

        if (start_pin.Type == ImNodesAttributeType_Output)
        {
            *started_at_pin_id = start_pin.Id;
            *ended_at_pin_id = end_pin.Id;
        }
        else
        {
            *started_at_pin_id = end_pin.Id;
            *ended_at_pin_id = start_pin.Id;
        }

        if (created_from_snap)
        {
            *created_from_snap =
                editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation;
        }
    }

    return is_created;
}

bool IsLinkCreated(
    int*  started_at_node_id,
    int*  started_at_pin_id,
    int*  ended_at_node_id,
    int*  ended_at_pin_id,
    bool* created_from_snap)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);
    IM_ASSERT(started_at_node_id != NULL);
    IM_ASSERT(started_at_pin_id != NULL);
    IM_ASSERT(ended_at_node_id != NULL);
    IM_ASSERT(ended_at_pin_id != NULL);

    const bool is_created = (GImNodes->ImNodesUIState & ImNodesUIState_LinkCreated) != 0;

    if (is_created)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        const int                   start_idx = editor.ClickInteraction.LinkCreation.StartPinIdx;
        const int         end_idx = editor.ClickInteraction.LinkCreation.EndPinIdx.Value();
        const ImPinData&  start_pin = editor.Pins.Pool[start_idx];
        const ImNodeData& start_node = editor.Nodes.Pool[start_pin.ParentNodeIdx];
        const ImPinData&  end_pin = editor.Pins.Pool[end_idx];
        const ImNodeData& end_node = editor.Nodes.Pool[end_pin.ParentNodeIdx];

        if (start_pin.Type == ImNodesAttributeType_Output)
        {
            *started_at_pin_id = start_pin.Id;
            *started_at_node_id = start_node.Id;
            *ended_at_pin_id = end_pin.Id;
            *ended_at_node_id = end_node.Id;
        }
        else
        {
            *started_at_pin_id = end_pin.Id;
            *started_at_node_id = end_node.Id;
            *ended_at_pin_id = start_pin.Id;
            *ended_at_node_id = start_node.Id;
        }

        if (created_from_snap)
        {
            *created_from_snap =
                editor.ClickInteraction.Type == ImNodesClickInteractionType_LinkCreation;
        }
    }

    return is_created;
}

bool IsLinkDestroyed(int* const link_id)
{
    IM_ASSERT(GImNodes->CurrentScope == ImNodesScope_None);

    const bool link_destroyed = GImNodes->DeletedLinkIdx.HasValue();
    if (link_destroyed)
    {
        const ImNodesEditorContext& editor = EditorContextGet();
        const int                   link_idx = GImNodes->DeletedLinkIdx.Value();
        *link_id = editor.Links.Pool[link_idx].Id;
    }

    return link_destroyed;
}

namespace
{
void NodeLineHandler(ImNodesEditorContext& editor, const char* const line)
{
    int id;
    int x, y;
    if (sscanf(line, "[node.%i", &id) == 1)
    {
        const int node_idx = ObjectPoolFindOrCreateIndex(editor.Nodes, id);
        GImNodes->CurrentNodeIdx = node_idx;
        ImNodeData& node = editor.Nodes.Pool[node_idx];
        node.Id = id;
    }
    else if (sscanf(line, "origin=%i,%i", &x, &y) == 2)
    {
        ImNodeData& node = editor.Nodes.Pool[GImNodes->CurrentNodeIdx];
        node.Origin = SnapOriginToGrid(ImVec2((float)x, (float)y));
    }
}

void EditorLineHandler(ImNodesEditorContext& editor, const char* const line)
{
    (void)sscanf(line, "panning=%f,%f", &editor.Panning.x, &editor.Panning.y);
}
} // namespace

const char* SaveCurrentEditorStateToIniString(size_t* const data_size)
{
    return SaveEditorStateToIniString(&EditorContextGet(), data_size);
}

const char* SaveEditorStateToIniString(
    const ImNodesEditorContext* const editor_ptr,
    size_t* const                     data_size)
{
    IM_ASSERT(editor_ptr != NULL);
    const ImNodesEditorContext& editor = *editor_ptr;

    GImNodes->TextBuffer.clear();
    // TODO: check to make sure that the estimate is the upper bound of element
    GImNodes->TextBuffer.reserve(64 * editor.Nodes.Pool.size());

    GImNodes->TextBuffer.appendf(
        "[editor]\npanning=%i,%i\n", (int)editor.Panning.x, (int)editor.Panning.y);

    for (int i = 0; i < editor.Nodes.Pool.size(); i++)
    {
        if (editor.Nodes.InUse[i])
        {
            const ImNodeData& node = editor.Nodes.Pool[i];
            GImNodes->TextBuffer.appendf("\n[node.%d]\n", node.Id);
            GImNodes->TextBuffer.appendf("origin=%i,%i\n", (int)node.Origin.x, (int)node.Origin.y);
        }
    }

    if (data_size != NULL)
    {
        *data_size = GImNodes->TextBuffer.size();
    }

    return GImNodes->TextBuffer.c_str();
}

void LoadCurrentEditorStateFromIniString(const char* const data, const size_t data_size)
{
    LoadEditorStateFromIniString(&EditorContextGet(), data, data_size);
}

void LoadEditorStateFromIniString(
    ImNodesEditorContext* const editor_ptr,
    const char* const           data,
    const size_t                data_size)
{
    if (data_size == 0u)
    {
        return;
    }

    ImNodesEditorContext& editor = editor_ptr == NULL ? EditorContextGet() : *editor_ptr;

    char*       buf = (char*)ImGui::MemAlloc(data_size + 1);
    const char* buf_end = buf + data_size;
    memcpy(buf, data, data_size);
    buf[data_size] = 0;

    void (*line_handler)(ImNodesEditorContext&, const char*);
    line_handler = NULL;
    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        while (*line == '\n' || *line == '\r')
        {
            line++;
        }
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
        {
            line_end++;
        }
        line_end[0] = 0;

        if (*line == ';' || *line == '\0')
        {
            continue;
        }

        if (line[0] == '[' && line_end[-1] == ']')
        {
            line_end[-1] = 0;
            if (strncmp(line + 1, "node", 4) == 0)
            {
                line_handler = NodeLineHandler;
            }
            else if (strcmp(line + 1, "editor") == 0)
            {
                line_handler = EditorLineHandler;
            }
        }

        if (line_handler != NULL)
        {
            line_handler(editor, line);
        }
    }
    ImGui::MemFree(buf);
}

void SaveCurrentEditorStateToIniFile(const char* const file_name)
{
    SaveEditorStateToIniFile(&EditorContextGet(), file_name);
}

void SaveEditorStateToIniFile(const ImNodesEditorContext* const editor, const char* const file_name)
{
    size_t      data_size = 0u;
    const char* data = SaveEditorStateToIniString(editor, &data_size);
    FILE*       file = ImFileOpen(file_name, "wt");
    if (!file)
    {
        return;
    }

    fwrite(data, sizeof(char), data_size, file);
    fclose(file);
}

void LoadCurrentEditorStateFromIniFile(const char* const file_name)
{
    LoadEditorStateFromIniFile(&EditorContextGet(), file_name);
}

void LoadEditorStateFromIniFile(ImNodesEditorContext* const editor, const char* const file_name)
{
    size_t data_size = 0u;
    char*  file_data = (char*)ImFileLoadToMemory(file_name, "rb", &data_size);

    if (!file_data)
    {
        return;
    }

    LoadEditorStateFromIniString(editor, file_data, data_size);
    ImGui::MemFree(file_data);
}
} // namespace IMNODES_NAMESPACE


================================================================================
FILE: juce\build\_deps\imnodes_fc-src\imnodes.h
================================================================================


#pragma once

#include <stddef.h>
#include <imgui.h>

#ifdef IMNODES_USER_CONFIG
#include IMNODES_USER_CONFIG
#endif

#ifndef IMNODES_NAMESPACE
#define IMNODES_NAMESPACE ImNodes
#endif

typedef int ImNodesCol;             // -> enum ImNodesCol_
typedef int ImNodesStyleVar;        // -> enum ImNodesStyleVar_
typedef int ImNodesStyleFlags;      // -> enum ImNodesStyleFlags_
typedef int ImNodesPinShape;        // -> enum ImNodesPinShape_
typedef int ImNodesAttributeFlags;  // -> enum ImNodesAttributeFlags_
typedef int ImNodesMiniMapLocation; // -> enum ImNodesMiniMapLocation_

enum ImNodesCol_
{
    ImNodesCol_NodeBackground = 0,
    ImNodesCol_NodeBackgroundHovered,
    ImNodesCol_NodeBackgroundSelected,
    ImNodesCol_NodeOutline,
    ImNodesCol_TitleBar,
    ImNodesCol_TitleBarHovered,
    ImNodesCol_TitleBarSelected,
    ImNodesCol_Link,
    ImNodesCol_LinkHovered,
    ImNodesCol_LinkSelected,
    ImNodesCol_Pin,
    ImNodesCol_PinHovered,
    ImNodesCol_BoxSelector,
    ImNodesCol_BoxSelectorOutline,
    ImNodesCol_GridBackground,
    ImNodesCol_GridLine,
    ImNodesCol_GridLinePrimary,
    ImNodesCol_MiniMapBackground,
    ImNodesCol_MiniMapBackgroundHovered,
    ImNodesCol_MiniMapOutline,
    ImNodesCol_MiniMapOutlineHovered,
    ImNodesCol_MiniMapNodeBackground,
    ImNodesCol_MiniMapNodeBackgroundHovered,
    ImNodesCol_MiniMapNodeBackgroundSelected,
    ImNodesCol_MiniMapNodeOutline,
    ImNodesCol_MiniMapLink,
    ImNodesCol_MiniMapLinkSelected,
    ImNodesCol_MiniMapCanvas,
    ImNodesCol_MiniMapCanvasOutline,
    ImNodesCol_COUNT
};

enum ImNodesStyleVar_
{
    ImNodesStyleVar_GridSpacing = 0,
    ImNodesStyleVar_NodeCornerRounding,
    ImNodesStyleVar_NodePadding,
    ImNodesStyleVar_NodeBorderThickness,
    ImNodesStyleVar_LinkThickness,
    ImNodesStyleVar_LinkLineSegmentsPerLength,
    ImNodesStyleVar_LinkHoverDistance,
    ImNodesStyleVar_PinCircleRadius,
    ImNodesStyleVar_PinQuadSideLength,
    ImNodesStyleVar_PinTriangleSideLength,
    ImNodesStyleVar_PinLineThickness,
    ImNodesStyleVar_PinHoverRadius,
    ImNodesStyleVar_PinOffset,
    ImNodesStyleVar_MiniMapPadding,
    ImNodesStyleVar_MiniMapOffset,
    ImNodesStyleVar_COUNT
};

enum ImNodesStyleFlags_
{
    ImNodesStyleFlags_None = 0,
    ImNodesStyleFlags_NodeOutline = 1 << 0,
    ImNodesStyleFlags_GridLines = 1 << 2,
    ImNodesStyleFlags_GridLinesPrimary = 1 << 3,
    ImNodesStyleFlags_GridSnapping = 1 << 4
};

enum ImNodesPinShape_
{
    ImNodesPinShape_Circle,
    ImNodesPinShape_CircleFilled,
    ImNodesPinShape_Triangle,
    ImNodesPinShape_TriangleFilled,
    ImNodesPinShape_Quad,
    ImNodesPinShape_QuadFilled
};

// This enum controls the way the attribute pins behave.
enum ImNodesAttributeFlags_
{
    ImNodesAttributeFlags_None = 0,
    // Allow detaching a link by left-clicking and dragging the link at a pin it is connected to.
    // NOTE: the user has to actually delete the link for this to work. A deleted link can be
    // detected by calling IsLinkDestroyed() after EndNodeEditor().
    ImNodesAttributeFlags_EnableLinkDetachWithDragClick = 1 << 0,
    // Visual snapping of an in progress link will trigger IsLink Created/Destroyed events. Allows
    // for previewing the creation of a link while dragging it across attributes. See here for demo:
    // https://github.com/Nelarius/imnodes/issues/41#issuecomment-647132113 NOTE: the user has to
    // actually delete the link for this to work. A deleted link can be detected by calling
    // IsLinkDestroyed() after EndNodeEditor().
    ImNodesAttributeFlags_EnableLinkCreationOnSnap = 1 << 1
};

struct ImNodesIO
{
    struct EmulateThreeButtonMouse
    {
        EmulateThreeButtonMouse();

        // The keyboard modifier to use in combination with mouse left click to pan the editor view.
        // Set to NULL by default. To enable this feature, set the modifier to point to a boolean
        // indicating the state of a modifier. For example,
        //
        // ImNodes::GetIO().EmulateThreeButtonMouse.Modifier = &ImGui::GetIO().KeyAlt;
        const bool* Modifier;
    } EmulateThreeButtonMouse;

    struct LinkDetachWithModifierClick
    {
        LinkDetachWithModifierClick();

        // Pointer to a boolean value indicating when the desired modifier is pressed. Set to NULL
        // by default. To enable the feature, set the modifier to point to a boolean indicating the
        // state of a modifier. For example,
        //
        // ImNodes::GetIO().LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyCtrl;
        //
        // Left-clicking a link with this modifier pressed will detach that link. NOTE: the user has
        // to actually delete the link for this to work. A deleted link can be detected by calling
        // IsLinkDestroyed() after EndNodeEditor().
        const bool* Modifier;
    } LinkDetachWithModifierClick;

    struct MultipleSelectModifier
    {
        MultipleSelectModifier();

        // Pointer to a boolean value indicating when the desired modifier is pressed. Set to NULL
        // by default. To enable the feature, set the modifier to point to a boolean indicating the
        // state of a modifier. For example,
        //
        // ImNodes::GetIO().MultipleSelectModifier.Modifier = &ImGui::GetIO().KeyCtrl;
        //
        // Left-clicking a node with this modifier pressed will add the node to the list of
        // currently selected nodes. If this value is NULL, the Ctrl key will be used.
        const bool* Modifier;
    } MultipleSelectModifier;

    // Holding alt mouse button pans the node area, by default middle mouse button will be used
    // Set based on ImGuiMouseButton values
    int AltMouseButton;

    // Panning speed when dragging an element and mouse is outside the main editor view.
    float AutoPanningSpeed;

    ImNodesIO();
};

struct ImNodesStyle
{
    float GridSpacing;

    float  NodeCornerRounding;
    ImVec2 NodePadding;
    float  NodeBorderThickness;

    float LinkThickness;
    float LinkLineSegmentsPerLength;
    float LinkHoverDistance;

    // The following variables control the look and behavior of the pins. The default size of each
    // pin shape is balanced to occupy approximately the same surface area on the screen.

    // The circle radius used when the pin shape is either ImNodesPinShape_Circle or
    // ImNodesPinShape_CircleFilled.
    float PinCircleRadius;
    // The quad side length used when the shape is either ImNodesPinShape_Quad or
    // ImNodesPinShape_QuadFilled.
    float PinQuadSideLength;
    // The equilateral triangle side length used when the pin shape is either
    // ImNodesPinShape_Triangle or ImNodesPinShape_TriangleFilled.
    float PinTriangleSideLength;
    // The thickness of the line used when the pin shape is not filled.
    float PinLineThickness;
    // The radius from the pin's center position inside of which it is detected as being hovered
    // over.
    float PinHoverRadius;
    // Offsets the pins' positions from the edge of the node to the outside of the node.
    float PinOffset;

    // Mini-map padding size between mini-map edge and mini-map content.
    ImVec2 MiniMapPadding;
    // Mini-map offset from the screen side.
    ImVec2 MiniMapOffset;

    // By default, ImNodesStyleFlags_NodeOutline and ImNodesStyleFlags_Gridlines are enabled.
    ImNodesStyleFlags Flags;
    // Set these mid-frame using Push/PopColorStyle. You can index this color array with with a
    // ImNodesCol value.
    unsigned int Colors[ImNodesCol_COUNT];

    ImNodesStyle();
};

enum ImNodesMiniMapLocation_
{
    ImNodesMiniMapLocation_BottomLeft,
    ImNodesMiniMapLocation_BottomRight,
    ImNodesMiniMapLocation_TopLeft,
    ImNodesMiniMapLocation_TopRight,
};

struct ImGuiContext;
struct ImVec2;

struct ImNodesContext;

// An editor context corresponds to a set of nodes in a single workspace (created with a single
// Begin/EndNodeEditor pair)
//
// By default, the library creates an editor context behind the scenes, so using any of the imnodes
// functions doesn't require you to explicitly create a context.
struct ImNodesEditorContext;

// Callback type used to specify special behavior when hovering a node in the minimap
#ifndef ImNodesMiniMapNodeHoveringCallback
typedef void (*ImNodesMiniMapNodeHoveringCallback)(int, void*);
#endif

#ifndef ImNodesMiniMapNodeHoveringCallbackUserData
typedef void* ImNodesMiniMapNodeHoveringCallbackUserData;
#endif

namespace IMNODES_NAMESPACE
{
// Call this function if you are compiling imnodes in to a dll, separate from ImGui. Calling this
// function sets the GImGui global variable, which is not shared across dll boundaries.
void SetImGuiContext(ImGuiContext* ctx);

ImNodesContext* CreateContext();
void            DestroyContext(ImNodesContext* ctx = NULL); // NULL = destroy current context
ImNodesContext* GetCurrentContext();
void            SetCurrentContext(ImNodesContext* ctx);

ImNodesEditorContext* EditorContextCreate();
void                  EditorContextFree(ImNodesEditorContext*);
void                  EditorContextSet(ImNodesEditorContext*);
ImVec2                EditorContextGetPanning();
void                  EditorContextResetPanning(const ImVec2& pos);
void                  EditorContextMoveToNode(const int node_id);

ImNodesIO& GetIO();

// Returns the global style struct. See the struct declaration for default values.
ImNodesStyle& GetStyle();
// Style presets matching the dear imgui styles of the same name. If dest is NULL, the active
// context's ImNodesStyle instance will be used as the destination.
void StyleColorsDark(ImNodesStyle* dest = NULL); // on by default
void StyleColorsClassic(ImNodesStyle* dest = NULL);
void StyleColorsLight(ImNodesStyle* dest = NULL);

// The top-level function call. Call this before calling BeginNode/EndNode. Calling this function
// will result the node editor grid workspace being rendered.
void BeginNodeEditor();
void EndNodeEditor();

// Add a navigable minimap to the editor; call before EndNodeEditor after all
// nodes and links have been specified
void MiniMap(
    const float                                      minimap_size_fraction = 0.2f,
    const ImNodesMiniMapLocation                     location = ImNodesMiniMapLocation_TopLeft,
    const ImNodesMiniMapNodeHoveringCallback         node_hovering_callback = NULL,
    const ImNodesMiniMapNodeHoveringCallbackUserData node_hovering_callback_data = NULL);

// Use PushColorStyle and PopColorStyle to modify ImNodesStyle::Colors mid-frame.
void PushColorStyle(ImNodesCol item, unsigned int color);
void PopColorStyle();
void PushStyleVar(ImNodesStyleVar style_item, float value);
void PushStyleVar(ImNodesStyleVar style_item, const ImVec2& value);
void PopStyleVar(int count = 1);

// id can be any positive or negative integer, but INT_MIN is currently reserved for internal use.
void BeginNode(int id);
void EndNode();

ImVec2 GetNodeDimensions(int id);

// Place your node title bar content (such as the node title, using ImGui::Text) between the
// following function calls. These functions have to be called before adding any attributes, or the
// layout of the node will be incorrect.
void BeginNodeTitleBar();
void EndNodeTitleBar();

// Attributes are ImGui UI elements embedded within the node. Attributes can have pin shapes
// rendered next to them. Links are created between pins.
//
// The activity status of an attribute can be checked via the IsAttributeActive() and
// IsAnyAttributeActive() function calls. This is one easy way of checking for any changes made to
// an attribute's drag float UI, for instance.
//
// Each attribute id must be unique.

// Create an input attribute block. The pin is rendered on left side.
void BeginInputAttribute(int id, ImNodesPinShape shape = ImNodesPinShape_CircleFilled);
void EndInputAttribute();
// Create an output attribute block. The pin is rendered on the right side.
void BeginOutputAttribute(int id, ImNodesPinShape shape = ImNodesPinShape_CircleFilled);
void EndOutputAttribute();
// Create a static attribute block. A static attribute has no pin, and therefore can't be linked to
// anything. However, you can still use IsAttributeActive() and IsAnyAttributeActive() to check for
// attribute activity.
void BeginStaticAttribute(int id);
void EndStaticAttribute();

// Push a single AttributeFlags value. By default, only AttributeFlags_None is set.
void PushAttributeFlag(ImNodesAttributeFlags flag);
void PopAttributeFlag();

// Render a link between attributes.
// The attributes ids used here must match the ids used in Begin(Input|Output)Attribute function
// calls. The order of start_attr and end_attr doesn't make a difference for rendering the link.
void Link(int id, int start_attribute_id, int end_attribute_id);

// Enable or disable the ability to click and drag a specific node.
void SetNodeDraggable(int node_id, const bool draggable);

// The node's position can be expressed in three coordinate systems:
// * screen space coordinates, -- the origin is the upper left corner of the window.
// * editor space coordinates -- the origin is the upper left corner of the node editor window
// * grid space coordinates, -- the origin is the upper left corner of the node editor window,
// translated by the current editor panning vector (see EditorContextGetPanning() and
// EditorContextResetPanning())

// Use the following functions to get and set the node's coordinates in these coordinate systems.

void SetNodeScreenSpacePos(int node_id, const ImVec2& screen_space_pos);
void SetNodeEditorSpacePos(int node_id, const ImVec2& editor_space_pos);
void SetNodeGridSpacePos(int node_id, const ImVec2& grid_pos);

ImVec2 GetNodeScreenSpacePos(const int node_id);
ImVec2 GetNodeEditorSpacePos(const int node_id);
ImVec2 GetNodeGridSpacePos(const int node_id);

// If ImNodesStyleFlags_GridSnapping is enabled, snap the specified node's origin to the grid.
void SnapNodeToGrid(int node_id);

// Returns true if the current node editor canvas is being hovered over by the mouse, and is not
// blocked by any other windows.
bool IsEditorHovered();
// The following functions return true if a UI element is being hovered over by the mouse cursor.
// Assigns the id of the UI element being hovered over to the function argument. Use these functions
// after EndNodeEditor() has been called.
bool IsNodeHovered(int* node_id);
bool IsLinkHovered(int* link_id);
bool IsPinHovered(int* attribute_id);

// Use The following two functions to query the number of selected nodes or links in the current
// editor. Use after calling EndNodeEditor().
int NumSelectedNodes();
int NumSelectedLinks();
// Get the selected node/link ids. The pointer argument should point to an integer array with at
// least as many elements as the respective NumSelectedNodes/NumSelectedLinks function call
// returned.
void GetSelectedNodes(int* node_ids);
void GetSelectedLinks(int* link_ids);
// Clears the list of selected nodes/links. Useful if you want to delete a selected node or link.
void ClearNodeSelection();
void ClearLinkSelection();
// Use the following functions to add or remove individual nodes or links from the current editors
// selection. Note that all functions require the id to be an existing valid id for this editor.
// Select-functions has the precondition that the object is currently considered unselected.
// Clear-functions has the precondition that the object is currently considered selected.
// Preconditions listed above can be checked via IsNodeSelected/IsLinkSelected if not already
// known.
void SelectNode(int node_id);
void ClearNodeSelection(int node_id);
bool IsNodeSelected(int node_id);
void SelectLink(int link_id);
void ClearLinkSelection(int link_id);
bool IsLinkSelected(int link_id);

// Was the previous attribute active? This will continuously return true while the left mouse button
// is being pressed over the UI content of the attribute.
bool IsAttributeActive();
// Was any attribute active? If so, sets the active attribute id to the output function argument.
bool IsAnyAttributeActive(int* attribute_id = NULL);

// Use the following functions to query a change of state for an existing link, or new link. Call
// these after EndNodeEditor().

// Did the user start dragging a new link from a pin?
bool IsLinkStarted(int* started_at_attribute_id);
// Did the user drop the dragged link before attaching it to a pin?
// There are two different kinds of situations to consider when handling this event:
// 1) a link which is created at a pin and then dropped
// 2) an existing link which is detached from a pin and then dropped
// Use the including_detached_links flag to control whether this function triggers when the user
// detaches a link and drops it.
bool IsLinkDropped(int* started_at_attribute_id = NULL, bool including_detached_links = true);
// Did the user finish creating a new link?
bool IsLinkCreated(
    int*  started_at_attribute_id,
    int*  ended_at_attribute_id,
    bool* created_from_snap = NULL);
bool IsLinkCreated(
    int*  started_at_node_id,
    int*  started_at_attribute_id,
    int*  ended_at_node_id,
    int*  ended_at_attribute_id,
    bool* created_from_snap = NULL);

// Was an existing link detached from a pin by the user? The detached link's id is assigned to the
// output argument link_id.
bool IsLinkDestroyed(int* link_id);

// Use the following functions to write the editor context's state to a string, or directly to a
// file. The editor context is serialized in the INI file format.

const char* SaveCurrentEditorStateToIniString(size_t* data_size = NULL);
const char* SaveEditorStateToIniString(
    const ImNodesEditorContext* editor,
    size_t*                     data_size = NULL);

void LoadCurrentEditorStateFromIniString(const char* data, size_t data_size);
void LoadEditorStateFromIniString(ImNodesEditorContext* editor, const char* data, size_t data_size);

void SaveCurrentEditorStateToIniFile(const char* file_name);
void SaveEditorStateToIniFile(const ImNodesEditorContext* editor, const char* file_name);

void LoadCurrentEditorStateFromIniFile(const char* file_name);
void LoadEditorStateFromIniFile(ImNodesEditorContext* editor, const char* file_name);
} // namespace IMNODES_NAMESPACE


================================================================================
FILE: juce\build\_deps\imnodes_fc-src\imnodes_internal.h
================================================================================


#pragma once

#define IMGUI_DEFINE_MATH_OPERATORS
#include <imgui.h>
#include <imgui_internal.h>

#include "imnodes.h"

#include <limits.h>

// the structure of this file:
//
// [SECTION] internal enums
// [SECTION] internal data structures
// [SECTION] global and editor context structs
// [SECTION] object pool implementation

struct ImNodesContext;

extern ImNodesContext* GImNodes;

// [SECTION] internal enums

typedef int ImNodesScope;
typedef int ImNodesAttributeType;
typedef int ImNodesUIState;
typedef int ImNodesClickInteractionType;
typedef int ImNodesLinkCreationType;

enum ImNodesScope_
{
    ImNodesScope_None = 1,
    ImNodesScope_Editor = 1 << 1,
    ImNodesScope_Node = 1 << 2,
    ImNodesScope_Attribute = 1 << 3
};

enum ImNodesAttributeType_
{
    ImNodesAttributeType_None,
    ImNodesAttributeType_Input,
    ImNodesAttributeType_Output
};

enum ImNodesUIState_
{
    ImNodesUIState_None = 0,
    ImNodesUIState_LinkStarted = 1 << 0,
    ImNodesUIState_LinkDropped = 1 << 1,
    ImNodesUIState_LinkCreated = 1 << 2
};

enum ImNodesClickInteractionType_
{
    ImNodesClickInteractionType_Node,
    ImNodesClickInteractionType_Link,
    ImNodesClickInteractionType_LinkCreation,
    ImNodesClickInteractionType_Panning,
    ImNodesClickInteractionType_BoxSelection,
    ImNodesClickInteractionType_ImGuiItem,
    ImNodesClickInteractionType_None
};

enum ImNodesLinkCreationType_
{
    ImNodesLinkCreationType_Standard,
    ImNodesLinkCreationType_FromDetach
};

// [SECTION] internal data structures

// The object T must have the following interface:
//
// struct T
// {
//     T();
//
//     int id;
// };
template<typename T>
struct ImObjectPool
{
    ImVector<T>    Pool;
    ImVector<bool> InUse;
    ImVector<int>  FreeList;
    ImGuiStorage   IdMap;

    ImObjectPool() : Pool(), InUse(), FreeList(), IdMap() {}
};

// Emulates std::optional<int> using the sentinel value `INVALID_INDEX`.
struct ImOptionalIndex
{
    ImOptionalIndex() : _Index(INVALID_INDEX) {}
    ImOptionalIndex(const int value) : _Index(value) {}

    // Observers

    inline bool HasValue() const { return _Index != INVALID_INDEX; }

    inline int Value() const
    {
        IM_ASSERT(HasValue());
        return _Index;
    }

    // Modifiers

    inline ImOptionalIndex& operator=(const int value)
    {
        _Index = value;
        return *this;
    }

    inline void Reset() { _Index = INVALID_INDEX; }

    inline bool operator==(const ImOptionalIndex& rhs) const { return _Index == rhs._Index; }

    inline bool operator==(const int rhs) const { return _Index == rhs; }

    inline bool operator!=(const ImOptionalIndex& rhs) const { return _Index != rhs._Index; }

    inline bool operator!=(const int rhs) const { return _Index != rhs; }

    static const int INVALID_INDEX = -1;

private:
    int _Index;
};

struct ImNodeData
{
    int    Id;
    ImVec2 Origin; // The node origin is in editor space
    ImRect TitleBarContentRect;
    ImRect Rect;

    struct
    {
        ImU32 Background, BackgroundHovered, BackgroundSelected, Outline, Titlebar, TitlebarHovered,
            TitlebarSelected;
    } ColorStyle;

    struct
    {
        float  CornerRounding;
        ImVec2 Padding;
        float  BorderThickness;
    } LayoutStyle;

    ImVector<int> PinIndices;
    bool          Draggable;

    ImNodeData(const int node_id)
        : Id(node_id), Origin(0.0f, 0.0f), TitleBarContentRect(),
          Rect(ImVec2(0.0f, 0.0f), ImVec2(0.0f, 0.0f)), ColorStyle(), LayoutStyle(), PinIndices(),
          Draggable(true)
    {
    }

    ~ImNodeData() { Id = INT_MIN; }
};

struct ImPinData
{
    int                  Id;
    int                  ParentNodeIdx;
    ImRect               AttributeRect;
    ImNodesAttributeType Type;
    ImNodesPinShape      Shape;
    ImVec2               Pos; // screen-space coordinates
    int                  Flags;

    struct
    {
        ImU32 Background, Hovered;
    } ColorStyle;

    ImPinData(const int pin_id)
        : Id(pin_id), ParentNodeIdx(), AttributeRect(), Type(ImNodesAttributeType_None),
          Shape(ImNodesPinShape_CircleFilled), Pos(), Flags(ImNodesAttributeFlags_None),
          ColorStyle()
    {
    }
};

struct ImLinkData
{
    int Id;
    int StartPinIdx, EndPinIdx;

    struct
    {
        ImU32 Base, Hovered, Selected;
    } ColorStyle;

    ImLinkData(const int link_id) : Id(link_id), StartPinIdx(), EndPinIdx(), ColorStyle() {}
};

struct ImClickInteractionState
{
    ImNodesClickInteractionType Type;

    struct
    {
        int                     StartPinIdx;
        ImOptionalIndex         EndPinIdx;
        ImNodesLinkCreationType Type;
    } LinkCreation;

    struct
    {
        ImRect Rect; // Coordinates in grid space
    } BoxSelector;

    ImClickInteractionState() : Type(ImNodesClickInteractionType_None) {}
};

struct ImNodesColElement
{
    ImU32      Color;
    ImNodesCol Item;

    ImNodesColElement(const ImU32 c, const ImNodesCol s) : Color(c), Item(s) {}
};

struct ImNodesStyleVarElement
{
    ImNodesStyleVar Item;
    float           FloatValue[2];

    ImNodesStyleVarElement(const ImNodesStyleVar variable, const float value) : Item(variable)
    {
        FloatValue[0] = value;
    }

    ImNodesStyleVarElement(const ImNodesStyleVar variable, const ImVec2 value) : Item(variable)
    {
        FloatValue[0] = value.x;
        FloatValue[1] = value.y;
    }
};

// [SECTION] global and editor context structs

struct ImNodesEditorContext
{
    ImObjectPool<ImNodeData> Nodes;
    ImObjectPool<ImPinData>  Pins;
    ImObjectPool<ImLinkData> Links;

    ImVector<int> NodeDepthOrder;

    // ui related fields
    ImVec2 Panning;
    ImVec2 AutoPanningDelta;
    // Minimum and maximum extents of all content in grid space. Valid after final
    // ImNodes::EndNode() call.
    ImRect GridContentBounds;

    ImVector<int> SelectedNodeIndices;
    ImVector<int> SelectedLinkIndices;

    // Relative origins of selected nodes for snapping of dragged nodes
    ImVector<ImVec2> SelectedNodeOffsets;
    // Offset of the primary node origin relative to the mouse cursor.
    ImVec2 PrimaryNodeOffset;

    ImClickInteractionState ClickInteraction;

    // Mini-map state set by MiniMap()

    bool                                       MiniMapEnabled;
    ImNodesMiniMapLocation                     MiniMapLocation;
    float                                      MiniMapSizeFraction;
    ImNodesMiniMapNodeHoveringCallback         MiniMapNodeHoveringCallback;
    ImNodesMiniMapNodeHoveringCallbackUserData MiniMapNodeHoveringCallbackUserData;

    // Mini-map state set during EndNodeEditor() call

    ImRect MiniMapRectScreenSpace;
    ImRect MiniMapContentScreenSpace;
    float  MiniMapScaling;

    ImNodesEditorContext()
        : Nodes(), Pins(), Links(), Panning(0.f, 0.f), SelectedNodeIndices(), SelectedLinkIndices(),
          SelectedNodeOffsets(), PrimaryNodeOffset(0.f, 0.f), ClickInteraction(),
          MiniMapEnabled(false), MiniMapSizeFraction(0.0f), MiniMapNodeHoveringCallback(NULL),
          MiniMapNodeHoveringCallbackUserData(NULL), MiniMapScaling(0.0f)
    {
    }
};

struct ImNodesContext
{
    ImNodesEditorContext* DefaultEditorCtx;
    ImNodesEditorContext* EditorCtx;

    // Canvas draw list and helper state
    ImDrawList*   CanvasDrawList;
    ImGuiStorage  NodeIdxToSubmissionIdx;
    ImVector<int> NodeIdxSubmissionOrder;
    ImVector<int> NodeIndicesOverlappingWithMouse;
    ImVector<int> OccludedPinIndices;

    // Canvas extents
    ImVec2 CanvasOriginScreenSpace;
    ImRect CanvasRectScreenSpace;

    // Debug helpers
    ImNodesScope CurrentScope;

    // Configuration state
    ImNodesIO                        Io;
    ImNodesStyle                     Style;
    ImVector<ImNodesColElement>      ColorModifierStack;
    ImVector<ImNodesStyleVarElement> StyleModifierStack;
    ImGuiTextBuffer                  TextBuffer;

    int           CurrentAttributeFlags;
    ImVector<int> AttributeFlagStack;

    // UI element state
    int CurrentNodeIdx;
    int CurrentPinIdx;
    int CurrentAttributeId;

    ImOptionalIndex HoveredNodeIdx;
    ImOptionalIndex HoveredLinkIdx;
    ImOptionalIndex HoveredPinIdx;

    ImOptionalIndex DeletedLinkIdx;
    ImOptionalIndex SnapLinkIdx;

    // Event helper state
    // TODO: this should be a part of a state machine, and not a member of the global struct.
    // Unclear what parts of the code this relates to.
    int ImNodesUIState;

    int  ActiveAttributeId;
    bool ActiveAttribute;

    // ImGui::IO cache

    ImVec2 MousePos;

    bool  LeftMouseClicked;
    bool  LeftMouseReleased;
    bool  AltMouseClicked;
    bool  LeftMouseDragging;
    bool  AltMouseDragging;
    float AltMouseScrollDelta;
    bool  MultipleSelectModifier;
};

namespace IMNODES_NAMESPACE
{
static inline ImNodesEditorContext& EditorContextGet()
{
    // No editor context was set! Did you forget to call ImNodes::CreateContext()?
    IM_ASSERT(GImNodes->EditorCtx != NULL);
    return *GImNodes->EditorCtx;
}

// [SECTION] ObjectPool implementation

template<typename T>
static inline int ObjectPoolFind(const ImObjectPool<T>& objects, const int id)
{
    const int index = objects.IdMap.GetInt(static_cast<ImGuiID>(id), -1);
    return index;
}

template<typename T>
static inline void ObjectPoolUpdate(ImObjectPool<T>& objects)
{
    for (int i = 0; i < objects.InUse.size(); ++i)
    {
        const int id = objects.Pool[i].Id;

        if (!objects.InUse[i] && objects.IdMap.GetInt(id, -1) == i)
        {
            objects.IdMap.SetInt(id, -1);
            objects.FreeList.push_back(i);
            (objects.Pool.Data + i)->~T();
        }
    }
}

template<>
inline void ObjectPoolUpdate(ImObjectPool<ImNodeData>& nodes)
{
    for (int i = 0; i < nodes.InUse.size(); ++i)
    {
        if (nodes.InUse[i])
        {
            nodes.Pool[i].PinIndices.clear();
        }
        else
        {
            const int id = nodes.Pool[i].Id;

            if (nodes.IdMap.GetInt(id, -1) == i)
            {
                // Remove node idx form depth stack the first time we detect that this idx slot is
                // unused
                ImVector<int>&   depth_stack = EditorContextGet().NodeDepthOrder;
                const int* const elem = depth_stack.find(i);
                IM_ASSERT(elem != depth_stack.end());
                depth_stack.erase(elem);

                nodes.IdMap.SetInt(id, -1);
                nodes.FreeList.push_back(i);
                (nodes.Pool.Data + i)->~ImNodeData();
            }
        }
    }
}

template<typename T>
static inline void ObjectPoolReset(ImObjectPool<T>& objects)
{
    if (!objects.InUse.empty())
    {
        memset(objects.InUse.Data, 0, objects.InUse.size_in_bytes());
    }
}

template<typename T>
static inline int ObjectPoolFindOrCreateIndex(ImObjectPool<T>& objects, const int id)
{
    int index = objects.IdMap.GetInt(static_cast<ImGuiID>(id), -1);

    // Construct new object
    if (index == -1)
    {
        if (objects.FreeList.empty())
        {
            index = objects.Pool.size();
            IM_ASSERT(objects.Pool.size() == objects.InUse.size());
            const int new_size = objects.Pool.size() + 1;
            objects.Pool.resize(new_size);
            objects.InUse.resize(new_size);
        }
        else
        {
            index = objects.FreeList.back();
            objects.FreeList.pop_back();
        }
        IM_PLACEMENT_NEW(objects.Pool.Data + index) T(id);
        objects.IdMap.SetInt(static_cast<ImGuiID>(id), index);
    }

    // Flag it as used
    objects.InUse[index] = true;

    return index;
}

template<>
inline int ObjectPoolFindOrCreateIndex(ImObjectPool<ImNodeData>& nodes, const int node_id)
{
    int node_idx = nodes.IdMap.GetInt(static_cast<ImGuiID>(node_id), -1);

    // Construct new node
    if (node_idx == -1)
    {
        if (nodes.FreeList.empty())
        {
            node_idx = nodes.Pool.size();
            IM_ASSERT(nodes.Pool.size() == nodes.InUse.size());
            const int new_size = nodes.Pool.size() + 1;
            nodes.Pool.resize(new_size);
            nodes.InUse.resize(new_size);
        }
        else
        {
            node_idx = nodes.FreeList.back();
            nodes.FreeList.pop_back();
        }
        IM_PLACEMENT_NEW(nodes.Pool.Data + node_idx) ImNodeData(node_id);
        nodes.IdMap.SetInt(static_cast<ImGuiID>(node_id), node_idx);

        ImNodesEditorContext& editor = EditorContextGet();
        editor.NodeDepthOrder.push_back(node_idx);
    }

    // Flag node as used
    nodes.InUse[node_idx] = true;

    return node_idx;
}

template<typename T>
static inline T& ObjectPoolFindOrCreateObject(ImObjectPool<T>& objects, const int id)
{
    const int index = ObjectPoolFindOrCreateIndex(objects, id);
    return objects.Pool[index];
}
} // namespace IMNODES_NAMESPACE


================================================================================
FILE: imnode_examples\hello.cpp
================================================================================


#include "node_editor.h"
#include <imnodes.h>
#include <imgui.h>

namespace example
{
namespace
{
class HelloWorldNodeEditor
{
public:
    void show()
    {
        ImGui::Begin("simple node editor");

        ImNodes::BeginNodeEditor();
        ImNodes::BeginNode(1);

        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted("simple node :)");
        ImNodes::EndNodeTitleBar();

        ImNodes::BeginInputAttribute(2);
        ImGui::Text("input");
        ImNodes::EndInputAttribute();

        ImNodes::BeginOutputAttribute(3);
        ImGui::Indent(40);
        ImGui::Text("output");
        ImNodes::EndOutputAttribute();

        ImNodes::EndNode();
        ImNodes::EndNodeEditor();

        ImGui::End();
    }
};

static HelloWorldNodeEditor editor;
} // namespace

void NodeEditorInitialize() { ImNodes::SetNodeGridSpacePos(1, ImVec2(200.0f, 200.0f)); }

void NodeEditorShow() { editor.show(); }

void NodeEditorShutdown() {}

} // namespace example


================================================================================
FILE: imnode_examples\main.cpp
================================================================================


#include "node_editor.h"

#include <imgui.h>
#include <imgui_impl_sdl2.h>
#include <imgui_impl_opengl3.h>
#include <imnodes.h>
#include <SDL2/SDL.h>
#if defined(IMGUI_IMPL_OPENGL_ES2)
#include <SDL2/SDL_opengles2.h>
#else
#include <SDL2/SDL_opengl.h>
#endif

#include <stdio.h>

int main(int, char**)
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0)
    {
        printf("Error: %s\n", SDL_GetError());
        return -1;
    }

    // Decide GL+GLSL versions
#if defined(IMGUI_IMPL_OPENGL_ES2)
    // GL ES 2.0 + GLSL 100
    const char* glsl_version = "#version 100";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
#elif defined(__APPLE__)
    // GL 3.2 Core + GLSL 150
    const char* glsl_version = "#version 150";
    SDL_GL_SetAttribute(
        SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG); // Always required on Mac
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
#else
    // GL 3.0 + GLSL 130
    const char* glsl_version = "#version 130";
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);
#endif

    // Create window with graphics context
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
    SDL_WindowFlags window_flags =
        (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);
    SDL_Window* window = SDL_CreateWindow(
        "Dear ImGui SDL2+OpenGL3 example",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        1280,
        720,
        window_flags);
    SDL_GLContext gl_context = SDL_GL_CreateContext(window);
    SDL_GL_MakeCurrent(window, gl_context);
    SDL_GL_SetSwapInterval(1); // Enable vsync

    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    (void)io;

    ImNodes::CreateContext();
    example::NodeEditorInitialize();

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    // ImGui::StyleColorsClassic();
    ImNodes::StyleColorsDark();

    // Setup Platform/Renderer backends
    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
    ImGui_ImplOpenGL3_Init(glsl_version);

    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

    // Main loop
    bool done = false;
    while (!done)
    {
        SDL_Event event;
        while (SDL_PollEvent(&event))
        {
            ImGui_ImplSDL2_ProcessEvent(&event);
            if (event.type == SDL_QUIT)
                done = true;
            if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE &&
                event.window.windowID == SDL_GetWindowID(window))
                done = true;
        }

        // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame();
        ImGui::NewFrame();

        example::NodeEditorShow();

        // Rendering
        ImGui::Render();
        glViewport(0, 0, (int)io.DisplaySize.x, (int)io.DisplaySize.y);
        glClearColor(
            clear_color.x * clear_color.w,
            clear_color.y * clear_color.w,
            clear_color.z * clear_color.w,
            clear_color.w);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        SDL_GL_SwapWindow(window);
    }

    // Cleanup
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    example::NodeEditorShutdown();
    ImNodes::DestroyContext();
    ImGui::DestroyContext();

    SDL_GL_DeleteContext(gl_context);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}


================================================================================
FILE: imnode_examples\save_load.cpp
================================================================================


#include "node_editor.h"

#include <imnodes.h>
#include <imgui.h>
#include <SDL_keycode.h>

#include <algorithm>
#include <cassert>
#include <fstream>
#include <ios> // for std::streamsize
#include <stddef.h>
#include <vector>

namespace example
{
namespace
{
struct Node
{
    int   id;
    float value;

    Node() = default;

    Node(const int i, const float v) : id(i), value(v) {}
};

struct Link
{
    int id;
    int start_attr, end_attr;
};

class SaveLoadEditor
{
public:
    SaveLoadEditor() : nodes_(), links_(), current_id_(0) {}

    void show()
    {
        ImGui::Begin("Save & load example");
        ImGui::TextUnformatted("A -- add node");
        ImGui::TextUnformatted(
            "Close the executable and rerun it -- your nodes should be exactly "
            "where you left them!");

        ImNodes::BeginNodeEditor();

        if (ImGui::IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows) &&
            ImNodes::IsEditorHovered() && ImGui::IsKeyReleased(ImGuiKey_A))
        {
            const int node_id = ++current_id_;
            ImNodes::SetNodeScreenSpacePos(node_id, ImGui::GetMousePos());
            nodes_.push_back(Node(node_id, 0.f));
        }

        for (Node& node : nodes_)
        {
            ImNodes::BeginNode(node.id);

            ImNodes::BeginNodeTitleBar();
            ImGui::TextUnformatted("node");
            ImNodes::EndNodeTitleBar();

            ImNodes::BeginInputAttribute(node.id << 8);
            ImGui::TextUnformatted("input");
            ImNodes::EndInputAttribute();

            ImNodes::BeginStaticAttribute(node.id << 16);
            ImGui::PushItemWidth(120.f);
            ImGui::DragFloat("value", &node.value, 0.01f);
            ImGui::PopItemWidth();
            ImNodes::EndStaticAttribute();

            ImNodes::BeginOutputAttribute(node.id << 24);
            const float text_width = ImGui::CalcTextSize("output").x;
            ImGui::Indent(120.f + ImGui::CalcTextSize("value").x - text_width);
            ImGui::TextUnformatted("output");
            ImNodes::EndOutputAttribute();

            ImNodes::EndNode();
        }

        for (const Link& link : links_)
        {
            ImNodes::Link(link.id, link.start_attr, link.end_attr);
        }

        ImNodes::EndNodeEditor();

        {
            Link link;
            if (ImNodes::IsLinkCreated(&link.start_attr, &link.end_attr))
            {
                link.id = ++current_id_;
                links_.push_back(link);
            }
        }

        {
            int link_id;
            if (ImNodes::IsLinkDestroyed(&link_id))
            {
                auto iter =
                    std::find_if(links_.begin(), links_.end(), [link_id](const Link& link) -> bool {
                        return link.id == link_id;
                    });
                assert(iter != links_.end());
                links_.erase(iter);
            }
        }

        ImGui::End();
    }

    void save()
    {
        // Save the internal imnodes state
        ImNodes::SaveCurrentEditorStateToIniFile("save_load.ini");

        // Dump our editor state as bytes into a file

        std::fstream fout(
            "save_load.bytes", std::ios_base::out | std::ios_base::binary | std::ios_base::trunc);

        // copy the node vector to file
        const size_t num_nodes = nodes_.size();
        fout.write(
            reinterpret_cast<const char*>(&num_nodes),
            static_cast<std::streamsize>(sizeof(size_t)));
        fout.write(
            reinterpret_cast<const char*>(nodes_.data()),
            static_cast<std::streamsize>(sizeof(Node) * num_nodes));

        // copy the link vector to file
        const size_t num_links = links_.size();
        fout.write(
            reinterpret_cast<const char*>(&num_links),
            static_cast<std::streamsize>(sizeof(size_t)));
        fout.write(
            reinterpret_cast<const char*>(links_.data()),
            static_cast<std::streamsize>(sizeof(Link) * num_links));

        // copy the current_id to file
        fout.write(
            reinterpret_cast<const char*>(&current_id_), static_cast<std::streamsize>(sizeof(int)));
    }

    void load()
    {
        // Load the internal imnodes state
        ImNodes::LoadCurrentEditorStateFromIniFile("save_load.ini");

        // Load our editor state into memory

        std::fstream fin("save_load.bytes", std::ios_base::in | std::ios_base::binary);

        if (!fin.is_open())
        {
            return;
        }

        // copy nodes into memory
        size_t num_nodes;
        fin.read(reinterpret_cast<char*>(&num_nodes), static_cast<std::streamsize>(sizeof(size_t)));
        nodes_.resize(num_nodes);
        fin.read(
            reinterpret_cast<char*>(nodes_.data()),
            static_cast<std::streamsize>(sizeof(Node) * num_nodes));

        // copy links into memory
        size_t num_links;
        fin.read(reinterpret_cast<char*>(&num_links), static_cast<std::streamsize>(sizeof(size_t)));
        links_.resize(num_links);
        fin.read(
            reinterpret_cast<char*>(links_.data()),
            static_cast<std::streamsize>(sizeof(Link) * num_links));

        // copy current_id into memory
        fin.read(reinterpret_cast<char*>(&current_id_), static_cast<std::streamsize>(sizeof(int)));
    }

private:
    std::vector<Node> nodes_;
    std::vector<Link> links_;
    int               current_id_;
};

static SaveLoadEditor editor;
} // namespace

void NodeEditorInitialize()
{
    ImNodes::GetIO().LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyCtrl;
    ImNodes::PushAttributeFlag(ImNodesAttributeFlags_EnableLinkDetachWithDragClick);
    editor.load();
}

void NodeEditorShow() { editor.show(); }

void NodeEditorShutdown()
{
    ImNodes::PopAttributeFlag();
    editor.save();
}
} // namespace example


================================================================================
FILE: imnode_examples\multi_editor.cpp
================================================================================


#include "node_editor.h"
#include <imnodes.h>
#include <imgui.h>
#include <SDL_scancode.h>

#include <algorithm>
#include <vector>

namespace example
{
namespace
{
struct Node
{
    int   id;
    float value;

    Node(const int i, const float v) : id(i), value(v) {}
};

struct Link
{
    int id;
    int start_attr, end_attr;
};

struct Editor
{
    ImNodesEditorContext* context = nullptr;
    std::vector<Node>     nodes;
    std::vector<Link>     links;
    int                   current_id = 0;
};

void show_editor(const char* editor_name, Editor& editor)
{
    ImNodes::EditorContextSet(editor.context);

    ImGui::Begin(editor_name);
    ImGui::TextUnformatted("A -- add node");

    ImNodes::BeginNodeEditor();

    if (ImGui::IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows) &&
        ImNodes::IsEditorHovered() && ImGui::IsKeyReleased(ImGuiKey_A))
    {
        const int node_id = ++editor.current_id;
        ImNodes::SetNodeScreenSpacePos(node_id, ImGui::GetMousePos());
        ImNodes::SnapNodeToGrid(node_id);
        editor.nodes.push_back(Node(node_id, 0.f));
    }

    for (Node& node : editor.nodes)
    {
        ImNodes::BeginNode(node.id);

        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted("node");
        ImNodes::EndNodeTitleBar();

        ImNodes::BeginInputAttribute(node.id << 8);
        ImGui::TextUnformatted("input");
        ImNodes::EndInputAttribute();

        ImNodes::BeginStaticAttribute(node.id << 16);
        ImGui::PushItemWidth(120.0f);
        ImGui::DragFloat("value", &node.value, 0.01f);
        ImGui::PopItemWidth();
        ImNodes::EndStaticAttribute();

        ImNodes::BeginOutputAttribute(node.id << 24);
        const float text_width = ImGui::CalcTextSize("output").x;
        ImGui::Indent(120.f + ImGui::CalcTextSize("value").x - text_width);
        ImGui::TextUnformatted("output");
        ImNodes::EndOutputAttribute();

        ImNodes::EndNode();
    }

    for (const Link& link : editor.links)
    {
        ImNodes::Link(link.id, link.start_attr, link.end_attr);
    }

    ImNodes::EndNodeEditor();

    {
        Link link;
        if (ImNodes::IsLinkCreated(&link.start_attr, &link.end_attr))
        {
            link.id = ++editor.current_id;
            editor.links.push_back(link);
        }
    }

    {
        int link_id;
        if (ImNodes::IsLinkDestroyed(&link_id))
        {
            auto iter = std::find_if(
                editor.links.begin(), editor.links.end(), [link_id](const Link& link) -> bool {
                    return link.id == link_id;
                });
            assert(iter != editor.links.end());
            editor.links.erase(iter);
        }
    }

    ImGui::End();
}

Editor editor1;
Editor editor2;
} // namespace

void NodeEditorInitialize()
{
    editor1.context = ImNodes::EditorContextCreate();
    editor2.context = ImNodes::EditorContextCreate();
    ImNodes::PushAttributeFlag(ImNodesAttributeFlags_EnableLinkDetachWithDragClick);

    ImNodesIO& io = ImNodes::GetIO();
    io.LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyCtrl;
    io.MultipleSelectModifier.Modifier = &ImGui::GetIO().KeyCtrl;

    ImNodesStyle& style = ImNodes::GetStyle();
    style.Flags |= ImNodesStyleFlags_GridLinesPrimary | ImNodesStyleFlags_GridSnapping;
}

void NodeEditorShow()
{
    show_editor("editor1", editor1);
    show_editor("editor2", editor2);
}

void NodeEditorShutdown()
{
    ImNodes::PopAttributeFlag();
    ImNodes::EditorContextFree(editor1.context);
    ImNodes::EditorContextFree(editor2.context);
}
} // namespace example


================================================================================
FILE: imnode_examples\color_node_editor.cpp
================================================================================


#include "node_editor.h"
#include "graph.h"

#include <imnodes.h>
#include <imgui.h>

#include <SDL2/SDL_timer.h>
#include <algorithm>
#include <cassert>
#include <chrono>
#include <cmath>
#include <vector>

namespace example
{
namespace
{
enum class NodeType
{
    add,
    multiply,
    output,
    sine,
    time,
    value
};

struct Node
{
    NodeType type;
    float    value;

    explicit Node(const NodeType t) : type(t), value(0.f) {}

    Node(const NodeType t, const float v) : type(t), value(v) {}
};

template<class T>
T clamp(T x, T a, T b)
{
    return std::min(b, std::max(x, a));
}

static float current_time_seconds = 0.f;
static bool  emulate_three_button_mouse = false;

ImU32 evaluate(const Graph<Node>& graph, const int root_node)
{
    std::stack<int> postorder;
    dfs_traverse(
        graph, root_node, [&postorder](const int node_id) -> void { postorder.push(node_id); });

    std::stack<float> value_stack;
    while (!postorder.empty())
    {
        const int id = postorder.top();
        postorder.pop();
        const Node node = graph.node(id);

        switch (node.type)
        {
        case NodeType::add:
        {
            const float rhs = value_stack.top();
            value_stack.pop();
            const float lhs = value_stack.top();
            value_stack.pop();
            value_stack.push(lhs + rhs);
        }
        break;
        case NodeType::multiply:
        {
            const float rhs = value_stack.top();
            value_stack.pop();
            const float lhs = value_stack.top();
            value_stack.pop();
            value_stack.push(rhs * lhs);
        }
        break;
        case NodeType::sine:
        {
            const float x = value_stack.top();
            value_stack.pop();
            const float res = std::abs(std::sin(x));
            value_stack.push(res);
        }
        break;
        case NodeType::time:
        {
            value_stack.push(current_time_seconds);
        }
        break;
        case NodeType::value:
        {
            // If the edge does not have an edge connecting to another node, then just use the value
            // at this node. It means the node's input pin has not been connected to anything and
            // the value comes from the node's UI.
            if (graph.num_edges_from_node(id) == 0ull)
            {
                value_stack.push(node.value);
            }
        }
        break;
        default:
            break;
        }
    }

    // The final output node isn't evaluated in the loop -- instead we just pop
    // the three values which should be in the stack.
    assert(value_stack.size() == 3ull);
    const int b = static_cast<int>(255.f * clamp(value_stack.top(), 0.f, 1.f) + 0.5f);
    value_stack.pop();
    const int g = static_cast<int>(255.f * clamp(value_stack.top(), 0.f, 1.f) + 0.5f);
    value_stack.pop();
    const int r = static_cast<int>(255.f * clamp(value_stack.top(), 0.f, 1.f) + 0.5f);
    value_stack.pop();

    return IM_COL32(r, g, b, 255);
}

class ColorNodeEditor
{
public:
    ColorNodeEditor()
        : graph_(), nodes_(), root_node_id_(-1),
          minimap_location_(ImNodesMiniMapLocation_BottomRight)
    {
    }

    void show()
    {
        // Update timer context
        current_time_seconds = 0.001f * SDL_GetTicks();

        auto flags = ImGuiWindowFlags_MenuBar;

        // The node editor window
        ImGui::Begin("color node editor", NULL, flags);

        if (ImGui::BeginMenuBar())
        {
            if (ImGui::BeginMenu("Mini-map"))
            {
                const char* names[] = {
                    "Top Left",
                    "Top Right",
                    "Bottom Left",
                    "Bottom Right",
                };
                int locations[] = {
                    ImNodesMiniMapLocation_TopLeft,
                    ImNodesMiniMapLocation_TopRight,
                    ImNodesMiniMapLocation_BottomLeft,
                    ImNodesMiniMapLocation_BottomRight,
                };

                for (int i = 0; i < 4; i++)
                {
                    bool selected = minimap_location_ == locations[i];
                    if (ImGui::MenuItem(names[i], NULL, &selected))
                        minimap_location_ = locations[i];
                }
                ImGui::EndMenu();
            }

            if (ImGui::BeginMenu("Style"))
            {
                if (ImGui::MenuItem("Classic"))
                {
                    ImGui::StyleColorsClassic();
                    ImNodes::StyleColorsClassic();
                }
                if (ImGui::MenuItem("Dark"))
                {
                    ImGui::StyleColorsDark();
                    ImNodes::StyleColorsDark();
                }
                if (ImGui::MenuItem("Light"))
                {
                    ImGui::StyleColorsLight();
                    ImNodes::StyleColorsLight();
                }
                ImGui::EndMenu();
            }

            ImGui::EndMenuBar();
        }

        ImGui::TextUnformatted("Edit the color of the output color window using nodes.");
        ImGui::Columns(2);
        ImGui::TextUnformatted("A -- add node");
        ImGui::TextUnformatted("X -- delete selected node or link");
        ImGui::NextColumn();
        if (ImGui::Checkbox("emulate_three_button_mouse", &emulate_three_button_mouse))
        {
            ImNodes::GetIO().EmulateThreeButtonMouse.Modifier =
                emulate_three_button_mouse ? &ImGui::GetIO().KeyAlt : NULL;
        }
        ImGui::Columns(1);

        ImNodes::BeginNodeEditor();

        // Handle new nodes
        // These are driven by the user, so we place this code before rendering the nodes
        {
            const bool open_popup = ImGui::IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows) &&
                                    ImNodes::IsEditorHovered() && ImGui::IsKeyReleased(ImGuiKey_A);

            ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.f, 8.f));
            if (!ImGui::IsAnyItemHovered() && open_popup)
            {
                ImGui::OpenPopup("add node");
            }

            if (ImGui::BeginPopup("add node"))
            {
                const ImVec2 click_pos = ImGui::GetMousePosOnOpeningCurrentPopup();

                if (ImGui::MenuItem("add"))
                {
                    const Node value(NodeType::value, 0.f);
                    const Node op(NodeType::add);

                    UiNode ui_node;
                    ui_node.type = UiNodeType::add;
                    ui_node.ui.add.lhs = graph_.insert_node(value);
                    ui_node.ui.add.rhs = graph_.insert_node(value);
                    ui_node.id = graph_.insert_node(op);

                    graph_.insert_edge(ui_node.id, ui_node.ui.add.lhs);
                    graph_.insert_edge(ui_node.id, ui_node.ui.add.rhs);

                    nodes_.push_back(ui_node);
                    ImNodes::SetNodeScreenSpacePos(ui_node.id, click_pos);
                }

                if (ImGui::MenuItem("multiply"))
                {
                    const Node value(NodeType::value, 0.f);
                    const Node op(NodeType::multiply);

                    UiNode ui_node;
                    ui_node.type = UiNodeType::multiply;
                    ui_node.ui.multiply.lhs = graph_.insert_node(value);
                    ui_node.ui.multiply.rhs = graph_.insert_node(value);
                    ui_node.id = graph_.insert_node(op);

                    graph_.insert_edge(ui_node.id, ui_node.ui.multiply.lhs);
                    graph_.insert_edge(ui_node.id, ui_node.ui.multiply.rhs);

                    nodes_.push_back(ui_node);
                    ImNodes::SetNodeScreenSpacePos(ui_node.id, click_pos);
                }

                if (ImGui::MenuItem("output") && root_node_id_ == -1)
                {
                    const Node value(NodeType::value, 0.f);
                    const Node out(NodeType::output);

                    UiNode ui_node;
                    ui_node.type = UiNodeType::output;
                    ui_node.ui.output.r = graph_.insert_node(value);
                    ui_node.ui.output.g = graph_.insert_node(value);
                    ui_node.ui.output.b = graph_.insert_node(value);
                    ui_node.id = graph_.insert_node(out);

                    graph_.insert_edge(ui_node.id, ui_node.ui.output.r);
                    graph_.insert_edge(ui_node.id, ui_node.ui.output.g);
                    graph_.insert_edge(ui_node.id, ui_node.ui.output.b);

                    nodes_.push_back(ui_node);
                    ImNodes::SetNodeScreenSpacePos(ui_node.id, click_pos);
                    root_node_id_ = ui_node.id;
                }

                if (ImGui::MenuItem("sine"))
                {
                    const Node value(NodeType::value, 0.f);
                    const Node op(NodeType::sine);

                    UiNode ui_node;
                    ui_node.type = UiNodeType::sine;
                    ui_node.ui.sine.input = graph_.insert_node(value);
                    ui_node.id = graph_.insert_node(op);

                    graph_.insert_edge(ui_node.id, ui_node.ui.sine.input);

                    nodes_.push_back(ui_node);
                    ImNodes::SetNodeScreenSpacePos(ui_node.id, click_pos);
                }

                if (ImGui::MenuItem("time"))
                {
                    UiNode ui_node;
                    ui_node.type = UiNodeType::time;
                    ui_node.id = graph_.insert_node(Node(NodeType::time));

                    nodes_.push_back(ui_node);
                    ImNodes::SetNodeScreenSpacePos(ui_node.id, click_pos);
                }

                ImGui::EndPopup();
            }
            ImGui::PopStyleVar();
        }

        for (const UiNode& node : nodes_)
        {
            switch (node.type)
            {
            case UiNodeType::add:
            {
                const float node_width = 100.f;
                ImNodes::BeginNode(node.id);

                ImNodes::BeginNodeTitleBar();
                ImGui::TextUnformatted("add");
                ImNodes::EndNodeTitleBar();
                {
                    ImNodes::BeginInputAttribute(node.ui.add.lhs);
                    const float label_width = ImGui::CalcTextSize("left").x;
                    ImGui::TextUnformatted("left");
                    if (graph_.num_edges_from_node(node.ui.add.lhs) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat("##hidelabel", &graph_.node(node.ui.add.lhs).value, 0.01f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                {
                    ImNodes::BeginInputAttribute(node.ui.add.rhs);
                    const float label_width = ImGui::CalcTextSize("right").x;
                    ImGui::TextUnformatted("right");
                    if (graph_.num_edges_from_node(node.ui.add.rhs) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat("##hidelabel", &graph_.node(node.ui.add.rhs).value, 0.01f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                ImGui::Spacing();

                {
                    ImNodes::BeginOutputAttribute(node.id);
                    const float label_width = ImGui::CalcTextSize("result").x;
                    ImGui::Indent(node_width - label_width);
                    ImGui::TextUnformatted("result");
                    ImNodes::EndOutputAttribute();
                }

                ImNodes::EndNode();
            }
            break;
            case UiNodeType::multiply:
            {
                const float node_width = 100.0f;
                ImNodes::BeginNode(node.id);

                ImNodes::BeginNodeTitleBar();
                ImGui::TextUnformatted("multiply");
                ImNodes::EndNodeTitleBar();

                {
                    ImNodes::BeginInputAttribute(node.ui.multiply.lhs);
                    const float label_width = ImGui::CalcTextSize("left").x;
                    ImGui::TextUnformatted("left");
                    if (graph_.num_edges_from_node(node.ui.multiply.lhs) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat(
                            "##hidelabel", &graph_.node(node.ui.multiply.lhs).value, 0.01f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                {
                    ImNodes::BeginInputAttribute(node.ui.multiply.rhs);
                    const float label_width = ImGui::CalcTextSize("right").x;
                    ImGui::TextUnformatted("right");
                    if (graph_.num_edges_from_node(node.ui.multiply.rhs) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat(
                            "##hidelabel", &graph_.node(node.ui.multiply.rhs).value, 0.01f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                ImGui::Spacing();

                {
                    ImNodes::BeginOutputAttribute(node.id);
                    const float label_width = ImGui::CalcTextSize("result").x;
                    ImGui::Indent(node_width - label_width);
                    ImGui::TextUnformatted("result");
                    ImNodes::EndOutputAttribute();
                }

                ImNodes::EndNode();
            }
            break;
            case UiNodeType::output:
            {
                const float node_width = 100.0f;
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(11, 109, 191, 255));
                ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, IM_COL32(45, 126, 194, 255));
                ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, IM_COL32(81, 148, 204, 255));
                ImNodes::BeginNode(node.id);

                ImNodes::BeginNodeTitleBar();
                ImGui::TextUnformatted("output");
                ImNodes::EndNodeTitleBar();

                ImGui::Dummy(ImVec2(node_width, 0.f));
                {
                    ImNodes::BeginInputAttribute(node.ui.output.r);
                    const float label_width = ImGui::CalcTextSize("r").x;
                    ImGui::TextUnformatted("r");
                    if (graph_.num_edges_from_node(node.ui.output.r) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat(
                            "##hidelabel", &graph_.node(node.ui.output.r).value, 0.01f, 0.f, 1.0f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                ImGui::Spacing();

                {
                    ImNodes::BeginInputAttribute(node.ui.output.g);
                    const float label_width = ImGui::CalcTextSize("g").x;
                    ImGui::TextUnformatted("g");
                    if (graph_.num_edges_from_node(node.ui.output.g) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat(
                            "##hidelabel", &graph_.node(node.ui.output.g).value, 0.01f, 0.f, 1.f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                ImGui::Spacing();

                {
                    ImNodes::BeginInputAttribute(node.ui.output.b);
                    const float label_width = ImGui::CalcTextSize("b").x;
                    ImGui::TextUnformatted("b");
                    if (graph_.num_edges_from_node(node.ui.output.b) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat(
                            "##hidelabel", &graph_.node(node.ui.output.b).value, 0.01f, 0.f, 1.0f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }
                ImNodes::EndNode();
                ImNodes::PopColorStyle();
                ImNodes::PopColorStyle();
                ImNodes::PopColorStyle();
            }
            break;
            case UiNodeType::sine:
            {
                const float node_width = 100.0f;
                ImNodes::BeginNode(node.id);

                ImNodes::BeginNodeTitleBar();
                ImGui::TextUnformatted("sine");
                ImNodes::EndNodeTitleBar();

                {
                    ImNodes::BeginInputAttribute(node.ui.sine.input);
                    const float label_width = ImGui::CalcTextSize("number").x;
                    ImGui::TextUnformatted("number");
                    if (graph_.num_edges_from_node(node.ui.sine.input) == 0ull)
                    {
                        ImGui::SameLine();
                        ImGui::PushItemWidth(node_width - label_width);
                        ImGui::DragFloat(
                            "##hidelabel",
                            &graph_.node(node.ui.sine.input).value,
                            0.01f,
                            0.f,
                            1.0f);
                        ImGui::PopItemWidth();
                    }
                    ImNodes::EndInputAttribute();
                }

                ImGui::Spacing();

                {
                    ImNodes::BeginOutputAttribute(node.id);
                    const float label_width = ImGui::CalcTextSize("output").x;
                    ImGui::Indent(node_width - label_width);
                    ImGui::TextUnformatted("output");
                    ImNodes::EndOutputAttribute();
                }

                ImNodes::EndNode();
            }
            break;
            case UiNodeType::time:
            {
                ImNodes::BeginNode(node.id);

                ImNodes::BeginNodeTitleBar();
                ImGui::TextUnformatted("time");
                ImNodes::EndNodeTitleBar();

                ImNodes::BeginOutputAttribute(node.id);
                ImGui::Text("output");
                ImNodes::EndOutputAttribute();

                ImNodes::EndNode();
            }
            break;
            }
        }

        for (const auto& edge : graph_.edges())
        {
            // If edge doesn't start at value, then it's an internal edge, i.e.
            // an edge which links a node's operation to its input. We don't
            // want to render node internals with visible links.
            if (graph_.node(edge.from).type != NodeType::value)
                continue;

            ImNodes::Link(edge.id, edge.from, edge.to);
        }

        ImNodes::MiniMap(0.2f, minimap_location_);
        ImNodes::EndNodeEditor();

        // Handle new links
        // These are driven by Imnodes, so we place the code after EndNodeEditor().

        {
            int start_attr, end_attr;
            if (ImNodes::IsLinkCreated(&start_attr, &end_attr))
            {
                const NodeType start_type = graph_.node(start_attr).type;
                const NodeType end_type = graph_.node(end_attr).type;

                const bool valid_link = start_type != end_type;
                if (valid_link)
                {
                    // Ensure the edge is always directed from the value to
                    // whatever produces the value
                    if (start_type != NodeType::value)
                    {
                        std::swap(start_attr, end_attr);
                    }
                    graph_.insert_edge(start_attr, end_attr);
                }
            }
        }

        // Handle deleted links

        {
            int link_id;
            if (ImNodes::IsLinkDestroyed(&link_id))
            {
                graph_.erase_edge(link_id);
            }
        }

        {
            const int num_selected = ImNodes::NumSelectedLinks();
            if (num_selected > 0 && ImGui::IsKeyReleased(ImGuiKey_X))
            {
                static std::vector<int> selected_links;
                selected_links.resize(static_cast<size_t>(num_selected));
                ImNodes::GetSelectedLinks(selected_links.data());
                for (const int edge_id : selected_links)
                {
                    graph_.erase_edge(edge_id);
                }
            }
        }

        {
            const int num_selected = ImNodes::NumSelectedNodes();
            if (num_selected > 0 && ImGui::IsKeyReleased(ImGuiKey_X))
            {
                static std::vector<int> selected_nodes;
                selected_nodes.resize(static_cast<size_t>(num_selected));
                ImNodes::GetSelectedNodes(selected_nodes.data());
                for (const int node_id : selected_nodes)
                {
                    graph_.erase_node(node_id);
                    auto iter = std::find_if(
                        nodes_.begin(), nodes_.end(), [node_id](const UiNode& node) -> bool {
                            return node.id == node_id;
                        });
                    // Erase any additional internal nodes
                    switch (iter->type)
                    {
                    case UiNodeType::add:
                        graph_.erase_node(iter->ui.add.lhs);
                        graph_.erase_node(iter->ui.add.rhs);
                        break;
                    case UiNodeType::multiply:
                        graph_.erase_node(iter->ui.multiply.lhs);
                        graph_.erase_node(iter->ui.multiply.rhs);
                        break;
                    case UiNodeType::output:
                        graph_.erase_node(iter->ui.output.r);
                        graph_.erase_node(iter->ui.output.g);
                        graph_.erase_node(iter->ui.output.b);
                        root_node_id_ = -1;
                        break;
                    case UiNodeType::sine:
                        graph_.erase_node(iter->ui.sine.input);
                        break;
                    default:
                        break;
                    }
                    nodes_.erase(iter);
                }
            }
        }

        ImGui::End();

        // The color output window

        const ImU32 color =
            root_node_id_ != -1 ? evaluate(graph_, root_node_id_) : IM_COL32(255, 20, 147, 255);
        ImGui::PushStyleColor(ImGuiCol_WindowBg, color);
        ImGui::Begin("output color");
        ImGui::End();
        ImGui::PopStyleColor();
    }

private:
    enum class UiNodeType
    {
        add,
        multiply,
        output,
        sine,
        time,
    };

    struct UiNode
    {
        UiNodeType type;
        // The identifying id of the ui node. For add, multiply, sine, and time
        // this is the "operation" node id. The additional input nodes are
        // stored in the structs.
        int id;

        union
        {
            struct
            {
                int lhs, rhs;
            } add;

            struct
            {
                int lhs, rhs;
            } multiply;

            struct
            {
                int r, g, b;
            } output;

            struct
            {
                int input;
            } sine;
        } ui;
    };

    Graph<Node>            graph_;
    std::vector<UiNode>    nodes_;
    int                    root_node_id_;
    ImNodesMiniMapLocation minimap_location_;
};

static ColorNodeEditor color_editor;
} // namespace

void NodeEditorInitialize()
{
    ImNodesIO& io = ImNodes::GetIO();
    io.LinkDetachWithModifierClick.Modifier = &ImGui::GetIO().KeyCtrl;
}

void NodeEditorShow() { color_editor.show(); }

void NodeEditorShutdown() {}
} // namespace example

