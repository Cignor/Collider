#pragma once

#include "ModuleProcessor.h"
#include <juce_audio_formats/juce_audio_formats.h>

class RecordModuleProcessor : public ModuleProcessor
{
public:
    RecordModuleProcessor();
    ~RecordModuleProcessor() override;

    const juce::String getName() const override { return "recorder"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void releaseResources() override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    juce::String getAudioInputLabel(int channel) const override;

    // Query recording state (prevents spacebar from stopping audio during recording)
    bool getIsRecording() const { return isRecording.load(); }
    
    // Pause/Resume recording (used by spacebar hold-to-audition)
    void pauseRecording() { isPaused = true; }
    void resumeRecording() { isPaused = false; }
    
    // Programmatic start/stop for global recording control
    void programmaticStartRecording();
    void programmaticStopRecording();

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String&)>&, const std::function<void()>&) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
    void requestStartRecording(const juce::File& file);
    
    // This is called by the editor when cables are connected/disconnected
    void updateSuggestedFilename(const juce::String& sourceName = "");
    
    // Set the properties file for persistent storage
    void setPropertiesFile(juce::PropertiesFile* props);
#endif

private:
    class WriterThread : public juce::Thread
    {
    public:
        WriterThread(RecordModuleProcessor& owner);
        ~WriterThread() override;
        void run() override;
        void stopRecording();

    private:
        bool doStartRecording();
        RecordModuleProcessor& owner;
        std::unique_ptr<juce::AudioFormatWriter> writer;
        juce::CriticalSection writerLock;
    };
    
    juce::AudioBuffer<float> fifoBuffer;
    juce::AbstractFifo abstractFifo { 0 };
    std::atomic<bool> isRecording { false };
    std::atomic<bool> isPaused { false };

    juce::AbstractFifo waveformFifo { 0 };
    std::vector<float> waveformFifoBuffer;
    
    WriterThread writerThread;

    juce::AudioFormatManager formatManager;
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    juce::AudioProcessorValueTreeState apvts;
    juce::AudioParameterChoice* formatParam { nullptr };

#if defined(PRESET_CREATOR_UI)
    std::unique_ptr<juce::FileChooser> fileChooser;
    juce::File saveDirectory;
    juce::String autoGeneratedPrefix;
    char userSuffixBuffer[256] { "" };
    juce::PropertiesFile* propertiesFile { nullptr };
#endif

    // Thread-safe communication for start requests
    juce::CriticalSection startRequestLock;
    juce::File pendingFileToRecord;
    std::atomic<bool> startRequestPending { false };

    juce::String currentFileRecording;
    std::atomic<int64_t> totalSamplesRecorded { 0 };
    std::vector<float> waveformData;
    juce::AudioBuffer<float> workBuffer;
};
