
================================================================================
FILE: guides\NOTIFICATION_SYSTEM_INTEGRATION_GUIDE.md
================================================================================


# üé® Notification System Integration Guide

**Objective**: Design and implement a robust, non-blocking notification system for the Preset Creator application. This system will replace the current, basic save notifications with a more flexible, informative, and visually appealing solution.

---

## 1. Current System Overview

The current notification system is a proof-of-concept implemented for save operations. It has several limitations that the new system should address.

### Existing Implementation

- **`ImGuiNodeEditorComponent::showSaveNotification()`**: A simple function that displays a `juce::Label` in the top-right corner.

- **`ImGuiNodeEditorComponent::renderImGui()`**: Contains logic to display a temporary, animated "Saving..." spinner while the `isSaveInProgress` flag is true.

### Code Snippets

**Notification Display (`showSaveNotification`)**

```cpp
// In ImGuiNodeEditorComponent.cpp (lines ~5520-5544)

void ImGuiNodeEditorComponent::showSaveNotification(const juce::String& message, juce::Colour color)
{
    if (!saveStatusLabel) {
        saveStatusLabel = std::make_unique<juce::Label>();
        addAndMakeVisible(*saveStatusLabel);
        saveStatusLabel->setJustificationType(juce::Justification::centred);
        saveStatusLabel->setColour(juce::Label::textColourId, juce::Colours::white);
        saveStatusLabel->setColour(juce::Label::outlineColourId, juce::Colours::black);
    }
    
    saveStatusLabel->setText(message, juce::dontSendNotification);
    saveStatusLabel->setColour(juce::Label::backgroundColourId, color);
    
    // Position it in the top-right corner, below the main menu bar
    saveStatusLabel->setBounds(getWidth() - 310, 30, 300, 40);
    saveStatusLabel->setVisible(true);
    saveStatusLabel->toFront(true);

    // Auto-hide after 4 seconds
    juce::Timer::callAfterDelay(4000, [this]() { 
        if (saveStatusLabel) 
            saveStatusLabel->setVisible(false); 
    });
}
```

**Save Progress Spinner (`renderImGui`)**

```cpp
// In ImGuiNodeEditorComponent.cpp (lines ~428-455)

void ImGuiNodeEditorComponent::renderImGui()
{
    // ...
    
    // --- NEW: In-Progress Save Indicator ---
    if (isSaveInProgress.load())
    {
        const float windowWidth = 200.0f;
        const float windowHeight = 50.0f;
        const float padding = 10.0f;
        
        ImGui::SetNextWindowPos(ImVec2(getWidth() - windowWidth - padding, ImGui::GetFrameHeight() + padding));
        ImGui::SetNextWindowSize(ImVec2(windowWidth, windowHeight));
        ImGui::SetNextWindowBgAlpha(0.8f);

        ImGui::Begin("Save Progress", nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav);

        // Simple animated spinner
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        const float radius = 10.0f;
        ImVec2 spinnerCenter = ImVec2(ImGui::GetCursorScreenPos().x + radius + 5, ImGui::GetCursorScreenPos().y + ImGui::GetTextLineHeight() / 2 + 5);
        float time = (float)ImGui::GetTime();
        drawList->PathClear();
        drawList->PathArcTo(spinnerCenter, radius, time * 2.0f - 1.57f, time * 2.0f + 1.57f, 32);
        drawList->PathStroke(IM_COL32(255, 255, 255, 255), 0, 2.0f);
        
        ImGui::SameLine(35.0f);
        ImGui::Text("Saving...");

        ImGui::End();
    }
    // --- END NEW INDICATOR ---
    
    // ...
}
```

### Limitations of the Current System

- **Single Message**: Can only display one notification at a time.
- **No Queuing**: New messages immediately overwrite the current one.
- **Limited Types**: Only supports a colored background; no distinct icons or styles for success, error, etc.
- **JUCE-Based**: It uses a `juce::Label`, which is drawn *under* the ImGui context, making it feel disconnected from the main UI. The new system should be pure ImGui.
- **Not Centralized**: The logic is split between two different functions and tied specifically to the save process.

---

## 2. Architecture Context

The application uses a hybrid JUCE/ImGui architecture.

- **JUCE**: Manages the window, audio processing, and OpenGL context. `ImGuiNodeEditorComponent` is a `juce::Component`.
- **ImGui**: Renders the entire user interface, including the node editor, within the `renderOpenGL()` callback.
- **Threading**:
    - **UI Thread (Message Thread)**: Handles all user input and ImGui rendering. It must remain responsive.
    - **Background Threads**: A `juce::ThreadPool` is used for slow operations like saving presets (`SavePresetJob`).
    - **Audio Thread**: Handles all real-time audio processing.

**Key Takeaway**: The new notification system must be rendered entirely within the ImGui `renderImGui()` loop and must be thread-safe to allow messages to be posted from background threads (like `SavePresetJob`).

---

## 3. Requirements Specification

The new system should be a significant upgrade, providing clear and consistent user feedback.

### Message Types

The system must support 5 distinct message types, each with a unique icon and color:

| Type | Icon | Color (ImGui) | Description |
| :--- | :--- | :--- | :--- |
| **Status** | üîÑ (Spinner) | Neutral (Grey/Blue) | For ongoing, non-blocking operations (e.g., "Scanning plugins..."). |
| **Success**| ‚úÖ | Green | For successful completion of an action (e.g., "Preset saved"). |
| **Error** | ‚ùå | Red | For critical failures (e.g., "Failed to load file"). |
| **Warning**| ‚ö†Ô∏è | Yellow/Orange | For non-critical issues (e.g., "Preset loaded with 2 missing connections"). |
| **Info** | ‚ÑπÔ∏è | Blue | For general information (e.g., "Auto-connected to Track Mixer"). |

### Functional Requirements

- **Message Queuing**: The system must maintain a queue of notifications. New messages should be added to the queue and displayed without overwriting existing ones.
- **Positioning**: Notifications should appear in the **top-right corner** of the screen and stack downwards.
- **Animation**:
    - **Fade In/Out**: Each notification should smoothly fade in upon arrival and fade out upon dismissal.
    - **Slide In/Out**: Notifications should slide in from the right edge of the screen and slide out to the right.
- **Auto-Dismissal**: Success, Info, and Warning messages should automatically dismiss after a configurable duration (e.g., 5 seconds). Error messages should persist until clicked.
- **Manual Dismissal**: All notifications can be dismissed by clicking on them.
- **Thread Safety**: It must be possible to post a notification from any thread (UI, background save thread, etc.).

### Visual Styling

- Semi-transparent background.
- Clear iconography on the left.
- Message text on the right.
- A subtle progress bar at the bottom showing the remaining time until auto-dismissal.

---

## 4. Integration Points

The new notification system should be used in the following places:

- **Save Operations**:
    - `savePresetToFile()`: Post a **Status** message ("Saving...") when the job starts and a **Success** or **Error** message in the `onSaveComplete` callback.

**Current Save Implementation** (`ImGuiNodeEditorComponent.cpp`, lines ~5441-5496):

```cpp
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    // ... save logic ...
    
    auto* job = new SavePresetJob(synthState, uiState, file);
    job->onSaveComplete = [this](const juce::File& savedFile, bool success) {
        if (success) {
            showSaveNotification("Saved: " + savedFile.getFileNameWithoutExtension(), 
                               juce::Colours::darkgreen);
            // Should become: NotificationManager::getInstance().post(Notification::Type::Success, "Saved: " + ...);
        } else {
            showSaveNotification("Error: Failed to save preset!", 
                               juce::Colours::darkred);
            // Should become: NotificationManager::getInstance().post(Notification::Type::Error, "Failed to save preset!");
        }
    };
}
```

- **Load Operations**:
    - `loadPresetFromFile()`: Post a **Success** message on successful load. If validation/healing occurs, post a **Warning** message with a summary of issues found.

- **Undo/Redo**:
    - `pushSnapshot()`: Post an **Info** message ("State saved to undo history").

- **Auto-Connection Features**:
    - `handleNodeChaining()`, `handleConnectSelectedToTrackMixer()`, etc.: Post an **Info** message summarizing the action (e.g., "Chained 3 nodes").

- **Background Scans**:
    - Plugin Scanner: Post a **Status** message ("Scanning plugins...") and a **Success** message upon completion.

---

## 5. Design & Implementation Recommendations

A singleton manager class is the cleanest approach.

### Proposed Architecture

1. **`Notification` Struct**: A simple struct to hold the data for a single message (type, text, creation time, duration).

2. **`NotificationManager` Singleton**: A thread-safe singleton class to manage the queue of notifications.
    - `std::vector<Notification> notifications`: The active queue.
    - `juce::CriticalSection lock`: To protect access to the queue.
    - `post(type, message)`: A static, thread-safe method to add a new notification.
    - `render()`: An ImGui-based function to be called from `renderImGui()` that handles the drawing, animation, and dismissal logic for all active notifications.

### `SavePresetJob` Integration Example

```cpp
// In SavePresetJob.cpp

SavePresetJob::JobStatus SavePresetJob::runJob()
{
    // ... (save logic) ...
    
    // Signal completion back to the UI thread
    juce::MessageManager::callAsync([this, success = writeSuccess]() {
        if (onSaveComplete) onSaveComplete(fileToSave, success);
        
        // NEW: Post notification from the callback on the UI thread
        if (success) {
            NotificationManager::getInstance().post(Notification::Type::Success, "Saved: " + fileToSave.getFileNameWithoutExtension());
        } else {
            NotificationManager::getInstance().post(Notification::Type::Error, "Error saving preset!");
        }
    });
    
    return jobHasFinished;
}
```

### Migration Path

1. Implement the `Notification` struct and `NotificationManager` class.
2. Add a call to `NotificationManager::getInstance().render()` inside `ImGuiNodeEditorComponent::renderImGui()`.
3. Replace the `showSaveNotification()` function and the "Saving..." spinner logic with calls to `NotificationManager::getInstance().post()`.
4. Gradually integrate `post()` calls into the other integration points listed above.

---

## 6. Questions for the Expert

1. What is the best way to handle the animation timing (fade/slide) within the ImGui `render()` loop?

2. Should the `NotificationManager` be a JUCE singleton or a simple static instance?

3. What's a robust pattern for handling the "time remaining" progress bar for auto-dismissal?

4. For the `post()` method, is a `juce::CriticalSection` sufficient for thread safety, or would a lock-free queue be better?

5. How should the `render()` function be designed to handle the stacking and downward movement of notifications as they are added or removed?

6. Should the notification manager be part of the `ImGuiNodeEditorComponent` or a globally accessible utility?

7. What's the best way to handle potential text overflow for long messages?

8. Can you provide a basic implementation of the `NotificationManager` class, including the `post()` and `render()` methods, that meets these requirements?

---

## 7. Relevant Code Files

### Primary Files

#### 1. `juce/Source/preset_creator/ImGuiNodeEditorComponent.h`

**Key Members Related to Notifications**:

```cpp
// Lines 335-337
std::atomic<bool> isSaveInProgress { false }; // Debouncing flag for save operations
juce::ThreadPool threadPool { 2 };
std::unique_ptr<juce::Label> saveStatusLabel; // Non-blocking notification (to be replaced)

// Line 168
void showSaveNotification(const juce::String& message, juce::Colour color); // To be replaced
```

#### 2. `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Key Functions**:
- `renderImGui()`: Main rendering function (line ~349)
- `showSaveNotification()`: Current notification display (line ~5520)
- `savePresetToFile()`: Save operation that posts notifications (line ~5441)

#### 3. `juce/Source/preset_creator/SavePresetJob.h` and `.cpp`

**Purpose**: Background thread job for saving presets asynchronously

**Key Pattern**: Uses `MessageManager::callAsync()` to communicate completion back to UI thread

```cpp
// Signal completion back to the UI thread
juce::MessageManager::callAsync([this, success = writeSuccess]() {
    if (onSaveComplete) onSaveComplete(fileToSave, success);
});
```

**Thread-Safe Pattern**: This is the pattern that should be used when posting notifications from background threads.

---

## 8. Thread Safety Considerations

### Current Pattern

**From Background Threads**:
```cpp
// Background thread
bool success = doBackgroundWork();

// Communicate to UI thread
juce::MessageManager::callAsync([this, success]() {
    if (success) {
        showSaveNotification("Success", juce::Colours::green);
    } else {
        showSaveNotification("Error", juce::Colours::red);
    }
});
```

### Recommended Pattern for Notification System

**Option 1: MessageManager Pattern** (Current approach - Recommended)
```cpp
// From any thread
juce::MessageManager::callAsync([this]() {
    NotificationManager::getInstance().post(Notification::Type::Success, "Message");
});
```

**Option 2: Thread-Safe Queue Pattern** (Alternative)
```cpp
// From any thread (thread-safe)
NotificationManager::getInstance().post(Notification::Type::Success, "Message");
// NotificationManager processes queue on UI thread
```

**Recommendation**: Option 1 is simpler and matches existing patterns. Option 2 might be more efficient if many messages are queued, but requires more careful implementation.

### Critical Points

1. **All rendering must be on UI thread** (inside `renderImGui()`)
2. **State changes should be atomic or message-thread-only**
3. **No blocking operations** in notification system
4. **Safe to call from audio thread** (if needed) via `MessageManager::callAsync`

---

## 9. Example Usage Scenarios

### Scenario 1: Save Operation

```cpp
// In savePresetToFile()
NotificationManager::getInstance().post(Notification::Type::Status, "Saving preset...");

// Background save completes
juce::MessageManager::callAsync([this]() {
    NotificationManager::getInstance().post(Notification::Type::Success, "Preset saved: MyPatch.xml");
});
```

### Scenario 2: Load with Validation

```cpp
NotificationManager::getInstance().post(Notification::Type::Status, "Loading preset...");

// Load completes with warnings
juce::MessageManager::callAsync([this, warningCount]() {
    NotificationManager::getInstance().post(
        Notification::Type::Warning,
        "Preset loaded with " + juce::String(warningCount) + " issues (auto-healed)"
    );
});
```

### Scenario 3: Undo/Redo

```cpp
// User presses Ctrl+Z
performUndo();
NotificationManager::getInstance().post(Notification::Type::Info, "Undo: Deleted VCO node");

// User presses Ctrl+Shift+Z
performRedo();
NotificationManager::getInstance().post(Notification::Type::Info, "Redo: Added VCO node");
```

### Scenario 4: Error from Background Thread

```cpp
// Background thread encounters error
juce::MessageManager::callAsync([this, errorMsg]() {
    NotificationManager::getInstance().post(Notification::Type::Error, "Export failed: " + errorMsg);
});
```

---

## 10. Deliverables Expected

1. **NotificationManager Class**
   - Header file (`NotificationManager.h`)
   - Implementation file (`NotificationManager.cpp`)
   - Clear, commented code

2. **Integration Guide**
   - Step-by-step integration instructions
   - Code examples for common use cases
   - Migration path from existing system

3. **API Documentation**
   - Public API reference
   - Thread-safety notes
   - Usage examples

4. **Styling Guide**
   - How to customize colors
   - How to adjust positioning
   - How to modify animations

5. **Testing Recommendations**
   - How to test thread safety
   - How to test animation performance
   - How to test edge cases (many messages, rapid updates)

---

## Conclusion

The current notification system is basic and limited to save operations. We need a centralized, flexible system that can handle multiple message types, queue messages, and integrate with all aspects of the application while maintaining thread safety and performance.

The expert should design a solution that:
- Fits naturally with the existing JUCE/ImGui architecture
- Provides a clean, easy-to-use API
- Handles threading correctly
- Renders efficiently
- Is easy to extend and customize

Thank you for your expertise in designing this system!


================================================================================
FILE: guides\XML_SAVING_AND_LOADING_HOW_TO.md
================================================================================


# XML Preset Saving and Loading - Complete Technical Guide

**Target Audience:** AI assistants and developers who need to understand the complete XML preset system in this JUCE-based modular synthesizer project.

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture](#architecture)
3. [Supporting Systems](#supporting-systems)
4. [The Save Process](#the-save-process)
5. [The Load Process](#the-load-process)
6. [XML File Structure](#xml-file-structure)
7. [Module Parameter Serialization](#module-parameter-serialization)
8. [Connection Management](#connection-management)
9. [UI State Persistence](#ui-state-persistence)
10. [Special Cases](#special-cases)
11. [Code Examples](#code-examples)
12. [Improvement Opportunities](#improvement-opportunities)

---

## System Overview

This modular synthesizer uses **XML-based presets** to save and restore complete patch configurations including:

- **Modules** (VCO, VCF, VCA, effects, utilities, etc.)
- **Module parameters** (frequency, waveform, envelope settings, etc.)
- **Audio connections** (routing between modules)
- **Modulation routings** (CV parameter modulation)
- **UI state** (node positions, colors, mute states)
- **VST plugin instances** (including their internal state)

The system is built on **JUCE's ValueTree** and **AudioProcessorValueTreeState (APVTS)** framework, which provides:
- Automatic parameter management
- Undo/redo support
- Thread-safe parameter access
- XML serialization/deserialization

---

## Architecture

### Key Classes

#### 1. **ModularSynthProcessor** (`juce/Source/audio/graph/ModularSynthProcessor.cpp`)
The core audio graph that manages all modules and connections.

**Responsibilities:**
- Maintains the `AudioProcessorGraph` (JUCE's internal audio routing system)
- Tracks all modules via **logical IDs** (stable across save/load)
- Implements `getStateInformation()` and `setStateInformation()` for serialization
- Manages audio connections between modules

#### 2. **ModuleProcessor** (`juce/Source/audio/modules/ModuleProcessor.h`)
Abstract base class for all synthesizer modules.

**Responsibilities:**
- Provides `getAPVTS()` for parameter access
- Implements `getExtraStateTree()` for module-specific state (file paths, etc.)
- Handles audio processing via `processBlock()`

#### 3. **PresetCreatorComponent** (`juce/Source/preset_creator/PresetCreatorComponent.cpp`)
The UI layer that triggers save/load operations.

**Responsibilities:**
- Presents file chooser dialogs
- Orchestrates save/load sequences
- Handles mute state management during save
- Updates UI after load

#### 4. **ImGuiNodeEditorComponent** (`juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`)
The visual node graph editor.

**Responsibilities:**
- Stores node positions, colors, sizes
- Manages mute states
- Provides `getUiValueTree()` for UI serialization
- Applies UI state via `applyUiValueTreeNow()`

---

## Supporting Systems

The XML save/load system relies on two critical supporting systems that define module metadata and documentation. Understanding these systems is essential for improving save/load functionality or adding new module types.

### 1. Pin Database (`juce/Source/preset_creator/PinDatabase.cpp`)

#### Overview

The **Pin Database** is a static registry that defines the input/output pin configuration for every module type in the system. It is used by the node editor UI to render pins correctly, validate connections, and provide auto-connection features.

#### Purpose

The pin database serves multiple critical functions:

1. **UI Rendering:** Tells the node editor which pins to display for each module type
2. **Connection Validation:** Ensures connections are made to valid pin types (Audio, CV, Gate, etc.)
3. **Auto-Connection:** Enables keyboard shortcuts (C/G/B/Y/R/V) to chain modules by data type
4. **Pin Type Safety:** Defines data types (Audio, CV, Gate, Raw, Video) for each pin
5. **Channel Mapping:** Specifies absolute channel indices for multi-channel modules

#### Key Data Structures

```cpp
// From PinDatabase.h (implied structure)
struct AudioPin {
    juce::String name;          // Display name (e.g., "In L", "Frequency Mod")
    int channelIndex;           // Absolute channel index in audio bus
    PinDataType dataType;       // Audio, CV, Gate, Raw, or Video
};

struct ModPin {
    juce::String name;          // Display name (e.g., "Frequency")
    juce::String paramId;       // APVTS parameter ID (e.g., "frequency_mod")
    PinDataType dataType;       // Typically CV
};

struct ModulePinInfo {
    NodeWidth defaultWidth;     // Small, Medium, Big, ExtraWide, or Exception
    std::vector<AudioPin> audioIns;   // Input pins
    std::vector<AudioPin> audioOuts;  // Output pins
    std::vector<ModPin> modPins;      // Modulation pins (for UI parameter disabling)
};
```

#### How It Works

The database is populated once at startup via `populatePinDatabase()`. Each module type is registered with its complete pin configuration:

```cpp
db["vco"] = ModulePinInfo(
    NodeWidth::Small,
    { 
        AudioPin("Frequency", 0, PinDataType::CV),
        AudioPin("Waveform", 1, PinDataType::CV),
        AudioPin("Gate", 2, PinDataType::Gate)
    },
    { 
        AudioPin("Out", 0, PinDataType::Audio)
    },
    {}
);
```

#### Relationship to Save/Load

**Important:** The Pin Database is **NOT directly saved in XML presets**. However, it is critical for load validation and UI reconstruction:

1. **Module Type Verification:** When loading, the system checks that the `type` string in XML matches a registered module type in the pin database
2. **Connection Validation:** After loading connections, the pin database can verify that connections target valid pins
3. **UI Reconstruction:** The node editor uses the pin database to rebuild the visual representation of loaded modules
4. **Missing Module Detection:** If a module type doesn't exist in the pin database, the UI can flag it as "unknown module type"

#### Important Notes for External Developers

- **Module Type Names:** The `type` string in XML (e.g., `"VCO"`, `"sample_loader"`) must exactly match the key used in the pin database (case-insensitive matching may be used, but exact match is safest)
- **Dynamic Pins:** Some modules (Timeline, BPM Monitor, Color Tracker) have **dynamic pins** that are added programmatically at runtime. These modules use empty pin lists in the database:
  ```cpp
  db["timeline"] = ModulePinInfo(
      NodeWidth::Big,
      {}, // Dynamic - defined by module at runtime
      {}, // Dynamic - defined by module at runtime
      {}
  );
  ```
- **Channel Indices:** The `channelIndex` in AudioPin corresponds to the **absolute bus channel index** used in JUCE's audio graph. Connection restoration uses these indices:
  ```xml
  <connection srcId="3" srcChan="0" dstId="4" dstChan="0"/>
  ```
  The `srcChan="0"` and `dstChan="0"` values come from the pin database's `channelIndex` fields.

#### Adding New Modules

When adding a new module type to the system:

1. **Add to Pin Database:** Register the module's pins in `populatePinDatabase()`
2. **Match Type String:** Ensure the `type` property saved in XML matches the database key
3. **Channel Consistency:** Keep channel indices consistent between pin database and module's actual bus layout

#### Example: VCO Pin Configuration

```cpp
// In PinDatabase.cpp
db["vco"] = ModulePinInfo(
    NodeWidth::Small,
    // Inputs: 3 pins on bus channels 0, 1, 2
    { 
        AudioPin("Frequency", 0, PinDataType::CV),    // Bus channel 0
        AudioPin("Waveform", 1, PinDataType::CV),      // Bus channel 1
        AudioPin("Gate", 2, PinDataType::Gate)         // Bus channel 2
    },
    // Outputs: 1 pin on bus channel 0
    { 
        AudioPin("Out", 0, PinDataType::Audio)         // Bus channel 0
    },
    {}  // No modulation pins (uses standard CV modulation)
);
```

When a connection is saved:
```xml
<connection srcId="5" srcChan="0" dstId="6" dstChan="0"/>
```

This means: Module 5's output pin at channel 0 ‚Üí Module 6's input pin at channel 0.

---

### 2. Nodes Dictionary (`USER_MANUAL/Nodes_Dictionary.md`)

#### Overview

The **Nodes Dictionary** is a comprehensive user-facing documentation file that describes every module in the system. It provides detailed information about inputs, outputs, parameters, and usage instructions for each module type.

#### Purpose

While not directly used by the save/load code, the Nodes Dictionary is essential for:

1. **Human-Readable Documentation:** Provides user-facing descriptions of what each module does
2. **Module Discovery:** Helps users understand what modules are available
3. **Parameter Reference:** Documents all parameters that get saved via APVTS
4. **Connection Guidance:** Shows what types of signals can connect where
5. **External Developer Reference:** Critical for understanding the expected behavior of modules during save/load

#### Structure

Each module entry in the dictionary includes:

- **Module Name:** Display name (e.g., "VCO", "Sample Loader")
- **Category:** Source, Effect, Modulator, Utility, etc.
- **Inputs:** List of input pins with data types
- **Outputs:** List of output pins with data types
- **Parameters:** All adjustable parameters with ranges
- **Usage Instructions:** How to use the module effectively

#### Relationship to Save/Load

The dictionary documents what gets saved/loaded for each module:

1. **Parameter Names:** All parameters listed in the dictionary are saved via APVTS:
   ```xml
   <PARAM id="frequency" value="440.0"/>
   ```
   The `id` must match the parameter ID in the module's `createParameterLayout()`.

2. **Module Types:** The dictionary lists all module type strings that can appear in XML:
   ```xml
   <module logicalId="3" type="VCO">
   ```
   The `type` string should match the module's registration name.

3. **Extra State:** Modules that use extra state (Sample Loader, Comment, VST Host) are documented in the dictionary's "Special Cases" section

4. **Connection Types:** The dictionary shows what data types connect where, which helps understand why certain connections work or fail during load

#### Example Entry: Sample Loader

From the dictionary:
```
### Sample Loader
**Audio Sample Player**

**Inputs:**
- `Pitch Mod` (CV) - Pitch modulation in semitones
- `Speed Mod` (CV) - Playback speed modulation
...
**Parameters:**
- `File` (Button) - Load audio file
- `Pitch` (-48 to +48 semitones) - Pitch shift amount
...
```

What gets saved in XML:
```xml
<module logicalId="4" type="Sample_Loader">
  <params>
    <SampleLoaderParams>
      <PARAM id="pitch" value="0.0"/>
      <PARAM id="speed" value="1.0"/>
      <!-- etc -->
    </SampleLoaderParams>
  </params>
  <extra>
    <SampleLoaderState audioFilePath="H:\audio\samples\kick.wav" 
                      loopMode="0" loopStart="0" loopEnd="44100"/>
  </extra>
</module>
```

The dictionary explains:
- What the `pitch` parameter does (pitch shift in semitones)
- That `audioFilePath` is stored in extra state (not in params)
- The expected file formats (WAV, AIFF, FLAC, MP3)

#### For External Developers

When improving the save/load system, refer to the Nodes Dictionary to:

1. **Verify Parameter Names:** Ensure parameter IDs in code match what's documented
2. **Understand Module Behavior:** Know what each module does to correctly restore state
3. **Identify Special Cases:** Find modules with unusual save/load requirements (dynamic pins, extra state, etc.)
4. **Validate Test Cases:** Use dictionary examples to create test presets

#### Maintaining Consistency

**Critical:** Keep the dictionary synchronized with code:

- ‚úÖ When adding a new parameter to a module, update the dictionary
- ‚úÖ When changing a module's type string, update both pin database AND dictionary
- ‚úÖ When adding a new module type, add it to pin database, dictionary, AND module factory
- ‚úÖ Document all extra state properties that get saved

#### Example: Finding Module Information

To understand what gets saved for the "Function Generator" module:

1. **Look up in Dictionary:** Find "Function Generator" entry
2. **Read Parameters Section:** Lists all APVTS parameters (Rate, Slew, Gate Threshold, etc.)
3. **Check Extra State:** Dictionary notes if module uses extra state (Function Generator does NOT use extra state)
4. **Understand Pin Configuration:** Dictionary shows inputs/outputs, but for exact channel indices, check PinDatabase.cpp
5. **Verify Save Format:** Dictionary + PinDatabase + code = complete picture of what XML should contain

---

### Interdependence of Systems

These three systems work together:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  XML Preset File                                    ‚îÇ
‚îÇ  - Module types (from Pin Database)                ‚îÇ
‚îÇ  - Parameter IDs (from Module code)                ‚îÇ
‚îÇ  - Connection channels (from Pin Database)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚îÇ Load/Save
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Pin Database (PinDatabase.cpp)                   ‚îÇ
‚îÇ  - Validates module types                          ‚îÇ
‚îÇ  - Provides pin configuration for UI               ‚îÇ
‚îÇ  - Maps display names to channel indices           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚îÇ Reference
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Nodes Dictionary (Nodes_Dictionary.md)           ‚îÇ
‚îÇ  - Documents module behavior                       ‚îÇ
‚îÇ  - Lists all parameters                            ‚îÇ
‚îÇ  - Explains usage                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Takeaway:** When improving save/load:
- **XML structure** defines what's stored
- **Pin Database** validates and enables UI reconstruction
- **Nodes Dictionary** provides human-readable reference and documentation

---

## The Save Process

### High-Level Flow

```
User clicks Save ‚Üí File chooser ‚Üí Unmute nodes ‚Üí Get synth state ‚Üí 
Re-mute nodes ‚Üí Append UI state ‚Üí Write XML file
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doSave()`)

```cpp
void PresetCreatorComponent::doSave()
{
    // Find default save location (project-root/Synth_presets)
    juce::File startDir;
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    // Search up to 8 parent directories for Synth_presets folder
    auto dir = exeDir;
    for (int i = 0; i < 8 && dir.exists(); ++i)
    {
        auto candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.exists() && candidate.isDirectory()) 
        { 
            startDir = candidate; 
            break; 
        }
        dir = dir.getParentDirectory();
    }
    
    // Launch async file chooser
    saveChooser = std::make_unique<juce::FileChooser>("Save preset", startDir, "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        // Callback continues in Step 2...
    });
}
```

#### Step 2: Unmute Nodes (Critical Fix)

**Problem:** Muted nodes have their connections replaced with bypass routing in the audio graph. If we save while nodes are muted, we'll save the bypass routing instead of the original connections.

**Solution:** Temporarily unmute all nodes before getting state, then immediately re-mute them.

```cpp
// 1. Get list of currently muted nodes
std::vector<juce::uint32> currentlyMutedNodes;
if (editor)
{
    for (const auto& pair : editor->mutedNodeStates)
    {
        currentlyMutedNodes.push_back(pair.first);
    }
    
    // 2. Temporarily UNMUTE all of them
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->unmuteNode(lid);
    }
}

// 3. Force synth to apply connection changes immediately
if (synth)
{
    synth->commitChanges();
}
```

#### Step 3: Get Synth State (`ModularSynthProcessor::getStateInformation()`)

This is where the core serialization happens.

```cpp
void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock(moduleLock);
    
    // Create root ValueTree
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    // === SERIALIZE MODULES ===
    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32)kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int)logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                // Special handling for VST modules
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    // Standard module: save APVTS parameters
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    // Save extra state (file paths, custom data)
                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    // === SERIALIZE CONNECTIONS ===
    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32)c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32)c.destination.nodeID.uid;
        
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            // Module-to-module connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int)dstIt->second, nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            // Module-to-output connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else
        {
            continue; // Skip internal graph connections
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    // === CONVERT TO XML ===
    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}
```

**Key Concepts:**

- **Logical IDs:** Each module gets a stable logical ID (1, 2, 3...) that persists across sessions
- **Node UIDs:** JUCE's internal graph node IDs (unstable, change on reload)
- **Parameter Storage:** Uses JUCE's APVTS `.copyState()` to serialize all parameters
- **Extra State:** Custom data (file paths, text, etc.) stored separately via `getExtraStateTree()`

#### Step 4: Re-mute Nodes and Add UI State

```cpp
// 5. IMMEDIATELY RE-MUTE the nodes to return editor to visible state
if (editor)
{
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->muteNode(lid);
    }
}

// 6. Force synth to apply the re-mute changes
if (synth)
{
    synth->commitChanges();
}

// === ADD UI STATE ===
juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);
if (editor)
{
    juce::ValueTree ui = editor->getUiValueTree();
    presetVT.addChild(ui, -1, nullptr);
}

// Write to file
f.replaceWithText(presetVT.createXml()->toString());
```

The UI state includes:
- Node X/Y positions
- Node colors
- Mute states
- Node widths/heights (for custom-sized modules)

---

## The Load Process

### High-Level Flow

```
User clicks Load ‚Üí File chooser ‚Üí Parse XML ‚Üí Clear existing state ‚Üí 
Recreate modules ‚Üí Restore parameters ‚Üí Recreate connections ‚Üí Apply UI state
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doLoad()`)

```cpp
void PresetCreatorComponent::doLoad()
{
    // Find default location
    juce::File startDir;
    // (same directory search logic as save)
    
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", startDir, "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData(mb);
                
                // First: set the synth state
                synth->setStateInformation(mb.getData(), (int)mb.getSize());
                
                // Then: parse and apply UI state
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse(mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml(*xml);
                        auto ui = vt.getChildWithName("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow(ui);
                    }
                }
                
                refreshModulesList();
                log.insertTextAtCaret("Loaded: " + f.getFullPathName() + "\n");
            }
        } catch (...) {
            juce::Logger::writeToLog("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}
```

#### Step 2: Set State (`ModularSynthProcessor::setStateInformation()`)

This is the most complex part of the system.

```cpp
void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    
    // Parse XML
    std::unique_ptr<juce::XmlElement> xml(
        juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes))
    );
    
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML");
        return;
    }

    // === CLEAR EXISTING STATE ===
    clearAll();
    
    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // === RESTORE GLOBAL SETTINGS ===
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found");
        return;
    }
    
    // === FIND HIGHEST LOGICAL ID ===
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    // === RECREATE MODULES ===
    std::map<juce::uint32, NodeID> logicalToNodeId;
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module")) continue;

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module: logicalId=" + juce::String(logicalId) + 
                                " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            // Check if this is a VST module
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr)
                    {
                        // Find VST in known plugins list
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE] Loading VST: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                break;
                            }
                        }
                    }
                }
            }
            
            if (!isVstModule)
            {
                // Standard module
                nodeId = addModule(type, false);
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                if (!isVstModule)
                {
                    // Update logical ID mapping
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;

                // === RESTORE STATE (ORDER MATTERS!) ===
                
                // FIRST: Restore extra state
                // This loads files, initializes custom data structures, etc.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE] Restored extra state.");
                    }
                }

                // SECOND: Restore parameters
                // This overwrites any defaults set by extra state loading
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE] Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE] ERROR: Node creation failed!");
            }
        }
    }
    
    // === RESTORE CONNECTIONS ===
    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connected " + juce::String(connectedCount) + " connections.");
    }

    // === FINALIZE ===
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}
```

**Critical Points:**

1. **Order of restoration:** Extra state BEFORE parameters (file loading sets defaults, then parameters overwrite them)
2. **Logical ID assignment:** Must match saved logical IDs for connections to work
3. **VST handling:** Separate code path for loading VST plugins vs. built-in modules
4. **Connection restoration:** Uses logical ID mapping to reconnect modules

#### Step 3: Apply UI State (`ImGuiNodeEditorComponent::applyUiValueTreeNow()`)

```cpp
void ImGuiNodeEditorComponent::applyUiValueTreeNow(const juce::ValueTree& uiTree)
{
    if (!uiTree.isValid()) return;
    
    // Clear existing UI state
    nodePositions.clear();
    nodeColors.clear();
    mutedNodeStates.clear();
    
    // Restore node positions and properties
    for (int i = 0; i < uiTree.getNumChildren(); ++i)
    {
        auto child = uiTree.getChild(i);
        if (child.hasType("node"))
        {
            int logicalId = child.getProperty("id", 0);
            float x = child.getProperty("x", 0.0f);
            float y = child.getProperty("y", 0.0f);
            
            nodePositions[logicalId] = ImVec2(x, y);
            
            // Restore color if saved
            if (child.hasProperty("color"))
            {
                juce::uint32 colorInt = child.getProperty("color", 0);
                nodeColors[logicalId] = ImColor(colorInt);
            }
            
            // Restore mute state
            if (child.getProperty("muted", false))
            {
                mutedNodeStates[logicalId] = true;
                // Apply mute routing
                muteNode(logicalId);
            }
            
            // Restore width override
            if (child.hasProperty("width"))
            {
                float width = child.getProperty("width", 0.0f);
                nodeWidthOverrides[logicalId] = width;
            }
        }
    }
    
    graphNeedsRebuild = true;
}
```

---

## XML File Structure

### Complete Example

```xml
<?xml version="1.0" encoding="UTF-8"?>

<ModularSynthPreset version="1">
  <modules>
    <module logicalId="3" type="VCO">
      <params>
        <VCOParams>
          <PARAM id="frequency" value="440.0"/>
          <PARAM id="waveform" value="0.0"/>
        </VCOParams>
      </params>
    </module>
    
    <module logicalId="4" type="Sample_Loader">
      <params>
        <SampleLoaderParams>
          <PARAM id="trimStart" value="0.0"/>
          <PARAM id="trimEnd" value="1.0"/>
          <PARAM id="cvMax" value="1.0"/>
          <PARAM id="cvMin" value="0.0"/>
        </SampleLoaderParams>
      </params>
      <extra>
        <SampleLoaderState audioFilePath="H:\audio\samples\kick.wav" 
                          loopMode="0" loopStart="0" loopEnd="44100"/>
      </extra>
    </module>
    
    <module logicalId="5" type="Pro-Q 3">
      <extra>
        <VstHostState fileOrIdentifier="C:\VST\FabFilter Pro-Q 3.vst3"
                      name="Pro-Q 3" 
                      manufacturerName="FabFilter" 
                      version="3.2.1.0"
                      pluginFormatName="VST3" 
                      pluginState="(base64 encoded state data)"/>
      </extra>
    </module>
  </modules>
  
  <connections>
    <connection srcId="3" srcChan="0" dstId="4" dstChan="0"/>
    <connection srcId="4" srcChan="0" dstId="5" dstChan="0"/>
    <connection srcId="5" srcChan="0" dstId="output" dstChan="0"/>
  </connections>
  
  <NodeEditorUI>
    <node id="3" x="100.0" y="200.0" color="4294901760" width="200.0"/>
    <node id="4" x="400.0" y="200.0" muted="true"/>
    <node id="5" x="700.0" y="200.0"/>
    <node id="0" x="1000.0" y="200.0"/>
  </NodeEditorUI>
</ModularSynthPreset>
```

### Structure Breakdown

#### Root Element
```xml
<ModularSynthPreset version="1">
```
- `version`: Schema version (for future compatibility)

#### Modules Section
```xml
<modules>
  <module logicalId="X" type="ModuleType">
    <params>
      <ModuleTypeParams>
        <PARAM id="paramId" value="0.5"/>
      </ModuleTypeParams>
    </params>
    <extra>
      <!-- Module-specific state -->
    </extra>
  </module>
</modules>
```

- `logicalId`: Stable identifier for this module instance
- `type`: Module type string (must match factory registration)
- `params`: APVTS-generated parameter state
- `extra`: Custom state (file paths, text, etc.)

#### Connections Section
```xml
<connections>
  <connection srcId="1" srcChan="0" dstId="2" dstChan="1"/>
  <connection srcId="2" srcChan="0" dstId="output" dstChan="0"/>
</connections>
```

- `srcId`: Source module logical ID
- `srcChan`: Source output channel (0-indexed)
- `dstId`: Destination module logical ID (or "output")
- `dstChan`: Destination input channel (0-indexed)

#### UI Section
```xml
<NodeEditorUI>
  <node id="X" x="123.45" y="678.90" color="4294901760" muted="true" width="250.0"/>
</NodeEditorUI>
```

- `id`: Module logical ID (or 0 for output node)
- `x`, `y`: Node position in canvas space
- `color`: ARGB color as 32-bit integer (optional)
- `muted`: Boolean mute state (optional)
- `width`: Custom width override (optional)

---

## Module Parameter Serialization

### How APVTS Works

**AudioProcessorValueTreeState (APVTS)** is JUCE's parameter management system. Each module creates an APVTS in its constructor:

```cpp
class VCOModuleProcessor : public ModuleProcessor
{
public:
    VCOModuleProcessor()
        : ModuleProcessor(/* bus layout */),
          apvts(*this, nullptr, "VCOParams", createParameterLayout())
    {
    }
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
    {
        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        
        layout.add(std::make_unique<juce::AudioParameterFloat>(
            "frequency",                    // Parameter ID
            "Frequency",                    // Display name
            juce::NormalisableRange<float>(20.0f, 20000.0f, 0.01f, 0.3f),
            440.0f));                       // Default value
        
        layout.add(std::make_unique<juce::AudioParameterChoice>(
            "waveform",
            "Waveform",
            juce::StringArray{"Sine", "Square", "Saw", "Triangle"},
            0));
        
        return layout;
    }
};
```

### Serialization

When we call `apvts.copyState()`, JUCE creates a ValueTree:

```xml
<VCOParams>
  <PARAM id="frequency" value="440.0"/>
  <PARAM id="waveform" value="0.0"/>
</VCOParams>
```

### Deserialization

When we call `apvts.replaceState(params)`, JUCE:
1. Finds each parameter by ID
2. Converts the string value to the parameter's native type
3. Sets the parameter value
4. Triggers any attached listeners

---

## Connection Management

### Connection Storage

Connections are stored in `juce::AudioProcessorGraph` as:

```cpp
struct Connection
{
    struct EndPoint
    {
        NodeID nodeID;
        int channelIndex;
    } source, destination;
};
```

### Channel Types

- **Audio channels:** 0, 1, 2, ... (stereo = channels 0 and 1)
- **MIDI channel:** `juce::AudioProcessorGraph::midiChannelIndex` (special constant)

### Connection Creation

```cpp
bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel,
                                    const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection{
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    // Check for duplicate
    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            return true; // Already connected
        }
    }

    // Add connection (deferred until commitChanges())
    return internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}
```

### Why Logical IDs?

**Problem:** JUCE's `NodeID::uid` values are unstable - they change every time you load a preset.

**Solution:** We maintain a separate `logicalId` system:

```cpp
// Mapping stored in ModularSynthProcessor
std::map<juce::uint32, LogicalModule> logicalIdToModule;

struct LogicalModule
{
    juce::AudioProcessorGraph::NodeID nodeID;  // Changes on reload
    juce::String type;
};
```

When saving:
```cpp
// Convert NodeID ‚Üí Logical ID
nodeUidToLogical[nodeID.uid] = logicalId;
```

When loading:
```cpp
// Convert Logical ID ‚Üí NodeID (new UID)
logicalToNodeId[logicalId] = newNodeId;
```

---

## UI State Persistence

### What UI State Includes

- **Node positions** (X, Y coordinates)
- **Node colors** (custom color per node)
- **Mute states** (which nodes are bypassed)
- **Width overrides** (custom widths for nodes)
- **Canvas pan/zoom** (viewport state)

### Generation (`ImGuiNodeEditorComponent::getUiValueTree()`)

```cpp
juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui("NodeEditorUI");
    
    // Save all module nodes
    for (const auto& pair : nodePositions)
    {
        int logicalId = pair.first;
        ImVec2 pos = pair.second;
        
        juce::ValueTree nodeVT("node");
        nodeVT.setProperty("id", logicalId, nullptr);
        nodeVT.setProperty("x", pos.x, nullptr);
        nodeVT.setProperty("y", pos.y, nullptr);
        
        // Optional: color
        if (nodeColors.count(logicalId))
        {
            ImU32 colorInt = nodeColors.at(logicalId);
            nodeVT.setProperty("color", (int)colorInt, nullptr);
        }
        
        // Optional: mute state
        if (mutedNodeStates.count(logicalId) && mutedNodeStates.at(logicalId))
        {
            nodeVT.setProperty("muted", true, nullptr);
        }
        
        // Optional: width override
        if (nodeWidthOverrides.count(logicalId))
        {
            nodeVT.setProperty("width", nodeWidthOverrides.at(logicalId), nullptr);
        }
        
        ui.addChild(nodeVT, -1, nullptr);
    }
    
    // Always save output node position
    if (outputNodePosition.x != 0.0f || outputNodePosition.y != 0.0f)
    {
        juce::ValueTree outputVT("node");
        outputVT.setProperty("id", 0, nullptr); // Output node is always ID 0
        outputVT.setProperty("x", outputNodePosition.x, nullptr);
        outputVT.setProperty("y", outputNodePosition.y, nullptr);
        ui.addChild(outputVT, -1, nullptr);
    }
    
    return ui;
}
```

### Restoration (shown earlier in Load Process)

---

## Special Cases

### 1. VST Plugins

VST plugins have opaque internal state that we can't inspect. JUCE provides:

```cpp
// Get plugin state
juce::MemoryBlock stateData;
plugin->getStateInformation(stateData);

// Restore plugin state
plugin->setStateInformation(stateData.getData(), stateData.getSize());
```

We wrap this in `VstHostModuleProcessor` and store:
- Plugin identifier (file path)
- Plugin metadata (name, manufacturer, version)
- Plugin state (base64 encoded in XML)

### 2. Sample Loader

The Sample Loader module needs to store:
- File path (absolute path to audio file)
- Trim points (start/end in samples)
- Loop settings

This uses "extra state":

```cpp
juce::ValueTree SampleLoaderModuleProcessor::getExtraStateTree()
{
    juce::ValueTree state("SampleLoaderState");
    state.setProperty("audioFilePath", currentFilePath, nullptr);
    state.setProperty("loopMode", (int)loopMode, nullptr);
    state.setProperty("loopStart", loopStart, nullptr);
    state.setProperty("loopEnd", loopEnd, nullptr);
    return state;
}

void SampleLoaderModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    if (!state.hasType("SampleLoaderState")) return;
    
    currentFilePath = state.getProperty("audioFilePath", "").toString();
    loopMode = (LoopMode)(int)state.getProperty("loopMode", 0);
    loopStart = state.getProperty("loopStart", 0);
    loopEnd = state.getProperty("loopEnd", 0);
    
    // Load the audio file
    if (currentFilePath.isNotEmpty())
    {
        loadAudioFile(juce::File(currentFilePath));
    }
}
```

### 3. Comment Module

Comments store text and dimensions:

```cpp
<extra>
  <CommentState title="My Note" 
                text="This is important!" 
                width="250.0" 
                height="150.0"/>
</extra>
```

### 4. Mute States

Muting is complex because it modifies the audio graph:

**When a node is muted:**
1. Store original connections
2. Remove all connections to/from node
3. Create bypass connections (input ‚Üí output directly)

**When saving with muted nodes:**
1. Temporarily unmute all nodes (restore original connections)
2. Save the unmuted connections
3. Immediately re-mute nodes

**When loading with muted nodes:**
1. Load normal connections
2. Apply mute states from UI tree
3. This triggers the mute logic, which replaces connections with bypasses

---

## Code Examples

### Example 1: Creating a Simple Module with APVTS

```cpp
// SimpleGainModule.h
#pragma once
#include "ModuleProcessor.h"

class SimpleGainModuleProcessor : public ModuleProcessor
{
public:
    SimpleGainModuleProcessor();
    ~SimpleGainModuleProcessor() override = default;
    
    const juce::String getName() const override { return "Simple Gain"; }
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override;
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SimpleGainModuleProcessor)
};

// SimpleGainModule.cpp
#include "SimpleGainModuleProcessor.h"

SimpleGainModuleProcessor::SimpleGainModuleProcessor()
    : ModuleProcessor(BusesProperties()
                       .withInput("Input", juce::AudioChannelSet::stereo())
                       .withOutput("Output", juce::AudioChannelSet::stereo())),
      apvts(*this, nullptr, "SimpleGainParams", createParameterLayout())
{
}

juce::AudioProcessorValueTreeState::ParameterLayout SimpleGainModuleProcessor::createParameterLayout()
{
    juce::AudioProcessorValueTreeState::ParameterLayout layout;
    
    layout.add(std::make_unique<juce::AudioParameterFloat>(
        "gain",                                           // Parameter ID
        "Gain",                                          // Display name
        juce::NormalisableRange<float>(0.0f, 2.0f),     // Range
        1.0f));                                          // Default value
    
    return layout;
}

void SimpleGainModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Read parameter value
    float gain = apvts.getRawParameterValue("gain")->load();
    
    // Apply gain
    buffer.applyGain(gain);
    
    // Update telemetry for visualization
    updateOutputTelemetry(buffer);
}
```

**What gets saved automatically:**
```xml
<module logicalId="X" type="Simple Gain">
  <params>
    <SimpleGainParams>
      <PARAM id="gain" value="1.5"/>
    </SimpleGainParams>
  </params>
</module>
```

### Example 2: Adding Extra State (File Path)

```cpp
class MyFileModuleProcessor : public ModuleProcessor
{
public:
    // ... (constructor, APVTS, etc.)
    
    // Override these two methods
    juce::ValueTree getExtraStateTree() override
    {
        juce::ValueTree state("MyFileModuleState");
        state.setProperty("filePath", currentFilePath, nullptr);
        state.setProperty("customData", someOtherData, nullptr);
        return state;
    }
    
    void setExtraStateTree(const juce::ValueTree& state) override
    {
        if (!state.hasType("MyFileModuleState")) return;
        
        currentFilePath = state.getProperty("filePath", "").toString();
        someOtherData = state.getProperty("customData", 0);
        
        // Do something with the loaded data
        if (currentFilePath.isNotEmpty())
        {
            loadFile(juce::File(currentFilePath));
        }
    }
    
private:
    juce::String currentFilePath;
    int someOtherData = 0;
};
```

**What gets saved:**
```xml
<module logicalId="X" type="MyFileModule">
  <params>
    <!-- APVTS parameters -->
  </params>
  <extra>
    <MyFileModuleState filePath="C:\audio\file.wav" customData="42"/>
  </extra>
</module>
```

### Example 3: Programmatic Save/Load

```cpp
// Save preset programmatically
void savePresetToFile(ModularSynthProcessor* synth, const juce::File& file)
{
    juce::MemoryBlock mb;
    synth->getStateInformation(mb);
    
    auto xml = juce::XmlDocument::parse(mb.toString());
    if (xml)
    {
        file.replaceWithText(xml->toString());
    }
}

// Load preset programmatically
void loadPresetFromFile(ModularSynthProcessor* synth, const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);
    
    synth->setStateInformation(mb.getData(), (int)mb.getSize());
}
```

---

## Summary

The XML preset system in this modular synthesizer is built on these key principles:

1. **Logical IDs** provide stable module references across save/load cycles
2. **JUCE's APVTS** handles automatic parameter serialization
3. **Extra state trees** allow modules to store custom data (files, text, etc.)
4. **Connection serialization** uses logical IDs instead of unstable node IDs
5. **UI state separation** keeps visual data separate from audio graph data
6. **Mute state handling** requires careful connection management during save
7. **VST support** wraps opaque plugin state in a standardized format

The complete flow is:
```
Save: UI ‚Üí Get State ‚Üí Serialize ‚Üí Write XML
Load: Read XML ‚Üí Parse ‚Üí Recreate Graph ‚Üí Apply UI
```

This architecture provides:
- ‚úÖ **Stability:** Presets work across app restarts
- ‚úÖ **Extensibility:** Easy to add new module types
- ‚úÖ **Debugging:** Human-readable XML format
- ‚úÖ **Performance:** Deferred graph updates via `commitChanges()`
- ‚úÖ **Completeness:** Captures all module state, connections, and UI layout

---

## Key Files Reference

| File | Purpose |
|------|---------|
| `ModularSynthProcessor.cpp` | Core save/load implementation |
| `ModularSynthProcessor.h` | Logical ID management |
| `ModuleProcessor.h` | Base class for all modules |
| `PresetCreatorComponent.cpp` | UI save/load dialogs |
| `ImGuiNodeEditorComponent.cpp` | UI state management |
| `PinDatabase.cpp` | Module pin configuration registry (see [Supporting Systems](#supporting-systems)) |
| `Nodes_Dictionary.md` | Module documentation and parameter reference (see [Supporting Systems](#supporting-systems)) |
| `VCOModuleProcessor.cpp` | Example APVTS usage |
| `SampleLoaderModuleProcessor.cpp` | Example extra state usage |
| `VstHostModuleProcessor.cpp` | VST plugin state handling |

---

## Improvement Opportunities

This section identifies known issues in the current save/load system and provides guidance for external developers on how to implement improvements.

### Issue 1: Blocking Save Operation

#### Problem Description

When saving presets, the operation blocks the UI thread for several seconds, causing noticeable stuttering and freezing. Users cannot interact with the application during save.

#### Root Cause Analysis

The blocking occurs in `PresetCreatorComponent::doSave()` callback:

```cpp
// Current synchronous save flow (BLOCKING)
void PresetCreatorComponent::doSave()
{
    saveChooser->launchAsync(..., [this](const juce::FileChooser& fc)
    {
        // === ALL THESE OPERATIONS RUN ON UI THREAD ===
        
        // 1. Unmute nodes (synchronous)
        for (juce::uint32 lid : currentlyMutedNodes)
            editor->unmuteNode(lid);
        synth->commitChanges();  // Blocks waiting for audio thread
        
        // 2. Get state (synchronous, locks moduleLock)
        juce::MemoryBlock mb;
        synth->getStateInformation(mb);  // Iterates all modules, locks
        
        // 3. Re-mute nodes (synchronous)
        for (juce::uint32 lid : currentlyMutedNodes)
            editor->muteNode(lid);
        synth->commitChanges();  // Blocks again
        
        // 4. Parse XML and add UI state (synchronous)
        auto xml = juce::XmlDocument::parse(mb.toString());
        auto vt = juce::ValueTree::fromXml(*xml);
        // ... add UI state ...
        
        // 5. Write to disk (synchronous I/O)
        f.replaceWithText(vt.createXml()->toString());  // BLOCKS on disk I/O
    });
}
```

**Performance Bottlenecks:**
- `commitChanges()` blocks waiting for audio thread synchronization
- `getStateInformation()` locks `moduleLock` and iterates all modules synchronously
- XML parsing happens synchronously on UI thread
- File I/O is synchronous and blocking

#### Solution Strategy: Asynchronous Saving with UI Feedback

The complete solution is to offload the entire save operation to a background thread pool, while providing non-blocking visual feedback to the user.

**Step 1: Create a Background Save Task**

We'll define a `ThreadPoolJob` that runs the entire save process isolated from the UI thread. Critical: UI modifications (like unmute/mute) must be done on the message thread using `juce::WaitableEvent` for proper thread synchronization.

**Important:** The `SavePresetJob` class should be in its own files (`SavePresetJob.h` and `SavePresetJob.cpp`) to avoid circular dependencies and compilation issues.

```cpp
// Create new file: juce/Source/preset_creator/SavePresetJob.h

class SavePresetJob : public juce::ThreadPoolJob
{
public:
    SavePresetJob(ModularSynthProcessor& synth, ImGuiNodeEditorComponent& editor, 
                  juce::File targetFile)
        : ThreadPoolJob("Save Preset"), 
          synthProcessor(synth), 
          nodeEditor(editor), 
          fileToSave(targetFile)
    {}

    JobStatus runJob() override
    {
        // This entire function runs on a background thread
        
        // 1. Get a list of muted nodes from the editor
        // Note: getMutedNodeIds() is const and thread-safe (only reads from map)
        auto mutedNodeIDs = nodeEditor.getMutedNodeIds();

        // 2. Temporarily unmute nodes (must be done on message thread)
        // Use WaitableEvent to safely synchronize with the UI thread
        {
            juce::WaitableEvent waitEvent;
            juce::MessageManager::callAsync([&]() {
                for (auto lid : mutedNodeIDs) nodeEditor.unmuteNode(lid);
                waitEvent.signal(); // Signal the background thread to continue
            });
            waitEvent.wait(); // Wait here until the message thread is done
        }
        synthProcessor.commitChanges(); // This blocks, but on our background thread

        // 3. Get the full synth and UI state
        juce::MemoryBlock synthState;
        synthProcessor.getStateInformation(synthState);
        
        // Get UI state on message thread to ensure thread safety
        juce::ValueTree uiState;
        {
            juce::WaitableEvent waitEvent;
            juce::MessageManager::callAsync([&]() {
                uiState = nodeEditor.getUiValueTree();
                waitEvent.signal();
            });
            waitEvent.wait();
        }

        // 4. Immediately re-mute the nodes to restore the UI state
        {
            juce::WaitableEvent waitEvent;
            juce::MessageManager::callAsync([&]() {
                for (auto lid : mutedNodeIDs) nodeEditor.muteNode(lid);
                waitEvent.signal(); // Signal the background thread to continue
            });
            waitEvent.wait(); // Wait here until the message thread is done
        }
        synthProcessor.commitChanges();

        // 5. Combine states and write to disk (all on background thread)
        std::unique_ptr<juce::XmlElement> xml = juce::XmlDocument::parse(synthState.toString());
        if (xml && xml->hasTagName("ModularSynthPreset"))
        {
            auto presetVT = juce::ValueTree::fromXml(*xml);
            if (uiState.isValid())
                presetVT.addChild(uiState, -1, nullptr);
            
            fileToSave.replaceWithText(presetVT.createXml()->toString());
            wasSuccessful = true;
        }

        // 6. Signal completion to the UI thread
        juce::MessageManager::callAsync([this]() {
            // This lambda runs back on the UI thread
            if (onSaveComplete)
                onSaveComplete(fileToSave, wasSuccessful);
        });
        
        return jobHasFinished;
    }

    std::function<void(const juce::File&, bool success)> onSaveComplete;

private:
    ModularSynthProcessor& synthProcessor;
    ImGuiNodeEditorComponent& nodeEditor;
    juce::File fileToSave;
    bool wasSuccessful = false;
};
```

**Step 2: Implement Non-Blocking Notification UI**

Create a simple, non-intrusive notification component that appears in a corner of the screen:

```cpp
// In PresetCreatorComponent.h
std::unique_ptr<juce::Label> saveStatusLabel;
juce::ThreadPool threadPool { 2 }; // Thread pool for background jobs
```

```cpp
// In PresetCreatorComponent.cpp

void PresetCreatorComponent::showSaveNotification(const juce::String& message, juce::Colour color)
{
    if (!saveStatusLabel) 
    {
        saveStatusLabel = std::make_unique<juce::Label>();
        saveStatusLabel->setJustificationType(juce::Justification::centred);
        saveStatusLabel->setColour(juce::Label::textColourId, juce::Colours::white);
        addAndMakeVisible(*saveStatusLabel);
    }
    
    saveStatusLabel->setText(message, juce::dontSendNotification);
    saveStatusLabel->setColour(juce::Label::backgroundColourId, color);
    
    // Position in top-right corner
    saveStatusLabel->setBounds(getWidth() - 310, 30, 300, 40);
    saveStatusLabel->setVisible(true);
    saveStatusLabel->toFront(false); // Bring to front but don't grab focus

    // Auto-hide after 4 seconds
    juce::Timer::callAfterDelay(4000, [this]() { 
        if (saveStatusLabel) 
            saveStatusLabel->setVisible(false); 
    });
}

// Replace the existing doSave() logic with this:
void PresetCreatorComponent::doSave()
{
    // Find default save location (existing code)
    juce::File startDir;
    // ... (existing directory search logic) ...
    
    saveChooser = std::make_unique<juce::FileChooser>("Save preset", startDir, "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
        {
            auto file = fc.getResult();
            if (file == juce::File{}) return;

            // Show initial notification
            showSaveNotification("Saving preset: " + file.getFileName(), 
                               juce::Colours::darkgrey);
            
            // Launch background save job
            auto* job = new SavePresetJob(*synth, *editor, file);
            job->onSaveComplete = [this](const juce::File& savedFile, bool success) {
                if (success) 
                {
                    showSaveNotification("Saved: " + savedFile.getFileName(), 
                                       juce::Colours::darkgreen);
                    // Update UI state if needed
                    // isPatchDirty = false;
                    // currentPresetFile = savedFile.getFileName();
                } 
                else 
                {
                    showSaveNotification("Error saving preset!", 
                                       juce::Colours::darkred);
                }
            };
            
            threadPool.addJob(job, true); // true = delete job when done
        });
}
```

**Key Benefits:**

- **Zero UI Blocking:** All heavy operations run on background thread
- **Thread-Safe UI Access:** Uses `juce::WaitableEvent` with `MessageManager::callAsync` for UI modifications
- **User Feedback:** Non-blocking notifications inform user of progress
- **Error Handling:** Completion callback handles both success and failure cases
- **Automatic Cleanup:** ThreadPool automatically deletes job when finished

#### Step 3: Implement Professional Save Workflow

For an improved user experience, implement two separate save commands:

- **`Ctrl+S` (Save)**: If the patch is already saved, saves instantly in the background to the same file without a dialog. If the patch is new/unsaved, automatically triggers "Save As" dialog.
- **`Ctrl+Alt+S` (Save As)**: Always opens the file dialog to save to a new location.

**Architecture Note:** The `SavePresetJob` class is now in its own files (`SavePresetJob.h` and `SavePresetJob.cpp`) to avoid circular dependencies and compilation issues. This is the correct C++ practice.

**Implementation:**

```cpp
// In ImGuiNodeEditorComponent.h

// Add member variables:
juce::File currentPresetFile;  // Track the current save file (changed from String to File)
bool isPatchDirty = false;      // Track if patch has unsaved changes
juce::ThreadPool threadPool { 2 }; // Thread pool for background jobs
std::unique_ptr<juce::Label> saveStatusLabel; // Non-blocking notification

// Add member functions:
void savePresetToFile(const juce::File& file);  // Core async save function
void startSaveDialog();                          // Save As dialog
std::vector<juce::uint32> getMutedNodeIds() const; // Thread-safe getter
void showSaveNotification(const juce::String& message, juce::Colour color); // Notification UI
```

```cpp
// In ImGuiNodeEditorComponent.cpp

// 1. Update keyboard shortcut handler
void ImGuiNodeEditorComponent::handleKeyboardShortcuts()
{
    if (!ImGui::GetIO().WantCaptureKeyboard)
    {
        const bool ctrl = ImGui::GetIO().KeyCtrl;
        const bool alt = ImGui::GetIO().KeyAlt;

        // Save As (Ctrl+Alt+S) - Always opens dialog
        if (ctrl && alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
        {
            startSaveDialog();
        }
        // Save (Ctrl+S) - Quick save if file exists, otherwise Save As
        else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
        {
            if (currentPresetFile.existsAsFile())
            {
                // File already exists, so save directly without a dialog
                savePresetToFile(currentPresetFile);
            }
            else
            {
                // This is a new, unsaved patch, so "Save" should act like "Save As"
                startSaveDialog();
            }
        }
        
        // ... (rest of keyboard shortcuts like Ctrl+O, Ctrl+P, etc.)
    }
}

// 2. Core asynchronous save function
void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    if (synth == nullptr) 
    {
        showSaveNotification("ERROR: Synth not ready!", juce::Colours::darkred);
        return;
    }

    // Show a non-blocking "Saving..." message
    showSaveNotification("Saving: " + file.getFileNameWithoutExtension(), 
                        juce::Colours::darkgrey);

    // Create and launch the background save job
    auto* job = new SavePresetJob(*synth, *this, file);

    job->onSaveComplete = [this](const juce::File& savedFile, bool success) {
        // This lambda will be called on the UI thread when the job is done
        if (success) 
        {
            showSaveNotification("Saved: " + savedFile.getFileNameWithoutExtension(), 
                               juce::Colours::darkgreen);
            isPatchDirty = false;
            currentPresetFile = savedFile; // Update the current file reference
        } 
        else 
        {
            showSaveNotification("Error: Failed to save preset!", 
                               juce::Colours::darkred);
        }
    };

    threadPool.addJob(job, true); // true = delete job when done
}

// 3. Save As dialog (simplified, always opens dialog)
void ImGuiNodeEditorComponent::startSaveDialog()
{
    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      findPresetsDirectory(), 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto fileToSave = fc.getResult();
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
    });
}
```

**Benefits of This Workflow:**

- ‚úÖ **Fast Quick Save:** `Ctrl+S` saves instantly if file exists (no dialog delay)
- ‚úÖ **Intuitive:** New patches automatically prompt for filename
- ‚úÖ **Flexible:** `Ctrl+Alt+S` always allows choosing new location
- ‚úÖ **Non-Blocking:** Both commands use background thread
- ‚úÖ **User Feedback:** Clear notifications for all save operations

**Note on Thread Safety:**

The `getMutedNodeIds()` method referenced above needs to be added to `ImGuiNodeEditorComponent`:

```cpp
// In ImGuiNodeEditorComponent.h
std::vector<juce::uint32> getMutedNodeIds() const
{
    const juce::ScopedLock lock(muteStateLock); // Use existing lock if available
    std::vector<juce::uint32> ids;
    for (const auto& pair : mutedNodeStates)
    {
        if (pair.second) // If node is muted
            ids.push_back(pair.first);
    }
    return ids;
}
```

#### Implementation Checklist

- [ ] Create `SaveTask` class extending `ThreadPoolJob`
- [ ] Move all heavy operations to background thread
- [ ] Add progress indicator UI component
- [ ] Update `doSave()` to use thread pool
- [ ] Test with large presets (100+ modules)
- [ ] Verify UI remains responsive during save
- [ ] Add error handling for background thread failures

---

### Issue 2: Silent Load Failures

#### Problem Description

When loading presets, if module names have changed, pins have been reconfigured, or channels have shifted, the system fails silently. The preset appears to load, but connections are broken, modules are missing, or parameters are wrong. Users have no indication that something went wrong.

#### Root Cause Analysis

The current load code in `ModularSynthProcessor::setStateInformation()`:

```cpp
void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    // ... parse XML ...
    
    // === NO VALIDATION OCCURS HERE ===
    
    // Module recreation - silently fails if type doesn't exist
    NodeID nodeId = addModule(type, false);  // Returns invalid NodeID if type unknown
    
    // Connection restoration - silently fails if channels invalid
    connect(srcNodeId, srcChan, dstNodeId, dstChan);  // Returns false on failure, but nobody checks!
    
    // Parameter restoration - silently fails if parameter ID changed
    mp->getAPVTS().replaceState(params);  // Ignores unknown parameters
}
```

**Failure Points:**
1. **Module Type Mismatch:** If `type="OldModuleName"` but module renamed to `"NewModuleName"`, `addModule()` fails silently
2. **Pin Changes:** If channel indices changed (e.g., VCO output moved from channel 0 to channel 1), connections fail silently
3. **Parameter ID Changes:** If parameter renamed (e.g., `"frequency"` ‚Üí `"freq"`), APVTS silently ignores it
4. **No User Feedback:** All failures are logged but never shown to user

#### Solution Strategy: Three-Stage Load Process

Instead of loading directly, we implement a robust pipeline: **Validate ‚Üí Auto-Heal ‚Üí Load & Notify**. This ensures presets are checked against the current system state (Pin Database, module factory) before loading, with automatic fixing of common issues.

**Step 1: Create a `PresetValidator`**

This class analyzes a preset `ValueTree` and produces a structured report of all discrepancies:

```cpp
// PresetValidator.h

class PresetValidator
{
public:
    struct Issue {
        enum Severity { Warning, Error };
        Severity severity;
        juce::String message;
        juce::ValueTree problematicNode; // Reference to the node in the ValueTree
    };

    std::vector<Issue> validate(const juce::ValueTree& preset)
    {
        std::vector<Issue> issues;
        auto modulesVT = preset.getChildWithName("modules");
        auto connsVT = preset.getChildWithName("connections");
        auto& pinDb = getModulePinDatabase();
        
        // Rule 1: Check if all module types exist in module factory
        // (Assuming you have access to moduleFactory or can check against PinDatabase)
        for (int i = 0; i < modulesVT.getNumChildren(); ++i)
        {
            auto moduleNode = modulesVT.getChild(i);
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Check against Pin Database (all valid modules should be registered there)
            auto it = pinDb.find(type.toLowerCase());
            if (it == pinDb.end())
            {
                issues.push_back({
                    Issue::Error, 
                    "Unknown module type: '" + type + "'", 
                    moduleNode
                });
            }
        }
        
        // Rule 2: Check if connection channels are valid
        // Build a map of logicalId -> module type for quick lookup
        std::map<juce::uint32, juce::String> logicalIdToType;
        for (int i = 0; i < modulesVT.getNumChildren(); ++i)
        {
            auto moduleNode = modulesVT.getChild(i);
            juce::uint32 logicalId = moduleNode.getProperty("logicalId", 0);
            juce::String type = moduleNode.getProperty("type").toString();
            logicalIdToType[logicalId] = type;
        }
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto connNode = connsVT.getChild(i);
            juce::uint32 srcId = connNode.getProperty("srcId", 0);
            int srcChan = connNode.getProperty("srcChan", 0);
            
            auto srcTypeIt = logicalIdToType.find(srcId);
            if (srcTypeIt != logicalIdToType.end())
            {
                juce::String srcModuleType = srcTypeIt->second;
                auto pinDbIt = pinDb.find(srcModuleType.toLowerCase());
                
                if (pinDbIt != pinDb.end())
                {
                    // Check if srcChan is a valid output channel for this module type
                    const auto& outputs = pinDbIt->second.audioOuts;
                    bool isValidChannel = std::any_of(outputs.begin(), outputs.end(),
                        [srcChan](const AudioPin& pin) { return pin.channelIndex == srcChan; });
                    
                    if (!isValidChannel)
                    {
                        issues.push_back({
                            Issue::Warning,
                            "Source channel " + juce::String(srcChan) + 
                            " is invalid for module type '" + srcModuleType + "'",
                            connNode
                        });
                    }
                }
            }
            
            // Similar validation for destination channels...
        }
        
        // Rule 3: Validate parameters (would need module instances or parameter registry)
        // TODO: Add parameter validation logic
        
        return issues;
    }
};
```

**Step 2: Create a `PresetAutoHealer`**

This class takes the `ValueTree` and attempts to fix common problems based on rules:

```cpp
// PresetAutoHealer.h

class PresetAutoHealer
{
public:
    // A simple map of known module renames (maintain this as modules evolve)
    const std::map<juce::String, juce::String> moduleRenames = {
        {"Sequencer", "sequencer"},
        {"VCO", "vco"},
        {"SampleLoader", "sample_loader"},
        {"OldVCO", "VCO"}, // Example: legacy name mapping
        // Add more mappings as modules are renamed across versions
    };

    juce::ValueTree heal(const juce::ValueTree& preset)
    {
        juce::ValueTree healed = preset.createCopy();
        auto modulesVT = healed.getChildWithName("modules");
        auto connsVT = healed.getChildWithName("connections");
        auto& pinDb = getModulePinDatabase();
        
        // Heal 1: Module Renames
        for (int i = 0; i < modulesVT.getNumChildren(); ++i)
        {
            auto moduleNode = modulesVT.getChild(i);
            juce::String currentType = moduleNode.getProperty("type").toString();
            
            if (moduleRenames.count(currentType))
            {
                juce::String newType = moduleRenames.at(currentType);
                moduleNode.setProperty("type", newType, nullptr);
                // Could log: "Healed: Renamed module type '" + currentType + "' ‚Üí '" + newType + "'"
            }
        }
        
        // Heal 2: Connection Channel Remapping
        // If a connection to channel X fails, but a pin with a similar name exists at channel Y,
        // attempt to remap the connection
        // TODO: Implement channel remapping by pin name matching
        // Example: If connection to channel 2 fails, but "Cutoff Mod" pin exists at channel 3,
        //          and the old pin was also named "Cutoff Mod", remap connection to channel 3
        
        return healed;
    }
};
```

**Step 3: Integrate into the Load Process**

Update the `doLoad()` function to use the validation and healing system. This reuses the `showSaveNotification()` function from the save solution:

```cpp
// In PresetCreatorComponent.cpp

void PresetCreatorComponent::doLoad()
{
    // Find default location (existing code)
    juce::File startDir;
    // ... (existing directory search logic) ...
    
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", startDir, "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc) noexcept
        {
            try {
                auto file = fc.getResult();
                if (!file.existsAsFile()) return;

                // Parse XML file
                auto xml = juce::XmlDocument::parse(file);
                if (!xml) 
                {
                    showSaveNotification("Failed to parse XML!", juce::Colours::darkred);
                    return;
                }

                juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);

                // === STAGE 1: VALIDATE ===
                PresetValidator validator;
                auto issues = validator.validate(presetVT);

                // === STAGE 2: AUTO-HEAL (if issues found) ===
                PresetAutoHealer healer;
                juce::ValueTree healedVT = presetVT;
                bool wasHealed = false;
                
                if (!issues.empty())
                {
                    healedVT = healer.heal(presetVT);
                    wasHealed = (healedVT != presetVT);
                    
                    // Re-validate the healed version to see if fixes worked
                    auto healedIssues = validator.validate(healedVT);
                    issues = healedIssues; // Use healed issues for notification
                }

                // === STAGE 3: LOAD & NOTIFY ===
                // Convert healed ValueTree to MemoryBlock for loading
                juce::MemoryBlock mb;
                juce::MemoryOutputStream mos(mb, false);
                healedVT.createXml()->writeTo(mos);
                
                // Load into synth
                synth->setStateInformation(mb.getData(), (int)mb.getSize());

                // Apply UI state from the file
                if (editor)
                {
                    auto uiState = healedVT.getChildWithName("NodeEditorUI");
                    if (uiState.isValid())
                        editor->applyUiValueTreeNow(uiState);
                }

                // Show non-blocking notification with results
                if (issues.empty()) 
                {
                    showSaveNotification("Preset loaded successfully!", 
                                       juce::Colours::darkgreen);
                } 
                else 
                {
                    int errorCount = 0;
                    int warningCount = 0;
                    for (const auto& issue : issues)
                    {
                        if (issue.severity == PresetValidator::Issue::Error)
                            errorCount++;
                        else
                            warningCount++;
                    }
                    
                    juce::String msg;
                    if (wasHealed && errorCount == 0)
                    {
                        msg = "Loaded with " + juce::String(warningCount) + 
                              " warnings (auto-healed)";
                        showSaveNotification(msg, juce::Colours::orange);
                    }
                    else
                    {
                        msg = "Loaded with " + juce::String(errorCount) + 
                              " errors, " + juce::String(warningCount) + " warnings";
                        if (wasHealed)
                            msg += " (partially healed)";
                        showSaveNotification(msg, juce::Colours::darkred);
                        
                        // TODO: Add a "Show Details" button that opens a log window
                        // showing all issues for debugging
                    }
                }

                refreshModulesList();
                
            } catch (...) {
                juce::Logger::writeToLog("[PresetCreator][FATAL] Exception in doLoad callback");
                showSaveNotification("Fatal error loading preset!", juce::Colours::darkred);
            }
        });
}
```

**Complete Flow Summary:**

```
1. Parse XML ‚Üí ValueTree
2. Validate ‚Üí List of Issues
3. Auto-Heal ‚Üí Fixed ValueTree (if issues found)
4. Re-Validate ‚Üí Check if healing worked
5. Load ‚Üí Apply to synth + UI
6. Notify ‚Üí Non-blocking status message
```

This three-stage approach ensures:
- ‚úÖ **Validation catches problems before loading**
- ‚úÖ **Auto-healing fixes common issues automatically**
- ‚úÖ **User gets clear feedback** about what happened
- ‚úÖ **System remains responsive** throughout the process

**4. Enhanced Logging for Debugging**

Create detailed load logs that can be shown to users:

```cpp
class LoadLogger
{
public:
    struct LogEntry {
        juce::Time timestamp;
        juce::String moduleType;
        juce::uint32 logicalId;
        juce::String action;      // "Created", "Connected", "ParameterSet", "Failed"
        juce::String details;
        bool success;
    };
    
    void logModuleCreation(juce::uint32 logicalId, const juce::String& type, bool success)
    {
        entries.push_back({
            juce::Time::getCurrentTime(),
            type,
            logicalId,
            "Created",
            success ? "OK" : "Module type not found",
            success
        });
    }
    
    void logConnection(juce::uint32 srcId, int srcChan, 
                      juce::uint32 dstId, int dstChan, bool success)
    {
        entries.push_back({
            juce::Time::getCurrentTime(),
            "",
            0,
            "Connected",
            "Module " + juce::String(srcId) + ":" + juce::String(srcChan) + 
            " ‚Üí " + juce::String(dstId) + ":" + juce::String(dstChan),
            success
        });
    }
    
    juce::String generateReport() const
    {
        juce::String report = "=== Preset Load Report ===\n\n";
        
        int successCount = 0;
        int failureCount = 0;
        
        for (const auto& entry : entries)
        {
            if (entry.success) successCount++;
            else failureCount++;
            
            report += "[" + entry.timestamp.toString(true, true) + "] ";
            report += entry.action;
            if (entry.logicalId > 0)
                report += " (Module " + juce::String(entry.logicalId);
            if (entry.moduleType.isNotEmpty())
                report += ", Type: " + entry.moduleType;
            report += "): " + entry.details + "\n";
        }
        
        report += "\nSummary: " + juce::String(successCount) + " successful, " +
                 juce::String(failureCount) + " failed\n";
        
        return report;
    }
    
private:
    std::vector<LogEntry> entries;
};
```

#### Implementation Checklist

**Validation System:**
- [ ] Create `PresetValidator` class with `Issue` struct
- [ ] Implement module type validation against Pin Database
- [ ] Implement connection channel validation (source and destination)
- [ ] Build logicalId ‚Üí moduleType lookup map for connection validation
- [ ] Add parameter validation (requires module instance or parameter registry)

**Auto-Healing System:**
- [ ] Create `PresetAutoHealer` class
- [ ] Maintain `moduleRenames` lookup table (update as modules evolve)
- [ ] Implement module name remapping in `heal()` method
- [ ] (Optional) Implement channel index remapping by pin name matching

**Integration:**
- [ ] Update `doLoad()` to use three-stage process (Validate ‚Üí Heal ‚Üí Load)
- [ ] Reuse `showSaveNotification()` for load feedback
- [ ] Add error handling for XML parsing failures
- [ ] Test with old presets containing renamed modules
- [ ] Test with presets containing invalid channels
- [ ] Test notification display with various issue combinations

**Future Enhancements:**
- [ ] Add "Show Details" button to notification (opens issue log window)
- [ ] Create `LoadLogger` class for detailed debugging reports
- [ ] Implement channel remapping by pin name similarity
- [ ] Document all auto-healing rules in code comments

#### Using Pin Database for Validation

**Example: Validating Connection Channels**

```cpp
bool validateConnectionChannel(const juce::String& moduleType,
                               int channelIndex,
                               bool isOutput)
{
    auto& pinDb = getModulePinDatabase();
    auto it = pinDb.find(moduleType.toLowerCase());
    
    if (it == pinDb.end())
        return false; // Module type doesn't exist
    
    const auto& pinInfo = it->second;
    const auto& pinList = isOutput ? pinInfo.audioOuts : pinInfo.audioIns;
    
    // Check if channel index exists in pin list
    return std::any_of(pinList.begin(), pinList.end(),
        [channelIndex](const AudioPin& pin) {
            return pin.channelIndex == channelIndex;
        });
}
```

**Example: Finding Alternate Channel Index**

```cpp
int findAlternateChannel(const juce::String& moduleType,
                        const juce::String& pinName,
                        bool isOutput)
{
    auto& pinDb = getModulePinDatabase();
    auto it = pinDb.find(moduleType.toLowerCase());
    if (it == pinDb.end()) return -1;
    
    const auto& pinList = isOutput ? it->second.audioOuts : it->second.audioIns;
    
    // Find pin with matching or similar name
    for (const auto& pin : pinList)
    {
        if (pin.name.toLowerCase().contains(pinName.toLowerCase()) ||
            pinName.toLowerCase().contains(pin.name.toLowerCase()))
        {
            return pin.channelIndex;
        }
    }
    
    return -1; // Not found
}
```

#### Using Nodes Dictionary for Parameter Validation

While the dictionary is Markdown (not directly parseable), you can:

1. **Extract Parameter Lists:** Create a script to parse `Nodes_Dictionary.md` and generate a parameter registry
2. **Maintain Registry:** Keep a `std::map<juce::String, std::vector<juce::String>>` mapping module types to parameter IDs
3. **Version History:** Document parameter renames in a lookup table

```cpp
// Parameter rename registry (maintained manually or via script)
std::map<std::pair<juce::String, juce::String>, juce::String> parameterRenames = {
    {{"VCO", "frequency"}, "freq"},  // Old param ID ‚Üí New param ID
    {{"VCF", "cutoff"}, "cutoffFreq"},
    // ... etc
};

juce::String healParameterId(const juce::String& moduleType, const juce::String& oldParamId)
{
    auto key = std::make_pair(moduleType, oldParamId);
    auto it = parameterRenames.find(key);
    return it != parameterRenames.end() ? it->second : oldParamId;
}
```

---

## Common Pitfalls

### ‚ùå Don't: Use Node UID in Connections
```cpp
// BAD: Node UIDs change on reload!
save_connection(node->nodeID.uid, otherNode->nodeID.uid);
```

### ‚úÖ Do: Use Logical IDs
```cpp
// GOOD: Logical IDs are stable
save_connection(logicalId1, logicalId2);
```

### ‚ùå Don't: Save Parameters Manually
```cpp
// BAD: Duplicate work, error-prone
xml->setAttribute("frequency", frequency);
xml->setAttribute("waveform", waveform);
```

### ‚úÖ Do: Use APVTS
```cpp
// GOOD: Automatic, correct, handles undo/redo
juce::ValueTree params = apvts.copyState();
```

### ‚ùå Don't: Forget commitChanges()
```cpp
// BAD: Changes not applied to audio thread
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
// Missing: synth->commitChanges();
```

### ‚úÖ Do: Always Commit
```cpp
// GOOD: Audio graph updated properly
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
synth->commitChanges(); // ‚úì
```

---

**End of Guide**

This document provides a complete understanding of the XML preset save/load system. For specific module implementation details, refer to the individual module processor files in `juce/Source/audio/modules/`.



================================================================================
FILE: USER_MANUAL\Nodes_Dictionary.md
================================================================================


# Collider Modular Synthesizer - Node Dictionary

**Last Updated:** December 18, 2024  
**Version:** 1.2

---

## Table of Contents

### Quick Reference Index

#### 1. SOURCE NODES
- [VCO](#vco) - Voltage-Controlled Oscillator
- [PolyVCO](#polyvco) - Multi-Voice Oscillator Bank
- [Noise](#noise) - Noise Generator
- [Audio Input](#audio-input) - Hardware Audio Input
- [Sample Loader](#sample-loader) - Audio Sample Player
- [Value](#value) - Constant Value Generator

#### 2. EFFECT NODES
- [VCF](#vcf) - Voltage-Controlled Filter
- [Delay](#delay) - Stereo Delay Effect
- [Reverb](#reverb) - Stereo Reverb Effect
- [Chorus](#chorus) - Stereo Chorus Effect
- [Phaser](#phaser) - Stereo Phaser Effect
- [Compressor](#compressor) - Dynamic Range Compressor
- [Limiter](#limiter) - Audio Limiter
- [Gate](#gate) - Noise Gate
- [Drive](#drive) - Waveshaping Distortion
- [Graphic EQ](#graphic-eq) - 8-Band Graphic Equalizer
- [Waveshaper](#waveshaper) - Multi-Algorithm Waveshaper
- [8-Band Shaper](#8-band-shaper) - Multi-Band Waveshaper
- [Granulator](#granulator) - Granular Synthesizer/Effect
- [Harmonic Shaper](#harmonic-shaper) - Harmonic Content Shaper
- [TimePitch](#timepitch) - Time/Pitch Manipulation
- [De-Crackle](#de-crackle) - Click/Pop Reducer
- [Vocal Tract Filter](#vocal-tract-filter) - Formant Filter

#### 3. MODULATOR NODES
- [LFO](#lfo) - Low-Frequency Oscillator
- [ADSR](#adsr) - Envelope Generator
- [Random](#random) - Random Value Generator
- [S&H](#sh) - Sample & Hold
- [Function Generator](#function-generator) - Drawable Envelope/LFO
- [Shaping Oscillator](#shaping-oscillator) - Oscillator with Built-in Waveshaper

#### 4. UTILITY & LOGIC NODES
- [VCA](#vca) - Voltage-Controlled Amplifier
- [Mixer](#mixer) - Stereo Audio Mixer
- [CV Mixer](#cv-mixer) - Control Voltage Mixer
- [Track Mixer](#track-mixer) - Multi-Channel Mixer
- [Attenuverter](#attenuverter) - Attenuate/Invert Signal
- [Lag Processor](#lag-processor) - Slew Limiter/Smoother
- [Math](#math) - Mathematical Operations
- [MapRange](#maprange) - Value Range Mapper
- [Quantizer](#quantizer) - Musical Scale Quantizer
- [Rate](#rate) - Rate Value Converter
- [Comparator](#comparator) - Threshold Comparator
- [Logic](#logic) - Boolean Logic Operations
- [Clock Divider](#clock-divider) - Clock Division/Multiplication
- [Sequential Switch](#sequential-switch) - Signal Router

#### 5. SEQUENCER NODES
- [Sequencer](#sequencer) - 16-Step CV/Gate Sequencer
- [Multi Sequencer](#multi-sequencer) - Advanced Multi-Output Sequencer
- [Snapshot Sequencer](#snapshot-sequencer) - Patch State Sequencer
- [Stroke Sequencer](#stroke-sequencer) - Gesture-Based Sequencer
- [Tempo Clock](#tempo-clock) - Global Clock Generator
- [Timeline](#timeline) - Automation Recorder and Playback

#### 6. MIDI NODES
- [MIDI CV](#midi-cv) - MIDI to CV Converter
- [MIDI Player](#midi-player) - MIDI File Player
- [MIDI Faders](#midi-faders) - MIDI-Learnable Faders (1-16)
- [MIDI Knobs](#midi-knobs) - MIDI-Learnable Knobs (1-16)
- [MIDI Buttons](#midi-buttons) - MIDI-Learnable Buttons (1-32)
- [MIDI Jog Wheel](#midi-jog-wheel) - MIDI Jog Wheel Control

#### 7. ANALYSIS NODES
- [Scope](#scope) - Oscilloscope
- [Debug](#debug) - Signal Value Logger
- [Input Debug](#input-debug) - Passthrough Debug Logger
- [Frequency Graph](#frequency-graph) - Spectrum Analyzer

#### 8. TTS (TEXT-TO-SPEECH) NODES
- [TTS Performer](#tts-performer) - Text-to-Speech Engine
- [Vocal Tract Filter](#vocal-tract-filter) - Formant Filter

#### 9. SPECIAL NODES
- [Physics](#physics) - 2D Physics Simulation
- [Animation](#animation) - 3D Animation Player

#### 10. COMPUTER VISION NODES
- [Webcam Loader](#webcam-loader) - Webcam Video Source
- [Video File Loader](#video-file-loader) - Video File Source
- [Movement Detector](#movement-detector) - Motion Detection
- [Human Detector](#human-detector) - Face/Body Detection
- [Object Detector](#object-detector) - Object Detection (YOLOv3)
- [Pose Estimator](#pose-estimator) - Body Keypoint Detection
- [Hand Tracker](#hand-tracker) - Hand Keypoint Tracking
- [Face Tracker](#face-tracker) - Facial Landmark Tracking
- [Color Tracker](#color-tracker) - Multi-Color Tracking
- [Contour Detector](#contour-detector) - Shape Detection
- [Semantic Segmentation](#semantic-segmentation) - Scene Segmentation
- [Video FX](#video-fx) - Real-Time Video Effects
- [Crop Video](#crop-video) - Video Cropping and Tracking

#### 11. SYSTEM NODES
- [Meta](#meta) - Meta Module Container
- [Inlet](#inlet) - Meta Module Input
- [Outlet](#outlet) - Meta Module Output
- [Comment](#comment) - Documentation Node
- [Recorder](#recorder) - Audio Recording to File
- [VST Host](#vst-host) - VST Plugin Host
- [BPM Monitor](#bpm-monitor) - Rhythm Detection and BPM Reporting

---

## 1. SOURCE NODES

Source nodes generate or input signals into your patch.

### VCO
**Voltage-Controlled Oscillator**

A standard analog-style oscillator that generates periodic waveforms.

**Inputs:**
- `Frequency` (CV) - Frequency modulation input
- `Waveform` (CV) - Waveform selection modulation
- `Gate` (Gate) - Gate input for amplitude control

**Outputs:**
- `Out` (Audio) - Mono audio output

**Parameters:**
- `Frequency` (20 Hz - 20 kHz) - Base oscillator frequency
- `Waveform` (Choice) - Sine, Sawtooth, or Square wave
- `Relative Freq Mod` (Bool) - When enabled, CV modulates ¬±4 octaves around slider position. When disabled, CV directly maps to 20 Hz - 20 kHz
- `Portamento` (0-2 seconds) - Frequency glide/smoothing time

**How to Use:**
1. Connect the audio output to an effect or VCA
2. Set the frequency slider to your desired pitch
3. Optionally connect CV (from sequencer, LFO, or ADSR) to modulate frequency
4. Use the Relative Freq Mod toggle to choose between relative (musical) or absolute (full range) modulation
5. Connect a gate signal for amplitude gating if needed
6. Adjust portamento for smooth frequency transitions

---

### PolyVCO
**Multi-Voice Oscillator Bank**

A polyphonic oscillator module with up to 32 independent voices, ideal for creating rich, layered sounds or building polyphonic synthesizers.

**Inputs:**
- `Num Voices Mod` (Raw) - Control number of active voices (1-32)
- `Freq 1-32 Mod` (CV) - Individual frequency modulation for each voice
- `Wave 1-32 Mod` (CV) - Individual waveform modulation for each voice
- `Gate 1-32 Mod` (Gate) - Individual gate inputs for each voice

**Outputs:**
- `Out 1-32` (Audio) - 32 independent audio outputs (one per voice)

**Parameters:**
- `Num Voices` (1-32) - Number of active voices
- `Base Frequency` (20 Hz - 20 kHz) - Base frequency for all voices
- `Detune Amount` (0-100 cents) - Amount of random detuning between voices
- `Spread` (0-100%) - Frequency spread between voices
- `Waveform` (Choice) - Base waveform for all voices (Sine, Sawtooth, Square)

**How to Use:**
1. Set the number of voices you want active
2. Connect the voice outputs to a Track Mixer or individual effects
3. Use the detune parameter to create a chorus-like effect
4. Connect a Multi Sequencer's parallel outputs to the individual frequency and gate inputs for polyphonic melodies
5. Adjust spread to create harmonic stacks

---

### Noise
**Noise Generator**

Generates white, pink, or brown noise for percussion, ambience, or modulation.

**Inputs:**
- `Level Mod` (CV) - Level modulation input
- `Colour Mod` (CV) - Noise color modulation

**Outputs:**
- `Out L` (Audio) - Left channel output
- `Out R` (Audio) - Right channel output

**Parameters:**
- `Colour` (Choice) - White (flat spectrum), Pink (-3 dB/octave), or Brown (-6 dB/octave)
- `Level dB` (-60 to +6 dB) - Output level in decibels

**How to Use:**
1. Select the noise color (white for hi-hats, pink for general noise, brown for low rumble)
2. Adjust the level to taste
3. Optionally modulate the color with CV for dynamic timbral changes
4. Great for percussion synthesis when combined with envelopes and filters
5. Use as a modulation source for subtle random variations

---

### Audio Input
**Hardware Audio Input**

Brings external audio from your audio interface into the patch.

**Outputs:**
- `Out 1` (Audio) - Input channel 1
- `Out 2` (Audio) - Input channel 2
- `Gate` (Gate) - Gate signal when audio exceeds threshold
- `Trigger` (Gate) - Trigger signal on transients
- `EOP` (Gate) - End of phrase detection

**Parameters:**
- `Input Gain` (-60 to +20 dB) - Input gain control
- `Gate Threshold` (-60 to 0 dB) - Threshold for gate output
- `Trigger Sensitivity` (Low/Medium/High) - Transient detection sensitivity

**How to Use:**
1. Connect your external audio source (microphone, instrument, etc.) to your audio interface
2. Adjust input gain to get a healthy signal level
3. Use the gate and trigger outputs to create envelope followers or rhythm detection
4. Process the audio through effects or use it as a modulation source via envelope following

---

### Sample Loader
**Audio Sample Player**

Loads and plays audio samples with extensive playback control and modulation options.

**Inputs:**
- `Pitch Mod` (CV) - Pitch modulation in semitones
- `Speed Mod` (CV) - Playback speed modulation
- `Gate Mod` (CV) - Gate/trigger modulation
- `Trigger Mod` (Gate) - Retrigger the sample
- `Range Start Mod` (CV) - Modulate sample start point
- `Range End Mod` (CV) - Modulate sample end point
- `Randomize Trig` (Gate) - Randomize sample settings on trigger

**Outputs:**
- `Out L` (Audio) - Left channel output
- `Out R` (Audio) - Right channel output

**Parameters:**
- `File` (Button) - Load audio file (WAV, AIFF, FLAC, MP3)
- `Pitch` (-48 to +48 semitones) - Pitch shift amount
- `Speed` (0.1x to 4x) - Playback speed multiplier
- `Loop Mode` (Choice) - Off, Forward, Ping-Pong
- `Gate Mode` (Choice) - Trigger (one-shot), Gate (held), Free (always play)
- `Range Start` (0-100%) - Sample start position
- `Range End` (0-100%) - Sample end position
- `Reverse` (Bool) - Play sample in reverse
- `Randomize Range` (Bool) - Randomize start/end on each trigger

**How to Use:**
1. Click the "Load File" button and select an audio file
2. Set the pitch and speed for your desired sound
3. Choose a loop mode (Off for one-shots, Forward for sustained sounds)
4. Use Gate Mode: Trigger for drums, Gate for sustained tones, Free for continuous playback
5. Adjust Range Start/End to isolate specific portions of the sample
6. Connect CV to Pitch Mod for melodic playing
7. Use Trigger Mod to retrigger the sample rhythmically
8. Enable Randomize Range for variation on each hit

---

### Value
**Constant Value Generator**

Outputs a constant, adjustable numerical value in multiple formats.

**Outputs:**
- `Raw` (Raw) - Unprocessed value as-is
- `Normalized` (CV) - Value normalized to 0-1 range
- `Inverted` (Raw) - Negative of raw value
- `Integer` (Raw) - Truncated integer value
- `CV Out` (CV) - Scaled CV output (0-1 range)

**Parameters:**
- `Value` (-100 to +100) - The constant value to output

**How to Use:**
1. Adjust the value slider to your desired number
2. Connect the appropriate output to the destination:
   - Use `CV Out` for standard 0-1 modulation
   - Use `Raw` for custom ranges or mathematical operations with the Math node
   - Use `Integer` for step/index control
3. Great for setting static modulation amounts, offsets, or reference values
4. Combine multiple Value nodes with Math nodes for complex calculations

---

## 2. EFFECT NODES

Effect nodes process audio signals to shape tone, add space, or create sonic textures.

### VCF
**Voltage-Controlled Filter**

A resonant multi-mode filter for subtractive synthesis and tone shaping.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Cutoff Mod` (CV) - Cutoff frequency modulation
- `Resonance Mod` (CV) - Resonance amount modulation
- `Type Mod` (CV) - Filter type modulation

**Outputs:**
- `Out L` (Audio) - Left filtered output
- `Out R` (Audio) - Right filtered output

**Parameters:**
- `Cutoff` (20 Hz - 20 kHz) - Filter cutoff frequency
- `Resonance` (0.1 - 10.0) - Resonance/Q factor
- `Type` (Choice) - Low-pass, High-pass, or Band-pass
- `Relative Cutoff Mod` (Bool) - When enabled, CV modulates ¬±5 octaves around slider. When disabled, CV maps to full 20 Hz - 20 kHz range
- `Relative Resonance Mod` (Bool) - When enabled, CV scales resonance 0.25x-4x. When disabled, CV maps to full 0.1-10.0 range

**How to Use:**
1. Connect audio through the filter
2. Adjust cutoff to set the frequency where filtering occurs
3. Increase resonance for emphasis around the cutoff (be careful, high values can self-oscillate!)
4. Choose filter type: Low-pass removes highs, High-pass removes lows, Band-pass keeps only around cutoff
5. Modulate cutoff with envelopes or LFOs for classic synth sounds
6. Use Relative mode for musical modulation around a set position

---

### Delay
**Stereo Delay Effect**

A stereo delay effect with modulation and tempo sync capabilities.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Time Mod` (CV) - Delay time modulation
- `Feedback Mod` (CV) - Feedback amount modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left delayed output
- `Out R` (Audio) - Right delayed output

**Parameters:**
- `Time (ms)` (1-2000 ms) - Delay time in milliseconds
- `Feedback` (0-0.95) - Amount of delayed signal fed back into the delay
- `Mix` (0-1) - Wet/dry balance (0=dry, 1=wet)
- `Relative Time Mod` (Bool) - Enable relative time modulation around slider position
- `Relative Feedback Mod` (Bool) - Enable relative feedback modulation
- `Relative Mix Mod` (Bool) - Enable relative mix modulation

**How to Use:**
1. Send audio through the delay
2. Set delay time to taste (short for slapback, long for echoes)
3. Adjust feedback for the number of repeats (be careful, high values can self-oscillate!)
4. Use mix to blend delayed signal with dry signal
5. Modulate time with LFOs for chorus-like effects
6. Connect to Tempo Clock's clock outputs and use short delay times for rhythmic effects

---

### Reverb
**Stereo Reverb Effect**

A stereo reverb effect that simulates acoustic spaces.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Size Mod` (CV) - Room size modulation
- `Damp Mod` (CV) - Damping modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left reverb output
- `Out R` (Audio) - Right reverb output

**Parameters:**
- `Size` (0-1) - Room size (0=small, 1=large)
- `Damping` (0-1) - High frequency damping (0=bright, 1=dark)
- `Width` (0-1) - Stereo width
- `Mix` (0-1) - Wet/dry balance (0=dry, 1=wet)

**How to Use:**
1. Send audio through the reverb
2. Adjust size to set the perceived space (small room to large hall)
3. Use damping to control brightness (low damping=reflective surfaces, high damping=absorptive)
4. Adjust mix to blend reverb with dry signal
5. Great for adding depth and space to sounds
6. Use sparingly on bass-heavy sounds to avoid muddiness

---

### Chorus
**Stereo Chorus Effect**

A stereo chorus effect that creates thick, shimmering textures by layering slightly detuned copies of the signal.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Rate Mod` (CV) - LFO rate modulation
- `Depth Mod` (CV) - Effect depth modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left chorus output
- `Out R` (Audio) - Right chorus output

**Parameters:**
- `Rate` (0.1-10 Hz) - LFO speed
- `Depth` (0-1) - Modulation depth
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Send audio through the chorus
2. Set rate for the speed of the sweeping effect (slow=gentle, fast=vibrato)
3. Adjust depth for intensity of detuning
4. Use mix to blend with dry signal
5. Great for thickening synth pads and leads
6. Use on clean guitars for classic 80s sounds

---

### Phaser
**Stereo Phaser Effect**

A stereo phaser effect that creates sweeping notches in the frequency spectrum.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Rate Mod` (CV) - LFO rate modulation
- `Depth Mod` (CV) - Effect depth modulation
- `Centre Mod` (CV) - Center frequency modulation
- `Feedback Mod` (CV) - Feedback amount modulation
- `Mix Mod` (CV) - Wet/dry mix modulation

**Outputs:**
- `Out L` (Audio) - Left phaser output
- `Out R` (Audio) - Right phaser output

**Parameters:**
- `Rate` (0.1-10 Hz) - LFO speed
- `Depth` (0-1) - Modulation depth
- `Centre Freq` (200-2000 Hz) - Center frequency of the sweep
- `Feedback` (0-0.95) - Amount of feedback (increases resonance)
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Send audio through the phaser
2. Adjust rate for sweep speed (slow=subtle, fast=intense)
3. Set centre frequency to target specific frequency ranges
4. Increase feedback for more pronounced notches
5. Great for adding movement to static sounds
6. Classic effect for electric pianos and guitars

---

### Compressor
**Dynamic Range Compressor**

Reduces the dynamic range of audio signals, making quiet parts louder and loud parts quieter.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Thresh Mod` (CV) - Threshold modulation
- `Ratio Mod` (CV) - Ratio modulation
- `Attack Mod` (CV) - Attack time modulation
- `Release Mod` (CV) - Release time modulation
- `Makeup Mod` (CV) - Makeup gain modulation

**Outputs:**
- `Out L` (Audio) - Left compressed output
- `Out R` (Audio) - Right compressed output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Level above which compression starts
- `Ratio` (1:1 to 20:1) - Amount of compression
- `Attack` (0.1-100 ms) - How quickly compression engages
- `Release` (10-1000 ms) - How quickly compression disengages
- `Makeup Gain` (0-24 dB) - Output gain to compensate for level reduction

**How to Use:**
1. Set threshold to the level where you want compression to start
2. Adjust ratio (2:1 for gentle, 10:1+ for heavy compression)
3. Use fast attack to catch transients, slow attack to preserve punch
4. Set release to taste (fast for pumping effects, slow for smooth)
5. Adjust makeup gain to match the output level to the input
6. Great for controlling dynamics, adding sustain, and gluing mixes together

---

### Limiter
**Audio Limiter**

Prevents audio from exceeding a set level, acting as a "brick wall" for peaks.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Thresh Mod` (CV) - Threshold modulation
- `Release Mod` (CV) - Release time modulation

**Outputs:**
- `Out L` (Audio) - Left limited output
- `Out R` (Audio) - Right limited output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Maximum allowed level
- `Release` (10-1000 ms) - Recovery time

**How to Use:**
1. Set threshold to the maximum level you want to allow
2. Adjust release time (fast for transparent, slow for smoother)
3. Use at the end of your signal chain to prevent clipping
4. Essential for mastering and protecting speakers
5. Can add punch and loudness when used aggressively

---

### Gate
**Noise Gate**

Silences signals below a threshold, useful for removing background noise or creating rhythmic effects.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left gated output
- `Out R` (Audio) - Right gated output

**Parameters:**
- `Threshold` (-60 to 0 dB) - Level below which the gate closes
- `Attack` (0.1-100 ms) - How quickly the gate opens
- `Release` (10-1000 ms) - How quickly the gate closes
- `Range` (-60 to 0 dB) - Amount of attenuation when gate is closed

**How to Use:**
1. Set threshold just above your noise floor
2. Adjust attack and release for smooth or rhythmic gating
3. Use range to set how much the signal is reduced (not necessarily to silence)
4. Great for cleaning up noisy recordings
5. Use creatively with short releases for rhythmic chopping effects

---

### Drive
**Waveshaping Distortion**

A waveshaping distortion effect that adds harmonic content and saturation.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left distorted output
- `Out R` (Audio) - Right distorted output

**Parameters:**
- `Drive` (0-100) - Amount of distortion
- `Type` (Choice) - Distortion algorithm (Soft clip, Hard clip, Foldback, etc.)
- `Output Gain` (-12 to +12 dB) - Output level compensation

**How to Use:**
1. Start with low drive and gradually increase
2. Try different distortion types for various tonal characters
3. Adjust output gain to compensate for level changes
4. Great for adding grit and harmonic richness
5. Use before or after filters for different tonal results

---

### Graphic EQ
**8-Band Graphic Equalizer**

An 8-band graphic equalizer with CV outputs for frequency-based triggering.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Band 1-8 Mod` (CV) - Individual band gain modulation
- `Gate Thresh Mod` (CV) - Gate threshold modulation
- `Trig Thresh Mod` (CV) - Trigger threshold modulation

**Outputs:**
- `Out L` (Audio) - Left EQ output
- `Out R` (Audio) - Right EQ output
- `Gate Out` (Gate) - Gates when signal exceeds gate threshold
- `Trig Out` (Gate) - Triggers on transients above trigger threshold

**Parameters:**
- `Gain Band 1-8` (-60 to +12 dB) - Gain for each frequency band (centered at: 60, 170, 310, 600, 1000, 3000, 6000, 12000 Hz)
- `Output Level` (-24 to +24 dB) - Overall output level
- `Gate Threshold` (-60 to 0 dB) - Threshold for gate output
- `Trigger Threshold` (-60 to 0 dB) - Threshold for trigger detection

**How to Use:**
1. Boost or cut specific frequency bands to shape your sound
2. Use negative gain to remove unwanted frequencies
3. Use the gate and trigger outputs for frequency-responsive triggering (great for kick/bass triggering)
4. Combine with other modules for frequency-dependent effects

---

### Waveshaper
**Multi-Algorithm Waveshaper**

A distortion effect with multiple waveshaping algorithms for varied saturation and distortion effects.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Drive Mod` (CV) - Drive amount modulation
- `Type Mod` (CV) - Algorithm selection modulation

**Outputs:**
- `Out L` (Audio) - Left waveshaped output
- `Out R` (Audio) - Right waveshaped output

**Parameters:**
- `Drive` (0-100) - Amount of waveshaping
- `Type` (Choice) - Waveshaping algorithm (Soft Clip, Hard Clip, Foldback, etc.)
- `Mix` (0-1) - Wet/dry balance

**How to Use:**
1. Choose a waveshaping algorithm
2. Gradually increase drive to add saturation
3. Try different algorithms for different characters
4. Use mix to blend with the dry signal

---

### 8-Band Shaper
**Multi-Band Waveshaper**

A multi-band waveshaper that applies frequency-specific distortion across 8 bands.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Drive 1-8 Mod` (CV) - Per-band drive modulation
- `Gain Mod` (CV) - Output gain modulation

**Outputs:**
- `Out L` (Audio) - Left processed output
- `Out R` (Audio) - Right processed output

**Parameters:**
- `Drive Band 1-8` (0-10) - Drive amount for each frequency band
- `Output Gain` (-24 to +24 dB) - Overall output level

**How to Use:**
1. Adjust individual band drives to add selective distortion
2. Drive bass frequencies differently than highs for balanced distortion
3. Great for adding harmonics to specific frequency ranges
4. Use sparingly for subtle enhancement or aggressively for heavy distortion

---

### Granulator
**Granular Synthesizer/Effect**

A granular processor that plays small grains of audio for textural and rhythmic effects.

**Inputs:**
- `In L` (Audio) - Left audio input (recorded to internal buffer)
- `In R` (Audio) - Right audio input (recorded to internal buffer)
- `Trigger In` (Gate) - Manual grain triggering
- `Density Mod` (CV) - Grain density modulation
- `Size Mod` (CV) - Grain size modulation
- `Position Mod` (CV) - Playback position modulation
- `Pitch Mod` (CV) - Pitch modulation
- `Gate Mod` (CV) - Gate amount modulation

**Outputs:**
- `Out L` (Audio) - Left granulated output
- `Out R` (Audio) - Right granulated output

**Parameters:**
- `Density` (0.1-100 Hz) - How often grains are triggered
- `Size` (5-500 ms) - Length of each grain
- `Position` (0-1) - Where in the buffer to read grains
- `Spread` (0-1) - Random variation in grain position
- `Pitch` (-24 to +24 semitones) - Pitch shift of grains
- `Pitch Random` (0-12 semitones) - Random pitch variation per grain
- `Pan Random` (0-1) - Random stereo placement per grain
- `Gate` (0-1) - Overall output level/gate

**How to Use:**
1. Audio is continuously recorded to a 2-second buffer
2. Adjust density for grain triggering rate (low=sparse, high=dense cloud)
3. Set grain size (small=rhythmic, large=smooth textures)
4. Use position to read from different parts of the buffer
5. Add spread for more random, evolving textures
6. Modulate position with LFOs for scanning effects
7. Great for creating ambient textures from any sound source

---

### Harmonic Shaper
**Harmonic Content Shaper**

Shapes the harmonic content of a signal using frequency-specific waveshaping.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Freq Mod` (CV) - Frequency modulation
- `Drive Mod` (CV) - Drive modulation

**Outputs:**
- `Out L` (Audio) - Left shaped output
- `Out R` (Audio) - Right shaped output

**Parameters:**
- `Master Frequency` (20 Hz - 20 kHz) - Center frequency for harmonic shaping
- `Master Drive` (0-10) - Amount of harmonic emphasis

**How to Use:**
1. Set the master frequency to target specific harmonics
2. Increase drive to emphasize those harmonics
3. Great for adding presence and character to sounds
4. Use on bass for sub-harmonic generation

---

### TimePitch
**Time/Pitch Manipulation**

Real-time pitch and time manipulation using the RubberBand library for high-quality time stretching and pitch shifting.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Speed Mod` (CV) - Playback speed modulation
- `Pitch Mod` (CV) - Pitch shift modulation

**Outputs:**
- `Out L` (Audio) - Left processed output
- `Out R` (Audio) - Right processed output

**Parameters:**
- `Speed` (0.25x to 4x) - Playback speed without affecting pitch
- `Pitch` (-24 to +24 semitones) - Pitch shift without affecting tempo
- `Formant` (Bool) - Preserve formants when pitch shifting

**How to Use:**
1. Adjust speed to time-stretch audio (0.5x=half speed, 2x=double speed)
2. Adjust pitch to transpose audio independently
3. Enable formant preservation for natural-sounding vocal pitch shifts
4. Great for creative effects and sound design

---

### De-Crackle
**Click/Pop Reducer**

A utility to reduce clicks and pops caused by discontinuous CV or audio signals.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input

**Outputs:**
- `Out L` (Audio) - Left de-clicked output
- `Out R` (Audio) - Right de-clicked output

**Parameters:**
- `Sensitivity` (Low/Medium/High) - How aggressively to detect and reduce clicks

**How to Use:**
1. Insert after modules that produce discontinuous signals
2. Adjust sensitivity based on the severity of clicks
3. Essential for smoothing abrupt parameter changes
4. Use on CV signals as well as audio

---

## 3. MODULATOR NODES

Modulator nodes generate control voltages for animating parameters over time.

### LFO
**Low-Frequency Oscillator**

A versatile LFO for modulating parameters with periodic waveforms.

**Inputs:**
- `Rate Mod` (CV) - Rate modulation input
- `Depth Mod` (CV) - Depth modulation input
- `Wave Mod` (CV) - Waveform selection modulation

**Outputs:**
- `Out` (CV) - CV modulation output

**Parameters:**
- `Rate` (0.05-20 Hz) - LFO frequency
- `Depth` (0-1) - Modulation amount
- `Bipolar` (Bool) - Output range: On = -1 to +1, Off = 0 to 1
- `Wave` (Choice) - Sine, Triangle, or Sawtooth
- `Sync` (Bool) - Sync to global tempo
- `Division` (Choice) - Note division when synced (1/32 to 8 bars)
- `Relative Mod` (Bool) - When enabled, rate CV is additive around slider position

**How to Use:**
1. Set rate to desired modulation speed
2. Choose bipolar for modulation around a center point, unipolar for one-directional
3. Select waveform based on desired modulation shape
4. Enable Sync and set Division for tempo-locked modulation
5. Connect output to any CV modulation input
6. Use multiple LFOs at different rates for complex modulation

---

### ADSR
**Attack-Decay-Sustain-Release Envelope Generator**

A classic ADSR envelope generator for shaping sounds over time.

**Inputs:**
- `Gate In` (Gate) - Gate signal to trigger and hold envelope
- `Trigger In` (Gate) - Trigger signal to retrigger envelope
- `Attack Mod` (CV) - Attack time modulation
- `Decay Mod` (CV) - Decay time modulation
- `Sustain Mod` (CV) - Sustain level modulation
- `Release Mod` (CV) - Release time modulation

**Outputs:**
- `Env Out` (CV) - Main envelope output (0-1)
- `Inv Out` (CV) - Inverted envelope output (1-0)
- `EOR Gate` (Gate) - End of Release gate
- `EOC Gate` (Gate) - End of Cycle gate

**Parameters:**
- `Attack` (0.001-5 seconds) - Rise time from 0 to 1
- `Decay` (0.001-5 seconds) - Fall time from 1 to sustain level
- `Sustain` (0-1) - Held level while gate is high
- `Release` (0.001-5 seconds) - Fall time from sustain to 0 after gate goes low
- `Relative Attack/Decay/Sustain/Release Mod` (Bool) - Enable relative modulation modes

**How to Use:**
1. Connect a gate source (sequencer, MIDI CV, etc.) to Gate In
2. Adjust Attack for how quickly sound reaches full volume
3. Set Decay for how quickly it falls to the sustain level
4. Sustain sets the held level while key/gate is pressed
5. Release controls fade-out time after gate is released
6. Connect Env Out to VCA gain for amplitude shaping
7. Use Inv Out for inverted modulation
8. EOR and EOC gates useful for triggering events at envelope completion

---

### Random
**Random Value Generator**

Generates random values at a specified rate with multiple output formats and tempo sync.

**Outputs:**
- `Norm Out` (CV) - Normalized random values (0-1 range)
- `Raw Out` (Raw) - Raw random values (custom range)
- `CV Out` (CV) - CV random values (custom CV range)
- `Bool Out` (Gate) - Random boolean (on/off)
- `Trig Out` (Gate) - Trigger pulse on each new random value

**Parameters:**
- `Rate` (0.1-50 Hz) - How often new random values are generated
- `Min` (-100 to 100) - Minimum value for Raw output
- `Max` (-100 to 100) - Maximum value for Raw output
- `CV Min` (0-1) - Minimum value for CV output
- `CV Max` (0-1) - Maximum value for CV output
- `Norm Min` (0-1) - Minimum value for Norm output
- `Norm Max` (0-1) - Maximum value for Norm output
- `Slew` (0-1) - Smoothing between random values
- `Trig Threshold` (0-1) - Threshold for Bool output
- `Sync` (Bool) - Sync to global tempo
- `Division` (Choice) - Note division when synced

**How to Use:**
1. Set rate for how often random values change
2. Adjust min/max ranges for each output type as needed
3. Use slew to smooth transitions between random values (0=stepped, 1=smooth)
4. Connect different outputs for different modulation needs
5. Use Bool Out for random gates/triggers
6. Enable sync for tempo-locked randomness
7. Great for adding unpredictability and variation to patches

---

### S&H
**Sample & Hold**

Samples and holds an input signal when triggered.

**Inputs:**
- `Signal In L` (Audio) - Left signal to sample
- `Signal In R` (Audio) - Right signal to sample
- `Trig In L` (Gate) - Trigger for left channel
- `Trig In R` (Gate) - Trigger for right channel
- `Threshold Mod` (CV) - Trigger threshold modulation
- `Edge Mod` (CV) - Trigger edge selection modulation
- `Slew Mod` (CV) - Slew limiting modulation

**Outputs:**
- `Out L` (Audio) - Left sampled & held output
- `Out R` (Audio) - Right sampled & held output

**Parameters:**
- `Threshold` (0-1) - Trigger threshold level
- `Edge` (Choice) - Rising, Falling, or Both edges
- `Slew` (0-1) - Slew limiting between sampled values

**How to Use:**
1. Connect a signal to sample (CV, audio, etc.)
2. Connect a trigger source (LFO, clock, gate)
3. Each trigger samples the current input value and holds it
4. Adjust threshold if using audio-rate triggers
5. Use slew to smooth transitions between held values
6. Classic for creating stepped random modulation (LFO ‚Üí S&H ‚Üí destination)

---

### Function Generator
**Drawable Envelope/LFO Generator**

A complex, drawable envelope and LFO generator with multiple curve slots and extensive modulation options.

**Inputs:**
- `Gate In` (Gate) - Gate input for envelope triggering
- `Trigger In` (Gate) - Trigger input for envelope
- `Sync In` (Gate) - Sync input for phase reset
- `Rate Mod` (CV) - Rate modulation
- `Slew Mod` (CV) - Slew limiting modulation
- `Gate Thresh Mod` (CV) - Gate threshold modulation
- `Trig Thresh Mod` (CV) - Trigger threshold modulation
- `Pitch Base Mod` (CV) - Pitch base modulation
- `Value Mult Mod` (CV) - Value multiplier modulation
- `Curve Select Mod` (CV) - Curve selection modulation

**Outputs:**
- `Value` (CV) - Main output value
- `Inverted` (CV) - Inverted output
- `Bipolar` (CV) - Bipolar output (-1 to +1)
- `Pitch` (CV) - Pitch CV output (V/Oct)
- `Gate` (Gate) - Gate output based on threshold
- `Trigger` (Gate) - Trigger output
- `End of Cycle` (Gate) - Trigger at cycle end
- `Blue/Red/Green Value` (CV) - Per-curve outputs
- `Blue/Red/Green Pitch` (CV) - Per-curve pitch outputs

**Parameters:**
- `Rate` (0.05-20 Hz) - Cycle speed
- `Slew` (0-1) - Smoothing between points
- `Gate Threshold` (0-1) - Threshold for gate output
- `Trig Threshold` (0-1) - Threshold for trigger output
- `Pitch Base` (-4 to +4 octaves) - Base pitch offset
- `Value Mult` (0-10) - Value scaling multiplier
- `Curve Select` (0-2) - Choose active curve (Blue, Red, or Green)
- Drawing Interface - Click and drag to draw curves

**How to Use:**
1. Click "Draw" to enter drawing mode
2. Draw up to 3 different curves (Blue, Red, Green tabs)
3. Set rate for cycle speed
4. Use as LFO (free-running) or envelope (gate-triggered)
5. Adjust slew for smooth or stepped transitions
6. Multiple outputs allow simultaneous different modulations
7. Per-curve outputs let you route different curves to different destinations
8. Extremely versatile for complex modulation shapes

---

### Shaping Oscillator
**Oscillator with Built-in Waveshaper**

An oscillator with integrated waveshaping for generating harmonically rich tones.

**Inputs:**
- `In L` (Audio) - External audio input (optional, can shape external audio)
- `In R` (Audio) - External audio input right channel
- `Freq Mod` (CV) - Frequency modulation
- `Wave Mod` (CV) - Waveform modulation
- `Drive Mod` (CV) - Drive modulation

**Outputs:**
- `Out` (Audio) - Shaped oscillator output

**Parameters:**
- `Frequency` (20 Hz - 20 kHz) - Oscillator frequency
- `Waveform` (Choice) - Base waveform
- `Drive` (0-10) - Waveshaping amount

**How to Use:**
1. Set frequency for desired pitch
2. Choose base waveform
3. Increase drive to add harmonics via waveshaping
4. Can also process external audio through the shaper
5. Great for thick, harmonically rich tones

---

## 4. UTILITY & LOGIC NODES

Utility nodes provide essential signal processing, routing, and logic operations.

### VCA
**Voltage-Controlled Amplifier**

A basic amp module for controlling audio levels with CV.

**Inputs:**
- `In L` (Audio) - Left audio input
- `In R` (Audio) - Right audio input
- `Gain Mod` (CV) - Gain modulation

**Outputs:**
- `Out L` (Audio) - Left amplified output
- `Out R` (Audio) - Right amplified output

**Parameters:**
- `Gain` (-60 to +12 dB) - Base gain level

**How to Use:**
1. Send audio through the VCA
2. Connect an envelope or LFO to Gain Mod for amplitude control
3. Essential for creating dynamic amplitude envelopes
4. The core of any subtractive synthesis voice

---

### Mixer
**Stereo Audio Mixer**

A two-input stereo mixer with gain, pan, and crossfade controls.

**Inputs:**
- `In A L/R` (Audio) - Input A stereo pair
- `In B L/R` (Audio) - Input B stereo pair
- `Gain Mod` (CV) - Gain modulation
- `Pan Mod` (CV) - Pan modulation
- `X-Fade Mod` (CV) - Crossfade modulation

**Outputs:**
- `Out L/R` (Audio) - Mixed stereo output

**Parameters:**
- `Gain` (-60 to +12 dB) - Overall output gain
- `Pan` (-1 to +1) - Stereo panning
- `Crossfade` (0-1) - Blend between input A (0) and input B (1)

**How to Use:**
1. Connect two stereo sources
2. Use crossfade to blend between them
3. Adjust gain and pan for final mix
4. Modulate crossfade with LFOs or envelopes for dynamic mixing

---

### CV Mixer
**Control Voltage Mixer**

A mixer specifically designed for mixing CV signals.

**Inputs:**
- `In A/B` (CV) - CV inputs
- `Gain Mod` (CV) - Gain modulation

**Outputs:**
- `Out` (CV) - Mixed CV output

**Parameters:**
- `Gain A/B` (-2 to +2) - Gain for each input

**How to Use:**
1. Mix multiple CV sources together
2. Use negative gain to invert signals
3. Create complex modulation by combining LFOs and envelopes
4. Essential for additive CV processing

---

### Track Mixer
**Multi-Channel Mixer**

A mixer for up to 8 monophonic tracks with individual gain and pan controls.

**Inputs:**
- `In 1-8` (Audio) - 8 mono audio inputs
- `Num Tracks Mod` (Raw) - Number of active tracks modulation
- `Gain 1-8 Mod` (CV) - Per-track gain modulation
- `Pan 1-8 Mod` (CV) - Per-track pan modulation

**Outputs:**
- `Out L/R` (Audio) - Stereo mixed output

**Parameters:**
- `Num Tracks` (1-8) - Number of active tracks
- `Gain 1-8` (-60 to +12 dB) - Per-track gain
- `Pan 1-8` (-1 to +1) - Per-track stereo panning

**How to Use:**
1. Connect multiple mono sources (great with PolyVCO outputs)
2. Adjust per-track gain and pan
3. Set Num Tracks to control how many inputs are active
4. Perfect for mixing polyphonic voices

---

### Attenuverter
**Attenuate/Invert Signal**

Attenuates (reduces) and/or inverts CV or audio signals.

**Inputs:**
- `In L/R` (Audio) - Stereo inputs
- `Amount Mod` (CV) - Amount modulation

**Outputs:**
- `Out L/R` (Audio) - Processed outputs

**Parameters:**
- `Amount` (-1 to +1) - Attenuation/inversion amount (0=silent, 0.5=half, 1=full, negative=inverted)

**How to Use:**
1. Use positive values (0-1) to reduce signal levels
2. Use negative values (-1-0) to invert and reduce
3. Set to 0 for silence
4. Essential for scaling modulation amounts
5. Use to create inverted versions of CV for opposite modulation

---

### Lag Processor
**Slew Limiter/Smoother**

Smooths abrupt changes in signals using independent rise and fall times.

**Inputs:**
- `Signal In` (CV) - CV input to smooth
- `Rise Mod` (CV) - Rise time modulation
- `Fall Mod` (CV) - Fall time modulation

**Outputs:**
- `Smoothed Out` (CV) - Smoothed CV output

**Parameters:**
- `Rise Time` (0.1-1000 ms) - Time to reach rising values
- `Fall Time` (0.1-1000 ms) - Time to reach falling values

**How to Use:**
1. Insert between a CV source and destination to smooth transitions
2. Use equal rise/fall times for symmetrical smoothing
3. Use different rise/fall for attack/release character
4. Great for portamento effects and smoothing stepped sequences
5. Can turn hard gates into smooth envelopes

---

### Math
**Mathematical Operations**

Performs mathematical operations on two input signals.

**Inputs:**
- `In A` (CV) - First operand
- `In B` (CV) - Second operand

**Outputs:**
- `Add` (CV) - A + B
- `Subtract` (CV) - A - B
- `Multiply` (CV) - A √ó B
- `Divide` (CV) - A √∑ B

**Parameters:**
- `Value A` (-100 to 100) - Default value for A (used if not patched)
- `Value B` (-100 to 100) - Default value for B (used if not patched)
- `Operation` (Choice) - Add, Subtract, Multiply, Divide, Min, Max, Power, Sqrt(A), Sin(A), Cos(A), Tan(A), Abs(A), Modulo, Fract(A), Int(A), A>B, A<B

**How to Use:**
1. Connect CV sources or use internal values
2. Choose operation
3. Use outputs for complex CV processing
4. Create custom modulation shapes by combining operations
5. Use comparison operations (A>B, A<B) for logic

---

### MapRange
**Value Range Mapper**

Remaps values from one range to another.

**Inputs:**
- `Raw In` (Raw) - Input value to remap

**Outputs:**
- `CV Out` (CV) - Remapped to 0-1 range
- `Audio Out` (Audio) - Remapped to audio-rate

**Parameters:**
- `Min In` (-1000 to 1000) - Input range minimum
- `Max In` (-1000 to 1000) - Input range maximum
- `Min Out` (-1000 to 1000) - Output range minimum
- `Max Out` (-1000 to 1000) - Output range maximum

**How to Use:**
1. Define your input range (min/max in)
2. Define your desired output range (min/max out)
3. Connect input signal
4. Output is linearly scaled to new range
5. Great for converting between different parameter ranges

---

### Quantizer
**Musical Scale Quantizer**

Snaps continuous CV to musical scales.

**Inputs:**
- `CV In` (CV) - Continuous pitch CV
- `Scale Mod` (CV) - Scale selection modulation
- `Root Mod` (CV) - Root note modulation

**Outputs:**
- `Out` (CV) - Quantized pitch CV

**Parameters:**
- `Scale` (Choice) - Musical scale (Major, Minor, Chromatic, Pentatonic, etc.)
- `Root` (Choice) - Root note (C, C#, D, etc.)

**How to Use:**
1. Connect a continuous CV source (LFO, random, etc.)
2. Choose a musical scale
3. Set the root note
4. Output will snap to nearest note in the scale
5. Great for creating melodic sequences from random sources

---

### Rate
**Rate Value Converter**

Converts raw values to normalized rate values for tempo-related modulation.

**Inputs:**
- `Rate Mod` (CV) - Rate modulation input

**Outputs:**
- `Out` (CV) - Normalized rate output

**Parameters:**
- `Rate` (0.1-20) - Rate multiplier

**How to Use:**
1. Use to convert between different rate representations
2. Useful for tempo-syncing external modulators
3. Provides standardized rate output for consistent timing

---

### Comparator
**Threshold Comparator**

Outputs a gate signal when input exceeds a threshold.

**Inputs:**
- `In` (CV) - CV input to compare

**Outputs:**
- `Out` (Gate) - Gate output (high when input > threshold)

**Parameters:**
- `Threshold` (0-1) - Comparison threshold

**How to Use:**
1. Connect a CV source
2. Set threshold
3. Output goes high when input exceeds threshold
4. Great for converting CV to gates
5. Create rhythm from slow LFOs

---

### Logic
**Boolean Logic Operations**

Performs boolean logic operations on gate signals.

**Inputs:**
- `In A` (Gate) - First input
- `In B` (Gate) - Second input

**Outputs:**
- `AND` (Gate) - High when both inputs are high
- `OR` (Gate) - High when either input is high
- `XOR` (Gate) - High when inputs differ
- `NOT A` (Gate) - Inverted A

**How to Use:**
1. Connect two gate sources
2. Use outputs for different logic combinations
3. AND: Both gates must be high (good for requiring multiple conditions)
4. OR: Either gate can be high (good for combining triggers)
5. XOR: Only one gate high (good for alternating patterns)
6. NOT A: Invert a gate signal

---

### Clock Divider
**Clock Division/Multiplication**

Divides and multiplies clock signals for polyrhythmic patterns.

**Inputs:**
- `Clock In` (Gate) - Clock input to divide/multiply
- `Reset` (Gate) - Reset all divisions to sync

**Outputs:**
- `/2, /4, /8` (Gate) - Divided clocks (half, quarter, eighth speed)
- `x2, x3, x4` (Gate) - Multiplied clocks (double, triple, quadruple speed)

**How to Use:**
1. Connect a clock source
2. Use divided outputs for slower rhythms
3. Use multiplied outputs for faster rhythms
4. Create polyrhythmic patterns by using multiple outputs
5. Use reset to synchronize all divisions

---

### Sequential Switch
**Signal Router**

Routes an input signal to one of four outputs based on CV thresholds.

**Inputs:**
- `Gate In` (Audio) - Signal to route
- `Thresh 1-4 CV` (CV) - Threshold values for each output

**Outputs:**
- `Out 1-4` (Audio) - Four possible output destinations

**Parameters:**
- `Threshold 1-4` (0-1) - Threshold levels

**How to Use:**
1. Connect a signal to Gate In
2. Set thresholds for each output
3. As input CV changes, signal routes to different outputs
4. Use with sequencers or LFOs for rhythmic switching
5. Great for creating evolving patterns

---

## 5. SEQUENCER NODES

Sequencer nodes generate rhythmic and melodic patterns.

### Sequencer
**16-Step CV/Gate Sequencer**

A classic 16-step sequencer for creating melodies and rhythms.

**Inputs:**
- Extensive per-step modulation inputs for values, triggers, and gates

**Outputs:**
- `Pitch` (CV) - Current step pitch value
- `Gate` (Gate) - Gate output
- `Gate Nuanced` (CV) - Gate with velocity
- `Velocity` (CV) - Velocity value
- `Mod` (CV) - Modulation output
- `Trigger` (Gate) - Trigger on each step

**Parameters:**
- `Rate` (0.1-20 Hz) - Sequence speed
- `Num Steps` (1-16) - Number of active steps
- `Gate Length` (0-1) - Duration of gates
- Per-step: Pitch, Gate, Velocity, Modulation values

**How to Use:**
1. Set number of steps and rate
2. Program pitch values for each step
3. Set gates on/off for rhythm
4. Adjust gate length for articulation
5. Can sync to Tempo Clock for musical timing

---

### Multi Sequencer
**Advanced Multi-Output Sequencer**

An advanced sequencer with parallel per-step outputs for polyphonic sequencing.

**Outputs:**
- Live outputs: Pitch, Gate, Trigger, Velocity, Mod
- Parallel outputs: Pitch 1-16, Gate 1-16, Trig 1-16 (all steps output simultaneously)

**How to Use:**
1. Similar to Sequencer but with simultaneous output of all 16 steps
2. Connect parallel outputs to PolyVCO for poly synth
3. Create complex polyphonic arrangements
4. Each step can trigger independently

---

### Tempo Clock
**Global Clock Generator**

Master tempo/clock source with transport controls.

**Inputs:**
- `BPM Mod` (CV) - BPM modulation
- `Tap` (Gate) - Tap tempo input
- `Nudge+/-` (Gate) - Fine tempo adjustment
- `Play/Stop/Reset` (Gate) - Transport controls
- `Swing Mod` (CV) - Swing amount modulation

**Outputs:**
- `Clock` (Gate) - Main clock pulse
- `Beat Trig` (Gate) - Trigger on each beat
- `Bar Trig` (Gate) - Trigger on each bar
- `Beat Gate` (Gate) - Gate for beat duration
- `Phase` (CV) - Clock phase (0-1)
- `BPM CV` (CV) - BPM as CV
- `Downbeat` (Gate) - First beat of bar

**Parameters:**
- `BPM` (20-300) - Tempo in beats per minute
- `Time Signature` (Choice) - 4/4, 3/4, 6/8, etc.
- `Swing` (0-100%) - Swing amount
- `Global Division` (Bool) - Override all synced modules' divisions

**How to Use:**
1. Set BPM for your project
2. Use clock outputs to drive sequencers and LFOs
3. Enable Global Division to control all synced modules at once
4. Use transport controls for performance

---

### Snapshot Sequencer
**Patch State Sequencer**

Sequences complete patch states, recalling all parameter values.

**How to Use:**
1. Create snapshots of your entire patch at different states
2. Sequence through snapshots for dramatic changes
3. Great for live performance and automation

---

### Stroke Sequencer
**Gesture-Based Sequencer**

Records and plays back drawn gestures as CV sequences.

**How to Use:**
1. Draw patterns with your mouse/tablet
2. Playback converts drawing to CV
3. Unique way to create expressive, human-feeling sequences

---

### Timeline
**Automation Recorder and Playback**

A transport-synchronized automation recorder that captures and plays back CV, Gate, Trigger, and Raw signals with sample-accurate precision. The Timeline Node serves as the single source of truth for temporal automation in the modular synthesizer.

**Inputs (Dynamic):**
- `[Channel Name] In` (CV) - One input per automation channel (up to 32 channels)

**Outputs (Dynamic):**
- `[Channel Name] Out` (CV) - One output per automation channel (up to 32 channels)

**Parameters:**
- `Record` (Bool) - Enable recording mode (mutually exclusive with Play)
- `Play` (Bool) - Enable playback mode (mutually exclusive with Record)
- `Add Channel` (Button) - Create a new automation channel
- `Remove Channel` (Button) - Remove the last automation channel

**Auto-Connect Shortcuts:**
- **B (CV)**: Chain automation outputs to CV modulation inputs
- **Y (Gate)**: Chain gate/trigger outputs to gate inputs
- **R (Raw)**: Chain raw value outputs

**How to Use:**
1. **Setup Channels:**
   - Click "Add Channel" to create automation channels
   - Each channel can record a separate signal (CV, Gate, Trigger, or Raw)
   - Channels are automatically named (e.g., "Channel 1", "Channel 2")
   
2. **Recording:**
   - Connect signals you want to record to the Timeline's input pins
   - Click the "‚óè REC" button to enable recording
   - Start the global transport (Tempo Clock)
   - The Timeline records keyframes with sample-accurate timing
   - Recording automatically detects value changes (only stores new keyframes when values change)
   - Click "‚óè REC" again to stop recording
   
3. **Playback:**
   - Click the "‚ñ∂ PLAY" button to enable playback
   - Start the global transport
   - The Timeline plays back recorded automation, interpolating between keyframes
   - Playback is sample-accurate and synchronized to the global tempo
   
4. **Visualization:**
   - Select a channel from the list to view its keyframes
   - A waveform plot shows the recorded automation curve
   - The UI displays the current playback position in Bar:Beat:Tick format
   
5. **Persistence:**
   - Automation data is automatically saved with presets
   - All channels and keyframes are preserved when saving/loading patches
   
6. **Tips:**
   - Use multiple channels to record different parameters simultaneously
   - Record is mutually exclusive with Play - switch modes as needed
   - The Timeline passes through signals when neither Record nor Play is active (zero-latency monitoring)
   - Great for creating complex automation that syncs perfectly to tempo

**Technical Details:**
- Synchronized with global `TransportState` (from Tempo Clock)
- Sample-accurate keyframe recording and playback
- Linear interpolation between keyframes during playback
- Thread-safe data access (audio thread + UI thread)
- XML persistence via `getExtraStateTree()` / `setExtraStateTree()`
- Dynamic I/O pins based on number of automation channels

---

## 6. MIDI NODES

MIDI nodes handle MIDI input/output and conversion to CV.

### MIDI CV
**MIDI to CV Converter**

Converts incoming MIDI notes to CV/Gate signals (monophonic).

**Outputs:**
- `Pitch` (CV) - Note pitch as CV (V/Oct)
- `Gate` (Gate) - Note on/off gate
- `Velocity` (CV) - Note velocity
- `Mod Wheel` (CV) - CC1 modulation wheel
- `Pitch Bend` (CV) - Pitch bend wheel
- `Aftertouch` (CV) - Channel aftertouch

**How to Use:**
1. Connect MIDI controller or use virtual MIDI
2. Play notes ‚Üí outputs CV/Gate
3. Use with VCO + VCA + ADSR for classic synth voice
4. Monophonic (last note priority)

---

### MIDI Player
**MIDI File Player**

Plays MIDI files with per-track CV/Gate outputs.

**How to Use:**
1. Load a MIDI file
2. Outputs CV/Gate for each MIDI track
3. Great for backing tracks or complex sequences

---

### MIDI Faders
**MIDI-Learnable Faders (1-16)**

1-16 MIDI-learnable faders with customizable output ranges.

**Outputs:**
- `Fader 1-16` (CV) - CV outputs (0-1 range)

**Parameters:**
- MIDI Learn for each fader
- Min/Max output range per fader

**How to Use:**
1. Click MIDI Learn
2. Move a fader on your controller
3. Fader is now linked
4. Adjust output ranges as needed

---

### MIDI Knobs
**MIDI-Learnable Knobs (1-16)**

Similar to MIDI Faders but optimized for rotary controls.

---

### MIDI Buttons
**MIDI-Learnable Buttons (1-32)**

1-32 MIDI-learnable buttons with Gate/Toggle/Trigger modes.

**Outputs:**
- `Button 1-32` (Gate) - Gate/trigger outputs

**Modes:**
- Gate: High while pressed
- Toggle: Alternates on/off each press
- Trigger: Brief pulse on press

---

### MIDI Jog Wheel
**MIDI Jog Wheel Control**

A single MIDI-learnable jog wheel for expressive modulation.

**Output:**
- `Value` (CV) - Wheel position/velocity

---

## 7. ANALYSIS NODES

Analysis nodes visualize and inspect signals.

### Scope
**Oscilloscope**

Visualizes audio or CV signals over time.

**Inputs/Outputs:**
- `In/Out` (Audio) - Pass-through with visualization

**Parameters:**
- `Window Size` (0.5-20 seconds) - Time window to display
- `Trigger Mode` (Choice) - Free-run, Rising Edge, Falling Edge
- `Trigger Level` (0-1) - Trigger threshold

**How to Use:**
1. Insert in signal path (pass-through)
2. Adjust window size to see desired time range
3. Use trigger modes for stable waveform display
4. Great for debugging and sound design

---

### Debug
**Signal Value Logger**

Logs signal value changes to the console.

**How to Use:**
1. Insert in CV path
2. Logs values to console when they change
3. Great for troubleshooting CV routing
4. No audio output (endpoint)

---

### Input Debug
**Passthrough Debug Logger**

Like Debug but with pass-through output.

---

### Frequency Graph
**Spectrum Analyzer**

High-resolution real-time spectrum analyzer with frequency-based gate outputs.

**Inputs:**
- `In` (Audio) - Mono audio to analyze

**Outputs:**
- `Out L/R` (Audio) - Stereo pass-through
- `Sub/Bass/Mid/High Gate` (Gate) - Per-band gate outputs
- `Sub/Bass/Mid/High Trig` (Gate) - Per-band trigger outputs

**Parameters:**
- `Gate Threshold` per band - Threshold for gate outputs

**How to Use:**
1. Send audio through for visualization
2. Displays frequency spectrum in real-time
3. Use gate/trigger outputs for frequency-reactive triggering
4. Great for kick drum detection, bass triggering, etc.

---

## 8. SPECIAL NODES

Special nodes provide unique functionality beyond traditional synthesis.

### TTS Performer
**Text-to-Speech Engine**

Advanced text-to-speech with word-level sequencing.

**Inputs:**
- Per-word trigger inputs (1-16)
- Rate, Gate, Speed, Pitch modulation

**Outputs:**
- `Audio` - Speech audio output
- `Word Gate` - Gate while speaking
- `EOP Gate` - End of phrase gate
- Per-word gates and triggers (1-16)

**Parameters:**
- Text input field
- Voice selection
- Rate, pitch, speed controls

**How to Use:**
1. Type text into text field
2. Choose voice
3. Trigger individual words or play entire phrase
4. Use per-word gates for word-synced events
5. Modulate pitch/speed for effects

---

### Vocal Tract Filter
**Formant Filter**

Simulates human vowel sounds through formant filtering.

**Parameters:**
- `Vowel Shape` - Continuous blend between vowels (A, E, I, O, U)
- `Formant Shift` - Shift formant frequencies up/down
- `Instability` - Add human-like variation
- `Gain` - Formant emphasis

**How to Use:**
1. Send audio through (great with sawtooth waves)
2. Adjust vowel shape to morph between vowels
3. Modulate with LFOs for talking/singing effects
4. Use with TTS Performer for enhanced vocal synthesis

---

### Physics
**2D Physics Simulation**

A 2D physics engine that outputs collision and contact data as CV.

**How to Use:**
1. Create physics objects in the UI
2. Set gravity, friction, elasticity
3. Objects collide and interact
4. Outputs include position, velocity, collision events
5. Use outputs to drive synthesis parameters
6. Experimental and creative

---

### Animation
**3D Animation Player**

Loads and plays 3D animations, outputs joint positions and velocities.

**How to Use:**
1. Load 3D animation file (FBX, etc.)
2. Play animation
3. Outputs joint positions as CV
4. Drive synthesis from motion capture data

---

## 9. COMPUTER VISION NODES

Computer vision nodes process video for audio/CV generation.

### Webcam Loader
**Webcam Video Source**

Captures video from webcam and publishes a `Source ID` for vision processing modules.

**Outputs:**
- `Source ID` (Video) - Video source identifier

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect `Source ID` to any `Source In` (Video) input on vision processing modules (e.g., Movement/Human/Object/Color/Pose/Hand/Face/Contour/Segmentation).
- Other chaining keys (**C/G/B/Y/R**) not applicable for this node.

---

### Video File Loader
**Video File Source**

Loads and plays video files; publishes a `Source ID` for vision processing modules.

**Outputs:**
- `Source ID` (Video) - Video source identifier

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect `Source ID` to any `Source In` (Video) input on vision processing modules.
- Other chaining keys (**C/G/B/Y/R**) not applicable for this node.

---

### Movement Detector
**Motion Detection**

Analyzes video for motion via optical flow or background subtraction.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Motion X` (CV), `Motion Y` (CV) - Motion vector components
- `Amount` (CV) - Total motion amount
- `Trigger` (Gate) - Trigger on significant motion
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain `Motion X/Y/Amount` to CV destinations
- **Y (Gate)**: Chain `Trigger` to gate inputs

**How to Use:**
1. Connect webcam or video file loader
2. Outputs motion as CV
3. Use for interactive installations
4. Motion triggers synthesis events

---

### Human Detector
**Face/Body Detection**

Detects faces or bodies in video via Haar Cascades or HOG.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `X` (CV), `Y` (CV) - Center position
- `Width` (CV), `Height` (CV) - Bounding box size
- `Gate` (Gate) - High when person detected
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected face/body

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain X/Y/Width/Height to CV inputs
- **Y (Gate)**: Chain `Gate` to gate inputs

**How to Use:**
1. Connect video source
2. Detects faces/bodies
3. Outputs position and size as CV
4. Use for interactive performances

---

### Pose Estimator
**Body Keypoint Detection**

Uses OpenPose MPI model to detect 15 body keypoints. Outputs 30 CV pins programmatically (X/Y for each keypoint).

**Inputs:**
- `Source In` (Video) - Video source ID from webcam or video file loader

**Outputs (dynamic/programmatic):**
- `Head X/Y`, `Neck X/Y`, `R Shoulder X/Y`, `R Elbow X/Y`, `R Wrist X/Y`, `L Shoulder X/Y`, `L Elbow X/Y`, `L Wrist X/Y`, `R Hip X/Y`, `R Knee X/Y`, `R Ankle X/Y`, `L Hip X/Y`, `L Knee X/Y`, `L Ankle X/Y`, `Chest X/Y` (all CV)
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected body

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain any keypoint X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1). Lower values detect more keypoints but may include false positives
- `Draw Skeleton` (Bool) - Toggle skeleton overlay on video preview
- `Zoom` (+/-) - Toggle between normal (480px) and zoomed (960px) video preview

**How to Use:**
1. **Setup:** Download OpenPose MPI model files (see `guides/POSE_ESTIMATOR_SETUP.md`)
2. **Connect Video Source:** Connect a Webcam Loader or Video File Loader's `Source ID` output to `Source In`
3. **Adjust Confidence:** Lower threshold for more sensitive detection, higher for more reliable detection
4. **Map Keypoints:** Connect individual keypoint X/Y outputs to any CV modulation input
5. **Example Patches:**
   - **Hand-Controlled Oscillator:** Connect `R Wrist X` ‚Üí VCO Frequency, `R Wrist Y` ‚Üí VCF Cutoff
   - **Body-Driven Rhythm:** Connect `R Knee Y` ‚Üí Sequencer Rate, `L Knee Y` ‚Üí Gate threshold
   - **Dance Performance:** Map multiple keypoints to different parameters for full-body control
6. **Performance Tips:**
   - Good lighting improves detection accuracy
   - Stand 1-3 meters from camera for best results
   - Keep full body in frame for all keypoints to be detected
   - Simple backgrounds work best

**Technical Details:**
- Uses OpenPose MPI (faster) model with 15 keypoints
- Runs at ~15 FPS on CPU (computationally intensive)
- Outputs normalized coordinates (0-1 range)
- Real-time safe: Processing runs on separate thread, lock-free FIFO to audio thread
- Video preview shows skeleton overlay when enabled

**Creative Applications:**
- **Interactive Installations:** Create body-responsive soundscapes
- **Live Performance:** Control synthesis with gestures and movement
- **Accessibility:** Hands-free instrument control for performers with mobility constraints
- **Dance + Music:** Choreography-driven composition
- **Fitness Apps:** Exercise-triggered sound design
- **Game Controllers:** Full-body game audio integration

**Requirements:**
- OpenPose MPI model files (~200 MB download)
- Webcam or video file source
- OpenCV with DNN module (included in build)

---

### Hand Tracker
**Hand Keypoint Detection**

Uses OpenPose hand model to detect 21 hand keypoints. Outputs 42 CV pins (X/Y per keypoint).

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic/programmatic):**
- `Wrist X/Y`, `Thumb 1-4 X/Y`, `Index 1-4 X/Y`, `Middle 1-4 X/Y`, `Ring 1-4 X/Y`, `Pinky 1-4 X/Y` (all CV)
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected hand

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain any keypoint X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires OpenPose hand model files in `assets/openpose_models/hand/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Adjust Confidence:** Lower values for sensitive detection, higher for reliable detection
4. **Map Gestures:** Connect finger joint positions to synthesis parameters
5. **Example Patches:**
   - **Gesture Control:** Map thumb position to filter cutoff, index position to VCO frequency
   - **Finger Tracking:** Use individual finger tips for multi-parameter control
   - **Hand Size:** Use wrist to fingertip distances for amplitude or volume control
6. **Performance Tips:**
   - Works best with hands clearly visible against contrasting background
   - Keep hands ~30-80cm from camera
   - Good lighting improves detection accuracy

**Technical Details:**
- Uses OpenPose hand detection model
- Detects 21 keypoints per hand
- Runs at ~15 FPS on CPU
- Outputs normalized coordinates (0-1 range)

---

### Face Tracker
**Facial Landmark Detection**

Uses OpenPose face model to detect 70 facial landmarks. Outputs 140 CV pins (X/Y per point).

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic/programmatic):**
- `Pt 1-70 X/Y` (CV) - Landmark positions
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected face

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain landmark X/Y outputs to CV targets

**Parameters:**
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.1)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires OpenPose face model files in `assets/openpose_models/face/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Adjust Confidence:** Lower values for sensitive detection, higher for reliable detection
4. **Map Landmarks:** Connect facial landmark positions to synthesis parameters
5. **Example Patches:**
   - **Expression Control:** Map mouth width to effect parameters, eyebrow position to filter resonance
   - **Head Tracking:** Use face center for spatial panning
   - **Lip Sync:** Use mouth landmarks for vocoder or formant filtering
6. **Performance Tips:**
   - Face-front camera position works best
   - Keep face well-lit
   - Maintain 50-150cm distance from camera

**Technical Details:**
- Uses Haar Cascade for face detection, OpenPose DNN for landmark estimation
- Detects 70 landmarks per face
- Runs at ~15 FPS on CPU
- Outputs normalized coordinates (0-1 range)

---

### Object Detector
**YOLOv3 Object Detection**

Uses YOLOv3 deep learning model to detect objects from 80 COCO classes (person, car, bottle, etc.) in real-time video.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `X` (CV) - Center X position (0-1)
- `Y` (CV) - Center Y position (0-1)
- `Width` (CV) - Width (0-1)
- `Height` (CV) - Height (0-1)
- `Gate` (Gate) - High when target detected
- `Video Out` (Video) - Passthrough video output for chaining
- `Cropped Out` (Video) - Cropped region around detected object

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` or `Cropped Out` ‚Üí next video module
- **B (CV)**: Chain X/Y/Width/Height to CV inputs
- **Y (Gate)**: Chain `Gate` to gate inputs

**Parameters:**
- `Target Class` (Choice) - Object class to detect (person, car, bicycle, etc.)
- `Confidence` (0.0-1.0) - Detection confidence threshold (default: 0.5)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires YOLOv3 model files (`yolov3.cfg`, `yolov3.weights`, `coco.names`) in `assets/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Select Target Class:** Choose which object type to detect
4. **Adjust Confidence:** Lower for more detections (may include false positives), higher for reliable detection
5. **Map Coordinates:** Connect X/Y/Width/Height outputs to synthesis parameters
6. **Example Patches:**
   - **Person Tracking:** Use person bounding box to trigger events when person enters/exits frame
   - **Object Size Control:** Use Width √ó Height to control effect amount
   - **Position-Based Effects:** Map center X to panning, center Y to filter cutoff
7. **Performance Tips:**
   - YOLO is computationally intensive (~10 FPS on CPU)
   - Good lighting and contrast improve detection
   - Larger objects are detected more reliably

**Technical Details:**
- Uses YOLOv3 (You Only Look Once v3) detection model
- 80 COCO object classes supported
- Runs at ~10 FPS on CPU
- Outputs normalized bounding box coordinates
- Falls back to YOLOv3-tiny if standard model not available

---

### Color Tracker
**Multi-Color HSV Tracking**

Tracks multiple custom colors in video using HSV color space. Outputs are dynamic: each added color creates three CV outputs.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs (dynamic):**
- For each tracked color:
  - `[Color] X` (CV) - Center X (0-1)
  - `[Color] Y` (CV) - Center Y (0-1)
  - `[Color] Area` (CV) - Covered area (0-1)
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain per-color X/Y/Area to CV inputs

**Parameters:**
- `Add Color...` (Button) - Click to pick a color from the video preview
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
2. **Pick Colors:** Click "Add Color..." and click on the video preview to sample a color
3. **Track Multiple:** Add up to 8 different colors to track simultaneously
4. **Remove Colors:** Click "Remove" button next to each tracked color
5. **Map Coordinates:** Connect individual color outputs to synthesis parameters
6. **Example Patches:**
   - **Two-Object Control:** Track two colored objects for stereo panning or dual oscillator control
   - **Area-Based Effects:** Use Area output to control effect wet/dry mix
   - **Position Automation:** Map color X/Y to sequencer position or filter sweeps
7. **Performance Tips:**
   - Works best with saturated, distinct colors
   - Avoid overlapping colors in similar hues
   - Good lighting maintains consistent HSV values

**Technical Details:**
- Uses HSV color space for robust color detection
- Tracks up to 8 colors simultaneously
- Automatic morphological cleanup for noise reduction
- Runs at ~30 FPS on CPU
- Outputs normalized coordinates and area

---

### Contour Detector
**Shape Detection via Background Subtraction**

Detects shapes and their properties using background subtraction and contour analysis.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Area` (CV) - Detected shape area (0-1)
- `Complexity` (CV) - Polygon complexity (0-1)
- `Aspect Ratio` (CV) - Width/height ratio
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain outputs to CV inputs

**Parameters:**
- `Threshold` (0-255) - Threshold for foreground/background separation (default: 128)
- `Noise Reduction` (Bool) - Enable morphological filtering to reduce noise (default: On)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
2. **Adjust Threshold:** Set threshold to separate foreground from background
3. **Enable Noise Reduction:** Reduce detection of small, noisy artifacts
4. **Map Shape Properties:** Connect Area, Complexity, and Aspect Ratio to synthesis parameters
5. **Example Patches:**
   - **Size-Based Filtering:** Use Area to control low-pass filter cutoff
   - **Shape Recognition:** Use Complexity to detect simple vs complex shapes
   - **Orientation Control:** Use Aspect Ratio to determine if object is horizontal or vertical
6. **Performance Tips:**
   - Requires relatively static background for best results
   - Good contrast between foreground and background
   - Use noise reduction for clean signal

**Technical Details:**
- Uses MOG2 background subtraction
- Polygon approximation for complexity calculation
- Runs at ~25 FPS on CPU
- Outputs normalized shape properties

---

### Semantic Segmentation
**Scene Segmentation via Deep Learning**

Uses semantic segmentation (ENet or DeepLabV3) to identify a target class and output region properties.

**Inputs:**
- `Source In` (Video) - Video source ID

**Outputs:**
- `Area` (CV) - Frame coverage of target class (0-1)
- `Center X` (CV) - Center X of detected region (0-1)
- `Center Y` (CV) - Center Y of detected region (0-1)
- `Gate` (Gate) - High when target detected
- `Video Out` (Video) - Passthrough video output for chaining

**Auto-Connect Shortcuts:**
- **V (Video)**: Connect loader `Source ID` ‚Üí `Source In`; chain `Video Out` ‚Üí next video module
- **B (CV)**: Chain Area and Center outputs to CV targets.
- **Y (Gate)**: Chain `Gate` to gate inputs.

**Parameters:**
- `Target Class` (Choice) - Semantic class to detect (person, road, car, etc.)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**How to Use:**
1. **Setup:** Requires ENet or DeepLabV3 model files in `assets/`
2. **Connect Video Source:** Connect Webcam or Video File Loader's `Source ID` to `Source In`
3. **Select Target Class:** Choose which semantic class to track
4. **Map Region Properties:** Connect Area and Center outputs to synthesis parameters
5. **Example Patches:**
   - **Presence Detection:** Use Gate output to trigger events when person enters frame
   - **Coverage-Based Effects:** Use Area to control reverb size or delay feedback
   - **Center Tracking:** Use Center X/Y for spatial effects
6. **Performance Tips:**
   - Computationally intensive (~10 FPS on CPU)
   - Best results with scenes that match training data (Cityscapes, etc.)
   - Works well for large, distinct regions

**Technical Details:**
- Uses ENet (Efficient Neural Network) or DeepLabV3 segmentation models
- Supports Cityscapes dataset classes by default
- Runs at ~10 FPS on CPU
- Outputs normalized region properties with colored preview overlay

---

### Video FX
**Real-Time Video Effects Processor**

A comprehensive video processing node that applies real-time effects to video streams. Supports chaining multiple effects for complex video transformations. All parameters can be modulated via CV inputs.

**Inputs:**
- `Source In` (Video) - Video source ID from webcam, video file, or other video processing nodes

**Outputs:**
- `Output ID` (Video) - Processed video source ID for chaining to other video modules

**Parameters (All CV-Modulatable):**

**Color Adjustments:**
- `Brightness` (-100 to +100) - Brightness adjustment
- `Contrast` (0.0-3.0) - Contrast multiplier
- `Saturation` (0.0-3.0) - Color saturation (0=grayscale, 1=normal, >1=enhanced)
- `Hue Shift` (-180 to +180) - Hue rotation in degrees
- `Red/Green/Blue Gain` (0.0-2.0) - Per-channel gain control
- `Temperature` (-1.0 to +1.0) - Color temperature (cold to warm)
- `Sepia` (Bool) - Apply sepia tone effect

**Filters & Effects:**
- `Sharpen` (0.0-2.0) - Sharpening amount
- `Blur` (0-20) - Blur radius
- `Grayscale` (Bool) - Convert to grayscale
- `Invert Colors` (Bool) - Invert color values
- `Flip Horizontal/Vertical` (Bool) - Mirror frames

**Advanced Effects:**
- `Threshold Enable` (Bool) - Enable threshold effect
- `Threshold Level` (0-255) - Threshold cutoff
- `Posterize Levels` (2-32) - Color quantization (lower = fewer colors)
- `Vignette Amount` (0.0-1.0) - Vignette darkening intensity
- `Vignette Size` (0.1-2.0) - Vignette radius
- `Pixelate Block Size` (1-128) - Pixelation block size
- `Edge Detect (Canny)` (Bool) - Enable Canny edge detection
- `Canny Threshold 1/2` (0-255) - Edge detection thresholds
- `Kaleidoscope` (Choice) - None, 4-Way, or 8-Way mirroring

**System:**
- `Use GPU (CUDA)` (Bool) - Enable GPU acceleration (if available)
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**Auto-Connect Shortcuts:**
- **V (Video)**: Chain video source ‚Üí `Source In`, `Output ID` ‚Üí next video module
- All color/filter parameters accept CV modulation for dynamic effects

**How to Use:**
1. **Connect Video Source:** Connect Webcam, Video File Loader, or another Video FX node to `Source In`
2. **Chain Effects:** Connect `Output ID` to another Video FX or CV processing module
3. **Adjust Parameters:** Use sliders for real-time preview
4. **Modulate with CV:** Connect LFOs, envelopes, or sequencers to CV inputs for animated effects
5. **Example Chains:**
   - **Color Grading Chain:** Video FX (saturation + temperature) ‚Üí Video FX (contrast + brightness)
   - **Stylization:** Video FX (posterize + vignette) ‚Üí Video FX (sepia + blur)
   - **Motion Effects:** LFO ‚Üí Brightness CV, ADSR ‚Üí Blur CV for dynamic effects
6. **Performance Tips:**
   - GPU acceleration significantly improves performance (enable if available)
   - Chain multiple Video FX nodes for complex effect combinations
   - Use CV modulation for automated video transformations
   - Preview size affects UI performance (use Small for many nodes)

**Technical Details:**
- Passthrough video processing (zero latency)
- Supports GPU acceleration via CUDA (when compiled with CUDA support)
- Real-time processing at video frame rate
- All effects are composable and can be combined
- Dynamic CV modulation inputs for all parameters
- Creates new video source ID for processed output (enables chaining)

---

### Crop Video
**Video Cropping with Automatic Tracking**

Crops video frames to a specified region. Supports three modes: manual cropping, automatic face tracking, and automatic object tracking (YOLOv3). Perfect for following detected objects or isolating regions of interest.

**Inputs:**
- `Source In` (Video) - Video source ID
- `Center X Mod` (CV) - Center X position modulation (0-1)
- `Center Y Mod` (CV) - Center Y position modulation (0-1)
- `Width Mod` (CV) - Crop width modulation (0-1)
- `Height Mod` (CV) - Crop height modulation (0-1)

**Outputs:**
- `Output ID` (Video) - Cropped video source ID for chaining

**Parameters:**
- `Tracking Mode` (Choice) - Manual, Track Face, or Track Object
- `Target Class` (Choice) - Object class when tracking objects (person, car, etc.)
- `Confidence` (0.0-1.0) - Detection confidence threshold
- `Padding` (0.0-2.0) - Padding around tracked region (0.1 = 10% padding)
- `Aspect Ratio` (Choice) - Stretch or Preserve (Fit)
- `Use GPU (CUDA)` (Bool) - Enable GPU acceleration for tracking
- `Zoom` (+/-) - Adjust preview size: Small (240px), Normal (480px), Large (960px)

**Manual Crop Controls:**
- `Center X/Y` (0-1) - Crop region center position
- `Width/Height` (0-1) - Crop region size

**Auto-Connect Shortcuts:**
- **V (Video)**: Chain video source ‚Üí `Source In`, `Output ID` ‚Üí next video module
- **B (CV)**: Connect CV signals (from Object/Human/Pose detectors) to Center X/Y/Width/Height modulation inputs

**How to Use:**
1. **Manual Mode:**
   - Connect video source to `Source In`
   - Adjust Center X/Y and Width/Height sliders
   - Use Aspect Ratio "Preserve" to maintain original proportions
   
2. **Track Face Mode:**
   - Select "Track Face" from Tracking Mode
   - Automatically detects and tracks faces using Haar Cascade
   - Adjust Padding to add space around face
   - GPU acceleration recommended for better performance

3. **Track Object Mode:**
   - Select "Track Object" from Tracking Mode
   - Choose Target Class (e.g., "person", "car", "bottle")
   - Requires YOLOv3 model files in `assets/`
   - Automatically tracks and crops to detected object bounding box
   - Adjust Confidence threshold to filter detections

4. **CV Modulation:**
   - Connect Object Detector X/Y/Width/Height outputs to Crop Video modulation inputs
   - Connect Pose Estimator keypoint positions for dynamic cropping
   - Use sequencers or LFOs for automated crop animations

5. **Example Patches:**
   - **Face Isolation:** Track Face mode ‚Üí Cropped output to Face Tracker for detailed analysis
   - **Person Following:** Object Detector (person) ‚Üí Crop Video CV inputs ‚Üí Cropped region to Pose Estimator
   - **Dynamic Cropping:** LFO ‚Üí Center X Mod, ADSR ‚Üí Width Mod for animated crops
   - **Multi-Stage Processing:** Crop Video ‚Üí Video FX (stylize cropped region) ‚Üí Further processing

6. **Performance Tips:**
   - GPU acceleration improves tracking performance (especially for YOLOv3)
   - Lower confidence thresholds detect more objects but may include false positives
   - Padding helps maintain context around tracked objects
   - Use Preserve aspect ratio to avoid distortion

**Technical Details:**
- Three tracking modes: Manual (slider-based), Face (Haar Cascade), Object (YOLOv3)
- YOLOv3 tracking requires model files (`yolov3.cfg`, `yolov3.weights`, `coco.names`)
- Falls back to YOLOv3-tiny if standard model not available
- GPU acceleration via CUDA (optional, improves performance)
- Real-time processing at video frame rate
- Passthrough video processing with zero latency
- CV modulation allows dynamic crop region control

---

## 11. SYSTEM NODES

System nodes provide special functionality for patch organization.

### Meta
**Meta Module Container**

A container for creating custom reusable modules from sub-patches.

**How to Use:**
1. Create a patch inside the Meta module
2. Use Inlet/Outlet nodes to define interface
3. Save as reusable module
4. Collapse complex patches into single nodes

---

### Inlet
**Meta Module Input**

Defines an input for a Meta module.

---

### Outlet
**Meta Module Output**

Defines an output for a Meta module.

---

### Comment
**Documentation Node**

A text comment node for documenting patches.

**How to Use:**
1. Add comment node
2. Type documentation text
3. Helps explain complex patches
4. No audio/CV functionality

---

### Recorder
**Audio Recording to File**

Records incoming audio to WAV, AIFF, or FLAC files.

**Inputs:**
- `In L/R` (Audio) - Stereo audio to record

**Parameters:**
- File path/name
- Format (WAV, AIFF, FLAC)
- Bit depth (16/24/32)
- Record button

**How to Use:**
1. Set file path and format
2. Connect audio source
3. Click Record to start
4. Click Stop to finish and save

---

### VST Host
**VST Plugin Host**

Hosts VST2/VST3 plugins within the modular environment.

**How to Use:**
1. Load VST plugin
2. Audio routed through plugin
3. Use external effects and instruments
4. Combine modular with traditional plugins

---

### BPM Monitor
**Rhythm Detection and BPM Reporting**

A hybrid smart system that automatically detects and reports BPM from rhythm-producing modules and audio inputs. This node is always present in patches (like the output node) and cannot be deleted. It dynamically generates output pins for each detected rhythm source.

**Inputs (Dynamic):**
- `In 1-16` (Audio) - Audio inputs for beat detection (up to 16 channels)

**Outputs (Dynamic):**
- For each detected rhythm source:
  - `[Source Name] BPM` (Raw) - Absolute BPM value
  - `[Source Name] CV` (CV) - Normalized BPM (0-1 range for modulation)
  - `[Source Name] Active` (Gate) - High when source is active (for introspected sources)
  - `[Source Name] Confidence` (CV) - Detection confidence (0-1, for detected sources)

**Parameters:**
- `Operation Mode` (Choice) - Auto (both methods), Introspection Only, or Detection Only
- `Min BPM` (20-120) - Minimum BPM for normalization (default: 60)
- `Max BPM` (120-300) - Maximum BPM for normalization (default: 240)

**Auto-Connect Shortcuts:**
- **B (CV)**: Chain `[Source] CV` outputs to CV modulation inputs
- **Y (Gate)**: Chain `[Source] Active` outputs to gate inputs
- **R (Raw)**: Chain `[Source] BPM` outputs to raw value inputs
- **G (Audio)**: Connect audio sources to beat detection inputs

**How to Use:**
1. **Operation Modes:**
   - **Auto**: Uses both introspection (fast) and beat detection (universal)
   - **Introspection Only**: Only scans modules that report rhythm info (sequencers, animations)
   - **Detection Only**: Only analyzes audio inputs using tap tempo algorithm
   
2. **Introspection (Recommended):**
   - Automatically detects modules that implement `getRhythmInfo()`
   - Works with: Sequencer, Step Sequencer, Animation, Physics, and other rhythm-producing modules
   - Provides instant, accurate BPM reporting
   - Scans the graph periodically (every 128 audio blocks for efficiency)
   
3. **Beat Detection (Fallback):**
   - Connect any rhythmic audio signal to the inputs
   - Uses tap tempo algorithm with rolling average
   - Works with external audio, VST plugins, or any rhythmic source
   - Outputs confidence level indicating detection stability
   
4. **Using Outputs:**
   - Each detected source generates three outputs:
     - **BPM (Raw)**: Absolute BPM value (e.g., 120.0)
     - **CV**: Normalized 0-1 range for modulation (scaled by Min/Max BPM parameters)
     - **Active/Confidence**: Gate for introspected sources, confidence CV for detected sources
   
5. **Example Patches:**
   - **Sync Effects to Sequencer**: Connect Sequencer ‚Üí BPM Monitor, use `CV` output to modulate delay time
   - **Beat-Synchronized LFO**: Use `CV` output to sync LFO rate to detected BPM
   - **Multi-Source Tempo**: Monitor multiple sequencers and select the most appropriate one
   - **External Tempo Sync**: Connect audio input from external source, use detected BPM to sync your patch
   
6. **Tips:**
   - Introspection mode is fastest and most accurate for compatible modules
   - Beat detection works with any rhythmic source but may have latency
   - Use Min/Max BPM parameters to set the CV output range for your modulation needs
   - The node automatically updates when new rhythm sources appear or disappear

**Technical Details:**
- Hybrid detection: introspection (via `getRhythmInfo()`) + audio analysis (TapTempo algorithm)
- Graph scanning runs every 128 audio blocks (~2.9ms at 44.1kHz) for efficiency
- Thread-safe access to detected sources (protects dynamic pin queries)
- Dynamic output pins generated based on detected sources
- Always present (logical ID 999, undeletable)
- Supports up to 16 audio detection inputs

**Supported Introspection Sources:**
- Sequencer (reports BPM when active)
- Step Sequencer (reports BPM when running)
- Animation (reports BPM based on animation speed and duration)
- Physics (can report rhythm from collision events)
- Other modules implementing `getRhythmInfo()`

---


## Glossary

**CV (Control Voltage):** A signal (typically 0-1 or -1 to +1) used to modulate parameters.

**Gate:** A binary signal (high/low, on/off) used for triggering and timing.

**Trigger:** A brief pulse signal, typically used to initiate events.

**Audio:** Full-rate audio signals (~44.1kHz or higher).

**Raw:** Unscaled numerical values for custom ranges.

**Video:** Video source identifier for computer vision processing.

**V/Oct:** Volt-per-octave pitch CV standard (1 semitone = 1/12 V).

**Relative Modulation:** CV modulates around a slider position (musical/proportional).

**Absolute Modulation:** CV directly maps to full parameter range.

**Bipolar:** Signal range from -1 to +1 (centered at 0).

**Unipolar:** Signal range from 0 to 1.

---

## Keyboard Shortcuts for Auto-Connection

When multiple nodes are selected, use these keys to chain them by data type:

| Key | Data Type | Color | Use Case |
|-----|-----------|-------|----------|
| **C** | Standard Chaining | White | Stereo audio chain (channels 0‚Üí0, 1‚Üí1) |
| **G** | Audio | Green | Audio effects chain |
| **B** | CV (Control Voltage) | Blue | CV signal chain |
| **Y** | Gate | Yellow | Gate/trigger chain |
| **R** | Raw | Red | Raw value chain |
| **V** | Video | Cyan | Video source chain (webcam/video ‚Üí CV modules) |

**Note:** Auto-connection shortcuts only work when 2+ nodes are selected.

---

## Tips for Using the Dictionary

1. **Search by Function:** Use Ctrl+F to find nodes by keyword (e.g., "distortion", "filter", "envelope")
2. **Follow the Signal Flow:** Start with Sources ‚Üí Effects ‚Üí Output
3. **Modulation is Key:** Most parameters can be modulated - experiment!
4. **Save Your Patches:** Use the preset system to save and recall configurations
5. **Start Simple:** Build complexity gradually by adding one module at a time

---

**End of Nodes Dictionary**

*For more information, see the main user manual and individual module guides.*




================================================================================
FILE: juce\Source\preset_creator\NotificationManager.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <juce_graphics/juce_graphics.h>
#include <deque>

class NotificationManager
{
public:
    enum class Type { Status, Success, Error, Warning, Info };

    // Call this from any thread to post a new notification
    static void post(Type type, const juce::String& message, float duration = 5.0f);

    // Call this once per frame inside your main ImGui render loop
    static void render();

private:
    struct Notification
    {
        uint32_t id;
        Type type;
        juce::String message;
        double startTime;
        float lifetime;
        float alpha = 0.0f; // For fade animation
    };

    // Singleton access
    static NotificationManager& getInstance();

    NotificationManager() = default;
    ~NotificationManager() = default;
    NotificationManager(const NotificationManager&) = delete;
    NotificationManager& operator=(const NotificationManager&) = delete;

    void postImpl(Type type, const juce::String& message, float duration);
    void renderImpl();

    std::deque<Notification> m_notifications;
    juce::CriticalSection m_lock;
    uint32_t m_nextId = 0;
};



================================================================================
FILE: juce\Source\preset_creator\NotificationManager.cpp
================================================================================


#include "NotificationManager.h"

#include <imgui.h>
#include <juce_events/juce_events.h>
#include <algorithm>

void NotificationManager::post(Type type, const juce::String& message, float duration)
{
    // Use MessageManager to ensure the post happens on the UI thread,
    // which simplifies thread safety as only the render loop modifies the queue.
    juce::MessageManager::callAsync([=]() {
        getInstance().postImpl(type, message, duration);
    });
}

void NotificationManager::render()
{
    getInstance().renderImpl();
}

NotificationManager& NotificationManager::getInstance()
{
    static NotificationManager instance;
    return instance;
}

void NotificationManager::postImpl(Type type, const juce::String& message, float duration)
{
    const juce::ScopedLock lock(m_lock);
    m_notifications.push_back({
        ++m_nextId,
        type,
        message,
        ImGui::GetTime(),
        duration
    });
}

void NotificationManager::renderImpl()
{
    const juce::ScopedLock lock(m_lock);
    if (m_notifications.empty()) return;

    const float now = (float)ImGui::GetTime();
    const float padding = 10.0f;
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImVec2 work_pos = viewport->WorkPos;
    float currentY = work_pos.y + padding;

    const float fadeInTime = 0.3f;
    const float fadeOutTime = 0.5f;

    for (auto& notif : m_notifications)
    {
        float age = now - (float)notif.startTime;
        bool isDismissed = false;

        // Fade In
        if (age < fadeInTime) {
            notif.alpha = juce::jmap(age, 0.0f, fadeInTime, 0.0f, 1.0f);
        }
        // Fade Out (triggered by time or click)
        else if (age > notif.lifetime) {
            float fadeAge = age - notif.lifetime;
            notif.alpha = juce::jmap(fadeAge, 0.0f, fadeOutTime, 1.0f, 0.0f);
            if (fadeAge > fadeOutTime) isDismissed = true;
        }
        // Fully visible
        else {
            notif.alpha = 1.0f;
        }

        float windowWidth = 350.0f;
        float windowHeight = 60.0f;

        float slideInOffset = juce::jmap(std::min(age, fadeInTime), 0.0f, fadeInTime, windowWidth, 0.0f);
        ImVec2 windowPos = ImVec2(viewport->WorkPos.x + viewport->WorkSize.x - windowWidth - padding + slideInOffset, currentY);

        ImGui::SetNextWindowPos(windowPos);
        ImGui::SetNextWindowSize(ImVec2(windowWidth, windowHeight));
        ImGui::SetNextWindowBgAlpha(0.8f * notif.alpha);

        char windowName[32];
        snprintf(windowName, 32, "Notification##%u", notif.id);

        ImGui::Begin(windowName, nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav);
        
        // Check if window was clicked (using hover + mouse button check)
        if (ImGui::IsWindowHovered() && ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
            notif.startTime = now - notif.lifetime; // Trigger fade out immediately
        }

        ImVec4 iconColor;
        const char* iconText = nullptr;

        switch (notif.type) {
            case Type::Success: 
                iconColor = ImVec4(0.2f, 1.0f, 0.2f, 1.0f); 
                iconText = "\xE2\x9C\x85"; // ‚úÖ
                break;
            case Type::Error:   
                iconColor = ImVec4(1.0f, 0.2f, 0.2f, 1.0f); 
                iconText = "\xE2\x9D\x8C"; // ‚ùå
                break;
            case Type::Warning: 
                iconColor = ImVec4(1.0f, 0.8f, 0.2f, 1.0f); 
                iconText = "\xE2\x9A\xA0\xEF\xB8\x8F"; // ‚ö†Ô∏è
                break;
            case Type::Info:    
                iconColor = ImVec4(0.2f, 0.6f, 1.0f, 1.0f); 
                iconText = "\xE2\x84\xB9\xEF\xB8\x8F"; // ‚ÑπÔ∏è
                break;
            case Type::Status:  
                iconColor = ImVec4(0.8f, 0.8f, 0.8f, 1.0f); 
                iconText = nullptr; // Spinner
                break;
        }
        ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertFloat4ToU32(ImVec4(iconColor.x, iconColor.y, iconColor.z, notif.alpha)));
        
        if (notif.type == Type::Status) {
            ImDrawList* drawList = ImGui::GetWindowDrawList();
            ImVec2 spinnerCenter = ImVec2(ImGui::GetCursorScreenPos().x + 12, ImGui::GetCursorScreenPos().y + 12);
            drawList->PathArcTo(spinnerCenter, 8.0f, now * 4.0f, now * 4.0f + 4.0f, 32);
            drawList->PathStroke(ImGui::GetColorU32(ImGuiCol_Text), 0, 2.0f);
        } else if (iconText != nullptr) {
            ImGui::TextUnformatted(iconText);
        }
        ImGui::PopStyleColor();

        ImGui::SameLine(35.0f);
        ImGui::PushStyleColor(ImGuiCol_Text, ImGui::ColorConvertFloat4ToU32(ImVec4(1.0f, 1.0f, 1.0f, notif.alpha)));
        ImGui::TextWrapped("%s", notif.message.toRawUTF8());
        ImGui::PopStyleColor();

        // Progress bar for auto-dismissal
        if (notif.type != Type::Error && notif.type != Type::Status) {
            float progress = juce::jlimit(0.0f, 1.0f, age / notif.lifetime);
            ImVec2 p_min = ImVec2(ImGui::GetWindowPos().x, ImGui::GetWindowPos().y + windowHeight - 3.0f);
            ImVec2 p_max = ImVec2(p_min.x + windowWidth * (1.0f - progress), p_min.y + 3.0f);
            ImGui::GetWindowDrawList()->AddRectFilled(p_min, p_max, ImGui::GetColorU32(iconColor));
        }

        ImGui::End();

        currentY += windowHeight + padding;
    }

    // Remove dismissed notifications
    m_notifications.erase(std::remove_if(m_notifications.begin(), m_notifications.end(), 
        [&](const Notification& n) {
            return (now - n.startTime) > (n.lifetime + fadeOutTime);
    }), m_notifications.end());
}



================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_opengl/juce_opengl.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <unordered_map>
#include <tuple>
#include <deque>
#include <atomic>
#include <imgui.h>
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/graph/ModularSynthProcessor.h"
#include "PresetManager.h"
#include "SampleManager.h"
#include "MidiManager.h"
#include "ControllerPresetManager.h"

// Forward declarations from Dear ImGui / imnodes
struct ImGuiContext; struct ImGuiIO; struct ImNodesContext;
class MIDIPlayerModuleProcessor;
class MultiSequencerModuleProcessor;
class StrokeSequencerModuleProcessor;
class AnimationModuleProcessor;
class ColorTrackerModule;

// Forward declaration (SavePresetJob is now in its own file to avoid circular dependencies)
class SavePresetJob;

// === NODE SIZING SYSTEM ===
// Standardized node width categories for consistent visual layout
enum class NodeWidth 
{ 
    Small,      // 240px - Basic modules (VCO, VCA, simple utilities)
    Medium,     // 360px - Effects with visualizations (Reverb, Chorus, Phaser)
    Big,        // 480px - Complex modules (PolyVCO, advanced effects)
    ExtraWide,  // 840px - Timeline/grid modules (MultiSequencer, MIDI Player)
    Exception   // Custom size - Module defines its own dimensions via getCustomNodeSize()
};

// Helper function to convert NodeWidth category to pixel width
inline float getWidthForCategory(NodeWidth width)
{
    switch (width)
    {
        case NodeWidth::Medium:    return 360.0f;
        case NodeWidth::Big:       return 480.0f;
        case NodeWidth::ExtraWide: return 840.0f;
        case NodeWidth::Exception: return 0.0f;  // Signals that module provides custom size
        case NodeWidth::Small:
        default:                   return 360.0f;
    }
}

// Pin information struct for node editor
struct PinInfo {
    uint32_t id;      // The unique ID of the pin
    juce::String type; // The parsed type ("Pitch", "Gate", "Trig", etc.)
};

class ImGuiNodeEditorComponent : public juce::Component,
                                 private juce::OpenGLRenderer
{
public:
    ImGuiNodeEditorComponent(juce::AudioDeviceManager& deviceManager);
    ~ImGuiNodeEditorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    // Input is handled by imgui_juce backend; no JUCE overrides needed
    
    void setMidiActivityFrames(int frames) { midiActivityFrames = frames; }
    
    void setModel (ModularSynthProcessor* model)
    { 
        synth = model; 
        undoStack.clear(); 
        redoStack.clear(); 
    }
    
    // ADD: Callback for showing audio settings dialog
    std::function<void()> onShowAudioSettings;
    
    // UI state roundtrip
    juce::ValueTree getUiValueTree() const;
    // Thread-safe: queues UI state to be applied on next render frame
    void applyUiValueTree (const juce::ValueTree& uiState);
    void applyUiValueTreeNow (const juce::ValueTree& uiState);

    // --- Helper structs ---
    struct Range { float min; float max; };
    
    // --- Pin ID System Struct (declare before any usage) ---
    struct PinID
    {
        juce::uint32 logicalId = 0;
        int channel = 0;
        bool isInput = false;
        bool isMod = false;
        juce::String paramId; // used for mod pins
    };

    // OpenGLRenderer
    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;

    // Helper functions for pin type checking and UI
    PinDataType getPinDataTypeForPin(const PinID& pin);
    unsigned int getImU32ForType(PinDataType type);
    const char* pinDataTypeToString(PinDataType type);
    
    void handleRandomizePatch();
    void handleRandomizeConnections();
    void handleConnectSelectedToTrackMixer();
    void handleBeautifyLayout();
    void handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleInsertNodeOnSelectedLinks(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin);
    void drawInsertNodeOnLinkPopup();

    // New intelligent auto-connection system
    void parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex);
    
    // Helper functions to get pins from modules
    std::vector<AudioPin> getOutputPins(const juce::String& moduleType);
    std::vector<AudioPin> getInputPins(const juce::String& moduleType);
    AudioPin* findInputPin(const juce::String& moduleType, const juce::String& pinName);
    AudioPin* findOutputPin(const juce::String& moduleType, const juce::String& pinName);
    std::vector<juce::uint32> findNodesOfType(const juce::String& moduleType);
    
    // New dynamic pin-fetching helper
    std::vector<PinInfo> getDynamicOutputPins(ModuleProcessor* module);
    
    template<typename TargetProcessorType>
    void connectToMonophonicTargets(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping, const std::vector<juce::uint32>& targetLids);
    template<typename TargetProcessorType>
    void connectToPolyphonicTarget(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping);
    void handleAutoConnectionRequests();
    
    // MIDI Player Quick Connect handler
    void handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType);
    
    // StrokeSequencer specific handler
    void handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid);
    
    // AnimationModule specific handlers
    void handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid);
    
    // MultiSequencer specific handlers
    void handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    void handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    
    // Color Tracker auto-connect handlers
    void handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid);
    void handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid);

    void renderImGui();
    void handleDeletion();
    void bypassDeleteSelectedNodes();
    void bypassDeleteNode(juce::uint32 logicalId);
    void startSaveDialog();
    void savePresetToFile(const juce::File& file);
    void startLoadDialog();
    std::vector<juce::uint32> getMutedNodeIds() const;
    juce::String getTypeForLogical (juce::uint32 logicalId) const;

    // --- Collision-Proof Pin ID System ---
    // 32-bit ID with guaranteed separation from node IDs:
    // Bit 31: PIN_ID_FLAG (always 1 for pins, 0 for nodes)
    // Bit 30: IS_INPUT_FLAG (1 for input, 0 for output)
    // Bits 16-29: Channel Index (14 bits, up to 16384 channels)
    // Bits 0-15: Node Logical ID (16 bits, up to 65535 nodes)
    // This ensures pin IDs can never collide with node IDs
    
    static int encodePinId(const PinID& pinId)
    {
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);
        
        juce::uint32 encoded = PIN_ID_FLAG |
                               (pinId.isInput ? IS_INPUT_FLAG : 0) |
                               (((juce::uint32)pinId.channel & 0x3FFF) << 16) |
                               (pinId.logicalId & 0xFFFF);
        
        return (int)encoded;
    }

    static PinID decodePinId(int id)
    {
        PinID pinId;
        const juce::uint32 uid = (juce::uint32)id;
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);

        // Only decode if this is actually a pin ID (has the flag set)
        if ((uid & PIN_ID_FLAG) == 0)
        {
            // This is not a pin ID! Return invalid pin
            juce::Logger::writeToLog("[ERROR] decodePinId called with non-pin ID: " + juce::String((int)id));
            pinId.logicalId = 0;
            pinId.channel = 0;
            pinId.isInput = false;
            pinId.isMod = false;
            return pinId;
        }

        pinId.logicalId = uid & 0xFFFF;
        pinId.channel   = (int)((uid >> 16) & 0x3FFF); // 14-bit mask
        pinId.isInput   = (uid & IS_INPUT_FLAG) != 0;
        pinId.isMod     = false; // handled contextually, not in the bitmask
        return pinId;
    }


    juce::OpenGLContext glContext;
    ImGuiContext* imguiContext { nullptr };
    ImGuiIO* imguiIO { nullptr };
    ImNodesContext* editorContext { nullptr };
    double lastTime { 0.0 };

    juce::AudioDeviceManager& deviceManager;
    ModularSynthProcessor* synth { nullptr };
    juce::ValueTree uiPending; // applied at next render before drawing nodes
    std::atomic<bool> graphNeedsRebuild { false };
    int midiActivityFrames = 0; // For MIDI activity indicator
    
    // Preset and sample management
    PresetManager m_presetManager;
    SampleManager m_sampleManager;
    juce::String m_presetSearchTerm;
    juce::String m_sampleSearchTerm;
    juce::File m_presetScanPath;
    juce::File m_sampleScanPath;
    std::unique_ptr<juce::FileChooser> presetPathChooser;
    std::unique_ptr<juce::FileChooser> samplePathChooser;
    
    // MIDI file management
    MidiManager m_midiManager;
    juce::File m_midiScanPath;
    juce::String m_midiSearchTerm;
    std::unique_ptr<juce::FileChooser> midiPathChooser;
    
    // Meta module editing state
    juce::uint32 metaModuleToEditLid = 0;
    
    // Cache of last-known valid node positions (used when graphNeedsRebuild prevents rendering)
    std::unordered_map<int, ImVec2> lastKnownNodePositions;

    // Selection state
    int selectedLogicalId { 0 };

    std::unique_ptr<juce::FileChooser> saveChooser, loadChooser;

    // Map of linkId -> (srcAttr, dstAttr) populated each frame
    std::unordered_map<int, std::pair<int,int>> linkIdToAttrs;
    
    // Link ID registry (cleared each frame for stateless rendering)
    struct LinkKey { int srcAttr; int dstAttr; };
    struct LinkKeyHash { size_t operator()(const LinkKey& k) const noexcept { return ((size_t)k.srcAttr << 32) ^ (size_t)k.dstAttr; } };
    struct LinkKeyEq { bool operator()(const LinkKey& a, const LinkKey& b) const noexcept { return a.srcAttr==b.srcAttr && a.dstAttr==b.dstAttr; } };
    std::unordered_map<LinkKey, int, LinkKeyHash, LinkKeyEq> linkToId;
    int nextLinkId { 1000 };
    int getLinkId(int srcAttr, int dstAttr)
    {
        LinkKey k{ srcAttr, dstAttr };
        auto it = linkToId.find(k);
        if (it != linkToId.end()) return it->second;
        const int id = nextLinkId++;
        linkToId.emplace(k, id);
        return id;
    }

    // Cable inspector highlight state (updated once per frame after EndNodeEditor)
    juce::uint32 hoveredLinkSrcId { 0 };
    juce::uint32 hoveredLinkDstId { 0 };
    static constexpr juce::uint32 kOutputHighlightId = 0xFFFFFFFFu; // sentinel for main output node highlight
    int lastHoveredLinkId { -1 }; // cache inside-editor hovered link id for post-editor use

    // Positions to apply for specific node IDs on the next render (grid space)
    std::unordered_map<int, ImVec2> pendingNodePositions;
    // Screen-space positions queued for just-created nodes (converted after draw)
    std::unordered_map<int, ImVec2> pendingNodeScreenPositions;
    // Sizes to apply for specific node IDs on the next render (for Comment nodes)
    std::unordered_map<int, ImVec2> pendingNodeSizes;

    // Cable inspector rolling stats (last N seconds) for quick visual validation
    struct ChannelHistory { std::deque<std::pair<double,float>> samples; };
    std::map<std::pair<juce::uint32,int>, ChannelHistory> inspectorHistory; // key: (logicalId, channel)
    float inspectorWindowSeconds { 5.0f };

    // --- NEW STATE FOR CABLE SPLITTING ---
    // Stores the attribute ID of the pin we are splitting from.
    // -1 means no split operation is active.
    int splittingFromAttrId = -1;

    // A map to cache the screen position of every pin attribute ID each frame.
    // This is a necessary workaround as ImNodes doesn't provide a public API
    // to get a pin's position by its ID.
    std::unordered_map<int, ImVec2> attrPositions;


    // UI state / hover
    int lastHoveredNodeId { -1 };
    bool isDraggingNode { false };
    bool snapshotAfterEditor { false }; // arm when action requires node to exist (add/duplicate)
    // zoom/pan disabled

    // --- Undo/Redo (module ops) ---
    struct Snapshot
    {
        juce::MemoryBlock synthState;
        juce::ValueTree   uiState;
    };
    std::vector<Snapshot> undoStack;
    std::vector<Snapshot> redoStack;
    void pushSnapshot();
    void restoreSnapshot (const Snapshot& s);
    
    // SampleLoader texture management (use JUCE OpenGLTexture to avoid raw GL includes)
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> sampleLoaderTextureIds;
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> visionModuleTextures;
    
    // Accessor for modules that need to render their own preview with interaction
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>>& getVisionModuleTextures() { return visionModuleTextures; }

    // Preset status tracking
    juce::File currentPresetFile;  // Full file path for save operations
    bool isPatchDirty { false };
    
    // Background save/load operations
    std::atomic<bool> isSaveInProgress { false }; // Debouncing flag for save operations
    juce::ThreadPool threadPool { 2 };

    // Help window
    bool showShortcutsWindow { false };

    // Shortcut debounce
    bool mixerShortcutCooldown { false };
    bool insertNodeShortcutCooldown { false };
    bool showInsertNodePopup { false };
    bool showDebugMenu { false };
    bool showMidiDeviceManager { false };
    int pendingInsertLinkId { -1 };
    
    // Probe tool state
    bool isProbeModeActive { false };
    bool showProbeScope { true };
    
    // Insert node on link state
    struct LinkInfo
    {
        int linkId = -1;
        bool isMod = false;
        // For Audio links:
        PinID srcPin;
        PinID dstPin;
        // For Mod links:
        juce::uint32 srcLogicalId;
        int srcChan;
        juce::uint32 dstLogicalId;
        juce::String paramId;
    };
    LinkInfo linkToInsertOn;
    
    // Mute/Bypass state management (non-destructive)
    struct MutedNodeState {
        std::vector<ModularSynthProcessor::ConnectionInfo> incomingConnections;
        std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
    };
    std::map<juce::uint32, MutedNodeState> mutedNodeStates;
    
    void muteNodeSilent(juce::uint32 logicalId);  // Store mute state without modifying graph (for loading presets)
    void muteNode(juce::uint32 logicalId);
    void unmuteNode(juce::uint32 logicalId);
    void handleMuteToggle();

    // Copy/Paste settings clipboard
    juce::ValueTree nodeSettingsClipboard;
    juce::String clipboardModuleType;

    // Helper functions
    void insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position);
    void insertNodeOnLinkStereo(const juce::String& nodeType, const LinkInfo& linkLeft, const LinkInfo& linkRight, const ImVec2& position);
    juce::File findPresetsDirectory();

    // --- NEW: Handler for node chaining shortcut ---
    void handleNodeChaining();

    // --- NEW: Handlers for color-coded chaining ---
    void handleColorCodedChaining(PinDataType targetType);
    std::vector<AudioPin> getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType);
    
    // --- Recorder Output Shortcut ---
    void handleRecordOutput();
    
    // --- Unified Preset Loading ---
    void loadPresetFromFile(const juce::File& file);
    void mergePresetFromFile(const juce::File& file, ImVec2 dropPosition);
    
    // --- Meta Module (Sub-Patching) Support ---
    void handleCollapseToMetaModule();
    
    // --- Module Category Color Coding ---
    enum class ModuleCategory { Source, Effect, Modulator, Utility, Seq, MIDI, Analysis, TTS_Voice, Special_Exp, OpenCV, Sys, Comment, Plugin };
    ModuleCategory getModuleCategory(const juce::String& moduleType);
    unsigned int getImU32ForCategory(ModuleCategory category, bool hovered = false);
    
    // --- Quick Add Menu ---
    std::map<juce::String, std::pair<const char*, const char*>> getModuleRegistry();
    std::vector<std::pair<juce::String, const char*>> getModuleDescriptions();
    
    // --- VST Plugin Support ---
    void addPluginModules();
    
    // --- Global GPU/CPU Settings ---
    static bool getGlobalGpuEnabled() { return s_globalGpuEnabled; }
    static void setGlobalGpuEnabled(bool enabled) { s_globalGpuEnabled = enabled; }
    
private:
    static bool s_globalGpuEnabled; // Global preference for GPU acceleration
};


================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.cpp
================================================================================


#include "ImGuiNodeEditorComponent.h"
#include "PinDatabase.h"
#include "SavePresetJob.h"
#include "NotificationManager.h"

#include <imgui.h>
#include <imnodes.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <unordered_map>
#include <unordered_set>
#include <cstdint>
#include <algorithm>

// ============================================================================
// Global GPU/CPU Settings (default: GPU enabled for best performance)
// ============================================================================
bool ImGuiNodeEditorComponent::s_globalGpuEnabled = true;
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/modules/AudioInputModuleProcessor.h"
#include "../audio/modules/AttenuverterModuleProcessor.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/RandomModuleProcessor.h"
#include "../audio/modules/ValueModuleProcessor.h"
#include "../audio/modules/SampleLoaderModuleProcessor.h"
#include "../audio/modules/MIDIPlayerModuleProcessor.h"
#include "../audio/modules/PolyVCOModuleProcessor.h"
#include "../audio/modules/TrackMixerModuleProcessor.h"
#include "../audio/modules/MathModuleProcessor.h"
#include "../audio/modules/StepSequencerModuleProcessor.h"
#include "../audio/modules/MultiSequencerModuleProcessor.h"
#include "../audio/modules/StrokeSequencerModuleProcessor.h"
#include "../audio/modules/AnimationModuleProcessor.h"
#include "../audio/modules/TempoClockModuleProcessor.h"
#include "../audio/modules/WebcamLoaderModule.h"
#include "../audio/modules/VideoFileLoaderModule.h"
#include "../audio/modules/MovementDetectorModule.h"
#include "../audio/modules/HumanDetectorModule.h"
#include "../audio/modules/PoseEstimatorModule.h"
#include "../audio/modules/ColorTrackerModule.h"
#include "../audio/modules/ContourDetectorModule.h"
#include "../audio/modules/SemanticSegmentationModule.h"
#include "../audio/modules/ObjectDetectorModule.h"
#include "../audio/modules/HandTrackerModule.h"
#include "../audio/modules/FaceTrackerModule.h"
#include "../audio/modules/VideoFXModule.h"
#include "../audio/modules/CropVideoModule.h"
#include "../audio/modules/MapRangeModuleProcessor.h"
#include "../audio/modules/LagProcessorModuleProcessor.h"
#include "../audio/modules/DeCrackleModuleProcessor.h"
#include "../audio/modules/GraphicEQModuleProcessor.h"
#include "../audio/modules/FrequencyGraphModuleProcessor.h"
#include "../audio/modules/ChorusModuleProcessor.h"
#include "../audio/modules/PhaserModuleProcessor.h"
#include "../audio/modules/CompressorModuleProcessor.h"
#include "../audio/modules/RecordModuleProcessor.h"
#include "../audio/modules/CommentModuleProcessor.h"
#include "../audio/modules/LimiterModuleProcessor.h"
#include "../audio/modules/GateModuleProcessor.h"
#include "../audio/modules/DriveModuleProcessor.h"
#include "../audio/modules/VstHostModuleProcessor.h"
// #include "../audio/modules/SnapshotSequencerModuleProcessor.h"  // Commented out - causing build errors
#include "../audio/modules/MIDICVModuleProcessor.h"
#include "../audio/modules/ScopeModuleProcessor.h"
#include "../audio/modules/MetaModuleProcessor.h"
#include "../audio/modules/InletModuleProcessor.h"
#include "../audio/modules/OutletModuleProcessor.h"
#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include <juce_audio_processors/juce_audio_processors.h>
#include <imgui_impl_juce/imgui_impl_juce.h>
#include <backends/imgui_impl_opengl2.h>
#include <juce_opengl/juce_opengl.h>

#define NODE_DEBUG 1

// --- Module Descriptions for Tooltips ---
static const char* toString(PinDataType t)
{
    switch (t)
    {
        case PinDataType::Audio: return "Audio";
        case PinDataType::CV: return "CV";
        case PinDataType::Gate: return "Gate";
        case PinDataType::Raw: return "Raw";
        case PinDataType::Video: return "Video";
        default: return "Unknown";
    }
}

#define LOG_LINK(msg) do { if (NODE_DEBUG) juce::Logger::writeToLog("[LINK] " + juce::String(msg)); } while(0)

struct Range { float min; float max; };

// Forward declarations
class ModularSynthProcessor;
class RandomModuleProcessor;
class ValueModuleProcessor;
class StepSequencerModuleProcessor;
class MapRangeModuleProcessor;

// Helper methods for MapRange configuration
ImGuiNodeEditorComponent::Range getSourceRange(const ImGuiNodeEditorComponent::PinID& srcPin, ModularSynthProcessor* synth)
{
    if (synth == nullptr) return {0.0f, 1.0f};
    
    auto* module = synth->getModuleForLogical(srcPin.logicalId);
    if (auto* random = dynamic_cast<RandomModuleProcessor*>(module))
    {
        auto& ap = random->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* value = dynamic_cast<ValueModuleProcessor*>(module))
    {
        auto& ap = value->getAPVTS();
        float min = 0.0f, max = 1.0f;
        if (auto* minParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("min")))
            min = minParam->get();
        if (auto* maxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("max")))
            max = maxParam->get();
        return {min, max};
    }
    else if (auto* stepSeq = dynamic_cast<StepSequencerModuleProcessor*>(module))
    {
        // StepSequencer outputs CV range
        return {0.0f, 1.0f};
    }
    // Fallback: estimate from source's lastOutputValues
    // TODO: implement fallback estimation
    return {0.0f, 1.0f};
}

void configureMapRangeFor(PinDataType srcType, PinDataType dstType, MapRangeModuleProcessor& m, ImGuiNodeEditorComponent::Range inRange)
{
    auto& ap = m.getAPVTS();
    
    // Set input range
    if (auto* inMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin")))
        *inMinParam = inRange.min;
    if (auto* inMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax")))
        *inMaxParam = inRange.max;
    
    // Set output range based on destination type
    if (dstType == PinDataType::Audio)
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = -1.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
    else // CV or Gate
    {
        if (auto* outMinParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin")))
            *outMinParam = 0.0f;
        if (auto* outMaxParam = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax")))
            *outMaxParam = 1.0f;
    }
}




ImGuiNodeEditorComponent::ImGuiNodeEditorComponent(juce::AudioDeviceManager& dm)
    : deviceManager(dm)
{
    juce::Logger::writeToLog("ImGuiNodeEditorComponent constructor starting...");
    
    // --- THIS WILL BE THE SMOKING GUN ---
    juce::Logger::writeToLog("About to populate pin database...");
    populatePinDatabase(); // Initialize the pin database for color coding
    juce::Logger::writeToLog("Pin database populated.");
    
    glContext.setRenderer (this);
    glContext.setContinuousRepainting (true);
    glContext.setComponentPaintingEnabled (false);
    glContext.attachTo (*this);
    setWantsKeyboardFocus (true);
    
    // Initialize browser paths (load from saved settings or use defaults)
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        // Load the last used paths, providing defaults if they don't exist
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultPresetPath = appFile.getParentDirectory().getChildFile("Presets");
        juce::File defaultSamplePath = appFile.getParentDirectory().getChildFile("Samples");

        m_presetScanPath = juce::File(props->getValue("presetScanPath", defaultPresetPath.getFullPathName()));
        m_sampleScanPath = juce::File(props->getValue("sampleScanPath", defaultSamplePath.getFullPathName()));
    }
    
    // Create these directories if they don't already exist
    if (!m_presetScanPath.exists())
        m_presetScanPath.createDirectory();
    if (!m_sampleScanPath.exists())
        m_sampleScanPath.createDirectory();
    
    juce::Logger::writeToLog("[UI] Preset path set to: " + m_presetScanPath.getFullPathName());
    juce::Logger::writeToLog("[UI] Sample path set to: " + m_sampleScanPath.getFullPathName());
    
    // --- MIDI BROWSER PATH INITIALIZATION ---
    if (auto* props = PresetCreatorApplication::getApp().getProperties())
    {
        auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
        juce::File defaultMidiPath = appFile.getParentDirectory().getChildFile("audio").getChildFile("MIDI");
        m_midiScanPath = juce::File(props->getValue("midiScanPath", defaultMidiPath.getFullPathName()));
    }
    if (!m_midiScanPath.exists())
        m_midiScanPath.createDirectory();
    juce::Logger::writeToLog("[UI] MIDI path set to: " + m_midiScanPath.getFullPathName());
    // --- END OF MIDI INITIALIZATION ---
}

ImGuiNodeEditorComponent::~ImGuiNodeEditorComponent()
{
    glContext.detach();
}

void ImGuiNodeEditorComponent::paint (juce::Graphics& g)
{
    juce::ignoreUnused (g);
}

void ImGuiNodeEditorComponent::resized()
{
    juce::Logger::writeToLog ("resized: " + juce::String (getWidth()) + "x" + juce::String (getHeight()));
}

// Input handled by imgui_juce backend

void ImGuiNodeEditorComponent::newOpenGLContextCreated()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: newOpenGLContextCreated()");
    // Create ImGui context
    imguiContext = ImGui::CreateContext();
    imguiIO = &ImGui::GetIO();
    ImGui::StyleColorsDark();

    // --- FONT LOADING FOR CHINESE CHARACTERS ---
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->AddFontDefault(); // Load default English font

    // Define the path to your new font file
    auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
    auto fontFile = appFile.getParentDirectory().getChildFile("../../Source/assets/NotoSansSC-VariableFont_wght.ttf");

    if (fontFile.existsAsFile())
    {
        ImFontConfig config;
        config.MergeMode = true; // IMPORTANT: This merges the new font into the default one
        config.PixelSnapH = true;

        // Define the character ranges to load for Chinese
        static const ImWchar ranges[] = { 0x4e00, 0x9fbf, 0, }; // Basic CJK Unified Ideographs

        io.Fonts->AddFontFromFileTTF(fontFile.getFullPathName().toRawUTF8(), 16.0f, &config, ranges);
        juce::Logger::writeToLog("ImGuiNodeEditor: Chinese font loaded successfully");
    }
    else
    {
        juce::Logger::writeToLog("ImGuiNodeEditor: WARNING - Chinese font not found at: " + fontFile.getFullPathName());
    }
    
    // --- END OF FONT LOADING ---

    // imgui_juce backend handles key mapping internally (new IO API)

    // Setup JUCE platform backend and OpenGL2 renderer backend
    ImGui_ImplJuce_Init (*this, glContext);
    ImGui_ImplOpenGL2_Init();
    
    // Build fonts after renderer is initialized
    io.Fonts->Build();

    // Setup imnodes
    ImNodes::SetImGuiContext(ImGui::GetCurrentContext());
    editorContext = ImNodes::CreateContext();
    
    // Enable grid snapping
    ImNodes::GetStyle().GridSpacing = 64.0f;
    
    // Optional ergonomics: Alt = pan, Ctrl = detach link
    {
        auto& ioNodes = ImNodes::GetIO();
        auto& ioImgui = ImGui::GetIO();
        ioNodes.EmulateThreeButtonMouse.Modifier = &ioImgui.KeyAlt;
        ioNodes.LinkDetachWithModifierClick.Modifier = &ioImgui.KeyCtrl;
    }
    juce::Logger::writeToLog("ImGuiNodeEditor: ImNodes context created");
}

void ImGuiNodeEditorComponent::openGLContextClosing()
{
    juce::Logger::writeToLog("ImGuiNodeEditor: openGLContextClosing()");
    ImNodes::DestroyContext(editorContext);
    editorContext = nullptr;
    ImGui_ImplOpenGL2_Shutdown();
    ImGui_ImplJuce_Shutdown();
    ImGui::DestroyContext (imguiContext);
    imguiContext = nullptr; imguiIO = nullptr;
}

void ImGuiNodeEditorComponent::renderOpenGL()
{
    if (imguiContext == nullptr)
        return;

    ImGui::SetCurrentContext (imguiContext);

    // Clear background
    juce::OpenGLHelpers::clear (juce::Colours::darkgrey);

    // Ensure IO is valid and configured each frame (size, delta time, DPI scale, fonts)
    ImGuiIO& io = ImGui::GetIO();
    const float scale = (float) glContext.getRenderingScale();
    io.DisplaySize = ImVec2 ((float) getWidth(), (float) getHeight());
    io.DisplayFramebufferScale = ImVec2 (scale, scale);

    // imgui_juce will queue and apply key/mouse events; avoid manual KeysDown edits that break internal asserts
    io.MouseDrawCursor = false;

    // Mouse input comes via backend listeners; avoid overriding io.MousePos here

    const double nowMs = juce::Time::getMillisecondCounterHiRes();
    if (lastTime <= 0.0)
        lastTime = nowMs;
    const double dtMs = nowMs - lastTime;
    lastTime = nowMs;
    io.DeltaTime = (dtMs > 0.0 ? (float) (dtMs / 1000.0) : 1.0f / 60.0f);

    // Zoom/pan disabled: use default font scale and editor panning

    // Start a new frame for both backends
    ImGui_ImplOpenGL2_NewFrame();
    ImGui_ImplJuce_NewFrame();

    ImGui::NewFrame();
    // Demo is hidden by default; toggle can be added later if needed
    renderImGui();
    ImGui::Render();
    auto* dd = ImGui::GetDrawData();
    // Render via OpenGL2 backend
    ImGui_ImplOpenGL2_RenderDrawData (dd);
}

void ImGuiNodeEditorComponent::renderImGui()
{
    // Render notification system (must be called early to appear on top)
    NotificationManager::render();
    
    static int frameCounter = 0;
    frameCounter++;

    // ========================= THE DEFINITIVE FIX =========================
    //
    // Rebuild the audio graph at the START of the frame if a change is pending.
    // This ensures that the synth model is in a consistent state BEFORE we try
    // to draw the UI, eliminating the "lost frame" that caused nodes to jump.
    //
    if (graphNeedsRebuild.load())
    {
        juce::Logger::writeToLog("[GraphSync] Rebuild flag is set. Committing changes now...");
        if (synth)
        {
            synth->commitChanges();
        }
        graphNeedsRebuild = false; // Reset the flag immediately after committing.
        
        // CRITICAL: Invalidate hover state to prevent cable inspector from accessing
        // modules that were just deleted/recreated during commitChanges()
        lastHoveredLinkId = -1;
        lastHoveredNodeId = -1;
        hoveredLinkSrcId = 0;
        hoveredLinkDstId = 0;
        
        juce::Logger::writeToLog("[GraphSync] Graph rebuild complete.");
    }
    // ========================== END OF FIX ==========================

    // Frame start
    
    // --- Stateless Frame Rendering ---
    // Clear link registries at start of each frame for fully stateless rendering.
    // Pin IDs are now generated directly via bitmasking, no maps needed.
    linkIdToAttrs.clear();
    linkToId.clear();
    nextLinkId = 1000;

    // Handle F1 key for shortcuts window
    if (ImGui::IsKeyPressed(ImGuiKey_F1, false))
    {
        showShortcutsWindow = !showShortcutsWindow;
    }

    // Basic docking-like two-panels layout
    ImGui::SetNextWindowPos (ImVec2 (0, 0), ImGuiCond_Always);
    ImGui::SetNextWindowSize (ImVec2 ((float) getWidth(), (float) getHeight()), ImGuiCond_Always);
    ImGui::Begin ("Preset Creator", nullptr,
                  ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_MenuBar);

    // --- DEFINITIVE STATUS OVERLAY ---
    // This code creates the small, semi-transparent window for the preset status.
    const float sidebarWidth = 260.0f;
    const float menuBarHeight = ImGui::GetFrameHeight();
    const float padding = 10.0f;

    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(0.5f);
    ImGui::Begin("Preset Status Overlay", nullptr, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_AlwaysAutoResize);

    // Display the preset name or "Unsaved Patch"
    if (currentPresetFile.getFullPathName().isNotEmpty()) { // Check if the file path is valid
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8()); // Display just the filename
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    // Display the "Saved" or "Edited" status
    if (isPatchDirty) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");
    } else {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
    }

    ImGui::End();
    // --- END OF OVERLAY ---

    
    // === PROBE SCOPE OVERLAY ===
    if (synth != nullptr && showProbeScope)
    {
        if (auto* scope = dynamic_cast<ScopeModuleProcessor*>(synth->getProbeScopeProcessor()))
        {
            ImGui::SetNextWindowPos(ImVec2((float)getWidth() - 270.0f, menuBarHeight + padding), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowSize(ImVec2(260, 180), ImGuiCond_FirstUseEver);
            ImGui::SetNextWindowBgAlpha(0.85f);
            
            if (ImGui::Begin("üî¨ Probe Scope", &showProbeScope, ImGuiWindowFlags_NoFocusOnAppearing))
            {
                ImGui::Text("Signal Probe");
                ImGui::Separator();
                
                // Get scope buffer
                const auto& buffer = scope->getScopeBuffer();
                
                if (buffer.getNumSamples() > 0)
                {
                    // Create a simple waveform display
                    const int numSamples = buffer.getNumSamples();
                    const float* samples = buffer.getReadPointer(0);
                    
                    // Calculate min/max for this buffer
                    float minVal = 0.0f, maxVal = 0.0f;
                    for (int i = 0; i < numSamples; ++i)
                    {
                        minVal = juce::jmin(minVal, samples[i]);
                        maxVal = juce::jmax(maxVal, samples[i]);
                    }
                    
                    // Display stats
                    ImGui::Text("Min: %.3f  Max: %.3f", minVal, maxVal);
                    ImGui::Text("Peak: %.3f", juce::jmax(std::abs(minVal), std::abs(maxVal)));
                    
                    // Draw waveform with explicit width to avoid node expansion feedback
                    ImVec2 plotSize = ImVec2(ImGui::GetContentRegionAvail().x, 100);
                    ImGui::PlotLines("##Waveform", samples, numSamples, 0, nullptr, -1.0f, 1.0f, plotSize);
                    
                    // Button to clear probe connection
                    if (ImGui::Button("Clear Probe"))
                    {
                        synth->clearProbeConnection();
                    }
                }
                else
                {
                    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No signal probed");
                    ImGui::Text("Right-click > Probe Signal");
                    ImGui::Text("Then click any output pin");
                }
            }
            ImGui::End();
        }
    }
    // === END OF PROBE SCOPE OVERLAY ===

    // Clean up textures for deleted sample loaders
    if (synth != nullptr)
    {
        auto infos = synth->getModulesInfo();
        std::unordered_set<int> activeSampleLoaderIds;
        for (const auto& info : infos)
        {
            if (info.second.equalsIgnoreCase("sample loader"))
            {
                activeSampleLoaderIds.insert((int)info.first);
            }
        }

        for (auto it = sampleLoaderTextureIds.begin(); it != sampleLoaderTextureIds.end(); )
        {
            if (activeSampleLoaderIds.find(it->first) == activeSampleLoaderIds.end())
            {
                if (it->second)
                    it->second.reset();
                it = sampleLoaderTextureIds.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    // ADD THIS BLOCK:
    if (ImGui::BeginMainMenuBar())
    {
        if (ImGui::BeginMenu("File"))
        {
            if (ImGui::MenuItem("Save Preset", "Ctrl+S")) { 
                if (currentPresetFile.existsAsFile()) {
                    savePresetToFile(currentPresetFile);
                } else {
                    startSaveDialog();
                }
            }
            if (ImGui::MenuItem("Save Preset As...", "Ctrl+Alt+S")) { startSaveDialog(); }
            if (ImGui::MenuItem("Load Preset", "Ctrl+O")) { startLoadDialog(); }
            
            ImGui::Separator();
            
            // Plugin scanning menu item
            if (ImGui::MenuItem("Scan for Plugins..."))
            {
                // Get the application instance to access plugin management
                auto& app = PresetCreatorApplication::getApp();
                auto& formatManager = app.getPluginFormatManager();
                auto& knownPluginList = app.getKnownPluginList();

                // 1. Find the VST3 format
                juce::VST3PluginFormat* vst3Format = nullptr;
                for (int i = 0; i < formatManager.getNumFormats(); ++i)
                {
                    if (auto* format = formatManager.getFormat(i); format->getName() == "VST3")
                    {
                        vst3Format = dynamic_cast<juce::VST3PluginFormat*>(format);
                        break;
                    }
                }

                if (vst3Format != nullptr)
                {
                    // 2. Define the specific folder to scan
                    juce::File vstDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile)
                                            .getParentDirectory().getChildFile("VST");

                    juce::FileSearchPath searchPath;
                    if (vstDir.isDirectory())
                    {
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Starting scan in: " + vstDir.getFullPathName());
                    }
                    else
                    {
                        vstDir.createDirectory();
                        searchPath.add(vstDir);
                        juce::Logger::writeToLog("[VST Scan] Created VST directory at: " + vstDir.getFullPathName());
                    }

                    // 3. Scan for plugins
                    auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                        .getChildFile(app.getApplicationName());
                    
                    juce::PluginDirectoryScanner scanner(knownPluginList, *vst3Format, searchPath, true,
                                                         appDataDir.getChildFile("dead_plugins.txt"), true);

                    // 4. Perform the scan
                    juce::String pluginBeingScanned;
                    int numFound = 0;
                    while (scanner.scanNextFile(true, pluginBeingScanned))
                    {
                        juce::Logger::writeToLog("[VST Scan] Scanning: " + pluginBeingScanned);
                        ++numFound;
                    }
                    
                    juce::Logger::writeToLog("[VST Scan] Scan complete. Found " + juce::String(numFound) + " plugin(s).");
                    juce::Logger::writeToLog("[VST Scan] Total plugins in list: " + juce::String(knownPluginList.getNumTypes()));
                    
                    // 5. Save the updated plugin list
                    auto pluginListFile = appDataDir.getChildFile("known_plugins.xml");
                    if (auto pluginListXml = knownPluginList.createXml())
                    {
                        if (pluginListXml->writeTo(pluginListFile))
                        {
                            juce::Logger::writeToLog("[VST Scan] Saved plugin list to: " + pluginListFile.getFullPathName());
                        }
                    }
                }
                else
                {
                    juce::Logger::writeToLog("[VST Scan] ERROR: VST3 format not found in format manager.");
                }
            }
            
            ImGui::EndMenu();
        }
        
        // <<< ADD THIS ENTIRE "Edit" MENU BLOCK >>>
        if (ImGui::BeginMenu("Edit"))
        {
            if (ImGui::MenuItem("Clear Output Connections")) 
            {
                if (synth != nullptr)
                {
                    synth->clearOutputConnections();
                    pushSnapshot(); // Make the action undoable
                }
            }

            // <<< ADD THIS ENTIRE BLOCK >>>
            bool isNodeSelected = (ImNodes::NumSelectedNodes() > 0);
            if (ImGui::MenuItem("Clear Selected Node Connections", nullptr, false, isNodeSelected))
            {
                if (synth != nullptr)
                {
                    std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                    ImNodes::GetSelectedNodes(selectedNodeIds.data());
                    if (!selectedNodeIds.empty())
                    {
                        // Act on the first selected node
                        juce::uint32 logicalId = (juce::uint32)selectedNodeIds[0];
                        auto nodeId = synth->getNodeIdForLogical(logicalId);
                        if (nodeId.uid != 0)
                        {
                            synth->clearConnectionsForNode(nodeId);
                            pushSnapshot(); // Make the action undoable
                        }
                    }
                }
            }
            // <<< END OF BLOCK >>>

            ImGui::EndMenu();
        }
        
        // ========================================================================
        // SETTINGS MENU - Global GPU/CPU Configuration, Audio, and MIDI
        // ========================================================================
        if (ImGui::BeginMenu("Settings"))
        {
            // Audio Settings
            if (ImGui::MenuItem("Audio Settings..."))
            {
                if (onShowAudioSettings)
                    onShowAudioSettings();
            }
            
            // MIDI Device Manager
            if (ImGui::MenuItem("MIDI Device Manager..."))
            {
                showMidiDeviceManager = !showMidiDeviceManager;
            }
            
            ImGui::Separator();
            
            #if WITH_CUDA_SUPPORT
                bool gpuEnabled = getGlobalGpuEnabled();
                if (ImGui::Checkbox("Enable GPU Acceleration (CUDA)", &gpuEnabled))
                {
                    setGlobalGpuEnabled(gpuEnabled);
                    juce::Logger::writeToLog("[Settings] Global GPU: " + juce::String(gpuEnabled ? "ENABLED" : "DISABLED"));
                }
                
                ImGui::TextDisabled("This setting controls all vision nodes:");
                ImGui::TextDisabled("  - Pose Estimator");
                ImGui::TextDisabled("  - Hand Tracker");
                ImGui::TextDisabled("  - Face Tracker");
                ImGui::TextDisabled("  - Object Detector");
                ImGui::TextDisabled("  - Human Detector");
                ImGui::TextDisabled("  - Color Tracker");
                ImGui::TextDisabled("  - Contour Detector");
                ImGui::TextDisabled("  - Movement Detector");
                ImGui::TextDisabled("  - Semantic Segmentation");
                
                ImGui::Separator();
                
                // Show CUDA device info
                #if WITH_CUDA_SUPPORT
                    int deviceCount = cv::cuda::getCudaEnabledDeviceCount();
                    if (deviceCount > 0)
                    {
                        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "CUDA Available");
                        ImGui::Text("GPU Devices: %d", deviceCount);
                    }
                    else
                    {
                        ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "CUDA compiled but no devices found");
                    }
                #endif
            #else
                ImGui::TextDisabled("GPU Acceleration: Not Compiled");
                ImGui::TextDisabled("Rebuild with CUDA support to enable");
            #endif
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Actions"))
        {
            // This item should only be enabled if at least one node is selected
            bool anyNodesSelected = ImNodes::NumSelectedNodes() > 0;
            bool multipleNodesSelected = ImNodes::NumSelectedNodes() > 1;
            
            if (ImGui::MenuItem("Connect Selected to Track Mixer", nullptr, false, anyNodesSelected))
            {
                handleConnectSelectedToTrackMixer();
            }
            
            // Meta Module: Collapse selected nodes into a reusable sub-patch
            if (ImGui::MenuItem("Collapse to Meta Module", "Ctrl+Shift+M", false, multipleNodesSelected))
            {
                handleCollapseToMetaModule();
            }
            
            if (ImGui::MenuItem("Record Output", "Ctrl+R"))
            {
                handleRecordOutput();
            }
            
            if (ImGui::MenuItem("Beautify Layout", "Ctrl+B"))
            {
                handleBeautifyLayout();
            }
            
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Recording"))
        {
            if (synth != nullptr)
            {
                bool isAnyRecording = synth->isAnyModuleRecording();
                const char* label = isAnyRecording ? "Stop All Recordings" : "Start All Recordings";
                if (ImGui::MenuItem(label))
                {
                    if (isAnyRecording)
                    {
                        synth->stopAllRecorders();
                    }
                    else
                    {
                        synth->startAllRecorders();
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Generate"))
        {
            if (ImGui::MenuItem("Randomize Patch", "Ctrl+P")) { handleRandomizePatch(); }
            if (ImGui::MenuItem("Randomize Connections", "Ctrl+M")) { handleRandomizeConnections(); }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Insert Node"))
        {
            bool isNodeSelected = (selectedLogicalId != 0);
            
            if (ImGui::BeginMenu("Effects", isNodeSelected))
            {
                if (ImGui::MenuItem("VCF")) { insertNodeBetween("vcf"); }
                if (ImGui::MenuItem("Delay")) { insertNodeBetween("delay"); }
                if (ImGui::MenuItem("Reverb")) { insertNodeBetween("reverb"); }
                if (ImGui::MenuItem("Chorus")) { insertNodeBetween("chorus"); }
                if (ImGui::MenuItem("Phaser")) { insertNodeBetween("phaser"); }
                if (ImGui::MenuItem("Compressor")) { insertNodeBetween("compressor"); }
                if (ImGui::MenuItem("Limiter")) { insertNodeBetween("limiter"); }
                if (ImGui::MenuItem("Noise Gate")) { insertNodeBetween("gate"); }
                if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
                if (ImGui::MenuItem("Graphic EQ")) { insertNodeBetween("graphic_eq"); }
                if (ImGui::MenuItem("Waveshaper")) { insertNodeBetween("waveshaper"); }
                if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); }
                if (ImGui::MenuItem("Granulator")) { insertNodeBetween("granulator"); }
                if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic_shaper"); }
                if (ImGui::MenuItem("Time/Pitch Shifter")) { insertNodeBetween("timepitch"); }
                if (ImGui::MenuItem("De-Crackle")) { insertNodeBetween("de_crackle"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Modulators", isNodeSelected))
            {
                if (ImGui::MenuItem("LFO")) { insertNodeBetween("lfo"); }
                if (ImGui::MenuItem("ADSR")) { insertNodeBetween("adsr"); }
                if (ImGui::MenuItem("Random")) { insertNodeBetween("random"); }
                if (ImGui::MenuItem("S&H")) { insertNodeBetween("s_and_h"); }
                if (ImGui::MenuItem("Function Generator")) { insertNodeBetween("function_generator"); }
                if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping_oscillator"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Utilities & Logic", isNodeSelected))
            {
                if (ImGui::MenuItem("VCA")) { insertNodeBetween("vca"); }
                if (ImGui::MenuItem("Mixer")) { insertNodeBetween("mixer"); }
                if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("cv_mixer"); }
                if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("attenuverter"); }
                if (ImGui::MenuItem("Lag Processor")) { insertNodeBetween("lag_processor"); }
                if (ImGui::MenuItem("Math")) { insertNodeBetween("math"); }
                if (ImGui::MenuItem("Map Range")) { insertNodeBetween("map_range"); }
                if (ImGui::MenuItem("Quantizer")) { insertNodeBetween("quantizer"); }
                if (ImGui::MenuItem("Rate")) { insertNodeBetween("rate"); }
                if (ImGui::MenuItem("Comparator")) { insertNodeBetween("comparator"); }
                if (ImGui::MenuItem("Logic")) { insertNodeBetween("logic"); }
                if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("sequential_switch"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Computer Vision", isNodeSelected))
            {
                if (ImGui::MenuItem("Video FX")) { insertNodeBetween("video_fx"); }
                if (ImGui::MenuItem("Crop Video")) { insertNodeBetween("crop_video"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("TTS", isNodeSelected))
            {
                if (ImGui::MenuItem("TTS Performer")) { insertNodeBetween("tts_performer"); }
                if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("vocal_tract_filter"); }
                ImGui::EndMenu();
            }
            
            if (ImGui::BeginMenu("Analysis", isNodeSelected))
            {
                if (ImGui::MenuItem("Scope")) { insertNodeBetween("scope"); }
                if (ImGui::MenuItem("Frequency Graph")) { insertNodeBetween("frequency_graph"); }
                ImGui::EndMenu();
            }
            
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("Inspector"))
        {
            ImGui::SliderFloat("Window (s)", &inspectorWindowSeconds, 0.5f, 20.0f, "%.1f s");
            ImGui::EndMenu();
        }
        
        // === DEBUG MENU ===
        if (ImGui::BeginMenu("Debug"))
        {
            if (ImGui::MenuItem("Show System Diagnostics", "Ctrl+Shift+D")) 
            {
                showDebugMenu = !showDebugMenu;
            }
            
            
            if (ImGui::MenuItem("Log System State"))
            {
                if (synth != nullptr)
                {
                    juce::Logger::writeToLog("=== SYSTEM DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getSystemDiagnostics());
                }
            }
            
            if (ImGui::MenuItem("Log Selected Module Diagnostics"))
            {
                if (synth != nullptr && selectedLogicalId != 0)
                {
                    juce::Logger::writeToLog("=== MODULE DIAGNOSTICS ===");
                    juce::Logger::writeToLog(synth->getModuleDiagnostics(selectedLogicalId));
                }
            }
            
            ImGui::EndMenu();
        }
        
        // === TRANSPORT CONTROLS ===
        if (synth != nullptr)
        {
            // Get current transport state
            auto transportState = synth->getTransportState();
            
            // Add some spacing before transport controls
            ImGui::Separator();
            ImGui::Spacing();
            
            // Play/Pause button
            if (transportState.isPlaying)
            {
                if (ImGui::Button("Pause"))
                    synth->setPlaying(false);
            }
            else
            {
                if (ImGui::Button("Play"))
                    synth->setPlaying(true);
            }
            
            ImGui::SameLine();
            
            // Stop button (resets position)
            if (ImGui::Button("Stop"))
            {
                synth->setPlaying(false);
                synth->resetTransportPosition();
            }
            
            ImGui::SameLine();
            
            // BPM control (greyed out if controlled by Tempo Clock module)
            float bpm = static_cast<float>(transportState.bpm);
            ImGui::SetNextItemWidth(80.0f);
            
            bool isControlled = transportState.isTempoControlledByModule.load();
            if (isControlled)
                ImGui::BeginDisabled();
                
            if (ImGui::DragFloat("BPM", &bpm, 0.1f, 20.0f, 999.0f, "%.1f"))
                synth->setBPM(static_cast<double>(bpm));
                
            if (isControlled)
            {
                ImGui::EndDisabled();
                if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
                {
                    ImGui::BeginTooltip();
                    ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                    ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Module Active");
                    ImGui::TextUnformatted("A Tempo Clock node with 'Sync to Host' disabled is controlling the global BPM.");
                    ImGui::PopTextWrapPos();
                    ImGui::EndTooltip();
                }
            }
            
            ImGui::SameLine();
            
            // Position display
            ImGui::Text("%.2f beats", transportState.songPositionBeats);
        }
        
        // === MULTI-MIDI DEVICE ACTIVITY INDICATOR ===
        ImGui::SameLine();
        ImGui::Separator();
        ImGui::SameLine();
        
        if (synth != nullptr)
        {
            auto activityState = synth->getMidiActivityState();
            
            if (activityState.deviceNames.empty())
            {
                // No MIDI devices connected
                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                ImGui::Text("MIDI: No Devices");
                ImGui::PopStyleColor();
            }
            else
            {
                ImGui::Text("MIDI:");
                ImGui::SameLine();
                
                // Display each device with active channels
                for (const auto& [deviceIndex, deviceName] : activityState.deviceNames)
                {
                    ImGui::SameLine();
                    
                    bool hasActivity = false;
                    if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                    {
                        const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                        for (bool active : channels)
                        {
                            if (active)
                            {
                                hasActivity = true;
                                break;
                            }
                        }
                    }
                    
                    // Abbreviated device name (max 12 chars)
                    juce::String abbrevName = deviceName;
                    if (abbrevName.length() > 12)
                        abbrevName = abbrevName.substring(0, 12) + "...";
                    
                    // Color: bright green if active, dim gray if inactive
                    if (hasActivity)
                        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255));
                    else
                        ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                    
                    ImGui::Text("[%s]", abbrevName.toRawUTF8());
                    ImGui::PopStyleColor();
                    
                    // Tooltip with full name and active channels
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("%s", deviceName.toRawUTF8());
                        ImGui::Separator();
                        
                        if (activityState.deviceChannelActivity.count(deviceIndex) > 0)
                        {
                            const auto& channels = activityState.deviceChannelActivity.at(deviceIndex);
                            ImGui::Text("Active Channels:");
                            juce::String activeChannels;
                            for (int ch = 0; ch < 16; ++ch)
                            {
                                if (channels[ch])
                                {
                                    if (activeChannels.isNotEmpty())
                                        activeChannels += ", ";
                                    activeChannels += juce::String(ch + 1);
                                }
                            }
                            if (activeChannels.isEmpty())
                                activeChannels = "None";
                            ImGui::Text("%s", activeChannels.toRawUTF8());
                        }
                        
                        ImGui::EndTooltip();
                    }
                }
            }
        }
        else
        {
            ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
            ImGui::Text("MIDI: ---");
            ImGui::PopStyleColor();
        }
        // === END OF MULTI-MIDI INDICATOR ===
        
        ImGui::EndMainMenuBar();
    }

    // --- PRESET STATUS OVERLAY ---
    ImGui::SetNextWindowPos(ImVec2(sidebarWidth + padding, menuBarHeight + padding));
    ImGui::SetNextWindowBgAlpha(0.7f);
    ImGui::Begin("Preset Status", nullptr, 
                 ImGuiWindowFlags_NoDecoration | 
                 ImGuiWindowFlags_NoMove | 
                 ImGuiWindowFlags_NoFocusOnAppearing | 
                 ImGuiWindowFlags_NoNav | 
                 ImGuiWindowFlags_AlwaysAutoResize);

    if (currentPresetFile.existsAsFile()) {
        ImGui::Text("Preset: %s", currentPresetFile.getFileName().toRawUTF8());
    } else {
        ImGui::Text("Preset: Unsaved Patch");
    }

    if (isPatchDirty) {
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Status: EDITED");
    } else {
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Status: SAVED");
    }

    ImGui::End();
    // --- END OF PRESET STATUS OVERLAY ---

    ImGui::Columns (2, nullptr, true);
    ImGui::SetColumnWidth (0, 260.0f);

    // Zoom removed

    // ADD THIS BLOCK:
    ImGui::Text("Browser");
    
    // Create a scrolling child window to contain the entire browser
    ImGui::BeginChild("BrowserScrollRegion", ImVec2(0, 0), true);
    
    // Helper lambda to recursively draw the directory tree for presets
    std::function<void(const PresetManager::DirectoryNode*)> drawPresetTree = 
        [&](const PresetManager::DirectoryNode* node)
    {
        if (!node || (node->presets.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawPresetTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw presets in this directory with drag-and-drop support
        for (const auto& preset : node->presets)
        {
            if (m_presetSearchTerm.isEmpty() || preset.name.containsIgnoreCase(m_presetSearchTerm))
            {
                // Draw the selectable item and capture its return value
                bool clicked = ImGui::Selectable(preset.name.toRawUTF8());

                // --- THIS IS THE FIX ---
                // Check if this item is the source of a drag operation
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload type and data (the preset's file path)
                    const juce::String path = preset.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_PRESET_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback while dragging
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Merge Preset: %s", preset.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // If a drag did NOT occur, and the item was clicked, load the preset
                else if (clicked)
                {
                    loadPresetFromFile(preset.file);
                }
                // --- END OF FIX ---
                
                // Tooltip (only shown when hovering, not dragging)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0) && preset.description.isNotEmpty())
                {
                    ImGui::BeginTooltip();
                    ImGui::TextUnformatted(preset.description.toRawUTF8());
                    if (!preset.tags.isEmpty())
                        ImGui::Text("Tags: %s", preset.tags.joinIntoString(", ").toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // Helper to push category colors (used for all module category headers)
    auto pushCategoryColor = [&](ModuleCategory cat) {
        ImU32 color = getImU32ForCategory(cat);
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        ImGui::PushStyleColor(ImGuiCol_Header, color);
        ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.2f, c.y*1.2f, c.z*1.2f, 1.0f)));
        ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::ColorConvertFloat4ToU32(ImVec4(c.x*1.4f, c.y*1.4f, c.z*1.4f, 1.0f)));
    };

    // === PRESET BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(218, 165, 32, 255)); // Gold
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(238, 185, 52, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(255, 205, 72, 255));
    bool presetsExpanded = ImGui::CollapsingHeader("Presets");
    ImGui::PopStyleColor(3);
    
    if (presetsExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_presetScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##presetpath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##preset"))
        {
            presetPathChooser = std::make_unique<juce::FileChooser>("Select Preset Directory", m_presetScanPath);
            presetPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_presetScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("presetScanPath", m_presetScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##preset"))
        {
            m_presetManager.clearCache();
            m_presetManager.scanDirectory(m_presetScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_presetSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##preset", searchBuf, sizeof(searchBuf)))
            m_presetSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical preset tree
        drawPresetTree(m_presetManager.getRootNode());
    }
    
    // Helper lambda to recursively draw the directory tree for samples
    std::function<void(const SampleManager::DirectoryNode*)> drawSampleTree = 
        [&](const SampleManager::DirectoryNode* node)
    {
        if (!node || (node->samples.empty() && node->subdirectories.empty())) return;

        // Draw subdirectories first
        for (const auto& subdir : node->subdirectories)
        {
            if (ImGui::TreeNode(subdir->name.toRawUTF8()))
            {
                drawSampleTree(subdir.get());
                ImGui::TreePop();
            }
        }
        
        // Then draw samples in this directory with drag-and-drop support
        for (const auto& sample : node->samples)
        {
            if (m_sampleSearchTerm.isEmpty() || sample.name.containsIgnoreCase(m_sampleSearchTerm))
            {
                // --- THIS IS THE HEROIC FIX ---

                // A. Draw the selectable item and capture its return value (which is true on mouse release).
                bool clicked = ImGui::Selectable(sample.name.toRawUTF8());

                // B. Check if this item is the source of a drag operation. This takes priority.
                if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                {
                    // Set the payload (the data we are transferring is the sample's file path).
                    const juce::String path = sample.file.getFullPathName();
                    const std::string pathStr = path.toStdString();
                    ImGui::SetDragDropPayload("DND_SAMPLE_PATH", pathStr.c_str(), pathStr.length() + 1);
                    
                    // Provide visual feedback during the drag.
                    ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                    ImGui::Text("Dragging: %s", sample.name.toRawUTF8());
                    
                    ImGui::EndDragDropSource();
                }
                // C. If a drag did NOT occur, and the item was clicked (mouse released on it), then create the node.
                else if (clicked)
                {
                    if (synth != nullptr)
                    {
                        auto newNodeId = synth->addModule("sample_loader");
                        auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                        pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                        if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                        {
                            sampleLoader->loadSample(sample.file);
                        }
                        snapshotAfterEditor = true;
                    }
                }
                
                // --- END OF FIX ---

                // (Existing tooltip for sample info remains the same)
                if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Duration: %.2f s", sample.durationSeconds);
                    ImGui::Text("Rate: %d Hz", sample.sampleRate);
                    ImGui::EndTooltip();
                }
            }
        }
    };

    // === SAMPLE BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(0, 180, 180, 255)); // Cyan
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(20, 200, 200, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(40, 220, 220, 255));
    bool samplesExpanded = ImGui::CollapsingHeader("Samples");
    ImGui::PopStyleColor(3);
    
    if (samplesExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_sampleScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##samplepath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##sample"))
        {
            samplePathChooser = std::make_unique<juce::FileChooser>("Select Sample Directory", m_sampleScanPath);
            samplePathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_sampleScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("sampleScanPath", m_sampleScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##sample"))
        {
            m_sampleManager.clearCache();
            m_sampleManager.scanDirectory(m_sampleScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_sampleSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##sample", searchBuf, sizeof(searchBuf)))
            m_sampleSearchTerm = juce::String(searchBuf);

        ImGui::Separator();

        // 5. Display hierarchical sample tree
        drawSampleTree(m_sampleManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MIDI BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(180, 120, 255, 255)); // Purple
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(200, 140, 255, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(220, 160, 255, 255));
    bool midiExpanded = ImGui::CollapsingHeader("MIDI Files");
    ImGui::PopStyleColor(3);
    
    if (midiExpanded)
    {
        // 1. Path Display (read-only)
        char pathBuf[1024];
        strncpy(pathBuf, m_midiScanPath.getFullPathName().toRawUTF8(), sizeof(pathBuf) - 1);
        ImGui::InputText("##midipath", pathBuf, sizeof(pathBuf), ImGuiInputTextFlags_ReadOnly);

        // 2. "Change Path" Button
        if (ImGui::Button("Change Path##midi"))
        {
            midiPathChooser = std::make_unique<juce::FileChooser>("Select MIDI Directory", m_midiScanPath);
            midiPathChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this](const juce::FileChooser& fc)
                {
                    auto dir = fc.getResult();
                    if (dir.isDirectory())
                    {
                        m_midiScanPath = dir;
                        // Save the new path to the properties file
                        if (auto* props = PresetCreatorApplication::getApp().getProperties())
                        {
                            props->setValue("midiScanPath", m_midiScanPath.getFullPathName());
                        }
                    }
                });
        }
        ImGui::SameLine();

        // 3. "Scan" Button
        if (ImGui::Button("Scan##midi"))
        {
            m_midiManager.clearCache();
            m_midiManager.scanDirectory(m_midiScanPath);
        }

        // 4. Search bar for filtering results
        char searchBuf[256] = {};
        strncpy(searchBuf, m_midiSearchTerm.toRawUTF8(), sizeof(searchBuf) - 1);
        if (ImGui::InputText("Search##midi", searchBuf, sizeof(searchBuf)))
            m_midiSearchTerm = juce::String(searchBuf);

        ImGui::Separator();
        
        // 5. Display hierarchical MIDI tree
        std::function<void(const MidiManager::DirectoryNode*)> drawMidiTree = 
            [&](const MidiManager::DirectoryNode* node)
        {
            if (!node || (node->midiFiles.empty() && node->subdirectories.empty())) return;

            // Draw subdirectories first
            for (const auto& subdir : node->subdirectories)
            {
                if (ImGui::TreeNode(subdir->name.toRawUTF8()))
                {
                    drawMidiTree(subdir.get());
                    ImGui::TreePop();
                }
            }
            
            // Then draw MIDI files in this directory with drag-and-drop support
            for (const auto& midi : node->midiFiles)
            {
                if (m_midiSearchTerm.isEmpty() || midi.name.containsIgnoreCase(m_midiSearchTerm))
                {
                    // Draw the selectable item and capture its return value
                    bool clicked = ImGui::Selectable(midi.name.toRawUTF8());

                    // Check if this item is the source of a drag operation
                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None))
                    {
                        // Set the payload (the MIDI file path)
                        const juce::String path = midi.file.getFullPathName();
                        const std::string pathStr = path.toStdString();
                        ImGui::SetDragDropPayload("DND_MIDI_PATH", pathStr.c_str(), pathStr.length() + 1);
                        
                        // Provide visual feedback during the drag
                        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
                        ImGui::Text("Dragging: %s", midi.name.toRawUTF8());
                        
                        ImGui::EndDragDropSource();
                    }
                    // If a drag did NOT occur, and the item was clicked, create a new MIDI Player node
                    else if (clicked)
                    {
                        if (synth != nullptr)
                        {
                            auto newNodeId = synth->addModule("midi_player");
                            auto newLogicalId = synth->getLogicalIdForNode(newNodeId);
                            pendingNodeScreenPositions[(int)newLogicalId] = ImGui::GetMousePos();
                            
                            // Load the MIDI file into the new player
                            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(newLogicalId)))
                            {
                                midiPlayer->loadMIDIFile(midi.file);
                            }
                            
                            snapshotAfterEditor = true;
                        }
                    }
                    
                    // Tooltip for MIDI info (only shown when hovering, not dragging)
                    if (ImGui::IsItemHovered() && !ImGui::IsMouseDragging(0))
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("MIDI File: %s", midi.file.getFileName().toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
            }
        };
        
        drawMidiTree(m_midiManager.getRootNode());
    }
    
    ImGui::Separator();
    
    // === MODULE BROWSER ===
    ImGui::PushStyleColor(ImGuiCol_Header, IM_COL32(80, 80, 80, 255)); // Neutral Grey
    ImGui::PushStyleColor(ImGuiCol_HeaderHovered, IM_COL32(100, 100, 100, 255));
    ImGui::PushStyleColor(ImGuiCol_HeaderActive, IM_COL32(120, 120, 120, 255));
    bool modulesExpanded = ImGui::CollapsingHeader("Modules", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    
    if (modulesExpanded)
    {
    
    auto addModuleButton = [this](const char* label, const char* type)
    {
        if (ImGui::Selectable(label, false))
        {
            if (synth != nullptr)
            {
                auto nodeId = synth->addModule(type);
                const ImVec2 mouse = ImGui::GetMousePos();
                // queue screen-space placement after node is drawn to avoid assertions
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                pendingNodeScreenPositions[logicalId] = mouse;
                // Defer snapshot until after EndNodeEditor so the node exists in this frame
                snapshotAfterEditor = true;
            }
        }
        
        // --- FIX: Show tooltip with module description on hover ---
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            
            // Find the description in our list using the module's internal 'type'
            bool found = false;
            for (const auto& pair : getModuleDescriptions())
            {
                if (pair.first.equalsIgnoreCase(type))
                {
                    // If found, display it
                    ImGui::TextUnformatted(pair.second);
                    found = true;
                    break;
                }
            }
            if (!found)
            {
                // Fallback text if a description is missing
                ImGui::TextUnformatted("No description available.");
            }
            
            ImGui::EndTooltip();
        }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MODULE NAMING CONVENTION:
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
    // ALL module type names MUST follow this strict naming convention:
    //   ‚Ä¢ Use ONLY lowercase letters (a-z)
    //   ‚Ä¢ Use ONLY numbers (0-9) where appropriate
    //   ‚Ä¢ Replace ALL spaces with underscores (_)
    //   ‚Ä¢ NO capital letters allowed
    //   ‚Ä¢ NO hyphens or other special characters
    //
    // Examples:
    //   ‚úì CORRECT:   "midi_player", "sample_loader", "graphic_eq", "vco"
    //   ‚úó INCORRECT: "MIDI Player", "Sample Loader", "Graphic EQ", "VCO"
    //
    // This ensures consistent module identification across the system.
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1. SOURCES - Signal generators and inputs
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Source);
    bool sourcesExpanded = ImGui::CollapsingHeader("Sources", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (sourcesExpanded) {
        addModuleButton("VCO", "vco");
        addModuleButton("Polyphonic VCO", "polyvco");
        addModuleButton("Noise", "noise");
        addModuleButton("Audio Input", "audio_input");
        addModuleButton("Sample Loader", "sample_loader");
        addModuleButton("Value", "value");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2. EFFECTS - Audio processing and tone shaping
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Effect);
    bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (effectsExpanded) {
        addModuleButton("VCF", "vcf");
        addModuleButton("Delay", "delay");
        addModuleButton("Reverb", "reverb");
        addModuleButton("Chorus", "chorus");
        addModuleButton("Phaser", "phaser");
        addModuleButton("Compressor", "compressor");
        addModuleButton("Limiter", "limiter");
        addModuleButton("Noise Gate", "gate");
        addModuleButton("Drive", "drive");
        addModuleButton("Graphic EQ", "graphic_eq");
        addModuleButton("Waveshaper", "waveshaper");
        addModuleButton("8-Band Shaper", "8bandshaper");
        addModuleButton("Granulator", "granulator");
        addModuleButton("Harmonic Shaper", "harmonic_shaper");
        addModuleButton("Time/Pitch Shifter", "timepitch");
        addModuleButton("De-Crackle", "de_crackle");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3. MODULATORS - CV generation and modulation sources
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Modulator);
    bool modulatorsExpanded = ImGui::CollapsingHeader("Modulators", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (modulatorsExpanded) {
        addModuleButton("LFO", "lfo");
        addModuleButton("ADSR", "adsr");
        addModuleButton("Random", "random");
        addModuleButton("S&H", "s_and_h");
        addModuleButton("Function Generator", "function_generator");
        addModuleButton("Shaping Oscillator", "shaping_oscillator");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 4. UTILITIES & LOGIC - Signal processing and routing
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Utility);
    bool utilitiesExpanded = ImGui::CollapsingHeader("Utilities & Logic", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (utilitiesExpanded) {
        addModuleButton("VCA", "vca");
        addModuleButton("Mixer", "mixer");
        addModuleButton("CV Mixer", "cv_mixer");
        addModuleButton("Track Mixer", "track_mixer");
        addModuleButton("Attenuverter", "attenuverter");
        addModuleButton("Lag Processor", "lag_processor");
        addModuleButton("Math", "math");
        addModuleButton("Map Range", "map_range");
        addModuleButton("Quantizer", "quantizer");
        addModuleButton("Rate", "rate");
        addModuleButton("Comparator", "comparator");
        addModuleButton("Logic", "logic");
        addModuleButton("Clock Divider", "clock_divider");
        addModuleButton("Sequential Switch", "sequential_switch");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 5. SEQUENCERS - Pattern and rhythm generation
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Seq);
    bool sequencersExpanded = ImGui::CollapsingHeader("Sequencers", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (sequencersExpanded) {
        addModuleButton("Sequencer", "sequencer");
        addModuleButton("Multi Sequencer", "multi_sequencer");
        addModuleButton("Tempo Clock", "tempo_clock");
        addModuleButton("Snapshot Sequencer", "snapshot_sequencer");
        addModuleButton("Stroke Sequencer", "stroke_sequencer");
        addModuleButton("Timeline", "timeline");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 6. MIDI - MIDI input/output and controllers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::MIDI);
    bool midiExpanded = ImGui::CollapsingHeader("MIDI", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (midiExpanded) {
        addModuleButton("MIDI CV", "midi_cv");
        addModuleButton("MIDI Player", "midi_player");
        ImGui::Separator();
        addModuleButton("MIDI Faders", "midi_faders");
        addModuleButton("MIDI Knobs", "midi_knobs");
        addModuleButton("MIDI Buttons", "midi_buttons");
        addModuleButton("MIDI Jog Wheel", "midi_jog_wheel");
        addModuleButton("MIDI Pads", "midi_pads");
        ImGui::Separator();
        addModuleButton("MIDI Logger", "midi_logger");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 7. ANALYSIS - Signal visualization and debugging
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Analysis);
    bool analysisExpanded = ImGui::CollapsingHeader("Analysis", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (analysisExpanded) {
        addModuleButton("Scope", "scope");
        addModuleButton("Debug", "debug");
        addModuleButton("Input Debug", "input_debug");
        addModuleButton("Frequency Graph", "frequency_graph");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 8. TTS - Text-to-Speech and vocal synthesis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::TTS_Voice);
    bool ttsExpanded = ImGui::CollapsingHeader("TTS", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (ttsExpanded) {
        addModuleButton("TTS Performer", "tts_performer");
        addModuleButton("Vocal Tract Filter", "vocal_tract_filter");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 9. SPECIAL - Physics, animation, and experimental
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Special_Exp);
    bool specialExpanded = ImGui::CollapsingHeader("Special", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (specialExpanded) {
        addModuleButton("Physics", "physics");
        addModuleButton("Animation", "animation");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 10. COMPUTER VISION - Video processing and analysis
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::OpenCV);
    bool openCVExpanded = ImGui::CollapsingHeader("Computer Vision", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (openCVExpanded) {
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Sources:");
        addModuleButton("Webcam Loader", "webcam_loader");
        addModuleButton("Video File Loader", "video_file_loader");
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Processors:");
        addModuleButton("Video FX", "video_fx");
        addModuleButton("Movement Detector", "movement_detector");
        addModuleButton("Human Detector", "human_detector");
        addModuleButton("Object Detector", "object_detector");
        addModuleButton("Pose Estimator", "pose_estimator");
        addModuleButton("Hand Tracker", "hand_tracker");
        addModuleButton("Face Tracker", "face_tracker");
        addModuleButton("Color Tracker", "color_tracker");
        addModuleButton("Contour Detector", "contour_detector");
        addModuleButton("Semantic Segmentation", "semantic_segmentation");
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 11. PLUGINS / VST - Third-party audio plugins
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Plugin);
    bool pluginsExpanded = ImGui::CollapsingHeader("Plugins / VST", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (pluginsExpanded) {
        addPluginModules();
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 12. SYSTEM - Patch organization and system utilities
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    pushCategoryColor(ModuleCategory::Sys);
    bool systemExpanded = ImGui::CollapsingHeader("System", ImGuiTreeNodeFlags_DefaultOpen);
    ImGui::PopStyleColor(3);
    if (systemExpanded) {
        addModuleButton("Meta", "meta");
        addModuleButton("Inlet", "inlet");
        addModuleButton("Outlet", "outlet");
        addModuleButton("Comment", "comment");
        addModuleButton("Recorder", "recorder");
        addModuleButton("VST Host", "vst_host");
        ImGui::Separator();
        addModuleButton("Best Practice", "best_practice");
    }
    
    } // End of Modules collapsing header

    // End the scrolling region
    ImGui::EndChild();

    ImGui::NextColumn();

    // --- DEFINITIVE FIX FOR PRESET DRAG-AND-DROP WITH VISUAL FEEDBACK ---
    // Step 1: Define canvas dimensions first (needed for the drop target)
    const ImU32 GRID_COLOR = IM_COL32(50, 50, 50, 255);
    const ImU32 GRID_ORIGIN_COLOR = IM_COL32(80, 80, 80, 255);
    const float GRID_SIZE = 64.0f;
    ImVec2 canvas_p0 = ImGui::GetCursorScreenPos();
    ImVec2 canvas_sz = ImGui::GetContentRegionAvail();
    ImVec2 canvas_p1 = ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + canvas_sz.y);

    // Step 2: Create a full-canvas invisible button to act as our drop area
    ImGui::SetCursorScreenPos(canvas_p0);
    ImGui::InvisibleButton("##canvas_drop_target", canvas_sz);

    // Step 3: Make this area a drop target with visual feedback
    if (ImGui::BeginDragDropTarget())
    {
        // Check if a preset payload is being hovered over the canvas
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_PRESET_PATH", ImGuiDragDropFlags_AcceptBeforeDelivery))
        {
            // Draw a semi-transparent overlay to show the canvas is a valid drop zone
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            drawList->AddRectFilled(canvas_p0, canvas_p1, IM_COL32(218, 165, 32, 80)); // Preset Gold color
            
            // Check if the mouse button was released to complete the drop
            if (payload->IsDelivery())
            {
                const char* path = (const char*)payload->Data;
                ImVec2 dropPos = ImGui::GetMousePos(); // Get the exact drop position
                mergePresetFromFile(juce::File(path), dropPos);
            }
        }
        ImGui::EndDragDropTarget();
    }
    // --- END OF DEFINITIVE FIX ---

    // Reset cursor position for subsequent drawing
    ImGui::SetCursorScreenPos(canvas_p0);

    // <<< ADD THIS ENTIRE BLOCK TO CACHE CONNECTION STATUS >>>
    std::unordered_set<int> connectedInputAttrs;
    std::unordered_set<int> connectedOutputAttrs;
    if (synth != nullptr)
    {
        for (const auto& c : synth->getConnectionsInfo())
        {
            int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            connectedOutputAttrs.insert(srcAttr);

            int dstAttr = c.dstIsOutput ? 
                encodePinId({0, c.dstChan, true}) : 
                encodePinId({c.dstLogicalId, c.dstChan, true});
            connectedInputAttrs.insert(dstAttr);
        }
    }
    // <<< END OF BLOCK >>>

    // <<< ADD THIS BLOCK TO DEFINE COLORS >>>
    const ImU32 colPin = IM_COL32(150, 150, 150, 255); // Grey for disconnected
    const ImU32 colPinConnected = IM_COL32(120, 255, 120, 255); // Green for connected
    // <<< END OF BLOCK >>>

    // Pre-register is no longer needed - stateless encoding generates IDs on-the-fly
    // (Removed the old pre-registration loop)

    // --- BACKGROUND GRID AND COORDINATE DISPLAY ---
    // (Canvas dimensions already defined above in the drop target code)
    ImDrawList* draw_list = ImGui::GetBackgroundDrawList();
    ImVec2 panning = ImNodes::EditorContextGetPanning();

    // Draw grid lines
    for (float x = fmodf(panning.x, GRID_SIZE); x < canvas_sz.x; x += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x + x, canvas_p0.y), ImVec2(canvas_p0.x + x, canvas_p0.y + canvas_sz.y), GRID_COLOR);
    for (float y = fmodf(panning.y, GRID_SIZE); y < canvas_sz.y; y += GRID_SIZE)
        draw_list->AddLine(ImVec2(canvas_p0.x, canvas_p0.y + y), ImVec2(canvas_p0.x + canvas_sz.x, canvas_p0.y + y), GRID_COLOR);

    // Draw thicker lines for the origin (0,0)
    ImVec2 origin_on_screen = ImVec2(canvas_p0.x + panning.x, canvas_p0.y + panning.y);
    draw_list->AddLine(ImVec2(origin_on_screen.x, canvas_p0.y), ImVec2(origin_on_screen.x, canvas_p1.y), GRID_ORIGIN_COLOR, 2.0f);
    draw_list->AddLine(ImVec2(canvas_p0.x, origin_on_screen.y), ImVec2(canvas_p1.x, origin_on_screen.y), GRID_ORIGIN_COLOR, 2.0f);

    // Draw scale markers every 400 grid units as a grid (not a cross)
    const float SCALE_INTERVAL = 400.0f;
    const ImU32 SCALE_TEXT_COLOR = IM_COL32(150, 150, 150, 80); // Reduced opacity
    ImDrawList* fg_draw_list = ImGui::GetForegroundDrawList();
    
    // X-axis scale markers - always at the bottom edge
    float gridLeft = -panning.x;
    float gridRight = canvas_sz.x - panning.x;
    int startX = (int)std::floor(gridLeft / SCALE_INTERVAL);
    int endX = (int)std::ceil(gridRight / SCALE_INTERVAL);
    
    for (int i = startX; i <= endX; ++i)
    {
        float gridX = i * SCALE_INTERVAL;
        float screenX = canvas_p0.x + panning.x + gridX;
        
        // Only draw if visible on screen
        if (screenX >= canvas_p0.x && screenX <= canvas_p1.x)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridX);
            // Always draw at bottom edge
            fg_draw_list->AddText(ImVec2(screenX + 2, canvas_p1.y - 45), SCALE_TEXT_COLOR, label);
        }
    }
    
    // Y-axis scale markers - always at the left edge
    float gridTop = -panning.y;
    float gridBottom = canvas_sz.y - panning.y;
    int startY = (int)std::floor(gridTop / SCALE_INTERVAL);
    int endY = (int)std::ceil(gridBottom / SCALE_INTERVAL);
    
    for (int i = startY; i <= endY; ++i)
    {
        float gridY = i * SCALE_INTERVAL;
        float screenY = canvas_p0.y + panning.y + gridY;
        
        // Only draw if visible on screen
        if (screenY >= canvas_p0.y && screenY <= canvas_p1.y)
        {
            char label[16];
            snprintf(label, sizeof(label), "%.0f", gridY);
            // Always draw at left edge
            fg_draw_list->AddText(ImVec2(canvas_p0.x + 5, screenY + 2), SCALE_TEXT_COLOR, label);
        }
    }

    // Mouse coordinate display overlay (bottom-left)
    ImVec2 mouseScreenPos = ImGui::GetMousePos();
    ImVec2 mouseGridPos = ImVec2(mouseScreenPos.x - canvas_p0.x - panning.x, mouseScreenPos.y - canvas_p0.y - panning.y);
    char posStr[32];
    snprintf(posStr, sizeof(posStr), "%.0f, %.0f", mouseGridPos.x, mouseGridPos.y);
    // Use the foreground draw list to ensure text is on top of everything
    // Position at bottom-left: canvas_p1.y is bottom edge, subtract text height plus padding
    ImGui::GetForegroundDrawList()->AddText(ImVec2(canvas_p0.x + 10, canvas_p1.y - 25), IM_COL32(200, 200, 200, 150), posStr);
    // --- END OF BACKGROUND GRID AND COORDINATE DISPLAY ---

    // Node canvas bound to the underlying model if available
    ImNodes::BeginNodeEditor();
    // Begin the editor

    // +++ ADD THIS LINE AT THE START OF THE RENDER LOOP +++
    attrPositions.clear(); // Clear the cache at the beginning of each frame.
    // Rebuild mod attribute mapping from currently drawn nodes only
    // modAttrToParam.clear(); // TODO: Remove when fully migrated
    // Track which attribute IDs were actually registered this frame
    std::unordered_set<int> availableAttrs;
    // Track duplicates to diagnose disappearing pins
    std::unordered_set<int> seenAttrs;
    auto linkIdOf = [this] (int srcAttr, int dstAttr) -> int
    {
        return getLinkId(srcAttr, dstAttr);
    };

    if (synth != nullptr)
    {
        // Apply any pending UI state restore (first frame after load)
        if (uiPending.isValid())
        {
            // Cache target positions to ensure they stick even if nodes are created later this frame
            auto nodes = uiPending;
for (int i = 0; i < nodes.getNumChildren(); ++i)
            {
                auto n = nodes.getChild(i);
if (! n.hasType("node")) continue;
                const int nid = (int) n.getProperty("id", 0);
                const float x = (float) n.getProperty("x", 0.0f);
const float y = (float) n.getProperty("y", 0.0f);
                if (!(x == 0.0f && y == 0.0f))
                    pendingNodePositions[nid] = ImVec2(x, y);
}
            uiPending = {};
}

        // Draw module nodes (exactly once per logical module)
        // Graph is now always in consistent state since we rebuild at frame start
        std::unordered_set<int> drawnNodes;
        for (const auto& mod : synth->getModulesInfo())
        {
            const juce::uint32 lid = mod.first;
const juce::String& type = mod.second;

            // Color-code modules by category (base colors)
            const auto moduleCategory = getModuleCategory(type);
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, getImU32ForCategory(moduleCategory));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarHovered, getImU32ForCategory(moduleCategory, true));
            ImNodes::PushColorStyle(ImNodesCol_TitleBarSelected, getImU32ForCategory(moduleCategory, true));

            // Highlight nodes participating in the hovered link (overrides category color)
            const bool isHoveredSource = (hoveredLinkSrcId != 0 && hoveredLinkSrcId == (juce::uint32) lid);
            const bool isHoveredDest   = (hoveredLinkDstId != 0 && hoveredLinkDstId == (juce::uint32) lid);
            if (isHoveredSource || isHoveredDest)
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));

            // Visual feedback for muted nodes (overrides category color and hover)
            const bool isMuted = mutedNodeStates.count(lid) > 0;
            if (isMuted) {
                ImNodes::PushStyleVar(ImNodesStyleVar_NodePadding, ImVec2(8, 8));
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.5f);
                ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(80, 80, 80, 255));
            }

            ImNodes::BeginNode ((int) lid);
            ImNodes::BeginNodeTitleBar();
            ImGui::TextUnformatted (type.toRawUTF8());
            ImNodes::EndNodeTitleBar();

            // Get node content width - check if module has custom size, otherwise use default
            float nodeContentWidth = 240.0f; // Default width
            if (auto* mp = synth->getModuleForLogical(lid))
            {
                ImVec2 customSize = mp->getCustomNodeSize();
                if (customSize.x > 0.0f) // Module specified a custom width
                {
                    nodeContentWidth = customSize.x;
                }
            }

            // Inline parameter controls per module type
            if (synth != nullptr)
            {
if (auto* mp = synth->getModuleForLogical (lid))
{
    ImGui::PushID ((int) lid);

    // This new lambda function checks if a parameter is being modulated
    auto isParamModulated = [&](const juce::String& paramId) -> bool {
        if (!synth) return false;
        if (auto* mp = synth->getModuleForLogical(lid))
        {
            int busIdx = -1, chInBus = -1;
            // Use the new standardized routing API on the module itself
            if (!mp->getParamRouting(paramId, busIdx, chInBus)) 
                return false;

            // Calculate the absolute channel index that the graph uses for this bus/channel pair
            const int absoluteChannelIndex = mp->getChannelIndexInProcessBlockBuffer(true, busIdx, chInBus);
            if (absoluteChannelIndex < 0) return false;
            
            // Scan the simple graph connections for a match
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == lid && c.dstChan == absoluteChannelIndex)
                    return true;
            }
        }
        return false;
    };

    // Helper to read a live, modulated value if available (respects _mod alias)
    auto getLiveValueOr = [&](const juce::String& paramId, float fallback) -> float
    {
        if (!synth) return fallback;
        if (auto* mp = synth->getModuleForLogical(lid))
            return mp->getLiveParamValueFor(paramId + "_mod", paramId + "_live", fallback);
        return fallback;
    };

    // Create a new function that calls pushSnapshot
    auto onModificationEnded = [&](){ this->pushSnapshot(); };

    // --- SPECIAL RENDERING FOR SAMPLE LOADER ---
    if (auto* sampleLoader = dynamic_cast<SampleLoaderModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (buttons, sliders, etc.)
        // We pass a modified onModificationEnded to avoid creating undo states while dragging.
        sampleLoader->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);

        // Now, handle the spectrogram texture and drawing
        juce::OpenGLTexture* texturePtr = nullptr;
        if (auto it = sampleLoaderTextureIds.find((int)lid); it != sampleLoaderTextureIds.end())
            texturePtr = it->second.get();

        juce::Image spectrogram = sampleLoader->getSpectrogramImage();
        if (spectrogram.isValid())
        {
            if (texturePtr == nullptr)
            {
                auto tex = std::make_unique<juce::OpenGLTexture>();
                texturePtr = tex.get();
                sampleLoaderTextureIds[(int)lid] = std::move(tex);
            }
            // Upload or update texture from JUCE image (handles format & parameters internally)
            texturePtr->loadImage(spectrogram);

            ImGui::Image((void*)(intptr_t) texturePtr->getTextureID(), ImVec2(nodeContentWidth, 100.0f));

            // Drag state is tracked per Sample Loader node to avoid cross-node interference
            static std::unordered_map<int,int> draggedHandleByNode; // lid -> -1,0,1
            int& draggedHandle = draggedHandleByNode[(int) lid];
            if (draggedHandle != 0 && draggedHandle != 1) draggedHandle = -1;
            ImGui::SetCursorScreenPos(ImGui::GetItemRectMin());
            ImGui::InvisibleButton("##spectrogram_interaction", ImVec2(nodeContentWidth, 100.0f));

            auto* drawList = ImGui::GetWindowDrawList();
            const ImVec2 rectMin = ImGui::GetItemRectMin();
            const ImVec2 rectMax = ImGui::GetItemRectMax();

            float startNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeStart")->load();
            float endNorm = sampleLoader->getAPVTS().getRawParameterValue("rangeEnd")->load();

            // Use live telemetry values when modulated
            startNorm = sampleLoader->getLiveParamValueFor("rangeStart_mod", "rangeStart_live", startNorm);
            endNorm = sampleLoader->getLiveParamValueFor("rangeEnd_mod", "rangeEnd_live", endNorm);

            // Visual guard even when modulated
            const float kMinGap = 0.001f;
            startNorm = juce::jlimit(0.0f, 1.0f, startNorm);
            endNorm   = juce::jlimit(0.0f, 1.0f, endNorm);
            if (startNorm >= endNorm)
            {
                if (startNorm <= 1.0f - kMinGap)
                    endNorm = juce::jmin(1.0f, startNorm + kMinGap);
                else
                    startNorm = juce::jmax(0.0f, endNorm - kMinGap);
            }

            // --- FIX FOR BUG 1: Separate modulation checks for each handle ---
            bool startIsModulated = isParamModulated("rangeStart_mod");
            bool endIsModulated = isParamModulated("rangeEnd_mod");

            const bool itemHovered = ImGui::IsItemHovered();
            const bool itemActive  = ImGui::IsItemActive();
            if (itemHovered)
            {
                ImVec2 mousePos = ImGui::GetMousePos();
                float startHandleX = rectMin.x + startNorm * nodeContentWidth;
                float endHandleX = rectMin.x + endNorm * nodeContentWidth;

                bool canDragStart = !startIsModulated && (std::abs(mousePos.x - startHandleX) < 5);
                bool canDragEnd = !endIsModulated && (std::abs(mousePos.x - endHandleX) < 5);

                if (draggedHandle == -1 && (canDragStart || canDragEnd))
                {
                    ImGui::SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                }

                if (ImGui::IsItemClicked())
                {
                    // Only allow dragging to start if the corresponding handle is not modulated
                    if (canDragStart && canDragEnd)
                        draggedHandle = (std::abs(mousePos.x - startHandleX) < std::abs(mousePos.x - endHandleX)) ? 0 : 1;
                    else if (canDragStart)
                        draggedHandle = 0;
                    else if (canDragEnd)
                        draggedHandle = 1;
                }
            }

            if (itemActive && ImGui::IsMouseReleased(0))
            {
                if (draggedHandle != -1) onModificationEnded();
                draggedHandle = -1;
            }

            // Handle the drag update, checking the specific modulation flag for the active handle
            if (itemActive && draggedHandle != -1 && ImGui::IsMouseDragging(0))
            {
                float newNormX = juce::jlimit(0.0f, 1.0f, (ImGui::GetMousePos().x - rectMin.x) / nodeContentWidth);
                if (draggedHandle == 0 && !startIsModulated)
                {
                    // Guard: start cannot be >= end
                    startNorm = juce::jmin(newNormX, endNorm - 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeStart")->setValueNotifyingHost(startNorm);
                }
                else if (draggedHandle == 1 && !endIsModulated)
                {
                    // Guard: end cannot be <= start
                    endNorm = juce::jmax(newNormX, startNorm + 0.001f);
                    sampleLoader->getAPVTS().getParameter("rangeEnd")->setValueNotifyingHost(endNorm);
                }
            }

            float startX = rectMin.x + startNorm * nodeContentWidth;
            float endX = rectMin.x + endNorm * nodeContentWidth;
            drawList->AddRectFilled(rectMin, ImVec2(startX, rectMax.y), IM_COL32(0, 0, 0, 120));
            drawList->AddRectFilled(ImVec2(endX, rectMin.y), rectMax, IM_COL32(0, 0, 0, 120));
            drawList->AddLine(ImVec2(startX, rectMin.y), ImVec2(startX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
            drawList->AddLine(ImVec2(endX, rectMin.y), ImVec2(endX, rectMax.y), IM_COL32(255, 255, 0, 255), 3.0f);
        }
    }
    // --- SPECIAL RENDERING FOR AUDIO INPUT (MULTI-CHANNEL) ---
    else if (auto* audioIn = dynamic_cast<AudioInputModuleProcessor*>(mp))
    {
        auto& apvts = audioIn->getAPVTS();

        // --- Device Selectors ---
        juce::AudioDeviceManager::AudioDeviceSetup setup;
        deviceManager.getAudioDeviceSetup(setup);
        
        // Input Device
        juce::StringArray availableInputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableInputDevices = deviceType->getDeviceNames(true);
        }
        std::vector<const char*> inputDeviceItems;
        for (const auto& name : availableInputDevices) inputDeviceItems.push_back(name.toRawUTF8());
        int currentInputDeviceIndex = availableInputDevices.indexOf(setup.inputDeviceName);
        if (currentInputDeviceIndex < 0) currentInputDeviceIndex = 0;

        ImGui::PushItemWidth(nodeContentWidth);
        if (ImGui::Combo("Input Device", &currentInputDeviceIndex, inputDeviceItems.data(), (int)inputDeviceItems.size())) {
            if (currentInputDeviceIndex < availableInputDevices.size()) {
                setup.inputDeviceName = availableInputDevices[currentInputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }

        // Output Device
        juce::StringArray availableOutputDevices;
        if (auto* deviceType = deviceManager.getAvailableDeviceTypes().getFirst()) {
            availableOutputDevices = deviceType->getDeviceNames(false);
        }
        std::vector<const char*> outputDeviceItems;
        for (const auto& name : availableOutputDevices) outputDeviceItems.push_back(name.toRawUTF8());
        int currentOutputDeviceIndex = availableOutputDevices.indexOf(setup.outputDeviceName);
        if (currentOutputDeviceIndex < 0) currentOutputDeviceIndex = 0;
        
        if (ImGui::Combo("Output Device", &currentOutputDeviceIndex, outputDeviceItems.data(), (int)outputDeviceItems.size())) {
            if (currentOutputDeviceIndex < availableOutputDevices.size()) {
                setup.outputDeviceName = availableOutputDevices[currentOutputDeviceIndex];
                deviceManager.setAudioDeviceSetup(setup, true);
                onModificationEnded();
            }
        }
        
        // --- Channel Count ---
        auto* numChannelsParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("numChannels"));
        int numChannels = numChannelsParam->get();
        if (ImGui::SliderInt("Channels", &numChannels, 1, AudioInputModuleProcessor::MAX_CHANNELS)) {
            *numChannelsParam = numChannels;
            onModificationEnded();
        }
        
        // --- Threshold Sliders ---
        auto* gateThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"));
        float gateThresh = gateThreshParam->get();
        if (ImGui::SliderFloat("Gate Threshold", &gateThresh, 0.0f, 1.0f, "%.3f")) {
            *gateThreshParam = gateThresh;
            onModificationEnded();
        }
        
        auto* trigThreshParam = static_cast<juce::AudioParameterFloat*>(apvts.getParameter("triggerThreshold"));
        float trigThresh = trigThreshParam->get();
        if (ImGui::SliderFloat("Trigger Threshold", &trigThresh, 0.0f, 1.0f, "%.3f")) {
            *trigThreshParam = trigThresh;
            onModificationEnded();
        }
        
        ImGui::PopItemWidth();

        // --- Dynamic Channel Selectors & VU Meters ---
        auto hardwareChannels = deviceManager.getCurrentAudioDevice() ? deviceManager.getCurrentAudioDevice()->getInputChannelNames() : juce::StringArray{};
        if (!hardwareChannels.isEmpty())
        {
            std::vector<const char*> hwChannelItems;
            for (const auto& name : hardwareChannels) hwChannelItems.push_back(name.toRawUTF8());
            
            for (int i = 0; i < numChannels; ++i) {
                auto* mappingParam = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(i)));
                int selectedHwChannel = mappingParam->get();
                selectedHwChannel = juce::jlimit(0, (int)hwChannelItems.size() - 1, selectedHwChannel);

                ImGui::PushID(i);
                ImGui::PushItemWidth(nodeContentWidth * 0.6f);
                if (ImGui::Combo(("Input for Out " + juce::String(i + 1)).toRawUTF8(), &selectedHwChannel, hwChannelItems.data(), (int)hwChannelItems.size())) {
                    *mappingParam = selectedHwChannel;
                    std::vector<int> newMapping(numChannels);
                    for (int j = 0; j < numChannels; ++j) {
                        auto* p = static_cast<juce::AudioParameterInt*>(apvts.getParameter("channelMap" + juce::String(j)));
                        newMapping[j] = p->get();
                    }
                    synth->setAudioInputChannelMapping(synth->getNodeIdForLogical(lid), newMapping);
                    onModificationEnded();
                }
                ImGui::PopItemWidth();

                ImGui::SameLine();
                
                // --- VU Meter with Threshold Lines ---
                float level = (i < (int)audioIn->channelLevels.size() && audioIn->channelLevels[i]) ? audioIn->channelLevels[i]->load() : 0.0f;
                ImVec2 meterSize(nodeContentWidth * 0.38f, ImGui::GetTextLineHeightWithSpacing() * 0.8f);
                ImGui::ProgressBar(level, meterSize, "");

                // Draw threshold lines on top of the progress bar
                ImVec2 p_min = ImGui::GetItemRectMin();
                ImVec2 p_max = ImGui::GetItemRectMax();
                ImDrawList* draw_list = ImGui::GetWindowDrawList();

                // Gate Threshold (Yellow)
                float gateLineX = p_min.x + gateThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(gateLineX, p_min.y), ImVec2(gateLineX, p_max.y), IM_COL32(255, 255, 0, 200), 2.0f);

                // Trigger Threshold (Orange)
                float trigLineX = p_min.x + trigThresh * (p_max.x - p_min.x);
                draw_list->AddLine(ImVec2(trigLineX, p_min.y), ImVec2(trigLineX, p_max.y), IM_COL32(255, 165, 0, 200), 2.0f);
                
                ImGui::PopID();
            }
        }
    }
    // --- SPECIAL RENDERING FOR SNAPSHOT SEQUENCER ---
    // Commented out - SnapshotSequencerModuleProcessor causing build errors
    /*else if (auto* snapshotSeq = dynamic_cast<SnapshotSequencerModuleProcessor*>(mp))
    {
        // First, draw the standard parameters (number of steps, etc.)
        snapshotSeq->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
        
        ImGui::Separator();
        ImGui::Text("Snapshot Management:");
        
        const int numSteps = 8; // Default, could read from parameter
        const int currentStepIndex = 0; // TODO: Get from module if exposed
        
        // Draw capture/clear buttons for each step
        for (int i = 0; i < numSteps; ++i)
        {
            ImGui::PushID(i);
            
            bool stored = snapshotSeq->isSnapshotStored(i);
            
            // Capture button
            if (ImGui::Button("Capture"))
            {
                // Get the current state of the whole synth
                juce::MemoryBlock currentState;
                synth->getStateInformation(currentState);
                
                // Store it in the snapshot sequencer
                snapshotSeq->setSnapshotForStep(i, currentState);
                
                // Create undo state
                pushSnapshot();
                
                juce::Logger::writeToLog("[SnapshotSeq UI] Captured snapshot for step " + juce::String(i));
            }
            
            ImGui::SameLine();
            
            // Clear button (only enabled if snapshot exists)
            if (!stored)
            {
                ImGui::BeginDisabled();
            }
            
            if (ImGui::Button("Clear"))
            {
                snapshotSeq->clearSnapshotForStep(i);
                pushSnapshot();
                juce::Logger::writeToLog("[SnapshotSeq UI] Cleared snapshot for step " + juce::String(i));
            }
            
            if (!stored)
            {
                ImGui::EndDisabled();
            }
            
            ImGui::PopID();
        }
    }*/
    // --- SPECIAL RENDERING FOR OPENCV MODULES (WITH VIDEO FEED) ---
    else if (auto* webcamModule = dynamic_cast<WebcamLoaderModule*>(mp))
    {
        juce::Image frame = webcamModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        webcamModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* videoFileModule = dynamic_cast<VideoFileLoaderModule*>(mp))
    {
        juce::Image frame = videoFileModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        videoFileModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* movementModule = dynamic_cast<MovementDetectorModule*>(mp))
    {
        juce::Image frame = movementModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        movementModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* humanModule = dynamic_cast<HumanDetectorModule*>(mp))
    {
        juce::Image frame = humanModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        humanModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* poseModule = dynamic_cast<PoseEstimatorModule*>(mp))
    {
        juce::Image frame = poseModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                // Calculate aspect ratio dynamically from the actual frame dimensions
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                
                // Preserve the video's native aspect ratio (handles portrait, landscape, square, etc.)
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                
                // Width is fixed at itemWidth (480px for video modules), height scales proportionally
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                
                // Flip Y-coordinates to fix upside-down video (OpenCV uses top-left origin, OpenGL uses bottom-left)
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        poseModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* colorModule = dynamic_cast<ColorTrackerModule*>(mp))
    {
        juce::Image frame = colorModule->getLatestFrame();
        if (!frame.isNull())
        {
            static std::map<int, int> hoverRadiusByNode; // logicalId -> radius (half-size), default 2 => 5x5
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));

                // Handle color picker clicks when active
                if (colorModule->isPickerActive() && ImGui::IsItemHovered())
                {
                    ImGui::SetTooltip("Click to pick a color from the video");
                    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
                    {
                        ImVec2 mousePos = ImGui::GetMousePos();
                        ImVec2 itemMin = ImGui::GetItemRectMin();
                        ImVec2 itemSize = ImGui::GetItemRectSize();
                        float nx = (mousePos.x - itemMin.x) / itemSize.x;
                        float ny = (mousePos.y - itemMin.y) / itemSize.y;
                        nx = juce::jlimit(0.0f, 1.0f, nx);
                        ny = juce::jlimit(0.0f, 1.0f, ny);
                        // Use ny directly (no flip) to align clicks with displayed image
                        int px = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                        int py = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());
                        juce::Logger::writeToLog(juce::String("[ColorTracker][UI] nx=") + juce::String(nx, 3) + ", ny=" + juce::String(ny, 3) +
                                                  ", px=" + juce::String(px) + ", py=" + juce::String(py));
                        colorModule->addColorAt(px, py);
                        colorModule->exitPickerMode();
                    }
                }

                // Hover preview: median/average color swatch and scroll-wheel radius control
                if (ImGui::IsItemHovered())
                {
                    // Update radius by mouse wheel
                    int& rad = hoverRadiusByNode[(int)lid]; if (rad <= 0) rad = 2;
                    float wheel = ImGui::GetIO().MouseWheel;
                    if (wheel != 0.0f)
                    {
                        rad += (wheel > 0) ? 1 : -1;
                        rad = juce::jlimit(1, 30, rad); // (2*rad+1)^2 window, max 61x61
                    }

                    // Map mouse to pixel
                    ImVec2 mousePos = ImGui::GetMousePos();
                    ImVec2 itemMin = ImGui::GetItemRectMin();
                    ImVec2 itemSize = ImGui::GetItemRectSize();
                    float nx = (mousePos.x - itemMin.x) / itemSize.x;
                    float ny = (mousePos.y - itemMin.y) / itemSize.y;
                    nx = juce::jlimit(0.0f, 1.0f, nx);
                    ny = juce::jlimit(0.0f, 1.0f, ny);
                    int cx = (int)juce::jlimit(0.0f, (float)frame.getWidth()  - 1.0f, nx * (float)frame.getWidth());
                    int cy = (int)juce::jlimit(0.0f, (float)frame.getHeight() - 1.0f, ny * (float)frame.getHeight());

                    // Sample ROI from juce::Image
                    std::vector<int> vr, vg, vb; vr.reserve((2*rad+1)*(2*rad+1)); vg.reserve(vr.capacity()); vb.reserve(vr.capacity());
                    juce::Image::BitmapData bd(frame, juce::Image::BitmapData::readOnly);
                    auto clampi = [](int v, int lo, int hi){ return (v < lo) ? lo : (v > hi ? hi : v); };
                    for (int y = cy - rad; y <= cy + rad; ++y)
                    {
                        int yy = clampi(y, 0, frame.getHeight()-1);
                        const juce::PixelARGB* row = (const juce::PixelARGB*)(bd.getLinePointer(yy));
                        for (int x = cx - rad; x <= cx + rad; ++x)
                        {
                            int xx = clampi(x, 0, frame.getWidth()-1);
                            const juce::PixelARGB& p = row[xx];
                            vr.push_back(p.getRed());
                            vg.push_back(p.getGreen());
                            vb.push_back(p.getBlue());
                        }
                    }
                    auto median = [](std::vector<int>& v){ std::nth_element(v.begin(), v.begin()+v.size()/2, v.end()); return v[v.size()/2]; };
                    int mr = median(vr), mg = median(vg), mb = median(vb);
                    juce::Colour mc((juce::uint8)mr, (juce::uint8)mg, (juce::uint8)mb);
                    float h = mc.getHue(), s = mc.getSaturation(), b = mc.getBrightness();

                    // Tooltip near cursor with swatch and numbers
                    ImGui::BeginTooltip();
                    ImGui::Text("(%d,%d) rad=%d", cx, cy, rad);
                    ImGui::ColorButton("##hoverSwatch", ImVec4(mc.getFloatRed(), mc.getFloatGreen(), mc.getFloatBlue(), 1.0f), 0, ImVec2(22,22));
                    ImGui::SameLine();
                    ImGui::Text("RGB %d,%d,%d\nHSV %d,%d,%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f));
                    ImGui::EndTooltip();

                    // Textual summary under the image (lightweight)
                    ImGui::TextDisabled("Hover RGB %d,%d,%d  HSV %d,%d,%d  rad=%d", mr, mg, mb, (int)(h*180.0f), (int)(s*255.0f), (int)(b*255.0f), rad);
                }
            }
        }
        colorModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* contourModule = dynamic_cast<ContourDetectorModule*>(mp))
    {
        juce::Image frame = contourModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        contourModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* segModule = dynamic_cast<SemanticSegmentationModule*>(mp))
    {
        juce::Image frame = segModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        segModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* objModule = dynamic_cast<ObjectDetectorModule*>(mp))
    {
        juce::Image frame = objModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            auto* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float ar = (float)frame.getHeight() / juce::jmax(1.0f, (float)frame.getWidth());
                ImVec2 size(nodeContentWidth, nodeContentWidth * ar);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), size, ImVec2(0,1), ImVec2(1,0));
            }
        }
        objModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* handModule = dynamic_cast<HandTrackerModule*>(mp))
    {
        juce::Image frame = handModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        handModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* faceModule = dynamic_cast<FaceTrackerModule*>(mp))
    {
        juce::Image frame = faceModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f;
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        faceModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* fxModule = dynamic_cast<VideoFXModule*>(mp))
    {
        juce::Image frame = fxModule->getLatestFrame();
        if (!frame.isNull())
        {
            if (visionModuleTextures.find((int)lid) == visionModuleTextures.end())
            {
                visionModuleTextures[(int)lid] = std::make_unique<juce::OpenGLTexture>();
            }
            juce::OpenGLTexture* texture = visionModuleTextures[(int)lid].get();
            texture->loadImage(frame);
            if (texture->getTextureID() != 0)
            {
                float nativeWidth = (float)frame.getWidth();
                float nativeHeight = (float)frame.getHeight();
                float aspectRatio = (nativeWidth > 0.0f) ? nativeHeight / nativeWidth : 0.75f; // Default to 4:3
                ImVec2 renderSize = ImVec2(nodeContentWidth, nodeContentWidth * aspectRatio);
                // Flip Y-coords for correct orientation
                ImGui::Image((void*)(intptr_t)texture->getTextureID(), renderSize, ImVec2(0, 1), ImVec2(1, 0));
            }
        }
        // Now draw the regular parameters below the video
        fxModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else if (auto* cropVideoModule = dynamic_cast<CropVideoModule*>(mp))
    {
        // CropVideoModule handles its own preview rendering with interaction in drawParametersInNode
        cropVideoModule->drawParametersInNode(nodeContentWidth, isParamModulated, onModificationEnded);
    }
    else
    {
        mp->drawParametersInNode (nodeContentWidth, isParamModulated, onModificationEnded);
    }
    ImGui::Spacing();
    ImGui::PopID();
}
            }

            // IO per module type via helpers
            NodePinHelpers helpers;
            
            // Helper to draw right-aligned text within a node's content width
            // From imnodes examples (color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73):
            // Use ImGui::Indent() for right-alignment - this is the CORRECT ImNodes pattern!
            auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
            {
                const ImVec2 textSize = ImGui::CalcTextSize(txt);
                
                // Indent by (nodeWidth - textWidth) to right-align the text
                // CRITICAL: Must call Unindent() to prevent indent from persisting!
                const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
                ImGui::Indent(indentAmount);
                ImGui::TextUnformatted(txt);
                ImGui::Unindent(indentAmount);  // Reset indent!
            };
            helpers.drawAudioInputPin = [&](const char* label, int channel)
            {
                int attr = encodePinId({lid, channel, true});
                seenAttrs.insert(attr);
                availableAttrs.insert(attr);

                // Get pin data type for color coding
                PinID pinId = { lid, channel, true, false, "" };
                PinDataType pinType = this->getPinDataTypeForPin(pinId);
                unsigned int pinColor = this->getImU32ForType(pinType);

                bool isConnected = connectedInputAttrs.count(attr) > 0;
                ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                ImNodes::BeginInputAttribute(attr); ImGui::TextUnformatted(label); ImNodes::EndInputAttribute();

                // --- THIS IS THE DEFINITIVE FIX ---
                // Get the bounding box of the pin circle that was just drawn.
                ImVec2 pinMin = ImGui::GetItemRectMin();
                ImVec2 pinMax = ImGui::GetItemRectMax();
                // Calculate the exact center and cache it.
                float centerX = (pinMin.x + pinMax.x) * 0.5f;
                float centerY = (pinMin.y + pinMax.y) * 0.5f;
                attrPositions[attr] = ImVec2(centerX, centerY);
                // --- END OF FIX ---

                ImNodes::PopColorStyle(); // Restore default color

                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    if (isConnected) {
                        ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        // Find which output this input is connected to and show source info
                        for (const auto& c : synth->getConnectionsInfo())
                        {
                            bool isConnectedToThisPin = (!c.dstIsOutput && c.dstLogicalId == lid && c.dstChan == channel) || (c.dstIsOutput && lid == 0 && c.dstChan == channel);
                            if (isConnectedToThisPin)
                            {
                                if (auto* srcMod = synth->getModuleForLogical(c.srcLogicalId))
                                {
                                    float value = srcMod->getOutputChannelValue(c.srcChan);
                                    ImGui::Text("From %u:%d", c.srcLogicalId, c.srcChan);
                                    ImGui::Text("Value: %.3f", value);
                                }
                                break; 
                            }
                        }
                    } else {
                        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                    }
                    // Show pin data type
                    ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                    ImGui::EndTooltip();
                }
            };

                // NEW CLEAN OUTPUT PIN TEXT FUNCTION - FIXED SPACING
                helpers.drawAudioOutputPin = [&](const char* label, int channel)
                {
                    const int attr = encodePinId({(juce::uint32)lid, channel, false});
                    seenAttrs.insert(attr);
                    availableAttrs.insert(attr);

                    PinID pinId = {(juce::uint32)lid, channel, false, false, ""};
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(attr) > 0;

                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);

                    // EXACT OFFICIAL PATTERN: Text right-aligned, pin touches text edge
                    ImNodes::BeginOutputAttribute(attr);
                    const float label_width = ImGui::CalcTextSize(label).x;
                    ImGui::Indent(nodeContentWidth - label_width);  // Right-align to content width
                    ImGui::TextUnformatted(label);
                    ImGui::Unindent(nodeContentWidth - label_width);
                    ImNodes::EndOutputAttribute();

                    // Cache pin center
                    {
                        ImVec2 pinMin = ImGui::GetItemRectMin();
                        ImVec2 pinMax = ImGui::GetItemRectMax();
                        float centerY = (pinMin.y + pinMax.y) * 0.5f;
                        float x_pos   = pinMax.x;
                        attrPositions[attr] = ImVec2(x_pos, centerY);
                    }

                    ImNodes::PopColorStyle();

                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        if (isConnected) {
                            ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Connected");
                        } else {
                            ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Not Connected");
                        }
                        ImGui::Text("Type: %s", this->pinDataTypeToString(pinType));
                        if (auto* mp = synth->getModuleForLogical(lid))
                        {
                            float value = mp->getOutputChannelValue(channel);
                            ImGui::Text("Value: %.3f", value);
                        }
                        ImGui::EndTooltip();
                    }
                };

            // ADD THE NEW drawParallelPins HELPER
            helpers.drawParallelPins = [&](const char* inLabel, int inChannel, const char* outLabel, int outChannel)
            {
                // 3-column layout: [InputPin] [Right-aligned Output Label] [Output Pin]
                ImGui::PushID((inChannel << 16) ^ outChannel ^ lid);
                ImGui::Columns(3, "parallel_io_layout", false);

                const float pinW = 18.0f;
                const float spacing = ImGui::GetStyle().ItemSpacing.x;
                // CRITICAL FIX: Use stable nodeContentWidth to set ALL column widths explicitly
                // This prevents the feedback loop that causes position-dependent node scaling
                
                // Calculate column widths to fill exactly nodeContentWidth
                float inTextW = inLabel ? ImGui::CalcTextSize(inLabel).x : 0.0f;
                float inColW = inLabel ? (inTextW + pinW + spacing) : 0.0f;  // Input label + pin + spacing
                float outPinColW = 20.0f;  // Output pin column (fixed narrow width)
                float labelColW = nodeContentWidth - inColW - outPinColW - spacing;  // Middle fills remaining space

                ImGui::SetColumnWidth(0, inColW);
                ImGui::SetColumnWidth(1, labelColW);
                ImGui::SetColumnWidth(2, outPinColW);

                // Column 0: Input pin with label
                if (inLabel != nullptr)
                {
                    int inAttr = encodePinId({lid, inChannel, true});
                    seenAttrs.insert(inAttr);
                    availableAttrs.insert(inAttr);
                    PinID pinId = { lid, inChannel, true, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedInputAttrs.count(inAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginInputAttribute(inAttr);
                    ImGui::TextUnformatted(inLabel);
                    ImNodes::EndInputAttribute();
                    ImNodes::PopColorStyle();
                }

                // Column 1: Output label (right-aligned within this column)
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    // EXACT OFFICIAL PATTERN: Same as regular output pins
                    const float textW = ImGui::CalcTextSize(outLabel).x;
                    ImGui::Indent(labelColW - textW);  // Right-align to column width
                    ImGui::TextUnformatted(outLabel);
                    ImGui::Unindent(labelColW - textW);
                }

                // Column 2: Output pin
                ImGui::NextColumn();
                if (outLabel != nullptr)
                {
                    int outAttr = encodePinId({lid, outChannel, false});
                    seenAttrs.insert(outAttr);
                    availableAttrs.insert(outAttr);
                    PinID pinId = { lid, outChannel, false, false, "" };
                    PinDataType pinType = this->getPinDataTypeForPin(pinId);
                    unsigned int pinColor = this->getImU32ForType(pinType);
                    bool isConnected = connectedOutputAttrs.count(outAttr) > 0;
                    ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
                    ImNodes::BeginOutputAttribute(outAttr);
                    ImGui::Dummy(ImVec2(1.0f, ImGui::GetTextLineHeight()));
                    ImNodes::EndOutputAttribute();

                    // Cache pin center
                    ImVec2 pinMin = ImGui::GetItemRectMin();
                    ImVec2 pinMax = ImGui::GetItemRectMax();
                    float yCenter = pinMin.y + (pinMax.y - pinMin.y) * 0.5f;
                    float xPos = pinMax.x;
                    attrPositions[outAttr] = ImVec2(xPos, yCenter);
                    ImNodes::PopColorStyle();
                }

                // Restore to single column for the next row
                ImGui::Columns(1);
                ImGui::PopID();
            };

            // --- DYNAMIC PIN FIX ---
            // Add a new helper that uses dynamic pin information from modules
            helpers.drawIoPins = [&](ModuleProcessor* module) {
                if (!module) return;
                const auto logicalId = module->getLogicalId();
                const auto moduleType = synth->getModuleTypeForLogical(logicalId);

                // 1. Get dynamic pins from the module itself.
                auto dynamicInputs = module->getDynamicInputPins();
                auto dynamicOutputs = module->getDynamicOutputPins();

                // 2. Get static pins from the database as a fallback.
                const auto& pinDb = getModulePinDatabase();
                auto pinInfoIt = pinDb.find(moduleType.toLowerCase());
                const bool hasStaticPinInfo = (pinInfoIt != pinDb.end());
                const auto& staticPinInfo = hasStaticPinInfo ? pinInfoIt->second : ModulePinInfo{};

                // 3. If the module has dynamic pins, use the new system
                const bool hasDynamicPins = !dynamicInputs.empty() || !dynamicOutputs.empty();
                
                if (hasDynamicPins)
                {
                    // Draw inputs (dynamic if available, otherwise static)
                    if (!dynamicInputs.empty())
                    {
                        for (const auto& pin : dynamicInputs)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioIns)
                        {
                            helpers.drawAudioInputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    
                    // Draw outputs (dynamic if available, otherwise static)
                    if (!dynamicOutputs.empty())
                    {
                        for (const auto& pin : dynamicOutputs)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                    else
                    {
                        for (const auto& pin : staticPinInfo.audioOuts)
                        {
                            helpers.drawAudioOutputPin(pin.name.toRawUTF8(), pin.channel);
                        }
                    }
                }
                else
                {
                    // 4. Otherwise, fall back to the module's custom drawIoPins implementation
                    module->drawIoPins(helpers);
                }
            };
            // --- END OF DYNAMIC PIN FIX ---

            // Delegate per-module IO pin drawing
            if (synth != nullptr)
                if (auto* mp = synth->getModuleForLogical (lid))
                    helpers.drawIoPins(mp);

            // Optional per-node right-click popup
            if (ImGui::IsItemHovered() && ImGui::IsMouseReleased(ImGuiMouseButton_Right))
            {
                selectedLogicalId = (int) lid;
                ImGui::OpenPopup("NodeActionPopup");
            }

            // Legacy per-type IO drawing removed; delegated to module implementations via helpers

            ImNodes::EndNode();
            
            // Cache position for snapshot safety
            // Graph is always in consistent state since we rebuild at frame start
            lastKnownNodePositions[(int)lid] = ImNodes::GetNodeGridSpacePos((int)lid);
            
            // Pop muted node styles (in reverse order of push)
            if (isMuted) {
                ImNodes::PopColorStyle();      // Mute TitleBar
                ImGui::PopStyleVar();          // Alpha
                ImNodes::PopStyleVar();        // NodePadding
            }
            
            // Pop hover highlight color
            if (isHoveredSource || isHoveredDest)
                ImNodes::PopColorStyle();      // Hover TitleBar
            
            // Pop category colors (in reverse order of push)
            ImNodes::PopColorStyle();          // TitleBarSelected
            ImNodes::PopColorStyle();          // TitleBarHovered
            ImNodes::PopColorStyle();          // TitleBar
            
            // Apply pending placement if queued
            if (auto itS = pendingNodeScreenPositions.find((int) lid); itS != pendingNodeScreenPositions.end())
            {
                ImNodes::SetNodeScreenSpacePos((int) lid, itS->second);
                pendingNodeScreenPositions.erase(itS);
            }
        if (auto it = pendingNodePositions.find((int) lid); it != pendingNodePositions.end())
        {
            // Apply saved position once; do not write (0,0) defaults
            const ImVec2 p = it->second;
            if (!(p.x == 0.0f && p.y == 0.0f))
            {
                ImNodes::SetNodeGridSpacePos((int) lid, p);
                juce::Logger::writeToLog("[PositionRestore] Applied pending position for node " + juce::String((int)lid) + ": (" + juce::String(p.x) + ", " + juce::String(p.y) + ")");
            }
            pendingNodePositions.erase(it);
        }
            // Apply pending size if queued (for Comment nodes to prevent feedback loop)
            if (auto itSize = pendingNodeSizes.find((int) lid); itSize != pendingNodeSizes.end())
            {
                // Store the desired size in the Comment module itself
                if (auto* comment = dynamic_cast<CommentModuleProcessor*>(synth->getModuleForLogical((juce::uint32)lid)))
                {
                    comment->nodeWidth = itSize->second.x;
                    comment->nodeHeight = itSize->second.y;
                }
                pendingNodeSizes.erase(itSize);
            }
            drawnNodes.insert((int) lid);
        }

        // Node action popup (Delete / Duplicate)
        bool triggerInsertMixer = false;
        if (ImGui::BeginPopup("NodeActionPopup"))
        {
            if (ImGui::MenuItem("Delete") && selectedLogicalId != 0 && selectedLogicalId != 999)
            {
                mutedNodeStates.erase((juce::uint32)selectedLogicalId); // Clean up muted state if exists
                synth->removeModule (synth->getNodeIdForLogical ((juce::uint32) selectedLogicalId));
                graphNeedsRebuild = true;
                // Post-state snapshot
                pushSnapshot();
                selectedLogicalId = 0;
            }
            if (ImGui::MenuItem("Duplicate") && selectedLogicalId != 0)
            {
                const juce::String type = getTypeForLogical ((juce::uint32) selectedLogicalId);
                if (! type.isEmpty())
                {
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    if (auto* src = synth->getModuleForLogical ((juce::uint32) selectedLogicalId))
                        if (auto* dst = synth->getModuleForLogical (synth->getLogicalIdForNode(newNodeId)))
                            dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos (selectedLogicalId);
                    ImNodes::SetNodeGridSpacePos ((int) synth->getLogicalIdForNode(newNodeId), ImVec2 (pos.x + 40.0f, pos.y + 40.0f));
                    // Post-state snapshot after duplication and position
                    pushSnapshot();
                }
            }
            if (ImGui::MenuItem("Insert Mixer", "Ctrl+T") && selectedLogicalId != 0) { triggerInsertMixer = true; }
            ImGui::EndPopup();
        }

        // Shortcut: Ctrl+T to insert a Mixer after selected node and reroute
        // Debounced Ctrl+T
        const bool ctrlDown = ImGui::GetIO().KeyCtrl;
        if (!ctrlDown) {
            mixerShortcutCooldown = false;
            insertNodeShortcutCooldown = false;
        }
        // Ctrl+R: Record Output
        if (ctrlDown && ImGui::IsKeyPressed(ImGuiKey_R, false))
        {
            handleRecordOutput();
        }
        
        if ((triggerInsertMixer || (selectedLogicalId != 0 && ctrlDown && ImGui::IsKeyPressed(ImGuiKey_T))) && !mixerShortcutCooldown)
        {
            mixerShortcutCooldown = true; // Prevent re-triggering in the same frame
            const juce::uint32 srcLid = (juce::uint32) selectedLogicalId;

            juce::Logger::writeToLog("--- [InsertMixer] Start ---");
            juce::Logger::writeToLog("[InsertMixer] Selected Node Logical ID: " + juce::String(srcLid));

            auto srcNodeId = synth->getNodeIdForLogical(srcLid);
            if (srcNodeId.uid == 0) 
            {
                juce::Logger::writeToLog("[InsertMixer] ABORT: Source node with logical ID " + juce::String(srcLid) + " is invalid or could not be found.");
            } 
            else 
            {
                // 1. Collect all outgoing connections from the selected node
                std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
                for (const auto& c : synth->getConnectionsInfo()) {
                    if (c.srcLogicalId == srcLid) {
                        outgoingConnections.push_back(c);
                    }
                }
                juce::Logger::writeToLog("[InsertMixer] Found " + juce::String(outgoingConnections.size()) + " outgoing connections to reroute.");
                for (const auto& c : outgoingConnections) {
                    juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                    juce::Logger::writeToLog("  - Stored connection: [Src: " + juce::String(c.srcLogicalId) + ":" + juce::String(c.srcChan) + "] -> [Dst: " + destStr + ":" + juce::String(c.dstChan) + "]");
                }

                // 2. Create and position the new mixer node intelligently
                auto mixNodeIdGraph = synth->addModule("mixer");
                const juce::uint32 mixLid = synth->getLogicalIdForNode(mixNodeIdGraph);
                
                ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(selectedLogicalId);
                ImVec2 avgDestPos = srcPos; // Default to source pos if no outputs
                
                if (!outgoingConnections.empty())
                {
                    float totalX = 0.0f, totalY = 0.0f;
                    for (const auto& c : outgoingConnections)
                    {
                        int destId = c.dstIsOutput ? 0 : (int)c.dstLogicalId;
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos(destId);
                        totalX += pos.x;
                        totalY += pos.y;
                    }
                    avgDestPos = ImVec2(totalX / outgoingConnections.size(), totalY / outgoingConnections.size());
                }
                else
                {
                    // If there are no outgoing connections, place it to the right
                    avgDestPos.x += 600.0f;
                }
                
                // Place the new mixer halfway between the source and the average destination
                pendingNodePositions[(int)mixLid] = ImVec2((srcPos.x + avgDestPos.x) * 0.5f, (srcPos.y + avgDestPos.y) * 0.5f);
                juce::Logger::writeToLog("[InsertMixer] Added new Mixer. Logical ID: " + juce::String(mixLid) + ", Node ID: " + juce::String(mixNodeIdGraph.uid));

                // 3. Disconnect all original outgoing links
                juce::Logger::writeToLog("[InsertMixer] Disconnecting original links...");
                for (const auto& c : outgoingConnections) {
                    auto currentSrcNodeId = synth->getNodeIdForLogical(c.srcLogicalId);
                    auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);

                    if (currentSrcNodeId.uid != 0 && dstNodeId.uid != 0) {
                        bool success = synth->disconnect(currentSrcNodeId, c.srcChan, dstNodeId, c.dstChan);
                        juce::Logger::writeToLog("  - Disconnecting [" + juce::String(currentSrcNodeId.uid) + ":" + juce::String(c.srcChan) + "] -> [" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                    } else {
                        juce::Logger::writeToLog("  - SKIPPING Disconnect due to invalid node ID.");
                    }
                }

                // 4. Connect the source node to the new mixer's first input
                juce::Logger::writeToLog("[InsertMixer] Connecting source node to new mixer...");
                bool c1 = synth->connect(srcNodeId, 0, mixNodeIdGraph, 0); // L to In A L
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":0] -> [" + juce::String(mixNodeIdGraph.uid) + ":0]... " + (c1 ? "SUCCESS" : "FAILED"));
                bool c2 = synth->connect(srcNodeId, 1, mixNodeIdGraph, 1); // R to In A R
                juce::Logger::writeToLog("  - Connecting [" + juce::String(srcNodeId.uid) + ":1] -> [" + juce::String(mixNodeIdGraph.uid) + ":1]... " + (c2 ? "SUCCESS" : "FAILED"));


                // 5. Connect the mixer's output to all the original destinations (maintaining the chain)
                juce::Logger::writeToLog("[InsertMixer] Connecting mixer to original destinations to maintain chain...");
                if (outgoingConnections.empty()) {
                    juce::Logger::writeToLog("  - No original outgoing connections. Connecting mixer to Main Output by default.");
                    auto outNode = synth->getOutputNodeID();
                    if (outNode.uid != 0) {
                        bool o1 = synth->connect(mixNodeIdGraph, 0, outNode, 0);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":0] -> [Output:0]... " + (o1 ? "SUCCESS" : "FAILED"));
                        bool o2 = synth->connect(mixNodeIdGraph, 1, outNode, 1);
                        juce::Logger::writeToLog("  - Connecting [" + juce::String(mixNodeIdGraph.uid) + ":1] -> [Output:1]... " + (o2 ? "SUCCESS" : "FAILED"));
                    }
                } else {
                    for (const auto& c : outgoingConnections) {
                        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                        if (dstNodeId.uid != 0) {
                            // Connect mixer output to the same destination the original node was connected to
                            // This maintains the chain: original -> mixer -> destination
                            bool success = synth->connect(mixNodeIdGraph, c.srcChan, dstNodeId, c.dstChan);
                            juce::String destStr = c.dstIsOutput ? "Main Output" : "Node " + juce::String(c.dstLogicalId);
                            juce::Logger::writeToLog("  - Maintaining chain: Mixer [" + juce::String(mixNodeIdGraph.uid) + ":" + juce::String(c.srcChan) + "] -> " + destStr + "[" + juce::String(dstNodeId.uid) + ":" + juce::String(c.dstChan) + "]... " + (success ? "SUCCESS" : "FAILED"));
                        } else {
                            juce::Logger::writeToLog("  - SKIPPING Reconnect due to invalid destination node ID for original logical ID " + juce::String(c.dstLogicalId));
                        }
                    }
                }

                graphNeedsRebuild = true;
                pushSnapshot(); // Make the entire operation undoable
                juce::Logger::writeToLog("[InsertMixer] Rerouting complete. Flagging for graph rebuild.");
            }
            juce::Logger::writeToLog("--- [InsertMixer] End ---");
        }

        // Shortcut: Ctrl+I to show Insert Node popup menu
        if (selectedLogicalId != 0 && ctrlDown && ImGui::IsKeyPressed(ImGuiKey_I) && !insertNodeShortcutCooldown)
        {
            insertNodeShortcutCooldown = true;
            showInsertNodePopup = true;
        }

        // Insert Node popup menu
        if (showInsertNodePopup)
        {
            ImGui::OpenPopup("InsertNodePopup");
            showInsertNodePopup = false;
        }

        if (ImGui::BeginPopup("InsertNodePopup"))
        {
            ImGui::Text("Insert Node Between Connections");
            
            // Audio Path
            if (ImGui::MenuItem("VCF")) { insertNodeBetween("VCF"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("VCA")) { insertNodeBetween("VCA"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Delay")) { insertNodeBetween("Delay"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Reverb")) { insertNodeBetween("Reverb"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Mixer")) { insertNodeBetween("Mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Recorder")) { insertNodeBetween("recorder"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Shaping Oscillator")) { insertNodeBetween("shaping oscillator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("8-Band Shaper")) { insertNodeBetween("8bandshaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Granulator")) { insertNodeBetween("Granulator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Harmonic Shaper")) { insertNodeBetween("harmonic shaper"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Vocal Tract Filter")) { insertNodeBetween("Vocal Tract Filter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Scope")) { insertNodeBetween("Scope"); ImGui::CloseCurrentPopup(); }
            
            ImGui::Separator();
            
            // Modulation Path
            if (ImGui::MenuItem("Attenuverter")) { insertNodeBetween("Attenuverter"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Math")) { insertNodeBetween("Math"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Comparator")) { insertNodeBetween("Comparator"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("CV Mixer")) { insertNodeBetween("CV Mixer"); ImGui::CloseCurrentPopup(); }
            if (ImGui::MenuItem("Sequential Switch")) { insertNodeBetween("Sequential Switch"); ImGui::CloseCurrentPopup(); }
            
            ImGui::EndPopup();
        }

        // Output sink node with stereo inputs (single, fixed ID 0)
        const bool isOutputHovered = (hoveredLinkDstId == kOutputHighlightId);
        if (isOutputHovered)
            ImNodes::PushColorStyle(ImNodesCol_TitleBar, IM_COL32(255, 220, 0, 255));
        ImNodes::BeginNode (0);
        ImNodes::BeginNodeTitleBar();
        ImGui::TextUnformatted ("Output");
        ImNodes::EndNodeTitleBar();
        if (isOutputHovered)
            ImNodes::PopColorStyle();
        
        // In L pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 0, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 0, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
            ImGui::Text ("In L");
            ImNodes::EndInputAttribute();
            ImNodes::PopColorStyle();
        }
        
        // In R pin with proper Audio type coloring (green)
        { 
            int a = encodePinId({0, 1, true}); 
            seenAttrs.insert(a); 
            availableAttrs.insert(a); 
            bool isConnected = connectedInputAttrs.count(a) > 0;
            PinID pinId = {0, 1, true, false, ""};
            PinDataType pinType = getPinDataTypeForPin(pinId);
            unsigned int pinColor = getImU32ForType(pinType);
            ImNodes::PushColorStyle(ImNodesCol_Pin, isConnected ? colPinConnected : pinColor);
            ImNodes::BeginInputAttribute (a);
            ImGui::Text ("In R");
            ImNodes::EndInputAttribute();
            ImNodes::PopColorStyle();
        }
        
        ImNodes::EndNode();
        
        // Cache output node position for snapshot safety
        // Graph is always in consistent state since we rebuild at frame start
        lastKnownNodePositions[0] = ImNodes::GetNodeGridSpacePos(0);
        
        if (auto it = pendingNodePositions.find(0); it != pendingNodePositions.end())
        {
            ImNodes::SetNodeGridSpacePos(0, it->second);
            juce::Logger::writeToLog("[PositionRestore] Applied pending position for output node 0: (" + juce::String(it->second.x) + ", " + juce::String(it->second.y) + ")");
            pendingNodePositions.erase(it);
        }
        drawnNodes.insert(0);

        // Use last frame's hovered node id for highlighting (queried after EndNodeEditor)
        int hoveredNodeId = lastHoveredNodeId;

        // Draw existing audio connections (IDs stable via bitmasking)
        int cableIdx = 0;
        for (const auto& c : synth->getConnectionsInfo())
        {
            
            // Skip links whose nodes weren't drawn this frame (e.g., just deleted)
            if (c.srcLogicalId != 0 && ! drawnNodes.count((int) c.srcLogicalId)) {
                continue;
            }
            if (! c.dstIsOutput && c.dstLogicalId != 0 && ! drawnNodes.count((int) c.dstLogicalId)) {
                continue;
            }
            
            const int srcAttr = encodePinId({c.srcLogicalId, c.srcChan, false});
            const int dstAttr = c.dstIsOutput ? encodePinId({0, c.dstChan, true}) : encodePinId({c.dstLogicalId, c.dstChan, true});
            
            if (! availableAttrs.count(srcAttr) || ! availableAttrs.count(dstAttr))
            {
                static std::unordered_set<std::string> skipOnce;
                const std::string key = std::to_string((int)c.srcLogicalId) + ":" + std::to_string(c.srcChan) + "->" +
                                         (c.dstIsOutput? std::string("0") : std::to_string((int)c.dstLogicalId)) + ":" + std::to_string(c.dstChan);
                if (skipOnce.insert(key).second)
                {
                    juce::Logger::writeToLog(
                        juce::String("[ImNodes][SKIP] missing attr: srcPresent=") + (availableAttrs.count(srcAttr)?"1":"0") +
                        " dstPresent=" + (availableAttrs.count(dstAttr)?"1":"0") +
                        " srcKey=(lid=" + juce::String((int)c.srcLogicalId) + ",ch=" + juce::String(c.srcChan) + ")" +
                        " dstKey=(lid=" + juce::String(c.dstIsOutput?0:(int)c.dstLogicalId) + ",ch=" + juce::String(c.dstChan) + ",in=1) id(s)=" +
                        juce::String(srcAttr) + "," + juce::String(dstAttr));
                }
                continue;
            }
            
            const int linkId = linkIdOf(srcAttr, dstAttr);
            linkIdToAttrs[linkId] = { srcAttr, dstAttr };
            
            // --- THIS IS THE DEFINITIVE FIX ---
            // 1. Determine the base color and check for signal activity.
            auto srcPin = decodePinId(srcAttr);
            PinDataType linkDataType = getPinDataTypeForPin(srcPin);
            ImU32 linkColor = getImU32ForType(linkDataType);
            float magnitude = 0.0f;
            bool hasThicknessModification = false;

            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
            {
                magnitude = srcModule->getOutputChannelValue(srcPin.channel);
            }

            // 2. If the signal is active, calculate a glowing/blinking color.
            if (magnitude > 0.01f)
            {
                const float blinkSpeed = 8.0f;
                float blinkFactor = (std::sin((float)ImGui::GetTime() * blinkSpeed) + 1.0f) * 0.5f;
                float glowIntensity = juce::jlimit(0.0f, 1.0f, blinkFactor * magnitude * 2.0f);

                // Brighten the base color and modulate alpha for glow effect
                ImVec4 colorVec = ImGui::ColorConvertU32ToFloat4(linkColor);
                colorVec.x = juce::jmin(1.0f, colorVec.x + glowIntensity * 0.4f);
                colorVec.y = juce::jmin(1.0f, colorVec.y + glowIntensity * 0.4f);
                colorVec.z = juce::jmin(1.0f, colorVec.z + glowIntensity * 0.4f);
                colorVec.w = juce::jlimit(0.5f, 1.0f, 0.5f + glowIntensity * 0.5f);
                linkColor = ImGui::ColorConvertFloat4ToU32(colorVec);

                // Make active cables slightly thicker
                ImNodes::PushStyleVar(ImNodesStyleVar_LinkThickness, 3.0f);
                hasThicknessModification = true;
            }

            // 3. Push the chosen color (either normal or glowing) to the style stack.
            ImNodes::PushColorStyle(ImNodesCol_Link, linkColor);
            ImNodes::PushColorStyle(ImNodesCol_LinkHovered, IM_COL32(255, 255, 0, 255));
            ImNodes::PushColorStyle(ImNodesCol_LinkSelected, IM_COL32(255, 255, 0, 255));

            // 4. Check for node hover highlight (this should override the glow).
            const bool hl = (hoveredNodeId != -1) && ((int) c.srcLogicalId == hoveredNodeId || (! c.dstIsOutput && (int) c.dstLogicalId == hoveredNodeId) || (c.dstIsOutput && hoveredNodeId == 0));
            if (hl)
            {
                ImNodes::PushColorStyle(ImNodesCol_Link, IM_COL32(255, 255, 0, 255));
            }
            
            // 5. Tell imnodes to draw the link. It will use the color we just pushed.
            ImNodes::Link(linkId, srcAttr, dstAttr);
            
            // 6. Pop ALL style modifications to restore the defaults for the next link.
            if (hl) ImNodes::PopColorStyle();
            ImNodes::PopColorStyle(); // LinkSelected
            ImNodes::PopColorStyle(); // LinkHovered
            ImNodes::PopColorStyle(); // Link
            if (hasThicknessModification) ImNodes::PopStyleVar(); // LinkThickness
            
            // --- END OF FIX ---
        }

        // Drag detection for node movement: snapshot once on mouse release (post-state)
        const bool hoveringNode = (lastHoveredNodeId != -1);
        if (hoveringNode && ImGui::IsMouseDragging(ImGuiMouseButton_Left))
        {
            isDraggingNode = true;
        }
        if (isDraggingNode && ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            isDraggingNode = false;
            // Capture positions after a move so subsequent operations (e.g. delete) undo to the moved location
            pushSnapshot();
        }
    }

    // --- Handle Auto-Connect Requests from MIDI Players ---
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
        {
            // Check for initial button presses
            if (midiPlayer->autoConnectTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Samplers;
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO;
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            else if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                midiPlayer->lastAutoConnectState = MIDIPlayerModuleProcessor::AutoConnectState::Hybrid;
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                pushSnapshot();
            }
            // --- THIS IS THE NEW LOGIC ---
            // Check if an update was requested after a new file was loaded
            else if (midiPlayer->connectionUpdateRequested.exchange(false))
            {
                // Re-run the correct handler based on the saved state
                switch (midiPlayer->lastAutoConnectState.load())
                {
                    case MIDIPlayerModuleProcessor::AutoConnectState::Samplers:
                        handleMidiPlayerAutoConnect(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::PolyVCO:
                        handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::Hybrid:
                        handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first);
                        pushSnapshot();
                        break;
                    case MIDIPlayerModuleProcessor::AutoConnectState::None:
                    default:
                        // Do nothing if it wasn't auto-connected before
                        break;
                }
            }
            // --- END OF NEW LOGIC ---
        }
    }

    // --- Handle Auto-Connect Requests using new intelligent system ---
    handleAutoConnectionRequests();

    ImNodes::MiniMap (0.2f, ImNodesMiniMapLocation_BottomRight);

    ImNodes::EndNodeEditor();
    
    // ================== MIDI PLAYER QUICK CONNECT LOGIC ==================
    // Poll all MIDI Player modules for connection requests
    if (synth != nullptr)
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                int requestType = midiPlayer->getAndClearConnectionRequest();
                if (requestType > 0)
                {
                    handleMIDIPlayerConnectionRequest(modInfo.first, midiPlayer, requestType);
                    break; // Only handle one request per frame
                }
            }
        }
    }
    // ================== END MIDI PLAYER QUICK CONNECT ==================
    
    // ================== META MODULE EDITING LOGIC ==================
    // Check if any Meta Module has requested to be edited
    if (synth != nullptr && metaModuleToEditLid == 0) // Only check if not already editing one
    {
        for (const auto& modInfo : synth->getModulesInfo())
        {
            if (auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(modInfo.first)))
            {
                // Atomically check and reset the flag
                if (metaModule->editRequested.exchange(false))
                {
                    metaModuleToEditLid = modInfo.first;
                    juce::Logger::writeToLog("[MetaEdit] Opening editor for Meta Module L-ID " + juce::String((int)metaModuleToEditLid));
                    ImGui::OpenPopup("Edit Meta Module");
                    break; // Only handle one request per frame
                }
            }
        }
    }
    
    // Draw the modal popup for the internal editor if one is selected
    if (metaModuleToEditLid != 0)
    {
        ImGui::SetNextWindowSize(ImVec2(1200, 800), ImGuiCond_FirstUseEver);
        if (ImGui::BeginPopupModal("Edit Meta Module", nullptr, ImGuiWindowFlags_MenuBar))
        {
            // Get the internal synth processor from the meta module
            auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaModuleToEditLid));
            if (metaModule && metaModule->getInternalGraph())
            {
                // Display a placeholder for now
                // TODO: Full recursive editor implementation would go here
                ImGui::Text("Editing internal graph of Meta Module %d", (int)metaModuleToEditLid);
                ImGui::Separator();
                
                auto* internalGraph = metaModule->getInternalGraph();
                auto modules = internalGraph->getModulesInfo();
                
                ImGui::Text("Internal modules: %d", (int)modules.size());
                if (ImGui::BeginChild("ModuleList", ImVec2(0, -30), true))
                {
                    for (const auto& [lid, type] : modules)
                    {
                        ImGui::Text("  [%d] %s", (int)lid, type.toRawUTF8());
                    }
                }
                ImGui::EndChild();
                
                ImGui::Text("NOTE: Full nested editor UI is a TODO");
                ImGui::Text("For now, you can inspect the internal graph structure above.");
            }
            
            if (ImGui::Button("Close"))
            {
                ImGui::CloseCurrentPopup();
                metaModuleToEditLid = 0;
                // When closing, the meta module might have new/removed inlets/outlets,
                // so we need to rebuild the main graph to update its pins
                graphNeedsRebuild = true;
            }
            ImGui::EndPopup();
        }
        else
        {
            // If the popup was closed by the user (e.g., pressing ESC)
            metaModuleToEditLid = 0;
            graphNeedsRebuild = true;
        }
    }
    // ======================= END OF META MODULE LOGIC =======================

    // --- CONSOLIDATED HOVERED LINK DETECTION ---
    // Declare these variables ONCE, immediately after the editor has ended.
    // All subsequent features that need to know about hovered links can now
    // safely reuse these results without causing redefinition or scope errors.
    // Graph is always in consistent state since we rebuild at frame start
    int hoveredLinkId = -1;
    bool isLinkHovered = ImNodes::IsLinkHovered(&hoveredLinkId);
    // --- END OF CONSOLIDATED DECLARATION ---
    
    // Smart cable visualization is now integrated directly into the link drawing loop above.
    // No separate overlay needed - cables glow by modifying their own color.
    
    // === PROBE TOOL MODE HANDLING ===
    if (isProbeModeActive)
    {
        // Change cursor to indicate probe mode is active
        ImGui::SetMouseCursor(ImGuiMouseCursor_Hand);
        
        // Draw "PROBE ACTIVE" indicator at mouse position
        auto* drawList = ImGui::GetForegroundDrawList();
        ImVec2 mousePos = ImGui::GetMousePos();
        const char* text = "PROBE MODE: Click output pin";
        auto textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImVec2(mousePos.x + 20, mousePos.y - 20);
        drawList->AddRectFilled(
            ImVec2(textPos.x - 5, textPos.y - 2),
            ImVec2(textPos.x + textSize.x + 5, textPos.y + textSize.y + 2),
            IM_COL32(50, 50, 50, 200)
        );
        drawList->AddText(textPos, IM_COL32(255, 255, 100, 255), text);
        
        // Check for pin clicks
        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                auto pinId = decodePinId(hoveredPinId);
                // Check if it's an output pin (not input, not mod)
                if (!pinId.isInput && !pinId.isMod && pinId.logicalId != 0)
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on valid output pin. LogicalID: " + juce::String(pinId.logicalId) + ", Channel: " + juce::String(pinId.channel));
                    auto nodeId = synth->getNodeIdForLogical(pinId.logicalId);
                    synth->setProbeConnection(nodeId, pinId.channel);
                    isProbeModeActive = false; // Deactivate after probing
                }
                else
                {
                    juce::Logger::writeToLog("[PROBE_UI] Probe clicked on an invalid pin (input or output node). Cancelling.");
                    isProbeModeActive = false;
                }
            }
            else
            {
                // Clicked on empty space, cancel probe mode
                juce::Logger::writeToLog("[PROBE_UI] Probe clicked on empty space. Cancelling.");
                isProbeModeActive = false;
            }
        }
        
        // Allow ESC to cancel probe mode
        if (ImGui::IsKeyPressed(ImGuiKey_Escape))
        {
            isProbeModeActive = false;
            juce::Logger::writeToLog("[PROBE_UI] Cancelled with ESC");
        }
    }

    // --- CONTEXTUAL RIGHT-CLICK HANDLER ---
    // A cable was right-clicked. Store its info and open the insert popup.
    if (isLinkHovered && hoveredLinkId != -1 && ImGui::IsMouseClicked(ImGuiMouseButton_Right))
    {
        juce::Logger::writeToLog("[InsertNode][RC] Hovered link id=" + juce::String(hoveredLinkId));
        // A cable was right-clicked. Store its info and open the insert popup.
        linkToInsertOn = {}; // Reset previous info
        linkToInsertOn.linkId = hoveredLinkId;

        bool captured = false;
        // TODO: Implement modulation link detection for new bus-based system
        // if (modLinkIdToRoute.count(hoveredLinkId))
        // {
        //     linkToInsertOn.isMod = true;
        //     auto& route = modLinkIdToRoute[hoveredLinkId];
        //     linkToInsertOn.srcLogicalId = std::get<0>(route);
        //     linkToInsertOn.srcChan = std::get<1>(route);
        //     linkToInsertOn.dstLogicalId = std::get<2>(route);
        //     linkToInsertOn.paramId = std::get<3>(route);
        //     juce::Logger::writeToLog("[InsertNode][RC] Mod link captured: srcLID=" + juce::String((int)linkToInsertOn.srcLogicalId) +
        //                               " srcChan=" + juce::String(linkToInsertOn.srcChan) +
        //                               " dstLID=" + juce::String((int)linkToInsertOn.dstLogicalId) +
        //                               " param='" + linkToInsertOn.paramId + "'");
        //     captured = true;
        // }
        if (linkIdToAttrs.count(hoveredLinkId))
        {
            linkToInsertOn.isMod = false;
            auto& attrs = linkIdToAttrs[hoveredLinkId];
            juce::Logger::writeToLog("[InsertNode][RC] Audio link attrs: srcAttr=" + juce::String(attrs.first) +
                                      " dstAttr=" + juce::String(attrs.second));
            linkToInsertOn.srcPin = decodePinId(attrs.first);
            linkToInsertOn.dstPin = decodePinId(attrs.second);
            // Decide list based on pin data types (treat CV/Gate/Raw/Video as modulation list)
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw ||
                srcType == PinDataType::Video || dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = true;
            }
            juce::Logger::writeToLog("[InsertNode][RC] Audio pins: src(lid=" + juce::String((int)linkToInsertOn.srcPin.logicalId) +
                                      ",ch=" + juce::String(linkToInsertOn.srcPin.channel) +
                                      ",in=" + juce::String((int)linkToInsertOn.srcPin.isInput) + ") -> dst(lid=" +
                                      juce::String((int)linkToInsertOn.dstPin.logicalId) + ",ch=" +
                                      juce::String(linkToInsertOn.dstPin.channel) + ",in=" +
                                      juce::String((int)linkToInsertOn.dstPin.isInput) + ")");
            captured = true;
        }
        else
        {
            juce::Logger::writeToLog("[InsertNode][RC] Link id not found in maps");
        }

        if (captured)
        {
            showInsertNodePopup = true; // defer opening until after EndNodeEditor
            pendingInsertLinkId = hoveredLinkId;
            juce::Logger::writeToLog("[InsertNode][RC] Will open popup after EndNodeEditor");
        }
        else
        {
            linkToInsertOn.linkId = -1; // nothing recognized; do not open
        }
    }

    // --- Keyboard Shortcuts for Node Chaining ---
    // Check if multiple nodes are selected and no modifiers are held
    if (ImNodes::NumSelectedNodes() > 1 && !ImGui::GetIO().KeyCtrl && !ImGui::GetIO().KeyShift && !ImGui::GetIO().KeyAlt)
    {
        // C: Standard stereo chaining (channels 0->0, 1->1)
        if (ImGui::IsKeyPressed(ImGuiKey_C))
        {
            handleNodeChaining();
        }
        // G: Audio type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_G))
        {
            handleColorCodedChaining(PinDataType::Audio);
        }
        // B: CV type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_B))
        {
            handleColorCodedChaining(PinDataType::CV);
        }
        // R: Raw type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_R))
        {
            handleColorCodedChaining(PinDataType::Raw);
        }
        // Y: Gate type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_Y))
        {
            handleColorCodedChaining(PinDataType::Gate);
        }
        // V: Video type chaining
        else if (ImGui::IsKeyPressed(ImGuiKey_V))
        {
            handleColorCodedChaining(PinDataType::Video);
        }
    }
    // --- END OF KEYBOARD SHORTCUTS ---

    // --- Cable Splitting (Ctrl+Middle-Click) ---
    if (isLinkHovered && hoveredLinkId != -1)
    {
        if (ImGui::GetIO().KeyCtrl && ImGui::IsMouseClicked(ImGuiMouseButton_Middle))
        {
            // User initiated a split. Find the source pin of the hovered link.
            if (auto it = linkIdToAttrs.find(hoveredLinkId); it != linkIdToAttrs.end())
            {
                splittingFromAttrId = it->second.first; // The source attribute ID
                juce::Logger::writeToLog("[CableSplit] Starting split from attr ID: " + juce::String(splittingFromAttrId));
            }
        }
    }
    // --- END OF CABLE SPLITTING ---

    // 2. If a split-drag is active, handle drawing and completion.
    if (splittingFromAttrId != -1)
    {
        // Draw a line from the source pin to the mouse cursor for visual feedback.
        if (auto it = attrPositions.find(splittingFromAttrId); it != attrPositions.end())
        {
            ImVec2 sourcePos = it->second;
            ImVec2 mousePos = ImGui::GetMousePos();
            ImGui::GetForegroundDrawList()->AddLine(sourcePos, mousePos, IM_COL32(255, 255, 0, 200), 3.0f);
        }

        // 3. Handle completion or cancellation of the drag.
        // We use Left-click to complete the link, matching ImNodes' default behavior.
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
        {
            int hoveredPinId = -1;
            if (ImNodes::IsPinHovered(&hoveredPinId) && hoveredPinId != -1)
            {
                // User dropped the link on a pin.
                auto srcPin = decodePinId(splittingFromAttrId);
                auto dstPin = decodePinId(hoveredPinId);

                // Ensure the connection is valid (Output -> Input).
                if (!srcPin.isInput && dstPin.isInput)
                {
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    graphNeedsRebuild = true;
                    pushSnapshot(); // Make it undoable
                }
            }

            // ALWAYS reset the state, whether the connection was successful or not.
            splittingFromAttrId = -1;
        }
        // Also allow cancellation with a right-click.
        else if (ImGui::IsMouseReleased(ImGuiMouseButton_Right))
        {
            splittingFromAttrId = -1; // Cancel the operation.
        }
    }
    // --- END OF NEW LOGIC ---

    // Open popup now (outside editor) if requested this frame
    if (showInsertNodePopup)
    {
        showInsertNodePopup = false;
        // Validate the link still exists
        if (pendingInsertLinkId != -1)
        {
            bool stillValid = (/* modLinkIdToRoute.count(pendingInsertLinkId) || */ linkIdToAttrs.count(pendingInsertLinkId));
            if (!stillValid)
            {
                juce::Logger::writeToLog("[InsertNode] Skipping popup: link disappeared this frame");
                pendingInsertLinkId = -1;
            }
        }
        if (pendingInsertLinkId != -1)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            // Consume the mouse release/click so the popup stays open
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode] Opened popup (post-editor)");
        }
        else
        {
            linkToInsertOn = {}; // safety
        }
        pendingInsertLinkId = -1;
    }

    // Fallback: If user right-clicked and a link was hovered this frame, open popup using cached hover
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Right)
        && lastHoveredLinkId != -1
        && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        int id = lastHoveredLinkId;
        linkToInsertOn = {}; linkToInsertOn.linkId = id;
        bool captured = false;
        // TODO: Handle modulation link deletion for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(id); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][RC-Fallback] Mod link captured id=" + juce::String(id));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            // Infer modulation vs audio list from pin data types
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw ||
                srcType == PinDataType::Video || dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Link captured id=" + juce::String(id));
        }
        if (captured)
        {
            ImGui::OpenPopup("InsertNodeOnLinkPopup");
            ImGui::GetIO().WantCaptureMouse = true;
            juce::Logger::writeToLog("[InsertNode][RC-Fallback] Opened popup");
        }
        else
        {
            linkToInsertOn.linkId = -1;
        }
    }
    // This function draws the popup if the popup is open.
    drawInsertNodeOnLinkPopup();

    // --- Cable Inspector: Stateless, rebuild-safe implementation ---
    hoveredLinkSrcId = 0;
    hoveredLinkDstId = 0;

    // Skip inspector if popups are open (graph is always in consistent state now)
    const bool anyPopupOpen = ImGui::IsPopupOpen("InsertNodeOnLinkPopup") || ImGui::IsPopupOpen("AddModulePopup");
    // Do not early-return here; we still need to finish the frame and close any ImGui scopes.

    if (!anyPopupOpen && isLinkHovered && hoveredLinkId != -1 && synth != nullptr)
    {
        // Safety: Re-verify link still exists in our mapping
        auto it = linkIdToAttrs.find(hoveredLinkId);
        if (it != linkIdToAttrs.end())
        {
            auto srcPin = decodePinId(it->second.first);
            auto dstPin = decodePinId(it->second.second);

            // Set highlight IDs for this frame only
            hoveredLinkSrcId = srcPin.logicalId;
            hoveredLinkDstId = (dstPin.logicalId == 0) ? kOutputHighlightId : dstPin.logicalId;

            // Query source module (no caching - stateless)
            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId))
            {
                // Validate channel index
                const int numOutputs = srcModule->getTotalNumOutputChannels();
                if (srcPin.channel >= 0 && srcPin.channel < numOutputs)
                {
                    // Optional: Throttle value sampling to 60 Hz (every 16.67ms)
                    // For now, query every frame for responsive UI
                    const float liveValue = srcModule->getOutputChannelValue(srcPin.channel);
                    const juce::String srcName = srcModule->getName();
                    const juce::String srcLabel = srcModule->getAudioOutputLabel(srcPin.channel);

                    // Render tooltip (stateless - no caching)
                    ImGui::BeginTooltip();
                    ImGui::Text("Value: %.3f", liveValue);
                    ImGui::Text("From: %s (ID %u)", srcName.toRawUTF8(), (unsigned)srcPin.logicalId);
                    if (srcLabel.isNotEmpty())
                        ImGui::Text("Pin: %s", srcLabel.toRawUTF8());
                    ImGui::EndTooltip();
                }
            }
        }
    }
    

    // Update hovered node/link id for next frame (must be called outside editor scope)
    // Graph is always in consistent state since we rebuild at frame start
    int hv = -1;
    if (ImNodes::IsNodeHovered(&hv)) lastHoveredNodeId = hv; else lastHoveredNodeId = -1;
    
    int hl = -1;
    if (ImNodes::IsLinkHovered(&hl)) lastHoveredLinkId = hl; else lastHoveredLinkId = -1;
    

    // Shortcut: press 'I' while hovering a link to open Insert-on-Link popup (bypasses mouse handling)
    if (ImGui::IsKeyPressed(ImGuiKey_I) && lastHoveredLinkId != -1 && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup"))
    {
        linkToInsertOn = {}; // reset
        linkToInsertOn.linkId = lastHoveredLinkId;
        bool captured = false;
        // TODO: Handle modulation link hover end for new bus-based system
        // if (auto itM = modLinkIdToRoute.find(lastHoveredLinkId); itM != modLinkIdToRoute.end())
        // {
        //     linkToInsertOn.isMod = true;
        //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
        //     linkToInsertOn.srcLogicalId = (juce::uint32) sL;
        //     linkToInsertOn.srcChan = sC;
        //     linkToInsertOn.dstLogicalId = (juce::uint32) dL;
        //     linkToInsertOn.paramId = paramId;
        //     captured = true;
        //     juce::Logger::writeToLog("[InsertNode][KeyI] Mod link captured id=" + juce::String(lastHoveredLinkId));
        // }
        // else 
        if (auto it = linkIdToAttrs.find(lastHoveredLinkId); it != linkIdToAttrs.end())
        {
            linkToInsertOn.isMod = false;
            linkToInsertOn.srcPin = decodePinId(it->second.first);
            linkToInsertOn.dstPin = decodePinId(it->second.second);
            const PinDataType srcType = getPinDataTypeForPin(linkToInsertOn.srcPin);
            const PinDataType dstType = getPinDataTypeForPin(linkToInsertOn.dstPin);
            if (srcType == PinDataType::CV || dstType == PinDataType::CV ||
                srcType == PinDataType::Gate || dstType == PinDataType::Gate ||
                srcType == PinDataType::Raw || dstType == PinDataType::Raw ||
                srcType == PinDataType::Video || dstType == PinDataType::Video)
            {
                linkToInsertOn.isMod = true;
            }
            captured = true;
            juce::Logger::writeToLog("[InsertNode][KeyI] Link captured id=" + juce::String(lastHoveredLinkId));
        }
        if (captured)
        {
            pendingInsertLinkId = lastHoveredLinkId;
            showInsertNodePopup = true; // will open next lines
        }
        else
        {
            linkToInsertOn.linkId = -1;
            juce::Logger::writeToLog("[InsertNode][KeyI] No link data found for id=" + juce::String(lastHoveredLinkId));
        }
    }

    // After editor pass, if we added/duplicated a node, take snapshot now that nodes exist
    if (snapshotAfterEditor)
    {
        snapshotAfterEditor = false;
        pushSnapshot();
    }

    if (synth != nullptr)
    {
        // No persistent panning state when zoom is disabled

        // Right-click on empty canvas -> Add module popup
        // Avoid passing nullptr to ImNodes::IsLinkHovered; some builds may write to the pointer
        int dummyHoveredLinkId = -1;
        const bool anyLinkHovered = ImNodes::IsLinkHovered(&dummyHoveredLinkId);
        if (ImGui::IsMouseReleased(ImGuiMouseButton_Right)
            && ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
            && ! ImGui::IsAnyItemHovered()
            && !anyLinkHovered
            && !ImGui::IsPopupOpen("InsertNodeOnLinkPopup")
            && linkToInsertOn.linkId == -1) // avoid conflict with insert-on-link popup
        {
                ImGui::OpenPopup("AddModulePopup");
        }

        // --- REVISED AND IMPROVED "QUICK ADD" POPUP ---
        if (ImGui::BeginPopup("AddModulePopup"))
        {
            static char searchQuery[128] = "";
            static int selectedIndex = 0;  // Track keyboard navigation

            // Auto-focus the search bar when the popup opens and clear any previous search
            if (ImGui::IsWindowAppearing()) {
                ImGui::SetKeyboardFocusHere(0);
                ImGui::SetWindowFocus();  // Ensure immediate keyboard input capture
                searchQuery[0] = '\0';
                selectedIndex = 0;  // Reset selection
            }
            
            ImGui::Text("Add Module");
            ImGui::PushItemWidth(250.0f);
            
            // Enable Enter key detection for instant module creation
            bool enterPressed = ImGui::InputText("Search##addmodule", searchQuery, sizeof(searchQuery), 
                                                  ImGuiInputTextFlags_EnterReturnsTrue);
            
            ImGui::PopItemWidth();
            ImGui::Separator();
            
            // --- PROBE TOOL ---
            if (ImGui::MenuItem("üî¨ Probe Signal (Click any output pin)"))
            {
                isProbeModeActive = true;
                ImGui::CloseCurrentPopup();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Activate probe mode to instantly visualize any signal without manual patching.\nClick on any output pin to route it to the probe scope.");
            }
            ImGui::Separator();

            auto addAtMouse = [this](const char* type) {
                auto nodeId = synth->addModule(type);
                const int logicalId = (int) synth->getLogicalIdForNode (nodeId);
                // This places the new node exactly where the user right-clicked
                pendingNodeScreenPositions[logicalId] = ImGui::GetMousePosOnOpeningCurrentPopup();
                
                // Special handling for recorder module
                if (juce::String(type).equalsIgnoreCase("recorder"))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical((juce::uint32)logicalId)))
                    {
                        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
                    }
                }
                
                // Give comment nodes a default size to prevent feedback loop
                if (juce::String(type).equalsIgnoreCase("comment"))
                {
                    pendingNodeSizes[logicalId] = ImVec2(250.f, 150.f);
                }
                
                snapshotAfterEditor = true;
                ImGui::CloseCurrentPopup();
            };
            
            juce::String filter(searchQuery);

            ImGui::BeginChild("ModuleList", ImVec2(280, 350), true);

            if (filter.isEmpty())
            {
                // --- BROWSE MODE (No text in search bar) ---
                // Reorganized to match the new category structure
                
                if (ImGui::BeginMenu("Sources")) {
                    if (ImGui::MenuItem("VCO")) addAtMouse("vco");
                    if (ImGui::MenuItem("Polyphonic VCO")) addAtMouse("polyvco");
                    if (ImGui::MenuItem("Noise")) addAtMouse("noise");
                    if (ImGui::MenuItem("Audio Input")) addAtMouse("audio_input");
                    if (ImGui::MenuItem("Sample Loader")) addAtMouse("sample_loader");
                    if (ImGui::MenuItem("Value")) addAtMouse("value");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Effects")) {
                    if (ImGui::MenuItem("VCF")) addAtMouse("vcf");
                    if (ImGui::MenuItem("Delay")) addAtMouse("delay");
                    if (ImGui::MenuItem("Reverb")) addAtMouse("reverb");
                    if (ImGui::MenuItem("Chorus")) addAtMouse("chorus");
                    if (ImGui::MenuItem("Phaser")) addAtMouse("phaser");
                    if (ImGui::MenuItem("Compressor")) addAtMouse("compressor");
                    if (ImGui::MenuItem("Limiter")) addAtMouse("limiter");
                    if (ImGui::MenuItem("Noise Gate")) addAtMouse("gate");
                    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
                    if (ImGui::MenuItem("Graphic EQ")) addAtMouse("graphic_eq");
                    if (ImGui::MenuItem("Waveshaper")) addAtMouse("waveshaper");
                    if (ImGui::MenuItem("8-Band Shaper")) addAtMouse("8bandshaper");
                    if (ImGui::MenuItem("Granulator")) addAtMouse("granulator");
                    if (ImGui::MenuItem("Harmonic Shaper")) addAtMouse("harmonic_shaper");
                    if (ImGui::MenuItem("Time/Pitch Shifter")) addAtMouse("timepitch");
                    if (ImGui::MenuItem("De-Crackle")) addAtMouse("de_crackle");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Modulators")) {
                    if (ImGui::MenuItem("LFO")) addAtMouse("lfo");
                    if (ImGui::MenuItem("ADSR")) addAtMouse("adsr");
                    if (ImGui::MenuItem("Random")) addAtMouse("random");
                    if (ImGui::MenuItem("S&H")) addAtMouse("s_and_h");
                    if (ImGui::MenuItem("Function Generator")) addAtMouse("function_generator");
                    if (ImGui::MenuItem("Shaping Oscillator")) addAtMouse("shaping_oscillator");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Utilities & Logic")) {
                    if (ImGui::MenuItem("VCA")) addAtMouse("vca");
                    if (ImGui::MenuItem("Mixer")) addAtMouse("mixer");
                    if (ImGui::MenuItem("CV Mixer")) addAtMouse("cv_mixer");
                    if (ImGui::MenuItem("Track Mixer")) addAtMouse("track_mixer");
                    if (ImGui::MenuItem("Attenuverter")) addAtMouse("attenuverter");
                    if (ImGui::MenuItem("Lag Processor")) addAtMouse("lag_processor");
                    if (ImGui::MenuItem("Math")) addAtMouse("math");
                    if (ImGui::MenuItem("Map Range")) addAtMouse("map_range");
                    if (ImGui::MenuItem("Quantizer")) addAtMouse("quantizer");
                    if (ImGui::MenuItem("Rate")) addAtMouse("rate");
                    if (ImGui::MenuItem("Comparator")) addAtMouse("comparator");
                    if (ImGui::MenuItem("Logic")) addAtMouse("logic");
                    if (ImGui::MenuItem("Clock Divider")) addAtMouse("clock_divider");
                    if (ImGui::MenuItem("Sequential Switch")) addAtMouse("sequential_switch");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Sequencers")) {
                    if (ImGui::MenuItem("Sequencer")) addAtMouse("sequencer");
                    if (ImGui::MenuItem("Multi Sequencer")) addAtMouse("multi_sequencer");
                    if (ImGui::MenuItem("Tempo Clock")) addAtMouse("tempo_clock");
                    if (ImGui::MenuItem("Snapshot Sequencer")) addAtMouse("snapshot_sequencer");
                    if (ImGui::MenuItem("Stroke Sequencer")) addAtMouse("stroke_sequencer");
                    if (ImGui::MenuItem("Timeline")) addAtMouse("timeline");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("MIDI")) {
                    if (ImGui::MenuItem("MIDI CV")) addAtMouse("midi_cv");
                    if (ImGui::MenuItem("MIDI Player")) addAtMouse("midi_player");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Faders")) addAtMouse("midi_faders");
                    if (ImGui::MenuItem("MIDI Knobs")) addAtMouse("midi_knobs");
                    if (ImGui::MenuItem("MIDI Buttons")) addAtMouse("midi_buttons");
                    if (ImGui::MenuItem("MIDI Jog Wheel")) addAtMouse("midi_jog_wheel");
                    if (ImGui::MenuItem("MIDI Pads")) addAtMouse("midi_pads");
                    ImGui::Separator();
                    if (ImGui::MenuItem("MIDI Logger")) addAtMouse("midi_logger");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Analysis")) {
                    if (ImGui::MenuItem("Scope")) addAtMouse("scope");
                    if (ImGui::MenuItem("Debug")) addAtMouse("debug");
                    if (ImGui::MenuItem("Input Debug")) addAtMouse("input_debug");
                    if (ImGui::MenuItem("Frequency Graph")) addAtMouse("frequency_graph");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("TTS")) {
                    if (ImGui::MenuItem("TTS Performer")) addAtMouse("tts_performer");
                    if (ImGui::MenuItem("Vocal Tract Filter")) addAtMouse("vocal_tract_filter");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Special")) {
                    if (ImGui::MenuItem("Physics")) addAtMouse("physics");
                    if (ImGui::MenuItem("Animation")) addAtMouse("animation");
                    ImGui::EndMenu();
                }
                if (ImGui::BeginMenu("Computer Vision")) {
                    if (ImGui::MenuItem("Webcam Loader")) addAtMouse("webcam_loader");
                    if (ImGui::MenuItem("Video File Loader")) addAtMouse("video_file_loader");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Video FX")) addAtMouse("video_fx");
                    if (ImGui::MenuItem("Crop Video")) addAtMouse("crop_video");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Movement Detector")) addAtMouse("movement_detector");
                    if (ImGui::MenuItem("Human Detector")) addAtMouse("human_detector");
                    if (ImGui::MenuItem("Object Detector")) addAtMouse("object_detector");
                    if (ImGui::MenuItem("Pose Estimator")) addAtMouse("pose_estimator");
                    if (ImGui::MenuItem("Hand Tracker")) addAtMouse("hand_tracker");
                    if (ImGui::MenuItem("Face Tracker")) addAtMouse("face_tracker");
                    if (ImGui::MenuItem("Color Tracker")) addAtMouse("color_tracker");
                    if (ImGui::MenuItem("Contour Detector")) addAtMouse("contour_detector");
                    if (ImGui::MenuItem("Semantic Segmentation")) addAtMouse("semantic_segmentation");
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("Plugins / VST")) {
                    addPluginModules(); // Re-use your existing plugin menu logic
                    ImGui::EndMenu();
                }
                
                if (ImGui::BeginMenu("System")) {
                    if (ImGui::MenuItem("Meta")) addAtMouse("meta");
                    if (ImGui::MenuItem("Inlet")) addAtMouse("inlet");
                    if (ImGui::MenuItem("Outlet")) addAtMouse("outlet");
                    if (ImGui::MenuItem("Comment")) addAtMouse("comment");
                    if (ImGui::MenuItem("Recorder")) addAtMouse("recorder");
                    if (ImGui::MenuItem("VST Host")) addAtMouse("vst_host");
                    ImGui::Separator();
                    if (ImGui::MenuItem("Best Practice")) addAtMouse("best_practice");
                    ImGui::EndMenu();
                }
            }
            else
            {
                // --- SEARCH MODE (Text has been entered) ---
                // Build list of matching modules first for keyboard navigation
                struct MatchedModule {
                    juce::String displayName;
                    const char* internalType;
                    const char* description;
                };
                std::vector<MatchedModule> matches;
                
                for (const auto& entry : getModuleRegistry())
                {
                    const juce::String& displayName = entry.first;
                    const char* internalType = entry.second.first;
                    const char* description = entry.second.second;
                    
                    if (displayName.containsIgnoreCase(filter))
                    {
                        matches.push_back({displayName, internalType, description});
                    }
                }
                
                // Handle keyboard navigation (arrow keys)
                if (ImGui::IsKeyPressed(ImGuiKey_DownArrow)) 
                {
                    selectedIndex++;
                    if (selectedIndex >= (int)matches.size()) 
                        selectedIndex = (int)matches.size() - 1;
                }
                if (ImGui::IsKeyPressed(ImGuiKey_UpArrow)) 
                {
                    selectedIndex--;
                    if (selectedIndex < 0) 
                        selectedIndex = 0;
                }
                
                // Handle Enter key to create selected module
                if (enterPressed && !matches.empty())
                {
                    if (selectedIndex >= 0 && selectedIndex < (int)matches.size())
                    {
                        addAtMouse(matches[selectedIndex].internalType);
                    }
                }
                
                // Display the matching modules with selection highlight
                for (int i = 0; i < (int)matches.size(); ++i)
                {
                    const auto& match = matches[i];
                    bool isSelected = (i == selectedIndex);
                    
                    if (ImGui::Selectable(match.displayName.toRawUTF8(), isSelected))
                    {
                        addAtMouse(match.internalType);
                    }
                    
                    // Auto-scroll to keep selected item visible
                    if (isSelected && ImGui::IsItemVisible() == false)
                    {
                        ImGui::SetScrollHereY(0.5f);
                    }
                    
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::TextUnformatted(match.description);
                        ImGui::EndTooltip();
                    }
                }
                
                // Reset selection if out of bounds
                if (selectedIndex >= (int)matches.size())
                    selectedIndex = (int)matches.size() - 1;
                if (selectedIndex < 0)
                    selectedIndex = 0;
            }

            ImGui::EndChild();
            ImGui::EndPopup();
        }

        // Helper functions are now class methods

        // Handle user-created links (must be called after EndNodeEditor)
        int startAttr = 0, endAttr = 0;
        if (ImNodes::IsLinkCreated(&startAttr, &endAttr))
        {
            auto startPin = decodePinId(startAttr);
            auto endPin = decodePinId(endAttr);
            auto srcPin = startPin.isInput ? endPin : startPin;
            auto dstPin = startPin.isInput ? startPin : endPin;

            // Ensure connection is always Output -> Input
            if (!srcPin.isInput && dstPin.isInput)
            {
                PinDataType srcType = getPinDataTypeForPin(srcPin);
                PinDataType dstType = getPinDataTypeForPin(dstPin);

                bool conversionHandled = false;

                // Determine if a converter is needed based on pin types
                if (srcType == PinDataType::Audio && dstType == PinDataType::CV)
                {
                    insertNodeBetween("Attenuverter", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::CV && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("Comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Audio && dstType == PinDataType::Gate)
                {
                    insertNodeBetween("Comparator", srcPin, dstPin);
                    conversionHandled = true;
                }
                else if (srcType == PinDataType::Raw && dstType != PinDataType::Raw)
                {
                    insertNodeBetween("MapRange", srcPin, dstPin);
                    conversionHandled = true;
                }

                if (conversionHandled)
                {
                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
                else
                {
                    // All other combinations are considered directly compatible.
                    auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                    auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                    synth->connect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                    // Immediate commit for RecordModuleProcessor filename update
                    synth->commitChanges();

                    if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId)) {
                        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule)) {
                            juce::String sourceName;
                            if (auto* srcModule = synth->getModuleForLogical(srcPin.logicalId)) {
                                sourceName = srcModule->getName();
                            }
                            recorder->updateSuggestedFilename(sourceName);
                        }
                    }

                    pushSnapshot();
                }
            }
        }

        // Handle link deletion (single)
        int linkId = 0;
        if (ImNodes::IsLinkDestroyed(&linkId))
        {
            if (auto it = linkIdToAttrs.find(linkId); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);
                
                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);

                // Debug log disconnect intent
                juce::Logger::writeToLog(
                    juce::String("[LinkDelete] src(lid=") + juce::String((int)srcPin.logicalId) + ",ch=" + juce::String(srcPin.channel) +
                    ") -> dst(lid=" + juce::String((int)dstPin.logicalId) + ",ch=" + juce::String(dstPin.channel) + ")");

                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
                
                // Immediate commit for RecordModuleProcessor filename update
                synth->commitChanges();
                
                // After disconnecting, tell the recorder to update (pass empty string for unconnected)
                if (auto* dstModule = synth->getModuleForLogical(dstPin.logicalId))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(dstModule))
                    {
                        recorder->updateSuggestedFilename(""); // Empty = unconnected
                    }
                }
                
                pushSnapshot();
                linkIdToAttrs.erase (it);
            }
        }
        // Handle link deletion (multi-select via Delete)

        // Keyboard shortcuts
        // Only process global keyboard shortcuts if no ImGui widget wants the keyboard
        if (!ImGui::GetIO().WantCaptureKeyboard)
        {
            const bool ctrl = ImGui::GetIO().KeyCtrl;
            const bool shift = ImGui::GetIO().KeyShift;
            const bool alt = ImGui::GetIO().KeyAlt;
            
            // Save As (Ctrl+Alt+S) - Always opens dialog
            if (ctrl && alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
            {
                startSaveDialog();
            }
            // Save (Ctrl+S) - Quick save if file exists, otherwise Save As
            else if (ctrl && !alt && ImGui::IsKeyPressed(ImGuiKey_S, false))
            {
                if (currentPresetFile.existsAsFile())
                {
                    // File already exists, so save directly without a dialog
                    savePresetToFile(currentPresetFile);
                }
                else
                {
                    // This is a new, unsaved patch, so "Save" should act like "Save As"
                    startSaveDialog();
                }
            }
            if (ctrl && ImGui::IsKeyPressed (ImGuiKey_O)) { startLoadDialog(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_P)) { handleRandomizePatch(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_M)) { handleRandomizeConnections(); }
            if (ctrl && ImGui::IsKeyPressed(ImGuiKey_B)) { handleBeautifyLayout(); }
            if (ctrl && !shift && !alt && ImGui::IsKeyPressed(ImGuiKey_R, false)) { handleRecordOutput(); }
        
        // M: Mute/Bypass selected nodes (without Ctrl modifier)
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_M, false) && ImNodes::NumSelectedNodes() > 0)
        {
            handleMuteToggle();
        }
        
        // Ctrl + A: Select All
        if (ctrl && !shift && ImGui::IsKeyPressed(ImGuiKey_A, false))
        {
            if (synth != nullptr)
            {
                const auto& modules = synth->getModulesInfo();
                std::vector<int> allNodeIds;
                allNodeIds.push_back(0); // Include output node
                for (const auto& mod : modules)
                {
                    allNodeIds.push_back((int)mod.first);
                }
                ImNodes::ClearNodeSelection();
                for (int id : allNodeIds)
                {
                    ImNodes::SelectNode(id);
                }
            }
        }
        
        // Ctrl + R: Reset selected node(s) to default parameters
        if (ctrl && ImGui::IsKeyPressed(ImGuiKey_R, false))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0 && synth != nullptr)
            {
                // Create a single undo state for the entire operation
                pushSnapshot();
                
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());

                for (int lid : selectedNodeIds)
                {
                    if (auto* module = synth->getModuleForLogical((juce::uint32)lid))
                    {
                        // Get all parameters for this module
                        auto& params = module->getParameters();
                        for (auto* paramBase : params)
                        {
                            // Cast to a ranged parameter to access default values
                            if (auto* param = dynamic_cast<juce::RangedAudioParameter*>(paramBase))
                            {
                                // Get the default value (normalized 0-1) and apply it
                                param->setValueNotifyingHost(param->getDefaultValue());
                            }
                        }
                        juce::Logger::writeToLog("[Reset] Reset parameters for node " + juce::String(lid));
                    }
                }
            }
        }
        
        // O: Connect selected to Output
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_O, false) && ImNodes::NumSelectedNodes() == 1)
        {
            if (synth != nullptr)
            {
                int selectedId;
                ImNodes::GetSelectedNodes(&selectedId);
                if (selectedId != 0)
                {
                    synth->connect(synth->getNodeIdForLogical(selectedId), 0, synth->getOutputNodeID(), 0);
                    synth->connect(synth->getNodeIdForLogical(selectedId), 1, synth->getOutputNodeID(), 1);
                    graphNeedsRebuild = true;
                    pushSnapshot();
                }
            }
        }
        
        // Alt + D: Disconnect selected nodes
        if (alt && ImGui::IsKeyPressed(ImGuiKey_D, false) && ImNodes::NumSelectedNodes() > 0)
        {
            if (synth != nullptr)
            {
                std::vector<int> selectedNodeIds(ImNodes::NumSelectedNodes());
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                for (int id : selectedNodeIds)
                {
                    synth->clearConnectionsForNode(synth->getNodeIdForLogical(id));
                }
                graphNeedsRebuild = true;
                pushSnapshot();
            }
        }
        
        // --- REVISED 'F' and 'Home' KEY LOGIC ---
        auto frameNodes = [&](const std::vector<int>& nodeIds) {
            if (nodeIds.empty() || synth == nullptr) return;

            juce::Rectangle<float> bounds;
            bool foundAny = false;
            
            // Build a set of valid node IDs for checking
            std::unordered_set<int> validNodes;
            validNodes.insert(0); // Output node
            for (const auto& mod : synth->getModulesInfo())
                validNodes.insert((int)mod.first);
            
            for (size_t i = 0; i < nodeIds.size(); ++i)
            {
                // Ensure the node exists before getting its position
                if (validNodes.find(nodeIds[i]) != validNodes.end())
                {
                    ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeIds[i]);
                    if (!foundAny)
                    {
                        bounds = juce::Rectangle<float>(pos.x, pos.y, 1, 1);
                        foundAny = true;
                    }
                    else
                    {
                        bounds = bounds.getUnion(juce::Rectangle<float>(pos.x, pos.y, 1, 1));
                    }
                }
            }

            if (!foundAny) return;

            // Add some padding to the bounds
            if (!nodeIds.empty() && validNodes.find(nodeIds[0]) != validNodes.end())
                bounds = bounds.expanded(ImNodes::GetNodeDimensions(nodeIds[0]).x, ImNodes::GetNodeDimensions(nodeIds[0]).y);
            
            ImVec2 center((bounds.getX() + bounds.getRight()) * 0.5f, (bounds.getY() + bounds.getBottom()) * 0.5f);
            ImNodes::EditorContextResetPanning(center);
        };

        // F: Frame Selected
        if (!ctrl && !alt && !shift && ImGui::IsKeyPressed(ImGuiKey_F, false))
        {
            const int numSelected = ImNodes::NumSelectedNodes();
            if (numSelected > 0)
            {
                std::vector<int> selectedNodeIds(numSelected);
                ImNodes::GetSelectedNodes(selectedNodeIds.data());
                frameNodes(selectedNodeIds);
            }
        }

        // Home and Ctrl+Home: Frame All / Reset to Origin
        if (ImGui::IsKeyPressed(ImGuiKey_Home, false))
        {
            if (ctrl) // Ctrl+Home: Reset to origin
            {
                ImNodes::EditorContextResetPanning(ImVec2(0, 0));
            }
            else // Home: Frame all
            {
                if (synth != nullptr)
                {
                    auto modules = synth->getModulesInfo();
                    std::vector<int> allNodeIds;
                    allNodeIds.push_back(0); // Include output node
                    for (const auto& mod : modules)
                    {
                        allNodeIds.push_back((int)mod.first);
                    }
                    frameNodes(allNodeIds);
                }
            }
        }
        
        // Debug menu (Ctrl+Shift+D)
        if (ctrl && shift && ImGui::IsKeyPressed(ImGuiKey_D)) { showDebugMenu = !showDebugMenu; }

        // Undo / Redo (Ctrl+Z / Ctrl+Y)
    if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Z))
        {
            if (undoStack.size() > 1)
            {
                Snapshot current = undoStack.back();
                redoStack.push_back (current);
                undoStack.pop_back();
                restoreSnapshot (undoStack.back());
                // After a restore, clear transient link maps only; keep pending positions so they apply next frame
                linkIdToAttrs.clear();
                // modLinkIdToRoute.clear(); // TODO: Remove when fully migrated
            }
        }
        if (ctrl && ImGui::IsKeyPressed (ImGuiKey_Y))
        {
            if (! redoStack.empty())
            {
                Snapshot s = redoStack.back(); redoStack.pop_back();
                restoreSnapshot (s);
                undoStack.push_back (s);
                linkIdToAttrs.clear();
                // modLinkIdToRoute.clear(); // TODO: Remove when fully migrated
            }
        }

        // Duplicate selected nodes (Ctrl+D) and Duplicate with connections (Shift+D)
        if ((ctrl || ImGui::GetIO().KeyShift) && ImGui::IsKeyPressed (ImGuiKey_D))
        {
            const int n = ImNodes::NumSelectedNodes();
            if (n > 0)
            {
                std::vector<int> sel((size_t) n);
                ImNodes::GetSelectedNodes(sel.data());
                for (int oldId : sel)
                {
                    if (oldId == 0) continue;
                    const juce::String type = getTypeForLogical ((juce::uint32) oldId);
                    if (type.isEmpty()) continue;
                    auto newNodeId = synth->addModule (type);
                    graphNeedsRebuild = true;
                    const juce::uint32 newLogical = synth->getLogicalIdForNode (newNodeId);
                    if (newLogical != 0)
                    {
                        if (auto* src = synth->getModuleForLogical ((juce::uint32) oldId))
                            if (auto* dst = synth->getModuleForLogical (newLogical))
                                dst->getAPVTS().replaceState (src->getAPVTS().copyState());
                        // Position offset
                        ImVec2 pos = ImNodes::GetNodeGridSpacePos (oldId);
                        pendingNodePositions[(int) newLogical] = ImVec2 (pos.x + 40.0f, pos.y + 40.0f);

                        // If Shift is held: duplicate connections into and out of this node
                        if (!ctrl && ImGui::GetIO().KeyShift)
                        {
                            const auto oldNode = synth->getNodeIdForLogical ((juce::uint32) oldId);
                            const auto newNode = newNodeId;
                            // Duplicate audio/CV connections
                            for (const auto& c : synth->getConnectionsInfo())
                            {
                                // Outgoing from old -> someone
                                if ((int) c.srcLogicalId == oldId)
                                {
                                    auto dstNode = (c.dstLogicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical (c.dstLogicalId);
                                    synth->connect (newNode, c.srcChan, dstNode, c.dstChan);
                                }
                                // Incoming from someone -> old
                                if ((int) c.dstLogicalId == oldId)
                                {
                                    auto srcNode = synth->getNodeIdForLogical (c.srcLogicalId);
                                    synth->connect (srcNode, c.srcChan, newNode, c.dstChan);
                                }
                            }
                            // TODO: Implement modulation route duplication for new bus-based system
                        }
                    }
                }
                pushSnapshot();
            }
        }
        
        } // End of keyboard shortcuts (WantCaptureKeyboard check)

        // Update selection for parameter panel
        {
            int selCount = ImNodes::NumSelectedNodes();
            if (selCount > 0)
            {
                std::vector<int> ids((size_t) selCount);
                ImNodes::GetSelectedNodes(ids.data());
                selectedLogicalId = ids.back();
            }
            else
            {
                selectedLogicalId = 0;
            }
        }

        handleDeletion();
    }

    // === MIDI DEVICE MANAGER WINDOW ===
    if (showMidiDeviceManager)
    {
        if (ImGui::Begin("MIDI Device Manager", &showMidiDeviceManager, ImGuiWindowFlags_AlwaysAutoResize))
        {
            ImGui::TextColored(ImVec4(0.6f, 0.8f, 1.0f, 1.0f), "MIDI Input Devices");
            ImGui::Separator();
            
            // Access MidiDeviceManager from PresetCreatorComponent
            auto* presetCreator = dynamic_cast<PresetCreatorComponent*>(getParentComponent());
            if (presetCreator && presetCreator->midiDeviceManager)
            {
                auto& midiMgr = *presetCreator->midiDeviceManager;
                const auto& devices = midiMgr.getDevices();
                
                if (devices.empty())
                {
                    ImGui::TextDisabled("No MIDI devices found");
                }
                else
                {
                    ImGui::Text("Found %d device(s):", (int)devices.size());
                    ImGui::Spacing();
                    
                    // Display each device
                    for (const auto& device : devices)
                    {
                        ImGui::PushID(device.identifier.toRawUTF8());
                        
                        // Checkbox to enable/disable device
                        bool enabled = device.enabled;
                        if (ImGui::Checkbox("##enabled", &enabled))
                        {
                            if (enabled)
                                midiMgr.enableDevice(device.identifier);
                            else
                                midiMgr.disableDevice(device.identifier);
                        }
                        
                        ImGui::SameLine();
                        
                        // Device name
                        ImGui::Text("%s", device.name.toRawUTF8());
                        
                        // Activity indicator
                        auto activity = midiMgr.getDeviceActivity(device.identifier);
                        if (activity.lastMessageTime > 0)
                        {
                            ImGui::SameLine();
                            float timeSinceMessage = (juce::Time::getMillisecondCounter() - activity.lastMessageTime) / 1000.0f;
                            if (timeSinceMessage < 1.0f)
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 255, 100, 255));
                                ImGui::Text("ACTIVE");
                                ImGui::PopStyleColor();
                            }
                            else
                            {
                                ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(100, 100, 100, 255));
                                ImGui::Text("idle");
                                ImGui::PopStyleColor();
                            }
                        }
                        
                        ImGui::PopID();
                    }
                }
                
                ImGui::Spacing();
                ImGui::Separator();
                ImGui::Spacing();
                
                // Rescan button
                if (ImGui::Button("Rescan Devices"))
                {
                    midiMgr.scanDevices();
                }
                
                ImGui::SameLine();
                
                // Enable/Disable all buttons
                if (ImGui::Button("Enable All"))
                {
                    midiMgr.enableAllDevices();
                }
                
                ImGui::SameLine();
                
                if (ImGui::Button("Disable All"))
                {
                    midiMgr.disableAllDevices();
                }
            }
            else
            {
                ImGui::TextDisabled("MIDI Manager not available");
            }
        }
        ImGui::End();
    }

    // === DEBUG WINDOW ===
    if (showDebugMenu)
    {
        if (ImGui::Begin("System Diagnostics", &showDebugMenu))
        {
            if (synth != nullptr)
            {
                ImGui::Text("=== SYSTEM OVERVIEW ===");
                if (ImGui::Button("Refresh"))
                {
                    // Force refresh of diagnostics
                }
                
                
                // System diagnostics
                ImGui::Text("System State:");
                juce::String systemDiag = synth->getSystemDiagnostics();
                ImGui::TextWrapped("%s", systemDiag.toUTF8());
                
                
                // Module selector
                ImGui::Text("Module Diagnostics:");
                auto modules = synth->getModulesInfo();
                if (!modules.empty())
                {
                    static int selectedModuleIndex = 0;
                    if (selectedModuleIndex >= (int)modules.size()) selectedModuleIndex = 0;
                    
                    juce::String moduleList = "";
                    for (size_t i = 0; i < modules.size(); ++i)
                    {
                        if (i > 0) moduleList += "\0";
                        moduleList += "Logical " + juce::String((int)modules[i].first) + ": " + modules[i].second;
                    }
                    moduleList += "\0";
                    
                    if (ImGui::Combo("Select Module", &selectedModuleIndex, moduleList.toUTF8()))
                    {
                        if (selectedModuleIndex < (int)modules.size())
                        {
                            juce::String moduleDiag = synth->getModuleDiagnostics(modules[selectedModuleIndex].first);
                            ImGui::TextWrapped("%s", moduleDiag.toUTF8());
                        }
                    }
                }
                else
                {
                    ImGui::Text("No modules found.");
                }
            }
            else
            {
                ImGui::Text("No synth processor available.");
            }
        }
        ImGui::End();
    }

    // Keyboard Shortcuts Help Window (F1)
    if (showShortcutsWindow)
    {
        ImGui::Begin("Keyboard Shortcuts", &showShortcutsWindow, ImGuiWindowFlags_AlwaysAutoResize);
        
        // --- NEW, COMPREHENSIVE SHORTCUT LIST ---

        ImGui::Text("Patch & File Management");
        ImGui::Separator();
        ImGui::BulletText("Ctrl + S: Save Preset.");
        ImGui::BulletText("Ctrl + O: Load Preset.");
        ImGui::BulletText("Ctrl + Z: Undo last action.");
        ImGui::BulletText("Ctrl + Y: Redo last action.");
        ImGui::BulletText("Ctrl + P: Generate a new random patch.");

        ImGui::Spacing();
        ImGui::Text("Node Creation & Deletion");
        ImGui::Separator();
        ImGui::BulletText("Right-click canvas: Open Quick Add menu to create a node.");
        ImGui::BulletText("Delete: Delete selected nodes and links.");
        ImGui::BulletText("Shift + Delete: Bypass-delete selected node(s), preserving signal chain.");
        ImGui::BulletText("Ctrl + D: Duplicate selected node(s).");
        ImGui::BulletText("Shift + D: Duplicate selected node(s) with their connections.");
        ImGui::BulletText("Ctrl + Shift + M: Collapse selected nodes into a new 'Meta Module'.");

        ImGui::Spacing();
        ImGui::Text("Connections & Signal Flow");
        ImGui::Separator();
        ImGui::BulletText("Right-click canvas -> Probe Signal: Enter Probe Mode.");
        ImGui::BulletText("  (In Probe Mode) Left-click output pin: Instantly view signal in the Probe Scope.");
        ImGui::BulletText("Right-click link: Open menu to insert a node on that cable.");
        ImGui::BulletText("I key (while hovering link): Open 'Insert Node' menu for that cable.");
        ImGui::BulletText("Ctrl + Middle-click link: Split a new cable from a connected output pin.");
        ImGui::BulletText("O key (with one node selected): Connect node's output to the Main Output.");
        ImGui::BulletText("Alt + D: Disconnect all cables from selected node(s).");
        ImGui::BulletText("Ctrl + M: Randomize connections between existing nodes.");
        ImGui::BulletText("C key (multi-select): Chain selected nodes (L->L, R->R).");
        ImGui::BulletText("G, B, Y, R keys (multi-select): Chain pins by type (Audio, CV, Gate, Raw).");
        
        ImGui::Spacing();
        ImGui::Text("Navigation & View");
        ImGui::Separator();
        ImGui::BulletText("F: Frame (zoom to fit) selected nodes.");
        ImGui::BulletText("Home: Frame all nodes in the patch.");
        ImGui::BulletText("Ctrl + Home: Reset view panning to the origin (0,0).");
        ImGui::BulletText("Ctrl + B: Automatically arrange nodes for a clean layout ('Beautify').");
        ImGui::BulletText("Ctrl + A: Select all nodes.");

        ImGui::Spacing();
        ImGui::Text("Parameter & Settings");
        ImGui::Separator();
        ImGui::BulletText("M key (with node(s) selected): Mute or Bypass the selected node(s).");
        ImGui::BulletText("Ctrl + R (with node(s) selected): Reset parameters of selected node(s) to default.");
        ImGui::BulletText("Ctrl + Shift + C: Copy selected node's settings to clipboard.");
        ImGui::BulletText("Ctrl + Shift + V: Paste settings to selected node (must be same type).");
        ImGui::BulletText("Mouse Wheel (on slider): Fine-tune parameter value.");

        ImGui::Spacing();
        ImGui::Text("General & Debugging");
        ImGui::Separator();
        ImGui::BulletText("Ctrl + R (no node selected): Insert a Recorder tapped into the Main Output.");
        ImGui::BulletText("Ctrl + Shift + D: Show System Diagnostics window.");
        ImGui::BulletText("F1: Toggle this help window.");
        
        ImGui::End();
    }

    ImGui::End();
    // drawPendingModPopup(); // TODO: Remove when fully migrated

    // No deferred snapshots; unified pre-state strategy
}

void ImGuiNodeEditorComponent::pushSnapshot()
{
    // Ensure any newly scheduled positions are flushed into the current UI state
    // by applying them immediately before capturing.
    if (! pendingNodePositions.empty())
    {
        // Temporarily mask rebuild flag to avoid ImNodes queries during capture
        const bool rebuilding = graphNeedsRebuild.load();
        if (rebuilding) {
            // getUiValueTree will still avoid ImNodes now, but assert safety
        }
        juce::ValueTree applied = getUiValueTree();
        for (const auto& kv : pendingNodePositions)
        {
            // Overwrite the entry for this node if present
            for (int i = 0; i < applied.getNumChildren(); ++i)
            {
                auto n = applied.getChild(i);
                if (n.hasType("node") && (int) n.getProperty("id", -1) == kv.first)
                { n.setProperty("x", kv.second.x, nullptr); n.setProperty("y", kv.second.y, nullptr); break; }
            }
        }
        // Do not commit pending positions of (0,0) which are placeholders
        for (int i = 0; i < applied.getNumChildren(); ++i)
        {
            auto n = applied.getChild(i);
            if (! n.hasType("node")) continue;
            const float x = (float) n.getProperty("x", 0.0f);
            const float y = (float) n.getProperty("y", 0.0f);
            if (x == 0.0f && y == 0.0f) {
                // Try to recover from last-known or pending
                const int nid = (int) n.getProperty("id", -1);
                auto itL = lastKnownNodePositions.find(nid);
                if (itL != lastKnownNodePositions.end()) { n.setProperty("x", itL->second.x, nullptr); n.setProperty("y", itL->second.y, nullptr); }
                else if (auto itP = pendingNodePositions.find(nid); itP != pendingNodePositions.end()) { n.setProperty("x", itP->second.x, nullptr); n.setProperty("y", itP->second.y, nullptr); }
            }
        }
        Snapshot s; s.uiState = applied; if (synth != nullptr) synth->getStateInformation (s.synthState);
        undoStack.push_back (std::move (s)); redoStack.clear();
        isPatchDirty = true; // Mark patch as dirty
        return;
    }
    Snapshot s; s.uiState = getUiValueTree();
    if (synth != nullptr) synth->getStateInformation (s.synthState);
    undoStack.push_back (std::move (s));
    redoStack.clear();
    
    // Mark patch as dirty whenever a change is made
    isPatchDirty = true;
}

void ImGuiNodeEditorComponent::restoreSnapshot (const Snapshot& s)
{
    if (synth != nullptr && s.synthState.getSize() > 0)
        synth->setStateInformation (s.synthState.getData(), (int) s.synthState.getSize());
    // Restore UI positions exactly as saved
    applyUiValueTreeNow (s.uiState);
}

juce::String ImGuiNodeEditorComponent::getTypeForLogical (juce::uint32 logicalId) const
{
    if (synth == nullptr) return {};
    for (const auto& p : synth->getModulesInfo())
        if (p.first == logicalId) return p.second;
    return {};
}

// Parameters are now drawn inline within each node; side panel removed


juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui ("NodeEditorUI");
    if (synth == nullptr) return ui;
    // Save node positions
    for (const auto& mod : synth->getModulesInfo())
    {
        const int nid = (int) mod.first;
        
        // Prefer cached position if available; never query ImNodes while rebuilding
        ImVec2 pos;
        if (lastKnownNodePositions.count(nid) > 0)
        {
            pos = lastKnownNodePositions.at(nid);
        }
        else if (graphNeedsRebuild.load())
        {
            // Fallback to any pending position queued for this node
            auto it = pendingNodePositions.find(nid);
            pos = (it != pendingNodePositions.end()) ? it->second : ImVec2(0.0f, 0.0f);
        }
        else
        {
            pos = ImNodes::GetNodeGridSpacePos(nid);
        }
        
        juce::ValueTree n ("node");
        n.setProperty ("id", nid, nullptr);
        n.setProperty ("x", pos.x, nullptr);
        n.setProperty ("y", pos.y, nullptr);
        
        // --- FIX: Save muted/bypassed state ---
        // If this node's ID is in our map of muted nodes, add the property to the XML
        if (mutedNodeStates.count(nid) > 0)
        {
            n.setProperty("muted", true, nullptr);
        }
        
        ui.addChild (n, -1, nullptr);
    }
    
    // --- FIX: Explicitly save the output node position (ID 0) ---
    // The main output node is not part of getModulesInfo(), so we need to save it separately
    
    // Prefer cached output position; avoid ImNodes when rebuilding
    ImVec2 outputPos;
    if (lastKnownNodePositions.count(0) > 0)
        outputPos = lastKnownNodePositions.at(0);
    else if (graphNeedsRebuild.load())
    {
        auto it0 = pendingNodePositions.find(0);
        outputPos = (it0 != pendingNodePositions.end()) ? it0->second : ImVec2(0.0f, 0.0f);
    }
    else
        outputPos = ImNodes::GetNodeGridSpacePos(0);
    
    juce::ValueTree outputNode("node");
    outputNode.setProperty("id", 0, nullptr);
    outputNode.setProperty("x", outputPos.x, nullptr);
    outputNode.setProperty("y", outputPos.y, nullptr);
    ui.addChild(outputNode, -1, nullptr);
    // --- END OF FIX ---
    
    return ui;
}

void ImGuiNodeEditorComponent::applyUiValueTreeNow (const juce::ValueTree& uiState)
{
    if (! uiState.isValid() || synth == nullptr) return;
    
    juce::Logger::writeToLog("[UI_RESTORE] Applying UI ValueTree now...");

    // This is the core of the crash: the synth graph has already been rebuilt by setStateInformation.
    // We must clear our stale UI data (like muted nodes) before applying the new state from the preset.
    mutedNodeStates.clear();
    
    auto nodes = uiState; // expect tag NodeEditorUI
    for (int i = 0; i < nodes.getNumChildren(); ++i)
    {
        auto n = nodes.getChild(i);
        
        if (! n.hasType ("node")) continue;
        const int nid = (int) n.getProperty ("id", 0);

        // ========================= THE FIX STARTS HERE =========================
        //
        // Before applying any property, VERIFY that this node ID actually exists
        // in the synth. This prevents crashes when loading presets that contain
        // modules which are not available in the current build.
        //
        bool nodeExistsInSynth = (nid == 0); // Node 0 is always the output node.
        if (!nodeExistsInSynth) {
            for (const auto& modInfo : synth->getModulesInfo()) {
                if ((int)modInfo.first == nid) {
                    nodeExistsInSynth = true;
                    break;
                }
            }
        }

        if (!nodeExistsInSynth)
        {
            juce::Logger::writeToLog("[UI_RESTORE] WARNING: Skipping UI properties for non-existent node ID " + juce::String(nid) + ". The module may be missing or failed to load.");
            continue; // Skip to the next node in the preset.
        }
        // ========================== END OF FIX ==========================

        const float x = (float) n.getProperty ("x", 0.0f);
        const float y = (float) n.getProperty ("y", 0.0f);
        if (!(x == 0.0f && y == 0.0f))
        {
            pendingNodePositions[nid] = ImVec2(x, y);
            juce::Logger::writeToLog("[UI_RESTORE] Queued position for node " + juce::String(nid) + ": (" + juce::String(x) + ", " + juce::String(y) + ")");
        }
        
        // Read and apply muted state from preset for existing nodes.
        if ((bool) n.getProperty("muted", false))
        {
            // Use muteNodeSilent to store the original connections first,
            // then apply the mute (which creates bypass connections)
            muteNodeSilent(nid);
            muteNode(nid);
        }
    }
    
    // Muting/unmuting modifies graph connections, so we must tell the
    // synth to rebuild its processing order.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[UI_RESTORE] UI state applied. Flagging for graph rebuild.");
}

void ImGuiNodeEditorComponent::applyUiValueTree (const juce::ValueTree& uiState)
{
    // Queue for next frame to avoid calling imnodes setters before editor is begun
    uiPending = uiState;
}

void ImGuiNodeEditorComponent::handleDeletion()
{
    if (synth == nullptr)
        return;

    // Shift+Delete => bypass delete (keep chain intact)
    if ((ImGui::GetIO().KeyShift) && ImGui::IsKeyPressed(ImGuiKey_Delete))
    {
        bypassDeleteSelectedNodes();
        return;
    }

    // Use new key query API (1.90+) for normal delete
    if (! ImGui::IsKeyPressed(ImGuiKey_Delete))
        return;

    // If a drag was in progress, capture positions before we mutate the graph
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    // Early out if nothing selected
    const int numSelLinks = ImNodes::NumSelectedLinks();
    const int numSelNodes = ImNodes::NumSelectedNodes();

    if (numSelLinks <= 0 && numSelNodes <= 0)
        return;

    // Perform batch delete; snapshot after commit

    // Disconnect selected links
        if (numSelLinks > 0)
        {
        std::vector<int> ids((size_t) numSelLinks);
        ImNodes::GetSelectedLinks(ids.data());
        for (int id : ids)
        {
            // TODO: Handle modulation link deletion for new bus-based system
            // if (auto itM = modLinkIdToRoute.find (id); itM != modLinkIdToRoute.end())
            // {
            //     int sL, sC, dL; juce::String paramId; std::tie(sL, sC, dL, paramId) = itM->second;
            //     // TODO: Handle modulation route removal
            //     // if (paramId.isNotEmpty())
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL, paramId);
            //     // else
            //     //     synth->removeModulationRoute (synth->getNodeIdForLogical ((juce::uint32) sL), sC, (juce::uint32) dL);
            // }
            // else 
            if (auto it = linkIdToAttrs.find(id); it != linkIdToAttrs.end())
            {
                auto srcPin = decodePinId(it->second.first);
                auto dstPin = decodePinId(it->second.second);

                auto srcNode = synth->getNodeIdForLogical(srcPin.logicalId);
                auto dstNode = (dstPin.logicalId == 0) ? synth->getOutputNodeID() : synth->getNodeIdForLogical(dstPin.logicalId);
                synth->disconnect(srcNode, srcPin.channel, dstNode, dstPin.channel);
            }
            }
        }

        if (numSelNodes > 0)
        {
        std::vector<int> nodeIds((size_t) numSelNodes);
        ImNodes::GetSelectedNodes(nodeIds.data());
        // Build a set for quick lookup when removing connections
        std::unordered_map<int, bool> toDelete;
        for (int nid : nodeIds) toDelete[nid] = true;
        // Disconnect all connections touching any selected node
        for (const auto& c : synth->getConnectionsInfo())
        {
            if (toDelete.count((int) c.srcLogicalId) || (! c.dstIsOutput && toDelete.count((int) c.dstLogicalId)))
            {
                auto srcNode = synth->getNodeIdForLogical(c.srcLogicalId);
                auto dstNode = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
                synth->disconnect(srcNode, c.srcChan, dstNode, c.dstChan);
            }
        }
        // Remove nodes
        for (int nid : nodeIds)
        {
            if (nid == 0) continue; // don't delete output sink
            
            // Clean up vision module textures if exists
            if (visionModuleTextures.count(nid))
            {
                visionModuleTextures.erase(nid);
            }
            
            // Clean up sample loader textures if exists
            if (sampleLoaderTextureIds.count(nid))
            {
                sampleLoaderTextureIds.erase(nid);
            }
            
            mutedNodeStates.erase((juce::uint32)nid); // Clean up muted state if exists
            lastKnownNodePositions.erase(nid); // Clean up position cache
            synth->removeModule(synth->getNodeIdForLogical((juce::uint32) nid));
        }
    }
    graphNeedsRebuild = true;
    pushSnapshot();
}

void ImGuiNodeEditorComponent::bypassDeleteSelectedNodes()
{
    const int numSelNodes = ImNodes::NumSelectedNodes();
    if (numSelNodes <= 0 || synth == nullptr) return;

    // Snapshot positions first if dragging
    if (isDraggingNode || ImGui::IsMouseDragging(ImGuiMouseButton_Left))
    {
        isDraggingNode = false;
        pushSnapshot();
    }

    std::vector<int> nodeIds((size_t) numSelNodes);
    ImNodes::GetSelectedNodes(nodeIds.data());

    for (int nid : nodeIds)
    {
        if (nid == 0) continue; // don't bypass-delete the output sink
        bypassDeleteNode((juce::uint32) nid);
    }
    graphNeedsRebuild = true;
    pushSnapshot();
}

void ImGuiNodeEditorComponent::bypassDeleteNode(juce::uint32 logicalId)
{
    // Collect all incoming/outgoing audio links for this node
    std::vector<decltype(synth->getConnectionsInfo())::value_type> inputs, outputs;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) inputs.push_back(c);
        if (c.srcLogicalId == logicalId) outputs.push_back(c);
    }

    // For each output channel, find matching input channel to splice
    for (const auto& out : outputs)
    {
        // Try to find input with same channel index, else fallback to first input
        const auto* inPtr = (const decltype(inputs)::value_type*) nullptr;
        for (const auto& in : inputs) { if (in.dstChan == out.srcChan) { inPtr = &in; break; } }
        if (inPtr == nullptr && !inputs.empty()) inPtr = &inputs.front();

        // Disconnect out link first
        auto srcNode = synth->getNodeIdForLogical(out.srcLogicalId);
        auto dstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
        synth->disconnect(srcNode, out.srcChan, dstNode, out.dstChan);

        if (inPtr != nullptr)
        {
            // Disconnect incoming link from the node
            auto inSrcNode = synth->getNodeIdForLogical(inPtr->srcLogicalId);
            auto inDstNode = synth->getNodeIdForLogical(inPtr->dstLogicalId);
            synth->disconnect(inSrcNode, inPtr->srcChan, inDstNode, inPtr->dstChan);

            // Connect source of incoming directly to destination of outgoing
            auto finalDstNode = out.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out.dstLogicalId);
            synth->connect(inSrcNode, inPtr->srcChan, finalDstNode, out.dstChan);
        }
    }

    // TODO: Remove modulation routes targeting or originating this node using new bus-based system

    // Finally remove the node itself
    mutedNodeStates.erase(logicalId); // Clean up muted state if exists
    synth->removeModule(synth->getNodeIdForLogical(logicalId));
}

// === Non-Destructive Mute/Bypass Implementation ===

void ImGuiNodeEditorComponent::muteNodeSilent(juce::uint32 logicalId)
{
    // This function is used when loading presets. It records the connections that were
    // loaded from the XML without modifying the graph or creating bypass connections.
    // This preserves the original "unmuted" connections for later use.
    
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // Store all connections attached to this node
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // Store the state, but DON'T modify the graph or create bypass connections
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[MuteSilent] Node " + juce::String(logicalId) + 
                            " marked as muted, stored " + juce::String(state.incomingConnections.size()) + 
                            " incoming and " + juce::String(state.outgoingConnections.size()) + 
                            " outgoing connections.");
}

void ImGuiNodeEditorComponent::muteNode(juce::uint32 logicalId)
{
    if (!synth) return;

    MutedNodeState state;
    auto allConnections = synth->getConnectionsInfo();

    // 1. Find and store all connections attached to this node.
    for (const auto& c : allConnections) {
        if (!c.dstIsOutput && c.dstLogicalId == logicalId) {
            state.incomingConnections.push_back(c);
        }
        if (c.srcLogicalId == logicalId) {
            state.outgoingConnections.push_back(c);
        }
    }

    // 2. Disconnect all of them.
    for (const auto& c : state.incomingConnections) {
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->disconnect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }
    
    // --- FIX: More robust bypass splicing logic ---
    // 3. Splice the connections to bypass the node.
    // Connect the FIRST input source to ALL output destinations.
    // This correctly handles cases where input channel != output channel (e.g., Mixer input 3 ‚Üí output 0).
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Connect the primary input's source directly to the original output's destination
            synth->connect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Mute] Splicing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 4. Store the original state.
    mutedNodeStates[logicalId] = state;
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " muted and bypassed.");
}

void ImGuiNodeEditorComponent::unmuteNode(juce::uint32 logicalId)
{
    if (!synth || mutedNodeStates.find(logicalId) == mutedNodeStates.end()) return;

    MutedNodeState state = mutedNodeStates[logicalId];

    // --- FIX: Remove bypass connections matching the new mute logic ---
    // 1. Find and remove the bypass connections.
    // The bypass connected the first input source to all output destinations.
    if (!state.incomingConnections.empty() && !state.outgoingConnections.empty())
    {
        const auto& primary_input = state.incomingConnections[0];
        auto srcNodeId = synth->getNodeIdForLogical(primary_input.srcLogicalId);

        for (const auto& out_conn : state.outgoingConnections)
        {
            auto dstNodeId = out_conn.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(out_conn.dstLogicalId);
            // Disconnect the bypass connection
            synth->disconnect(srcNodeId, primary_input.srcChan, dstNodeId, out_conn.dstChan);
            juce::Logger::writeToLog("[Unmute] Removing bypass: [" + juce::String(primary_input.srcLogicalId) + 
                                    ":" + juce::String(primary_input.srcChan) + "] -> [" + 
                                    (out_conn.dstIsOutput ? "Output" : juce::String(out_conn.dstLogicalId)) + 
                                    ":" + juce::String(out_conn.dstChan) + "]");
        }
    }

    // 2. Restore the original connections.
    for (const auto& c : state.incomingConnections) {
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, synth->getNodeIdForLogical(c.dstLogicalId), c.dstChan);
    }
    for (const auto& c : state.outgoingConnections) {
        auto dstNodeId = c.dstIsOutput ? synth->getOutputNodeID() : synth->getNodeIdForLogical(c.dstLogicalId);
        synth->connect(synth->getNodeIdForLogical(c.srcLogicalId), c.srcChan, dstNodeId, c.dstChan);
    }

    // 3. Remove from muted state.
    mutedNodeStates.erase(logicalId);
    juce::Logger::writeToLog("[Mute] Node " + juce::String(logicalId) + " unmuted.");
}

void ImGuiNodeEditorComponent::handleMuteToggle()
{
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected == 0) return;

    pushSnapshot(); // Create a single undo state for the whole operation.

    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    for (int lid : selectedNodeIds) {
        if (mutedNodeStates.count(lid)) {
            unmuteNode(lid);
        } else {
            muteNode(lid);
        }
    }

    graphNeedsRebuild = true;
}


void ImGuiNodeEditorComponent::savePresetToFile(const juce::File& file)
{
    if (isSaveInProgress.exchange(true)) // Atomically check and set
    {
        juce::Logger::writeToLog("[SaveWorkflow] Save action ignored (already in progress).");
        return;
    }

    if (synth == nullptr) {
        NotificationManager::post(NotificationManager::Type::Error, "ERROR: Synth not ready!");
        isSaveInProgress.store(false);
        return;
    }

    juce::Logger::writeToLog("--- [Save Workflow] Initiated for: " + file.getFullPathName() + " ---");
    
    // Post status notification (long duration since it will be replaced by Success/Error when complete)
    NotificationManager::post(NotificationManager::Type::Status, "Saving: " + file.getFileNameWithoutExtension(), 1000.0f);
    
    // --- All fast operations now happen on the UI thread BEFORE the job is launched ---
    
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] Capturing state...");
    auto mutedNodeIDs = getMutedNodeIds();

    // Temporarily unmute to get correct connections
    for (auto lid : mutedNodeIDs) unmuteNode(lid);
    synth->commitChanges();

    // Capture state while unmuted
    juce::MemoryBlock synthState;
    synth->getStateInformation(synthState);
    juce::ValueTree uiState = getUiValueTree();

    // Immediately re-mute to restore visual state
    for (auto lid : mutedNodeIDs) muteNode(lid);
    synth->commitChanges();
    juce::Logger::writeToLog("[SaveWorkflow][UI_THREAD] State captured. Offloading to background thread.");

    // Launch the background job with the captured data
    auto* job = new SavePresetJob(synthState, uiState, file);

    job->onSaveComplete = [this](const juce::File& savedFile, bool success) {
        if (success) {
            NotificationManager::post(NotificationManager::Type::Success, "Saved: " + savedFile.getFileNameWithoutExtension());
            isPatchDirty = false;
            currentPresetFile = savedFile;
        } else {
            NotificationManager::post(NotificationManager::Type::Error, "Failed to save preset!");
        }
        isSaveInProgress.store(false); // Reset the flag
    };

    threadPool.addJob(job, true);
}

void ImGuiNodeEditorComponent::startSaveDialog()
{
    // Check if a save is already in progress to avoid opening multiple dialogs
    if (isSaveInProgress.load()) {
        juce::Logger::writeToLog("[SaveWorkflow] 'Save As' action ignored (a save is already in progress).");
        return;
    }

    saveChooser = std::make_unique<juce::FileChooser>("Save Preset As...", 
                                                      findPresetsDirectory(), 
                                                      "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | 
                             juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        auto fileToSave = fc.getResult();
        if (fileToSave != juce::File{}) // Check if user selected a file and didn't cancel
        {
            // Call the unified, asynchronous save function
            savePresetToFile(fileToSave);
        }
    });
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::getMutedNodeIds() const
{
    std::vector<juce::uint32> ids;
    // MutedNodeState is a map, so we don't need a lock if we're just reading keys
    for (const auto& pair : mutedNodeStates)
    {
        ids.push_back(pair.first);
    }
    return ids;
}


void ImGuiNodeEditorComponent::startLoadDialog()
{
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", findPresetsDirectory(), "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.existsAsFile())
        {
            loadPresetFromFile(f); // Use the unified loading function
        }
    });
}

void ImGuiNodeEditorComponent::handleRandomizePatch()
{
    if (synth == nullptr) return;
    
    populatePinDatabase();

    // 1. --- SETUP ---
    synth->clearAll();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());
    
    // 2. --- ADD A "CLOUD" OF RANDOM MODULES ---
    std::vector<juce::String> modulePool = {
        "VCO", "Noise", "Sequencer", "VCF", "Delay", "Reverb", "Waveshaper",
        "LFO", "ADSR", "Random", "S&H", "Math", "MapRange", "Quantizer", "ClockDivider"
    };
    int numModules = 6 + rng.nextInt(7); // 6 to 12 modules
    std::vector<std::pair<juce::uint32, juce::String>> addedModules;

    for (int i = 0; i < numModules; ++i) {
        auto type = modulePool[rng.nextInt(modulePool.size())];
        auto newId = synth->getLogicalIdForNode(synth->addModule(type));
        addedModules.push_back({newId, type});
    }

    // 3. --- ESTABLISH AN OBSERVATION POINT ---
    // Always add a Mixer and Scope. This is our window into the chaos.
    auto mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    addedModules.push_back({mixerId, "Mixer"});
    auto scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));
    addedModules.push_back({scopeId, "Scope"});
    
    // Connect the observation path: Mixer -> Scope -> Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 1, outputNodeId, 1);

    // 4. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;

    for (const auto& mod : addedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect a few random audio sources to the Mixer to make sound likely
    int numMixerInputs = 2 + rng.nextInt(3); // 2 to 4 mixer inputs
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            // Connect to mixer inputs 0, 1, 2, 3
            synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }

    // Make a large number of fully random connections
    int numRandomConnections = numModules + rng.nextInt(numModules);
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        // 70% chance of making a CV modulation connection
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        // 30% chance of making an audio-path or gate connection
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            // Allow self-connection for feedback
            if (source.first != target.first || rng.nextFloat() < 0.2f) {
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 5. --- LAYOUT AND FINALIZE ---
    // Arrange nodes in a neat grid to prevent overlap.
    const float startX = 50.0f;
    const float startY = 50.0f;
    const float cellWidth = 300.0f;
    const float cellHeight = 400.0f;
    const int numColumns = 4;
    int col = 0;
    int row = 0;

    juce::uint32 finalMixerId = 0, finalScopeId = 0;
    for (const auto& mod : addedModules) {
        if (mod.second == "Mixer") finalMixerId = mod.first;
        if (mod.second == "Scope") finalScopeId = mod.first;
    }

    for (const auto& mod : addedModules)
    {
        // Skip the special output-chain nodes; we will place them manually.
        if (mod.first == finalMixerId || mod.first == finalScopeId) continue;

        float x = startX + col * cellWidth;
        float y = startY + row * cellHeight;
        pendingNodePositions[(int)mod.first] = ImVec2(x, y);

        col++;
        if (col >= numColumns) {
            col = 0;
            row++;
        }
    }

    // Manually place the Mixer and Scope on the far right for a clean, readable signal flow.
    float finalX = startX + numColumns * cellWidth;
    if (finalMixerId != 0) pendingNodePositions[(int)finalMixerId] = ImVec2(finalX, startY);
    if (finalScopeId != 0) pendingNodePositions[(int)finalScopeId] = ImVec2(finalX, startY + cellHeight);
    
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleRandomizeConnections()
{
    if (synth == nullptr) return;
    auto currentModules = synth->getModulesInfo();
    if (currentModules.empty()) return;

    // 1. --- SETUP AND CLEAR ---
    synth->clearAllConnections();
    juce::Random rng(juce::Time::getMillisecondCounterHiRes());

    // 2. --- ESTABLISH AN OBSERVATION POINT ---
    juce::uint32 mixerId = 0, scopeId = 0;
    for (const auto& mod : currentModules) {
        if (mod.second == "Mixer") mixerId = mod.first;
        if (mod.second == "Scope") scopeId = mod.first;
    }
    // Add Mixer/Scope if they don't exist, as they are crucial for listening
    if (mixerId == 0) mixerId = synth->getLogicalIdForNode(synth->addModule("mixer"));
    if (scopeId == 0) scopeId = synth->getLogicalIdForNode(synth->addModule("scope"));

    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(synth->getNodeIdForLogical(mixerId), 0, synth->getNodeIdForLogical(scopeId), 0);
    synth->connect(synth->getNodeIdForLogical(scopeId), 0, outputNodeId, 0);

    // 3. --- CREATE CHAOTIC CONNECTIONS ---
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioOuts;
    std::vector<std::pair<juce::uint32, AudioPin>> allAudioIns;
    std::vector<std::pair<juce::uint32, ModPin>> allModIns;
    
    // Refresh module list in case we added a Mixer/Scope
    auto updatedModules = synth->getModulesInfo();
    for (const auto& mod : updatedModules) {
        auto it = getModulePinDatabase().find(mod.second);
        if (it != getModulePinDatabase().end()) {
            for(const auto& pin : it->second.audioOuts) allAudioOuts.push_back({mod.first, pin});
            for(const auto& pin : it->second.audioIns) allAudioIns.push_back({mod.first, pin});
            for(const auto& pin : it->second.modIns) allModIns.push_back({mod.first, pin});
        }
    }
    
    // Connect random sources to the Mixer
    int numMixerInputs = 2 + rng.nextInt(3);
    if (!allAudioOuts.empty()) {
        for (int i = 0; i < numMixerInputs; ++i) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            if (source.first != mixerId) // Don't connect mixer to itself here
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(mixerId), i);
        }
    }
    
    // Make a large number of fully random connections
    int numRandomConnections = (int)updatedModules.size() + rng.nextInt((int)updatedModules.size());
    for (int i = 0; i < numRandomConnections; ++i)
    {
        float choice = rng.nextFloat();
        if (choice < 0.7f && !allAudioOuts.empty() && !allModIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allModIns[rng.nextInt(allModIns.size())];
            // TODO: synth->addModulationRouteByLogical(source.first, source.second.channel, target.first, target.second.paramId);
        }
        else if (!allAudioOuts.empty() && !allAudioIns.empty()) {
            auto& source = allAudioOuts[rng.nextInt(allAudioOuts.size())];
            auto& target = allAudioIns[rng.nextInt(allAudioIns.size())];
            if (source.first != target.first || rng.nextFloat() < 0.2f) { // Allow feedback
                synth->connect(synth->getNodeIdForLogical(source.first), source.second.channel, synth->getNodeIdForLogical(target.first), target.second.channel);
            }
        }
    }

    // 4. --- FINALIZE ---
    synth->commitChanges();
    pushSnapshot();
}

void ImGuiNodeEditorComponent::handleBeautifyLayout()
{
    if (synth == nullptr) return;

    // Graph is always in consistent state since we rebuild at frame start
    // Create an undo state so the action can be reversed
    pushSnapshot();
    juce::Logger::writeToLog("--- [Beautify Layout] Starting ---");

    // --- STEP 1: Build Graph Representation ---
    // Adjacency list: map<source_lid, vector<destination_lid>>
    std::map<juce::uint32, std::vector<juce::uint32>> adjacencyList;
    std::map<juce::uint32, int> inDegree; // Counts incoming connections for each node
    std::vector<juce::uint32> sourceNodes;

    auto modules = synth->getModulesInfo();
    for (const auto& mod : modules)
    {
        inDegree[mod.first] = 0;
        adjacencyList[mod.first] = {};
    }
    // Include the output node in the graph
    inDegree[0] = 0; // Output node ID is 0
    adjacencyList[0] = {}; // Output node has no outgoing connections

    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput)
        {
            adjacencyList[conn.srcLogicalId].push_back(0); // Connect to output node
            inDegree[0]++;
        }
        else
        {
            adjacencyList[conn.srcLogicalId].push_back(conn.dstLogicalId);
            inDegree[conn.dstLogicalId]++;
        }
    }

    for (const auto& mod : modules)
    {
        if (inDegree[mod.first] == 0)
        {
            sourceNodes.push_back(mod.first);
        }
    }

    juce::Logger::writeToLog("[Beautify] Found " + juce::String(sourceNodes.size()) + " source nodes");

    // --- STEP 2: Assign Nodes to Columns (Topological Sort) ---
    std::map<juce::uint32, int> nodeColumn;
    std::vector<std::vector<juce::uint32>> columns;
    int maxColumn = 0;

    // Initialize source nodes in column 0
    for (juce::uint32 nodeId : sourceNodes)
    {
        nodeColumn[nodeId] = 0;
    }
    columns.push_back(sourceNodes);

    // Process each column and assign children to appropriate columns
    std::queue<juce::uint32> processQueue;
    for (juce::uint32 srcNode : sourceNodes)
        processQueue.push(srcNode);

    while (!processQueue.empty())
    {
        juce::uint32 u = processQueue.front();
        processQueue.pop();

        for (juce::uint32 v : adjacencyList[u])
        {
            // The column for node 'v' is the maximum of its predecessors' columns + 1
            int newColumn = nodeColumn[u] + 1;
            if (nodeColumn.count(v) == 0 || newColumn > nodeColumn[v])
            {
                nodeColumn[v] = newColumn;
                maxColumn = std::max(maxColumn, newColumn);
                processQueue.push(v);
            }
        }
    }

    // Re-populate columns based on assignments
    columns.assign(maxColumn + 1, {});
    for (const auto& pair : nodeColumn)
    {
        columns[pair.second].push_back(pair.first);
    }

    juce::Logger::writeToLog("[Beautify] Arranged nodes into " + juce::String(maxColumn + 1) + " columns");

    // --- STEP 3: Optimize Node Ordering Within Columns ---
    // Sort nodes in each column based on median position of their parents
    for (int c = 1; c <= maxColumn; ++c)
    {
        std::map<juce::uint32, float> medianPositions;
        
        for (juce::uint32 nodeId : columns[c])
        {
            std::vector<float> parentPositions;
            
            // Find all parents in previous columns
            for (const auto& pair : adjacencyList)
            {
                for (juce::uint32 dest : pair.second)
                {
                    if (dest == nodeId)
                    {
                        // Find the vertical index of the parent node
                        int parentColumn = nodeColumn[pair.first];
                        auto& parentColVec = columns[parentColumn];
                        auto it = std::find(parentColVec.begin(), parentColVec.end(), pair.first);
                        if (it != parentColVec.end())
                        {
                            parentPositions.push_back((float)std::distance(parentColVec.begin(), it));
                        }
                    }
                }
            }
            
            if (!parentPositions.empty())
            {
                std::sort(parentPositions.begin(), parentPositions.end());
                medianPositions[nodeId] = parentPositions[parentPositions.size() / 2];
            }
            else
            {
                medianPositions[nodeId] = 0.0f;
            }
        }
        
        // Sort the column based on median positions
        std::sort(columns[c].begin(), columns[c].end(), [&](juce::uint32 a, juce::uint32 b) {
            return medianPositions[a] < medianPositions[b];
        });
    }

    // --- STEP 4: Calculate Final Coordinates ---
    const float COLUMN_WIDTH = 400.0f;
    const float NODE_VERTICAL_PADDING = 50.0f;

    // Find the tallest column to center shorter ones
    float tallestColumnHeight = 0.0f;
    for (const auto& col : columns)
    {
        float height = 0.0f;
        for (juce::uint32 lid : col)
        {
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            height += nodeSize.y + NODE_VERTICAL_PADDING;
        }
        tallestColumnHeight = std::max(tallestColumnHeight, height);
    }

    // --- STEP 5: Apply Positions ---
    for (int c = 0; c <= maxColumn; ++c)
    {
        // Calculate column height for centering
        float columnHeight = 0.0f;
        for (juce::uint32 lid : columns[c])
        {
            columnHeight += ImNodes::GetNodeDimensions((int)lid).y + NODE_VERTICAL_PADDING;
        }
        
        // Start Y position (centered vertically)
        float currentY = (tallestColumnHeight - columnHeight) / 2.0f;

        for (juce::uint32 lid : columns[c])
        {
            float x = c * COLUMN_WIDTH;
            pendingNodePositions[(int)lid] = ImVec2(x, currentY);
            
            ImVec2 nodeSize = ImNodes::GetNodeDimensions((int)lid);
            currentY += nodeSize.y + NODE_VERTICAL_PADDING;
        }
    }

    // Position the output node to the right of all other modules
    float finalX = (maxColumn + 1) * COLUMN_WIDTH;
    float outputNodeY = (tallestColumnHeight - ImNodes::GetNodeDimensions(0).y) / 2.0f;
    pendingNodePositions[0] = ImVec2(finalX, outputNodeY);
    juce::Logger::writeToLog("[Beautify] Applied position to Output Node");
    
    juce::Logger::writeToLog("[Beautify] Applied positions to " + juce::String(modules.size()) + " nodes");
    juce::Logger::writeToLog("--- [Beautify Layout] Complete ---");
}

void ImGuiNodeEditorComponent::handleConnectSelectedToTrackMixer()
{
    if (synth == nullptr || ImNodes::NumSelectedNodes() <= 0)
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: No synth or no nodes selected.");
        return;
    }

    // This is a significant action, so create an undo state first.
    pushSnapshot();
    juce::Logger::writeToLog("--- [Connect to Mixer] Starting routine ---");

    // 1. Get all selected node IDs.
    const int numSelectedNodes = ImNodes::NumSelectedNodes();
    std::vector<int> selectedNodeLids(numSelectedNodes);
    ImNodes::GetSelectedNodes(selectedNodeLids.data());

    // 2. Find the geometric center of the selected nodes to position our new modules.
    float totalX = 0.0f, maxX = 0.0f, totalY = 0.0f;
    for (int lid : selectedNodeLids)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(lid);
        totalX += pos.x;
        totalY += pos.y;
        if (pos.x > maxX) {
            maxX = pos.x;
        }
    }
    ImVec2 centerPos = ImVec2(totalX / numSelectedNodes, totalY / numSelectedNodes);
    
    // 3. Create the Value node and set its value to the number of selected nodes.
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    if (auto* valueProc = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(valueProc->getAPVTS().getParameter("value")))
        {
            *p = (float)numSelectedNodes;
            juce::Logger::writeToLog("[AutoConnect] Created Value node " + juce::String(valueLid) + " and set its value to " + juce::String(numSelectedNodes));
        }
    }
    // Position it slightly to the right of the center of the selection.
    pendingNodePositions[(int)valueLid] = ImVec2(centerPos.x + 400.0f, centerPos.y);

    // 4. Create the Track Mixer node.
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    // Position it to the right of the right-most selected node for a clean signal flow.
    pendingNodePositions[(int)mixerLid] = ImVec2(maxX + 800.0f, centerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 5. Connect the Value node to the Track Mixer's "Num Tracks Mod" input.
    // The Value module's "Raw" output is channel 0 (provides the exact value entered by the user).
    // The Track Mixer's "Num Tracks Mod" is on Bus 1, Channel 0, which is absolute channel 64.
    synth->connect(valueNodeId, 0, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected Value node 'Raw' output to Track Mixer's Num Tracks Mod input.");

    // 6. Connect the primary audio output of each selected node to a unique input on the Track Mixer.
    int mixerInputChannel = 0;
    for (int lid : selectedNodeLids)
    {
        if (mixerInputChannel >= TrackMixerModuleProcessor::MAX_TRACKS) break;

        auto sourceNodeId = synth->getNodeIdForLogical((juce::uint32)lid);
        
        // We will connect the first audio output (channel 0) of the source to the next available mixer input.
        synth->connect(sourceNodeId, 0, mixerNodeId, mixerInputChannel);
        juce::Logger::writeToLog("[AutoConnect] Connected node " + juce::String(lid) + " (Out 0) to Track Mixer (In " + juce::String(mixerInputChannel + 1) + ")");
        
        mixerInputChannel++;
    }

    // 7. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [Connect to Mixer] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnect] Aborted: MIDI Player not ready.");
        return;
    }

    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);

    // --- FIX: Create and position the Track Mixer first ---
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 1200.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnect] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // --- FIX: Connect MIDI Player "Num Tracks" output to Track Mixer "Num Tracks Mod" input ---
    // This ensures the Track Mixer automatically adjusts its track count based on the MIDI file content
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
    juce::Logger::writeToLog("[AutoConnect] Connected MIDI Player Num Tracks to Track Mixer Num Tracks Mod");

    // 2. Create and connect a Sample Loader for each active MIDI track.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnect] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks.");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= MIDIPlayerModuleProcessor::kMaxTracks) break;

        // A. Create and position the new modules.
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y + (i * 350.0f));

        auto mapRangeNodeId = synth->addModule("map_range");
        auto mapRangeLid = synth->getLogicalIdForNode(mapRangeNodeId);
        pendingNodePositions[(int)mapRangeLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y + (i * 350.0f));
        
        // B. Configure the MapRange module for Pitch CV conversion.
        if (auto* mapRangeProc = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(mapRangeLid)))
        {
            auto& ap = mapRangeProc->getAPVTS();
            // MIDI Player Pitch Out (0..1) -> Sample Loader Pitch Mod (-24..+24 semitones)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMin"))) *p = 0.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("inMax"))) *p = 1.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMin"))) *p = -24.0f;
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("outMax"))) *p = 24.0f;
        }

        // C. Connect the outputs for this track.
        const int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        const int gateChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 1;
        const int trigChan  = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 3;

        // Pitch: MIDI Player -> MapRange -> Sample Loader
        synth->connect(midiPlayerNodeId, pitchChan, mapRangeNodeId, 0); // Pitch Out -> MapRange In
        synth->connect(mapRangeNodeId, 1, samplerNodeId, 0);             // MapRange Raw Out -> SampleLoader Pitch Mod In

        // Gate: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, gateChan, samplerNodeId, 2);    // Gate Out -> SampleLoader Gate Mod In

        // Trigger: MIDI Player -> Sample Loader
        synth->connect(midiPlayerNodeId, trigChan, samplerNodeId, 3);    // Trigger Out -> SampleLoader Trigger Mod In

        // --- FIX: Connect the Sample Loader's audio output to the Track Mixer ---
        // The Sample Loader's main audio output is channel 0.
        // The Track Mixer's inputs are mono channels 0, 1, 2...
        synth->connect(samplerNodeId, 0, mixerNodeId, i);
    }

    // --- FIX: Connect the mixer to the main output so you can hear it! ---
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R

    // 3. Flag the graph for a rebuild to apply all changes.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnect to Samplers] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer || midiPlayerLid == 0 || !midiPlayer->hasMIDIFileLoaded())
    {
        juce::Logger::writeToLog("[AutoConnectVCO] Aborted: MIDI Player not ready.");
        return;
    }
    
    juce::Logger::writeToLog("--- [AutoConnectVCO] Starting routine for MIDI Player " + juce::String(midiPlayerLid) + " ---");

    // 1. Get initial positions and clear all existing connections from the MIDI Player.
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPlayerPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);
    synth->clearConnectionsForNode(midiPlayerNodeId);
    
    // 2. Create and position the PolyVCO and Track Mixer.
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPlayerPos.x + 400.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created PolyVCO with logical ID " + juce::String(polyVcoLid));

    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(midiPlayerPos.x + 800.0f, midiPlayerPos.y);
    juce::Logger::writeToLog("[AutoConnectVCO] Created Track Mixer with logical ID " + juce::String(mixerLid));

    // 3. Connect the track count outputs to control both new modules.
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, polyVcoNodeId, 0); // Raw Num Tracks -> PolyVCO Num Voices Mod
    synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS); // Raw Num Tracks -> Mixer Num Tracks Mod
    juce::Logger::writeToLog("[AutoConnectVCO] Connected MIDI Player raw track counts to PolyVCO and Track Mixer modulation inputs.");
    
    // 4. Loop through active MIDI tracks to connect CV routes and audio.
    const auto& activeTrackIndices = midiPlayer->getActiveTrackIndices();
    juce::Logger::writeToLog("[AutoConnectVCO] MIDI file has " + juce::String(activeTrackIndices.size()) + " active tracks. Patching voices...");

    for (int i = 0; i < (int)activeTrackIndices.size(); ++i)
    {
        if (i >= PolyVCOModuleProcessor::MAX_VOICES) break; // Don't try to connect more voices than the PolyVCO has

        int sourceTrackIndex = activeTrackIndices[i];

        // A. Connect CV modulation routes from MIDI Player to the corresponding PolyVCO voice.
        int pitchChan = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 0;
        int velChan   = i * MIDIPlayerModuleProcessor::kOutputsPerTrack + 2;
        
        // Connect MIDI CV to the corresponding PolyVCO voice inputs
        synth->connect(midiPlayerNodeId, pitchChan, polyVcoNodeId, 1 + i); // Pitch -> Freq Mod
        synth->connect(midiPlayerNodeId, velChan,   polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Velocity -> Gate Mod

        // B. Connect the PolyVCO voice's audio output to the Track Mixer's input.
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // 5. Connect the Track Mixer to the main audio output.
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Main Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Main Out R
    
    // 6. Flag the graph for a rebuild.
    graphNeedsRebuild = true;
    juce::Logger::writeToLog("--- [AutoConnectVCO] Routine complete. ---");
}

void ImGuiNodeEditorComponent::handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid)
{
    if (!synth || !midiPlayer) return;

    pushSnapshot();

    const int numTracks = midiPlayer->getNumTracks();
    if (numTracks == 0) return;

    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    ImVec2 midiPos = ImNodes::GetNodeGridSpacePos((int)midiPlayerLid);

    // --- THIS IS THE NEW "FIND-BY-TRACING" LOGIC ---

    juce::uint32 polyVcoLid = 0;
    juce::uint32 trackMixerLid = 0;

    // 1. Scan existing connections to find modules to reuse by tracing backwards.
    // First, find a TrackMixer connected to the output.
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.dstIsOutput && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("trackmixer"))
        {
            trackMixerLid = conn.srcLogicalId; // Found a TrackMixer to reuse!
            break;
        }
    }
    // If we found a TrackMixer, now find a PolyVCO connected to it.
    if (trackMixerLid != 0)
    {
        for (const auto& conn : synth->getConnectionsInfo())
        {
            if (conn.dstLogicalId == trackMixerLid && synth->getModuleTypeForLogical(conn.srcLogicalId).equalsIgnoreCase("polyvco"))
            {
                polyVcoLid = conn.srcLogicalId; // Found a PolyVCO to reuse!
                break;
            }
        }
    }

    // 2. Clear all old Pitch/Gate/Velocity connections from the MIDI Player.
    std::vector<ModularSynthProcessor::ConnectionInfo> oldConnections;
    for (const auto& conn : synth->getConnectionsInfo())
    {
        if (conn.srcLogicalId == midiPlayerLid && conn.srcChan < 16 * 3)
            oldConnections.push_back(conn);
    }
    for (const auto& conn : oldConnections)
    {
        synth->disconnect(synth->getNodeIdForLogical(conn.srcLogicalId), conn.srcChan,
                          synth->getNodeIdForLogical(conn.dstLogicalId), conn.dstChan);
    }

    // 3. If we didn't find a PolyVCO to reuse after tracing, create a new one.
    if (polyVcoLid == 0)
    {
        auto polyVcoNodeId = synth->addModule("polyvco", false);
        polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
        pendingNodePositions[(int)polyVcoLid] = ImVec2(midiPos.x + 400.0f, midiPos.y);
    }

    // 4. If we didn't find a TrackMixer to reuse after tracing, create a new one.
    if (trackMixerLid == 0)
    {
        auto trackMixerNodeId = synth->addModule("track_mixer", false);
        trackMixerLid = synth->getLogicalIdForNode(trackMixerNodeId);
        pendingNodePositions[(int)trackMixerLid] = ImVec2(midiPos.x + 800.0f, midiPos.y);
    }
    // --- END OF NEW LOGIC ---

    auto polyVcoNodeId = synth->getNodeIdForLogical(polyVcoLid);
    auto trackMixerNodeId = synth->getNodeIdForLogical(trackMixerLid);

    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numTracks;
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(trackMixerLid)))
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numTracks;

    int voicesToConnect = std::min({numTracks, PolyVCOModuleProcessor::MAX_VOICES, 64});
    for (int i = 0; i < voicesToConnect; ++i)
    {
        synth->connect(midiPlayerNodeId, i, polyVcoNodeId, 1 + i);
        synth->connect(midiPlayerNodeId, i + 16, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2);
        synth->connect(polyVcoNodeId, i, trackMixerNodeId, i * 2 + 1);
    }
    
    synth->connect(trackMixerNodeId, 0, synth->getOutputNodeID(), 0);
    synth->connect(trackMixerNodeId, 1, synth->getOutputNodeID(), 1);

    synth->commitChanges();
}

void ImGuiNodeEditorComponent::handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid)
{
    if (!synth || !strokeSeq) return;

    juce::Logger::writeToLog("ü•Å BUILD DRUM KIT handler called! Creating modules...");

    // 1. Get Stroke Sequencer position
    auto seqNodeId = synth->getNodeIdForLogical(strokeSeqLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)strokeSeqLid);

    // 2. Create 3 Sample Loaders (for Floor, Mid, Ceiling triggers)
    auto sampler1NodeId = synth->addModule("sample_loader");
    auto sampler2NodeId = synth->addModule("sample_loader");
    auto sampler3NodeId = synth->addModule("sample_loader");
    
    auto sampler1Lid = synth->getLogicalIdForNode(sampler1NodeId);
    auto sampler2Lid = synth->getLogicalIdForNode(sampler2NodeId);
    auto sampler3Lid = synth->getLogicalIdForNode(sampler3NodeId);
    
    // Position samplers in a vertical stack to the right
    pendingNodePositions[(int)sampler1Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    pendingNodePositions[(int)sampler2Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 220.0f);
    pendingNodePositions[(int)sampler3Lid] = ImVec2(seqPos.x + 400.0f, seqPos.y + 440.0f);

    // 3. Create Track Mixer (will be set to 6 tracks by Value node)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 200.0f);

    // 4. Create Value node set to 6.0 (for 3 stereo tracks = 6 channels)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(seqPos.x + 600.0f, seqPos.y + 550.0f);
    
    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = 6.0f;
    }

    // 5. Connect Stroke Sequencer TRIGGERS to Sample Loader TRIGGER MOD inputs (channel 3)
    synth->connect(seqNodeId, 0, sampler1NodeId, 3); // Floor Trig   -> Sampler 1 Trigger Mod
    synth->connect(seqNodeId, 1, sampler2NodeId, 3); // Mid Trig     -> Sampler 2 Trigger Mod
    synth->connect(seqNodeId, 2, sampler3NodeId, 3); // Ceiling Trig -> Sampler 3 Trigger Mod

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    // Sampler 1 (L+R) -> Mixer Audio 1+2
    synth->connect(sampler1NodeId, 0, mixerNodeId, 0); // Sampler 1 L -> Mixer Audio 1
    synth->connect(sampler1NodeId, 1, mixerNodeId, 1); // Sampler 1 R -> Mixer Audio 2
    
    // Sampler 2 (L+R) -> Mixer Audio 3+4
    synth->connect(sampler2NodeId, 0, mixerNodeId, 2); // Sampler 2 L -> Mixer Audio 3
    synth->connect(sampler2NodeId, 1, mixerNodeId, 3); // Sampler 2 R -> Mixer Audio 4
    
    // Sampler 3 (L+R) -> Mixer Audio 5+6
    synth->connect(sampler3NodeId, 0, mixerNodeId, 4); // Sampler 3 L -> Mixer Audio 5
    synth->connect(sampler3NodeId, 1, mixerNodeId, 5); // Sampler 3 R -> Mixer Audio 6

    // 7. Connect Value node (6.0) to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value (6) -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid)
{
    if (!synth || !animModule) return;

    // Query the dynamic output pins to determine how many bones are tracked
    auto dynamicPins = animModule->getDynamicOutputPins();
    
    // Each bone has 3 outputs: Vel X, Vel Y, Hit
    // So number of bones = number of pins / 3
    int numTrackedBones = (int)dynamicPins.size() / 3;
    
    if (numTrackedBones == 0)
    {
        juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO: No tracked bones! Add bones first.");
        return;
    }

    juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO handler called! Creating modules for " + 
                             juce::String(numTrackedBones) + " tracked bones...");

    // 1. Get Animation Module position
    auto animNodeId = synth->getNodeIdForLogical(animModuleLid);
    ImVec2 animPos = ImNodes::GetNodeGridSpacePos((int)animModuleLid);

    // 2. Create one Sample Loader per tracked bone
    std::vector<juce::AudioProcessorGraph::NodeID> samplerNodeIds;
    std::vector<juce::uint32> samplerLids;
    
    for (int i = 0; i < numTrackedBones; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        samplerNodeIds.push_back(samplerNodeId);
        samplerLids.push_back(synth->getLogicalIdForNode(samplerNodeId));
        
        // Position samplers in a vertical stack to the right
        pendingNodePositions[(int)samplerLids[i]] = ImVec2(animPos.x + 400.0f, animPos.y + i * 220.0f);
    }

    // 3. Create Track Mixer (num_bones * 2 for stereo pairs)
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(animPos.x + 800.0f, animPos.y + (numTrackedBones * 110.0f));

    // 4. Create Value node for mixer track count
    int numMixerTracks = numTrackedBones * 2; // 2 channels per sampler (stereo)
    auto valueNodeId = synth->addModule("value");
    auto valueLid = synth->getLogicalIdForNode(valueNodeId);
    pendingNodePositions[(int)valueLid] = ImVec2(animPos.x + 600.0f, animPos.y + (numTrackedBones * 220.0f));

    if (auto* valueNode = dynamic_cast<ValueModuleProcessor*>(synth->getModuleForLogical(valueLid)))
    {
        *dynamic_cast<juce::AudioParameterFloat*>(valueNode->getAPVTS().getParameter("value")) = (float)numMixerTracks;
    }

    // 5. Connect Animation Module TRIGGERS to Sample Loader TRIGGER MOD inputs
    // Animation Module Output Channels (per bone):
    //   i*3 + 0: Bone Vel X
    //   i*3 + 1: Bone Vel Y
    //   i*3 + 2: Bone Hit (trigger) ‚Üê Connect this to sampler
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int triggerChannel = i * 3 + 2; // Every 3rd channel starting at 2 (2, 5, 8, 11, ...)
        synth->connect(animNodeId, triggerChannel, samplerNodeIds[i], 3); // Bone Hit -> Sampler Trigger Mod
    }

    // 6. Connect Sample Loader AUDIO OUTPUTS to Track Mixer AUDIO INPUTS (stereo pairs)
    for (int i = 0; i < numTrackedBones; ++i)
    {
        int mixerChannelL = i * 2;       // 0, 2, 4, 6, ...
        int mixerChannelR = i * 2 + 1;   // 1, 3, 5, 7, ...
        
        synth->connect(samplerNodeIds[i], 0, mixerNodeId, mixerChannelL); // Sampler L -> Mixer Audio L
        synth->connect(samplerNodeIds[i], 1, mixerNodeId, mixerChannelR); // Sampler R -> Mixer Audio R
    }

    // 7. Connect Value node to Track Mixer's "Num Tracks" input
    synth->connect(valueNodeId, 0, mixerNodeId, 64); // Value -> Num Tracks Mod

    // 8. Connect Track Mixer output to global output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Mixer Out L -> Global Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Mixer Out R -> Global Out R

    synth->commitChanges();
    graphNeedsRebuild = true;
    
    juce::Logger::writeToLog("ü¶∂ BUILD TRIGGERS AUDIO complete! " + juce::String(numTrackedBones) + 
                             " samplers + mixer + wiring created.");
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. Create the necessary Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y + 100.0f);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        *dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")) = numSteps;
    }

    // 3. CREATE a Sample Loader for each step and connect its audio to the mixer
    for (int i = 0; i < numSteps; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(seqPos.x + 400.0f, seqPos.y + (i * 220.0f));

        // Connect this sampler's audio output to the mixer's input
        synth->connect(samplerNodeId, 0 /*Audio Output*/, mixerNodeId, i);
        
        // Connect the Sequencer's CV/Trig for this step directly to the new sampler
        synth->connect(seqNodeId, 7 + i * 3 + 0, samplerNodeId, 0); // Pitch N -> Pitch Mod
        synth->connect(seqNodeId, 1, samplerNodeId, 2); // Main Gate -> Gate Mod
        synth->connect(seqNodeId, 7 + i * 3 + 2, samplerNodeId, 3); // Trig N  -> Trigger Mod
    }
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod

    // 4. Connect the mixer to the main output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid)
{
    if (!synth || !sequencer) return;

    // 1. Get Sequencer info and clear its old connections
    auto seqNodeId = synth->getNodeIdForLogical(sequencerLid);
    ImVec2 seqPos = ImNodes::GetNodeGridSpacePos((int)sequencerLid);
    const int numSteps = static_cast<int>(sequencer->getAPVTS().getRawParameterValue("numSteps")->load());
    synth->clearConnectionsForNode(seqNodeId);

    // 2. CREATE the PolyVCO and Track Mixer
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(seqPos.x + 400.0f, seqPos.y);
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices"))) *p = numSteps;
    }
    
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(seqPos.x + 800.0f, seqPos.y);
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid))) {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks"))) *p = numSteps;
    }

    // 3. Connect CV, Audio, and Main Output
    for (int i = 0; i < numSteps; ++i)
    {
        // Connect CV: Sequencer -> PolyVCO
        synth->connect(seqNodeId, 7 + i * 3 + 0, polyVcoNodeId, 1 + i);                                  // Pitch N -> Freq N Mod
        synth->connect(seqNodeId, 1, polyVcoNodeId, 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i); // Main Gate -> Gate N Mod

        // Connect Audio: PolyVCO -> Mixer
        synth->connect(polyVcoNodeId, i, mixerNodeId, i);
    }
    
    // Connect Num Steps output (channel 6) to PolyVCO's Num Voices Mod input (channel 0)
    synth->connect(seqNodeId, 6, polyVcoNodeId, 0); // Num Steps -> Num Voices Mod
    
    // Connect Num Steps output (channel 6) to Track Mixer's Num Tracks Mod input (channel 64)
    synth->connect(seqNodeId, 6, mixerNodeId, 64); // Num Steps -> Num Tracks Mod
    
    // Connect Mixer -> Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectPolyVCO(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info and get number of tracked colors
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count using the new helper method
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create PolyVCO with matching number of voices
    auto polyVcoNodeId = synth->addModule("polyvco");
    auto polyVcoLid = synth->getLogicalIdForNode(polyVcoNodeId);
    pendingNodePositions[(int)polyVcoLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y);
    
    if (auto* vco = dynamic_cast<PolyVCOModuleProcessor*>(synth->getModuleForLogical(polyVcoLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(vco->getAPVTS().getParameter("numVoices")))
            *p = numColors;
    }
    
    // 3. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 4. Connect Num Colors output to PolyVCO's NumVoices Mod and TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, polyVcoNodeId, 0); // Num Colors -> NumVoices Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64);  // Num Colors -> Num Tracks Mod
    
    // 5. Connect ColorTracker outputs to PolyVCO inputs
    for (int i = 0; i < numColors; ++i)
    {
        // Map X position to pitch/frequency for voice i
        synth->connect(colorTrackerNodeId, i * 3 + 0, polyVcoNodeId, 1 + i); // X -> Freq Mod
        
        // Map Area to gate level for voice i
        const int gateModChannel = 1 + PolyVCOModuleProcessor::MAX_VOICES * 2 + i;
        synth->connect(colorTrackerNodeId, i * 3 + 2, polyVcoNodeId, gateModChannel); // Area -> Gate Mod
    }
    
    // 6. Connect PolyVCO audio outputs to Track Mixer inputs
    for (int i = 0; i < numColors; ++i)
    {
        synth->connect(polyVcoNodeId, i, mixerNodeId, i); // Voice i -> Mixer Track i
    }
    
    // 7. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to PolyVCO.");
}

void ImGuiNodeEditorComponent::handleColorTrackerAutoConnectSamplers(ColorTrackerModule* colorTracker, juce::uint32 colorTrackerLid)
{
    if (!synth || !colorTracker) return;

    // 1. Get ColorTracker info
    auto colorTrackerNodeId = synth->getNodeIdForLogical(colorTrackerLid);
    ImVec2 colorTrackerPos = ImNodes::GetNodeGridSpacePos((int)colorTrackerLid);
    
    // Get tracked colors count
    int numColors = colorTracker->getTrackedColorsCount();
    
    if (numColors == 0)
    {
        juce::Logger::writeToLog("[ColorTracker Auto-Connect] No colors tracked, aborting.");
        return;
    }
    
    // 2. Create Track Mixer
    auto mixerNodeId = synth->addModule("track_mixer");
    auto mixerLid = synth->getLogicalIdForNode(mixerNodeId);
    pendingNodePositions[(int)mixerLid] = ImVec2(colorTrackerPos.x + 800.0f, colorTrackerPos.y + 100.0f);
    
    if (auto* mixer = dynamic_cast<TrackMixerModuleProcessor*>(synth->getModuleForLogical(mixerLid)))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterInt*>(mixer->getAPVTS().getParameter("numTracks")))
            *p = numColors;
    }

    // 3. Connect Num Colors output to TrackMixer's Num Tracks Mod
    synth->connect(colorTrackerNodeId, 72, mixerNodeId, 64); // Num Colors -> Num Tracks Mod

    // 4. Create a Sample Loader for each tracked color
    for (int i = 0; i < numColors; ++i)
    {
        auto samplerNodeId = synth->addModule("sample_loader");
        auto samplerLid = synth->getLogicalIdForNode(samplerNodeId);
        pendingNodePositions[(int)samplerLid] = ImVec2(colorTrackerPos.x + 400.0f, colorTrackerPos.y + (i * 220.0f));

        // Connect Sample Loader audio output to mixer
        synth->connect(samplerNodeId, 0, mixerNodeId, i); // Audio -> Mixer Track i
        
        // Connect ColorTracker CV outputs to Sample Loader modulation inputs
        synth->connect(colorTrackerNodeId, i * 3 + 0, samplerNodeId, 0); // X -> Pitch Mod
        synth->connect(colorTrackerNodeId, i * 3 + 2, samplerNodeId, 2); // Area -> Gate Mod
    }
    
    // 5. Connect Track Mixer to Main Output
    auto outputNodeId = synth->getOutputNodeID();
    synth->connect(mixerNodeId, 0, outputNodeId, 0); // Out L
    synth->connect(mixerNodeId, 1, outputNodeId, 1); // Out R

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[ColorTracker Auto-Connect] Connected " + juce::String(numColors) + " colors to Sample Loaders.");
}

// Add this exact helper function to the class
void ImGuiNodeEditorComponent::parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex)
{
    outIndex = -1; // Default to no index
    outType = fullName;

    if (fullName.contains(" "))
    {
        const juce::String lastWord = fullName.substring(fullName.lastIndexOfChar(' ') + 1);
        if (lastWord.containsOnly("0123456789"))
        {
            outIndex = lastWord.getIntValue();
            outType = fullName.substring(0, fullName.lastIndexOfChar(' '));
        }
    }
}

// Helper functions to get pins from modules
std::vector<AudioPin> ImGuiNodeEditorComponent::getOutputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioOuts;
    return {};
}

std::vector<AudioPin> ImGuiNodeEditorComponent::getInputPins(const juce::String& moduleType)
{
    auto it = getModulePinDatabase().find(moduleType);
    if (it != getModulePinDatabase().end())
        return it->second.audioIns;
    return {};
}

AudioPin* ImGuiNodeEditorComponent::findInputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getInputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

AudioPin* ImGuiNodeEditorComponent::findOutputPin(const juce::String& moduleType, const juce::String& pinName)
{
    auto pins = getOutputPins(moduleType);
    for (auto& pin : pins)
    {
        if (pin.name == pinName)
            return &pin;
    }
    return nullptr;
}

std::vector<juce::uint32> ImGuiNodeEditorComponent::findNodesOfType(const juce::String& moduleType)
{
    std::vector<juce::uint32> result;
    if (!synth) return result;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleTypeForLogical(modInfo.first) == moduleType)
        {
            result.push_back(modInfo.first);
        }
    }
    return result;
}

// New dynamic pin-fetching helper
std::vector<PinInfo> ImGuiNodeEditorComponent::getDynamicOutputPins(ModuleProcessor* module)
{
    std::vector<PinInfo> pins;
    if (!module) return pins;

    const int numOutputChannels = module->getBus(false, 0)->getNumberOfChannels();
    for (int i = 0; i < numOutputChannels; ++i)
    {
        juce::String pinName = module->getAudioOutputLabel(i);
        if (pinName.isNotEmpty())
        {
            pins.push_back({(uint32_t)i, pinName}); // Store the full pin name in the type field
        }
    }
    return pins;
}

// Template function implementations
template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToMonophonicTargets(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping,
    const std::vector<juce::uint32>& targetLids)
{
    if (!synth || !sourceNode || targetLids.empty()) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToMonophonicTargets called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    // Use provided target logical IDs explicitly
    auto targetNodes = targetLids;

    int currentTargetIndex = 0;

    // First, group all of the source node's output pins by their index number.
    // For example, "Pitch 1" and "Trig 1" will both be in the group for index 1.
    std::map<int, std::vector<PinInfo>> pinsByIndex;
    
    // THE FIX: Get pins directly from the module instance.
    auto outputPins = getDynamicOutputPins(sourceNode);
    
    for (const auto& pin : outputPins)
    {
        juce::String type;
        int index = -1;
        parsePinName(pin.type, type, index); // Use pin.type instead of pin.name
        if (index != -1) {
            // Store channel ID as the pin's ID
            pinsByIndex[index].push_back({(uint32_t)pin.id, type}); 
        }
    }

    // Now, loop through each group of pins (each voice).
    for (auto const& [index, pinsInGroup] : pinsByIndex)
    {
        if (currentTargetIndex >= (int)targetNodes.size()) break; // Stop if we run out of targets
        auto targetNodeId = targetNodes[currentTargetIndex];

        // For each pin in the group (e.g., for "Pitch 1" and "Trig 1")...
        for (const auto& pinInfo : pinsInGroup)
        {
            // Check if we have a connection rule for this pin type (e.g., "Pitch").
            if (pinNameMapping.count(pinInfo.type))
            {
                juce::String targetPinName = pinNameMapping.at(pinInfo.type);
                auto* targetPin = findInputPin("sample loader", targetPinName);

                // If the target pin exists, create the connection.
                if (targetPin)
                {
                    juce::uint32 sourceLogicalId = 0;
                    for (const auto& modInfo : synth->getModulesInfo())
                    {
                        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
                        {
                            sourceLogicalId = modInfo.first;
                            break;
                        }
                    }
                    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);
                    synth->connect(sourceNodeId, pinInfo.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
                }
            }
        }
        // IMPORTANT: Move to the next target module for the next voice.
        currentTargetIndex++;
    }
}

template<typename TargetProcessorType>
void ImGuiNodeEditorComponent::connectToPolyphonicTarget(
    ModuleProcessor* sourceNode,
    const std::map<juce::String, juce::String>& pinNameMapping)
{
    if (!synth || !sourceNode) return;
    
    juce::Logger::writeToLog("[AutoConnect] connectToPolyphonicTarget called for " + sourceNode->getName());
    
    // Get the source module type
    juce::String sourceModuleType;
    juce::uint32 sourceLogicalId = 0;
    for (const auto& modInfo : synth->getModulesInfo())
    {
        if (synth->getModuleForLogical(modInfo.first) == sourceNode)
        {
            sourceModuleType = synth->getModuleTypeForLogical(modInfo.first);
            sourceLogicalId = modInfo.first;
            break;
        }
    }
    
    if (sourceModuleType.isEmpty()) return;
    
    auto targetNodes = findNodesOfType("polyvco");
    if (targetNodes.empty()) return;
    auto targetNodeId = targetNodes[0]; // Use the first available PolyVCO

    auto sourceNodeId = synth->getNodeIdForLogical(sourceLogicalId);

    // THE FIX: Get pins directly from the module instance, not the database.
    auto outputPins = getDynamicOutputPins(sourceNode);

    // Loop through every output pin on the source module.
    for (const auto& sourcePin : outputPins)
    {
        // Parse the source pin's name to get its type and index.
        juce::String sourceType;
        int sourceIndex = -1;
        parsePinName(sourcePin.type, sourceType, sourceIndex); // Use pin.type instead of pin.name

        if (sourceIndex == -1) continue; // Skip pins that aren't numbered.

        // Check if we have a rule for this pin type (e.g., "Pitch" maps to "Freq").
        if (pinNameMapping.count(sourceType))
        {
            juce::String targetType = pinNameMapping.at(sourceType);
            // PolyVCO inputs use the format "Freq 1 Mod", "Gate 1 Mod", etc.
            juce::String targetPinName = targetType + " " + juce::String(sourceIndex) + " Mod";

            // Find that pin on the target and connect it if available.
            auto* targetPin = findInputPin("polyvco", targetPinName);
            if (targetPin)
            {
                synth->connect(sourceNodeId, sourcePin.id, synth->getNodeIdForLogical(targetNodeId), targetPin->channel);
            }
        }
    }
}

void ImGuiNodeEditorComponent::handleAutoConnectionRequests()
{
    if (!synth) return;
    
    for (const auto& modInfo : synth->getModulesInfo())
    {
        auto* module = synth->getModuleForLogical(modInfo.first);
        if (!module) continue;

        // --- Check MultiSequencer Flags ---
        if (auto* multiSeq = dynamic_cast<MultiSequencerModuleProcessor*>(module))
        {
            if (multiSeq->autoConnectSamplersTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectSamplers(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
            if (multiSeq->autoConnectVCOTriggered.exchange(false))
            {
                handleMultiSequencerAutoConnectVCO(multiSeq, modInfo.first); // Call the new specific handler
                pushSnapshot();
                return;
            }
        }
        
        // --- Check ColorTracker Flags ---
        if (auto* colorTracker = dynamic_cast<ColorTrackerModule*>(module))
        {
            if (colorTracker->autoConnectPolyVCOTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectPolyVCO(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
            if (colorTracker->autoConnectSamplersTriggered.exchange(false))
            {
                handleColorTrackerAutoConnectSamplers(colorTracker, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check StrokeSequencer Flags ---
        if (auto* strokeSeq = dynamic_cast<StrokeSequencerModuleProcessor*>(module))
        {
            if (strokeSeq->autoBuildDrumKitTriggered.exchange(false))
            {
                handleStrokeSeqBuildDrumKit(strokeSeq, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check AnimationModule Flags ---
        if (auto* animModule = dynamic_cast<AnimationModuleProcessor*>(module))
        {
            if (animModule->autoBuildTriggersAudioTriggered.exchange(false))
            {
                handleAnimationBuildTriggersAudio(animModule, modInfo.first);
                pushSnapshot();
                return;
            }
        }
        
        // --- Check MIDIPlayer Flags ---
        if (auto* midiPlayer = dynamic_cast<MIDIPlayerModuleProcessor*>(module))
        {
            if (midiPlayer->autoConnectTriggered.exchange(false)) // Samplers
            {
                handleMidiPlayerAutoConnect(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectVCOTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectVCO(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
            if (midiPlayer->autoConnectHybridTriggered.exchange(false))
            {
                handleMidiPlayerAutoConnectHybrid(midiPlayer, modInfo.first); // Reuse old detailed handler
                pushSnapshot();
                return;
            }
        }
    }
}

void ImGuiNodeEditorComponent::handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType)
{
    if (!synth || !midiPlayer) return;
    
    juce::Logger::writeToLog("[MIDI Player Quick Connect] Request type: " + juce::String(requestType));
    
    // Get ALL tracks (don't filter by whether they have notes)
    const auto& notesByTrack = midiPlayer->getNotesByTrack();
    int numTracks = (int)notesByTrack.size();
    
    if (numTracks == 0)
    {
        juce::Logger::writeToLog("[MIDI Player Quick Connect] No tracks in MIDI file");
        return;
    }
    
    // Get MIDI Player position for positioning new nodes
    ImVec2 playerPos = ImNodes::GetNodeEditorSpacePos(static_cast<int>(midiPlayerLid));
    auto midiPlayerNodeId = synth->getNodeIdForLogical(midiPlayerLid);
    
    // Request Type: 1=PolyVCO, 2=Samplers, 3=Both
    juce::uint32 polyVCOLid = 0;
    juce::uint32 mixerLid = 0;
    
    if (requestType == 1 || requestType == 3) // PolyVCO or Both
    {
        // 1. Create PolyVCO
        auto polyVCONodeId = synth->addModule("polyvco");
        polyVCOLid = synth->getLogicalIdForNode(polyVCONodeId);
        pendingNodeScreenPositions[(int)polyVCOLid] = ImVec2(playerPos.x + 400.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created PolyVCO at LID " + juce::String((int)polyVCOLid));
        
        // 2. Create Track Mixer
        auto mixerNodeId = synth->addModule("track_mixer");
        mixerLid = synth->getLogicalIdForNode(mixerNodeId);
        pendingNodeScreenPositions[(int)mixerLid] = ImVec2(playerPos.x + 700.0f, playerPos.y);
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        
        // 3. Connect MIDI Player tracks to PolyVCO
        // Connect ALL tracks, regardless of whether they have notes
        int trackIdx = 0;
        for (size_t i = 0; i < notesByTrack.size() && trackIdx < 32; ++i)
        {
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiVeloPin = trackIdx * 4 + 2;
            
            const int vcoFreqPin = trackIdx + 1;
            const int vcoWavePin = 32 + trackIdx + 1;
            const int vcoGatePin = 64 + trackIdx + 1;
            
            synth->connect(midiPlayerNodeId, midiPitchPin, polyVCONodeId, vcoFreqPin);
            synth->connect(midiPlayerNodeId, midiGatePin, polyVCONodeId, vcoGatePin);
            synth->connect(midiPlayerNodeId, midiVeloPin, polyVCONodeId, vcoWavePin);
            trackIdx++;
        }
        
        // 4. Connect Num Tracks to PolyVCO (Num Voices Mod on channel 0)
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       polyVCONodeId, 0);
        
        // 5. Connect PolyVCO outputs to Track Mixer inputs
        for (int i = 0; i < trackIdx; ++i)
        {
            synth->connect(polyVCONodeId, i, mixerNodeId, i);
        }
        
        // 6. Connect Num Tracks output to mixer's Num Tracks Mod input
        synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                       mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
        
        // 7. Connect Track Mixer to main output
        auto outputNodeId = synth->getOutputNodeID();
        synth->connect(mixerNodeId, 0, outputNodeId, 0); // L
        synth->connect(mixerNodeId, 1, outputNodeId, 1); // R
        
        juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                " tracks: MIDI Player ‚Üí PolyVCO ‚Üí Track Mixer ‚Üí Output");
    }
    
    if (requestType == 2 || requestType == 3) // Samplers or Both
    {
        float samplerX = playerPos.x + 400.0f;
        float mixerX = playerPos.x + 700.0f;
        
        // If PolyVCO mode (Both), offset samplers and use same mixer
        if (requestType == 3)
        {
            samplerX += 300.0f; // Offset samplers if PolyVCO exists
            // Reuse existing mixer created in PolyVCO section
        }
        else
        {
            // 1. Create Track Mixer for Samplers-only mode
            auto mixerNodeId = synth->addModule("track_mixer");
            mixerLid = synth->getLogicalIdForNode(mixerNodeId);
            pendingNodeScreenPositions[(int)mixerLid] = ImVec2(mixerX, playerPos.y);
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Created Track Mixer at LID " + juce::String((int)mixerLid));
        }
        
        // 2. Create samplers and connect
        // Connect ALL tracks, regardless of whether they have notes
        auto mixerNodeId = synth->getNodeIdForLogical(mixerLid);
        int trackIdx = 0;
        int totalTracks = (int)notesByTrack.size();
        int mixerStartChannel = (requestType == 3) ? totalTracks : 0; // Offset for "Both" mode
        
        for (size_t i = 0; i < notesByTrack.size(); ++i)
        {
            // Create SampleLoader
            float samplerY = playerPos.y + (trackIdx * 150.0f);
            auto samplerNodeId = synth->addModule("sample_loader");
            juce::uint32 samplerLid = synth->getLogicalIdForNode(samplerNodeId);
            pendingNodeScreenPositions[(int)samplerLid] = ImVec2(samplerX, samplerY);
            
            const int midiPitchPin = trackIdx * 4 + 1;
            const int midiGatePin = trackIdx * 4 + 0;
            const int midiTrigPin = trackIdx * 4 + 3;
            
            // Connect MIDI Player to Sampler
            synth->connect(midiPlayerNodeId, midiPitchPin, samplerNodeId, 0);
            synth->connect(midiPlayerNodeId, midiGatePin, samplerNodeId, 2);
            synth->connect(midiPlayerNodeId, midiTrigPin, samplerNodeId, 3);
            
            // Connect Sampler output to Track Mixer input
            synth->connect(samplerNodeId, 0, mixerNodeId, mixerStartChannel + trackIdx);
            
            trackIdx++;
        }
        
        // 3. Connect Num Tracks to mixer and route to output (only if not already done in PolyVCO mode)
        if (requestType != 3)
        {
            synth->connect(midiPlayerNodeId, MIDIPlayerModuleProcessor::kRawNumTracksChannelIndex, 
                           mixerNodeId, TrackMixerModuleProcessor::MAX_TRACKS);
            
            // 4. Connect Track Mixer to output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(mixerNodeId, 0, outputNodeId, 0);
            synth->connect(mixerNodeId, 1, outputNodeId, 1);
            
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Complete chain: " + juce::String(trackIdx) + 
                                    " SampleLoaders ‚Üí Track Mixer (with Num Tracks) ‚Üí Stereo Output");
        }
        else
        {
            juce::Logger::writeToLog("[MIDI Player Quick Connect] Connected " + juce::String(trackIdx) + 
                                    " SampleLoaders ‚Üí Track Mixer (channels " + juce::String(mixerStartChannel) + 
                                    "-" + juce::String(mixerStartChannel + trackIdx - 1) + 
                                    ") [Mixer already connected in PolyVCO section]");
        }
    }
    
    // Commit changes
    if (synth)
    {
        synth->commitChanges();
        graphNeedsRebuild = true;
    }
    
    pushSnapshot();
}

void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        const int numSelected = ImNodes::NumSelectedLinks();
        const bool isMultiInsert = numSelected > 1;

        // --- Module Insertion on Cables (Organized by Category) ---
        // Map format: {Display Name, Internal Type}
        // Internal types use lowercase with underscores for spaces
        const std::map<const char*, const char*> audioInsertable = {
            // Effects
            {"VCF", "vcf"}, {"Delay", "delay"}, {"Reverb", "reverb"},
            {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
            {"Limiter", "limiter"}, {"Noise Gate", "gate"}, {"Drive", "drive"},
            {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"}, 
            {"8-Band Shaper", "8bandshaper"}, {"Granulator", "granulator"}, 
            {"Harmonic Shaper", "harmonic_shaper"}, {"Time/Pitch Shifter", "timepitch"},
            {"De-Crackle", "de_crackle"},
            // Utilities
            {"VCA", "vca"}, {"Mixer", "mixer"}, {"Attenuverter", "attenuverter"},
            // Modulators
            {"Function Generator", "function_generator"}, {"Shaping Oscillator", "shaping_oscillator"},
            // TTS
            {"Vocal Tract Filter", "vocal_tract_filter"},
            // Analysis
            {"Scope", "scope"}, {"Frequency Graph", "frequency_graph"}
        };
        const std::map<const char*, const char*> modInsertable = {
            // Utilities
            {"Attenuverter", "attenuverter"}, {"Lag Processor", "lag_processor"}, 
            {"Math", "math"}, {"Map Range", "map_range"}, {"Quantizer", "quantizer"},
            {"Rate", "rate"}, {"Comparator", "comparator"}, {"Logic", "logic"},
            {"CV Mixer", "cv_mixer"}, {"Sequential Switch", "sequential_switch"},
            // Modulators
            {"S&H", "s_and_h"}, {"Function Generator", "function_generator"},
            // Sequencers
            {"Timeline", "timeline"},
            // Computer Vision (Video processing - Video cables are treated as mod)
            // Passthrough nodes (Video In ‚Üí Video Out)
            {"Video FX", "video_fx"}, {"Crop Video", "crop_video"},
            {"Movement Detector", "movement_detector"},
            {"Human Detector", "human_detector"}, {"Object Detector", "object_detector"},
            {"Pose Estimator", "pose_estimator"}, {"Hand Tracker", "hand_tracker"},
            {"Face Tracker", "face_tracker"}, {"Color Tracker", "color_tracker"},
            {"Contour Detector", "contour_detector"}, {"Semantic Segmentation", "semantic_segmentation"}
        };
        const auto& listToShow = linkToInsertOn.isMod ? modInsertable : audioInsertable;

        if (isMultiInsert)
            ImGui::Text("Insert Node on %d Cables", numSelected);
        else
            ImGui::Text("Insert Node on Cable");

        // --- FIX: Iterate over map pairs instead of simple strings ---
        for (const auto& pair : listToShow)
        {
            // pair.first = display label, pair.second = internal type
            if (ImGui::MenuItem(pair.first))
            {
                if (isMultiInsert)
                {
                    handleInsertNodeOnSelectedLinks(pair.second);
                }
                else
                {
                    insertNodeBetween(pair.second);
                }
                ImGui::CloseCurrentPopup();
            }
        }
        
        // VST Plugins submenu (only for audio cables)
        if (!linkToInsertOn.isMod)
        {
            ImGui::Separator();
            if (ImGui::BeginMenu("VST"))
            {
                auto& app = PresetCreatorApplication::getApp();
                auto& knownPluginList = app.getKnownPluginList();
                
                for (const auto& desc : knownPluginList.getTypes())
                {
                    if (ImGui::MenuItem(desc.name.toRawUTF8()))
                    {
                        if (isMultiInsert)
                        {
                            handleInsertNodeOnSelectedLinks(desc.name);
                        }
                        else
                        {
                            insertNodeBetween(desc.name);
                        }
                        ImGui::CloseCurrentPopup();
                    }
                    
                    // Show tooltip with plugin info
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
                        ImGui::Text("Version: %s", desc.version.toRawUTF8());
                        ImGui::EndTooltip();
                    }
                }
                ImGui::EndMenu();
            }
        }
        
        ImGui::EndPopup();
    }
    else
    {
        // --- FIX: Reset state when popup is closed ---
        // If the popup is not open (i.e., it was closed or the user clicked away),
        // we must reset the state variable. This ensures that the application
        // is no longer "stuck" in the insert-on-link mode and right-click on
        // empty canvas will work again.
        linkToInsertOn.linkId = -1;
    }
}

// --- NEW HELPER FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position)
{
    if (synth == nullptr) return;

    PinDataType srcType = getPinDataTypeForPin(linkInfo.srcPin);
    PinDataType dstType = getPinDataTypeForPin(linkInfo.dstPin);

    // 1. Create and Position the New Node
    // Check if this is a VST plugin by checking against known plugins
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            // This is a VST plugin - use addVstModule
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        // Regular module - use addModule
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points
    auto originalSrcNodeId = synth->getNodeIdForLogical(linkInfo.srcPin.logicalId);
    auto originalDstNodeId = (linkInfo.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkInfo.dstPin.logicalId);

    // 3. Disconnect the Original Link
    synth->disconnect(originalSrcNodeId, linkInfo.srcPin.channel, originalDstNodeId, linkInfo.dstPin.channel);

    // 4. Configure newly inserted node if necessary (e.g., MapRange)
    int newNodeOutputChannel = 0;
    if (nodeType == "MapRange")
    {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid)))
        {
            Range inRange = getSourceRange(linkInfo.srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0;
        }
    }

    // 5. Reconnect Through the New Node
    synth->connect(originalSrcNodeId, linkInfo.srcPin.channel, newNodeId, 0);
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, linkInfo.dstPin.channel);
}

void ImGuiNodeEditorComponent::insertNodeOnLinkStereo(const juce::String& nodeType, 
                                                       const LinkInfo& linkLeft, 
                                                       const LinkInfo& linkRight, 
                                                       const ImVec2& position)
{
    if (synth == nullptr) return;

    juce::Logger::writeToLog("[InsertStereo] Inserting stereo node: " + nodeType);
    juce::Logger::writeToLog("[InsertStereo] Left cable: " + juce::String(linkLeft.srcPin.logicalId) + 
                            " ch" + juce::String(linkLeft.srcPin.channel) + " -> " + 
                            juce::String(linkLeft.dstPin.logicalId) + " ch" + juce::String(linkLeft.dstPin.channel));
    juce::Logger::writeToLog("[InsertStereo] Right cable: " + juce::String(linkRight.srcPin.logicalId) + 
                            " ch" + juce::String(linkRight.srcPin.channel) + " -> " + 
                            juce::String(linkRight.dstPin.logicalId) + " ch" + juce::String(linkRight.dstPin.channel));

    // 1. Create ONE node for both channels
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodeScreenPositions[(int)newNodeLid] = position;

    // 2. Get Original Connection Points for LEFT cable (first cable)
    auto leftSrcNodeId = synth->getNodeIdForLogical(linkLeft.srcPin.logicalId);
    auto leftDstNodeId = (linkLeft.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkLeft.dstPin.logicalId);

    // 3. Get Original Connection Points for RIGHT cable (second cable)
    auto rightSrcNodeId = synth->getNodeIdForLogical(linkRight.srcPin.logicalId);
    auto rightDstNodeId = (linkRight.dstPin.logicalId == 0) 
        ? synth->getOutputNodeID() 
        : synth->getNodeIdForLogical(linkRight.dstPin.logicalId);

    // 4. Disconnect BOTH Original Links (using their actual source/dest channels)
    synth->disconnect(leftSrcNodeId, linkLeft.srcPin.channel, leftDstNodeId, linkLeft.dstPin.channel);
    synth->disconnect(rightSrcNodeId, linkRight.srcPin.channel, rightDstNodeId, linkRight.dstPin.channel);

    // 5. Reconnect Through the New Node
    // Left cable -> new node's LEFT input (ch0)
    synth->connect(leftSrcNodeId, linkLeft.srcPin.channel, newNodeId, 0);
    
    // Right cable -> new node's RIGHT input (ch1)
    synth->connect(rightSrcNodeId, linkRight.srcPin.channel, newNodeId, 1);
    
    // New node's outputs -> original destinations
    // Note: We'll connect both outputs to their respective destinations
    synth->connect(newNodeId, 0, leftDstNodeId, linkLeft.dstPin.channel);
    synth->connect(newNodeId, 1, rightDstNodeId, linkRight.dstPin.channel);

    juce::Logger::writeToLog("[InsertStereo] Successfully inserted stereo node with separate sources/destinations");
}

// --- REFACTORED OLD FUNCTION ---
void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin)
{
    if (synth == nullptr) return;

    // 1. Get positions to place the new node between the source and destination
    ImVec2 srcPos = ImNodes::GetNodeGridSpacePos(srcPin.logicalId);
    ImVec2 dstPos = ImNodes::GetNodeGridSpacePos(dstPin.logicalId == 0 ? 0 : dstPin.logicalId);
    ImVec2 newNodePos = ImVec2((srcPos.x + dstPos.x) * 0.5f, (srcPos.y + dstPos.y) * 0.5f);

    // 2. Create and position the new converter node
    // Check if this is a VST plugin
    juce::AudioProcessorGraph::NodeID newNodeId;
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    bool isVst = false;
    
    for (const auto& desc : knownPluginList.getTypes())
    {
        if (desc.name == nodeType)
        {
            newNodeId = synth->addVstModule(app.getPluginFormatManager(), desc);
            isVst = true;
            break;
        }
    }
    
    if (!isVst)
    {
        newNodeId = synth->addModule(nodeType);
    }
    
    auto newNodeLid = synth->getLogicalIdForNode(newNodeId);
    pendingNodePositions[(int)newNodeLid] = newNodePos;

    // 3. Get original node IDs
    auto originalSrcNodeId = synth->getNodeIdForLogical(srcPin.logicalId);
    auto originalDstNodeId = (dstPin.logicalId == 0)
        ? synth->getOutputNodeID()
        : synth->getNodeIdForLogical(dstPin.logicalId);

    // 4. Configure the new node if it's a MapRange or Attenuverter
    int newNodeOutputChannel = 0;
    if (nodeType == "MapRange") {
        if (auto* mapRange = dynamic_cast<MapRangeModuleProcessor*>(synth->getModuleForLogical(newNodeLid))) {
            PinDataType srcType = getPinDataTypeForPin(srcPin);
            PinDataType dstType = getPinDataTypeForPin(dstPin);
            Range inRange = getSourceRange(srcPin, synth);
            configureMapRangeFor(srcType, dstType, *mapRange, inRange);
            newNodeOutputChannel = (dstType == PinDataType::Audio) ? 1 : 0; // Use Raw Out for Audio, Norm Out for CV
        }
    } else if (nodeType == "Attenuverter") {
        // You might want to pre-configure the Attenuverter here if needed
    }

    // 5. Connect the signal chain: Original Source -> New Node -> Original Destination
    synth->connect(originalSrcNodeId, srcPin.channel, newNodeId, 0); // Source -> New Node's first input
    synth->connect(newNodeId, newNodeOutputChannel, originalDstNodeId, dstPin.channel); // New Node -> Destination

    juce::Logger::writeToLog("[AutoConvert] Inserted '" + nodeType + "' between " + juce::String(srcPin.logicalId) + " and " + juce::String(dstPin.logicalId));
}

void ImGuiNodeEditorComponent::insertNodeBetween(const juce::String& nodeType)
{
    // This function is now just a wrapper that calls the helper
    // with the stored link info and the current mouse position.
    if (linkToInsertOn.linkId != -1)
    {
        insertNodeOnLink(nodeType, linkToInsertOn, ImGui::GetMousePos());
        graphNeedsRebuild = true;
        pushSnapshot();
        linkToInsertOn.linkId = -1; // Reset state
    }
}

void ImGuiNodeEditorComponent::handleInsertNodeOnSelectedLinks(const juce::String& nodeType)
{
    if (synth == nullptr || ImNodes::NumSelectedLinks() == 0) return;

    pushSnapshot(); // Create one undo state for the entire batch operation.

    const int numSelectedLinks = ImNodes::NumSelectedLinks();
    std::vector<int> selectedLinkIds(numSelectedLinks);
    ImNodes::GetSelectedLinks(selectedLinkIds.data());

    ImVec2 basePosition = ImGui::GetMousePos();
    float x_offset = 0.0f;

    // === OPTION A: If exactly 2 audio cables are selected, insert ONE stereo node ===
    if (numSelectedLinks == 2)
    {
        // Get info for both cables
        auto it0 = linkIdToAttrs.find(selectedLinkIds[0]);
        auto it1 = linkIdToAttrs.find(selectedLinkIds[1]);
        
        if (it0 != linkIdToAttrs.end() && it1 != linkIdToAttrs.end())
        {
            LinkInfo link0, link1;
            link0.linkId = selectedLinkIds[0];
            link0.srcPin = decodePinId(it0->second.first);
            link0.dstPin = decodePinId(it0->second.second);
            link0.isMod = link0.srcPin.isMod || link0.dstPin.isMod;
            
            link1.linkId = selectedLinkIds[1];
            link1.srcPin = decodePinId(it1->second.first);
            link1.dstPin = decodePinId(it1->second.second);
            link1.isMod = link1.srcPin.isMod || link1.dstPin.isMod;
            
            // Check if BOTH are audio cables (not mod cables)
            if (!link0.isMod && !link1.isMod)
            {
                // Create ONE stereo node with link0 -> Left (ch0), link1 -> Right (ch1)
                insertNodeOnLinkStereo(nodeType, link0, link1, basePosition);
                juce::Logger::writeToLog("[InsertNode] Inserted STEREO node for 2 selected audio cables");
                graphNeedsRebuild = true;
                return; // Done - we've handled both cables with one node
            }
        }
    }

    // === FALLBACK: Multiple cables or mixed mod/audio - insert separate nodes ===
    std::set<int> processedLinks; // Track which links we've already handled
    
    for (size_t i = 0; i < selectedLinkIds.size(); ++i)
    {
        int linkId = selectedLinkIds[i];
        if (processedLinks.count(linkId)) continue;

        auto it = linkIdToAttrs.find(linkId);
        if (it == linkIdToAttrs.end()) continue;

        LinkInfo currentLink;
        currentLink.linkId = linkId;
        currentLink.srcPin = decodePinId(it->second.first);
        currentLink.dstPin = decodePinId(it->second.second);
        currentLink.isMod = currentLink.srcPin.isMod || currentLink.dstPin.isMod;

        ImVec2 newPosition = ImVec2(basePosition.x + x_offset, basePosition.y);
        
        // === MONO INSERT: Create separate node for each cable ===
        insertNodeOnLink(nodeType, currentLink, newPosition);
        processedLinks.insert(linkId);
        juce::Logger::writeToLog("[InsertNode] Inserted MONO node for link " + juce::String(linkId));

        x_offset += 40.0f;
    }

    graphNeedsRebuild = true;
    // The single pushSnapshot at the beginning handles the undo state.
}

juce::File ImGuiNodeEditorComponent::findPresetsDirectory()
{
    // Search upwards from the executable's location for a sibling directory
    // named "Synth_presets". This is robust to different build configurations.
    juce::File dir = juce::File::getSpecialLocation(juce::File::currentApplicationFile);

    for (int i = 0; i < 8; ++i) // Limit search depth to 8 levels
    {
        dir = dir.getParentDirectory();
        if (!dir.exists()) break;

        juce::File candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.isDirectory())
        {
            return candidate;
        }
    }
    
    // Fallback to an empty file (system default) if not found
    return {};
}

// Helper function implementations
PinDataType ImGuiNodeEditorComponent::getPinDataTypeForPin(const PinID& pin)
{
    if (synth == nullptr) return PinDataType::Raw;

    // Handle the main output node as a special case
    if (pin.logicalId == 0)
    {
        return PinDataType::Audio;
    }

    juce::String moduleType = getTypeForLogical(pin.logicalId);
    if (moduleType.isEmpty()) return PinDataType::Raw;

    // *** NEW: Check dynamic pins FIRST ***
    if (auto* module = synth->getModuleForLogical(pin.logicalId))
    {
        // Check dynamic input pins
        if (pin.isInput && !pin.isMod)
        {
            auto dynamicInputs = module->getDynamicInputPins();
            for (const auto& dynPin : dynamicInputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
        // Check dynamic output pins
        else if (!pin.isInput && !pin.isMod)
        {
            auto dynamicOutputs = module->getDynamicOutputPins();
            for (const auto& dynPin : dynamicOutputs)
            {
                if (dynPin.channel == pin.channel)
                {
                    return dynPin.type;
                }
            }
        }
    }
    // *** END NEW CODE ***

    auto it = getModulePinDatabase().find(moduleType);
    if (it == getModulePinDatabase().end())
    {
        // Fallback: case-insensitive lookup (module registry may use different casing)
        juce::String moduleTypeLower = moduleType.toLowerCase();
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0 || kv.first.toLowerCase() == moduleTypeLower)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
        if (it == getModulePinDatabase().end())
        {
            // If the module type is not in our static database, it's likely a VST plugin.
            // A safe assumption is that its pins are for audio.
            if (auto* module = synth->getModuleForLogical(pin.logicalId))
            {
                if (dynamic_cast<VstHostModuleProcessor*>(module))
                {
                    return PinDataType::Audio; // Green for VST pins
                }
            }
            return PinDataType::Raw;
        }
    }

    const auto& pinInfo = it->second;

    if (pin.isMod)
    {
        for (const auto& modPin : pinInfo.modIns)
        {
            if (modPin.paramId == pin.paramId)
            {
                return modPin.type;
            }
        }
    }
    else // It's an audio pin
    {
        const auto& pins = pin.isInput ? pinInfo.audioIns : pinInfo.audioOuts;
        for (const auto& audioPin : pins)
        {
            if (audioPin.channel == pin.channel)
            {
                return audioPin.type;
            }
        }
    }
    return PinDataType::Raw; // Fallback
}

unsigned int ImGuiNodeEditorComponent::getImU32ForType(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return IM_COL32(100, 150, 255, 255); // Blue
        case PinDataType::Audio: return IM_COL32(100, 255, 150, 255); // Green
        case PinDataType::Gate:  return IM_COL32(255, 220, 100, 255); // Yellow
        case PinDataType::Raw:   return IM_COL32(255, 100, 100, 255); // Red
        case PinDataType::Video: return IM_COL32(0, 200, 255, 255);   // Cyan
        default:                 return IM_COL32(150, 150, 150, 255); // Grey
    }
}

const char* ImGuiNodeEditorComponent::pinDataTypeToString(PinDataType type)
{
    switch (type)
    {
        case PinDataType::CV:    return "CV (0 to 1)";
        case PinDataType::Audio: return "Audio (-1 to 1)";
        case PinDataType::Gate:  return "Gate/Trigger";
        case PinDataType::Raw:   return "Raw";
        case PinDataType::Video: return "Video Source";
        default:                 return "Unknown";
    }
}

// Add this new function implementation to the .cpp file.

void ImGuiNodeEditorComponent::handleNodeChaining()
{
    if (synth == nullptr) return;

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1) return;

    juce::Logger::writeToLog("[Node Chaining] Initiated for " + juce::String(numSelected) + " nodes.");

    // 1. Get all selected nodes and their horizontal positions.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        // Don't include the main output node in the chaining logic.
        if (nodeId == 0) continue;
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    // 2. Sort the nodes from left to right based on their X position.
    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    // 3. Connect the nodes in sequence.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid != 0 && destNodeId.uid != 0)
        {
            // Standard stereo connection: Out L -> In L, Out R -> In R
            synth->connect(sourceNodeId, 0, destNodeId, 0); // Connect channel 0
            synth->connect(sourceNodeId, 1, destNodeId, 1); // Connect channel 1

            juce::Logger::writeToLog("[Node Chaining] Connected " + getTypeForLogical(sourceLid) + " (" + juce::String(sourceLid) + ") to " + getTypeForLogical(destLid) + " (" + juce::String(destLid) + ")");
            
            // Check if the destination is a recorder and update its filename
            if (auto* destModule = synth->getModuleForLogical(destLid))
            {
                if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                {
                    if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                    {
                        recorder->updateSuggestedFilename(sourceModule->getName());
                    }
                }
            }
        }
    }

    // 4. Apply all the new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Add this new helper function implementation.

std::vector<AudioPin> ImGuiNodeEditorComponent::getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType)
{
    std::vector<AudioPin> matchingPins;
    juce::String moduleType = getTypeForLogical(logicalId);

    if (moduleType.isEmpty())
    {
        return matchingPins;
    }

    auto it = getModulePinDatabase().find(moduleType);

    // --- CASE-INSENSITIVE LOOKUP ---
    if (it == getModulePinDatabase().end())
    {
        for (const auto& kv : getModulePinDatabase())
        {
            if (kv.first.compareIgnoreCase(moduleType) == 0)
            {
                it = getModulePinDatabase().find(kv.first);
                break;
            }
        }
    }

    if (it != getModulePinDatabase().end())
    {
        // --- Standard path for built-in modules ---
        const auto& pins = isInput ? it->second.audioIns : it->second.audioOuts;
        for (const auto& pin : pins)
        {
            if (pin.type == targetType)
            {
                matchingPins.push_back(pin);
            }
        }
    }

    // If no static pins matched (or none defined), fall back to dynamic pins from the module
    if (matchingPins.empty())
    {
        if (auto* module = synth->getModuleForLogical(logicalId))
        {
            // --- DYNAMIC PATH FOR MODULES WITH getDynamicInputPins/getDynamicOutputPins ---
            auto dynamicPins = isInput ? module->getDynamicInputPins() : module->getDynamicOutputPins();
            
            if (!dynamicPins.empty())
            {
                // Module provides dynamic pins - filter by type
                for (const auto& pin : dynamicPins)
                {
                    if (pin.type == targetType)
                    {
                        matchingPins.emplace_back(pin.name, pin.channel, pin.type);
                    }
                }
            }
            else if (auto* vst = dynamic_cast<VstHostModuleProcessor*>(module))
            {
                // For VSTs without dynamic pins, assume all pins are 'Audio' type for chaining.
                if (targetType == PinDataType::Audio)
                {
                    const int numChannels = isInput ? vst->getTotalNumInputChannels() : vst->getTotalNumOutputChannels();
                    for (int i = 0; i < numChannels; ++i)
                    {
                        juce::String pinName = isInput ? vst->getAudioInputLabel(i) : vst->getAudioOutputLabel(i);
                        if (pinName.isNotEmpty())
                        {
                            matchingPins.emplace_back(pinName, i, PinDataType::Audio);
                        }
                    }
                }
            }
        }
    }

    return matchingPins;
}

// Add this new function implementation to the .cpp file.

void ImGuiNodeEditorComponent::handleRecordOutput()
{
    if (!synth) return;

    pushSnapshot();
    juce::Logger::writeToLog("[Record Output] Initiated.");

    // 1. Find connections going to the main output node.
    std::vector<ModularSynthProcessor::ConnectionInfo> outputFeeds;
    for (const auto& c : synth->getConnectionsInfo())
    {
        if (c.dstIsOutput)
        {
            outputFeeds.push_back(c);
        }
    }

    if (outputFeeds.empty())
    {
        juce::Logger::writeToLog("[Record Output] No connections to main output found.");
        return;
    }

    // 2. Create and position the recorder.
    auto recorderNodeId = synth->addModule("recorder");
    auto recorderLid = synth->getLogicalIdForNode(recorderNodeId);
    ImVec2 outPos = ImNodes::GetNodeGridSpacePos(0);
    pendingNodePositions[(int)recorderLid] = ImVec2(outPos.x - 400.0f, outPos.y);
    
    auto* recorder = dynamic_cast<RecordModuleProcessor*>(synth->getModuleForLogical(recorderLid));
    if (recorder)
    {
        recorder->setPropertiesFile(PresetCreatorApplication::getApp().getProperties());
    }

    // 3. "Tap" the signals by connecting the original sources to the recorder.
    juce::String sourceName;
    for (const auto& feed : outputFeeds)
    {
        auto srcNodeId = synth->getNodeIdForLogical(feed.srcLogicalId);
        synth->connect(srcNodeId, feed.srcChan, recorderNodeId, feed.dstChan); // dstChan will be 0 or 1
        
        // Get the name of the first source for the filename prefix
        if (sourceName.isEmpty())
        {
            if (auto* srcModule = synth->getModuleForLogical(feed.srcLogicalId))
            {
                sourceName = srcModule->getName();
            }
        }
    }
    
    if (recorder)
    {
        recorder->updateSuggestedFilename(sourceName);
    }

    graphNeedsRebuild = true;
    juce::Logger::writeToLog("[Record Output] Recorder added and connected.");
}

void ImGuiNodeEditorComponent::handleColorCodedChaining(PinDataType targetType)
{
    if (synth == nullptr)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: synth is nullptr");
        return;
    }

    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected <= 1)
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: numSelected <= 1 (" + juce::String(numSelected) + ")");
        return;
    }

    juce::Logger::writeToLog("[Color Chaining] Started for " + juce::String(toString(targetType)) + " with " + juce::String(numSelected) + " nodes");

    // 1. Get and sort selected nodes by their horizontal position.
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());

    std::vector<std::pair<float, int>> sortedNodes;
    for (int nodeId : selectedNodeIds)
    {
        if (nodeId == 0) continue; // Exclude the output node.
        ImVec2 pos = ImNodes::GetNodeGridSpacePos(nodeId);
        sortedNodes.push_back({pos.x, nodeId});
    }

    if (sortedNodes.empty())
    {
        juce::Logger::writeToLog("[Color Chaining] ERROR: No valid nodes after filtering");
        return;
    }

    std::sort(sortedNodes.begin(), sortedNodes.end(), [](const auto& a, const auto& b) {
        return a.first < b.first;
    });

    // Create a single undo action for the entire operation.
    pushSnapshot();

    int totalConnectionsMade = 0;
    int totalConnectionAttempts = 0;

    // 2. Iterate through sorted nodes and connect matching pins.
    for (size_t i = 0; i < sortedNodes.size() - 1; ++i)
    {
        juce::uint32 sourceLid = sortedNodes[i].second;
        juce::uint32 destLid   = sortedNodes[i + 1].second;

        auto sourceNodeId = synth->getNodeIdForLogical(sourceLid);
        auto destNodeId   = synth->getNodeIdForLogical(destLid);

        if (sourceNodeId.uid == 0 || destNodeId.uid == 0)
        {
            juce::Logger::writeToLog("[Color Chaining] Skipping invalid node pair: " + juce::String(sourceLid) + " -> " + juce::String(destLid));
            continue;
        }

        // Find all matching output pins on the source and input pins on the destination.
        auto sourcePins = getPinsOfType(sourceLid, false, targetType);
        auto destPins   = getPinsOfType(destLid, true, targetType);

        if (sourcePins.empty() || destPins.empty())
        {
            juce::Logger::writeToLog("[Color Chaining] No matching pins: " + juce::String(sourcePins.size()) + " src, " + juce::String(destPins.size()) + " dst");
            continue;
        }

        // Connect them one-to-one until we run out of available pins on either side.
        int connectionsToMake = std::min((int)sourcePins.size(), (int)destPins.size());

        for (int j = 0; j < connectionsToMake; ++j)
        {
            totalConnectionAttempts++;
            bool connectResult = synth->connect(sourceNodeId, sourcePins[j].channel, destNodeId, destPins[j].channel);
            if (connectResult)
            {
                totalConnectionsMade++;
                juce::Logger::writeToLog("[Color Chaining] Connected " + getTypeForLogical(sourceLid) + " -> " + getTypeForLogical(destLid));

                // Check if the destination is a recorder and update its filename
                if (auto* destModule = synth->getModuleForLogical(destLid))
                {
                    if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(destModule))
                    {
                        if (auto* sourceModule = synth->getModuleForLogical(sourceLid))
                        {
                            recorder->updateSuggestedFilename(sourceModule->getName());
                        }
                    }
                }
            }
        }
    }

    juce::Logger::writeToLog("[Color Chaining] Completed: " + juce::String(totalConnectionsMade) + "/" + juce::String(totalConnectionAttempts) + " connections made");

    // 3. Apply all new connections to the audio graph.
    graphNeedsRebuild = true;
}

// Module Category Color Coding
ImGuiNodeEditorComponent::ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleType)
{
    juce::String lower = moduleType.toLowerCase();
    
    // === CATEGORY CLASSIFICATION (Following Dictionary Structure) ===
    
    // --- 1. SOURCES (Green) ---
    if (lower.contains("vco") || lower.contains("polyvco") ||
        lower.contains("noise") || lower == "audio_input" || 
        lower.contains("sample") || lower == "value")
        return ModuleCategory::Source;
    
    // --- 2. EFFECTS (Red) ---
    // Note: Recorder moved to System, Vocal Tract Filter moved to TTS
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("reverb") || lower.contains("chorus") || 
        lower.contains("phaser") || lower.contains("compressor") || 
        lower.contains("limiter") || lower == "gate" ||
        lower.contains("drive") || lower.contains("eq") ||
        lower.contains("waveshaper") || lower.contains("8bandshaper") ||
        lower.contains("granulator") || lower.contains("harmonic_shaper") ||
        lower.contains("timepitch") || lower.contains("crackle"))
        return ModuleCategory::Effect;
    
    // --- 3. MODULATORS (Blue) ---
    if (lower.contains("lfo") || lower.contains("adsr") || 
        lower.contains("random") || lower.contains("s&h") || 
        lower.contains("function_generator") || lower.contains("shaping_oscillator"))
        return ModuleCategory::Modulator;
    
    // --- 4. UTILITIES & LOGIC (Orange) ---
    if (lower.contains("vca") || lower.contains("mixer") || 
        lower.contains("attenuverter") || lower.contains("lag_processor") ||
        lower.contains("math") || lower.contains("map_range") ||
        lower.contains("quantizer") || lower.contains("rate") ||
        lower.contains("comparator") || lower.contains("logic") ||
        lower.contains("clock_divider") || lower.contains("sequential_switch"))
        return ModuleCategory::Utility;
    
    // --- 5. SEQUENCERS (Light Green) ---
    if (lower.contains("sequencer") || lower.contains("tempo_clock") || lower == "timeline")
        return ModuleCategory::Seq;
    
    // --- 6. MIDI (Vibrant Purple) ---
    if (lower.contains("midi"))
        return ModuleCategory::MIDI;
    
    // --- 7. ANALYSIS (Purple) ---
    if (lower.contains("scope") || lower.contains("debug") || 
        lower.contains("frequency_graph"))
        return ModuleCategory::Analysis;
    
    // --- 8. TTS (Peach/Coral) ---
    if (lower.contains("tts") || lower.contains("vocal_tract"))
        return ModuleCategory::TTS_Voice;
    
    // --- 9. SPECIAL (Cyan) - Physics & Animation ---
    if (lower.contains("physics") || lower.contains("animation"))
        return ModuleCategory::Special_Exp;
    
    // --- 10. COMPUTER VISION (Bright Orange) ---
    if (lower.contains("webcam") || lower.contains("video_file") ||
        lower == "video_fx" || lower == "crop_video" ||
        lower.contains("movement") || lower.contains("detector") || 
        lower.contains("opencv") || lower.contains("vision") ||
        lower.contains("tracker") || lower.contains("segmentation") ||
        lower.contains("pose_estimator"))
        return ModuleCategory::OpenCV;
    
    // --- 11. SYSTEM (Lavender) ---
    if (lower.contains("meta") || lower.contains("inlet") || 
        lower.contains("outlet") || lower.contains("comment") ||
        lower.contains("recorder") || lower.contains("vst_host") ||
        lower.contains("best_practice") || lower == "bpm_monitor" || lower.contains("bpm monitor"))
        return ModuleCategory::Sys;
    
    // --- 12. PLUGINS (Teal) ---
    if (lower.contains("vst") || lower.contains("plugin"))
        return ModuleCategory::Plugin;
    
    // --- Default: Utility ---
    return ModuleCategory::Utility;
}

unsigned int ImGuiNodeEditorComponent::getImU32ForCategory(ModuleCategory category, bool hovered)
{
    ImU32 color;
    switch (category)
    {
        case ModuleCategory::Source:      color = IM_COL32(50, 120, 50, 255); break;     // Green
        case ModuleCategory::Effect:      color = IM_COL32(130, 60, 60, 255); break;     // Red
        case ModuleCategory::Modulator:   color = IM_COL32(50, 50, 130, 255); break;     // Blue
        case ModuleCategory::Utility:     color = IM_COL32(110, 80, 50, 255); break;     // Orange
        case ModuleCategory::Seq:         color = IM_COL32(90, 140, 90, 255); break;     // Light Green
        case ModuleCategory::MIDI:        color = IM_COL32(180, 120, 255, 255); break;   // Vibrant Purple
        case ModuleCategory::Analysis:    color = IM_COL32(100, 50, 110, 255); break;    // Purple
        case ModuleCategory::TTS_Voice:   color = IM_COL32(255, 180, 100, 255); break;   // Peach/Coral
        case ModuleCategory::Special_Exp: color = IM_COL32(50, 200, 200, 255); break;    // Cyan
        case ModuleCategory::OpenCV:      color = IM_COL32(255, 140, 0, 255); break;     // Bright Orange
        case ModuleCategory::Sys:         color = IM_COL32(120, 100, 140, 255); break;   // Lavender
        case ModuleCategory::Comment:     color = IM_COL32(80, 80, 80, 255); break;      // Grey
        case ModuleCategory::Plugin:      color = IM_COL32(50, 110, 110, 255); break;    // Teal
        default:                         color = IM_COL32(70, 70, 70, 255); break;
    }
    
    if (hovered) 
    { 
        // Brighten on hover
        ImVec4 c = ImGui::ColorConvertU32ToFloat4(color);
        c.x *= 1.3f; c.y *= 1.3f; c.z *= 1.3f;
        return ImGui::ColorConvertFloat4ToU32(c);
    }
    return color;
}

// Quick Add Menu - Module Registry - Dictionary
// Maps Display Name -> { Internal Type, Description }
std::map<juce::String, std::pair<const char*, const char*>> ImGuiNodeEditorComponent::getModuleRegistry()
{
    return {
        // Sources
        {"Audio Input", {"audio_input", "Records audio from your audio interface"}},
        {"VCO", {"vco", "Voltage Controlled Oscillator - generates waveforms"}},
        {"Polyphonic VCO", {"polyvco", "Polyphonic VCO with multiple voices"}},
        {"Noise", {"noise", "White, pink, or brown noise generator"}},
        {"Sequencer", {"sequencer", "Step sequencer for creating patterns"}},
        {"Multi Sequencer", {"multi_sequencer", "Multi-track step sequencer"}},
        {"Stroke Sequencer", {"stroke_sequencer", "Freeform visual rhythmic and CV generator"}},
        {"MIDI Player", {"midi_player", "Plays MIDI files"}},
        {"MIDI CV", {"midi_cv", "Converts MIDI Note/CC messages to CV signals. (Monophonic)"}},
        {"MIDI Faders", {"midi_faders", "Up to 16 MIDI faders with CC learning"}},
        {"MIDI Knobs", {"midi_knobs", "Up to 16 MIDI knobs/rotary encoders with CC learning"}},
        {"MIDI Buttons", {"midi_buttons", "Up to 32 MIDI buttons with Gate/Toggle/Trigger modes"}},
        {"MIDI Jog Wheel", {"midi_jog_wheel", "Single MIDI jog wheel/rotary encoder"}},
        {"MIDI Pads", {"midi_pads", "16-pad MIDI controller with polyphonic triggers and velocity outputs"}},
        {"MIDI Logger", {"midi_logger", "Records CV/Gate to MIDI events with piano roll editor and .mid export"}},
        {"Value", {"value", "Constant CV value output"}},
        {"Sample Loader", {"sample_loader", "Loads and plays audio samples"}},
        
        // TTS
        {"TTS Performer", {"tts_performer", "Text-to-speech synthesizer"}},
        {"Vocal Tract Filter", {"vocal_tract_filter", "Physical model vocal tract filter"}},
        
        // Physics & Animation
        {"Physics", {"physics", "2D physics simulation for audio modulation"}},
        {"Animation", {"animation", "Skeletal animation system with glTF file support"}},
        
        // OpenCV (Computer Vision)
        {"Webcam Loader", {"webcam_loader", "Captures video from a webcam and publishes it as a source for vision processing modules"}},
        {"Video File Loader", {"video_file_loader", "Loads and plays a video file, publishes it as a source for vision processing modules"}},
        {"Video FX", {"video_fx", "Applies real-time video effects (brightness, contrast, saturation, blur, sharpen, etc.) to video sources, chainable"}},
        {"Crop Video", {"crop_video", "Crops and resizes video frames to a specified region, chainable video processor"}},
        {"Movement Detector", {"movement_detector", "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV"}},
        {"Human Detector", {"human_detector", "Detects faces or bodies in video source via Haar Cascades or HOG, outputs position and size as CV"}},
        {"Object Detector", {"object_detector", "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV"}},
        {"Pose Estimator", {"pose_estimator", "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals"}},
        {"Hand Tracker", {"hand_tracker", "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels)"}},
        {"Face Tracker", {"face_tracker", "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels)"}},
        {"Color Tracker", {"color_tracker", "Tracks multiple colors in video and outputs their positions and sizes as CV"}},
        {"Contour Detector", {"contour_detector", "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV"}},
        {"Semantic Segmentation", {"semantic_segmentation", "Uses deep learning to segment video into semantic regions and outputs detected areas as CV"}},
        
        // Effects
        {"VCF", {"vcf", "Voltage Controlled Filter"}},
        {"Delay", {"delay", "Echo/delay effect"}},
        {"Reverb", {"reverb", "Reverb effect"}},
        {"Chorus", {"chorus", "Chorus effect for thickening sound"}},
        {"Phaser", {"phaser", "Phaser modulation effect"}},
        {"Compressor", {"compressor", "Dynamic range compressor"}},
        {"Recorder", {"recorder", "Records audio to disk"}},
        {"Limiter", {"limiter", "Peak limiter"}},
        {"Noise Gate", {"gate", "Noise gate"}},
        {"Drive", {"drive", "Distortion/overdrive"}},
        {"Graphic EQ", {"graphic_eq", "Graphic equalizer"}},
        {"Waveshaper", {"waveshaper", "Waveshaping distortion"}},
        {"8-Band Shaper", {"8bandshaper", "8-band spectral shaper"}},
        {"Granulator", {"granulator", "Granular synthesis effect"}},
        {"Harmonic Shaper", {"harmonic_shaper", "Harmonic content shaper"}},
        {"Time/Pitch Shifter", {"timepitch", "Time stretching and pitch shifting"}},
        {"De-Crackle", {"de_crackle", "Removes clicks and pops"}},
        
        // Modulators
        {"LFO", {"lfo", "Low Frequency Oscillator for modulation"}},
        {"ADSR", {"adsr", "Attack Decay Sustain Release envelope"}},
        {"Random", {"random", "Random value generator"}},
        {"S&H", {"s_and_h", "Sample and Hold"}},
        {"Tempo Clock", {"tempo_clock", "Global clock with BPM control, transport (play/stop/reset), division, swing, and clock/gate outputs. Use External Takeover to drive the master transport."}},
        {"Function Generator", {"function_generator", "Custom function curves"}},
        {"Shaping Oscillator", {"shaping_oscillator", "Oscillator with waveshaping"}},
        
        // Utilities
        {"VCA", {"vca", "Voltage Controlled Amplifier"}},
        {"Mixer", {"mixer", "Audio/CV mixer"}},
        {"CV Mixer", {"cv_mixer", "CV signal mixer"}},
        {"Track Mixer", {"track_mixer", "Multi-track mixer with panning"}},
        {"Attenuverter", {"attenuverter", "Attenuate and invert signals"}},
        {"Lag Processor", {"lag_processor", "Slew rate limiter/smoother"}},
        {"Math", {"math", "Mathematical operations"}},
        {"Map Range", {"map_range", "Map values from one range to another"}},
        {"Quantizer", {"quantizer", "Quantize CV to scales"}},
        {"Rate", {"rate", "Rate/frequency divider"}},
        {"Comparator", {"comparator", "Compare and threshold signals"}},
        {"Logic", {"logic", "Boolean logic operations"}},
        {"Clock Divider", {"clock_divider", "Clock division and multiplication"}},
        {"Sequential Switch", {"sequential_switch", "Sequential signal router"}},
        {"Comment", {"comment", "Text comment box"}},
        {"Best Practice", {"best_practice", "Best practice node template"}},
        {"Snapshot Sequencer", {"snapshot_sequencer", "Snapshot sequencer for parameter automation"}},
        {"Timeline", {"timeline", "Transport-synchronized automation recorder for CV, Gate, Trigger, and Raw signals"}},
        {"BPM Monitor", {"bpm_monitor", "Hybrid rhythm detection and BPM reporting from sequencers and audio inputs"}},
        
        // Analysis
        {"Scope", {"scope", "Oscilloscope display"}},
        {"Debug", {"debug", "Debug value display"}},
        {"Input Debug", {"input_debug", "Input signal debugger"}},
        {"Frequency Graph", {"frequency_graph", "Spectrum analyzer display"}}
    };
}

// Legacy function for backwards compatibility with tooltip display
std::vector<std::pair<juce::String, const char*>> ImGuiNodeEditorComponent::getModuleDescriptions()
{
    std::vector<std::pair<juce::String, const char*>> result;
    for (const auto& entry : getModuleRegistry())
    {
        // Return {internal type, description} for compatibility
        result.push_back({entry.second.first, entry.second.second});
    }
    return result;
}

// VST Plugin Support
void ImGuiNodeEditorComponent::addPluginModules()
{
    if (synth == nullptr)
        return;
    
    auto& app = PresetCreatorApplication::getApp();
    auto& knownPluginList = app.getKnownPluginList();
    auto& formatManager = app.getPluginFormatManager();
    
    // Set the plugin format manager and known plugin list on the synth if not already set
    synth->setPluginFormatManager(&formatManager);
    synth->setKnownPluginList(&knownPluginList);
    
    // Display each known plugin as a button
    const auto& plugins = knownPluginList.getTypes();
    
    if (plugins.isEmpty())
    {
        ImGui::TextDisabled("No plugins found.");
        ImGui::TextDisabled("Use 'Scan for Plugins...' in the File menu.");
        return;
    }
    
    for (const auto& desc : plugins)
    {
        juce::String buttonLabel = desc.name;
        if (desc.manufacturerName.isNotEmpty())
        {
            buttonLabel += " (" + desc.manufacturerName + ")";
        }
        
        if (ImGui::Selectable(buttonLabel.toRawUTF8()))
        {
            auto nodeId = synth->addVstModule(formatManager, desc);
            if (nodeId.uid != 0)
            {
                const ImVec2 mouse = ImGui::GetMousePos();
                const auto logicalId = synth->getLogicalIdForNode(nodeId);
                pendingNodeScreenPositions[(int)logicalId] = mouse;
                snapshotAfterEditor = true;
                juce::Logger::writeToLog("[VST] Added plugin: " + desc.name);
            }
            else
            {
                juce::Logger::writeToLog("[VST] ERROR: Failed to add plugin: " + desc.name);
            }
        }
        
        // Show tooltip with plugin info on hover
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            ImGui::Text("Name: %s", desc.name.toRawUTF8());
            ImGui::Text("Manufacturer: %s", desc.manufacturerName.toRawUTF8());
            ImGui::Text("Version: %s", desc.version.toRawUTF8());
            ImGui::Text("Format: %s", desc.pluginFormatName.toRawUTF8());
            ImGui::Text("Type: %s", desc.isInstrument ? "Instrument" : "Effect");
            ImGui::Text("Inputs: %d", desc.numInputChannels);
            ImGui::Text("Outputs: %d", desc.numOutputChannels);
            ImGui::EndTooltip();
        }
    }
}

void ImGuiNodeEditorComponent::handleCollapseToMetaModule()
{
    if (!synth)
        return;
    
    juce::Logger::writeToLog("[Meta Module] Starting collapse operation...");
    
    // 1. Get selected nodes
    const int numSelected = ImNodes::NumSelectedNodes();
    if (numSelected < 2)
    {
        juce::Logger::writeToLog("[Meta Module] ERROR: Need at least 2 nodes selected");
        return;
    }
    
    std::vector<int> selectedNodeIds(numSelected);
    ImNodes::GetSelectedNodes(selectedNodeIds.data());
    
    // Convert to logical IDs
    std::set<juce::uint32> selectedLogicalIds;
    for (int nodeId : selectedNodeIds)
    {
        selectedLogicalIds.insert((juce::uint32)nodeId);
    }
    
    juce::Logger::writeToLog("[Meta Module] Selected " + juce::String(numSelected) + " nodes");
    
    // 2. Analyze boundary connections
    struct BoundaryConnection
    {
        juce::uint32 externalLogicalId;
        int externalChannel;
        juce::uint32 internalLogicalId;
        int internalChannel;
        bool isInput; // true = external -> internal, false = internal -> external
    };
    
    std::vector<BoundaryConnection> boundaries;
    auto allConnections = synth->getConnectionsInfo();
    
    for (const auto& conn : allConnections)
    {
        bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
        bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0 && !conn.dstIsOutput;
        bool dstIsOutput = conn.dstIsOutput;
        
        // Inlet: external -> selected
        if (!srcIsSelected && dstIsSelected)
        {
            BoundaryConnection bc;
            bc.externalLogicalId = conn.srcLogicalId;
            bc.externalChannel = conn.srcChan;
            bc.internalLogicalId = conn.dstLogicalId;
            bc.internalChannel = conn.dstChan;
            bc.isInput = true;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found inlet: " + juce::String(bc.externalLogicalId) + 
                                    " -> " + juce::String(bc.internalLogicalId));
        }
        // Outlet: selected -> external or output
        else if (srcIsSelected && (!dstIsSelected || dstIsOutput))
        {
            BoundaryConnection bc;
            bc.externalLogicalId = dstIsOutput ? 0 : conn.dstLogicalId;
            bc.externalChannel = conn.dstChan;
            bc.internalLogicalId = conn.srcLogicalId;
            bc.internalChannel = conn.srcChan;
            bc.isInput = false;
            boundaries.push_back(bc);
            juce::Logger::writeToLog("[Meta Module] Found outlet: " + juce::String(bc.internalLogicalId) + 
                                    " -> " + (dstIsOutput ? "OUTPUT" : juce::String(bc.externalLogicalId)));
        }
    }
    
    // Count inlets and outlets
    int numInlets = 0;
    int numOutlets = 0;
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
            numInlets++;
        else
            numOutlets++;
    }
    
    juce::Logger::writeToLog("[META] Boundary Detection: Found " + juce::String(numInlets) + " inlets and " + juce::String(numOutlets) + " outlets.");
    juce::Logger::writeToLog("[META] Found " + juce::String(boundaries.size()) + " boundary connections");
    
    if (boundaries.empty())
    {
        juce::Logger::writeToLog("[META] WARNING: No boundary connections - creating isolated meta module");
    }
    
    // 3. Create the internal graph state
    pushSnapshot(); // Make undoable
    
    // Save the state of selected nodes
    juce::MemoryBlock internalState;
    {
        // Create a temporary state containing only selected nodes
        juce::ValueTree internalRoot("ModularSynthPreset");
        internalRoot.setProperty("version", 1, nullptr);
        
        juce::ValueTree modsVT("modules");
        juce::ValueTree connsVT("connections");
        
        // Add selected modules
        std::map<juce::uint32, juce::uint32> oldToNewLogicalId;
        juce::uint32 newLogicalId = 1;
        
        for (juce::uint32 oldId : selectedLogicalIds)
        {
            oldToNewLogicalId[oldId] = newLogicalId++;
            
            auto* module = synth->getModuleForLogical(oldId);
            if (!module)
                continue;
            
            juce::String moduleType = synth->getModuleTypeForLogical(oldId);
            
            juce::ValueTree mv("module");
            mv.setProperty("logicalId", (int)oldToNewLogicalId[oldId], nullptr);
            mv.setProperty("type", moduleType, nullptr);
            
            // Save parameters
            juce::ValueTree params = module->getAPVTS().copyState();
            juce::ValueTree paramsWrapper("params");
            paramsWrapper.addChild(params, -1, nullptr);
            mv.addChild(paramsWrapper, -1, nullptr);
            
            // Save extra state
            if (auto extra = module->getExtraStateTree(); extra.isValid())
            {
                juce::ValueTree extraWrapper("extra");
                extraWrapper.addChild(extra, -1, nullptr);
                mv.addChild(extraWrapper, -1, nullptr);
            }
            
            modsVT.addChild(mv, -1, nullptr);
        }
        
        // Add inlet modules for each unique input
        std::map<std::pair<juce::uint32, int>, juce::uint32> inletMap; // (extId, extCh) -> inletLogicalId
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                auto key = std::make_pair(bc.externalLogicalId, bc.externalChannel);
                if (inletMap.find(key) == inletMap.end())
                {
                    juce::uint32 inletId = newLogicalId++;
                    inletMap[key] = inletId;
                    
                    juce::ValueTree mv("module");
                    mv.setProperty("logicalId", (int)inletId, nullptr);
                    mv.setProperty("type", "inlet", nullptr);
                    modsVT.addChild(mv, -1, nullptr);
                    
                    juce::Logger::writeToLog("[Meta Module] Created inlet node ID=" + juce::String(inletId));
                }
            }
        }
        
        // Add outlet modules for each unique output
        std::map<std::pair<juce::uint32, int>, juce::uint32> outletMap; // (intId, intCh) -> outletLogicalId
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                auto key = std::make_pair(bc.internalLogicalId, bc.internalChannel);
                if (outletMap.find(key) == outletMap.end())
                {
                    juce::uint32 outletId = newLogicalId++;
                    outletMap[key] = outletId;
                    
                    juce::ValueTree mv("module");
                    mv.setProperty("logicalId", (int)outletId, nullptr);
                    mv.setProperty("type", "outlet", nullptr);
                    modsVT.addChild(mv, -1, nullptr);
                    
                    juce::Logger::writeToLog("[Meta Module] Created outlet node ID=" + juce::String(outletId));
                }
            }
        }
        
        // Add internal connections (between selected nodes)
        for (const auto& conn : allConnections)
        {
            bool srcIsSelected = selectedLogicalIds.count(conn.srcLogicalId) > 0;
            bool dstIsSelected = selectedLogicalIds.count(conn.dstLogicalId) > 0;
            
            if (srcIsSelected && dstIsSelected)
            {
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[conn.srcLogicalId], nullptr);
                cv.setProperty("srcChan", conn.srcChan, nullptr);
                cv.setProperty("dstId", (int)oldToNewLogicalId[conn.dstLogicalId], nullptr);
                cv.setProperty("dstChan", conn.dstChan, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from inlets to internal nodes
        for (const auto& bc : boundaries)
        {
            if (bc.isInput)
            {
                auto key = std::make_pair(bc.externalLogicalId, bc.externalChannel);
                juce::uint32 inletId = inletMap[key];
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)inletId, nullptr);
                cv.setProperty("srcChan", 0, nullptr); // Inlets output on channel 0
                cv.setProperty("dstId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("dstChan", bc.internalChannel, nullptr);
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        // Add connections from internal nodes to outlets
        for (const auto& bc : boundaries)
        {
            if (!bc.isInput)
            {
                auto key = std::make_pair(bc.internalLogicalId, bc.internalChannel);
                juce::uint32 outletId = outletMap[key];
                
                juce::ValueTree cv("connection");
                cv.setProperty("srcId", (int)oldToNewLogicalId[bc.internalLogicalId], nullptr);
                cv.setProperty("srcChan", bc.internalChannel, nullptr);
                cv.setProperty("dstId", (int)outletId, nullptr);
                cv.setProperty("dstChan", 0, nullptr); // Outlets input on channel 0
                connsVT.addChild(cv, -1, nullptr);
            }
        }
        
        internalRoot.addChild(modsVT, -1, nullptr);
        internalRoot.addChild(connsVT, -1, nullptr);
        
        // Serialize to memory block
        if (auto xml = internalRoot.createXml())
        {
            juce::MemoryOutputStream mos(internalState, false);
            xml->writeTo(mos);
            juce::Logger::writeToLog("[META] Generated state for sub-patch.");
        }
    }
    
    // 4. Calculate average position for the meta module
    ImVec2 avgPos(0.0f, 0.0f);
    int posCount = 0;
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        ImVec2 pos = ImNodes::GetNodeGridSpacePos((int)logicalId);
        avgPos.x += pos.x;
        avgPos.y += pos.y;
        posCount++;
    }
    if (posCount > 0)
    {
        avgPos.x /= posCount;
        avgPos.y /= posCount;
    }
    
    // 5. Delete selected nodes
    for (juce::uint32 logicalId : selectedLogicalIds)
    {
        auto nodeId = synth->getNodeIdForLogical(logicalId);
        synth->removeModule(nodeId);
    }
    
    // 6. Create meta module
    auto metaNodeId = synth->addModule("meta module");
    auto metaLogicalId = synth->getLogicalIdForNode(metaNodeId);
    pendingNodePositions[(int)metaLogicalId] = avgPos;
    
    juce::Logger::writeToLog("[META] Created new MetaModule with logical ID: " + juce::String((int)metaLogicalId));
    
    auto* metaModule = dynamic_cast<MetaModuleProcessor*>(synth->getModuleForLogical(metaLogicalId));
    if (metaModule)
    {
        // Load the internal state
        metaModule->setStateInformation(internalState.getData(), (int)internalState.getSize());
        juce::Logger::writeToLog("[META] Loaded internal state into meta module");
    }
    else
    {
        juce::Logger::writeToLog("[META] ERROR: Failed to create meta module");
        return;
    }
    
    // 7. Reconnect external connections
    // Note: This is a simplified implementation - in production, you'd need to map
    // inlet/outlet indices to meta module input/output channels properly
    for (const auto& bc : boundaries)
    {
        if (bc.isInput)
        {
            // Connect external source to meta module input
            auto extNodeId = synth->getNodeIdForLogical(bc.externalLogicalId);
            synth->connect(extNodeId, bc.externalChannel, metaNodeId, 0);
        }
        else if (bc.externalLogicalId != 0)
        {
            // Connect meta module output to external destination
            auto extNodeId = synth->getNodeIdForLogical(bc.externalLogicalId);
            synth->connect(metaNodeId, 0, extNodeId, bc.externalChannel);
        }
        else
        {
            // Connect meta module output to main output
            auto outputNodeId = synth->getOutputNodeID();
            synth->connect(metaNodeId, 0, outputNodeId, bc.externalChannel);
        }
    }
    
    graphNeedsRebuild = true;
    synth->commitChanges();
    
    juce::Logger::writeToLog("[META] Reconnected external cables. Collapse complete!");
}

void ImGuiNodeEditorComponent::loadPresetFromFile(const juce::File& file)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    // 1. Load the file content.
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);

    // 2. Set the synthesizer's state. This rebuilds the audio graph.
    synth->setStateInformation(mb.getData(), (int)mb.getSize());

    // 3. Parse the XML to find the UI state.
    juce::ValueTree uiState;
    if (auto xml = juce::XmlDocument::parse(mb.toString()))
    {
        auto vt = juce::ValueTree::fromXml(*xml);
        uiState = vt.getChildWithName("NodeEditorUI");
        if (uiState.isValid())
        {
            // 4. Apply the UI state (node positions, muted status, etc.).
            // This queues the changes to be applied on the next frame.
            applyUiValueTree(uiState);
        }
    }

    // 5. Create an undo snapshot for this action.
    Snapshot s;
    synth->getStateInformation(s.synthState);
    s.uiState = uiState.isValid() ? uiState : getUiValueTree();
    undoStack.push_back(std::move(s));
    redoStack.clear();

    // 6. Update the UI status trackers.
    isPatchDirty = false;
    currentPresetFile = file; // Store full file path
    
    juce::Logger::writeToLog("[Preset] Successfully loaded preset: " + file.getFullPathName());
}

void ImGuiNodeEditorComponent::mergePresetFromFile(const juce::File& file, ImVec2 dropPosition)
{
    if (!file.existsAsFile() || synth == nullptr)
        return;

    auto xml = juce::XmlDocument::parse(file);
    if (xml == nullptr) return;

    juce::ValueTree preset = juce::ValueTree::fromXml(*xml);
    auto modulesVT = preset.getChildWithName("modules");
    auto connectionsVT = preset.getChildWithName("connections");
    auto uiVT = preset.getChildWithName("NodeEditorUI");

    if (!modulesVT.isValid()) return;

    pushSnapshot(); // Create an undo state before we start merging.

    // --- THIS IS THE NEW LOGIC ---
    // 1. Find the top-most Y coordinate of all existing nodes on the canvas.
    float topMostY = FLT_MAX;
    auto currentUiState = getUiValueTree();
    bool canvasHasNodes = false;
    for (int i = 0; i < currentUiState.getNumChildren(); ++i)
    {
        auto nodePosVT = currentUiState.getChild(i);
        if (nodePosVT.hasType("node"))
        {
            canvasHasNodes = true;
            float y = (float)nodePosVT.getProperty("y");
            if (y < topMostY)
            {
                topMostY = y;
            }
        }
    }
    // If the canvas is empty, use the drop position as the reference.
    if (!canvasHasNodes)
    {
        topMostY = dropPosition.y;
    }

    // 2. Find the bounding box of the nodes within the preset we are dropping.
    float presetMinX = FLT_MAX;
    float presetMaxY = -FLT_MAX;
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                float x = (float)nodePosVT.getProperty("x");
                float y = (float)nodePosVT.getProperty("y");
                if (x < presetMinX) presetMinX = x;
                if (y > presetMaxY) presetMaxY = y; // We need the lowest point (max Y) of the preset group.
            }
        }
    }
    
    // 3. Calculate the necessary offsets.
    const float verticalPadding = 100.0f;
    const float yOffset = topMostY - presetMaxY - verticalPadding;
    const float xOffset = dropPosition.x - presetMinX;
    // --- END OF NEW LOGIC ---

    // This map will track how we remap old IDs from the file to new, unique IDs on the canvas.
    std::map<juce::uint32, juce::uint32> oldIdToNewId;

    // First pass: create all the new modules from the preset.
    for (int i = 0; i < modulesVT.getNumChildren(); ++i)
    {
        auto moduleNode = modulesVT.getChild(i);
        if (moduleNode.hasType("module"))
        {
            juce::uint32 oldLogicalId = (juce::uint32)(int)moduleNode.getProperty("logicalId");
            juce::String type = moduleNode.getProperty("type").toString();
            
            // Add the module without committing the graph changes yet.
            auto newNodeId = synth->addModule(type, false);
            juce::uint32 newLogicalId = synth->getLogicalIdForNode(newNodeId);

            oldIdToNewId[oldLogicalId] = newLogicalId; // Store the mapping

            // Restore the new module's parameters and extra state.
            if (auto* proc = synth->getModuleForLogical(newLogicalId))
            {
                auto paramsWrapper = moduleNode.getChildWithName("params");
                if (paramsWrapper.isValid()) proc->getAPVTS().replaceState(paramsWrapper.getChild(0));
                
                auto extraWrapper = moduleNode.getChildWithName("extra");
                if (extraWrapper.isValid()) proc->setExtraStateTree(extraWrapper.getChild(0));
            }
        }
    }

    // Second pass: recreate the internal connections between the new modules.
    if (connectionsVT.isValid())
    {
        for (int i = 0; i < connectionsVT.getNumChildren(); ++i)
        {
            auto connNode = connectionsVT.getChild(i);
            if (connNode.hasType("connection"))
            {
                juce::uint32 oldSrcId = (juce::uint32)(int)connNode.getProperty("srcId");
                int srcChan = (int)connNode.getProperty("srcChan");
                juce::uint32 oldDstId = (juce::uint32)(int)connNode.getProperty("dstId");
                int dstChan = (int)connNode.getProperty("dstChan");

                // Only connect if both source and destination are part of the preset we're merging.
                if (oldIdToNewId.count(oldSrcId) && oldIdToNewId.count(oldDstId))
                {
                    auto newSrcNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldSrcId]);
                    auto newDstNodeId = synth->getNodeIdForLogical(oldIdToNewId[oldDstId]);
                    synth->connect(newSrcNodeId, srcChan, newDstNodeId, dstChan);
                }
            }
        }
    }
    
    // Third pass: Apply UI positions using our new calculated offsets.
    if (uiVT.isValid())
    {
        for (int i = 0; i < uiVT.getNumChildren(); ++i)
        {
            auto nodePosVT = uiVT.getChild(i);
            if (nodePosVT.hasType("node"))
            {
                juce::uint32 oldId = (juce::uint32)(int)nodePosVT.getProperty("id");
                if (oldIdToNewId.count(oldId)) // Check if it's one of our new nodes
                {
                    ImVec2 pos = ImVec2((float)nodePosVT.getProperty("x"), (float)nodePosVT.getProperty("y"));
                    
                    // Apply the smart offsets
                    ImVec2 newPos = ImVec2(pos.x + xOffset, pos.y + yOffset);
                    
                    pendingNodeScreenPositions[(int)oldIdToNewId[oldId]] = newPos;
                }
            }
        }
    }

    // Finally, commit all the changes to the audio graph at once.
    synth->commitChanges();
    isPatchDirty = true; // Mark the patch as edited.
    
    juce::Logger::writeToLog("[Preset] Successfully merged preset: " + file.getFullPathName() + 
                             " above existing nodes with offsets (" + juce::String(xOffset) + ", " + juce::String(yOffset) + ")");
}




================================================================================
FILE: juce\Source\preset_creator\PinDatabase.h
================================================================================


#pragma once

#include "../audio/modules/ModuleProcessor.h"
#include <map>

// Getter functions that return references to static local variables
// This ensures safe initialization after JUCE is ready (construct on first use idiom)

// Returns the pin database for all module types
inline std::map<juce::String, ModulePinInfo>& getModulePinDatabase()
{
    // By declaring the map as static inside a function, we ensure it's
    // initialized safely on its first use, after JUCE is ready.
    static std::map<juce::String, ModulePinInfo> modulePinDatabase;
    return modulePinDatabase;
}

// Returns the module descriptions database
inline std::map<juce::String, const char*>& getModuleDescriptions()
{
    static std::map<juce::String, const char*> moduleDescriptions;
    return moduleDescriptions;
}

// Function to populate both databases - must be called before first use
void populatePinDatabase();



================================================================================
FILE: juce\Source\preset_creator\PinDatabase.cpp
================================================================================


#include "PinDatabase.h"
#include "ImGuiNodeEditorComponent.h" // For NodeWidth enum

// Module Descriptions - populated on first use
void populateModuleDescriptions()
{
    auto& descriptions = getModuleDescriptions();
    if (!descriptions.empty()) return; // Only run once
    
    // Sources
    descriptions["audio_input"] = "Brings hardware audio into the patch.";
    descriptions["VCO"] = "A standard Voltage-Controlled Oscillator.";
    descriptions["polyvco"] = "A multi-voice oscillator bank for polyphony.";
    descriptions["Noise"] = "Generates white, pink, or brown noise.";
    descriptions["Sequencer"] = "A classic 16-step CV and Gate sequencer.";
    descriptions["multi sequencer"] = "Advanced sequencer with parallel per-step outputs.";
    descriptions["midi player"] = "Plays MIDI files and outputs CV/Gate for each track.";
    descriptions["midi cv"] = "Converts MIDI Note/CC messages to CV signals. (Monophonic)";
    descriptions["midi control center"] = "A powerful MIDI learn interface to map any MIDI CC to CV/Gate outputs.";
    descriptions["midi faders"] = "1-16 MIDI-learnable faders with customizable output ranges.";
    descriptions["midi knobs"] = "1-16 MIDI-learnable knobs with customizable output ranges.";
    descriptions["midi buttons"] = "1-32 MIDI-learnable buttons with Gate/Toggle/Trigger modes.";
    descriptions["midi jog wheel"] = "A single MIDI-learnable jog wheel control for expressive modulation.";
    descriptions["Value"] = "Outputs a constant, adjustable numerical value.";
    descriptions["sample_loader"] = "Loads and plays audio samples with pitch/time control.";
    descriptions["best_practice"] = "A template and example node demonstrating best practices.";
    // TTS Family
    descriptions["TTS Performer"] = "Advanced Text-to-Speech engine with word-level sequencing.";
    descriptions["Vocal Tract Filter"] = "A formant filter that simulates human vowel sounds.";
    // Effects
    descriptions["VCF"] = "A Voltage-Controlled Filter (LP, HP, BP).";
    descriptions["Delay"] = "A stereo delay effect with modulation.";
    descriptions["Reverb"] = "A stereo reverb effect.";
    descriptions["chorus"] = "A stereo chorus effect.";
    descriptions["phaser"] = "A stereo phaser effect.";
    descriptions["compressor"] = "Reduces the dynamic range of a signal.";
    descriptions["limiter"] = "Prevents a signal from exceeding a set level.";
    descriptions["gate"] = "A stereo noise gate to silence signals below a threshold.";
    descriptions["drive"] = "A waveshaping distortion effect.";
    descriptions["graphic_eq"] = "An 8-band graphic equalizer.";
    descriptions["frequency_graph"] = "A high-resolution, real-time spectrum analyzer.";
    descriptions["Waveshaper"] = "A distortion effect with multiple shaping algorithms.";
    descriptions["8bandshaper"] = "A multi-band waveshaper for frequency-specific distortion.";
    descriptions["Granulator"] = "A granular synthesizer/effect that plays small grains of a sample.";
    descriptions["harmonic shaper"] = "Shapes the harmonic content of a signal.";
    descriptions["timepitch"] = "Real-time pitch and time manipulation using RubberBand.";
    descriptions["De-Crackle"] = "A utility to reduce clicks from discontinuous signals.";
    descriptions["recorder"] = "Records incoming audio to a WAV, AIFF, or FLAC file.";
    descriptions["tempo_clock"] = "Global clock generator with BPM control, transport, and clock outputs.";
    descriptions["bpm_monitor"] = "Monitors and reports BPM from rhythm-producing modules (sequencers, animations). Always present and undeletable.";
    descriptions["timeline"] = "Transport-synchronized automation recorder with sample-accurate timing for CV, Gate, Trigger, and Raw signals.";
    // Modulators
    descriptions["LFO"] = "A Low-Frequency Oscillator for modulation.";
    descriptions["ADSR"] = "An Attack-Decay-Sustain-Release envelope generator.";
    descriptions["Random"] = "A random value generator with internal sample & hold.";
    descriptions["S&H"] = "A classic Sample and Hold module.";
    descriptions["function_generator"] = "A complex, drawable envelope/LFO generator.";
    descriptions["shaping_oscillator"] = "An oscillator with a built-in waveshaper.";
    // Utilities & Logic
    descriptions["VCA"] = "A Voltage-Controlled Amplifier to control signal level.";
    descriptions["Mixer"] = "A stereo audio mixer with crossfading and panning.";
    descriptions["cv mixer"] = "A mixer specifically for control voltage signals.";
    descriptions["trackmixer"] = "A multi-channel mixer for polyphonic sources.";
    descriptions["Attenuverter"] = "Attenuates (reduces) and/or inverts signals.";
    descriptions["Lag Processor"] = "Smooths out abrupt changes in a signal (slew limiter).";
    descriptions["Math"] = "Performs mathematical operations on signals.";
    descriptions["MapRange"] = "Remaps a signal from one numerical range to another.";
    descriptions["Quantizer"] = "Snaps a continuous signal to a musical scale.";
    descriptions["Rate"] = "Converts a control signal into a normalized rate value.";
    descriptions["Comparator"] = "Outputs a high signal if an input is above a threshold.";
    descriptions["Logic"] = "Performs boolean logic (AND, OR, XOR, NOT) on gate signals.";
    descriptions["ClockDivider"] = "Divides and multiplies clock signals.";
    descriptions["SequentialSwitch"] = "A signal router with multiple thresholds.";
    // Analysis
    descriptions["Scope"] = "Visualizes an audio or CV signal.";
    descriptions["debug"] = "A tool for logging signal value changes.";
    descriptions["input_debug"] = "A passthrough version of the Debug node for inspecting signals on a cable.";
    
    // Physics
    descriptions["physics"] = "A 2D physics simulation that outputs collision and contact data.";
    descriptions["animation"] = "Loads and plays 3D animations, outputs joint positions and velocities.";
    descriptions["stroke_sequencer"] = "Gesture-based sequencer that records and plays back drawn patterns.";
    
    // OpenCV (Computer Vision)
    descriptions["webcam_loader"] = "Captures video from a webcam and publishes it as a source for vision processing modules.";
    descriptions["video_file_loader"] = "Loads and plays a video file, publishes it as a source for vision processing modules.";
    descriptions["video_fx"] = "Applies real-time video effects (brightness, contrast, saturation, blur, sharpen, etc.) to video sources, chainable.";
    descriptions["movement_detector"] = "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV.";
    descriptions["human_detector"] = "Detects faces or bodies in video source via Haar Cascades or HOG, outputs position and size as CV.";
    descriptions["pose_estimator"] = "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals.";
    descriptions["hand_tracker"] = "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels).";
    descriptions["face_tracker"] = "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels).";
    descriptions["object_detector"] = "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV.";
    descriptions["color_tracker"] = "Tracks multiple colors in video and outputs their positions and sizes as CV.";
    descriptions["contour_detector"] = "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV.";
    descriptions["semantic_segmentation"] = "Uses deep learning to segment video into semantic regions and outputs detected areas as CV.";
    descriptions["crop_video"] = "Crops a video stream based on CV signals (X, Y, Width, Height). Perfect for following detected objects or regions.";
    
    // Add aliases for underscore naming conventions
    descriptions["clock_divider"] = descriptions["ClockDivider"];
    descriptions["sequential_switch"] = descriptions["SequentialSwitch"];
    descriptions["s_and_h"] = descriptions["S&H"];
    descriptions["snapshot_sequencer"] = "A sequencer that stores and recalls complete patch states.";
}

void populatePinDatabase()
{
    // Populate both databases
    populateModuleDescriptions();
    
    auto& db = getModulePinDatabase();
    if (!db.empty()) return; // Only run once

    // --- Sources ---
    db["audio_input"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Out 1", 0, PinDataType::Audio), AudioPin("Out 2", 1, PinDataType::Audio),
          AudioPin("Gate", 16, PinDataType::Gate), AudioPin("Trigger", 17, PinDataType::Gate), AudioPin("EOP", 18, PinDataType::Gate) },
        {}
    );
    db["vco"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Frequency", 0, PinDataType::CV), AudioPin("Waveform", 1, PinDataType::CV), AudioPin("Gate", 2, PinDataType::Gate) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    db["noise"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Level Mod", 0, PinDataType::CV), AudioPin("Colour Mod", 1, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) }, // Stereo output to match actual implementation
        {}
    );
    db["value"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Raw", 0, PinDataType::Raw), AudioPin("Normalized", 1, PinDataType::CV), AudioPin("Inverted", 2, PinDataType::Raw),
          AudioPin("Integer", 3, PinDataType::Raw), AudioPin("CV Out", 4, PinDataType::CV) },
        {}
    );
    db["sample_loader"] = ModulePinInfo(
        NodeWidth::Big,
        { AudioPin("Pitch Mod", 0, PinDataType::CV), AudioPin("Speed Mod", 1, PinDataType::CV), AudioPin("Gate Mod", 2, PinDataType::CV),
          AudioPin("Trigger Mod", 3, PinDataType::Gate), AudioPin("Range Start Mod", 4, PinDataType::CV), AudioPin("Range End Mod", 5, PinDataType::CV),
          AudioPin("Randomize Trig", 6, PinDataType::Gate) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // --- Effects ---
    db["vcf"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Cutoff Mod", 2, PinDataType::CV),
          AudioPin("Resonance Mod", 3, PinDataType::CV), AudioPin("Type Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["delay"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Time Mod", 2, PinDataType::CV),
          AudioPin("Feedback Mod", 3, PinDataType::CV), AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["reverb"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Size Mod", 2, PinDataType::CV),
          AudioPin("Damp Mod", 3, PinDataType::CV), AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["compressor"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Thresh Mod", 2, PinDataType::CV),
          AudioPin("Ratio Mod", 3, PinDataType::CV), AudioPin("Attack Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV),
          AudioPin("Makeup Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // --- Modulators ---
    db["lfo"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Rate Mod", 0, PinDataType::CV), AudioPin("Depth Mod", 1, PinDataType::CV), AudioPin("Wave Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );
    db["adsr"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Gate In", 0, PinDataType::Gate), AudioPin("Trigger In", 1, PinDataType::Gate), AudioPin("Attack Mod", 2, PinDataType::CV),
          AudioPin("Decay Mod", 3, PinDataType::CV), AudioPin("Sustain Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV) },
        { AudioPin("Env Out", 0, PinDataType::CV), AudioPin("Inv Out", 1, PinDataType::CV), AudioPin("EOR Gate", 2, PinDataType::Gate),
          AudioPin("EOC Gate", 3, PinDataType::Gate) },
        {}
    );
    db["random"] = ModulePinInfo(
        NodeWidth::Small,
        {}, // No inputs - self-contained random generator
        { AudioPin("Norm Out", 0, PinDataType::CV), AudioPin("Raw Out", 1, PinDataType::Raw), AudioPin("CV Out", 2, PinDataType::CV),
          AudioPin("Bool Out", 3, PinDataType::Gate), AudioPin("Trig Out", 4, PinDataType::Gate) },
        {}
    );

    // --- Utilities ---
    db["vca"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Gain Mod", 2, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["mixer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A L", 0, PinDataType::Audio), AudioPin("In A R", 1, PinDataType::Audio), AudioPin("In B L", 2, PinDataType::Audio),
          AudioPin("In B R", 3, PinDataType::Audio), AudioPin("Gain Mod", 4, PinDataType::CV), AudioPin("Pan Mod", 5, PinDataType::CV),
          AudioPin("X-Fade Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["scope"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In", 0, PinDataType::Audio) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    db["graphic_eq"] = ModulePinInfo(
        NodeWidth::Big,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Band 1 Mod", 2, PinDataType::CV), AudioPin("Band 2 Mod", 3, PinDataType::CV),
          AudioPin("Band 3 Mod", 4, PinDataType::CV), AudioPin("Band 4 Mod", 5, PinDataType::CV),
          AudioPin("Band 5 Mod", 6, PinDataType::CV), AudioPin("Band 6 Mod", 7, PinDataType::CV),
          AudioPin("Band 7 Mod", 8, PinDataType::CV), AudioPin("Band 8 Mod", 9, PinDataType::CV),
          AudioPin("Gate Thresh Mod", 10, PinDataType::CV), AudioPin("Trig Thresh Mod", 11, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio),
          AudioPin("Gate Out", 2, PinDataType::Gate), AudioPin("Trig Out", 3, PinDataType::Gate) },
        {}
    );
    db["frequency_graph"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("In", 0, PinDataType::Audio) }, // Mono Audio Input
        { // Outputs: Stereo audio pass-through + 8 Gate/Trigger outputs
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio),
            AudioPin("Sub Gate", 2, PinDataType::Gate),
            AudioPin("Sub Trig", 3, PinDataType::Gate),
            AudioPin("Bass Gate", 4, PinDataType::Gate),
            AudioPin("Bass Trig", 5, PinDataType::Gate),
            AudioPin("Mid Gate", 6, PinDataType::Gate),
            AudioPin("Mid Trig", 7, PinDataType::Gate),
            AudioPin("High Gate", 8, PinDataType::Gate),
            AudioPin("High Trig", 9, PinDataType::Gate)
        },
        {} // No modulation inputs
    );
    db["chorus"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Depth Mod", 3, PinDataType::CV),
          AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["phaser"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Depth Mod", 3, PinDataType::CV),
          AudioPin("Centre Mod", 4, PinDataType::CV), AudioPin("Feedback Mod", 5, PinDataType::CV),
          AudioPin("Mix Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["compressor"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Thresh Mod", 2, PinDataType::CV), AudioPin("Ratio Mod", 3, PinDataType::CV),
          AudioPin("Attack Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV),
          AudioPin("Makeup Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["Recorder"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        {}, // No outputs
        {}
    );
    db["limiter"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Thresh Mod", 2, PinDataType::CV), AudioPin("Release Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["gate"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["drive"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["timepitch"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Speed Mod", 2, PinDataType::CV), AudioPin("Pitch Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["waveshaper"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Drive Mod", 2, PinDataType::CV), AudioPin("Type Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["8bandshaper"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("In L", 0, PinDataType::Audio),
            AudioPin("In R", 1, PinDataType::Audio),
            AudioPin("Drive 1 Mod", 2, PinDataType::CV),
            AudioPin("Drive 2 Mod", 3, PinDataType::CV),
            AudioPin("Drive 3 Mod", 4, PinDataType::CV),
            AudioPin("Drive 4 Mod", 5, PinDataType::CV),
            AudioPin("Drive 5 Mod", 6, PinDataType::CV),
            AudioPin("Drive 6 Mod", 7, PinDataType::CV),
            AudioPin("Drive 7 Mod", 8, PinDataType::CV),
            AudioPin("Drive 8 Mod", 9, PinDataType::CV),
            AudioPin("Gain Mod", 10, PinDataType::CV)
        },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["granulator"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("In L", 0, PinDataType::Audio),
            AudioPin("In R", 1, PinDataType::Audio),
            AudioPin("Trigger In", 2, PinDataType::Gate),
            AudioPin("Density Mod", 3, PinDataType::CV),
            AudioPin("Size Mod", 4, PinDataType::CV),
            AudioPin("Position Mod", 5, PinDataType::CV),
            AudioPin("Pitch Mod", 6, PinDataType::CV),
            AudioPin("Gate Mod", 7, PinDataType::CV)
        },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["mixer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A L", 0, PinDataType::Audio), AudioPin("In A R", 1, PinDataType::Audio), AudioPin("In B L", 2, PinDataType::Audio), AudioPin("In B R", 3, PinDataType::Audio), AudioPin("Gain Mod", 4, PinDataType::CV), AudioPin("Pan Mod", 5, PinDataType::CV), AudioPin("X-Fade Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("Mod In L", 0, PinDataType::Audio), AudioPin("Mod In R", 1, PinDataType::Audio), AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Gate Mod", 3, PinDataType::CV), AudioPin("Steps Mod", 4, PinDataType::CV), AudioPin("Gate Thr Mod", 5, PinDataType::CV),
          // Per-step value mods absolute 6..21 (Step1..Step16)
          AudioPin("Step 1 Mod", 6, PinDataType::CV), AudioPin("Step 2 Mod", 7, PinDataType::CV), AudioPin("Step 3 Mod", 8, PinDataType::CV), AudioPin("Step 4 Mod", 9, PinDataType::CV),
          AudioPin("Step 5 Mod", 10, PinDataType::CV), AudioPin("Step 6 Mod", 11, PinDataType::CV), AudioPin("Step 7 Mod", 12, PinDataType::CV), AudioPin("Step 8 Mod", 13, PinDataType::CV),
          AudioPin("Step 9 Mod", 14, PinDataType::CV), AudioPin("Step 10 Mod", 15, PinDataType::CV), AudioPin("Step 11 Mod", 16, PinDataType::CV), AudioPin("Step 12 Mod", 17, PinDataType::CV),
          AudioPin("Step 13 Mod", 18, PinDataType::CV), AudioPin("Step 14 Mod", 19, PinDataType::CV), AudioPin("Step 15 Mod", 20, PinDataType::CV), AudioPin("Step 16 Mod", 21, PinDataType::CV),
          // Per-step trig mods absolute 22..37 (Step1..Step16) ‚Äî these are Gates
          AudioPin("Step 1 Trig Mod", 22, PinDataType::Gate), AudioPin("Step 2 Trig Mod", 23, PinDataType::Gate), AudioPin("Step 3 Trig Mod", 24, PinDataType::Gate), AudioPin("Step 4 Trig Mod", 25, PinDataType::Gate),
          AudioPin("Step 5 Trig Mod", 26, PinDataType::Gate), AudioPin("Step 6 Trig Mod", 27, PinDataType::Gate), AudioPin("Step 7 Trig Mod", 28, PinDataType::Gate), AudioPin("Step 8 Trig Mod", 29, PinDataType::Gate),
          AudioPin("Step 9 Trig Mod", 30, PinDataType::Gate), AudioPin("Step 10 Trig Mod", 31, PinDataType::Gate), AudioPin("Step 11 Trig Mod", 32, PinDataType::Gate), AudioPin("Step 12 Trig Mod", 33, PinDataType::Gate),
          AudioPin("Step 13 Trig Mod", 34, PinDataType::Gate), AudioPin("Step 14 Trig Mod", 35, PinDataType::Gate), AudioPin("Step 15 Trig Mod", 36, PinDataType::Gate), AudioPin("Step 16 Trig Mod", 37, PinDataType::Gate),
          // Per-step gate level mods absolute 38..53
          AudioPin("Step 1 Gate Mod", 38, PinDataType::CV), AudioPin("Step 2 Gate Mod", 39, PinDataType::CV), AudioPin("Step 3 Gate Mod", 40, PinDataType::CV), AudioPin("Step 4 Gate Mod", 41, PinDataType::CV),
          AudioPin("Step 5 Gate Mod", 42, PinDataType::CV), AudioPin("Step 6 Gate Mod", 43, PinDataType::CV), AudioPin("Step 7 Gate Mod", 44, PinDataType::CV), AudioPin("Step 8 Gate Mod", 45, PinDataType::CV),
          AudioPin("Step 9 Gate Mod", 46, PinDataType::CV), AudioPin("Step 10 Gate Mod", 47, PinDataType::CV), AudioPin("Step 11 Gate Mod", 48, PinDataType::CV), AudioPin("Step 12 Gate Mod", 49, PinDataType::CV),
          AudioPin("Step 13 Gate Mod", 50, PinDataType::CV), AudioPin("Step 14 Gate Mod", 51, PinDataType::CV), AudioPin("Step 15 Gate Mod", 52, PinDataType::CV), AudioPin("Step 16 Gate Mod", 53, PinDataType::CV) },
        { AudioPin("Pitch", 0, PinDataType::CV), AudioPin("Gate", 1, PinDataType::Gate), AudioPin("Gate Nuanced", 2, PinDataType::CV), AudioPin("Velocity", 3, PinDataType::CV), AudioPin("Mod", 4, PinDataType::CV), AudioPin("Trigger", 5, PinDataType::Gate) },
        {}
    );

    db["value"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Raw", 0, PinDataType::Raw), AudioPin("Normalized", 1, PinDataType::CV), AudioPin("Inverted", 2, PinDataType::Raw), AudioPin("Integer", 3, PinDataType::Raw), AudioPin("CV Out", 4, PinDataType::CV) },
        {}
    );

db["random"] = ModulePinInfo(
    NodeWidth::Small,
    {}, // No inputs - self-contained random generator
    { 
        AudioPin("Norm Out", 0, PinDataType::CV), 
        AudioPin("Raw Out", 1, PinDataType::Raw), 
        AudioPin("CV Out", 2, PinDataType::CV),
        AudioPin("Bool Out", 3, PinDataType::Gate), 
        AudioPin("Trig Out", 4, PinDataType::Gate) 
    },
    {} // No modulation inputs
);

    db["tts performer"] = ModulePinInfo(
        NodeWidth::Big,
        { // Inputs (absolute channels based on bus structure)
            AudioPin("Rate Mod", 0, PinDataType::CV),
            AudioPin("Gate Mod", 1, PinDataType::CV),
            AudioPin("Trigger", 2, PinDataType::Gate),
            AudioPin("Reset", 3, PinDataType::Gate),
            AudioPin("Randomize Trig", 4, PinDataType::Gate),
            AudioPin("Trim Start Mod", 5, PinDataType::CV),
            AudioPin("Trim End Mod", 6, PinDataType::CV),
            AudioPin("Speed Mod", 7, PinDataType::CV),
            AudioPin("Pitch Mod", 8, PinDataType::CV),
            // Word Triggers (Channels 9-24)
            AudioPin("Word 1 Trig", 9, PinDataType::Gate), AudioPin("Word 2 Trig", 10, PinDataType::Gate),
            AudioPin("Word 3 Trig", 11, PinDataType::Gate), AudioPin("Word 4 Trig", 12, PinDataType::Gate),
            AudioPin("Word 5 Trig", 13, PinDataType::Gate), AudioPin("Word 6 Trig", 14, PinDataType::Gate),
            AudioPin("Word 7 Trig", 15, PinDataType::Gate), AudioPin("Word 8 Trig", 16, PinDataType::Gate),
            AudioPin("Word 9 Trig", 17, PinDataType::Gate), AudioPin("Word 10 Trig", 18, PinDataType::Gate),
            AudioPin("Word 11 Trig", 19, PinDataType::Gate), AudioPin("Word 12 Trig", 20, PinDataType::Gate),
            AudioPin("Word 13 Trig", 21, PinDataType::Gate), AudioPin("Word 14 Trig", 22, PinDataType::Gate),
            AudioPin("Word 15 Trig", 23, PinDataType::Gate), AudioPin("Word 16 Trig", 24, PinDataType::Gate)
        },
        { // Outputs
            AudioPin("Audio", 0, PinDataType::Audio),
            AudioPin("Word Gate", 1, PinDataType::Gate),
            AudioPin("EOP Gate", 2, PinDataType::Gate),
            // Per-Word Gates (Channels 3-18)
            AudioPin("Word 1 Gate", 3, PinDataType::Gate), AudioPin("Word 2 Gate", 4, PinDataType::Gate),
            AudioPin("Word 3 Gate", 5, PinDataType::Gate), AudioPin("Word 4 Gate", 6, PinDataType::Gate),
            AudioPin("Word 5 Gate", 7, PinDataType::Gate), AudioPin("Word 6 Gate", 8, PinDataType::Gate),
            AudioPin("Word 7 Gate", 9, PinDataType::Gate), AudioPin("Word 8 Gate", 10, PinDataType::Gate),
            AudioPin("Word 9 Gate", 11, PinDataType::Gate), AudioPin("Word 10 Gate", 12, PinDataType::Gate),
            AudioPin("Word 11 Gate", 13, PinDataType::Gate), AudioPin("Word 12 Gate", 14, PinDataType::Gate),
            AudioPin("Word 13 Gate", 15, PinDataType::Gate), AudioPin("Word 14 Gate", 16, PinDataType::Gate),
            AudioPin("Word 15 Gate", 17, PinDataType::Gate), AudioPin("Word 16 Gate", 18, PinDataType::Gate),
            // Per-Word Triggers (Channels 19-34)
            AudioPin("Word 1 Trig", 19, PinDataType::Gate), AudioPin("Word 2 Trig", 20, PinDataType::Gate),
            AudioPin("Word 3 Trig", 21, PinDataType::Gate), AudioPin("Word 4 Trig", 22, PinDataType::Gate),
            AudioPin("Word 5 Trig", 23, PinDataType::Gate), AudioPin("Word 6 Trig", 24, PinDataType::Gate),
            AudioPin("Word 7 Trig", 25, PinDataType::Gate), AudioPin("Word 8 Trig", 26, PinDataType::Gate),
            AudioPin("Word 9 Trig", 27, PinDataType::Gate), AudioPin("Word 10 Trig", 28, PinDataType::Gate),
            AudioPin("Word 11 Trig", 29, PinDataType::Gate), AudioPin("Word 12 Trig", 30, PinDataType::Gate),
            AudioPin("Word 13 Trig", 31, PinDataType::Gate), AudioPin("Word 14 Trig", 32, PinDataType::Gate),
            AudioPin("Word 15 Trig", 33, PinDataType::Gate), AudioPin("Word 16 Trig", 34, PinDataType::Gate)
        },
        { // Modulation Pins (for UI parameter disabling)
            ModPin("Rate", "rate_mod", PinDataType::CV),
            ModPin("Gate", "gate_mod", PinDataType::CV),
            ModPin("Trim Start", "trimStart_mod", PinDataType::CV),
            ModPin("Trim End", "trimEnd_mod", PinDataType::CV),
            ModPin("Speed", "speed_mod", PinDataType::CV),
            ModPin("Pitch", "pitch_mod", PinDataType::CV)
        }
    );
    db["vocal tract filter"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Audio In", 0, PinDataType::Audio) },
        { AudioPin("Audio Out", 0, PinDataType::Audio) },
        { ModPin("Vowel", "vowelShape", PinDataType::CV), ModPin("Formant", "formantShift", PinDataType::CV), ModPin("Instability", "instability", PinDataType::CV), ModPin("Gain", "formantGain", PinDataType::CV) }
    );
    db["best_practice"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Wave Mod", 3, PinDataType::CV), AudioPin("Drive Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        { ModPin("Frequency", "frequency_mod", PinDataType::CV), ModPin("Waveform", "waveform_mod", PinDataType::CV), ModPin("Drive", "drive_mod", PinDataType::CV) }
    );
    db["shaping_oscillator"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Wave Mod", 3, PinDataType::CV), AudioPin("Drive Mod", 4, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        { ModPin("Frequency", "frequency_mod", PinDataType::CV), ModPin("Waveform", "waveform_mod", PinDataType::CV), ModPin("Drive", "drive_mod", PinDataType::CV) }
    );
    db["harmonic shaper"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Drive Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        { ModPin("Master Frequency", "masterFrequency_mod", PinDataType::CV), ModPin("Master Drive", "masterDrive_mod", PinDataType::CV) }
    );
    db["function_generator"] = ModulePinInfo(
        NodeWidth::Big,
        { 
            AudioPin("Gate In", 0, PinDataType::Gate),
            AudioPin("Trigger In", 1, PinDataType::Gate),
            AudioPin("Sync In", 2, PinDataType::Gate),
            AudioPin("Rate Mod", 3, PinDataType::CV),
            AudioPin("Slew Mod", 4, PinDataType::CV),
            AudioPin("Gate Thresh Mod", 5, PinDataType::CV),
            AudioPin("Trig Thresh Mod", 6, PinDataType::CV),
            AudioPin("Pitch Base Mod", 7, PinDataType::CV),
            AudioPin("Value Mult Mod", 8, PinDataType::CV),
            AudioPin("Curve Select Mod", 9, PinDataType::CV)
        },
        { 
            AudioPin("Value", 0, PinDataType::CV),
            AudioPin("Inverted", 1, PinDataType::CV),
            AudioPin("Bipolar", 2, PinDataType::CV),
            AudioPin("Pitch", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate),
            AudioPin("Trigger", 5, PinDataType::Gate),
            AudioPin("End of Cycle", 6, PinDataType::Gate),
            // New dedicated outputs
            AudioPin("Blue Value", 7, PinDataType::CV),
            AudioPin("Blue Pitch", 8, PinDataType::CV),
            AudioPin("Red Value", 9, PinDataType::CV),
            AudioPin("Red Pitch", 10, PinDataType::CV),
            AudioPin("Green Value", 11, PinDataType::CV),
            AudioPin("Green Pitch", 12, PinDataType::CV)
        },
        { 
            ModPin("Rate", "rate_mod", PinDataType::CV),
            ModPin("Slew", "slew_mod", PinDataType::CV),
            ModPin("Gate Thresh", "gateThresh_mod", PinDataType::CV),
            ModPin("Trig Thresh", "trigThresh_mod", PinDataType::CV),
            ModPin("Pitch Base", "pitchBase_mod", PinDataType::CV),
            ModPin("Value Mult", "valueMult_mod", PinDataType::CV),
            ModPin("Curve Select", "curveSelect_mod", PinDataType::CV)
        }
    );

    db["multi sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { // Inputs: Mod In L, Mod In R, Rate Mod, Gate Mod, Steps Mod, Gate Thr Mod, plus per-step mods and triggers
            AudioPin("Mod In L", 0, PinDataType::Audio), AudioPin("Mod In R", 1, PinDataType::Audio),
            AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Gate Mod", 3, PinDataType::CV),
            AudioPin("Steps Mod", 4, PinDataType::CV), AudioPin("Gate Thr Mod", 5, PinDataType::CV),
            // Per-step mods (channels 6-21)
            AudioPin("Step 1 Mod", 6, PinDataType::CV), AudioPin("Step 2 Mod", 7, PinDataType::CV),
            AudioPin("Step 3 Mod", 8, PinDataType::CV), AudioPin("Step 4 Mod", 9, PinDataType::CV),
            AudioPin("Step 5 Mod", 10, PinDataType::CV), AudioPin("Step 6 Mod", 11, PinDataType::CV),
            AudioPin("Step 7 Mod", 12, PinDataType::CV), AudioPin("Step 8 Mod", 13, PinDataType::CV),
            AudioPin("Step 9 Mod", 14, PinDataType::CV), AudioPin("Step 10 Mod", 15, PinDataType::CV),
            AudioPin("Step 11 Mod", 16, PinDataType::CV), AudioPin("Step 12 Mod", 17, PinDataType::CV),
            AudioPin("Step 13 Mod", 18, PinDataType::CV), AudioPin("Step 14 Mod", 19, PinDataType::CV),
            AudioPin("Step 15 Mod", 20, PinDataType::CV), AudioPin("Step 16 Mod", 21, PinDataType::CV),
            // Per-step trigger mods (channels 22-37)
            AudioPin("Step 1 Trig Mod", 22, PinDataType::Gate), AudioPin("Step 2 Trig Mod", 23, PinDataType::Gate),
            AudioPin("Step 3 Trig Mod", 24, PinDataType::Gate), AudioPin("Step 4 Trig Mod", 25, PinDataType::Gate),
            AudioPin("Step 5 Trig Mod", 26, PinDataType::Gate), AudioPin("Step 6 Trig Mod", 27, PinDataType::Gate),
            AudioPin("Step 7 Trig Mod", 28, PinDataType::Gate), AudioPin("Step 8 Trig Mod", 29, PinDataType::Gate),
            AudioPin("Step 9 Trig Mod", 30, PinDataType::Gate), AudioPin("Step 10 Trig Mod", 31, PinDataType::Gate),
            AudioPin("Step 11 Trig Mod", 32, PinDataType::Gate), AudioPin("Step 12 Trig Mod", 33, PinDataType::Gate),
            AudioPin("Step 13 Trig Mod", 34, PinDataType::Gate), AudioPin("Step 14 Trig Mod", 35, PinDataType::Gate),
            AudioPin("Step 15 Trig Mod", 36, PinDataType::Gate), AudioPin("Step 16 Trig Mod", 37, PinDataType::Gate)
        },
        { // Outputs: Live outputs (0-6) + Parallel step outputs (7+)
            // Live Outputs
            AudioPin("Pitch", 0, PinDataType::CV), AudioPin("Gate", 1, PinDataType::Gate),
            AudioPin("Gate Nuanced", 2, PinDataType::CV), AudioPin("Velocity", 3, PinDataType::CV),
            AudioPin("Mod", 4, PinDataType::CV), AudioPin("Trigger", 5, PinDataType::Gate),
            AudioPin("Num Steps", 6, PinDataType::Raw),
            // Parallel Step Outputs (Corrected Names and Channels, shifted by +1 after Num Steps)
            AudioPin("Pitch 1", 7, PinDataType::CV), AudioPin("Gate 1", 8, PinDataType::Gate), AudioPin("Trig 1", 9, PinDataType::Gate),
            AudioPin("Pitch 2", 10, PinDataType::CV), AudioPin("Gate 2", 11, PinDataType::Gate), AudioPin("Trig 2", 12, PinDataType::Gate),
            AudioPin("Pitch 3", 13, PinDataType::CV), AudioPin("Gate 3", 14, PinDataType::Gate), AudioPin("Trig 3", 15, PinDataType::Gate),
            AudioPin("Pitch 4", 16, PinDataType::CV), AudioPin("Gate 4", 17, PinDataType::Gate), AudioPin("Trig 4", 18, PinDataType::Gate),
            AudioPin("Pitch 5", 19, PinDataType::CV), AudioPin("Gate 5", 20, PinDataType::Gate), AudioPin("Trig 5", 21, PinDataType::Gate),
            AudioPin("Pitch 6", 22, PinDataType::CV), AudioPin("Gate 6", 23, PinDataType::Gate), AudioPin("Trig 6", 24, PinDataType::Gate),
            AudioPin("Pitch 7", 25, PinDataType::CV), AudioPin("Gate 7", 26, PinDataType::Gate), AudioPin("Trig 7", 27, PinDataType::Gate),
            AudioPin("Pitch 8", 28, PinDataType::CV), AudioPin("Gate 8", 29, PinDataType::Gate), AudioPin("Trig 8", 30, PinDataType::Gate),
            AudioPin("Pitch 9", 31, PinDataType::CV), AudioPin("Gate 9", 32, PinDataType::Gate), AudioPin("Trig 9", 33, PinDataType::Gate),
            AudioPin("Pitch 10", 34, PinDataType::CV), AudioPin("Gate 10", 35, PinDataType::Gate), AudioPin("Trig 10", 36, PinDataType::Gate),
            AudioPin("Pitch 11", 37, PinDataType::CV), AudioPin("Gate 11", 38, PinDataType::Gate), AudioPin("Trig 11", 39, PinDataType::Gate),
            AudioPin("Pitch 12", 40, PinDataType::CV), AudioPin("Gate 12", 41, PinDataType::Gate), AudioPin("Trig 12", 42, PinDataType::Gate),
            AudioPin("Pitch 13", 43, PinDataType::CV), AudioPin("Gate 13", 44, PinDataType::Gate), AudioPin("Trig 13", 45, PinDataType::Gate),
            AudioPin("Pitch 14", 46, PinDataType::CV), AudioPin("Gate 14", 47, PinDataType::Gate), AudioPin("Trig 14", 48, PinDataType::Gate),
            AudioPin("Pitch 15", 49, PinDataType::CV), AudioPin("Gate 15", 50, PinDataType::Gate), AudioPin("Trig 15", 51, PinDataType::Gate),
            AudioPin("Pitch 16", 52, PinDataType::CV), AudioPin("Gate 16", 53, PinDataType::Gate), AudioPin("Trig 16", 54, PinDataType::Gate)
        },
        {}
    );
    db["comparator"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In", 0, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Gate) },
        {}
    );

    db["sample_loader"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("Pitch Mod", 0, PinDataType::CV),
            AudioPin("Speed Mod", 1, PinDataType::CV),
            AudioPin("Gate Mod", 2, PinDataType::CV),
            AudioPin("Trigger Mod", 3, PinDataType::Gate),
            AudioPin("Range Start Mod", 4, PinDataType::CV),
            AudioPin("Range End Mod", 5, PinDataType::CV),
            AudioPin("Randomize Trig", 6, PinDataType::Gate)
        },
        {
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    // Track Mixer - first 8 tracks UI definition (mono per track + gain/pan CV) and a Tracks Mod pin
    db["track mixer"] = ModulePinInfo(
        NodeWidth::Big,
        {
            // Mono audio inputs for first 8 tracks (absolute channels 0..7)
            AudioPin("In 1", 0, PinDataType::Audio),
            AudioPin("In 2", 1, PinDataType::Audio),
            AudioPin("In 3", 2, PinDataType::Audio),
            AudioPin("In 4", 3, PinDataType::Audio),
            AudioPin("In 5", 4, PinDataType::Audio),
            AudioPin("In 6", 5, PinDataType::Audio),
            AudioPin("In 7", 6, PinDataType::Audio),
            AudioPin("In 8", 7, PinDataType::Audio),

            // Num Tracks modulation CV at absolute channel 64 (start of Mod bus)
            AudioPin("Num Tracks Mod", 64, PinDataType::Raw),

            // Per-track CV inputs on Mod bus: Gain at 65,67,... Pan at 66,68,...
            AudioPin("Gain 1 Mod", 65, PinDataType::CV),  AudioPin("Pan 1 Mod", 66, PinDataType::CV),
            AudioPin("Gain 2 Mod", 67, PinDataType::CV),  AudioPin("Pan 2 Mod", 68, PinDataType::CV),
            AudioPin("Gain 3 Mod", 69, PinDataType::CV),  AudioPin("Pan 3 Mod", 70, PinDataType::CV),
            AudioPin("Gain 4 Mod", 71, PinDataType::CV),  AudioPin("Pan 4 Mod", 72, PinDataType::CV),
            AudioPin("Gain 5 Mod", 73, PinDataType::CV),  AudioPin("Pan 5 Mod", 74, PinDataType::CV),
            AudioPin("Gain 6 Mod", 75, PinDataType::CV),  AudioPin("Pan 6 Mod", 76, PinDataType::CV),
            AudioPin("Gain 7 Mod", 77, PinDataType::CV),  AudioPin("Pan 7 Mod", 78, PinDataType::CV),
            AudioPin("Gain 8 Mod", 79, PinDataType::CV),  AudioPin("Pan 8 Mod", 80, PinDataType::CV)
        },
        {
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    // Add PolyVCO module - Build the pin lists directly in initializer list
    db["polyvco"] = ModulePinInfo(
        NodeWidth::Big,
        {
            // Num Voices modulation input
            AudioPin("Num Voices Mod", 0, PinDataType::Raw),
            
            // Frequency modulation inputs (channels 1-32)
            AudioPin("Freq 1 Mod", 1, PinDataType::CV), AudioPin("Freq 2 Mod", 2, PinDataType::CV),
            AudioPin("Freq 3 Mod", 3, PinDataType::CV), AudioPin("Freq 4 Mod", 4, PinDataType::CV),
            AudioPin("Freq 5 Mod", 5, PinDataType::CV), AudioPin("Freq 6 Mod", 6, PinDataType::CV),
            AudioPin("Freq 7 Mod", 7, PinDataType::CV), AudioPin("Freq 8 Mod", 8, PinDataType::CV),
            AudioPin("Freq 9 Mod", 9, PinDataType::CV), AudioPin("Freq 10 Mod", 10, PinDataType::CV),
            AudioPin("Freq 11 Mod", 11, PinDataType::CV), AudioPin("Freq 12 Mod", 12, PinDataType::CV),
            AudioPin("Freq 13 Mod", 13, PinDataType::CV), AudioPin("Freq 14 Mod", 14, PinDataType::CV),
            AudioPin("Freq 15 Mod", 15, PinDataType::CV), AudioPin("Freq 16 Mod", 16, PinDataType::CV),
            AudioPin("Freq 17 Mod", 17, PinDataType::CV), AudioPin("Freq 18 Mod", 18, PinDataType::CV),
            AudioPin("Freq 19 Mod", 19, PinDataType::CV), AudioPin("Freq 20 Mod", 20, PinDataType::CV),
            AudioPin("Freq 21 Mod", 21, PinDataType::CV), AudioPin("Freq 22 Mod", 22, PinDataType::CV),
            AudioPin("Freq 23 Mod", 23, PinDataType::CV), AudioPin("Freq 24 Mod", 24, PinDataType::CV),
            AudioPin("Freq 25 Mod", 25, PinDataType::CV), AudioPin("Freq 26 Mod", 26, PinDataType::CV),
            AudioPin("Freq 27 Mod", 27, PinDataType::CV), AudioPin("Freq 28 Mod", 28, PinDataType::CV),
            AudioPin("Freq 29 Mod", 29, PinDataType::CV), AudioPin("Freq 30 Mod", 30, PinDataType::CV),
            AudioPin("Freq 31 Mod", 31, PinDataType::CV), AudioPin("Freq 32 Mod", 32, PinDataType::CV),
            
            // Waveform modulation inputs (channels 33-64)
            AudioPin("Wave 1 Mod", 33, PinDataType::CV), AudioPin("Wave 2 Mod", 34, PinDataType::CV),
            AudioPin("Wave 3 Mod", 35, PinDataType::CV), AudioPin("Wave 4 Mod", 36, PinDataType::CV),
            AudioPin("Wave 5 Mod", 37, PinDataType::CV), AudioPin("Wave 6 Mod", 38, PinDataType::CV),
            AudioPin("Wave 7 Mod", 39, PinDataType::CV), AudioPin("Wave 8 Mod", 40, PinDataType::CV),
            AudioPin("Wave 9 Mod", 41, PinDataType::CV), AudioPin("Wave 10 Mod", 42, PinDataType::CV),
            AudioPin("Wave 11 Mod", 43, PinDataType::CV), AudioPin("Wave 12 Mod", 44, PinDataType::CV),
            AudioPin("Wave 13 Mod", 45, PinDataType::CV), AudioPin("Wave 14 Mod", 46, PinDataType::CV),
            AudioPin("Wave 15 Mod", 47, PinDataType::CV), AudioPin("Wave 16 Mod", 48, PinDataType::CV),
            AudioPin("Wave 17 Mod", 49, PinDataType::CV), AudioPin("Wave 18 Mod", 50, PinDataType::CV),
            AudioPin("Wave 19 Mod", 51, PinDataType::CV), AudioPin("Wave 20 Mod", 52, PinDataType::CV),
            AudioPin("Wave 21 Mod", 53, PinDataType::CV), AudioPin("Wave 22 Mod", 54, PinDataType::CV),
            AudioPin("Wave 23 Mod", 55, PinDataType::CV), AudioPin("Wave 24 Mod", 56, PinDataType::CV),
            AudioPin("Wave 25 Mod", 57, PinDataType::CV), AudioPin("Wave 26 Mod", 58, PinDataType::CV),
            AudioPin("Wave 27 Mod", 59, PinDataType::CV), AudioPin("Wave 28 Mod", 60, PinDataType::CV),
            AudioPin("Wave 29 Mod", 61, PinDataType::CV), AudioPin("Wave 30 Mod", 62, PinDataType::CV),
            AudioPin("Wave 31 Mod", 63, PinDataType::CV), AudioPin("Wave 32 Mod", 64, PinDataType::CV),
            
            // Gate modulation inputs (channels 65-96)
            AudioPin("Gate 1 Mod", 65, PinDataType::Gate), AudioPin("Gate 2 Mod", 66, PinDataType::Gate),
            AudioPin("Gate 3 Mod", 67, PinDataType::Gate), AudioPin("Gate 4 Mod", 68, PinDataType::Gate),
            AudioPin("Gate 5 Mod", 69, PinDataType::Gate), AudioPin("Gate 6 Mod", 70, PinDataType::Gate),
            AudioPin("Gate 7 Mod", 71, PinDataType::Gate), AudioPin("Gate 8 Mod", 72, PinDataType::Gate),
            AudioPin("Gate 9 Mod", 73, PinDataType::Gate), AudioPin("Gate 10 Mod", 74, PinDataType::Gate),
            AudioPin("Gate 11 Mod", 75, PinDataType::Gate), AudioPin("Gate 12 Mod", 76, PinDataType::Gate),
            AudioPin("Gate 13 Mod", 77, PinDataType::Gate), AudioPin("Gate 14 Mod", 78, PinDataType::Gate),
            AudioPin("Gate 15 Mod", 79, PinDataType::Gate), AudioPin("Gate 16 Mod", 80, PinDataType::Gate),
            AudioPin("Gate 17 Mod", 81, PinDataType::Gate), AudioPin("Gate 18 Mod", 82, PinDataType::Gate),
            AudioPin("Gate 19 Mod", 83, PinDataType::Gate), AudioPin("Gate 20 Mod", 84, PinDataType::Gate),
            AudioPin("Gate 21 Mod", 85, PinDataType::Gate), AudioPin("Gate 22 Mod", 86, PinDataType::Gate),
            AudioPin("Gate 23 Mod", 87, PinDataType::Gate), AudioPin("Gate 24 Mod", 88, PinDataType::Gate),
            AudioPin("Gate 25 Mod", 89, PinDataType::Gate), AudioPin("Gate 26 Mod", 90, PinDataType::Gate),
            AudioPin("Gate 27 Mod", 91, PinDataType::Gate), AudioPin("Gate 28 Mod", 92, PinDataType::Gate),
            AudioPin("Gate 29 Mod", 93, PinDataType::Gate), AudioPin("Gate 30 Mod", 94, PinDataType::Gate),
            AudioPin("Gate 31 Mod", 95, PinDataType::Gate), AudioPin("Gate 32 Mod", 96, PinDataType::Gate)
        },
        {
            // Audio outputs (channels 0-31)
            AudioPin("Out 1", 0, PinDataType::Audio), AudioPin("Out 2", 1, PinDataType::Audio),
            AudioPin("Out 3", 2, PinDataType::Audio), AudioPin("Out 4", 3, PinDataType::Audio),
            AudioPin("Out 5", 4, PinDataType::Audio), AudioPin("Out 6", 5, PinDataType::Audio),
            AudioPin("Out 7", 6, PinDataType::Audio), AudioPin("Out 8", 7, PinDataType::Audio),
            AudioPin("Out 9", 8, PinDataType::Audio), AudioPin("Out 10", 9, PinDataType::Audio),
            AudioPin("Out 11", 10, PinDataType::Audio), AudioPin("Out 12", 11, PinDataType::Audio),
            AudioPin("Out 13", 12, PinDataType::Audio), AudioPin("Out 14", 13, PinDataType::Audio),
            AudioPin("Out 15", 14, PinDataType::Audio), AudioPin("Out 16", 15, PinDataType::Audio),
            AudioPin("Out 17", 16, PinDataType::Audio), AudioPin("Out 18", 17, PinDataType::Audio),
            AudioPin("Out 19", 18, PinDataType::Audio), AudioPin("Out 20", 19, PinDataType::Audio),
            AudioPin("Out 21", 20, PinDataType::Audio), AudioPin("Out 22", 21, PinDataType::Audio),
            AudioPin("Out 23", 22, PinDataType::Audio), AudioPin("Out 24", 23, PinDataType::Audio),
            AudioPin("Out 25", 24, PinDataType::Audio), AudioPin("Out 26", 25, PinDataType::Audio),
            AudioPin("Out 27", 26, PinDataType::Audio), AudioPin("Out 28", 27, PinDataType::Audio),
            AudioPin("Out 29", 28, PinDataType::Audio), AudioPin("Out 30", 29, PinDataType::Audio),
            AudioPin("Out 31", 30, PinDataType::Audio), AudioPin("Out 32", 31, PinDataType::Audio)
        },
        {}
    );
    
    // Add missing modules
    db["Quantizer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("CV In", 0, PinDataType::CV), AudioPin("Scale Mod", 1, PinDataType::CV), AudioPin("Root Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );
    
    db["TimePitch"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Audio In", 0, PinDataType::Audio), AudioPin("Speed Mod", 1, PinDataType::CV), AudioPin("Pitch Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    
    // Note: TTS Performer pin database is defined earlier in this function (around line 378)
    // Duplicate entry removed to avoid conflicts

    
    // Add TrackMixer module alias (main definition is "track mixer" above)
    db["trackmixer"] = db["track mixer"];
    
    
    // Add MIDI Player module
    db["midiplayer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        {},
        {},
        {}
    );
    
    // Add converter modules
    db["Attenuverter"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Amount Mod", 2, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    
    // Add lowercase alias for Attenuverter
    db["attenuverter"] = db["Attenuverter"];
    
    // Add Sample & Hold module
    db["s&h"] = ModulePinInfo(
        NodeWidth::Small,
        { 
            AudioPin("Signal In L", 0, PinDataType::Audio),
            AudioPin("Signal In R", 1, PinDataType::Audio),
            AudioPin("Trig In L", 2, PinDataType::Gate),
            AudioPin("Trig In R", 3, PinDataType::Gate),
            AudioPin("Threshold Mod", 4, PinDataType::CV),
            AudioPin("Edge Mod", 5, PinDataType::CV),
            AudioPin("Slew Mod", 6, PinDataType::CV)
        },
        { 
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    db["MapRange"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Raw In", 0, PinDataType::Raw) },
        { AudioPin("CV Out", 0, PinDataType::CV), AudioPin("Audio Out", 1, PinDataType::Audio) },
        { ModPin("Min In", "minIn", PinDataType::Raw), ModPin("Max In", "maxIn", PinDataType::Raw), ModPin("Min Out", "minOut", PinDataType::Raw), ModPin("Max Out", "maxOut", PinDataType::Raw) }
    );
    
    db["Lag Processor"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Signal In", 0, PinDataType::CV), AudioPin("Rise Mod", 1, PinDataType::CV), AudioPin("Fall Mod", 2, PinDataType::CV) },
        { AudioPin("Smoothed Out", 0, PinDataType::CV) },
        {}
    );
    
    db["De-Crackle"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // ADD MISSING MODULES FOR COLOR-CODED CHAINING

    db["Scope"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In", 0, PinDataType::Audio) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );

    db["Logic"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A", 0, PinDataType::Gate), AudioPin("In B", 1, PinDataType::Gate) },
        {
            AudioPin("AND", 0, PinDataType::Gate),
            AudioPin("OR", 1, PinDataType::Gate),
            AudioPin("XOR", 2, PinDataType::Gate),
            AudioPin("NOT A", 3, PinDataType::Gate)
        },
        {}
    );

    db["ClockDivider"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Clock In", 0, PinDataType::Gate), AudioPin("Reset", 1, PinDataType::Gate) },
        {
            AudioPin("/2", 0, PinDataType::Gate), AudioPin("/4", 1, PinDataType::Gate),
            AudioPin("/8", 2, PinDataType::Gate), AudioPin("x2", 3, PinDataType::Gate),
            AudioPin("x3", 4, PinDataType::Gate), AudioPin("x4", 5, PinDataType::Gate)
        },
        {}
    );

    db["Rate"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Rate Mod", 0, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );

    // ADD REMAINING MISSING MODULES FROM CMAKE LISTS

    db["Math"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A", 0, PinDataType::CV), AudioPin("In B", 1, PinDataType::CV) },
        { AudioPin("Add", 0, PinDataType::CV), AudioPin("Subtract", 1, PinDataType::CV),
          AudioPin("Multiply", 2, PinDataType::CV), AudioPin("Divide", 3, PinDataType::CV) },
        {}
    );

    db["SequentialSwitch"] = ModulePinInfo(
        NodeWidth::Small,
        { 
            AudioPin("Gate In", 0, PinDataType::Audio),
            AudioPin("Thresh 1 CV", 1, PinDataType::CV),
            AudioPin("Thresh 2 CV", 2, PinDataType::CV),
            AudioPin("Thresh 3 CV", 3, PinDataType::CV),
            AudioPin("Thresh 4 CV", 4, PinDataType::CV)
        },
        { 
            AudioPin("Out 1", 0, PinDataType::Audio),
            AudioPin("Out 2", 1, PinDataType::Audio),
            AudioPin("Out 3", 2, PinDataType::Audio),
            AudioPin("Out 4", 3, PinDataType::Audio)
        },
        {}
    );

    db["snapshot_sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("Clock", 0, PinDataType::Gate), AudioPin("Reset", 1, PinDataType::Gate) },
        {}, // No audio outputs
        {}
    );

    db["midi cv"] = ModulePinInfo(
        NodeWidth::Medium,
        {}, // No inputs - receives MIDI messages
        {
            AudioPin("Pitch", 0, PinDataType::CV),
            AudioPin("Gate", 1, PinDataType::Gate),
            AudioPin("Velocity", 2, PinDataType::CV),
            AudioPin("Mod Wheel", 3, PinDataType::CV),
            AudioPin("Pitch Bend", 4, PinDataType::CV),
            AudioPin("Aftertouch", 5, PinDataType::CV)
        },
        {}
    );

    // MIDI Family - New Modules with Correct Pin Types
    {
        // MIDI Faders: All outputs are CV (blue)
        db["midi faders"] = ModulePinInfo();
        db["midi faders"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 16; ++i)
            db["midi faders"].audioOuts.emplace_back("Fader " + juce::String(i+1), i, PinDataType::CV);

        // MIDI Knobs: All outputs are CV (blue)
        db["midi knobs"] = ModulePinInfo();
        db["midi knobs"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 16; ++i)
            db["midi knobs"].audioOuts.emplace_back("Knob " + juce::String(i+1), i, PinDataType::CV);

        // MIDI Buttons: All outputs are Gate/Trigger (yellow)
        db["midi buttons"] = ModulePinInfo();
        db["midi buttons"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 32; ++i)
            db["midi buttons"].audioOuts.emplace_back("Button " + juce::String(i+1), i, PinDataType::Gate);

        // MIDI Jog Wheel: Output is CV (blue)
        db["midi jog wheel"] = ModulePinInfo(
            NodeWidth::Small,
            {},
            { AudioPin("Value", 0, PinDataType::CV) },
            {}
        );
    }

    db["Debug"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In", 0, PinDataType::Audio) },
        {}, // No outputs
        {}
    );

    db["InputDebug"] = ModulePinInfo(
        NodeWidth::Small,
        {}, // No inputs
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );

    // Tempo Clock
    db["tempo_clock"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        {
            AudioPin("BPM Mod", 0, PinDataType::CV),
            AudioPin("Tap", 1, PinDataType::Gate),
            AudioPin("Nudge+", 2, PinDataType::Gate),
            AudioPin("Nudge-", 3, PinDataType::Gate),
            AudioPin("Play", 4, PinDataType::Gate),
            AudioPin("Stop", 5, PinDataType::Gate),
            AudioPin("Reset", 6, PinDataType::Gate),
            AudioPin("Swing Mod", 7, PinDataType::CV)
        },
        {
            AudioPin("Clock", 0, PinDataType::Gate),
            AudioPin("Beat Trig", 1, PinDataType::Gate),
            AudioPin("Bar Trig", 2, PinDataType::Gate),
            AudioPin("Beat Gate", 3, PinDataType::Gate),
            AudioPin("Phase", 4, PinDataType::CV),
            AudioPin("BPM CV", 5, PinDataType::CV),
            AudioPin("Downbeat", 6, PinDataType::Gate)
        },
        {
            ModPin("BPM", "bpm_mod", PinDataType::CV),
            ModPin("Tap", "tap_mod", PinDataType::Gate),
            ModPin("Nudge+", "nudge_up_mod", PinDataType::Gate),
            ModPin("Nudge-", "nudge_down_mod", PinDataType::Gate),
            ModPin("Play", "play_mod", PinDataType::Gate),
            ModPin("Stop", "stop_mod", PinDataType::Gate),
            ModPin("Reset", "reset_mod", PinDataType::Gate),
            ModPin("Swing", "swing_mod", PinDataType::CV)
        }
    );

    // Timeline - Uses dynamic pins based on automation channels
    db["timeline"] = ModulePinInfo(
        NodeWidth::Big,
        {}, // Dynamic inputs defined by module (one per automation channel)
        {}, // Dynamic outputs defined by module (one per automation channel)
        {}
    );

    // BPM Monitor - Uses dynamic pins based on detected rhythm sources
    db["bpm_monitor"] = ModulePinInfo(
        NodeWidth::Big,
        {}, // Dynamic inputs defined by module (beat detection inputs)
        {}, // Dynamic outputs defined by module (per-source BPM/CV/Active)
        {}
    );

    // Physics Module - Exception size (custom dimensions defined by module)
    db["physics"] = ModulePinInfo(
        NodeWidth::Exception,
        {}, // Dynamic inputs defined by module
        {}, // Dynamic outputs defined by module
        {}
    );

    db["webcam_loader"] = ModulePinInfo(
        NodeWidth::Exception, // Custom size for video display
        {}, // No inputs
        { 
            AudioPin("Source ID", 0, PinDataType::Video)
        },
        {}
    );

    db["video_file_loader"] = ModulePinInfo(
        NodeWidth::Exception, // Custom size for video display
        {}, // No inputs
        { 
            AudioPin("Source ID", 0, PinDataType::Video)
        },
        {}
    );

    db["movement_detector"] = ModulePinInfo(
        NodeWidth::Exception,
        { AudioPin("Source In", 0, PinDataType::Video) },
        { 
            AudioPin("Motion X", 0, PinDataType::CV), AudioPin("Motion Y", 1, PinDataType::CV),
            AudioPin("Amount", 2, PinDataType::CV), AudioPin("Trigger", 3, PinDataType::Gate),
            AudioPin("Video Out", 0, PinDataType::Video) // Bus 1
        },
        {}
    );

    db["human_detector"] = ModulePinInfo(
        NodeWidth::Exception,
        { AudioPin("Source In", 0, PinDataType::Video) },
        {
            AudioPin("X", 0, PinDataType::CV), AudioPin("Y", 1, PinDataType::CV),
            AudioPin("Width", 2, PinDataType::CV), AudioPin("Height", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate),
            AudioPin("Video Out", 0, PinDataType::Video),   // Bus 1
            AudioPin("Cropped Out", 1, PinDataType::Video) // Bus 2
        },
        {}
    );

    // Object Detector (YOLOv3) - 1 input (Source ID) and 7 outputs (X,Y,Width,Height,Gate,Video Out,Cropped Out)
    db["object_detector"] = ModulePinInfo(
        NodeWidth::Exception,
        { AudioPin("Source In", 0, PinDataType::Video) },
        {
            AudioPin("X", 0, PinDataType::CV), AudioPin("Y", 1, PinDataType::CV),
            AudioPin("Width", 2, PinDataType::CV), AudioPin("Height", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate),
            AudioPin("Video Out", 0, PinDataType::Video),   // Bus 1
            AudioPin("Cropped Out", 1, PinDataType::Video) // Bus 2
        },
        {}
    );

    // Color Tracker: dynamic outputs (3 per color). Only declare input here.
    db["color_tracker"] = ModulePinInfo(
        NodeWidth::Exception, // custom node width with zoom
        {
            AudioPin("Source In", 0, PinDataType::Video)
        },
        {
            AudioPin("Video Out", 0, PinDataType::Video) // Bus 1 - dynamic color pins are added programmatically
        },
        {}
    );

    // Pose Estimator: 15 keypoints x 2 coordinates = 30 output pins + Video Out
    db["pose_estimator"] = ModulePinInfo();
    db["pose_estimator"].defaultWidth = NodeWidth::Exception; // Custom size with zoom support
    db["pose_estimator"].audioIns.emplace_back("Source In", 0, PinDataType::Video);
    // Programmatically add all 30 output pins (15 keypoints x 2 coordinates)
    const std::vector<std::string> keypointNames = {
        "Head", "Neck", "R Shoulder", "R Elbow", "R Wrist",
        "L Shoulder", "L Elbow", "L Wrist", "R Hip", "R Knee",
        "R Ankle", "L Hip", "L Knee", "L Ankle", "Chest"
    };
    for (size_t i = 0; i < keypointNames.size(); ++i)
    {
        db["pose_estimator"].audioOuts.emplace_back(keypointNames[i] + " X", static_cast<int>(i * 2), PinDataType::CV);
        db["pose_estimator"].audioOuts.emplace_back(keypointNames[i] + " Y", static_cast<int>(i * 2 + 1), PinDataType::CV);
    }
    // Add Video Out and Cropped Out pins (bus 1 and 2)
    db["pose_estimator"].audioOuts.emplace_back("Video Out", 0, PinDataType::Video);
    db["pose_estimator"].audioOuts.emplace_back("Cropped Out", 1, PinDataType::Video);

    // Hand Tracker: 21 keypoints x 2 = 42 outs
    db["hand_tracker"] = ModulePinInfo();
    db["hand_tracker"].defaultWidth = NodeWidth::Exception;
    db["hand_tracker"].audioIns.emplace_back("Source In", 0, PinDataType::Video);
    const char* handNames[21] = {
        "Wrist",
        "Thumb 1","Thumb 2","Thumb 3","Thumb 4",
        "Index 1","Index 2","Index 3","Index 4",
        "Middle 1","Middle 2","Middle 3","Middle 4",
        "Ring 1","Ring 2","Ring 3","Ring 4",
        "Pinky 1","Pinky 2","Pinky 3","Pinky 4"
    };
    for (int i=0;i<21;++i)
    {
        db["hand_tracker"].audioOuts.emplace_back(std::string(handNames[i]) + " X", i*2, PinDataType::CV);
        db["hand_tracker"].audioOuts.emplace_back(std::string(handNames[i]) + " Y", i*2+1, PinDataType::CV);
    }
    // Add Video Out and Cropped Out pins (bus 1 and 2)
    db["hand_tracker"].audioOuts.emplace_back("Video Out", 0, PinDataType::Video);
    db["hand_tracker"].audioOuts.emplace_back("Cropped Out", 1, PinDataType::Video);

    // Face Tracker: 70 * 2 = 140 outs + Video Out + Cropped Out
    db["face_tracker"] = ModulePinInfo();
    db["face_tracker"].defaultWidth = NodeWidth::Exception;
    db["face_tracker"].audioIns.emplace_back("Source In", 0, PinDataType::Video);
    for (int i=0;i<70;++i)
    {
        std::string base = std::string("Pt ") + std::to_string(i+1);
        db["face_tracker"].audioOuts.emplace_back(base + " X", i*2, PinDataType::CV);
        db["face_tracker"].audioOuts.emplace_back(base + " Y", i*2+1, PinDataType::CV);
    }
    // Add Video Out and Cropped Out pins (bus 1 and 2)
    db["face_tracker"].audioOuts.emplace_back("Video Out", 0, PinDataType::Video);
    db["face_tracker"].audioOuts.emplace_back("Cropped Out", 1, PinDataType::Video);

    // Add aliases for nodes with underscore naming convention
    db["clock_divider"] = db["ClockDivider"];
    db["sequential_switch"] = db["SequentialSwitch"];
    db["s_and_h"] = db["s&h"];

    // Contour Detector: 1 input, 3 CV outputs + Video Out
    db["contour_detector"] = ModulePinInfo(
        NodeWidth::Exception,
        { AudioPin("Source In", 0, PinDataType::Video) },
        { 
            AudioPin("Area", 0, PinDataType::CV), AudioPin("Complexity", 1, PinDataType::CV), 
            AudioPin("Aspect Ratio", 2, PinDataType::CV), AudioPin("Video Out", 0, PinDataType::Video) // Bus 1
        },
        {}
    );

    // Semantic Segmentation: 1 input, 4 CV outputs + Video Out
    db["semantic_segmentation"] = ModulePinInfo(
        NodeWidth::Exception,
        { AudioPin("Source In", 0, PinDataType::Video) },
        { 
            AudioPin("Area", 0, PinDataType::CV), AudioPin("Center X", 1, PinDataType::CV), 
            AudioPin("Center Y", 2, PinDataType::CV), AudioPin("Gate", 3, PinDataType::Gate),
            AudioPin("Video Out", 0, PinDataType::Video) // Bus 1
        },
        {}
    );

    // Video FX Module - Uses dynamic pins based on video source
    db["video_fx"] = ModulePinInfo(
        NodeWidth::Exception, // Custom size for video preview
        {}, // Dynamic inputs defined by module (video source + optional CV parameters)
        {}, // Dynamic outputs defined by module (processed video output)
        {}
    );

    // Crop Video Module - takes source ID and CV modulation signals (X, Y, W, H) to crop a video stream
    db["crop_video"] = ModulePinInfo(
        NodeWidth::Exception, // Uses custom size for video preview
        {
            AudioPin("Source In", 0, PinDataType::Video)
        },
        {
            AudioPin("Output ID", 0, PinDataType::Video)
        },
        {
            ModPin("Center X", "cropX_mod", PinDataType::CV),
            ModPin("Center Y", "cropY_mod", PinDataType::CV),
            ModPin("Width", "cropW_mod", PinDataType::CV),
            ModPin("Height", "cropH_mod", PinDataType::CV)
        }
    );

}





================================================================================
FILE: juce\Source\ui\MainComponent.cpp
================================================================================


#include "MainComponent.h"
#include "../audio/AudioEngine.h"

struct ConnTimer : public juce::Timer {
    MainComponent& mc;
    ConnTimer (MainComponent& m) : mc (m) { startTimerHz (10); }
    void timerCallback() override {
        mc.connLabel.setText ("OSC: listening", juce::dontSendNotification);
    }
};

MainComponent::MainComponent()
    : testHarness(deviceManager) // Initialize testHarness with deviceManager in member initializer list
{
    // Create audio engine (OSC + graph, acts as AudioSource)
    audioEngine = std::make_unique<AudioEngine>(deviceManager);
    
    // Make the UI visible
    addAndMakeVisible(testHarness);
    
    // THIS IS THE CRITICAL CONNECTION:
    // Pass the engine pointer to the UI component.
    testHarness.setAudioEngine(audioEngine.get());

    // Open default audio device on this MainComponent (the AudioAppComponent)
    setAudioChannels (2, 2); // Request 2 input channels, 2 output channels

    setSize(1600, 900); // Set a default size for the main window
}

MainComponent::~MainComponent()
{
    // Close audio device on MainComponent
    shutdownAudio();
}

void MainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (16.0f);
    g.drawFittedText ("Collider Audio Engine (JUCE)", getLocalBounds(), juce::Justification::centredTop, 1);
}

void MainComponent::resized()
{
    // Make the TestHarnessComponent fill the entire window.
    testHarness.setBounds(getLocalBounds());
}

void MainComponent::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    juce::Logger::writeToLog ("[APP] MainComponent::prepareToPlay called");
    // Log current audio device selection for diagnostics
    {
        juce::AudioDeviceManager::AudioDeviceSetup setup; deviceManager.getAudioDeviceSetup (setup);
        auto* dev = deviceManager.getCurrentAudioDevice();
        juce::Logger::writeToLog ("[APP] Audio device: out='" + setup.outputDeviceName
                                  + "' sr=" + juce::String (dev ? dev->getCurrentSampleRate() : 0.0)
                                  + " bs=" + juce::String (dev ? dev->getCurrentBufferSizeSamples() : 0));
    }
    if (audioEngine)
        audioEngine->prepareToPlay (samplesPerBlockExpected, sampleRate);
}

void MainComponent::getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill)
{
    if (audioEngine)
        audioEngine->getNextAudioBlock (bufferToFill);
    else if (bufferToFill.buffer != nullptr)
        bufferToFill.buffer->clear();
}

void MainComponent::releaseResources()
{
    juce::Logger::writeToLog ("[APP] MainComponent::releaseResources called");
    if (audioEngine)
        audioEngine->releaseResources();
}




================================================================================
FILE: juce\Source\ui\TestHarnessComponent.cpp
================================================================================


#include "TestHarnessComponent.h"
#include "MainComponent.h"
#include "../audio/voices/NoiseVoiceProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include "../audio/voices/SynthVoiceProcessor.h"
#include "../audio/voices/SampleVoiceProcessor.h"
#include "../audio/voices/ModularVoice.h"
#include "../audio/utils/VoiceDeletionUtils.h"
#include "../audio/AudioEngine.h"
#include "../ipc/CommandBus.h"

static juce::TextEditor* gLoggerEditor = nullptr;

void OnScreenLogger::attach (juce::TextEditor* editor)
{
    gLoggerEditor = editor;
}

void OnScreenLogger::log (const juce::String& msg)
{
    if (gLoggerEditor != nullptr)
    {
        if (juce::MessageManager::getInstanceWithoutCreating() != nullptr
            && juce::MessageManager::getInstance()->isThisTheMessageThread())
        {
            gLoggerEditor->moveCaretToEnd();
            gLoggerEditor->insertTextAtCaret (msg + "\n");
        }
        else
        {
            juce::MessageManager::callAsync ([s = msg]
            {
                if (gLoggerEditor != nullptr)
                {
                    gLoggerEditor->moveCaretToEnd();
                    gLoggerEditor->insertTextAtCaret (s + "\n");
                }
            });
        }
    }
    juce::Logger::writeToLog (msg);
}

TestHarnessComponent::TestHarnessComponent(juce::AudioDeviceManager& adm)
    : deviceManager(adm)
{
    OnScreenLogger::attach (&logView);
    OnScreenLogger::log ("Harness: Constructor starting...");

    // Set initial harness window size once
    setSize (1600, 900); // More reasonable default size


    addAndMakeVisible (btnAudioSettings);
    addAndMakeVisible (btnCreateSynth);
    addAndMakeVisible (btnCreateSample);
    addAndMakeVisible (btnCreateNoise);
    addAndMakeVisible (btnCreateModular);
    addAndMakeVisible (btnLoadPreset);
    addAndMakeVisible (btnDestroy);
    addAndMakeVisible (btnDestroyRandom);
    addAndMakeVisible (btnDestroySelected);
    addAndMakeVisible (btnRandomPitch);
    addAndMakeVisible (btnRandomTime);
    addAndMakeVisible (btnResetFx);
    addAndMakeVisible (btnChaos);
    addAndMakeVisible (btnManualFx);
    addAndMakeVisible (lEngine);
    addAndMakeVisible (comboEngine);
    comboEngine.addItem ("RubberBand", 1);
    comboEngine.addItem ("Naive", 2);
    comboEngine.setSelectedId (1, juce::dontSendNotification);
    comboEngine.addListener (this);
    addAndMakeVisible (sliderGain);
    addAndMakeVisible (sliderPan);
    addAndMakeVisible (lblGain);
    addAndMakeVisible (lblPan);
    addAndMakeVisible (lblStatus);
    addAndMakeVisible (lblDevice);
    addAndMakeVisible (lblVoices);
    addAndMakeVisible (lblPeak);
    addAndMakeVisible (logView);
    addAndMakeVisible (listDirs);
    addAndMakeVisible (listSamples);
    addAndMakeVisible (listVoices);
    listDirs.setRowHeight (22);
    listSamples.setRowHeight (22);
    listVoices.setRowHeight (22);
    listDirs.setMultipleSelectionEnabled (false);
    listSamples.setMultipleSelectionEnabled (false);
    listVoices.setMultipleSelectionEnabled (false);
    listDirs.setModel (&dirModel);
    listSamples.setModel (&sampleModel);
    listVoices.setModel (&voiceModel);
    listDirs.getVerticalScrollBar().setAutoHide (false);
    listSamples.getVerticalScrollBar().setAutoHide (false);
    listVoices.getVerticalScrollBar().setAutoHide (false);
    auto initSlider = [] (juce::Slider& s, double min, double max, double def, double inc=0.001)
    {
        s.setRange (min, max, inc);
        s.setValue (def);
    };
    auto addL = [this] (juce::Label& l) { addAndMakeVisible (l); };
    auto addS = [this] (juce::Slider& s) { addAndMakeVisible (s); s.addListener (this); };

    // Initialize FX sliders, defaults to "dry" positions
    addL (lFilterCutoff); addS (sFilterCutoff); initSlider (sFilterCutoff, 20.0, 20000.0, 20000.0, 1.0);
    addL (lFilterRes);    addS (sFilterRes);    initSlider (sFilterRes, 1.0, 20.0, 1.0);

    addL (lChRate);  addS (sChRate);  initSlider (sChRate, 0.1, 10.0, 1.0);
    addL (lChDepth); addS (sChDepth); initSlider (sChDepth, 0.0, 1.0, 0.0);
    addL (lChMix);   addS (sChMix);   initSlider (sChMix, 0.0, 1.0, 0.0);

    addL (lPhRate);   addS (sPhRate);   initSlider (sPhRate, 0.01, 10.0, 0.5);
    addL (lPhDepth);  addS (sPhDepth);  initSlider (sPhDepth, 0.0, 1.0, 0.0);
    addL (lPhCentre); addS (sPhCentre); initSlider (sPhCentre, 20.0, 20000.0, 1000.0, 1.0);
    addL (lPhFb);     addS (sPhFb);     initSlider (sPhFb, -0.99, 0.99, 0.0);
    addL (lPhMix);    addS (sPhMix);    initSlider (sPhMix, 0.0, 1.0, 0.0);

    addL (lRvRoom); addS (sRvRoom); initSlider (sRvRoom, 0.0, 1.0, 0.0);
    addL (lRvDamp); addS (sRvDamp); initSlider (sRvDamp, 0.0, 1.0, 0.5);
    addL (lRvWidth);addS (sRvWidth);initSlider (sRvWidth,0.0, 1.0, 1.0);
    addL (lRvMix);  addS (sRvMix);  initSlider (sRvMix,  0.0, 1.0, 0.0);

    addL (lDlTime); addS (sDlTime); initSlider (sDlTime, 1.0, 2000.0, 0.0, 1.0);
    addL (lDlFb);   addS (sDlFb);   initSlider (sDlFb,   0.0, 0.95, 0.0);
    addL (lDlMix);  addS (sDlMix);  initSlider (sDlMix,  0.0, 1.0, 0.0);

    addL (lCpThresh); addS (sCpThresh); initSlider (sCpThresh, -60.0, 0.0, 0.0);
    addL (lCpRatio);  addS (sCpRatio);  initSlider (sCpRatio,  1.0, 20.0, 1.0);
    addL (lCpAtk);    addS (sCpAtk);    initSlider (sCpAtk,    0.1, 200.0, 10.0);
    addL (lCpRel);    addS (sCpRel);    initSlider (sCpRel,    5.0, 1000.0, 100.0);
    addL (lCpMake);   addS (sCpMake);   initSlider (sCpMake,  -12.0, 12.0, 0.0);

    addL (lLmThresh); addS (sLmThresh); initSlider (sLmThresh, -20.0, 0.0, 0.0);
    addL (lLmRel);    addS (sLmRel);    initSlider (sLmRel,     1.0, 200.0, 10.0);

    addL (lDrAmt); addS (sDrAmt); initSlider (sDrAmt, 0.0, 2.0, 0.0);
    addL (lDrMix); addS (sDrMix); initSlider (sDrMix, 0.0, 1.0, 0.0);

    addL (lGtThresh); addS (sGtThresh); initSlider (sGtThresh, -80.0, -20.0, -100.0);
    addL (lGtAtk);    addS (sGtAtk);    initSlider (sGtAtk,      0.1, 50.0, 1.0);
    addL (lGtRel);    addS (sGtRel);    initSlider (sGtRel,        5.0, 500.0, 50.0);

    addL (lTsRatio); addS (sTsRatio); initSlider (sTsRatio, 0.25, 6.0, 1.0);
    addL (lPtSemis); addS (sPtSemis); initSlider (sPtSemis, -24.0, 24.0, 0.0);
    addL (lPtRatio); addS (sPtRatio); initSlider (sPtRatio, 0.5, 2.0, 1.0);

    btnAudioSettings.addListener (this);
    btnCreateSynth.addListener (this);
    btnCreateSample.addListener (this);
    btnCreateNoise.addListener (this);
    btnCreateModular.addListener (this);
    btnLoadPreset.addListener (this);
    btnDestroy.addListener (this);
    btnDestroyRandom.addListener (this);
    btnDestroySelected.addListener (this);
    btnRandomPitch.addListener (this);
    btnRandomTime.addListener (this);
    btnResetFx.addListener (this);

    sliderGain.setRange (0.0, 1.0, 0.001);
    sliderGain.setSkewFactor (0.7);
    sliderGain.setValue (0.7);
    sliderGain.addListener (this);

    sliderPan.setRange (-1.0, 1.0, 0.001);
    sliderPan.setValue (0.0);
    sliderPan.addListener (this);

    lblStatus.setText ("Controlling Voice ID: -", juce::dontSendNotification);
    logView.setMultiLine (true); logView.setReadOnly (true); logView.setScrollbarsShown (true); logView.setCaretVisible (false);
    logView.setText ("[Harness] Ready\n");
    startTimerHz (15);

    // (Removed VCO verification instantiation and slider)

    // Load samples by searching upwards for 'audio/samples' from exe and CWD
    auto findSamplesDir = []() -> juce::File
    {
        juce::Array<juce::File> starts;
        starts.add (juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory());
        starts.add (juce::File::getCurrentWorkingDirectory());
        for (auto s : starts)
        {
            juce::File cur = s;
            for (int i = 0; i < 8; ++i)
            {
                juce::File candidate = cur.getChildFile ("audio").getChildFile ("samples");
                if (candidate.isDirectory())
                    return candidate;
                cur = cur.getParentDirectory();
            }
        }
        return {};
    };

    juce::File root = findSamplesDir();
    if (root.isDirectory())
    {
        OnScreenLogger::log ("[SampleBank] Searching samples in: " + root.getFullPathName());
        sampleBank.loadSamplesFromDirectory (root);
        samplesRoot = root;
        refreshDirectories();
        refreshSamples();
    }
    else
    {
        OnScreenLogger::log ("[SampleBank][WARN] Could not locate 'audio/samples' relative to exe or CWD.");
    }

    OnScreenLogger::log ("Harness: Constructor finished.");
}

// ----------- ListBoxModel (shared for both lists) -----------
int TestHarnessComponent::DirListModel::getNumRows() { return owner.dirNames.size(); }
void TestHarnessComponent::DirListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowNumber < 0 || rowNumber >= owner.dirNames.size()) return;
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    g.setColour (juce::Colours::white);
    g.drawText (owner.dirNames[rowNumber], 6, 0, width - 12, height, juce::Justification::centredLeft);
}
void TestHarnessComponent::DirListModel::selectedRowsChanged (int /*lastRowSelected*/)
{
    owner.selectedDirIndex = owner.listDirs.getSelectedRow();
    owner.refreshSamples();
}
void TestHarnessComponent::DirListModel::listBoxItemClicked (int row, const juce::MouseEvent&)
{
    owner.selectedDirIndex = row;
    owner.listDirs.selectRow (row);
    owner.refreshSamples();
}
int TestHarnessComponent::SampleListModel::getNumRows() { return owner.sampleNames.size(); }
void TestHarnessComponent::SampleListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    if (rowNumber < 0 || rowNumber >= owner.sampleNames.size()) return;
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    g.setColour (juce::Colours::white);
    g.drawText (owner.sampleNames[rowNumber], 6, 0, width - 12, height, juce::Justification::centredLeft);
}
void TestHarnessComponent::SampleListModel::selectedRowsChanged (int lastRowSelected)
{
    owner.selectedSampleIndex = lastRowSelected;
}

// -------- Voices list model --------
// --- VoiceListModel Methods ---
int TestHarnessComponent::VoiceListModel::getNumRows() { return (int)owner.engineVoices.size(); }

void TestHarnessComponent::VoiceListModel::paintListBoxItem (int rowNumber, juce::Graphics& g, int width, int height, bool rowIsSelected)
{
    g.fillAll (rowIsSelected ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
    if (rowNumber >= 0 && rowNumber < (int)owner.engineVoices.size())
    {
        const auto& voiceInfo = owner.engineVoices[rowNumber];
        juce::String text = juce::String((juce::int64)voiceInfo.voiceId) + " - " + voiceInfo.voiceType;
        if (voiceInfo.displayName.isNotEmpty())
            text += " (" + voiceInfo.displayName + ")";
        g.setColour (juce::Colours::white);
        g.drawText (text, 6, 0, width - 12, height, juce::Justification::centredLeft);
    }
}

void TestHarnessComponent::VoiceListModel::listBoxItemClicked (int row, const juce::MouseEvent&)
{
    owner.listVoices.selectRow(row);
}

void TestHarnessComponent::VoiceListModel::selectedRowsChanged(int lastRowSelected)
{
    owner.setControlledVoiceByIndex(lastRowSelected);
}

void TestHarnessComponent::refreshDirectories()
{
    dirNames.clear(); dirPaths.clear();
    if (! samplesRoot.isDirectory()) return;
    auto sub = samplesRoot.findChildFiles (juce::File::findDirectories, false);
    sub.sort();
    for (auto& d : sub)
    {
        dirNames.add (d.getFileName());
        dirPaths.add (d);
    }
    listDirs.updateContent();
    if (selectedDirIndex < 0 && dirNames.size() > 0)
    {
        selectedDirIndex = 0;
        listDirs.selectRow (0);
    }
}

void TestHarnessComponent::refreshSamples()
{
    sampleNames.clear(); samplePaths.clear();
    if (selectedDirIndex >= 0 && selectedDirIndex < dirPaths.size())
    {
        auto dir = dirPaths[(int) selectedDirIndex];
        juce::Array<juce::File> files;
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.wav"));
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.aif"));
        files.addArray (dir.findChildFiles (juce::File::findFiles, false, "*.aiff"));
        files.sort();
        for (auto& f : files)
        {
            sampleNames.add (f.getFileName());
            samplePaths.add (f);
        }
    }
    listSamples.updateContent();
}

TestHarnessComponent::~TestHarnessComponent()
{
}

void TestHarnessComponent::setAudioEngine(AudioEngine* engine)
{
    audioEngine = engine;
    OnScreenLogger::log ("Harness: Connected to AudioEngine.");
}




void TestHarnessComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
    g.setColour (juce::Colours::white);
    g.setFont (16.0f);
    g.drawFittedText ("Collider Audio Test Harness", getLocalBounds(), juce::Justification::centredTop, 1);
}

void TestHarnessComponent::resized()
{
	// Do not setSize() here; window size controlled in constructor and by host
	int x = 10, y = 40, w = juce::jmin (340, getWidth() - 20), h = 24, gap = 6;
    btnAudioSettings.setBounds (x, y, w, h); y += h + gap;
	btnCreateSynth.setBounds (x, y, w, h); y += h + gap;
	btnCreateSample.setBounds (x, y, w, h); y += h + gap;
	btnCreateNoise.setBounds (x, y, w, h); y += h + gap;
	btnCreateModular.setBounds (x, y, w, h); y += h + gap;
	btnLoadPreset.setBounds(x, y, w, h); y += h + gap;
	btnDestroy.setBounds (x, y, w, h); y += h + gap;
	btnDestroyRandom.setBounds (x, y, w, h); y += h + gap;
	btnDestroySelected.setBounds (x, y, w, h); y += h + gap;
	btnRandomPitch.setBounds (x, y, w, h); y += h + gap;
	btnRandomTime.setBounds (x, y, w, h); y += h + gap;
	btnResetFx.setBounds (x, y, w, h); y += h + gap;
	btnManualFx.setBounds (x, y, w, h); btnManualFx.setToggleState (true, juce::dontSendNotification); y += h + gap * 2;
    lEngine.setBounds (x, y, 70, h); comboEngine.setBounds (x + 75, y, w - 80, h); y += h + gap;

	lblGain.setBounds (x, y, 70, h); sliderGain.setBounds (x + 75, y, w - 80, h); y += h + gap;
	lblPan.setBounds (x, y, 70, h); sliderPan.setBounds (x + 75, y, w - 80, h); y += h + gap;
	btnChaos.setBounds (x, y, w, h); y += h + gap;
	lblStatus.setBounds (x, y, w, h); y += h + gap;
	lblDevice.setBounds (x, y, w, h); y += h + gap;
	lblVoices.setBounds (x, y, w, h); y += h + gap;
	lblPeak.setBounds (x, y, w, h); y += h + gap;

	// FX grid to the right with column wrap
	int gx = x + w + 20;
	int gy = 40;
	const int gw = 300;
	auto place = [&] (juce::Label& l, juce::Slider& s)
	{
		if (gy + h > getHeight() - 40)
		{
			gx += gw + 30;
			gy = 40;
		}
		l.setBounds (gx, gy, 100, h); s.setBounds (gx + 105, gy, gw - 110, h); gy += h + gap;
	};
	place (lFilterCutoff, sFilterCutoff);
	place (lFilterRes,    sFilterRes);
	place (lChRate,       sChRate);
	place (lChDepth,      sChDepth);
	place (lChMix,        sChMix);
	place (lPhRate,       sPhRate);
	place (lPhDepth,      sPhDepth);
	place (lPhCentre,     sPhCentre);
	place (lPhFb,         sPhFb);
	place (lPhMix,        sPhMix);
	place (lRvRoom,       sRvRoom);
	place (lRvDamp,       sRvDamp);
	place (lRvWidth,      sRvWidth);
	place (lRvMix,        sRvMix);
	place (lDlTime,       sDlTime);
	place (lDlFb,         sDlFb);
	place (lDlMix,        sDlMix);
	place (lCpThresh,     sCpThresh);
	place (lCpRatio,      sCpRatio);
	place (lCpAtk,        sCpAtk);
	place (lCpRel,        sCpRel);
	place (lCpMake,       sCpMake);
	place (lLmThresh,     sLmThresh);
	place (lLmRel,        sLmRel);
	place (lDrAmt,        sDrAmt);
	place (lDrMix,        sDrMix);
	place (lGtThresh,     sGtThresh);
	place (lGtAtk,        sGtAtk);
	place (lGtRel,        sGtRel);
	place (lTsRatio,      sTsRatio);
	place (lPtSemis,      sPtSemis);
	place (lPtRatio,      sPtRatio);

	int rightX = gx + gw + 30;
	int panelAreaW = getWidth() - (rightX + 40);
	int panelW = juce::jmin (500, panelAreaW / 2);
	int voicesW = juce::jmin (500, panelAreaW - panelW - 20);
	int totalH = getHeight() - 60;
	int dirsH = totalH / 2;
	int samH  = totalH - dirsH - 10;
	listDirs.setBounds (rightX, 40, panelW, dirsH);
	listSamples.setBounds (rightX, 40 + dirsH + 10, panelW, samH);
	listVoices.setBounds (rightX + panelW + 20, 40, voicesW, totalH);
	logView.setBounds (rightX + panelW + 20 + voicesW + 20, 40, getWidth() - (rightX + panelW + 20 + voicesW + 30), getHeight() - 50);
}

void TestHarnessComponent::comboBoxChanged (juce::ComboBox* c)
{
    if (c != &comboEngine) return;
    if (!audioEngine || controlledVoiceId == 0) return;
    // Send engine selection as a dedicated Update param understood by SampleVoiceProcessor via APVTS
    Command cmd; cmd.type = Command::Type::Update; cmd.voiceId = controlledVoiceId;
    cmd.paramName = "engine"; // mirrored by SampleLoader in Preset Creator
    cmd.paramValue = (float) (comboEngine.getSelectedId() == 2 ? 1.0f : 0.0f); // 0=RB, 1=Naive
    audioEngine->getCommandBus().enqueueLatest (cmd);
    OnScreenLogger::log ("[UI] Engine set to: " + comboEngine.getText());
}

void TestHarnessComponent::buttonClicked (juce::Button* b)
{
    // Ensure the engine is connected before sending any commands
    if (audioEngine == nullptr) {
        OnScreenLogger::log("[UI] ERROR: No AudioEngine connected!");
        return;
    }

    // --- Create Logic ---
    if (b == &btnCreateSynth || b == &btnCreateSample || b == &btnCreateNoise || b == &btnCreateModular)
    {
        Command cmd;
        cmd.type = Command::Type::Create;
        cmd.voiceId = juce::Time::getMillisecondCounterHiRes();

        if (b == &btnCreateSynth) {
            cmd.voiceType = "synth";
            OnScreenLogger::log("[UI] Sending CREATE command for Synth voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateNoise) {
            cmd.voiceType = "noise";
            OnScreenLogger::log("[UI] Sending CREATE command for Noise voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateModular) {
            cmd.voiceType = "modular";
            OnScreenLogger::log("[UI] Sending CREATE command for Modular voice...");
            audioEngine->getCommandBus().enqueue(cmd);
        }
        else if (b == &btnCreateSample) {
            if (selectedSampleIndex >= 0 && selectedSampleIndex < samplePaths.size()) {
                cmd.voiceType = "sample";
                cmd.resourceName = samplePaths[(int)selectedSampleIndex].getFullPathName();
                OnScreenLogger::log("[UI] Sending CREATE command for Sample voice: " + cmd.resourceName);
                audioEngine->getCommandBus().enqueue(cmd);
            } else {
                OnScreenLogger::log("[UI] No sample selected. Cannot create sample voice.");
            }
        }
    }
    // --- Load Preset for Modular ---
    else if (b == &btnLoadPreset)
    {
        // 1. Check if a voice is selected.
        if (controlledVoiceId == 0)
        {
            OnScreenLogger::log("[UI] ERROR: No voice selected to load preset into.");
            return;
        }

        // 2. Verify that the selected voice is a Modular voice.
        bool isModular = false;
        for (const auto& voiceInfo : engineVoices)
        {
            if (voiceInfo.voiceId == controlledVoiceId && voiceInfo.voiceType == "Modular")
            {
                isModular = true;
                break;
            }
        }

        if (!isModular)
        {
            OnScreenLogger::log("[UI] ERROR: The selected voice is not a Modular Synth.");
            return;
        }

        // 3. Launch the file chooser.
        loadChooser = std::make_unique<juce::FileChooser>("Load Modular Preset", juce::File{}, "*.xml");
        auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

        loadChooser->launchAsync(chooserFlags, [this](const juce::FileChooser& fc)
        {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                // 4. Read file content and create the command.
                Command cmd;
                cmd.type = Command::Type::LoadPreset;
                cmd.voiceId = controlledVoiceId;
                cmd.presetData = f.loadFileAsString();

                // 5. Send the command to the engine.
                if (audioEngine)
                {
                    audioEngine->getCommandBus().enqueue(cmd);
                    OnScreenLogger::log("[UI] Sent LoadPreset command for voice " + juce::String((juce::int64)controlledVoiceId));
                }
            }
        });
    }

    // --- Destroy Logic ---
    else if (b == &btnDestroySelected || b == &btnDestroy) // Treat "Destroy" and "Destroy Selected" as the same action
    {
        if (controlledVoiceId != 0) {
            Command cmd;
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = controlledVoiceId;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI] Sending DESTROY command for selected voice ID: " + juce::String((juce::int64)controlledVoiceId));
            controlledVoiceId = 0; // De-select the voice since it's being deleted
        } else {
            OnScreenLogger::log("[UI] No voice selected to destroy.");
        }
    }
    // --- Audio Settings Dialog ---
    else if (b == &btnAudioSettings)
    {
        if (audioSetupComp == nullptr)
        {
            audioSetupComp = std::make_unique<juce::AudioDeviceSelectorComponent>(
                deviceManager,
                0, 256,   // min/max inputs
                0, 256,   // min/max outputs
                true, false, false, false);
        }
        audioSetupComp->setSize(500, 450);
        juce::DialogWindow::LaunchOptions o;
        o.content.setOwned(audioSetupComp.get());
        o.content.get()->setSize(500, 450);
        o.dialogTitle = "Audio Settings";
        o.dialogBackgroundColour = juce::Colours::darkgrey;
        o.escapeKeyTriggersCloseButton = true;
        o.resizable = false;
        o.launchAsync();
    }
    else if (b == &btnDestroyRandom)
    {
        if (!engineVoices.empty()) {
            auto& rng = juce::Random::getSystemRandom();
            const int index = rng.nextInt((int)engineVoices.size());
            const juce::uint64 idToDestroy = engineVoices[index].voiceId;
            
            Command cmd;
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = idToDestroy;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI] Sending DESTROY command for random voice ID: " + juce::String((juce::int64)idToDestroy));
            
            if (controlledVoiceId == idToDestroy) {
                controlledVoiceId = 0; // De-select if it was the one deleted
            }
        } else {
            OnScreenLogger::log("[UI] No voices to destroy at random.");
        }
    }
    else
    {
        OnScreenLogger::log("[UI] Button '" + b->getButtonText() + "' is not yet wired to the AudioEngine.");
    }
}

void TestHarnessComponent::sliderValueChanged (juce::Slider* s)
{
    if (isSyncingSliders) return;
    // Ensure the engine is connected before sending any commands
    if (audioEngine == nullptr) {
        OnScreenLogger::log("[UI] ERROR: No AudioEngine connected!");
        return;
    }

    // Create a lambda for sending update commands
    auto set = [this] (const char* id, double v)
    {
        OnScreenLogger::log("[UI LOG] Slider for '" + juce::String(id) + "' was moved.");
        
        if (audioEngine && controlledVoiceId != 0)
        {
            Command cmd;
            cmd.type = Command::Type::Update;
            cmd.voiceId = controlledVoiceId;
            cmd.paramName = id;
            cmd.paramValue = (float)v;
            audioEngine->getCommandBus().enqueue(cmd);
            OnScreenLogger::log("[UI LOG] Sent UPDATE command for '" + juce::String(id) + "' to AudioEngine.");
        }
        else
        {
            OnScreenLogger::log("[UI LOG] ERROR: No voice selected!");
        }
    };

    if (s == &sliderGain)
    {
        set("gain", sliderGain.getValue());
    }
    else if (s == &sliderPan)
    {
        set("pan", sliderPan.getValue());
    }
    else if (btnManualFx.getToggleState())
    {
        if (s == &sFilterCutoff) set ("filterCutoff", s->getValue());
        else if (s == &sFilterRes) set ("filterResonance", s->getValue());
        else if (s == &sChRate) set ("chorusRate", s->getValue());
        else if (s == &sChDepth) set ("chorusDepth", s->getValue());
        else if (s == &sChMix) set ("chorusMix", s->getValue());
        else if (s == &sPhRate) set ("phaserRate", s->getValue());
        else if (s == &sPhDepth) set ("phaserDepth", s->getValue());
        else if (s == &sPhCentre) set ("phaserCentre", s->getValue());
        else if (s == &sPhFb) set ("phaserFeedback", s->getValue());
        else if (s == &sPhMix) set ("phaserMix", s->getValue());
        else if (s == &sRvRoom) set ("reverbRoom", s->getValue());
        else if (s == &sRvDamp) set ("reverbDamp", s->getValue());
        else if (s == &sRvWidth) set ("reverbWidth", s->getValue());
        else if (s == &sRvMix) set ("reverbMix", s->getValue());
        else if (s == &sDlTime) set ("delayTimeMs", s->getValue());
        else if (s == &sDlFb) set ("delayFeedback", s->getValue());
        else if (s == &sDlMix) set ("delayMix", s->getValue());
        else if (s == &sCpThresh) set ("compThreshold", s->getValue());
        else if (s == &sCpRatio) set ("compRatio", s->getValue());
        else if (s == &sCpAtk) set ("compAttackMs", s->getValue());
        else if (s == &sCpRel) set ("compReleaseMs", s->getValue());
        else if (s == &sCpMake) set ("compMakeup", s->getValue());
        else if (s == &sLmThresh) set ("limitThreshold", s->getValue());
        else if (s == &sLmRel) set ("limitReleaseMs", s->getValue());
        else if (s == &sDrAmt) set ("driveAmount", s->getValue());
        else if (s == &sDrMix) set ("driveMix", s->getValue());
        else if (s == &sGtThresh) set ("gateThreshold", s->getValue());
        else if (s == &sGtAtk) set ("gateAttackMs", s->getValue());
        else if (s == &sGtRel) set ("gateReleaseMs", s->getValue());
        else if (s == &sTsRatio) set ("timeStretchRatio", s->getValue());
        else if (s == &sPtSemis) set ("pitchSemitones", s->getValue());
        else if (s == &sPtRatio) set ("pitchRatio", s->getValue());
    }
}

// --- Sync Timer ---
void TestHarnessComponent::timerCallback()
{
    if (audioEngine)
    {
        auto currentEngineVoices = audioEngine->getActiveVoicesInfo();
        // Check if the list has changed before updating the UI to prevent flickering
        if (currentEngineVoices.size() != engineVoices.size()) // A simple check is enough for now
        {
            engineVoices.clear();
            for (const auto& voice : currentEngineVoices)
            {
                AudioEngine::VoiceInfo info;
                info.voiceId = voice.voiceId;
                info.voiceType = voice.voiceType;
                info.displayName = voice.displayName;
                engineVoices.push_back(info);
            }
            listVoices.updateContent();
            lblVoices.setText("Voices: " + juce::String((int)engineVoices.size()), juce::dontSendNotification);
        }
        
        // Update peak level display
        auto stats = audioEngine->getRuntimeStats();
        lblPeak.setText("Peak: " + juce::String(stats.lastPeak, 3), juce::dontSendNotification);
        
        // Update device info display
        lblDevice.setText("Device: " + juce::String(stats.sampleRate, 0) + "Hz, " + 
                         juce::String(stats.blockSize) + " samples", juce::dontSendNotification);
        
        // Route engine logs to UI
        auto engineLogs = audioEngine->drainLogs();
        for (const auto& log : engineLogs) {
            OnScreenLogger::log(log);
        }
    }
}

void TestHarnessComponent::refreshVoicesList()
{
    listVoices.updateContent();
}

void TestHarnessComponent::syncSlidersWithSelectedVoice()
{
    if (!audioEngine || controlledVoiceId == 0) return;

    isSyncingSliders = true;

    auto syncSlider = [&](juce::Slider& slider, const juce::String& paramId)
    {
        float value = audioEngine->getVoiceParameterValue(controlledVoiceId, paramId);
        slider.setValue(value, juce::dontSendNotification);
    };

    // Core & Time/Pitch
    syncSlider(sliderGain, "gain");
    syncSlider(sliderPan, "pan");
    syncSlider(sTsRatio, "timeStretchRatio");
    syncSlider(sPtSemis, "pitchSemitones");
    syncSlider(sPtRatio, "pitchRatio");

    // Filter
    syncSlider(sFilterCutoff, "filterCutoff");
    syncSlider(sFilterRes,    "filterResonance");

    // Chorus
    syncSlider(sChRate,  "chorusRate");
    syncSlider(sChDepth, "chorusDepth");
    syncSlider(sChMix,   "chorusMix");

    // Phaser
    syncSlider(sPhRate,   "phaserRate");
    syncSlider(sPhDepth,  "phaserDepth");
    syncSlider(sPhCentre, "phaserCentre");
    syncSlider(sPhFb,     "phaserFeedback");
    syncSlider(sPhMix,    "phaserMix");

    // Reverb
    syncSlider(sRvRoom,  "reverbRoom");
    syncSlider(sRvDamp,  "reverbDamp");
    syncSlider(sRvWidth, "reverbWidth");
    syncSlider(sRvMix,   "reverbMix");

    // Delay
    syncSlider(sDlTime, "delayTimeMs");
    syncSlider(sDlFb,   "delayFeedback");
    syncSlider(sDlMix,  "delayMix");

    // Compressor
    syncSlider(sCpThresh, "compThreshold");
    syncSlider(sCpRatio,  "compRatio");
    syncSlider(sCpAtk,    "compAttackMs");
    syncSlider(sCpRel,    "compReleaseMs");
    syncSlider(sCpMake,   "compMakeup");

    // Limiter
    syncSlider(sLmThresh, "limitThreshold");
    syncSlider(sLmRel,    "limitReleaseMs");

    // Drive
    syncSlider(sDrAmt, "driveAmount");
    syncSlider(sDrMix, "driveMix");

    // Gate
    syncSlider(sGtThresh, "gateThreshold");
    syncSlider(sGtAtk,    "gateAttackMs");
    syncSlider(sGtRel,    "gateReleaseMs");

    isSyncingSliders = false;
}

// --- Control Logic ---
void TestHarnessComponent::setControlledVoiceByIndex (int index)
{
    if (index >= 0 && index < (int)engineVoices.size())
    {
        controlledVoiceId = engineVoices[index].voiceId;
        OnScreenLogger::log("[UI] Selected voice ID: " + juce::String((juce::int64)controlledVoiceId));
        syncSlidersWithSelectedVoice(); // Sync UI with voice parameters
    }
    else
    {
        controlledVoiceId = 0;
    }
    lblStatus.setText("Controlling Voice ID: " + (controlledVoiceId != 0 ? juce::String((juce::int64)controlledVoiceId) : "-"), juce::dontSendNotification);
}



================================================================================
FILE: juce\Source\preset_creator\PresetManager.h
================================================================================


#pragma once
#include <juce_core/juce_core.h>
#include <vector>
#include <memory>

class PresetManager
{
public:
    struct PresetInfo
    {
        juce::String name;
        juce::File file;
        juce::String description;
        juce::StringArray tags;
    };

    struct DirectoryNode
    {
        juce::String name;
        juce::File directory;
        std::vector<PresetInfo> presets;
        std::vector<std::unique_ptr<DirectoryNode>> subdirectories;
    };

    PresetManager() : rootNode(std::make_unique<DirectoryNode>()) {}

    DirectoryNode* getRootNode() const { return rootNode.get(); }

    void scanDirectory(const juce::File& directory)
    {
        rootNode->name = directory.getFileName();
        rootNode->directory = directory;
        rootNode->presets.clear();
        rootNode->subdirectories.clear();
        scanRecursively(rootNode.get());
    }

    void clearCache()
    {
        rootNode = std::make_unique<DirectoryNode>();
    }

private:
    void scanRecursively(DirectoryNode* node)
    {
        if (!node->directory.isDirectory()) return;

        for (const auto& entry : juce::RangedDirectoryIterator(node->directory, false, "*", juce::File::findFilesAndDirectories))
        {
            const auto& file = entry.getFile();
            if (file.isDirectory())
            {
                auto subdir = std::make_unique<DirectoryNode>();
                subdir->name = file.getFileName();
                subdir->directory = file;
                scanRecursively(subdir.get());
                node->subdirectories.push_back(std::move(subdir));
            }
            else if (file.hasFileExtension(".xml"))
            {
                PresetInfo info;
                info.name = file.getFileNameWithoutExtension();
                info.file = file;
                if (auto xml = juce::parseXML(file))
                {
                    info.description = xml->getStringAttribute("description", "");
                    info.tags = juce::StringArray::fromTokens(xml->getStringAttribute("tags", ""), ",", "");
                }
                node->presets.push_back(info);
            }
        }
    }

    std::unique_ptr<DirectoryNode> rootNode;
};


================================================================================
FILE: juce\Source\preset_creator\PresetManager.cpp
================================================================================


#include "PresetManager.h"

PresetManager::PresetManager()
{
}

void PresetManager::scanDirectory(const juce::File& directory)
{
    if (!directory.exists() || !directory.isDirectory())
        return;
    
    // Find all .xml preset files
    juce::Array<juce::File> presetFiles;
    directory.findChildFiles(presetFiles, juce::File::findFiles, false, "*.xml");
    
    for (const auto& file : presetFiles)
    {
        PresetInfo info = extractMetadata(file);
        m_presets.push_back(info);
    }
    
    juce::Logger::writeToLog("[PresetManager] Scanned " + juce::String(m_presets.size()) + 
                            " presets from: " + directory.getFullPathName());
}

std::vector<PresetManager::PresetInfo> PresetManager::searchPresets(const juce::String& searchTerm) const
{
    std::vector<PresetInfo> results;
    
    for (const auto& preset : m_presets)
    {
        if (preset.matchesSearch(searchTerm))
            results.push_back(preset);
    }
    
    return results;
}

std::vector<PresetManager::PresetInfo> PresetManager::getPresetsByTag(const juce::String& tag) const
{
    std::vector<PresetInfo> results;
    
    for (const auto& preset : m_presets)
    {
        if (preset.tags.contains(tag))
            results.push_back(preset);
    }
    
    return results;
}

juce::StringArray PresetManager::getAllTags() const
{
    juce::StringArray allTags;
    
    for (const auto& preset : m_presets)
    {
        for (const auto& tag : preset.tags)
        {
            if (!allTags.contains(tag))
                allTags.add(tag);
        }
    }
    
    allTags.sort(true);
    return allTags;
}

juce::XmlElement* PresetManager::loadPreset(const juce::File& file)
{
    if (!file.exists())
        return nullptr;
    
    return juce::XmlDocument::parse(file).release();
}

bool PresetManager::savePreset(const juce::File& file, 
                               const juce::XmlElement& presetData,
                               const juce::String& description,
                               const juce::StringArray& tags)
{
    // Create a copy of the preset data and add metadata
    std::unique_ptr<juce::XmlElement> presetCopy(new juce::XmlElement(presetData));
    
    // Add metadata properties to the root element
    if (description.isNotEmpty())
        presetCopy->setAttribute("description", description);
    
    if (!tags.isEmpty())
        presetCopy->setAttribute("tags", tags.joinIntoString(","));
    
    // Write to file
    if (presetCopy->writeTo(file))
    {
        // Update cache
        PresetInfo info = extractMetadata(file);
        
        // Remove old entry if exists
        m_presets.erase(std::remove_if(m_presets.begin(), m_presets.end(),
            [&file](const PresetInfo& p) { return p.file == file; }), m_presets.end());
        
        // Add new entry
        m_presets.push_back(info);
        
        return true;
    }
    
    return false;
}

PresetManager::PresetInfo PresetManager::extractMetadata(const juce::File& file)
{
    PresetInfo info;
    info.file = file;
    info.name = file.getFileNameWithoutExtension();
    info.lastModified = file.getLastModificationTime();
    
    // Parse the XML to extract metadata
    std::unique_ptr<juce::XmlElement> xml = juce::XmlDocument::parse(file);
    
    if (xml != nullptr)
    {
        // Extract description
        info.description = xml->getStringAttribute("description", "");
        
        // Extract tags
        juce::String tagsStr = xml->getStringAttribute("tags", "");
        if (tagsStr.isNotEmpty())
        {
            info.tags.addTokens(tagsStr, ",", "");
            info.tags.trim();
        }
    }
    
    return info;
}



================================================================================
FILE: juce\Source\preset_creator\ControllerPresetManager.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <juce_data_structures/juce_data_structures.h>
#include <map>

// A global singleton to manage saving/loading MIDI controller mapping presets.
class ControllerPresetManager
{
public:
    // Defines the types of modules that can have controller presets.
    enum class ModuleType
    {
        Faders,
        Knobs,
        Buttons,
        JogWheel,
        StrokeSequencer
    };

    // Get the singleton instance of the manager.
    static ControllerPresetManager& get()
    {
        static ControllerPresetManager instance;
        return instance;
    }

    // Get the names of all saved presets for a specific module type.
    const juce::StringArray& getPresetNamesFor(ModuleType type) const;

    // Load a preset's data as a ValueTree.
    juce::ValueTree loadPreset(ModuleType type, const juce::String& presetName);

    // Save a ValueTree of mapping data to a preset file.
    bool savePreset(ModuleType type, const juce::String& presetName, const juce::ValueTree& dataToSave);

    // Delete a preset file.
    bool deletePreset(ModuleType type, const juce::String& presetName);

private:
    // Private constructor for singleton pattern.
    ControllerPresetManager();
    ~ControllerPresetManager() = default;

    // Helper to get the correct subdirectory for a module type.
    juce::File getDirectoryForType(ModuleType type);
    
    // Scans all subdirectories and populates the cache.
    void scanAllPresets();

    juce::File rootDirectory;
    std::map<ModuleType, juce::StringArray> presetCache;
    juce::StringArray emptyArray; // Used as a safe fallback
};



================================================================================
FILE: juce\Source\preset_creator\ControllerPresetManager.cpp
================================================================================


#include "ControllerPresetManager.h"

ControllerPresetManager::ControllerPresetManager()
{
    // 1. Find or create the root directory for all controller presets.
    rootDirectory = juce::File::getSpecialLocation(juce::File::currentApplicationFile)
                        .getParentDirectory().getChildFile("MidiControllerPresets");
    
    if (!rootDirectory.exists())
        rootDirectory.createDirectory();

    // 2. Ensure subdirectories exist for each module type.
    getDirectoryForType(ModuleType::Faders);
    getDirectoryForType(ModuleType::Knobs);
    getDirectoryForType(ModuleType::Buttons);
    getDirectoryForType(ModuleType::JogWheel);
    getDirectoryForType(ModuleType::StrokeSequencer);

    // 3. Perform an initial scan to populate the cache.
    scanAllPresets();
}

const juce::StringArray& ControllerPresetManager::getPresetNamesFor(ModuleType type) const
{
    auto it = presetCache.find(type);
    if (it != presetCache.end())
        return it->second;
    return emptyArray;
}

juce::ValueTree ControllerPresetManager::loadPreset(ModuleType type, const juce::String& presetName)
{
    juce::File presetFile = getDirectoryForType(type).getChildFile(presetName + ".xml");
    if (presetFile.existsAsFile())
    {
        if (auto xml = juce::XmlDocument::parse(presetFile))
        {
            return juce::ValueTree::fromXml(*xml);
        }
    }
    return {};
}

bool ControllerPresetManager::savePreset(ModuleType type, const juce::String& presetName, const juce::ValueTree& dataToSave)
{
    if (presetName.isEmpty())
        return false;

    juce::File presetFile = getDirectoryForType(type).getChildFile(presetName + ".xml");
    
    if (auto xml = dataToSave.createXml())
    {
        if (xml->writeTo(presetFile))
        {
            scanAllPresets(); // Re-scan to update the cache with the new file.
            return true;
        }
    }
    return false;
}

bool ControllerPresetManager::deletePreset(ModuleType type, const juce::String& presetName)
{
    juce::File presetFile = getDirectoryForType(type).getChildFile(presetName + ".xml");
    if (presetFile.deleteFile())
    {
        scanAllPresets(); // Re-scan to update the cache.
        return true;
    }
    return false;
}

juce::File ControllerPresetManager::getDirectoryForType(ModuleType type)
{
    juce::String subfolderName;
    switch (type)
    {
        case ModuleType::Faders:          subfolderName = "MidiFaders";       break;
        case ModuleType::Knobs:           subfolderName = "MidiKnobs";        break;
        case ModuleType::Buttons:         subfolderName = "MidiButtons";      break;
        case ModuleType::JogWheel:        subfolderName = "MidiJogWheel";     break;
        case ModuleType::StrokeSequencer: subfolderName = "StrokeSequencer";  break;
    }
    
    auto dir = rootDirectory.getChildFile(subfolderName);
    if (!dir.exists())
        dir.createDirectory();
        
    return dir;
}

void ControllerPresetManager::scanAllPresets()
{
    presetCache.clear();
    for (int i = 0; i <= (int)ModuleType::StrokeSequencer; ++i)
    {
        auto type = (ModuleType)i;
        auto dir = getDirectoryForType(type);
        
        // Find all .xml files and get them as juce::File objects
        juce::Array<juce::File> presetFiles;
        dir.findChildFiles(presetFiles, juce::File::findFiles, false, "*.xml");
        
        // Create a StringArray of just the filenames without the extension
        juce::StringArray names;
        for (const auto& file : presetFiles)
        {
            names.add(file.getFileNameWithoutExtension());
        }
            
        presetCache[type] = names;
    }
}



================================================================================
FILE: juce\Source\preset_creator\SavePresetJob.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <juce_data_structures/juce_data_structures.h>
#include <functional>

// This class is now self-contained and does not need forward declarations.

class SavePresetJob : public juce::ThreadPoolJob
{
public:
    // The job now takes the already-prepared state data by value.
    SavePresetJob(juce::MemoryBlock synthState, juce::ValueTree uiState, juce::File targetFile);

    juce::ThreadPoolJob::JobStatus runJob() override;

    std::function<void(const juce::File&, bool success)> onSaveComplete;

private:
    juce::MemoryBlock synthState;
    juce::ValueTree uiState;
    juce::File fileToSave;
};


================================================================================
FILE: juce\Source\preset_creator\SavePresetJob.cpp
================================================================================


#include "SavePresetJob.h"
#include <juce_events/juce_events.h> // For MessageManager

SavePresetJob::SavePresetJob(juce::MemoryBlock synthStateData, juce::ValueTree uiStateData, juce::File targetFile)
    : juce::ThreadPoolJob("Save Preset To Disk"), 
      synthState(std::move(synthStateData)), 
      uiState(std::move(uiStateData)), 
      fileToSave(std::move(targetFile))
{}

juce::ThreadPoolJob::JobStatus SavePresetJob::runJob()
{
    // This entire function runs safely on a background thread.
    // It has no access to the synth or editor, only the data it was given.
    
    auto xml = juce::XmlDocument::parse(synthState.toString());
    bool writeSuccess = false;

    if (xml)
    {
        auto presetVT = juce::ValueTree::fromXml(*xml);
        presetVT.addChild(uiState, -1, nullptr);
        
        // This is the only slow part, and it's safely on a background thread.
        writeSuccess = fileToSave.replaceWithText(presetVT.createXml()->toString());
    }

    // Signal completion back to the UI thread.
    juce::MessageManager::callAsync([this, success = writeSuccess]() {
        if (onSaveComplete) onSaveComplete(fileToSave, success);
    });
    
    return juce::ThreadPoolJob::jobHasFinished;
}


================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include "../audio/graph/ModularSynthProcessor.h"
#include "../audio/MidiDeviceManager.h"

class PresetCreatorComponent : public juce::Component,
                               private juce::Button::Listener,
                               private juce::Timer
{
public:
    PresetCreatorComponent(juce::AudioDeviceManager& deviceManager,
                           juce::AudioPluginFormatManager& formatManager,
                           juce::KnownPluginList& knownPluginList);
    ~PresetCreatorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    
    // Unified playback control (audio engine + transport)
    void setMasterPlayState(bool shouldBePlaying);
    
    bool keyPressed (const juce::KeyPress& key) override;
    bool keyStateChanged (bool isKeyDown) override;
    void visibilityChanged() override;

    // ADD: Public function to show audio settings dialog
    void showAudioSettingsDialog();
    
    // Get MIDI activity indicator state
    int getMidiActivityFrames() const { return midiActivityFrames; }
    
    // Multi-MIDI device manager (public for access from ImGuiNodeEditorComponent)
    std::unique_ptr<MidiDeviceManager> midiDeviceManager;

private:
    int midiActivityFrames = 0; // For MIDI activity indicator

    void setWindowFileName(const juce::String& fileName);
    void buttonClicked (juce::Button*) override;
    void timerCallback() override;
    void refreshModulesList();
    void doConnect();
    void doSave();
    void doLoad();
    void startAudition();
    void stopAudition();

    juce::TextButton btnAddVCO { "Add VCO" };
    juce::TextButton btnAddVCF { "Add VCF" };
    juce::TextButton btnAddVCA { "Add VCA" };
    juce::TextButton btnConnect { "Connect" };
    juce::TextButton btnSave { "Save Preset" };
    juce::TextButton btnLoad { "Load Preset" };

    juce::ListBox listModules { "Modules", nullptr };
    struct ModulesModel : public juce::ListBoxModel
    {
        juce::StringArray rows;
        int getNumRows() override { return rows.size(); }
        void paintListBoxItem (int row, juce::Graphics& g, int w, int h, bool sel) override
        {
            g.fillAll (sel ? juce::Colours::dimgrey : juce::Colours::transparentBlack);
            g.setColour (juce::Colours::white);
            if (row >= 0 && row < rows.size()) g.drawText (rows[row], 6, 0, w - 12, h, juce::Justification::centredLeft);
        }
    } modulesModel;

    juce::ComboBox cbSrc, cbDst, cbSrcChan, cbDstChan;
    juce::TextEditor log;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<class ImGuiNodeEditorComponent> editor;

    std::unique_ptr<ModularSynthProcessor> synth;
    double sampleRate { 48000.0 };
    int blockSize { 512 };

    std::unique_ptr<juce::FileChooser> saveChooser;
    std::unique_ptr<juce::FileChooser> loadChooser;

    // Unified spacebar control (toggle and momentary gate mode)
    juce::uint64 spacebarDownTime { 0 };
    bool wasLongPress { false };
    static constexpr int longPressThresholdMs = 250;

    juce::AudioDeviceManager& deviceManager;
    juce::AudioPluginFormatManager& pluginFormatManager;
    juce::KnownPluginList& knownPluginList;
    juce::AudioProcessorPlayer processorPlayer;
    bool auditioning { false };
};




================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.cpp
================================================================================


// RtLogger flush integrated via timer in component
#include "PresetCreatorComponent.h"
#include "ImGuiNodeEditorComponent.h"
#include "../utils/RtLogger.h"

PresetCreatorComponent::PresetCreatorComponent(juce::AudioDeviceManager& adm,
                                               juce::AudioPluginFormatManager& fm,
                                               juce::KnownPluginList& kl)
    : deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("PresetCreatorComponent constructor starting...");
    addAndMakeVisible (log);

    // Replace list/combos UI with ImGui node editor
    juce::Logger::writeToLog("Attempting to create ImGuiNodeEditorComponent...");
    editor.reset (new ImGuiNodeEditorComponent(deviceManager));
    juce::Logger::writeToLog("ImGuiNodeEditorComponent created.");
    editor->onShowAudioSettings = [this]() { this->showAudioSettingsDialog(); };
    addAndMakeVisible (editor.get());
    log.setMultiLine (true); log.setReadOnly (true);

    juce::Logger::writeToLog("Creating ModularSynthProcessor...");
    synth = std::make_unique<ModularSynthProcessor>();
    
    // --- THIS IS THE FIX ---
    // Set the managers immediately so the synth is ready for state restoration.
    synth->setPluginFormatManager(&pluginFormatManager);
    synth->setKnownPluginList(&knownPluginList);
    juce::Logger::writeToLog("Plugin managers set on ModularSynthProcessor.");
    // --- END OF FIX ---
    
    juce::Logger::writeToLog("Setting model on editor...");
    if (editor != nullptr)
    {
        editor->setModel (synth.get());
    }
    synth->prepareToPlay (sampleRate, blockSize);

    // Use the shared AudioDeviceManager settings
    if (auto* dev = deviceManager.getCurrentAudioDevice())
    {
        sampleRate = dev->getCurrentSampleRate();
        blockSize = dev->getCurrentBufferSizeSamples();
        synth->prepareToPlay (sampleRate, blockSize);
        juce::Logger::writeToLog ("Audio device: " + dev->getName() +
                                   ", sr=" + juce::String (sampleRate) +
                                   ", bs=" + juce::String (blockSize));
    }
    // AudioProcessorPlayer lives in juce_audio_utils namespace path include; type is juce::AudioSourcePlayer for routing
    // Use AudioProcessorPlayer via juce_audio_utils module
    processorPlayer.setProcessor (synth.get());
    
    // --- MULTI-MIDI DEVICE SUPPORT ---
    // Initialize multi-device MIDI manager
    midiDeviceManager = std::make_unique<MidiDeviceManager>(deviceManager);
    midiDeviceManager->scanDevices();
    midiDeviceManager->enableAllDevices();  // Enable all MIDI devices by default
    juce::Logger::writeToLog("[MIDI] Multi-device manager initialized");
    // Note: MidiDeviceManager now handles all MIDI input callbacks
    // The processorPlayer will receive MIDI through ModularSynthProcessor's processBlock
    // --- END MULTI-MIDI SUPPORT ---
    
    // === CRITICAL FIX: Audio callback must ALWAYS be active for MIDI processing ===
    // Without this, processBlock never runs and MIDI learn doesn't work!
    deviceManager.addAudioCallback(&processorPlayer);
    auditioning = true;  // Set flag to indicate audio is active
    juce::Logger::writeToLog("[Audio] Audio callback started - synth is now processing");
    // === END FIX ===
    
    setWantsKeyboardFocus (true);

    // Setup FileLogger at the same path the user checks: <exe>/juce/logs/preset_creator_*.log
    {
        auto exeDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory();
        auto juceLogsDir = exeDir.getChildFile ("juce").getChildFile ("logs");
        juceLogsDir.createDirectory();
        auto logName = juce::String ("preset_creator_") + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log";
        auto logFile = juceLogsDir.getChildFile (logName);
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 10 * 1024 * 1024);
        if (fileLogger != nullptr)
            juce::Logger::setCurrentLogger (fileLogger.get());
        juce::Logger::writeToLog ("PresetCreator log file: " + logFile.getFullPathName());
    }
    // Init RT logger and start periodic flush
    RtLogger::init (2048, 256);
    
    // NOTE: Audio Settings button removed - now using menu integration
    
    juce::Logger::writeToLog ("PresetCreator constructed");
    startTimerHz (30);
    
    setWindowFileName({}); // Set the default title on startup
}

// ADD: Implementation of the audio settings dialog function
void PresetCreatorComponent::showAudioSettingsDialog()
{
    auto* component = new juce::AudioDeviceSelectorComponent(
        deviceManager, 0, 256, 0, 256, true, true, false, false);
    
    component->setSize(500, 450);

    juce::DialogWindow::LaunchOptions o;
    o.content.setOwned(component);
    o.dialogTitle                   = "Audio Settings";
    o.dialogBackgroundColour        = juce::Colours::darkgrey;
    o.escapeKeyTriggersCloseButton  = true;
    o.resizable                     = false;
    o.launchAsync();
}

void PresetCreatorComponent::setWindowFileName(const juce::String& fileName)
{
    // Find the parent window of this component
    if (auto* window = findParentComponentOfClass<juce::DocumentWindow>())
    {
        juce::String newTitle = "Preset Creator"; // The default title
        if (fileName.isNotEmpty())
        {
            newTitle += " - " + fileName; // Append the filename if one is provided
        }
        window->setName(newTitle);
    }
}

void PresetCreatorComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void PresetCreatorComponent::resized()
{
    for (auto* c : getChildren())
        if (dynamic_cast<ImGuiNodeEditorComponent*>(c) != nullptr)
            c->setBounds (0, 0, getWidth(), getHeight());
    
    // Audio Settings button removed - now using menu integration
    
    // Keep log overlay minimal for now
    log.setBounds (10, getHeight() - 160, getWidth() - 20, 150);
}

void PresetCreatorComponent::setMasterPlayState(bool shouldBePlaying)
{
    if (synth == nullptr)
        return;

    // 1. Control the Audio Engine (start/stop pulling audio)
    if (shouldBePlaying)
    {
        if (!auditioning)
        {
            deviceManager.addAudioCallback(&processorPlayer);
            auditioning = true;
        }
    }
    else
    {
        if (auditioning)
        {
            deviceManager.removeAudioCallback(&processorPlayer);
            auditioning = false;
        }
    }

    // 2. Control the synth's internal transport clock
    synth->setPlaying(shouldBePlaying);
}

PresetCreatorComponent::~PresetCreatorComponent()
{
    // MULTI-MIDI SUPPORT: MidiDeviceManager handles cleanup automatically in its destructor
    midiDeviceManager.reset();

    stopAudition();
    processorPlayer.setProcessor (nullptr);
    juce::Logger::writeToLog ("PresetCreator destroyed");
    RtLogger::shutdown();
    juce::Logger::setCurrentLogger (nullptr);
}

void PresetCreatorComponent::buttonClicked (juce::Button* b)
{
    if (b == &btnAddVCO) { synth->addModule ("VCO"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCF) { synth->addModule ("VCF"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCA) { synth->addModule ("VCA"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnConnect) { doConnect(); }
    else if (b == &btnSave) { doSave(); }
    else if (b == &btnLoad) { doLoad(); }
}

void PresetCreatorComponent::refreshModulesList()
{
    modulesModel.rows.clear();
    cbSrc.clear(); cbDst.clear();
    int idx = 1;
    for (auto [logicalId, type] : synth->getModulesInfo())
    {
        modulesModel.rows.add (juce::String ((int) logicalId) + " - " + type);
        cbSrc.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        cbDst.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        ++idx;
    }
    cbDst.addItem ("Output", 9999);
    listModules.updateContent();
}

void PresetCreatorComponent::doConnect()
{
    int selSrc = cbSrc.getSelectedId();
    int selDst = cbDst.getSelectedId();
    if (selSrc <= 0 || selDst <= 0) { log.insertTextAtCaret ("Select src/dst first\n"); return; }

    // Extract logical IDs from combo texts
    auto parseId = [] (const juce::String& s) -> juce::uint32 { return (juce::uint32) s.upToFirstOccurrenceOf(" ", false, false).getIntValue(); };
    juce::uint32 srcLogical = parseId (cbSrc.getText());
    juce::uint32 dstLogical = parseId (cbDst.getText());

    auto srcNode = synth->getNodeIdForLogical (srcLogical);
    juce::AudioProcessorGraph::NodeID dstNode;
    if (cbDst.getSelectedId() == 9999)
        dstNode = synth->getOutputNodeID();
    else
        dstNode = synth->getNodeIdForLogical (dstLogical);
    const int srcChan = cbSrcChan.getSelectedId() - 1;
    const int dstChan = cbDstChan.getSelectedId() - 1;
    if (srcNode.uid != 0 && dstNode.uid != 0)
    {
        if (synth->connect (srcNode, srcChan, dstNode, dstChan))
        {
            log.insertTextAtCaret ("Connected\n");
            synth->commitChanges();
        }
        else
        {
            log.insertTextAtCaret ("Connect failed\n");
        }
    }
}

void PresetCreatorComponent::doSave()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", startDir, "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.exists() || f.getParentDirectory().exists())
        {
            // Ensure directory exists when saving into default folder
            f.getParentDirectory().createDirectory();
            
            // --- FIX: Temporarily unmute nodes to save original connections ---
            // When nodes are muted, their connections are replaced with bypass routing.
            // We must save the ORIGINAL connections, not the bypass connections.
            
            // 1. Get a list of all currently muted nodes from the editor
            std::vector<juce::uint32> currentlyMutedNodes;
            if (editor)
            {
                for (const auto& pair : editor->mutedNodeStates)
                {
                    currentlyMutedNodes.push_back(pair.first);
                }
                
                // 2. Temporarily UNMUTE all of them to restore the original connections
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->unmuteNode(lid);
                }
            }
            
            // 3. CRITICAL: Force the synth to apply these connection changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // At this point, the synth graph is in its "true", unmuted state
            
            // 4. NOW get the state - this will save the correct, original connections
            juce::MemoryBlock mb;
            synth->getStateInformation (mb);
            auto xml = juce::XmlDocument::parse (mb.toString());
            if (! xml) return;
            
            // 5. IMMEDIATELY RE-MUTE the nodes to return the editor to its visible state
            if (editor)
            {
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->muteNode(lid);
                }
            }
            
            // 6. CRITICAL: Force the synth to apply the re-mute changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // The synth graph is now back to its bypassed state for audio processing
            // --- END OF FIX ---
            
            juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
            // Attach UI state as child (which correctly contains the "muted" flags)
            if (editor)
            {
                juce::ValueTree ui = editor->getUiValueTree();
                presetVT.addChild (ui, -1, nullptr);
            }
            // Write
            f.replaceWithText (presetVT.createXml()->toString());
            log.insertTextAtCaret ("Saved: " + f.getFullPathName() + "\n");
            
            setWindowFileName(f.getFileName()); // Update title bar with filename
        }
    });
}

void PresetCreatorComponent::doLoad()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", startDir, "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData (mb);
                // First set the synth state
                synth->setStateInformation (mb.getData(), (int) mb.getSize());
                // Then parse and queue UI state for next frame (ensures editor exists and nodes are created)
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse (mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml (*xml);
                        auto ui = vt.getChildWithName ("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow (ui);
                    }
                }
                refreshModulesList();
                log.insertTextAtCaret ("Loaded: " + f.getFullPathName() + "\n");
                
                setWindowFileName(f.getFileName()); // Update title bar with filename
            }
        } catch (...) {
            juce::Logger::writeToLog ("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}

bool PresetCreatorComponent::keyPressed (const juce::KeyPress& key)
{
    if (key.getKeyCode() == juce::KeyPress::spaceKey)
    {
        if (spacebarDownTime == 0) // Only record time on the initial press
        {
            spacebarDownTime = juce::Time::getMillisecondCounter();
            wasLongPress = false;
        }
        return true;
    }
    return false;
}

bool PresetCreatorComponent::keyStateChanged (bool isKeyDown)
{
    juce::ignoreUnused (isKeyDown);

    if (!juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
    {
        if (spacebarDownTime != 0) // Key was just released
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration < longPressThresholdMs && !wasLongPress)
            {
                // SHORT PRESS (TOGGLE)
                if (synth)
                {
                    const bool isCurrentlyPlaying = synth->getTransportState().isPlaying;
                    setMasterPlayState(!isCurrentlyPlaying); // Use the unified function
                }
            }
            // If it was a long press, the timer callback will handle stopping.
        }
        spacebarDownTime = 0; // Reset for next press
    }
    return false;
}

void PresetCreatorComponent::visibilityChanged()
{
    juce::Logger::writeToLog (juce::String ("Component visible? ") + (isShowing() ? "yes" : "no"));
}

void PresetCreatorComponent::startAudition()
{
    if (auditioning) return;
    deviceManager.addAudioCallback (&processorPlayer);
    auditioning = true;
    log.insertTextAtCaret ("[Audition] Start (hold space)\n");
}

void PresetCreatorComponent::stopAudition()
{
    if (! auditioning) return;
    deviceManager.removeAudioCallback (&processorPlayer);
    auditioning = false;
    log.insertTextAtCaret ("[Audition] Stop\n");
}

void PresetCreatorComponent::timerCallback()
{
    RtLogger::flushToFileLogger();
    
    // MULTI-MIDI SUPPORT: Transfer MIDI messages from MidiDeviceManager to ModularSynthProcessor
    if (midiDeviceManager && synth)
    {
        std::vector<MidiDeviceManager::MidiMessageWithSource> midiMessages;
        midiDeviceManager->swapMessageBuffer(midiMessages);
        
        if (!midiMessages.empty())
        {
            juce::Logger::writeToLog("[PresetCreator] Received " + juce::String(midiMessages.size()) + 
                                    " MIDI messages from MidiDeviceManager");
            
            // Convert to ModularSynthProcessor format
            std::vector<MidiMessageWithDevice> convertedMessages;
            convertedMessages.reserve(midiMessages.size());
            
            for (const auto& msg : midiMessages)
            {
                MidiMessageWithDevice converted;
                converted.message = msg.message;
                converted.deviceIdentifier = msg.deviceIdentifier;
                converted.deviceName = msg.deviceName;
                converted.deviceIndex = msg.deviceIndex;
                convertedMessages.push_back(converted);
            }
            
            juce::Logger::writeToLog("[PresetCreator] Passing " + juce::String(convertedMessages.size()) + 
                                    " messages to ModularSynthProcessor");
            
            // Pass to synth for distribution to modules
            synth->processMidiWithDeviceInfo(convertedMessages);
        }
    }
    
    // Check for MIDI activity from the synth
    if (synth != nullptr && synth->hasMidiActivity())
        midiActivityFrames = 30;
    
    // Update MIDI activity indicator in editor
    if (editor != nullptr)
        editor->setMidiActivityFrames(midiActivityFrames);
    
    if (synth != nullptr)
    {
        // Check for long press activation
        if (spacebarDownTime != 0 && !wasLongPress)
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration >= longPressThresholdMs)
            {
                wasLongPress = true;
                setMasterPlayState(true); // Use the unified function
            }
        }
        
        // Check for long press release
        if (wasLongPress && !juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
        {
            setMasterPlayState(false); // Use the unified function
            wasLongPress = false;
            spacebarDownTime = 0;
        }
    }

    static int counter = 0;
    if ((++counter % 60) == 0)
        juce::Logger::writeToLog ("[Heartbeat] UI alive");
}


================================================================================
FILE: juce\Source\preset_creator\PresetCreatorApplication.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <juce_audio_processors/juce_audio_processors.h>

class PresetCreatorApplication : public juce::JUCEApplication
{
public:
    const juce::String getApplicationName() override { return "Preset Creator"; }
    const juce::String getApplicationVersion() override { return "0.1.0"; }
    
    // Accessors for shared components
    juce::AudioDeviceManager& getAudioDeviceManager() { return audioDeviceManager; }
    juce::AudioPluginFormatManager& getPluginFormatManager() { return pluginFormatManager; }
    juce::KnownPluginList& getKnownPluginList() { return knownPluginList; }
    
    // Static getter for global access
    static PresetCreatorApplication& getApp()
    {
        return *dynamic_cast<PresetCreatorApplication*>(juce::JUCEApplication::getInstance());
    }
    
    juce::PropertiesFile* getProperties() { return appProperties.get(); }
    
    void initialise(const juce::String&) override;
    void shutdown() override;

    class MainWindow : public juce::DocumentWindow
    {
    public:
        MainWindow(juce::String name, 
                   juce::AudioDeviceManager& adm,
                   juce::AudioPluginFormatManager& fm,
                   juce::KnownPluginList& kl);
        void closeButtonPressed() override { juce::JUCEApplication::getInstance()->systemRequestedQuit(); }
        
    private:
        juce::AudioDeviceManager& deviceManager;
        juce::AudioPluginFormatManager& pluginFormatManager;
        juce::KnownPluginList& knownPluginList;
    };

private:
    // Shared components for the entire application
    juce::AudioDeviceManager audioDeviceManager;
    juce::AudioPluginFormatManager pluginFormatManager;
    juce::KnownPluginList knownPluginList;
    juce::File pluginScanListFile;
    
    std::unique_ptr<MainWindow> mainWindow;
    std::unique_ptr<juce::FileLogger> fileLogger;
    std::unique_ptr<juce::PropertiesFile> appProperties;
};



================================================================================
FILE: juce\Source\preset_creator\PresetCreatorMain.cpp
================================================================================


#include "PresetCreatorApplication.h"
#include "PresetCreatorComponent.h"
#include "../utils/RtLogger.h"

void PresetCreatorApplication::initialise(const juce::String&)
    {
        DBG("[PresetCreator] initialise() starting"); RtLogger::init();
        // Crash handler to capture unexpected exceptions
        std::set_terminate([]{
            auto bt = juce::SystemStats::getStackBacktrace();
            juce::Logger::writeToLog("[PresetCreator][FATAL] terminate called. Backtrace:\n" + bt);
            std::abort();
        });
        // Set up file logger for diagnostics
        auto logsDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile)
                           .getParentDirectory().getChildFile ("juce").getChildFile ("logs");
        logsDir.createDirectory();
        auto logFile = logsDir.getChildFile ("preset_creator_" + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log");
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 0);
        juce::Logger::setCurrentLogger (fileLogger.get());
        DBG("[PresetCreator] Logger initialised at: " + logFile.getFullPathName());
        juce::Logger::writeToLog("PresetCreatorApplication::initialise called");
        
        // ADD: Load persistent audio settings
        // Define where to store the settings file
        auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                .getChildFile(getApplicationName());
        appDataDir.createDirectory(); // Ensure the directory exists
        auto settingsFile = appDataDir.getChildFile("audio_settings.xml");

        std::unique_ptr<juce::XmlElement> savedState;
        if (settingsFile.existsAsFile())
        {
            savedState = juce::XmlDocument::parse(settingsFile);
            juce::Logger::writeToLog("Loading audio settings from: " + settingsFile.getFullPathName());
        }
        else
        {
            juce::Logger::writeToLog("No saved audio settings found, using defaults");
        }
        
        // Pass the saved state to the device manager.
        // It will automatically use the saved settings or fall back to defaults.
        audioDeviceManager.initialise(2, 2, savedState.get(), true);
        
        // Initialize plugin management
        pluginFormatManager.addDefaultFormats();
        
        // Initialize application properties
        juce::PropertiesFile::Options options;
        options.applicationName = getApplicationName();
        options.filenameSuffix = ".settings";
        options.osxLibrarySubFolder = "Application Support";
        options.folderName = appDataDir.getFullPathName();
        appProperties = std::make_unique<juce::PropertiesFile>(options);
        
        // Define where to save the plugin list XML
        auto deadMansPedalFile = appDataDir.getChildFile("blacklisted_plugins.txt");
        pluginScanListFile = appDataDir.getChildFile("known_plugins.xml");
        
        // Load the list from the XML file
        if (pluginScanListFile.existsAsFile())
        {
            auto pluginListXml = juce::XmlDocument::parse(pluginScanListFile);
            if (pluginListXml != nullptr)
            {
                knownPluginList.recreateFromXml(*pluginListXml);
                juce::Logger::writeToLog("Loaded " + juce::String(knownPluginList.getNumTypes()) + " plugin(s) from cache");
            }
        }
        else
        {
            juce::Logger::writeToLog("No cached plugin list found");
        }
        
        juce::Logger::writeToLog("Attempting to create MainWindow...");
        mainWindow.reset (new MainWindow (getApplicationName(), 
                                         audioDeviceManager,
                                         pluginFormatManager,
                                         knownPluginList));
        juce::Logger::writeToLog("MainWindow created successfully");
}

void PresetCreatorApplication::shutdown()
{ 
        // Save persistent audio settings
        std::unique_ptr<juce::XmlElement> currentState(audioDeviceManager.createStateXml());

        if (currentState != nullptr)
        {
            // Define the same settings file path as in initialise()
            auto appDataDir = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
                                    .getChildFile(getApplicationName());
            auto settingsFile = appDataDir.getChildFile("audio_settings.xml");

            // Write the XML to the file
            if (currentState->writeTo(settingsFile))
            {
                juce::Logger::writeToLog("Audio settings saved to: " + settingsFile.getFullPathName());
            }
            else
            {
                juce::Logger::writeToLog("Failed to save audio settings to: " + settingsFile.getFullPathName());
            }
        }
        
        // Save plugin list
        if (auto pluginListXml = knownPluginList.createXml())
        {
            if (pluginListXml->writeTo(pluginScanListFile))
            {
                juce::Logger::writeToLog("Plugin list saved to: " + pluginScanListFile.getFullPathName());
            }
        }
        
        // Save application properties
        if (appProperties)
            appProperties->saveIfNeeded();
        
        RtLogger::shutdown(); 
        mainWindow = nullptr; 
        juce::Logger::setCurrentLogger (nullptr); 
        fileLogger = nullptr; 
}

PresetCreatorApplication::MainWindow::MainWindow(juce::String name, 
                                                 juce::AudioDeviceManager& adm,
                                                 juce::AudioPluginFormatManager& fm,
                                                 juce::KnownPluginList& kl)
    : DocumentWindow(name,
                     juce::Desktop::getInstance().getDefaultLookAndFeel()
                         .findColour(ResizableWindow::backgroundColourId),
                     DocumentWindow::allButtons),
      deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("MainWindow constructor starting...");
    setUsingNativeTitleBar(true);
    juce::Logger::writeToLog("Attempting to create PresetCreatorComponent...");
    setContentOwned(new PresetCreatorComponent(deviceManager, pluginFormatManager, knownPluginList), true);
    juce::Logger::writeToLog("PresetCreatorComponent created and set.");
    centreWithSize(2600, 1080);
    setVisible(true);
    toFront(true);
    juce::Logger::writeToLog("MainWindow setup complete");
}

START_JUCE_APPLICATION (PresetCreatorApplication)




================================================================================
FILE: juce\Source\preset_creator\SampleManager.h
================================================================================


#pragma once
#include <juce_core/juce_core.h>
#include <juce_audio_formats/juce_audio_formats.h>
#include <vector>
#include <memory>

class SampleManager
{
public:
    struct SampleInfo
    {
        juce::String name;
        juce::File file;
        double durationSeconds;
        int sampleRate;
        int numChannels;
    };

    struct DirectoryNode
    {
        juce::String name;
        juce::File directory;
        std::vector<SampleInfo> samples;
        std::vector<std::unique_ptr<DirectoryNode>> subdirectories;
    };

    SampleManager() : rootNode(std::make_unique<DirectoryNode>())
    {
        formatManager.registerBasicFormats();
    }

    DirectoryNode* getRootNode() const { return rootNode.get(); }

    void scanDirectory(const juce::File& directory)
    {
        rootNode->name = directory.getFileName();
        rootNode->directory = directory;
        rootNode->samples.clear();
        rootNode->subdirectories.clear();
        scanRecursively(rootNode.get());
    }

    void clearCache()
    {
        rootNode = std::make_unique<DirectoryNode>();
    }

private:
    void scanRecursively(DirectoryNode* node)
    {
        if (!node->directory.isDirectory()) return;

        for (const auto& entry : juce::RangedDirectoryIterator(node->directory, false, "*", juce::File::findFilesAndDirectories))
        {
            const auto& file = entry.getFile();
            if (file.isDirectory())
            {
                auto subdir = std::make_unique<DirectoryNode>();
                subdir->name = file.getFileName();
                subdir->directory = file;
                scanRecursively(subdir.get());
                node->subdirectories.push_back(std::move(subdir));
            }
            else if (file.hasFileExtension(".wav") || file.hasFileExtension(".aif") || file.hasFileExtension(".flac") || file.hasFileExtension(".mp3") || file.hasFileExtension(".ogg"))
            {
                SampleInfo info;
                info.name = file.getFileNameWithoutExtension();
                info.file = file;
                if (auto* reader = formatManager.createReaderFor(file))
                {
                    info.durationSeconds = reader->lengthInSamples / reader->sampleRate;
                    info.sampleRate = (int)reader->sampleRate;
                    info.numChannels = (int)reader->numChannels;
                    delete reader;
                }
                node->samples.push_back(info);
            }
        }
    }
    
    juce::AudioFormatManager formatManager;
    std::unique_ptr<DirectoryNode> rootNode;
};


================================================================================
FILE: juce\Source\preset_creator\SampleManager.cpp
================================================================================


#include "SampleManager.h"

SampleManager::SampleManager()
{
    // Register common audio formats
    m_formatManager.registerBasicFormats();
}

void SampleManager::scanDirectory(const juce::File& directory, bool recursive)
{
    if (!directory.exists() || !directory.isDirectory())
        return;
    
    // Supported audio file extensions
    juce::String wildcardPattern = "*.wav;*.mp3;*.aif;*.aiff;*.flac;*.ogg";
    
    // Find all audio files
    juce::Array<juce::File> audioFiles;
    directory.findChildFiles(audioFiles, 
                             juce::File::findFiles, 
                             recursive, 
                             wildcardPattern);
    
    for (const auto& file : audioFiles)
    {
        SampleInfo info = extractMetadata(file);
        if (info.sampleRate > 0) // Valid audio file
            m_samples.push_back(info);
    }
    
    juce::Logger::writeToLog("[SampleManager] Scanned " + juce::String(m_samples.size()) + 
                            " samples from: " + directory.getFullPathName());
}

std::vector<SampleManager::SampleInfo> SampleManager::searchSamples(const juce::String& searchTerm) const
{
    std::vector<SampleInfo> results;
    
    for (const auto& sample : m_samples)
    {
        if (sample.matchesSearch(searchTerm))
            results.push_back(sample);
    }
    
    return results;
}

SampleManager::SampleInfo SampleManager::extractMetadata(const juce::File& file)
{
    SampleInfo info;
    info.file = file;
    info.name = file.getFileNameWithoutExtension();
    info.lastModified = file.getLastModificationTime();
    
    // Try to read audio file metadata
    std::unique_ptr<juce::AudioFormatReader> reader(m_formatManager.createReaderFor(file));
    
    if (reader != nullptr)
    {
        info.sampleRate = static_cast<int>(reader->sampleRate);
        info.numChannels = static_cast<int>(reader->numChannels);
        info.lengthInSamples = reader->lengthInSamples;
        
        if (info.sampleRate > 0)
            info.durationSeconds = info.lengthInSamples / static_cast<double>(info.sampleRate);
    }
    
    return info;
}



================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <atomic>
#include <vector>
#include <memory>
#include "../modules/ModuleProcessor.h"
#include "../modules/InputDebugModuleProcessor.h"

class ModularSynthProcessor : public juce::AudioProcessor
{
public:
    ModularSynthProcessor();
    ~ModularSynthProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    const juce::String getName() const override { return "Modular Synth"; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return true; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    // Public API (initial)
public:
    using Node = juce::AudioProcessorGraph::Node;
    using NodeID = juce::AudioProcessorGraph::NodeID;
    

    NodeID addModule(const juce::String& moduleType, bool commit = true);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc, juce::uint32 logicalIdToAssign);
    void removeModule(const NodeID& nodeID);
    void clearAll(); // Add this line
    void clearAllConnections(); // Add this line
    void clearOutputConnections(); // <<< ADD THIS LINE
    void clearConnectionsForNode(const NodeID& nodeID); // <<< ADD THIS LINE
    bool connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    
    // Set the hardware input channel mapping for an Audio Input module
    void setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap);
    
    void commitChanges();
    NodeID getOutputNodeID() const { return audioOutputNode ? audioOutputNode->nodeID : NodeID{}; }
    NodeID getBPMMonitorNodeID() const { return bpmMonitorNode ? bpmMonitorNode->nodeID : NodeID{}; }
    // Introspection for editor
    std::vector<std::pair<juce::uint32, juce::String>> getModulesInfo() const;
    juce::AudioProcessorGraph::NodeID getNodeIdForLogical (juce::uint32 logicalId) const;
    juce::uint32 getLogicalIdForNode (const NodeID& nodeId) const;
    juce::String getModuleTypeForLogical(juce::uint32 logicalId) const;
    bool disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    struct ConnectionInfo
    {
        juce::uint32 srcLogicalId { 0 };
        int srcChan { 0 };
        juce::uint32 dstLogicalId { 0 }; // 0 means audio output
        int dstChan { 0 };
        bool dstIsOutput { false };
    };
    std::vector<ConnectionInfo> getConnectionsInfo() const;
    // Access a module processor for UI parameter editing
    ModuleProcessor* getModuleForLogical (juce::uint32 logicalId) const;
    
    // === GLOBAL TRANSPORT & TIMING ===
    // (TransportState struct is defined in ModuleProcessor.h)
    
    TransportState getTransportState() const { return m_transportState; }
    void setPlaying(bool playing) {
        m_transportState.isPlaying = playing;
        // Immediately broadcast timing change to modules even if audio callback is stopped
        if (auto processors = activeAudioProcessors.load())
        {
            for (const auto& modulePtr : *processors)
                if (modulePtr)
                    modulePtr->setTimingInfo(m_transportState);
        }
    }
    void setBPM(double bpm) { m_transportState.bpm = juce::jlimit(20.0, 999.0, bpm); }
    void setGlobalDivisionIndex(int idx) { m_transportState.globalDivisionIndex.store(idx); }
    void setTempoControlledByModule(bool controlled) { m_transportState.isTempoControlledByModule.store(controlled); }
    
    // MIDI activity indicator
    bool hasMidiActivity() const { return m_midiActivityFlag.exchange(false); }
    void resetTransportPosition() { m_samplePosition = 0; m_transportState.songPositionBeats = 0.0; m_transportState.songPositionSeconds = 0.0; }
    
    // === MULTI-MIDI DEVICE SUPPORT ===
    
    /**
     * @brief Process device-aware MIDI messages
     * 
     * This method receives MIDI messages with device source information and
     * distributes them to all modules via handleDeviceSpecificMidi().
     * Should be called from the message thread (timer callback in PresetCreatorComponent).
     * 
     * @param messages Vector of MIDI messages with device information
     */
    void processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages);
    
    /**
     * @brief MIDI activity state per device and channel
     */
    struct MidiActivityState {
        std::map<int, std::array<bool, 16>> deviceChannelActivity;  // deviceIndex -> channels[16]
        std::map<int, juce::String> deviceNames;                    // deviceIndex -> name
    };
    
    /**
     * @brief Get snapshot of current MIDI activity
     * 
     * Used by UI for visualization (top bar indicator).
     * Thread-safe.
     * 
     * @return MidiActivityState structure
     */
    MidiActivityState getMidiActivityState() const;
    
    // === VOICE MANAGEMENT FOR POLYPHONY ===
    struct Voice {
        bool isActive = false;
        int noteNumber = -1;
        float velocity = 0.0f;
        juce::uint32 age = 0;  // Used for note stealing (oldest voice)
        juce::uint32 targetModuleLogicalId = 0;  // Which PolyVCO this voice is assigned to
    };
    
    void setVoiceManagerEnabled(bool enabled) { m_voiceManagerEnabled = enabled; }
    bool isVoiceManagerEnabled() const { return m_voiceManagerEnabled; }
    void setMaxVoices(int numVoices) { m_voices.resize(numVoices); }
    int getMaxVoices() const { return static_cast<int>(m_voices.size()); }
    const std::vector<Voice>& getVoices() const { return m_voices; }
    
    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get system-wide diagnostics
    juce::String getSystemDiagnostics() const;
    
    // Get diagnostics for a specific module
    juce::String getModuleDiagnostics(juce::uint32 logicalId) const;
    
    // Get parameter routing diagnostics for a specific module
    juce::String getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const;
    
    // Get all connection diagnostics
    juce::String getConnectionDiagnostics() const;
    
    // Check if any recorder module is currently recording (prevents spacebar from stopping audio)
    bool isAnyModuleRecording() const;
    
    // Pause/Resume all active recorders (used by spacebar during audition)
    void pauseAllRecorders();
    void resumeAllRecorders();
    
    // Global start/stop all recorders (used by menu bar)
    void startAllRecorders();
    void stopAllRecorders();
    
    // Plugin format manager for VST support (optional, set by application)
    void setPluginFormatManager(juce::AudioPluginFormatManager* manager) { pluginFormatManager = manager; }
    void setKnownPluginList(juce::KnownPluginList* list) { knownPluginList = list; }
    
    // === PROBE TOOL API ===
    // Probe system for instant signal debugging without manual patching
    void setProbeConnection(const NodeID& sourceNodeID, int sourceChannel);
    void clearProbeConnection();
    ModuleProcessor* getProbeScopeProcessor() const;

private:
    // The internal graph that represents the modular patch
    std::unique_ptr<juce::AudioProcessorGraph> internalGraph;

    // Special nodes for handling I/O within the internal graph
    Node::Ptr audioInputNode;
    Node::Ptr audioOutputNode;
    Node::Ptr midiInputNode;
    
    
    // MIDI activity indicator (mutable because hasMidiActivity() is const)
    mutable std::atomic<bool> m_midiActivityFlag{false};
    
    // Multi-MIDI device support
    std::vector<MidiMessageWithDevice> currentBlockMidiMessages;
    mutable juce::CriticalSection midiActivityLock;
    MidiActivityState currentActivity;

    // The APVTS that will expose proxy parameters to the host/AudioEngine
    juce::AudioProcessorValueTreeState apvts;

    // Thread-safe module access for audio thread
    mutable juce::CriticalSection moduleLock;
    std::atomic<std::shared_ptr<const std::vector<std::shared_ptr<ModuleProcessor>>>> activeAudioProcessors;

    // Manage module nodes (legacy map by NodeID.uid)
    std::map<juce::uint32, Node::Ptr> modules; // keyed by NodeID.uid
    // Logical ID mapping for preset save/load
    struct LogicalModule
    {
        juce::AudioProcessorGraph::NodeID nodeID;
        juce::String type;
    };
    std::map<juce::uint32, LogicalModule> logicalIdToModule; // logicalId -> module
    juce::uint32 nextLogicalId { 1 };
    
    // Optional pointers for VST support
    juce::AudioPluginFormatManager* pluginFormatManager { nullptr };
    juce::KnownPluginList* knownPluginList { nullptr };
    
    // Probe scope for instant signal debugging (hidden from user, not saved in presets)
    Node::Ptr probeScopeNode;
    NodeID probeScopeNodeId;
    
    // BPM Monitor node (always present, undeletable like output node)
    Node::Ptr bpmMonitorNode;
    
    // Transport state
    TransportState m_transportState;
    juce::uint64 m_samplePosition { 0 };
    
    // Voice management state
    std::vector<Voice> m_voices;
    bool m_voiceManagerEnabled { false };
    juce::uint32 m_globalVoiceAge { 0 };  // Incremented for each note-on
    
    // Voice management helper methods
    int findFreeVoice();
    int findOldestVoice();
    void assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn);
    void releaseVoice(const juce::MidiMessage& noteOff);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModularSynthProcessor)
};

================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.cpp
================================================================================


#include "ModularSynthProcessor.h"
#include "../modules/AudioInputModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/VCOModuleProcessor.h"
#include "../modules/VCFModuleProcessor.h"
#include "../modules/VCAModuleProcessor.h"
#include "../modules/NoiseModuleProcessor.h"
#include "../modules/LFOModuleProcessor.h"
#include "../modules/ADSRModuleProcessor.h"
#include "../modules/MixerModuleProcessor.h"
#include "../modules/DelayModuleProcessor.h"
#include "../modules/ReverbModuleProcessor.h"
#include "../modules/AttenuverterModuleProcessor.h"
#include "../modules/ScopeModuleProcessor.h"
#include "../modules/SAndHModuleProcessor.h"
#include "../modules/StepSequencerModuleProcessor.h"
#include "../modules/MathModuleProcessor.h"
#include "../modules/MapRangeModuleProcessor.h"
#include "../modules/RandomModuleProcessor.h"
#include "../modules/RateModuleProcessor.h"
#include "../modules/QuantizerModuleProcessor.h"
#include "../modules/SequentialSwitchModuleProcessor.h"
#include "../modules/LogicModuleProcessor.h"
#include "../modules/ValueModuleProcessor.h"
#include "../modules/ClockDividerModuleProcessor.h"
#include "../modules/WaveshaperModuleProcessor.h"
#include "../modules/MultiBandShaperModuleProcessor.h"
#include "../modules/GranulatorModuleProcessor.h"
#include "../modules/HarmonicShaperModuleProcessor.h"
#include "../modules/TrackMixerModuleProcessor.h"
#include "../modules/TTSPerformerModuleProcessor.h"
#include "../modules/ComparatorModuleProcessor.h"
#include "../modules/VocalTractFilterModuleProcessor.h"
#include "../modules/VstHostModuleProcessor.h"
#include "../modules/SampleLoaderModuleProcessor.h"
#include "../modules/FunctionGeneratorModuleProcessor.h"
#include "../modules/TimePitchModuleProcessor.h"
#include "../modules/DebugModuleProcessor.h"
#include "../modules/CommentModuleProcessor.h"
#include "../modules/MIDIPlayerModuleProcessor.h"
#include "../modules/PolyVCOModuleProcessor.h"
#include "../modules/BestPracticeNodeProcessor.h"
#include "../modules/TimelineModuleProcessor.h"
#include "../modules/BPMMonitorModuleProcessor.h"
#include "../modules/ShapingOscillatorModuleProcessor.h"
#include "../modules/MultiSequencerModuleProcessor.h"
#include "../modules/LagProcessorModuleProcessor.h"
#include "../modules/DeCrackleModuleProcessor.h"
#include "../modules/CVMixerModuleProcessor.h"
#include "../modules/GraphicEQModuleProcessor.h"
#include "../modules/FrequencyGraphModuleProcessor.h"
#include "../modules/ChorusModuleProcessor.h"
#include "../modules/PhaserModuleProcessor.h"
#include "../modules/CompressorModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/LimiterModuleProcessor.h"
#include "../modules/GateModuleProcessor.h"
#include "../modules/DriveModuleProcessor.h"
#include "../modules/SnapshotSequencerModuleProcessor.h"
#include "../modules/MIDICVModuleProcessor.h"
#include "../modules/MIDIFadersModuleProcessor.h"
#include "../modules/MIDIKnobsModuleProcessor.h"
#include "../modules/MIDIButtonsModuleProcessor.h"
#include "../modules/MIDIJogWheelModuleProcessor.h"
#include "../modules/MIDIPadModuleProcessor.h"
#include "../modules/MidiLoggerModuleProcessor.h"
#include "../modules/TempoClockModuleProcessor.h"
#include "../modules/PhysicsModuleProcessor.h"
#include "../modules/StrokeSequencerModuleProcessor.h"
#include "../modules/AnimationModuleProcessor.h"
#include "../modules/WebcamLoaderModule.h"
#include "../modules/VideoFileLoaderModule.h"
#include "../modules/VideoFXModule.h"
#include "../modules/MovementDetectorModule.h"
#include "../modules/HumanDetectorModule.h"
#include "../modules/PoseEstimatorModule.h"
#include "../modules/HandTrackerModule.h"
#include "../modules/FaceTrackerModule.h"
#include "../modules/ObjectDetectorModule.h"
#include "../modules/ColorTrackerModule.h"
#include "../modules/ContourDetectorModule.h"
#include "../modules/SemanticSegmentationModule.h"
#include "../modules/CropVideoModule.h"
#include "../modules/InletModuleProcessor.h"
#include "../modules/OutletModuleProcessor.h"
#include "../modules/MetaModuleProcessor.h"

ModularSynthProcessor::ModularSynthProcessor()
    : juce::AudioProcessor(BusesProperties()
                            .withInput("Input", juce::AudioChannelSet::stereo(), true)
                            .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "ModularSynthParams", {})
{
    internalGraph = std::make_unique<juce::AudioProcessorGraph>();

    using IOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor;
    audioInputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioInputNode));
    audioOutputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioOutputNode));
    midiInputNode  = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::midiInputNode));

    internalGraph->addConnection({ { midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex },
                                   { audioOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex } });
    
    probeScopeNode = internalGraph->addNode(std::make_unique<ScopeModuleProcessor>());
    probeScopeNodeId = probeScopeNode->nodeID;
    juce::Logger::writeToLog("[ModularSynth] Initialized probe scope with nodeID: " + juce::String(probeScopeNodeId.uid));
    
    // Create BPM Monitor node (always present, undeletable like output node)
    auto bpmMonitor = std::make_unique<BPMMonitorModuleProcessor>();
    bpmMonitor->setLogicalId(999); // Special ID to make it undeletable
    bpmMonitorNode = internalGraph->addNode(std::move(bpmMonitor));
    if (auto* processor = dynamic_cast<ModuleProcessor*>(bpmMonitorNode->getProcessor()))
        processor->setParent(this);
    // Add to logicalIdToModule so it appears in the UI
    logicalIdToModule[999] = LogicalModule{ bpmMonitorNode->nodeID, "bpm_monitor" };
    juce::Logger::writeToLog("[ModularSynth] Initialized BPM Monitor with logicalID: 999");
    
    activeAudioProcessors.store(std::make_shared<const std::vector<std::shared_ptr<ModuleProcessor>>>());
    
    m_voices.resize(8);
    for (auto& voice : m_voices)
    {
        voice.isActive = false;
        voice.noteNumber = -1;
        voice.velocity = 0.0f;
        voice.age = 0;
        voice.targetModuleLogicalId = 0;
    }
}

ModularSynthProcessor::~ModularSynthProcessor() {}

void ModularSynthProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    internalGraph->setPlayConfigDetails(getTotalNumInputChannels(), getTotalNumOutputChannels(), sampleRate, samplesPerBlock);
    internalGraph->prepareToPlay(sampleRate, samplesPerBlock);
}

void ModularSynthProcessor::releaseResources()
{
    internalGraph->releaseResources();
}

//==============================================================================
// Multi-MIDI Device Support
//==============================================================================

void ModularSynthProcessor::processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages)
{
    const juce::ScopedLock lock(midiActivityLock);
    currentBlockMidiMessages = messages;
    
    // DEBUG LOGGING
    if (!messages.empty())
    {
        juce::Logger::writeToLog("[ModularSynth] processMidiWithDeviceInfo received " + 
                                juce::String(messages.size()) + " MIDI messages");
    }
    
    // Update activity tracking
    currentActivity.deviceChannelActivity.clear();
    currentActivity.deviceNames.clear();
    
    for (const auto& msg : messages)
    {
        // Skip system realtime messages
        if (msg.message.isMidiClock() || msg.message.isActiveSense())
            continue;
        
        int channel = msg.message.getChannel();
        if (channel >= 1 && channel <= 16)
        {
            int channelIndex = channel - 1;  // 0-15
            currentActivity.deviceChannelActivity[msg.deviceIndex][channelIndex] = true;
            currentActivity.deviceNames[msg.deviceIndex] = msg.deviceName;
        }
    }
}

ModularSynthProcessor::MidiActivityState ModularSynthProcessor::getMidiActivityState() const
{
    const juce::ScopedLock lock(midiActivityLock);
    return currentActivity;
}

//==============================================================================
// Audio Processing
//==============================================================================

void ModularSynthProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    try {
        // NOTE: Both tempo and division control flags are managed by Tempo Clock modules directly
        // No resets here to avoid flickering in UI
        
        // --- ADD THIS LOGGING BLOCK ---
        if (!midiMessages.isEmpty())
        {
            // If we get this message, it means MIDI is successfully reaching the synth.
            juce::Logger::writeToLog("[SynthCore] Received " + juce::String(midiMessages.getNumEvents()) + " MIDI events this block.");
            m_midiActivityFlag.store(true);
        }
        // --- END OF BLOCK ---
        
        if (m_transportState.isPlaying)
        {
            m_samplePosition += buffer.getNumSamples();
            m_transportState.songPositionSeconds = m_samplePosition / getSampleRate();
            m_transportState.songPositionBeats = (m_transportState.songPositionSeconds / 60.0) * m_transportState.bpm;
        }

        // --- FINAL THREAD-SAFE FIX ---
        auto currentProcessors = activeAudioProcessors.load();
        if (currentProcessors)
        {
            // Iterate over the safe, shared list.
            for (const auto& modulePtr : *currentProcessors)
            {
                // SAFETY NET + GRANULAR LOGGING
                if (modulePtr != nullptr)
                {
                    // Log the memory address before calling the function
                    // juce::Logger::writeToLog("[AudioThread] Ticking module at 0x" + juce::String::toHexString((juce::pointer_sized_int)modulePtr.get()));
                    modulePtr->setTimingInfo(m_transportState);
                }
                else
                {
                    // This should never happen with the shared_ptr fix, but if it does, it's critical info.
                    juce::Logger::writeToLog("[AudioThread] CRITICAL WARNING: Encountered nullptr in active processor list!");
                }
            }
        }
        // --- END OF FIX ---
        
        // === MULTI-MIDI DEVICE SUPPORT: Distribute device-aware MIDI to modules ===
        // This happens BEFORE voice management and graph processing
        // Modules receive device info and can filter by device/channel
        {
            const juce::ScopedLock lock(midiActivityLock);
            
            // DEBUG: Log every processBlock attempt to check the buffer
            static int checkCount = 0;
            static int distributionCount = 0;
            checkCount++;
            
            if (!currentBlockMidiMessages.empty())
            {
                distributionCount++;
                
                // Log only first few times to avoid spam
                if (distributionCount <= 5)
                {
                    juce::Logger::writeToLog("[ModularSynth processBlock] CHECK #" + juce::String(checkCount) + 
                                            " - Found " + juce::String(currentBlockMidiMessages.size()) + " messages to distribute");
                }
                
                if (internalGraph)
                {
                    int nodeCount = internalGraph->getNodes().size();
                    int moduleCount = 0;
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Distributing to " + juce::String(nodeCount) + " nodes");
                    }
                    
                    for (auto* node : internalGraph->getNodes())
                    {
                        if (auto* module = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                        {
                            moduleCount++;
                            module->handleDeviceSpecificMidi(currentBlockMidiMessages);
                        }
                    }
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Called handleDeviceSpecificMidi on " + 
                                                juce::String(moduleCount) + " modules");
                    }
                    
                    // Merge device-aware MIDI into standard MidiBuffer for backward compatibility
                    for (const auto& msg : currentBlockMidiMessages)
                    {
                        midiMessages.addEvent(msg.message, 0);
                    }
                    
                    // Clear for next block
                    currentBlockMidiMessages.clear();
                }
                else
                {
                    juce::Logger::writeToLog("[ModularSynth] WARNING: Have MIDI messages but internalGraph is null!");
                }
            }
        }
        // === END MULTI-MIDI DISTRIBUTION ===
        
        if (m_voiceManagerEnabled && !m_voices.empty())
        {
            juce::MidiBuffer processedMidi;
            for (const auto metadata : midiMessages)
            {
                const auto msg = metadata.getMessage();
                if (msg.isNoteOn())
                {
                    int voiceIndex = findFreeVoice();
                    if (voiceIndex < 0) voiceIndex = findOldestVoice();
                    if (voiceIndex >= 0)
                    {
                        assignNoteToVoice(voiceIndex, msg);
                        processedMidi.addEvent(msg, metadata.samplePosition);
                    }
                }
                else if (msg.isNoteOff())
                {
                    releaseVoice(msg);
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
                else
                {
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
            }
            midiMessages.swapWith(processedMidi);
        }
        
        internalGraph->processBlock(buffer, midiMessages);
        static int silentCtr = 0;
        if (buffer.getMagnitude(0, buffer.getNumSamples()) < 1.0e-6f)
        {
            if ((++silentCtr % 600) == 0)
                juce::Logger::writeToLog("[ModularSynthProcessor] silent block from internal graph");
        }
        else
        {
            silentCtr = 0;
        }
    } catch (const std::exception& e) {
        juce::Logger::writeToLog(juce::String("[ModSynth][FATAL] Exception in processBlock: ") + e.what());
        buffer.clear();
        return;
    } catch (...) {
        juce::Logger::writeToLog("[ModSynth][FATAL] Unknown exception in processBlock");
        buffer.clear();
        return;
    }
}

void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock (moduleLock);
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32) kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int) logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32) c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32) c.destination.nodeID.uid;
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int) dstIt->second, nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else
        {
            continue;
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}

void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes)));
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML or wrong root tag. Aborting restore.");
        return;
    }

    clearAll();
    juce::Logger::writeToLog("[STATE] Cleared existing state.");

    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // Restore global transport settings
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    juce::Logger::writeToLog("[STATE] Restored BPM to " + juce::String(m_transportState.bpm));
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found in preset.");
        return;
    }
    
    juce::Logger::writeToLog("[STATE] Found <modules> block with " + juce::String(modsVT.getNumChildren()) + " children.");
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    std::map<juce::uint32, NodeID> logicalToNodeId;
    juce::Logger::writeToLog("[STATE] Starting module recreation pass...");
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module"))
        {
            juce::Logger::writeToLog("[STATE] Skipping non-module child at index " + juce::String(i));
            continue;
        }

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module " + juce::String(i) + ": logicalId=" + juce::String(logicalId) + " type='" + type + "'");

        // Skip BPM Monitor (logical ID 999) - it's always present and should not be loaded from preset
        if (logicalId == 999)
        {
            juce::Logger::writeToLog("[STATE] Skipping BPM Monitor (logical ID 999) - always present");
            continue;
        }

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::Logger::writeToLog("[STATE]   Loading VST module...");
                    
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr && knownPluginList != nullptr)
                    {
                        bool found = false;
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE]   Found VST to load: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found)
                        {
                            juce::Logger::writeToLog("[STATE]   ERROR: VST plugin not found: " + identifier);
                        }
                    }
                    else
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: No plugin identifier or format manager/list not available");
                    }
                    
                    if (nodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: Failed to create VST module, skipping...");
                        continue;
                    }
                }
            }
            
            if (!isVstModule)
            {
                juce::Logger::writeToLog("[STATE]   Calling addModule('" + type + "')...");
                nodeId = addModule(type, false);
                juce::Logger::writeToLog("[STATE]   addModule returned nodeId.uid=" + juce::String(nodeId.uid));
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                juce::Logger::writeToLog("[STATE]   Node created successfully.");
                
                if (!isVstModule)
                {
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;
                juce::Logger::writeToLog("[STATE]   Mapped logicalId " + juce::String(logicalId) + " to nodeId.uid " + juce::String(nodeId.uid));

                // --- FIX: Restore extra state FIRST ---
                // This will load the clip and reset trim sliders to defaults.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE]   Restored extra state.");
                    }
                }

                // Now restore parameters SECOND.
                // This will overwrite the temporary default trim values with the correct saved values.
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE]   Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   ERROR: Node creation failed! nodeId.uid was " + juce::String(nodeId.uid) + " but getNodeForId returned nullptr.");
            }
        }
        else
        {
            juce::Logger::writeToLog("[STATE]   Skipping module: logicalId=" + juce::String(logicalId) + " (valid=" + juce::String(logicalId > 0 ? "yes" : "no") + ") type='" + type + "' (empty=" + juce::String(type.isEmpty() ? "yes" : "no") + ")");
        }
    }
    
    juce::Logger::writeToLog("[STATE] Module recreation complete. Created " + juce::String(logicalToNodeId.size()) + " modules.");

    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        int skippedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   WARNING: Skipping connection " + juce::String(i) + 
                                        ": srcId=" + juce::String(srcId) + " (uid=" + juce::String(srcNodeId.uid) + 
                                        ") ‚Üí dstId=" + (dstIsOutput ? "output" : juce::String(dstId)) + 
                                        " (uid=" + juce::String(dstNodeId.uid) + ")");
                skippedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connection restore complete: " + juce::String(connectedCount) + 
                                " connected, " + juce::String(skippedCount) + " skipped.");
    }
    else
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <connections> block found in preset.");
    }


    juce::Logger::writeToLog("[STATE] Calling commitChanges()...");
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}

namespace {
    static juce::String toLowerId (const juce::String& s)
    {
        return s.toLowerCase();
    }

    using Creator = std::function<std::unique_ptr<juce::AudioProcessor>()>;

    static std::map<juce::String, Creator>& getModuleFactory()
    {
        static std::map<juce::String, Creator> factory;
        static bool initialised = false;
        if (!initialised)
        {
            auto reg = [&](const juce::String& key, Creator c) { factory.emplace(toLowerId(key), std::move(c)); };

            reg("vco", []{ return std::make_unique<VCOModuleProcessor>(); });
            reg("audio_input", []{ return std::make_unique<AudioInputModuleProcessor>(); });
            reg("vcf", []{ return std::make_unique<VCFModuleProcessor>(); });
            reg("vca", []{ return std::make_unique<VCAModuleProcessor>(); });
            reg("noise", []{ return std::make_unique<NoiseModuleProcessor>(); });
            reg("lfo", []{ return std::make_unique<LFOModuleProcessor>(); });
            reg("adsr", []{ return std::make_unique<ADSRModuleProcessor>(); });
            reg("mixer", []{ return std::make_unique<MixerModuleProcessor>(); });
            reg("cv_mixer", []{ return std::make_unique<CVMixerModuleProcessor>(); });
            reg("track_mixer", []{ return std::make_unique<TrackMixerModuleProcessor>(); });
            reg("delay", []{ return std::make_unique<DelayModuleProcessor>(); });
            reg("reverb", []{ return std::make_unique<ReverbModuleProcessor>(); });
            reg("attenuverter", []{ return std::make_unique<AttenuverterModuleProcessor>(); });
            reg("scope", []{ return std::make_unique<ScopeModuleProcessor>(); });
            reg("frequency_graph", []{ return std::make_unique<FrequencyGraphModuleProcessor>(); });
            reg("s_and_h", []{ return std::make_unique<SAndHModuleProcessor>(); });
            reg("sequencer", []{ return std::make_unique<StepSequencerModuleProcessor>(); });
            reg("math", []{ return std::make_unique<MathModuleProcessor>(); });
            reg("map_range", []{ return std::make_unique<MapRangeModuleProcessor>(); });
            reg("comparator", []{ return std::make_unique<ComparatorModuleProcessor>(); });
            reg("random", []{ return std::make_unique<RandomModuleProcessor>(); });
            reg("rate", []{ return std::make_unique<RateModuleProcessor>(); });
            reg("quantizer", []{ return std::make_unique<QuantizerModuleProcessor>(); });
            reg("sequential_switch", []{ return std::make_unique<SequentialSwitchModuleProcessor>(); });
            reg("logic", []{ return std::make_unique<LogicModuleProcessor>(); });
            reg("clock_divider", []{ return std::make_unique<ClockDividerModuleProcessor>(); });
            reg("waveshaper", []{ return std::make_unique<WaveshaperModuleProcessor>(); });
            reg("8bandshaper", []{ return std::make_unique<MultiBandShaperModuleProcessor>(); });
            reg("granulator", []{ return std::make_unique<GranulatorModuleProcessor>(); });
            reg("harmonic_shaper", []{ return std::make_unique<HarmonicShaperModuleProcessor>(); });
            reg("debug", []{ return std::make_unique<DebugModuleProcessor>(); });
            reg("input_debug", []{ return std::make_unique<InputDebugModuleProcessor>(); });
            reg("vocal_tract_filter", []{ return std::make_unique<VocalTractFilterModuleProcessor>(); });
            reg("value", []{ return std::make_unique<ValueModuleProcessor>(); });
            reg("tts_performer", []{ return std::make_unique<TTSPerformerModuleProcessor>(); });
            reg("sample_loader", []{ return std::make_unique<SampleLoaderModuleProcessor>(); });
            reg("function_generator", []{ return std::make_unique<FunctionGeneratorModuleProcessor>(); });
            reg("timepitch", []{ return std::make_unique<TimePitchModuleProcessor>(); });
            reg("midi_player", []{ return std::make_unique<MIDIPlayerModuleProcessor>(); });
            reg("polyvco", []{ return std::make_unique<PolyVCOModuleProcessor>(); });
            reg("best_practice", []{ return std::make_unique<BestPracticeNodeProcessor>(); });
            reg("timeline", []{ return std::make_unique<TimelineModuleProcessor>(); });
            reg("shaping_oscillator", []{ return std::make_unique<ShapingOscillatorModuleProcessor>(); });
            reg("multi_sequencer", []{ return std::make_unique<MultiSequencerModuleProcessor>(); });
            reg("lag_processor", []{ return std::make_unique<LagProcessorModuleProcessor>(); });
            reg("de_crackle", []{ return std::make_unique<DeCrackleModuleProcessor>(); });
            reg("graphic_eq", []{ return std::make_unique<GraphicEQModuleProcessor>(); });
            reg("chorus", []{ return std::make_unique<ChorusModuleProcessor>(); });
            reg("phaser", []{ return std::make_unique<PhaserModuleProcessor>(); });
            reg("compressor", []{ return std::make_unique<CompressorModuleProcessor>(); });
            reg("recorder", []{ return std::make_unique<RecordModuleProcessor>(); });
            reg("limiter", []{ return std::make_unique<LimiterModuleProcessor>(); });
            reg("gate", []{ return std::make_unique<GateModuleProcessor>(); });
            reg("drive", []{ return std::make_unique<DriveModuleProcessor>(); });
            reg("comment", []{ return std::make_unique<CommentModuleProcessor>(); });
            reg("snapshot_sequencer", []{ return std::make_unique<SnapshotSequencerModuleProcessor>(); });
            reg("midi_cv", []{ return std::make_unique<MIDICVModuleProcessor>(); });
            reg("midi_faders", []{ return std::make_unique<MIDIFadersModuleProcessor>(); });
            reg("midi_knobs", []{ return std::make_unique<MIDIKnobsModuleProcessor>(); });
            reg("midi_buttons", []{ return std::make_unique<MIDIButtonsModuleProcessor>(); });
            reg("midi_jog_wheel", []{ return std::make_unique<MIDIJogWheelModuleProcessor>(); });
            reg("midi_pads", []{ return std::make_unique<MIDIPadModuleProcessor>(); });
            reg("midi_logger", []{ return std::make_unique<MidiLoggerModuleProcessor>(); });
            reg("tempo_clock", []{ return std::make_unique<TempoClockModuleProcessor>(); });
            reg("physics", []{ return std::make_unique<PhysicsModuleProcessor>(); });
            reg("animation", []{ return std::make_unique<AnimationModuleProcessor>(); });
            reg("bpm_monitor", []{ return std::make_unique<BPMMonitorModuleProcessor>(); });
            reg("webcam_loader", []{ return std::make_unique<WebcamLoaderModule>(); });
            reg("video_file_loader", []{ return std::make_unique<VideoFileLoaderModule>(); });
            reg("video_fx", []{ return std::make_unique<VideoFXModule>(); });
            reg("movement_detector", []{ return std::make_unique<MovementDetectorModule>(); });
            reg("human_detector", []{ return std::make_unique<HumanDetectorModule>(); });
            reg("pose_estimator", []{ return std::make_unique<PoseEstimatorModule>(); });
            reg("hand_tracker", []{ return std::make_unique<HandTrackerModule>(); });
            reg("face_tracker", []{ return std::make_unique<FaceTrackerModule>(); });
            reg("object_detector", []{ return std::make_unique<ObjectDetectorModule>(); });
            reg("color_tracker", []{ return std::make_unique<ColorTrackerModule>(); });
            reg("contour_detector", []{ return std::make_unique<ContourDetectorModule>(); });
            reg("semantic_segmentation", []{ return std::make_unique<SemanticSegmentationModule>(); });
            reg("crop_video", []{ return std::make_unique<CropVideoModule>(); });
            reg("stroke_sequencer", []{ return std::make_unique<StrokeSequencerModuleProcessor>(); });
            
            reg("meta module", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("metamodule", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("inlet", []{ return std::make_unique<InletModuleProcessor>(); });
            reg("outlet", []{ return std::make_unique<OutletModuleProcessor>(); });

            initialised = true;
        }
        return factory;
    }
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addModule(const juce::String& moduleType, bool commit)
{
    const juce::ScopedLock lock (moduleLock);
    auto& factory = getModuleFactory();
    const juce::String key = moduleType.toLowerCase();
    std::unique_ptr<juce::AudioProcessor> processor;

    if (auto it = factory.find(key); it != factory.end())
        processor = it->second();

    if (! processor)
    {
        for (const auto& kv : factory)
            if (moduleType.equalsIgnoreCase(kv.first)) { processor = kv.second(); break; }
    }

    if (processor)
    {
        auto node = internalGraph->addNode(std::move(processor), {}, juce::AudioProcessorGraph::UpdateKind::none);
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setParent(this);
        modules[(juce::uint32) node->nodeID.uid] = node;
        const juce::uint32 logicalId = nextLogicalId++;
        logicalIdToModule[logicalId] = LogicalModule{ node->nodeID, moduleType };
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        {
            mp->setLogicalId(logicalId);
            mp->setSecondaryLogicalId(nextLogicalId++); // Assign secondary ID for extra outputs (e.g., cropped video)
        }
        
        if (moduleType.equalsIgnoreCase("audio_input"))
        {
            std::vector<int> defaultMapping = {0, 1};
            setAudioInputChannelMapping(node->nodeID, defaultMapping);
        }
        
        if (commit)
        {
            // Ensure the new module is immediately active
            commitChanges();
        }
        
        return node->nodeID;
    }

    juce::Logger::writeToLog("[ModSynth][WARN] Unknown module type: " + moduleType);
    return {};
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc,
    juce::uint32 logicalIdToAssign)
{
    juce::String errorMessage;
    std::unique_ptr<juce::AudioPluginInstance> instance = 
        formatManager.createPluginInstance(vstDesc, getSampleRate(), getBlockSize(), errorMessage);

    if (instance == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] Could not create VST instance: " + errorMessage);
        return {};
    }

    auto wrapper = std::make_unique<VstHostModuleProcessor>(std::move(instance), vstDesc);
    
    auto node = internalGraph->addNode(std::move(wrapper), {}, juce::AudioProcessorGraph::UpdateKind::none);

    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setParent(this);
    
    modules[(juce::uint32) node->nodeID.uid] = node;
    
    logicalIdToModule[logicalIdToAssign] = LogicalModule{ node->nodeID, vstDesc.name };
    
    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setLogicalId(logicalIdToAssign);
    
    juce::Logger::writeToLog("[ModSynth] Added VST module: " + vstDesc.name + " with logical ID " + juce::String(logicalIdToAssign));
    return node->nodeID;
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc)
{
    const juce::uint32 logicalId = nextLogicalId++;
    auto nodeId = addVstModule(formatManager, vstDesc, logicalId);
    
    if (nodeId.uid != 0)
        commitChanges();
    
    return nodeId;
}

void ModularSynthProcessor::removeModule(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;
    const juce::ScopedLock lock(moduleLock); // Ensure thread-safe access

    // --- LOGGING ---
    if (auto* node = internalGraph->getNodeForId(nodeID))
    {
        if (auto* proc = node->getProcessor())
        {
            juce::Logger::writeToLog("[GraphSync] Deleting module L-ID " + juce::String(getLogicalIdForNode(nodeID)) + 
                                   " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
        }
    }
    // --- END LOGGING ---

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    internalGraph->removeNode(nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    
    modules.erase((juce::uint32) nodeID.uid);
    if (logicalId != 0)
    {
        logicalIdToModule.erase(logicalId);
    }
}

bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            juce::Logger::writeToLog("[ModSynth][INFO] Skipping duplicate connection [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                     + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
            return true;
        }
    }

    const bool ok = internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
    if (! ok)
    {
        juce::Logger::writeToLog("[ModSynth][WARN] Failed to connect [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                 + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
    }
    return ok;
}

void ModularSynthProcessor::commitChanges()
{
    internalGraph->rebuild();
    
    if (getSampleRate() > 0 && getBlockSize() > 0)
    {
        internalGraph->prepareToPlay(getSampleRate(), getBlockSize());
    }

    juce::Logger::writeToLog("--- Modular Synth Internal Patch State ---");
    juce::Logger::writeToLog("Num Nodes: " + juce::String(internalGraph->getNodes().size()));
    juce::Logger::writeToLog("Num Connections: " + juce::String(internalGraph->getConnections().size()));
    for (const auto& node : internalGraph->getNodes())
    {
        auto* p = node->getProcessor();
        juce::String name = p ? p->getName() : juce::String("<null>");
        const int ins  = p ? p->getTotalNumInputChannels()  : -1;
        const int outs = p ? p->getTotalNumOutputChannels() : -1;
        juce::Logger::writeToLog("  Node: id=" + juce::String(node->nodeID.uid) + " name='" + name + "' ins=" + juce::String(ins) + " outs=" + juce::String(outs));
    }
    for (const auto& conn : internalGraph->getConnections())
    {
        juce::Logger::writeToLog("  Connection: [" + juce::String(conn.source.nodeID.uid) + ":" + juce::String(conn.source.channelIndex)
            + "] -> [" + juce::String(conn.destination.nodeID.uid) + ":" + juce::String(conn.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog("-----------------------------------------");
    
    for (const auto& kv : logicalIdToModule)
    {
        if (ModuleProcessor* mp = getModuleForLogical(kv.first))
        {
            mp->setLogicalId(kv.first);
        }
    }
    
    // --- FINAL THREAD-SAFE FIX: Rebuild the list of active processors for the audio thread ---
    auto newProcessors = std::make_shared<std::vector<std::shared_ptr<ModuleProcessor>>>();
    {
        const juce::ScopedLock lock(moduleLock);
        newProcessors->reserve(logicalIdToModule.size());
        juce::Logger::writeToLog("[GraphSync] Building new processor list...");
        for (const auto& pair : logicalIdToModule)
        {
            // Find the Node::Ptr from the modules map
            auto modIt = modules.find((juce::uint32)pair.second.nodeID.uid);
            if (modIt != modules.end())
            {
                auto nodePtr = modIt->second; // This is a Node::Ptr (shared_ptr<Node>)
                if (auto* proc = dynamic_cast<ModuleProcessor*>(nodePtr->getProcessor()))
                {
                    // Create a shared_ptr to the processor with a custom deleter that keeps the Node alive
                    auto processor = std::shared_ptr<ModuleProcessor>(proc, [nodePtr](ModuleProcessor*) {
                        // Custom deleter: just hold the nodePtr, don't actually delete the processor
                        // When this shared_ptr is destroyed, the nodePtr will be released
                    });
                    newProcessors->push_back(processor);
                    juce::Logger::writeToLog("  [+] Adding module L-ID " + juce::String(pair.first) + 
                                           " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
                }
            }
        }
    }
    activeAudioProcessors.store(newProcessors);
    juce::Logger::writeToLog("[GraphSync] Updated active processor list for audio thread with " + juce::String(newProcessors->size()) + " modules.");
}

void ModularSynthProcessor::clearAll()
{
    const juce::ScopedLock lock (moduleLock);
    
    // --- LOGGING ---
    juce::Logger::writeToLog("[GraphSync] clearAll() initiated - removing " + juce::String(logicalIdToModule.size()) + " modules");
    // --- END LOGGING ---
    
    for (const auto& kv : logicalIdToModule)
    {
        internalGraph->removeNode(kv.second.nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    }

    modules.clear();
    logicalIdToModule.clear();
    nextLogicalId = 1;

    commitChanges();
}

void ModularSynthProcessor::clearAllConnections()
{
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex && 
            conn.destination.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearOutputConnections()
{
    if (audioOutputNode == nullptr)
        return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == audioOutputNode->nodeID)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearConnectionsForNode(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == nodeID || conn.destination.nodeID == nodeID)
        {
            if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
            {
                internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            }
        }
    }

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    commitChanges();
}

void ModularSynthProcessor::setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap)
{
    if (audioInputNode == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] setAudioInputChannelMapping called but main audioInputNode is null.");
        return;
    }

    juce::String mapStr;
    for (int i = 0; i < (int)channelMap.size(); ++i)
    {
        if (i > 0) mapStr += ", ";
        mapStr += juce::String(channelMap[i]);
    }
    juce::Logger::writeToLog("[ModSynth] Remapping Audio Input Module " + juce::String(audioInputNodeId.uid) +
                             " to channels: [" + mapStr + "]");

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == audioInputNode->nodeID && conn.destination.nodeID == audioInputNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }

    for (int moduleChannel = 0; moduleChannel < (int)channelMap.size(); ++moduleChannel)
    {
        int hardwareChannel = channelMap[moduleChannel];
        internalGraph->addConnection({ { audioInputNode->nodeID, hardwareChannel }, { audioInputNodeId, moduleChannel } }, 
                                     juce::AudioProcessorGraph::UpdateKind::none);
    }

    commitChanges();
}

std::vector<std::pair<juce::uint32, juce::String>> ModularSynthProcessor::getModulesInfo() const
{
    const juce::ScopedLock lock (moduleLock);
    std::vector<std::pair<juce::uint32, juce::String>> out;
    out.reserve(logicalIdToModule.size());
    for (const auto& kv : logicalIdToModule)
        out.emplace_back(kv.first, kv.second.type);
    return out;
}

juce::AudioProcessorGraph::NodeID ModularSynthProcessor::getNodeIdForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return {};
    return it->second.nodeID;
}

juce::uint32 ModularSynthProcessor::getLogicalIdForNode (const NodeID& nodeId) const
{
    const juce::ScopedLock lock (moduleLock);
    for (const auto& kv : logicalIdToModule)
        if (kv.second.nodeID == nodeId)
            return kv.first;
    return 0;
}

bool ModularSynthProcessor::disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };
    return internalGraph->removeConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}

std::vector<ModularSynthProcessor::ConnectionInfo> ModularSynthProcessor::getConnectionsInfo() const
{
    std::vector<ConnectionInfo> out;
    for (const auto& c : internalGraph->getConnections())
    {
        ConnectionInfo info;
        info.srcLogicalId = getLogicalIdForNode(c.source.nodeID);
        info.srcChan = c.source.channelIndex;
        info.dstLogicalId = getLogicalIdForNode(c.destination.nodeID);
        info.dstChan = c.destination.channelIndex;
        info.dstIsOutput = (c.destination.nodeID == audioOutputNode->nodeID);
        if (info.srcLogicalId != 0 && (info.dstLogicalId != 0 || info.dstIsOutput))
            out.push_back(info);
    }
    return out;
}


ModuleProcessor* ModularSynthProcessor::getModuleForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return nullptr;
    if (auto* node = internalGraph->getNodeForId(it->second.nodeID))
        return dynamic_cast<ModuleProcessor*>(node->getProcessor());
    return nullptr;
}

juce::String ModularSynthProcessor::getModuleTypeForLogical(juce::uint32 logicalId) const
{
    auto it = logicalIdToModule.find(logicalId);
    if (it != logicalIdToModule.end())
    {
        return it->second.type;
    }
    return {};
}

// === COMPREHENSIVE DIAGNOSTICS SYSTEM ===

juce::String ModularSynthProcessor::getSystemDiagnostics() const
{
    juce::String result = "=== MODULAR SYNTH SYSTEM DIAGNOSTICS ===\n\n";
    
    result += "Total Modules: " + juce::String((int)logicalIdToModule.size()) + "\n";
    result += "Next Logical ID: " + juce::String((int)nextLogicalId) + "\n\n";
    
    result += "=== MODULES ===\n";
    for (const auto& pair : logicalIdToModule)
    {
        result += "Logical ID " + juce::String((int)pair.first) + ": " + pair.second.type + 
                 " (Node ID: " + juce::String((int)pair.second.nodeID.uid) + ")\n";
    }
    result += "\n";
    
    result += getConnectionDiagnostics() + "\n";
    
    result += "=== GRAPH STATE ===\n";
    result += "Total Nodes: " + juce::String(internalGraph->getNumNodes()) + "\n";
    result += "Total Connections: (not available)\n";
    
    return result;
}

juce::String ModularSynthProcessor::getModuleDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (module)
    {
        return module->getAllDiagnostics();
    }
    else
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
}

juce::String ModularSynthProcessor::getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (!module)
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
    
    juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
    result += "Module: " + module->getName() + "\n\n";
    
    auto params = module->getParameters();
    
    for (int i = 0; i < params.size(); ++i)
    {
        auto* param = params[i];
        if (auto* paramWithId = dynamic_cast<juce::AudioProcessorParameterWithID*>(param))
        {
            int busIndex, channelIndex;
            if (module->getParamRouting(paramWithId->paramID, busIndex, channelIndex))
            {
                int absoluteChannel = module->getChannelIndexInProcessBlockBuffer(true, busIndex, channelIndex);
                result += "  \"" + paramWithId->paramID + "\" -> Bus " + juce::String(busIndex) + 
                         ", Channel " + juce::String(channelIndex) + " (Absolute: " + juce::String(absoluteChannel) + ")\n";
            }
            else
            {
                result += "  \"" + paramWithId->paramID + "\" -> NO ROUTING\n";
            }
        }
    }
    
    return result;
}

juce::String ModularSynthProcessor::getConnectionDiagnostics() const
{
    juce::String result = "=== CONNECTIONS ===\n";
    
    auto connections = getConnectionsInfo();
    for (const auto& conn : connections)
    {
        result += "Logical " + juce::String((int)conn.srcLogicalId) + ":" + juce::String(conn.srcChan) + 
                 " -> ";
        
        if (conn.dstIsOutput)
        {
            result += "OUTPUT:" + juce::String(conn.dstChan);
        }
        else
        {
            result += "Logical " + juce::String((int)conn.dstLogicalId) + ":" + juce::String(conn.dstChan);
        }
        result += "\n";
    }
    
    if (connections.empty())
    {
        result += "No connections found.\n";
    }
    
    return result;
}

bool ModularSynthProcessor::isAnyModuleRecording() const
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            if (recorder->getIsRecording())
                return true;
        }
    }
    return false;
}

void ModularSynthProcessor::pauseAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->pauseRecording();
        }
    }
}

void ModularSynthProcessor::resumeAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->resumeRecording();
        }
    }
}

void ModularSynthProcessor::startAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStartRecording();
        }
    }
}

void ModularSynthProcessor::stopAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStopRecording();
        }
    }
}

// === VOICE MANAGEMENT IMPLEMENTATION ===

int ModularSynthProcessor::findFreeVoice()
{
    for (int i = 0; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (!m_voices[i].isActive)
            return i;
    }
    return -1;
}

int ModularSynthProcessor::findOldestVoice()
{
    if (m_voices.empty())
        return -1;
    
    int oldestIndex = 0;
    juce::uint32 oldestAge = m_voices[0].age;
    
    for (int i = 1; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (m_voices[i].age < oldestAge)
        {
            oldestAge = m_voices[i].age;
            oldestIndex = i;
        }
    }
    
    return oldestIndex;
}

void ModularSynthProcessor::assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn)
{
    if (voiceIndex < 0 || voiceIndex >= static_cast<int>(m_voices.size()))
        return;
    
    Voice& voice = m_voices[voiceIndex];
    voice.isActive = true;
    voice.noteNumber = noteOn.getNoteNumber();
    voice.velocity = noteOn.getFloatVelocity();
    voice.age = m_globalVoiceAge++;
    
    juce::Logger::writeToLog("[VoiceManager] Assigned note " + juce::String(voice.noteNumber) + 
                            " to voice " + juce::String(voiceIndex));
}

void ModularSynthProcessor::releaseVoice(const juce::MidiMessage& noteOff)
{
    int noteNumber = noteOff.getNoteNumber();
    
    for (auto& voice : m_voices)
    {
        if (voice.isActive && voice.noteNumber == noteNumber)
        {
            voice.isActive = false;
            voice.noteNumber = -1;
            juce::Logger::writeToLog("[VoiceManager] Released note " + juce::String(noteNumber));
            return;
        }
    }
}

// === PROBE TOOL IMPLEMENTATION ===

void ModularSynthProcessor::setProbeConnection(const NodeID& sourceNodeID, int sourceChannel)
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
    {
        juce::Logger::writeToLog("[PROBE] ERROR: Probe scope not initialized!");
        return;
    }
    
    juce::Logger::writeToLog("[PROBE] setProbeConnection called. Source NodeID: " + juce::String(sourceNodeID.uid) + ", Channel: " + juce::String(sourceChannel));
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            juce::Logger::writeToLog("[PROBE] Cleared old probe connection.");
        }
    }
    
    bool success = connect(sourceNodeID, sourceChannel, probeScopeNodeId, 0);
    juce::Logger::writeToLog("[PROBE] New connection attempt " + juce::String(success ? "succeeded." : "FAILED."));
    if (success)
    {
        juce::Logger::writeToLog("[Probe] Successfully connected to probe scope");
    }
    else
    {
        juce::Logger::writeToLog("[Probe] ERROR: Failed to connect to probe scope");
    }
    
    commitChanges();
}

void ModularSynthProcessor::clearProbeConnection()
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
        return;
    
    juce::Logger::writeToLog("[PROBE] clearProbeConnection called.");
    bool cleared = false;
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            cleared = true;
        }
    }
    
    if (cleared) {
        juce::Logger::writeToLog("[PROBE] Cleared active probe connection.");
        commitChanges();
    } else {
        juce::Logger::writeToLog("[PROBE] No active probe connection to clear.");
    }
}

ModuleProcessor* ModularSynthProcessor::getProbeScopeProcessor() const
{
    if (!probeScopeNode)
        return nullptr;
    
    return dynamic_cast<ModuleProcessor*>(probeScopeNode->getProcessor());
}

================================================================================
FILE: juce\Source\audio\graph\VoiceProcessor.h
================================================================================


#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_dsp/juce_dsp.h>

class VoiceProcessor : public juce::AudioProcessor
{
public:
    VoiceProcessor();
    ~VoiceProcessor() override = default;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override final; // Final - cannot be overridden
    void releaseResources() override {}

    // Pure virtual method for subclasses to implement sound generation
    virtual void renderBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) = 0;

    const juce::String getName() const override { return "VoiceProcessor"; }
    bool isBusesLayoutSupported (const BusesLayout& layouts) const override
    {
        // Allow layouts where the input and output channel sets match (common for effects)
        // or where there is no input (for pure generators).
        if (layouts.getMainInputChannelSet() == layouts.getMainOutputChannelSet())
            return true;
            
        if (layouts.getMainInputChannelSet().isDisabled() && (layouts.getMainOutputChannelSet().size() == 1 || layouts.getMainOutputChannelSet().size() == 2))
            return true;
            
        return false;
    }
    // Implement all other necessary pure virtuals with empty bodies
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return ""; }
    void changeProgramName(int, const juce::String&) override {}
    void getStateInformation(juce::MemoryBlock&) override {}
    void setStateInformation(const void*, int) override {}

    juce::AudioProcessorValueTreeState& getAPVTS() { return apvts; }
    juce::uint64 uniqueId { 0 };

protected:
    juce::AudioProcessorValueTreeState apvts;

private:
    juce::dsp::StateVariableTPTFilter<float> filter;
    juce::dsp::Chorus<float>                 chorus;
    juce::dsp::Phaser<float>                 phaser;
    juce::dsp::Reverb                        reverb;
    juce::dsp::Compressor<float>             compressor;
    juce::dsp::Limiter<float>                limiter;
    juce::dsp::WaveShaper<float>             waveshaper;

    using DelayLine = juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear>;
    DelayLine                                   delayL { 192000 }, delayR { 192000 }; // up to ~2s @96k

    float gateEnvL { 1.0f }, gateEnvR { 1.0f };
    double currentSampleRate { 48000.0 };
    bool fxPrepared { false };
    juce::uint32 preparedChannels { 0 };
    juce::AudioBuffer<float>                 tempBuffer;
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VoiceProcessor)
};


================================================================================
FILE: juce\Source\audio\graph\VoiceProcessor.cpp
================================================================================


#include "VoiceProcessor.h"

VoiceProcessor::VoiceProcessor()
    : AudioProcessor(BusesProperties()
        .withInput("Input", juce::AudioChannelSet::stereo(), true)
        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "Parameters", createParameterLayout())
{}

void VoiceProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 2 };
    currentSampleRate = sampleRate;
    filter.reset();
    filter.prepare (spec);
    filter.setType (juce::dsp::StateVariableTPTFilterType::lowpass);
    chorus.reset();
    chorus.prepare (spec);
    phaser.reset();
    phaser.prepare (spec);
    reverb.reset();
    reverb.prepare (spec);
    compressor.reset();
    compressor.prepare (spec);
    limiter.reset();
    limiter.prepare (spec);
    waveshaper.reset();
    delayL.reset(); delayR.reset();
    {
        juce::dsp::ProcessSpec specMono { sampleRate, (juce::uint32) samplesPerBlock, 1 };
        delayL.prepare (specMono);
        delayR.prepare (specMono);
    }
    fxPrepared = true;
    preparedChannels = spec.numChannels;
}

void VoiceProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    // Generate raw sound directly into the provided buffer.
    buffer.clear();
    renderBlock(buffer, midi);

    // No logging on audio thread

    // Load all parameters at the top
    const float cutoff        = apvts.getRawParameterValue("filterCutoff")    ? apvts.getRawParameterValue("filterCutoff")->load()    : 20000.0f;
    const float resonance     = apvts.getRawParameterValue("filterResonance") ? apvts.getRawParameterValue("filterResonance")->load() : 1.0f;
    const float chorusRate    = apvts.getRawParameterValue("chorusRate")      ? apvts.getRawParameterValue("chorusRate")->load()      : 1.0f;
    const float chorusDepth   = apvts.getRawParameterValue("chorusDepth")     ? apvts.getRawParameterValue("chorusDepth")->load()     : 0.25f;
    const float chorusMix     = apvts.getRawParameterValue("chorusMix")       ? apvts.getRawParameterValue("chorusMix")->load()       : 0.5f;
    const float phaserRate    = apvts.getRawParameterValue("phaserRate")      ? apvts.getRawParameterValue("phaserRate")->load()      : 0.5f;
    const float phaserDepth   = apvts.getRawParameterValue("phaserDepth")     ? apvts.getRawParameterValue("phaserDepth")->load()     : 0.5f;
    const float phaserCentre  = apvts.getRawParameterValue("phaserCentre")    ? apvts.getRawParameterValue("phaserCentre")->load()    : 1000.0f;
    const float phaserFB      = apvts.getRawParameterValue("phaserFeedback")  ? apvts.getRawParameterValue("phaserFeedback")->load()  : 0.0f;
    const float phaserMix     = apvts.getRawParameterValue("phaserMix")       ? apvts.getRawParameterValue("phaserMix")->load()       : 0.0f;
    const float revRoom       = apvts.getRawParameterValue("reverbRoom")      ? apvts.getRawParameterValue("reverbRoom")->load()      : 0.0f;
    const float revDamp       = apvts.getRawParameterValue("reverbDamp")      ? apvts.getRawParameterValue("reverbDamp")->load()      : 0.5f;
    const float revWidth      = apvts.getRawParameterValue("reverbWidth")     ? apvts.getRawParameterValue("reverbWidth")->load()     : 1.0f;
    const float revMix        = apvts.getRawParameterValue("reverbMix")       ? apvts.getRawParameterValue("reverbMix")->load()       : 0.0f;
    const float delayMs       = apvts.getRawParameterValue("delayTimeMs")     ? apvts.getRawParameterValue("delayTimeMs")->load()     : 0.0f;
    const float delayFB       = apvts.getRawParameterValue("delayFeedback")   ? apvts.getRawParameterValue("delayFeedback")->load()   : 0.0f;
    const float delayMix      = apvts.getRawParameterValue("delayMix")        ? apvts.getRawParameterValue("delayMix")->load()        : 0.0f;
    const float compThresh    = apvts.getRawParameterValue("compThreshold")   ? apvts.getRawParameterValue("compThreshold")->load()   : 0.0f;
    const float compRatio     = apvts.getRawParameterValue("compRatio")       ? apvts.getRawParameterValue("compRatio")->load()       : 1.0f;
    const float compAttack    = apvts.getRawParameterValue("compAttackMs")    ? apvts.getRawParameterValue("compAttackMs")->load()    : 10.0f;
    const float compRelease   = apvts.getRawParameterValue("compReleaseMs")   ? apvts.getRawParameterValue("compReleaseMs")->load()   : 100.0f;
    const float compMakeup    = apvts.getRawParameterValue("compMakeup")      ? apvts.getRawParameterValue("compMakeup")->load()      : 0.0f;
    const float limitThresh   = apvts.getRawParameterValue("limitThreshold")  ? apvts.getRawParameterValue("limitThreshold")->load()  : 0.0f;
    const float limitRelease  = apvts.getRawParameterValue("limitReleaseMs")  ? apvts.getRawParameterValue("limitReleaseMs")->load()  : 10.0f;
    const float drive         = apvts.getRawParameterValue("driveAmount")     ? apvts.getRawParameterValue("driveAmount")->load()     : 0.0f;
    const float driveMix      = apvts.getRawParameterValue("driveMix")        ? apvts.getRawParameterValue("driveMix")->load()        : 0.0f;
    const float gateThresh    = apvts.getRawParameterValue("gateThreshold")   ? apvts.getRawParameterValue("gateThreshold")->load()   : -100.0f;
    const float gateAttack    = apvts.getRawParameterValue("gateAttackMs")    ? apvts.getRawParameterValue("gateAttackMs")->load()    : 1.0f;
    const float gateRelease   = apvts.getRawParameterValue("gateReleaseMs")   ? apvts.getRawParameterValue("gateReleaseMs")->load()   : 50.0f;

    // --- 2. Process FX: Filter then Chorus ---
    // Guard against unprepared FX or channel mismatch
    juce::dsp::AudioBlock<float> block (buffer);
    if (fxPrepared && preparedChannels > 0 && block.getNumChannels() > 0 && block.getNumChannels() == preparedChannels)
    {
        juce::dsp::ProcessContextReplacing<float> context (block);

        // Apply Filter only if non-neutral
        if (cutoff < 19900.0f || resonance > 1.0f)
        {
            filter.setCutoffFrequency (juce::jlimit (20.0f, 20000.0f, cutoff));
            filter.setResonance       (juce::jlimit (0.1f, 20.0f,   resonance));
            filter.process (context);
        }

        // Apply Chorus only if it has depth
        if (chorusDepth > 0.001f)
        {
            chorus.setRate  (juce::jlimit (0.05f, 5.0f, chorusRate));
            chorus.setDepth (juce::jlimit (0.0f, 1.0f,  chorusDepth));
            chorus.setMix   (juce::jlimit (0.0f, 1.0f,  chorusMix));
            chorus.process (context);
        }

        // Phaser
        if (phaserDepth > 0.001f || std::abs (phaserFB) > 0.001f)
        {
            phaser.setRate (juce::jlimit (0.01f, 10.0f, phaserRate));
            phaser.setDepth (juce::jlimit (0.0f, 1.0f, phaserDepth));
            phaser.setCentreFrequency (juce::jlimit (20.0f, 20000.0f, phaserCentre));
            phaser.setFeedback (juce::jlimit (-0.99f, 0.99f, phaserFB));
            if (phaserMix > 0.0f)
            {
                tempBuffer.makeCopyOf (buffer, true);
                juce::dsp::AudioBlock<float> tmp (tempBuffer);
                juce::dsp::ProcessContextReplacing<float> ctx (tmp);
                phaser.process (ctx);
                const float dry = 1.0f - phaserMix;
                const float wet = phaserMix;
                for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
                    buffer.addFrom (ch, 0, tempBuffer, ch, 0, buffer.getNumSamples(), wet - dry);
                buffer.applyGain (dry);
            }
            else
            {
                phaser.process (context);
            }
        }

        // Delay (simple stereo): process using dsp::DelayLine processSample to avoid state issues
        if (delayMix > 0.0f && delayMs > 0.0f)
        {
            const float maxDelaySamples = 4.0f * (float) currentSampleRate; // 4s safety
            const float delaySamples = juce::jlimit (1.0f, maxDelaySamples, delayMs * (float) currentSampleRate * 0.001f);
            const float fb = juce::jlimit (0.0f, 0.95f, delayFB);

            delayL.setDelay (delaySamples);
            delayR.setDelay (delaySamples);
            auto* l = buffer.getWritePointer (0);
            auto* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : l;

            const float dry = 1.0f - delayMix;
            const float wet = delayMix;
            for (int i = 0; i < buffer.getNumSamples(); ++i)
            {
                const float yl = delayL.popSample (0);
                const float yr = delayR.popSample (0);
                const float dlIn = juce::jlimit (-1.0f, 1.0f, l[i] + yl * fb);
                const float drIn = juce::jlimit (-1.0f, 1.0f, r[i] + yr * fb);
                delayL.pushSample (0, dlIn);
                delayR.pushSample (0, drIn);
                l[i] = l[i] * dry + yl * wet;
                r[i] = r[i] * dry + yr * wet;
            }
        }

        // Reverb
        if (revMix > 0.0f)
        {
            juce::dsp::Reverb::Parameters rp;
            rp.roomSize = juce::jlimit (0.0f, 1.0f, revRoom);
            rp.damping  = juce::jlimit (0.0f, 1.0f, revDamp);
            rp.width    = juce::jlimit (0.0f, 1.0f, revWidth);
            rp.wetLevel = juce::jlimit (0.0f, 1.0f, revMix);
            rp.dryLevel = 1.0f - rp.wetLevel;
            reverb.setParameters (rp);
            reverb.process (context);
        }

        // Drive (tanh) with dry/wet
        if (drive > 0.001f)
        {
            const float k = juce::jlimit (0.0f, 10.0f, drive) * 5.0f;
            tempBuffer.makeCopyOf (buffer, true);
            for (int ch = 0; ch < tempBuffer.getNumChannels(); ++ch)
            {
                auto* d = tempBuffer.getWritePointer (ch);
                for (int i = 0; i < tempBuffer.getNumSamples(); ++i)
                    d[i] = std::tanh (k * d[i]);
            }
            const float dry = juce::jlimit (0.0f, 1.0f, 1.0f - driveMix);
            const float wet = juce::jlimit (0.0f, 1.0f, driveMix);
            buffer.applyGain (dry);
            for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
                buffer.addFrom (ch, 0, tempBuffer, ch, 0, buffer.getNumSamples(), wet);
        }

        // Compressor
        if (compRatio > 1.0f)
        {
            compressor.setThreshold (juce::jlimit (-60.0f, 0.0f, compThresh));
            compressor.setRatio (juce::jmax (1.0f, compRatio));
            compressor.setAttack (juce::jlimit (0.1f, 200.0f, compAttack));
            compressor.setRelease (juce::jlimit (5.0f, 1000.0f, compRelease));
            juce::dsp::AudioBlock<float> b (buffer);
            juce::dsp::ProcessContextReplacing<float> c (b);
            compressor.process (c);
            if (std::abs (compMakeup) > 0.001f)
                buffer.applyGain (juce::Decibels::decibelsToGain (compMakeup));
        }

        // Limiter
        if (limitThresh < 0.0f)
        {
            limiter.setThreshold (juce::jlimit (-20.0f, 0.0f, limitThresh));
            limiter.setRelease (juce::jlimit (1.0f, 200.0f, limitRelease));
            juce::dsp::AudioBlock<float> b (buffer);
            juce::dsp::ProcessContextReplacing<float> c (b);
            limiter.process (c);
        }

        // Simple noise gate (post FX, pre gain) using envelope follower against dB threshold
        if (gateThresh > -90.0f)
        {
            const float thrLin = juce::Decibels::decibelsToGain (gateThresh);
            const float atk = juce::jlimit (0.001f, 0.5f, gateAttack * 0.001f);
            const float rel = juce::jlimit (0.001f, 2.0f, gateRelease * 0.001f);
            auto* l = buffer.getWritePointer (0);
            auto* r = buffer.getNumChannels() > 1 ? buffer.getWritePointer (1) : l;
            for (int i = 0; i < buffer.getNumSamples(); ++i)
            {
                const float mag = std::max (std::abs (l[i]), std::abs (r[i]));
                const float target = (mag >= thrLin) ? 1.0f : 0.0f;
                gateEnvL += (target - gateEnvL) * (target > gateEnvL ? atk : rel);
                gateEnvR = gateEnvL;
                l[i] *= gateEnvL;
                r[i] *= gateEnvR;
            }
        }
    }

    // --- Apply final Gain and Pan. ---
    const float gain = apvts.getRawParameterValue("gain") ? apvts.getRawParameterValue("gain")->load() : 0.7f;
    const float pan  = apvts.getRawParameterValue("pan")  ? apvts.getRawParameterValue("pan")->load()  : 0.0f;

    // Calculate left and right channel multipliers based on pan law
    const float panL = std::cos((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);
    const float panR = std::sin((pan + 1.0f) * juce::MathConstants<float>::pi * 0.25f);

    // Apply the master gain and the pan law separately for clarity and correctness.
    // First, apply the overall gain to all channels.
    buffer.applyGain(gain);

    // Then, apply the panning multipliers to their respective channels.
    buffer.applyGain(0, 0, buffer.getNumSamples(), panL);
    if (buffer.getNumChannels() > 1)
        buffer.applyGain(1, 0, buffer.getNumSamples(), panR);

    // Release diagnostics: append once in a while when silent
    {
        static int diagCounter = 0;
        if ((++diagCounter % 600) == 0)
        {
            const float mag = buffer.getMagnitude (0, buffer.getNumSamples());
            if (mag < 1.0e-6f)
            {
                juce::Logger::writeToLog ("[VoiceProcessor] silent block, gain=" + juce::String (gain) +
                                          " pan=" + juce::String (pan) +
                                          " ch=" + juce::String (buffer.getNumChannels()));
            }
        }
    }
}

juce::AudioProcessorValueTreeState::ParameterLayout VoiceProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    // Core Voice Params
    params.push_back(std::make_unique<juce::AudioParameterFloat>("gain", "Gain", 0.0f, 1.0f, 0.7f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("pan", "Pan", -1.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("frequency", "Frequency", 20.0f, 20000.0f, 440.0f));

    // --- FX PARAMS ---
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "filterCutoff", "Filter Cutoff",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 20000.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "filterResonance", "Filter Resonance",
        1.0f, 20.0f, 1.0f));

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusRate", "Chorus Rate",
        0.1f, 10.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusDepth", "Chorus Depth",
        0.0f, 1.0f, 0.25f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "chorusMix", "Chorus Mix",
        0.0f, 1.0f, 0.5f));

    // Phaser
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserRate", "Phaser Rate",
        0.01f, 10.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserDepth", "Phaser Depth",
        0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserCentre", "Phaser Centre",
        20.0f, 20000.0f, 1000.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserFeedback", "Phaser Feedback",
        -0.99f, 0.99f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "phaserMix", "Phaser Mix",
        0.0f, 1.0f, 0.0f));

    // Reverb
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbRoom", "Reverb Room",
        0.0f, 1.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbDamp", "Reverb Damping",
        0.0f, 1.0f, 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbWidth", "Reverb Width",
        0.0f, 1.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "reverbMix", "Reverb Mix",
        0.0f, 1.0f, 0.0f));

    // Delay
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayTimeMs", "Delay Time (ms)",
        1.0f, 2000.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayFeedback", "Delay Feedback",
        0.0f, 0.95f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "delayMix", "Delay Mix",
        0.0f, 1.0f, 0.0f));

    // Compressor
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compThreshold", "Comp Threshold (dB)",
        -60.0f, 0.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compRatio", "Comp Ratio",
        1.0f, 20.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compAttackMs", "Comp Attack (ms)",
        0.1f, 200.0f, 10.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compReleaseMs", "Comp Release (ms)",
        5.0f, 1000.0f, 100.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "compMakeup", "Comp Makeup (dB)",
        -12.0f, 12.0f, 0.0f));

    // Limiter
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "limitThreshold", "Limiter Threshold (dB)",
        -20.0f, 0.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "limitReleaseMs", "Limiter Release (ms)",
        1.0f, 200.0f, 10.0f));

    // Distortion / Drive
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "driveAmount", "Drive Amount",
        0.0f, 2.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "driveMix", "Drive Mix",
        0.0f, 1.0f, 0.0f));

    // Time/Pitch
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "timeStretchRatio", "Time Stretch Ratio",
        0.25f, 6.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitchSemitones", "Pitch Shift (Semitones)",
        -24.0f, 24.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "pitchRatio", "Pitch Ratio",
        0.5f, 2.0f, 1.0f));

    // Noise Gate
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateThreshold", "Gate Threshold (dB)",
        -80.0f, -20.0f, -100.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateAttackMs", "Gate Attack (ms)",
        0.1f, 50.0f, 1.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "gateReleaseMs", "Gate Release (ms)",
        5.0f, 500.0f, 50.0f));

    return { params.begin(), params.end() };
}

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <functional> // Required for std::function
#include <vector>
#include <map>
#include <unordered_map>
#include <atomic>

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#include <cmath>
#endif

// <<< TRANSPORT STATE FOR GLOBAL CLOCK >>>
// Transport state struct shared by all modules
struct TransportState {
    bool isPlaying = false;
    double bpm = 120.0;
    double songPositionBeats = 0.0;
    double songPositionSeconds = 0.0;
    // Optional global division broadcast from a master tempo/clock (-1 means inactive)
    std::atomic<int> globalDivisionIndex { -1 };
    // Flag to indicate if a Tempo Clock module is controlling the BPM (for UI feedback)
    std::atomic<bool> isTempoControlledByModule { false };
    
    // Custom copy constructor (atomics are not copyable by default)
    TransportState() = default;
    TransportState(const TransportState& other)
        : isPlaying(other.isPlaying)
        , bpm(other.bpm)
        , songPositionBeats(other.songPositionBeats)
        , songPositionSeconds(other.songPositionSeconds)
        , globalDivisionIndex(other.globalDivisionIndex.load())
        , isTempoControlledByModule(other.isTempoControlledByModule.load())
    {}
    
    // Custom copy assignment operator
    TransportState& operator=(const TransportState& other)
    {
        if (this != &other)
        {
            isPlaying = other.isPlaying;
            bpm = other.bpm;
            songPositionBeats = other.songPositionBeats;
            songPositionSeconds = other.songPositionSeconds;
            globalDivisionIndex.store(other.globalDivisionIndex.load());
            isTempoControlledByModule.store(other.isTempoControlledByModule.load());
        }
        return *this;
    }
};

// === RHYTHM REPORTING SYSTEM ===
// Allows modules to report their rhythmic timing for the BPM Monitor node

/**
 * Rhythm information reported by modules that produce rhythmic patterns
 */
struct RhythmInfo
{
    juce::String displayName;    // e.g., "Sequencer #3", "Animation: Walk Cycle"
    float bpm;                    // Current BPM (can be modulated live value)
    bool isActive;                // Is this source currently producing rhythm?
    bool isSynced;                // Is it synced to global transport?
    juce::String sourceType;      // "sequencer", "animation", "physics", etc.
    
    RhythmInfo() : bpm(0.0f), isActive(false), isSynced(false) {}
    RhythmInfo(const juce::String& name, float bpmValue, bool active, bool synced, const juce::String& type = "")
        : displayName(name), bpm(bpmValue), isActive(active), isSynced(synced), sourceType(type) {}
};

/**
 * Beat detection source (from audio input analysis)
 * Used by the BPM Monitor's tap tempo engine
 */
struct DetectedRhythmSource
{
    juce::String name;            // e.g., "Input 1 (Detected)"
    int inputChannel;             // Which input is being analyzed
    float detectedBPM;            // Calculated BPM from beat detection
    float confidence;             // 0.0-1.0 (how stable is the detection)
    bool isActive;                // Currently detecting beats?
    
    DetectedRhythmSource() : inputChannel(-1), detectedBPM(0.0f), confidence(0.0f), isActive(false) {}
};

// <<< MULTI-MIDI DEVICE SUPPORT >>>
// MIDI message with device source information
// This struct allows modules to filter MIDI by device and channel
struct MidiMessageWithDevice {
    juce::MidiMessage message;
    juce::String deviceIdentifier;
    juce::String deviceName;
    int deviceIndex = -1;
};

// <<< ALL PIN-RELATED DEFINITIONS ARE NOW CENTRALIZED HERE >>>

// Defines the data type of a modulation or audio signal
enum class PinDataType { CV, Audio, Gate, Raw, Video };

// Forward declare NodeWidth enum (defined in ImGuiNodeEditorComponent.h)
// This avoids circular dependency while allowing ModulePinInfo to store it
enum class NodeWidth;

// Describes a single audio/CV input or output pin
struct AudioPin
{
    juce::String name;
    int channel;
    PinDataType type;
    
    AudioPin(const juce::String& n, int ch, PinDataType t) : name(n), channel(ch), type(t) {}
};

// Renamed to avoid conflict with ImGuiNodeEditorComponent's PinInfo
struct DynamicPinInfo {
    juce::String name;
    int channel;
    PinDataType type;

    // Constructor to allow brace-initialization
    DynamicPinInfo(const juce::String& n, int c, PinDataType t) : name(n), channel(c), type(t) {}
};

// Describes a single modulation input pin targeting a parameter
struct ModPin
{
    juce::String name;
    juce::String paramId;
    PinDataType type;
    
    ModPin(const juce::String& n, const juce::String& p, PinDataType t) : name(n), paramId(p), type(t) {}
};

// A collection of all pins for a given module type
struct ModulePinInfo
{
    NodeWidth defaultWidth;  // Standardized node width category
    std::vector<AudioPin> audioIns;
    std::vector<AudioPin> audioOuts;
    std::vector<ModPin> modIns;
    
    ModulePinInfo() : defaultWidth(static_cast<NodeWidth>(0)) {}  // Default to Small (0)
    
    ModulePinInfo(NodeWidth width,
                  std::initializer_list<AudioPin> ins,
                  std::initializer_list<AudioPin> outs,
                  std::initializer_list<ModPin> mods)
        : defaultWidth(width), audioIns(ins), audioOuts(outs), modIns(mods) {}
};

// Forward declaration for NodePinHelpers
class ModuleProcessor;

// Helper struct passed to modules for drawing their pins
struct NodePinHelpers
{
    std::function<void(const char* label, int channel)> drawAudioInputPin;
    std::function<void(const char* label, int channel)> drawAudioOutputPin;
    std::function<void(const char* inLabel, int inChannel, const char* outLabel, int outChannel)> drawParallelPins;
    std::function<void(ModuleProcessor* module)> drawIoPins;
};

class ModularSynthProcessor; // forward declaration

/**
    An abstract base class for all modular synthesizer components.

    This class enforces a common interface for modules, ensuring they can be
    managed by the ModularSynthProcessor. The key requirement is providing access
    to the module's own parameter state via getAPVTS().
*/
class ModuleProcessor : public juce::AudioProcessor
{
public:
    ModuleProcessor(const BusesProperties& ioLayouts) : juce::AudioProcessor(ioLayouts) {}
    ~ModuleProcessor() override = default;

    // Parent container link (set by ModularSynthProcessor when node is created)
    void setParent(ModularSynthProcessor* parent) { parentSynth = parent; }
    ModularSynthProcessor* getParent() const { return parentSynth; }

    // Pure virtual method that all concrete modules MUST implement.
    // This is crucial for the parameter proxy system.
    virtual juce::AudioProcessorValueTreeState& getAPVTS() = 0;

    // Optional UI hook for drawing parameters inside nodes (used by Preset Creator)
    virtual void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
    {
        juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded);
    }

    // Optional UI hook for drawing IO pins inside nodes
    virtual void drawIoPins(const NodePinHelpers& /*helpers*/) {}

#if defined(PRESET_CREATOR_UI)
    // Optional UI hook for modules that need custom node dimensions (Exception size category)
    // Return ImVec2(width, height) for custom size, or ImVec2(0, 0) to use default from PinDatabase
    // Height of 0 means auto-size to content (recommended for most cases)
    virtual ImVec2 getCustomNodeSize() const 
    { 
        return ImVec2(0.0f, 0.0f); // Default: use PinDatabase size
    }
#endif


    // Get the current output value for a channel (for visualization)
    virtual float getOutputChannelValue(int channel) const
    {
        if (juce::isPositiveAndBelow(channel, (int)lastOutputValues.size()) && lastOutputValues[channel])
            return lastOutputValues[channel]->load();
        return 0.0f;
    }
    
    // Helper method to update output telemetry with peak magnitude
    // Call this at the end of processBlock to update visualization values
    void updateOutputTelemetry(const juce::AudioBuffer<float>& buffer)
    {
        const int numChannels = juce::jmin(buffer.getNumChannels(), (int)lastOutputValues.size());
        for (int ch = 0; ch < numChannels; ++ch)
        {
            if (lastOutputValues[ch])
            {
                // Use peak magnitude (max absolute value) for better visualization
                const float peak = buffer.getMagnitude(ch, 0, buffer.getNumSamples());
                lastOutputValues[ch]->store(peak, std::memory_order_relaxed);
            }
        }
    }

    // Standardized labels for module audio I/O channels (override per module if needed)
    virtual juce::String getAudioInputLabel(int channel) const
    {
        return juce::String("In ") + juce::String(channel + 1);
    }

    virtual juce::String getAudioOutputLabel(int channel) const
    {
        return juce::String("Out ") + juce::String(channel + 1);
    }

    // Stable logical ID assigned by ModularSynthProcessor upon node creation.
    void setLogicalId(juce::uint32 id) { storedLogicalId = id; }
    juce::uint32 getLogicalId() const { return storedLogicalId; }

    // Secondary logical ID for extra outputs (like cropped video from detector nodes)
    void setSecondaryLogicalId(juce::uint32 id) { storedSecondaryLogicalId = id; }
    juce::uint32 getSecondaryLogicalId() const { return storedSecondaryLogicalId; }

    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get detailed connection information for debugging
    virtual juce::String getConnectionDiagnostics() const
    {
        juce::String result = "=== CONNECTION DIAGNOSTICS ===\n";
        
        // Bus layout info
        result += "Input Buses: " + juce::String(getBusCount(true)) + "\n";
        result += "Output Buses: " + juce::String(getBusCount(false)) + "\n";
        
        for (int bus = 0; bus < getBusCount(true); ++bus)
        {
            auto busName = getBus(true, bus)->getName();
            auto numChannels = getBus(true, bus)->getNumberOfChannels();
            result += "  Input Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        for (int bus = 0; bus < getBusCount(false); ++bus)
        {
            auto busName = getBus(false, bus)->getName();
            auto numChannels = getBus(false, bus)->getNumberOfChannels();
            result += "  Output Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        return result;
    }
    
    // Get parameter routing diagnostics
    virtual juce::String getParameterRoutingDiagnostics() const
    {
        juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
        
        // Note: This method is const, so we can't access getAPVTS() directly
        // We'll return a placeholder for now
        result += "Parameter routing diagnostics require non-const access.\n";
        result += "Use getModuleDiagnostics() from ModularSynthProcessor instead.\n";
        
        return result;
    }
    
    // Get live parameter values for debugging
    virtual juce::String getLiveParameterDiagnostics() const
    {
        juce::String result = "=== LIVE PARAMETER VALUES ===\n";
        
        for (const auto& pair : paramLiveValues)
        {
            result += "  " + pair.first + ": " + juce::String(pair.second.load(), 4) + "\n";
        }
        
        return result;
    }
    
    // Get comprehensive module diagnostics
    virtual juce::String getAllDiagnostics() const
    {
        juce::String result = "=== MODULE DIAGNOSTICS ===\n";
        result += "Module Type: " + getName() + "\n\n";
        result += getConnectionDiagnostics() + "\n";
        result += getParameterRoutingDiagnostics() + "\n";
        result += getLiveParameterDiagnostics();
        return result;
    }


    /**
        Resolves a parameter's string ID to its modulation bus and channel.

        This is a virtual function that each module must override to declare which of its
        parameters can be modulated by an external signal. The function maps parameter IDs
        to their corresponding input bus and channel indices within that bus.

        @param paramId              The string ID of the parameter to query (e.g., "cutoff", "frequency").
        @param outBusIndex          Receives the index of the input bus used for modulation.
        @param outChannelIndexInBus Receives the channel index within that bus.
        @returns                    True if the parameter supports modulation, false otherwise.
        
        @see isParamInputConnected
    */
    virtual bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const;

    /**
        Checks if a parameter's modulation input is connected in the synth graph.

        This is the single, reliable method for a module's audio thread to determine
        if it should use an incoming CV signal instead of its internal parameter value.
        The function internally uses getParamRouting() to resolve the parameter to its
        bus/channel location, then queries the parent synth's connection graph.

        @param paramId The string ID of the parameter to check (e.g., "cutoff", "frequency").
        @returns       True if a cable is connected to this parameter's modulation input.
        
        @see getParamRouting
    */
    bool isParamInputConnected(const juce::String& paramId) const;

    // --- Live telemetry for UI (thread-safe, lock-free) ---
    void setLiveParamValue(const juce::String& paramId, float value)
    {
        auto result = paramLiveValues.try_emplace(paramId, value);
        if (!result.second)
            result.first->second.store(value, std::memory_order_relaxed);
    }

    float getLiveParamValue(const juce::String& paramId, float fallback) const
    {
        // FIX: Only return the "live" (modulated) value if the corresponding
        // modulation input is actually connected. Otherwise, always return the
        // fallback, which is the base parameter's real value.
        if (isParamInputConnected(paramId))
        {
            if (auto it = paramLiveValues.find(paramId); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // New helper: decouple the connectivity check (modParamId) from the live value key (liveKey).
    // This allows UI code to ask "is X_mod connected?" while reading the corresponding
    // live telemetry stored under a different key like "X_live".
    float getLiveParamValueFor(const juce::String& modParamId,
                               const juce::String& liveKey,
                               float fallback) const
    {
        if (isParamInputConnected(modParamId))
        {
            if (auto it = paramLiveValues.find(liveKey); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // Optional extra state hooks for modules that need to persist non-parameter data
    // Default: return invalid tree / ignore.
    virtual juce::ValueTree getExtraStateTree() const { return {}; }
    virtual void setExtraStateTree(const juce::ValueTree&) {}
    
    // Optional timing info hook for modules that need global clock/transport
    // Default: ignore (modules that don't need timing can skip implementing this)
    virtual void setTimingInfo(const TransportState& state) { juce::ignoreUnused(state); }
    
    // Optional rhythm reporting hook for BPM Monitor node
    // Modules that produce rhythmic patterns can implement this to report their BPM
    // Default: return empty (module doesn't produce rhythm)
    virtual std::optional<RhythmInfo> getRhythmInfo() const { return std::nullopt; }
    
    // Optional dynamic pin interface for modules with variable I/O (e.g., polyphonic modules)
    // Default: return empty vector (no dynamic pins)
    virtual std::vector<DynamicPinInfo> getDynamicInputPins() const { return {}; }
    virtual std::vector<DynamicPinInfo> getDynamicOutputPins() const { return {}; }
    
    /**
        Device-aware MIDI processing (MULTI-MIDI CONTROLLER SUPPORT)
        
        This method is called by ModularSynthProcessor BEFORE the standard graph processing
        begins. It provides MIDI modules with device-aware MIDI messages that include the
        source device information (name, identifier, index).
        
        MIDI modules should override this method to:
        - Filter messages by device (e.g., only respond to a specific controller)
        - Filter messages by MIDI channel
        - Update internal state based on filtered MIDI input
        
        The regular processBlock() can then use this updated state to generate CV outputs.
        
        @param midiMessages A vector of MIDI messages with device source information
        
        Default implementation: Does nothing (opt-in for MIDI modules only)
        
        @see MidiMessageWithDevice
    */
    virtual void handleDeviceSpecificMidi(const std::vector<MidiMessageWithDevice>& midiMessages)
    {
        juce::ignoreUnused(midiMessages);
        // Default: do nothing. MIDI-aware modules will override this method.
    }

public:
    // OPTION 9: Make public for TTS debugging
    // Live, modulated parameter values for UI feedback
    std::unordered_map<juce::String, std::atomic<float>> paramLiveValues;

protected:
    // Thread-safe storage for last known output values (for tooltips)
    std::vector<std::unique_ptr<std::atomic<float>>> lastOutputValues;

#if defined(PRESET_CREATOR_UI)

    static void adjustParamOnWheel (juce::RangedAudioParameter* parameter,
                                    const juce::String& idOrName,
                                    float displayedValue)
    {
        if (parameter == nullptr) return;
        if (! ImGui::IsItemHovered()) return;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel == 0.0f) return;

        if (auto* pf = dynamic_cast<juce::AudioParameterFloat*>(parameter))
        {
            // No right-click editing here; modules can add InputFloat next to sliders

            const auto& range = pf->range;
            const float span = range.end - range.start;
            const juce::String id = idOrName.toLowerCase();

            float step = span / 200.0f; // default ~0.5% of range
            if (span <= 1.0f) step = 0.01f;
            // Custom: fine tune for sequencer steps
            if (id.contains ("step"))
            {
                step = 0.05f;
            }
            if (id.contains ("hz") || id.contains ("freq") || id.contains ("cutoff") || id.contains ("rate"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (1.0f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("ms") || id.contains ("time"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (0.1f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("db") || id.contains ("gain"))
            {
                step = 0.5f;
            }
            else if (id.contains ("mix") || id.contains ("depth") || id.contains ("amount") || id.contains ("resonance") || id.contains ("q") || id.contains ("size") || id.contains ("damp") || id.contains ("pan") || id.contains ("threshold"))
            {
                step = 0.01f;
            }

            float newVal = pf->get() + (wheel > 0 ? step : -step);
            newVal = juce::jlimit (range.start, range.end, newVal);
            *pf = newVal;
        }
        else if (auto* pc = dynamic_cast<juce::AudioParameterChoice*>(parameter))
        {
            int idx = pc->getIndex();
            idx += (ImGui::GetIO().MouseWheel > 0 ? 1 : -1);
            idx = juce::jlimit (0, pc->choices.size() - 1, idx);
            *pc = idx;
        }
        else if (auto* pi = dynamic_cast<juce::AudioParameterInt*>(parameter))
        {
            int currentVal = pi->get();
            int newVal = currentVal + (wheel > 0 ? 1 : -1);
            const auto& range = pi->getNormalisableRange();
            newVal = juce::jlimit((int)range.start, (int)range.end, newVal);
            *pi = newVal;
        }
        else if (auto* pb = dynamic_cast<juce::AudioParameterBool*>(parameter))
        {
            // Optional: toggle on strong scroll
            juce::ignoreUnused (pb);
        }
    }

#endif

public:
    //==============================================================================
    // Helper function to convert bus index and channel-in-bus to absolute channel index
    //==============================================================================
    int getChannelIndexInProcessBlockBuffer(bool isInput, int busIndex, int channelIndexInBus) const
    {
        int absoluteChannel = channelIndexInBus;
        if (busIndex > 0)
        {
            int sum = 0;
            const int numBuses = getBusCount(isInput);
            for (int b = 0; b < numBuses && b < busIndex; ++b)
                sum += getChannelCountOfBus(isInput, b);
            absoluteChannel = sum + channelIndexInBus;
        }
        return absoluteChannel;
    }

    //==============================================================================
    // Provide default implementations for the pure virtuals to reduce boilerplate
    // in concrete module classes.
    //==============================================================================
    const juce::String getName() const override { return "Module"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModuleProcessor)

protected:
    ModularSynthProcessor* parentSynth { nullptr };
    juce::uint32 storedLogicalId { 0 };
    juce::uint32 storedSecondaryLogicalId { 0 };
};

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.cpp
================================================================================


#include "ModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <unordered_set>


bool ModuleProcessor::getParamRouting(const juce::String& /*paramId*/, int& /*outBusIndex*/, int& /*outChannelIndexInBus*/) const
{
    return false;
}

bool ModuleProcessor::isParamInputConnected(const juce::String& paramId) const
{
    auto* synth = parentSynth;
    if (synth == nullptr)
        return false;

    juce::uint32 myLogicalId = storedLogicalId;
    if (myLogicalId == 0)
    {
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical (info.first) == this)
            {
                myLogicalId = info.first;
                break;
            }
        }
        if (myLogicalId == 0)
            return false;
    }

    int busIndex = -1;
    int chanInBus = -1;
    if (!getParamRouting(paramId, busIndex, chanInBus))
        return false;

    int absoluteChannel = chanInBus;
    if (busIndex > 0)
    {
        int sum = 0;
        const int numInputBuses = getBusCount(true);
        for (int b = 0; b < numInputBuses && b < busIndex; ++b)
            sum += getChannelCountOfBus(true, b);
        absoluteChannel = sum + chanInBus;
    }

    for (const auto& c : synth->getConnectionsInfo())
        if (c.dstLogicalId == myLogicalId && c.dstChan == absoluteChannel)
            return true;

    // Fallback: if stored logicalId yields no match, re-resolve by pointer and retry once.
    {
        juce::uint32 ptrResolvedId = 0;
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical(info.first) == this)
            {
                ptrResolvedId = info.first;
                break;
            }
        }
        if (ptrResolvedId != 0 && ptrResolvedId != myLogicalId)
        {
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == ptrResolvedId && c.dstChan == absoluteChannel)
                {
                    const_cast<ModuleProcessor*>(this)->setLogicalId(ptrResolvedId);
                    return true;
                }
            }
        }
    }

    return false;
}


================================================================================
FILE: juce\Source\audio\modules\TempoClockModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class TempoClockModuleProcessor : public ModuleProcessor
{
public:
    TempoClockModuleProcessor();
    ~TempoClockModuleProcessor() override = default;

    // Parameter IDs for APVTS
    static constexpr auto paramIdBpm              = "bpm";
    static constexpr auto paramIdSwing            = "swing";
    static constexpr auto paramIdDivision         = "division";
    static constexpr auto paramIdGateWidth        = "gateWidth";
    static constexpr auto paramIdSyncToHost       = "syncToHost";
    static constexpr auto paramIdDivisionOverride = "divisionOverride";

    // Virtual modulation/control input IDs (no APVTS parameters required)
    static constexpr auto paramIdBpmMod       = "bpm_mod";
    static constexpr auto paramIdTapMod       = "tap_mod";
    static constexpr auto paramIdNudgeUpMod   = "nudge_up_mod";
    static constexpr auto paramIdNudgeDownMod = "nudge_down_mod";
    static constexpr auto paramIdPlayMod      = "play_mod";
    static constexpr auto paramIdStopMod      = "stop_mod";
    static constexpr auto paramIdResetMod     = "reset_mod";
    static constexpr auto paramIdSwingMod     = "swing_mod";

    const juce::String getName() const override { return "tempo_clock"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void setTimingInfo(const TransportState& state) override { m_currentTransport = state; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

    // Parameter bus contract (virtual modulation IDs)
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

    juce::String getAudioInputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "BPM Mod";
            case 1: return "Tap";
            case 2: return "Nudge+";
            case 3: return "Nudge-";
            case 4: return "Play";
            case 5: return "Stop";
            case 6: return "Reset";
            case 7: return "Swing Mod";
            default: return juce::String("In ") + juce::String(channel + 1);
        }
    }

    juce::String getAudioOutputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "Clock";
            case 1: return "Beat Trig";
            case 2: return "Bar Trig";
            case 3: return "Beat Gate";
            case 4: return "Phase";
            case 5: return "BPM CV";
            case 6: return "Downbeat";
            default: return juce::String("Out ") + juce::String(channel + 1);
        }
    }

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    // Parameters
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* bpmParam { nullptr };
    std::atomic<float>* swingParam { nullptr };
    std::atomic<float>* divisionParam { nullptr };
    std::atomic<float>* gateWidthParam { nullptr };
    std::atomic<float>* syncToHostParam { nullptr };
    std::atomic<float>* divisionOverrideParam { nullptr };

    // Transport cache for per-block start
    TransportState m_currentTransport;

    // Internal state for tap/nudge and trigger edge detection
    double sampleRateHz { 0.0 };
    int lastBeatIndex { 0 };
    int lastBarIndex { 0 };
    double lastScaledBeats { 0.0 };
    bool lastPlayHigh { false };
    bool lastStopHigh { false };
    bool lastResetHigh { false };
    bool lastTapHigh { false };
    bool lastNudgeUpHigh { false };
    bool lastNudgeDownHigh { false };
    double samplesSinceLastTap { 0.0 };
    bool hasPreviousTap { false };  // Track if we have a valid previous tap for BPM calculation
    
    // UI tap button state (for GUI thread to trigger taps)
    std::atomic<double> uiTapTimestamp { 0.0 };  // Timestamp of last UI tap (in seconds)
    double lastProcessedUiTap { 0.0 };  // Last tap timestamp we've processed (audio thread)
};




================================================================================
FILE: juce\Source\audio\modules\TempoClockModuleProcessor.cpp
================================================================================


#include "TempoClockModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"

TempoClockModuleProcessor::TempoClockModuleProcessor()
    : ModuleProcessor(BusesProperties()
          .withInput("Mods", juce::AudioChannelSet::discreteChannels(8), true)    // bpm,tap,nudge+,nudge-,play,stop,reset,swing
          .withOutput("Clock", juce::AudioChannelSet::discreteChannels(7), true)), // clock, beatTrig, barTrig, beatGate, phase, bpmCv, downbeat
      apvts(*this, nullptr, "TempoClockParams", createParameterLayout())
{
    bpmParam = apvts.getRawParameterValue(paramIdBpm);
    swingParam = apvts.getRawParameterValue(paramIdSwing);
    divisionParam = apvts.getRawParameterValue(paramIdDivision);
    gateWidthParam = apvts.getRawParameterValue(paramIdGateWidth);
    syncToHostParam = apvts.getRawParameterValue(paramIdSyncToHost);
    divisionOverrideParam = apvts.getRawParameterValue(paramIdDivisionOverride);
}

juce::AudioProcessorValueTreeState::ParameterLayout TempoClockModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdBpm, "BPM", juce::NormalisableRange<float>(20.0f, 300.0f, 0.01f, 0.3f), 120.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSwing, "Swing", juce::NormalisableRange<float>(0.0f, 0.75f, 0.0f, 1.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterChoice>(paramIdDivision, "Division", juce::StringArray{"1/32","1/16","1/8","1/4","1/2","1","2","4"}, 3));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdGateWidth, "Gate Width", juce::NormalisableRange<float>(0.01f, 0.99f, 0.0f, 1.0f), 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdSyncToHost, "Sync to Host", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdDivisionOverride, "Division Override", false));
    return { params.begin(), params.end() };
}

void TempoClockModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    sampleRateHz = sampleRate;
}

void TempoClockModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    const int numSamples = buffer.getNumSamples();
    if (numSamples <= 0 || sampleRateHz <= 0.0)
        return;
    
    // FIX: DON'T clear output buffer yet - it might alias with input buffer!
    // We'll write to all output channels explicitly, so no need to clear.

    // Read CV inputs ONLY if connected (BestPractice/TTS pattern)
    const bool bpmMod = isParamInputConnected(paramIdBpmMod);
    const bool tapMod = isParamInputConnected(paramIdTapMod);
    const bool nudgeUpMod = isParamInputConnected(paramIdNudgeUpMod);
    const bool nudgeDownMod = isParamInputConnected(paramIdNudgeDownMod);
    const bool playMod = isParamInputConnected(paramIdPlayMod);
    const bool stopMod = isParamInputConnected(paramIdStopMod);
    const bool resetMod = isParamInputConnected(paramIdResetMod);
    const bool swingMod = isParamInputConnected(paramIdSwingMod);

    const float* bpmCV       = (bpmMod       && in.getNumChannels() > 0) ? in.getReadPointer(0) : nullptr;
    const float* tapCV       = (tapMod       && in.getNumChannels() > 1) ? in.getReadPointer(1) : nullptr;
    const float* nudgeUpCV   = (nudgeUpMod   && in.getNumChannels() > 2) ? in.getReadPointer(2) : nullptr;
    const float* nudgeDownCV = (nudgeDownMod && in.getNumChannels() > 3) ? in.getReadPointer(3) : nullptr;
    const float* playCV      = (playMod      && in.getNumChannels() > 4) ? in.getReadPointer(4) : nullptr;
    const float* stopCV      = (stopMod      && in.getNumChannels() > 5) ? in.getReadPointer(5) : nullptr;
    const float* resetCV     = (resetMod     && in.getNumChannels() > 6) ? in.getReadPointer(6) : nullptr;
    const float* swingCV     = (swingMod     && in.getNumChannels() > 7) ? in.getReadPointer(7) : nullptr;

    float bpm = bpmParam->load();
    
    // FIX: Set flag when BPM comes from CV so other sources won't override it (MultiBandShaper pattern)
    bool bpmFromCV = false;
    if (bpmCV)
    {
        const float cv = juce::jlimit(0.0f, 1.0f, bpmCV[0]);
        // Map 0..1 -> 20..300 with perceptual curve
        bpm = juce::jmap(std::pow(cv, 0.3f), 0.0f, 1.0f, 20.0f, 300.0f);
        bpmFromCV = true;
    }

    float swing = swingParam ? swingParam->load() : 0.0f;
    if (swingCV)
        swing = juce::jlimit(0.0f, 0.75f, swingCV[0]);

    // Increment tap counter each block (if we're waiting for a second tap)
    if (hasPreviousTap)
    {
        samplesSinceLastTap += numSamples;
    }

    // Handle edge controls (play/stop/reset/tap/nudge)
    // FIX: Only allow these to modify BPM if CV is NOT connected
    auto edge = [&](const float* cv, bool& last){ bool now = (cv && cv[0] > 0.5f); bool rising = now && !last; last = now; return rising; };
    if (edge(playCV, lastPlayHigh))   if (auto* p = getParent()) p->setPlaying(true);
    if (edge(stopCV, lastStopHigh))   if (auto* p = getParent()) p->setPlaying(false);
    if (edge(resetCV, lastResetHigh)) if (auto* p = getParent()) p->resetTransportPosition();
    
    // TAP TEMPO (CV Input): Calculate BPM from interval between taps (ONLY if BPM CV not connected)
    bool tapDetected = false;
    if (!bpmFromCV && edge(tapCV, lastTapHigh))
    {
        tapDetected = true;
    }
    
    // TAP TEMPO (UI Button): Detect if UI button was pressed
    if (!bpmFromCV)
    {
        const double currentUiTap = uiTapTimestamp.load();
        if (currentUiTap != lastProcessedUiTap && currentUiTap > 0.0)
        {
            tapDetected = true;
            lastProcessedUiTap = currentUiTap;
        }
    }
    
    // Process tap (from CV or UI button)
    if (tapDetected)
    {
        if (hasPreviousTap && samplesSinceLastTap > 0.0)
        {
            // Calculate BPM from time between taps
            const double secondsBetweenTaps = samplesSinceLastTap / sampleRateHz;
            
            // Sanity check: prevent extreme values (20-300 BPM range)
            // Min interval: 0.2 seconds (300 BPM), Max interval: 3.0 seconds (20 BPM)
            if (secondsBetweenTaps >= 0.2 && secondsBetweenTaps <= 3.0)
            {
                float newBPM = 60.0f / static_cast<float>(secondsBetweenTaps);
                bpm = juce::jlimit(20.0f, 300.0f, newBPM);
                
                // Update the parameter so it persists
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdBpm)))
                    *p = bpm;
                
                juce::Logger::writeToLog("[TempoClock] Tap tempo: " + 
                    juce::String(secondsBetweenTaps, 3) + "s interval = " + 
                    juce::String(bpm, 1) + " BPM");
            }
        }
        
        // Reset counter and mark that we have a valid tap
        samplesSinceLastTap = 0.0;
        hasPreviousTap = true;
    }
    
    // TAP TIMEOUT: Reset if no tap for 4 seconds
    if (hasPreviousTap && samplesSinceLastTap > sampleRateHz * 4.0)
    {
        hasPreviousTap = false;
        samplesSinceLastTap = 0.0;
    }
    
    // NUDGE: Only allow if BPM CV not connected
    if (!bpmFromCV)
    {
        if (edge(nudgeUpCV, lastNudgeUpHigh))   { bpm = juce::jlimit(20.0f, 300.0f, bpm + 0.5f); }
        if (edge(nudgeDownCV, lastNudgeDownHigh)) { bpm = juce::jlimit(20.0f, 300.0f, bpm - 0.5f); }
    }

    // Sync to Host: Use host transport tempo OR control it
    // FIX: BPM CV always takes priority over sync-to-host
    bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;
    if (auto* parent = getParent())
    {
        if (syncToHost && !bpmFromCV)  // FIX: Only sync from host if BPM CV is NOT connected
        {
            // Pull tempo FROM host transport (Tempo Clock follows)
            bpm = (float)m_currentTransport.bpm;
            parent->setTempoControlledByModule(false);  // Not controlling
        }
        else
        {
            // Push tempo TO host transport (Tempo Clock controls the global BPM)
            // This includes: manual BPM, BPM CV, tap tempo, and nudge
            parent->setBPM(bpm);
            parent->setTempoControlledByModule(true);  // Controlling - UI should be greyed
        }
    }
    
    // Publish live telemetry AFTER all BPM sources resolved (including sync)
    setLiveParamValue("bpm_live", bpm);
    setLiveParamValue("swing_live", swing);

    // Compute outputs
    float* clockOut = out.getNumChannels() > 0 ? out.getWritePointer(0) : nullptr;
    float* beatTrig = out.getNumChannels() > 1 ? out.getWritePointer(1) : nullptr;
    float* barTrig  = out.getNumChannels() > 2 ? out.getWritePointer(2) : nullptr;
    float* beatGate = out.getNumChannels() > 3 ? out.getWritePointer(3) : nullptr;
    float* phaseOut = out.getNumChannels() > 4 ? out.getWritePointer(4) : nullptr;
    float* bpmOut   = out.getNumChannels() > 5 ? out.getWritePointer(5) : nullptr;
    float* downbeat = out.getNumChannels() > 6 ? out.getWritePointer(6) : nullptr;

    int divisionIdx = divisionParam ? (int)divisionParam->load() : 3; // default 1/4
    
    // Division Override: Broadcast local division to global transport OR clear it
    bool divisionOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
    if (auto* parent = getParent())
    {
        if (divisionOverride)
        {
            // This clock becomes the master division source
            parent->setGlobalDivisionIndex(divisionIdx);
        }
        else
        {
            // Not overriding - clear the global division
            parent->setGlobalDivisionIndex(-1);
        }
    }
    static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0 };
    const double div = divisions[juce::jlimit(0, 7, divisionIdx)];

    // Use transport position + per-sample advancement to produce stable clock
    double sr = juce::jmax(1.0, sampleRateHz);
    double localBeatsStart = m_currentTransport.songPositionBeats;
    double phaseBeats = localBeatsStart;

    for (int i = 0; i < numSamples; ++i)
    {
        // Advance beats using current bpm
        phaseBeats += (1.0 / sr) * (bpm / 60.0);

        // Subdivision phase
        const double scaled = phaseBeats * div;
        const double frac = scaled - std::floor(scaled);

        if (phaseOut) phaseOut[i] = (float) frac;
        if (clockOut) clockOut[i] = frac < 0.01 ? 1.0f : 0.0f;
        if (bpmOut) bpmOut[i] = juce::jmap(bpm, 20.0f, 300.0f, 0.0f, 1.0f);

        // Beat/bar triggers from integer boundaries
        const int beatIndex = (int) std::floor(phaseBeats);
        const int barIndex = beatIndex / 4;
        if (beatTrig) beatTrig[i] = (beatIndex > lastBeatIndex) ? 1.0f : 0.0f;
        if (barTrig)  barTrig[i]  = (barIndex > lastBarIndex)   ? 1.0f : 0.0f;
        if (downbeat) downbeat[i] = (beatIndex > lastBeatIndex && (beatIndex % 4) == 0) ? 1.0f : 0.0f;

        // Gate width within subdivision
        const float gw = gateWidthParam ? gateWidthParam->load() : 0.5f;
        if (beatGate) beatGate[i] = (float)(frac < gw ? 1.0 : 0.0);

        lastBeatIndex = beatIndex;
        lastBarIndex = barIndex;
    }

    // Telemetry and meter
    setLiveParamValue("phase_live", (float)(phaseBeats - std::floor(phaseBeats)));
    if (!lastOutputValues.empty())
    {
        if (!lastOutputValues[0]) lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
        if (lastOutputValues[0]) lastOutputValues[0]->store(out.getNumChannels() > 0 ? out.getSample(0, numSamples - 1) : 0.0f);
    }
}

// Parameter routing: virtual IDs on single input bus
bool TempoClockModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0;
    if (paramId == paramIdBpmMod) { outChannelIndexInBus = 0; return true; }
    if (paramId == paramIdTapMod) { outChannelIndexInBus = 1; return true; }
    if (paramId == paramIdNudgeUpMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdNudgeDownMod) { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdPlayMod) { outChannelIndexInBus = 4; return true; }
    if (paramId == paramIdStopMod) { outChannelIndexInBus = 5; return true; }
    if (paramId == paramIdResetMod) { outChannelIndexInBus = 6; return true; }
    if (paramId == paramIdSwingMod) { outChannelIndexInBus = 7; return true; }
    return false;
}

#if defined(PRESET_CREATOR_UI)
void TempoClockModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth(itemWidth);
    
    // Helper for tooltips
    auto HelpMarkerClock = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    // === TEMPO CONTROLS SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Tempo");
    ImGui::Spacing();

    // BPM slider with live display
    bool bpmMod = isParamInputConnected(paramIdBpmMod);  // FIX: Use isParamInputConnected, not isParamModulated
    float bpm = bpmMod ? getLiveParamValueFor(paramIdBpmMod, "bpm_live", bpmParam->load()) : bpmParam->load();
    bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;
    
    // Disable BPM control if synced to host
    if (bpmMod || syncToHost) { ImGui::BeginDisabled(); }
    if (ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f, "%.1f"))
    {
        if (!bpmMod && !syncToHost)
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdBpm))) *p = bpm;
        }
        onModificationEnded();
    }
    if (!bpmMod && !syncToHost) adjustParamOnWheel(apvts.getParameter(paramIdBpm), paramIdBpm, bpm);
    if (bpmMod) { ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    if (syncToHost) { ImGui::SameLine(); ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.8f, 1.0f), "(synced)"); }
    if (bpmMod || syncToHost) { ImGui::EndDisabled(); }
    ImGui::SameLine();
    HelpMarkerClock("Beats per minute (20-300 BPM)\nDisabled when synced to host");
    
    // TAP TEMPO BUTTON
    if (bpmMod || syncToHost) { ImGui::BeginDisabled(); }
    if (ImGui::Button("TAP", ImVec2(itemWidth * 0.3f, 30)))
    {
        // Record tap timestamp (audio thread will detect the change)
        uiTapTimestamp.store(juce::Time::getMillisecondCounterHiRes() / 1000.0);
    }
    if (bpmMod || syncToHost) { ImGui::EndDisabled(); }
    ImGui::SameLine();
    HelpMarkerClock("Click repeatedly to set tempo by tapping\nTap at least twice to calculate BPM");

    // Swing
    bool swingM = isParamInputConnected(paramIdSwingMod);  // FIX: Use isParamInputConnected, not isParamModulated
    float swing = swingM ? getLiveParamValueFor(paramIdSwingMod, "swing_live", swingParam->load()) : swingParam->load();
    if (swingM) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Swing", &swing, 0.0f, 0.75f, "%.2f"))
    {
        if (!swingM)
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdSwing))) *p = swing;
        }
        onModificationEnded();
    }
    if (!swingM) adjustParamOnWheel(apvts.getParameter(paramIdSwing), paramIdSwing, swing);
    if (swingM) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerClock("Swing amount (0-75%)\nDelays every other beat for shuffle feel");

    ImGui::Spacing();
    ImGui::Spacing();

    // === CLOCK OUTPUT SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Clock Output");
    ImGui::Spacing();

    // Division + Gate width in-line
    int div = divisionParam ? (int)divisionParam->load() : 3;
    const char* items[] = { "1/32","1/16","1/8","1/4","1/2","1","2","4" };
    ImGui::SetNextItemWidth(itemWidth * 0.5f);
    if (ImGui::Combo("Division", &div, items, 8))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter(paramIdDivision))) *p = div;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Clock output division\n1/4 = quarter notes, 1/16 = sixteenth notes");

    float gw = gateWidthParam ? gateWidthParam->load() : 0.5f;
    ImGui::SetNextItemWidth(itemWidth);
    if (ImGui::SliderFloat("Gate Width", &gw, 0.01f, 0.99f, "%.2f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdGateWidth))) *p = gw;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Gate/trigger pulse width (1-99%)");

    ImGui::Spacing();
    ImGui::Spacing();

    // === LIVE CLOCK DISPLAY SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Clock Status");
    ImGui::Spacing();

    // Animated beat indicator (4 boxes for 4/4 time)
    float phase = getLiveParamValue("phase_live", 0.0f);
    int currentBeat = (int)(phase * 4.0f) % 4;
    
    for (int i = 0; i < 4; ++i)
    {
        if (i > 0) ImGui::SameLine();
        
        bool isCurrentBeat = (currentBeat == i);
        ImVec4 color = isCurrentBeat ? ImVec4(1.0f, 0.3f, 0.3f, 1.0f) : ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        
        ImGui::PushStyleColor(ImGuiCol_Button, color);
        ImGui::Button(juce::String(i + 1).toRawUTF8(), ImVec2(itemWidth * 0.23f, 30));
        ImGui::PopStyleColor();
    }

    // Current BPM display (large, colored)
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.0f, 0.7f, 1.0f));
    ImGui::Text("‚ô© = %.1f BPM", getLiveParamValue("bpm_live", bpm));
    ImGui::PopStyleColor();

    // Bar:Beat display
    int bar = (int)(phase / 4.0f) + 1;
    int beat = currentBeat + 1;
    ImGui::Text("Bar %d | Beat %d", bar, beat);

    ImGui::Spacing();
    ImGui::Spacing();

    // === TRANSPORT SYNC SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Transport Sync");
    ImGui::Spacing();

    // Sync to Host checkbox
    bool sync = syncToHost;
    if (ImGui::Checkbox("Sync to Host", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(paramIdSyncToHost))) *p = sync;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Follow host transport tempo\nDisables manual BPM control when enabled");
    
    if (sync)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 1.0f, 0.8f, 1.0f));
        ImGui::Text("‚ö° SYNCED TO HOST TRANSPORT");
        ImGui::PopStyleColor();
    }
    
    ImGui::Spacing();
    
    // Division Override checkbox
    bool divOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
    if (ImGui::Checkbox("Division Override", &divOverride))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(paramIdDivisionOverride))) *p = divOverride;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Broadcast this clock's division globally\nForces all synced modules to follow this clock's subdivision");
    
    if (divOverride)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.2f, 1.0f));
        ImGui::Text("‚ö° MASTER DIVISION SOURCE");
        ImGui::PopStyleColor();
    }

    ImGui::PopItemWidth();
}

void TempoClockModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("BPM Mod", 0);
    helpers.drawAudioInputPin("Tap", 1);
    helpers.drawAudioInputPin("Nudge+", 2);
    helpers.drawAudioInputPin("Nudge-", 3);
    helpers.drawAudioInputPin("Play", 4);
    helpers.drawAudioInputPin("Stop", 5);
    helpers.drawAudioInputPin("Reset", 6);
    helpers.drawAudioInputPin("Swing Mod", 7);

    helpers.drawAudioOutputPin("Clock", 0);
    helpers.drawAudioOutputPin("Beat Trig", 1);
    helpers.drawAudioOutputPin("Bar Trig", 2);
    helpers.drawAudioOutputPin("Beat Gate", 3);
    helpers.drawAudioOutputPin("Phase", 4);
    helpers.drawAudioOutputPin("BPM CV", 5);
    helpers.drawAudioOutputPin("Downbeat", 6);
}
#endif




================================================================================
FILE: juce\Source\audio\modules\SnapshotSequencerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "../../ipc/CommandBus.h"
#include <array>

class SnapshotSequencerModuleProcessor : public ModuleProcessor
{
public:
    SnapshotSequencerModuleProcessor();
    ~SnapshotSequencerModuleProcessor() override = default;

    const juce::String getName() const override { return "snapshot_sequencer"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // Public API for UI to capture and manage snapshots
    void setSnapshotForStep(int stepIndex, const juce::MemoryBlock& state);
    const juce::MemoryBlock& getSnapshotForStep(int stepIndex) const;
    void clearSnapshotForStep(int stepIndex);
    bool isSnapshotStored(int stepIndex) const;
    
    // Set the CommandBus pointer so we can enqueue LoadPatchState commands
    void setCommandBus(CommandBus* bus) { commandBus = bus; }
    
    // Get parent voice ID (needed for command routing)
    juce::uint64 getParentVoiceId() const { return parentVoiceId; }
    void setParentVoiceId(juce::uint64 id) { parentVoiceId = id; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;

    void drawIoPins(const NodePinHelpers& helpers) override
    {
        helpers.drawAudioInputPin("Clock", 0);
        helpers.drawAudioInputPin("Reset", 1);
    }

    juce::String getAudioInputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "Clock";
            case 1: return "Reset";
            default: return juce::String("In ") + juce::String(channel + 1);
        }
    }

    juce::String getAudioOutputLabel(int channel) const override
    {
        return ""; // No audio outputs
    }
#endif

    // State persistence
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree& tree) override;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;

    // Parameters
    std::atomic<float>* numStepsParam { nullptr };
    
    // Snapshot storage (16 steps maximum)
    static constexpr int MAX_STEPS = 16;
    std::array<juce::MemoryBlock, MAX_STEPS> snapshots;
    
    // Sequencer state
    std::atomic<int> currentStep { 0 };
    double sampleRate { 44100.0 };
    
    // Clock detection
    bool lastClockHigh { false };
    bool lastResetHigh { false };
    
    // Command bus for triggering patch loads
    CommandBus* commandBus { nullptr };
    juce::uint64 parentVoiceId { 0 };

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SnapshotSequencerModuleProcessor)
};



================================================================================
FILE: juce\Source\audio\modules\SnapshotSequencerModuleProcessor.cpp
================================================================================


#include "SnapshotSequencerModuleProcessor.h"

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#endif

SnapshotSequencerModuleProcessor::SnapshotSequencerModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        .withInput ("Input", juce::AudioChannelSet::stereo(), true)
                        .withOutput("Output", juce::AudioChannelSet::mono(), true)), // Dummy output
      apvts (*this, nullptr, "SnapshotSeqParams", createParameterLayout())
{
    numStepsParam = apvts.getRawParameterValue ("numSteps");
    
    // Initialize empty snapshots
    for (auto& snapshot : snapshots)
    {
        snapshot.reset();
    }
    
    // Inspector value tracking (no outputs to track)
    lastOutputValues.clear();
}

juce::AudioProcessorValueTreeState::ParameterLayout SnapshotSequencerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps", "Num Steps", 1, MAX_STEPS, 8));
    
    return { params.begin(), params.end() };
}

void SnapshotSequencerModuleProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sampleRate = newSampleRate > 0.0 ? newSampleRate : 44100.0;
    currentStep.store(0);
    lastClockHigh = false;
    lastResetHigh = false;
}

void SnapshotSequencerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    
    if (numStepsParam == nullptr)
    {
        buffer.clear();
        return;
    }

    const int numSamples = buffer.getNumSamples();
    const int numSteps = juce::jlimit(1, MAX_STEPS, (int)numStepsParam->load());
    
    // Get clock and reset inputs
    const bool hasClockInput = buffer.getNumChannels() > 0;
    const bool hasResetInput = buffer.getNumChannels() > 1;
    
    const float* clockIn = hasClockInput ? buffer.getReadPointer(0) : nullptr;
    const float* resetIn = hasResetInput ? buffer.getReadPointer(1) : nullptr;
    
    // Process sample by sample to detect triggers
    for (int i = 0; i < numSamples; ++i)
    {
        // Check for reset trigger (rising edge above 0.5V)
        if (resetIn != nullptr)
        {
            bool resetHigh = resetIn[i] > 0.5f;
            if (resetHigh && !lastResetHigh)
            {
                // Reset trigger detected
                currentStep.store(0);
                
                // Load snapshot for step 0 if it exists
                if (isSnapshotStored(0) && commandBus != nullptr && parentVoiceId != 0)
                {
                    Command cmd;
                    cmd.type = Command::Type::LoadPatchState;
                    cmd.voiceId = parentVoiceId;
                    cmd.patchState = snapshots[0];
                    commandBus->enqueue(cmd);
                    juce::Logger::writeToLog("[SnapshotSeq] Reset: Loading snapshot for step 0");
                }
            }
            lastResetHigh = resetHigh;
        }
        
        // Check for clock trigger (rising edge above 0.5V)
        if (clockIn != nullptr)
        {
            bool clockHigh = clockIn[i] > 0.5f;
            if (clockHigh && !lastClockHigh)
            {
                // Clock trigger detected - advance to next step
                int oldStep = currentStep.load();
                int newStep = (oldStep + 1) % numSteps;
                currentStep.store(newStep);
                
                juce::Logger::writeToLog("[SnapshotSeq] Step " + juce::String(oldStep) + " -> " + juce::String(newStep));
                
                // Load snapshot for the new step if it exists
                if (isSnapshotStored(newStep) && commandBus != nullptr && parentVoiceId != 0)
                {
                    Command cmd;
                    cmd.type = Command::Type::LoadPatchState;
                    cmd.voiceId = parentVoiceId;
                    cmd.patchState = snapshots[newStep];
                    commandBus->enqueue(cmd);
                    juce::Logger::writeToLog("[SnapshotSeq] Loading snapshot for step " + juce::String(newStep));
                }
            }
            lastClockHigh = clockHigh;
        }
    }
    
    // Clear output buffer (this module has no audio output)
    buffer.clear();
}

void SnapshotSequencerModuleProcessor::setSnapshotForStep(int stepIndex, const juce::MemoryBlock& state)
{
    if (stepIndex >= 0 && stepIndex < MAX_STEPS)
    {
        snapshots[stepIndex] = state;
        juce::Logger::writeToLog("[SnapshotSeq] Stored snapshot for step " + juce::String(stepIndex) + 
                                " (size: " + juce::String(state.getSize()) + " bytes)");
    }
}

const juce::MemoryBlock& SnapshotSequencerModuleProcessor::getSnapshotForStep(int stepIndex) const
{
    static juce::MemoryBlock emptyBlock;
    if (stepIndex >= 0 && stepIndex < MAX_STEPS)
        return snapshots[stepIndex];
    return emptyBlock;
}

void SnapshotSequencerModuleProcessor::clearSnapshotForStep(int stepIndex)
{
    if (stepIndex >= 0 && stepIndex < MAX_STEPS)
    {
        snapshots[stepIndex].reset();
        juce::Logger::writeToLog("[SnapshotSeq] Cleared snapshot for step " + juce::String(stepIndex));
    }
}

bool SnapshotSequencerModuleProcessor::isSnapshotStored(int stepIndex) const
{
    if (stepIndex >= 0 && stepIndex < MAX_STEPS)
        return snapshots[stepIndex].getSize() > 0;
    return false;
}

juce::ValueTree SnapshotSequencerModuleProcessor::getExtraStateTree() const
{
    juce::ValueTree tree("SnapshotSeqState");
    
    // Save each snapshot as Base64-encoded string
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        if (snapshots[i].getSize() > 0)
        {
            juce::ValueTree stepTree("Step");
            stepTree.setProperty("index", i, nullptr);
            stepTree.setProperty("data", snapshots[i].toBase64Encoding(), nullptr);
            tree.appendChild(stepTree, nullptr);
        }
    }
    
    return tree;
}

void SnapshotSequencerModuleProcessor::setExtraStateTree(const juce::ValueTree& tree)
{
    if (!tree.hasType("SnapshotSeqState"))
        return;
    
    // Clear all snapshots first
    for (auto& snapshot : snapshots)
        snapshot.reset();
    
    // Load snapshots from tree
    for (int i = 0; i < tree.getNumChildren(); ++i)
    {
        auto stepTree = tree.getChild(i);
        if (stepTree.hasType("Step"))
        {
            int index = stepTree.getProperty("index", -1);
            juce::String dataStr = stepTree.getProperty("data", "").toString();
            
            if (index >= 0 && index < MAX_STEPS && dataStr.isNotEmpty())
            {
                juce::MemoryBlock mb;
                if (mb.fromBase64Encoding(dataStr))
                {
                    snapshots[index] = mb;
                    juce::Logger::writeToLog("[SnapshotSeq] Restored snapshot for step " + juce::String(index) +
                                           " (size: " + juce::String(mb.getSize()) + " bytes)");
                }
            }
        }
    }
}

#if defined(PRESET_CREATOR_UI)
void SnapshotSequencerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    juce::ignoreUnused(isParamModulated, onModificationEnded);
    
    ImGui::PushItemWidth(itemWidth);
    
    // Number of steps parameter
    if (auto* param = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numSteps")))
    {
        int steps = param->get();
        if (ImGui::SliderInt("Steps", &steps, 1, MAX_STEPS))
        {
            param->beginChangeGesture();
            *param = steps;
            param->endChangeGesture();
        }
    }
    
    ImGui::PopItemWidth();
    
    ImGui::Text("Snapshots:");
    
    // Display current step
    int currentStepIndex = currentStep.load();
    ImGui::Text("Current Step: %d", currentStepIndex + 1);
    
    
    // Draw snapshot slots
    const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
    
    for (int i = 0; i < numSteps; ++i)
    {
        ImGui::PushID(i);
        
        // Highlight current step
        if (i == currentStepIndex)
        {
            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.0f, 1.0f));
        }
        
        ImGui::Text("Step %d:", i + 1);
        
        if (i == currentStepIndex)
        {
            ImGui::PopStyleColor();
        }
        
        ImGui::SameLine();
        
        bool stored = isSnapshotStored(i);
        
        // Status indicator
        if (stored)
        {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "[STORED]");
        }
        else
        {
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), "[EMPTY]");
        }
        
        // Note: Capture and Clear buttons are handled by the ImGuiNodeEditorComponent
        // since it needs access to the synth's getStateInformation method
        
        ImGui::PopID();
    }
    
    ImGui::TextWrapped("Connect a clock to advance steps. Each step can store a complete patch state.");
}
#endif



================================================================================
FILE: juce\Source\ipc\CommandBus.h
================================================================================


// Rationale: CommandBus is the single-producer/multi-consumer queue between OSC
// receiver and the engine. We provide enqueueLatest to coalesce noisy updates
// (e.g., positionX/Y) and a hard size cap to avoid unbounded growth under load.
#pragma once

#include <juce_core/juce_core.h>
#include <limits>

struct Command
{
    enum class Type { Create, Destroy, Update, DebugDump, LoadPreset, ResetFx, RandomizePitch, RandomizeTime, SetChaosMode, LoadPatchState };
    Type type { Type::Update };
    juce::uint64 voiceId { 0 };
    // Create
    juce::String voiceType;    // "sample", "synth", "noise"
    juce::String resourceName; // file name or preset name
    // Optional initial parameters for Create
    float initialPosX { std::numeric_limits<float>::quiet_NaN() };
    float initialPosY { std::numeric_limits<float>::quiet_NaN() };
    float initialAmplitude { std::numeric_limits<float>::quiet_NaN() };
    int   initialPitchOnGrid { -1 }; // -1 unknown, 0 false, 1 true
    int   initialLooping     { -1 }; // -1 unknown, 0 false, 1 true
    float initialVolume      { std::numeric_limits<float>::quiet_NaN() };
    juce::String presetData; // For LoadPreset command
    // Update
    juce::String paramName;    // e.g. "pan", "gain", "cutoff"
    float paramValue { 0.0f };
    // Chaos Mode
    bool chaosModeEnabled { false };
    // Patch State (for LoadPatchState command from Snapshot Sequencer)
    juce::MemoryBlock patchState;
};

class CommandBus
{
public:
    void enqueue (const Command& c)
    {
        const juce::ScopedLock sl (lock);
        queue.add (c);
        trimIfOversize();
    }

    bool tryDequeue (Command& out)
    {
        const juce::ScopedLock sl (lock);
        if (queue.isEmpty()) return false;
        out = queue.removeAndReturn (0);
        return true;
    }

    // Replace any existing queued update with the same (voiceId, paramName)
    void enqueueLatest (const Command& c)
    {
        const juce::ScopedLock sl (lock);
        if (c.type == Command::Type::Update)
        {
            for (int i = queue.size(); --i >= 0; )
            {
                const auto& q = queue.getReference (i);
                if (q.type == Command::Type::Update && q.voiceId == c.voiceId && q.paramName == c.paramName)
                {
                    queue.remove (i);
                    break;
                }
            }
        }
        queue.add (c);
        trimIfOversize();
    }

    int getSize() const
    {
        const juce::ScopedLock sl (lock);
        return queue.size();
    }

    void clear()
    {
        const juce::ScopedLock sl (lock);
        queue.clear();
    }

private:
    juce::CriticalSection lock;
    juce::Array<Command> queue;

    void trimIfOversize()
    {
        const int maxSize = 20000; // safety cap
        if (queue.size() > maxSize)
        {
            const int excess = queue.size() - maxSize;
            queue.removeRange (0, excess);
        }
    }
};




================================================================================
FILE: juce\Source\ipc\IpcServer.h
================================================================================


#pragma once

#include <juce_osc/juce_osc.h>
#include "CommandBus.h"

// OSC-based server. Binds to a UDP port and translates messages into Commands.
class IpcServer : public juce::OSCReceiver,
                  public juce::OSCReceiver::Listener<juce::OSCReceiver::RealtimeCallback>
{
public:
    explicit IpcServer (CommandBus& b) : bus (b)
    {
        addListener (this);
    }
    ~IpcServer() override
    {
        disconnect();
        removeListener (this);
    }

    bool bind (int port)
    {
        return connect (port);
    }

    void oscMessageReceived (const juce::OSCMessage& message) override
    {
        const auto addr = message.getAddressPattern().toString();
        Command cmd;
        if (addr == "/voice/create" && message.size() == 3 && message[0].isInt32() && message[1].isString() && message[2].isString())
        {
            cmd.type = Command::Type::Create;
            cmd.voiceId = (juce::uint64) message[0].getInt32();
            cmd.voiceType = message[1].getString();
            cmd.resourceName = message[2].getString();
            juce::Logger::writeToLog ("[OSC] create id=" + juce::String ((juce::int64) cmd.voiceId) + " type=" + cmd.voiceType + " res=" + cmd.resourceName);
            bus.enqueue (cmd);
        }
        else if (addr == "/voice/destroy" && message.size() == 1 && message[0].isInt32())
        {
            cmd.type = Command::Type::Destroy;
            cmd.voiceId = (juce::uint64) message[0].getInt32();
            juce::Logger::writeToLog ("[OSC] destroy id=" + juce::String ((juce::int64) cmd.voiceId));
            bus.enqueue (cmd);
        }
        // Extended create with initial position and amplitude to avoid later backlog
        else if (addr == "/voice/create_ex" || addr == "/voice/createEx")
        {
            if (message.size() >= 6 && message[0].isInt32() && message[1].isString() && message[2].isString())
            {
                cmd.type = Command::Type::Create;
                cmd.voiceId = (juce::uint64) message[0].getInt32();
                cmd.voiceType = message[1].getString();
                cmd.resourceName = message[2].getString();
                cmd.initialPosX = message[3].isFloat32() ? message[3].getFloat32() : (message[3].isInt32() ? (float) message[3].getInt32() : 0.0f);
                cmd.initialPosY = message[4].isFloat32() ? message[4].getFloat32() : (message[4].isInt32() ? (float) message[4].getInt32() : 0.0f);
                cmd.initialAmplitude = message[5].isFloat32() ? message[5].getFloat32() : (message[5].isInt32() ? (float) message[5].getInt32() : 0.0f);
                // Optional flags: pitch_on_grid, looping, volume
                if (message.size() > 6)
                {
                    if (message[6].isInt32()) cmd.initialPitchOnGrid = message[6].getInt32();
                    if (message.size() > 7 && message[7].isInt32()) cmd.initialLooping = message[7].getInt32();
                    if (message.size() > 8 && (message[8].isFloat32() || message[8].isInt32()))
                        cmd.initialVolume = message[8].isFloat32() ? message[8].getFloat32() : (float) message[8].getInt32();
                }
                juce::Logger::writeToLog ("[OSC] create_ex id=" + juce::String ((juce::int64) cmd.voiceId) + " type=" + cmd.voiceType + " res=" + cmd.resourceName);
                bus.enqueue (cmd);
            }
        }
        else if (addr.startsWith ("/voice/update/") && message.size() == 2 && message[0].isInt32())
        {
            cmd.type = Command::Type::Update;
            cmd.voiceId = (juce::uint64) message[0].getInt32();
            cmd.paramName = addr.fromLastOccurrenceOf ("/", false, false);
            if (message[1].isFloat32())       cmd.paramValue = message[1].getFloat32();
            else if (message[1].isInt32())    cmd.paramValue = (float) message[1].getInt32();
            else                              cmd.paramValue = 0.0f;
            // Coalesce frequent param updates
            if (cmd.paramName == "positionX" || cmd.paramName == "positionY")
                bus.enqueueLatest (cmd);
            else
                bus.enqueue (cmd);
        }
        else if (addr == "/settings/setMasterGain" && message.size() == 1)
        {
            Command c; c.type = Command::Type::Update; c.voiceId = 0; c.paramName = "master.gain";
            if (message[0].isFloat32()) c.paramValue = message[0].getFloat32();
            else if (message[0].isInt32()) c.paramValue = (float) message[0].getInt32();
            else c.paramValue = 0.0f;
            bus.enqueue (c);
        }
        else if (addr == "/settings/setDevice" && message.size() == 2)
        {
            // type ("input"/"output"), deviceName
            Command c; c.type = Command::Type::Update; c.voiceId = 0; c.paramName = "device.set";
            juce::String t = message[0].getString();
            c.paramValue = 0.0f; // unused numeric channel
            // Pack the type and name into a temp string we retrieve on the other side via bus (quick hack)
            // Format: "type\nname"
            juce::String name = message[1].getString();
            c.voiceType = t + "\n" + name;
            bus.enqueue (c);
        }
        else if (addr == "/settings/setBufferSize" && message.size() == 1)
        {
            // buffer size in frames (int)
            Command c; c.type = Command::Type::Update; c.voiceId = 0; c.paramName = "device.bufferSize";
            if (message[0].isInt32()) c.paramValue = (float) message[0].getInt32();
            else if (message[0].isFloat32()) c.paramValue = message[0].getFloat32();
            else c.paramValue = 0.0f;
            bus.enqueue (c);
        }
        else if (addr == "/settings/requestInfo")
        {
            // No args; request JUCE to resend all info snapshots
            Command c; c.type = Command::Type::Update; c.voiceId = 0; c.paramName = "engine.requestInfo"; c.paramValue = 0.0f;
            bus.enqueue (c);
        }
        else if (addr == "/debug/dump_state")
        {
            Command cd; cd.type = Command::Type::DebugDump; cd.voiceId = 0; bus.enqueue (cd);
        }
        else if (addr == "/listener/pos" && message.size() == 2)
        {
            // Coalesce into two updates so CommandProcessor can apply latest per tick
            Command cx; cx.type = Command::Type::Update; cx.voiceId = 0; cx.paramName = "listener.posX";
            if (message[0].isFloat32()) cx.paramValue = message[0].getFloat32(); else if (message[0].isInt32()) cx.paramValue = (float) message[0].getInt32(); else cx.paramValue = 0.0f;
            bus.enqueueLatest (cx);
            Command cy; cy.type = Command::Type::Update; cy.voiceId = 0; cy.paramName = "listener.posY";
            if (message[1].isFloat32()) cy.paramValue = message[1].getFloat32(); else if (message[1].isInt32()) cy.paramValue = (float) message[1].getInt32(); else cy.paramValue = 0.0f;
            bus.enqueueLatest (cy);
        }
        else if (addr == "/listener/set" && message.size() == 2)
        {
            Command cr; cr.type = Command::Type::Update; cr.voiceId = 0; cr.paramName = "listener.radius";
            if (message[0].isFloat32()) cr.paramValue = message[0].getFloat32(); else if (message[0].isInt32()) cr.paramValue = (float) message[0].getInt32(); else cr.paramValue = 0.0f;
            bus.enqueue (cr);
            Command cn; cn.type = Command::Type::Update; cn.voiceId = 0; cn.paramName = "listener.near";
            if (message[1].isFloat32()) cn.paramValue = message[1].getFloat32(); else if (message[1].isInt32()) cn.paramValue = (float) message[1].getInt32(); else cn.paramValue = 0.0f;
            bus.enqueue (cn);
        }
        else if (addr == "/engine/stopAll")
        {
            Command ce; ce.type = Command::Type::Update; ce.voiceId = 0; ce.paramName = "engine.stopAll"; ce.paramValue = 0.0f; bus.enqueue (ce);
        }
        else if (addr == "/voices/update_positions" && message.size() >= 3)
        {
            // Expect triplets: id(int32), x(float), y(float) ...
            const int n = (int) message.size();
            for (int i = 0; i + 2 < n; i += 3)
            {
                if (! message[i].isInt32()) continue;
                const juce::uint64 vid = (juce::uint64) message[i].getInt32();
                float x = 0.0f, y = 0.0f;
                if (message[i+1].isFloat32()) x = message[i+1].getFloat32(); else if (message[i+1].isInt32()) x = (float) message[i+1].getInt32();
                if (message[i+2].isFloat32()) y = message[i+2].getFloat32(); else if (message[i+2].isInt32()) y = (float) message[i+2].getInt32();
                Command cx; cx.type = Command::Type::Update; cx.voiceId = vid; cx.paramName = "positionX"; cx.paramValue = x; bus.enqueueLatest (cx);
                Command cy; cy.type = Command::Type::Update; cy.voiceId = vid; cy.paramName = "positionY"; cy.paramValue = y; bus.enqueueLatest (cy);
            }
        }
    }

private:
    CommandBus& bus;
};




================================================================================
FILE: juce\CMakeLists.txt
================================================================================


cmake_minimum_required(VERSION 3.22)
project(ColliderAudioEngine VERSION 0.1.0)

# --- TTS Integration (Piper) ---

# 1. Set paths to pre-built Piper and ONNX Runtime
set(PIPER_DIR "${CMAKE_SOURCE_DIR}/../vendor/piper/piper" CACHE PATH "Path to Piper TTS")
set(ONNXRUNTIME_DIR "${CMAKE_SOURCE_DIR}/../vendor/onnxruntime" CACHE PATH "Path to ONNX Runtime")

if(NOT EXISTS "${PIPER_DIR}")
    message(WARNING "Piper TTS not found at ${PIPER_DIR}. TTS features will be limited.")
endif()

if(NOT EXISTS "${ONNXRUNTIME_DIR}")
    message(WARNING "ONNX Runtime not found at ${ONNXRUNTIME_DIR}. TTS features will be limited.")
endif()

# 2. Add SoundTouch library
set(SOUNDTOUCH_SOURCE_DIR "${CMAKE_SOURCE_DIR}/../soundtouch/source")
add_library(soundtouch STATIC
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/AAFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/BPMDetect.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIFOSampleBuffer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/FIRFilter.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateCubic.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateLinear.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/InterpolateShannon.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/PeakFinder.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/RateTransposer.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/SoundTouch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/TDStretch.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/cpu_detect_x86.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/mmx_optimized.cpp
    ${SOUNDTOUCH_SOURCE_DIR}/SoundTouch/sse_optimized.cpp
)
target_include_directories(soundtouch PUBLIC 
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

include(FetchContent)

# ==============================================================================
# Third-Party Dependencies (Fetch Only)
# ==============================================================================

FetchContent_Declare(JUCE
    GIT_REPOSITORY https://github.com/juce-framework/JUCE.git
    GIT_TAG 7.0.9
)
set(JUCE_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(JUCE_BUILD_EXTRAS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(JUCE)

FetchContent_Declare(imgui_fc
    GIT_REPOSITORY https://github.com/ocornut/imgui.git
    GIT_TAG v1.92.0
)
FetchContent_MakeAvailable(imgui_fc)

# imnodes uses find_package(imgui) in its CMake; build as sources instead
FetchContent_Declare(imnodes_fc
    GIT_REPOSITORY https://github.com/Nelarius/imnodes.git
    GIT_TAG b2ec254ce576ac3d42dfb7aef61deadbff8e7211
)
FetchContent_GetProperties(imnodes_fc)
if(NOT imnodes_fc_POPULATED)
  FetchContent_Populate(imnodes_fc)
endif()

# imgui_juce backend (dedicated JUCE bridge for ImGui)
FetchContent_Declare(imgui_juce_fc
    GIT_REPOSITORY https://github.com/Krasjet/imgui_juce.git
    GIT_TAG master
)
FetchContent_MakeAvailable(imgui_juce_fc)

# --------------------------------------------------------------
# Box2D (2D physics engine for physics-based audio module)
# --------------------------------------------------------------
FetchContent_Declare(box2d_fc
    GIT_REPOSITORY https://github.com/erincatto/box2d.git
    GIT_TAG v2.4.1
)
set(BOX2D_BUILD_UNIT_TESTS OFF CACHE BOOL "" FORCE)
set(BOX2D_BUILD_TESTBED OFF CACHE BOOL "" FORCE)
set(BOX2D_BUILD_DOCS OFF CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(box2d_fc)

# --------------------------------------------------------------
# GLM (OpenGL Mathematics library for 3D vector/matrix math)
# --------------------------------------------------------------
FetchContent_Declare(
  glm
  GIT_REPOSITORY https://github.com/g-truc/glm.git
  GIT_TAG        1.0.1 # Latest stable version
)
FetchContent_MakeAvailable(glm)

# --------------------------------------------------------------
# nlohmann/json (required by tinygltf)
# --------------------------------------------------------------
FetchContent_Declare(
  nlohmann_json
  GIT_REPOSITORY https://github.com/nlohmann/json.git
  GIT_TAG        v3.11.3 # A recent stable version
)
FetchContent_MakeAvailable(nlohmann_json)

# --------------------------------------------------------------
# tinygltf (glTF 2.0 file loader for animation system)
# --------------------------------------------------------------
FetchContent_Declare(
  tinygltf
  GIT_REPOSITORY https://github.com/syoyo/tinygltf.git
  GIT_TAG        v2.8.20 # A recent stable version
)
FetchContent_MakeAvailable(tinygltf)

# --------------------------------------------------------------
# ufbx (FBX file loader for animation system)
# --------------------------------------------------------------
FetchContent_Declare(
  ufbx
  GIT_REPOSITORY https://github.com/ufbx/ufbx.git
  GIT_TAG        v0.10.0 # A recent stable version of ufbx
)
FetchContent_MakeAvailable(ufbx)

# Get the path to the downloaded ufbx source code
FetchContent_GetProperties(ufbx SOURCE_DIR ufbx_SOURCE_DIR)

# Create a dedicated static library target for ufbx (single-header library needs separate compilation unit)
add_library(ufbx_static STATIC ${ufbx_SOURCE_DIR}/ufbx.c)
target_include_directories(ufbx_static PUBLIC ${ufbx_SOURCE_DIR})

# ==============================================================================
# CUDA & cuDNN Configuration (MUST be done before OpenCV)
# ==============================================================================
# Find the CUDA Toolkit. This will use the default installation path or environment
# variables. This is essential for OpenCV's configuration to detect CUDA correctly.
find_package(CUDAToolkit REQUIRED)

# Find CUDA runtime library for direct linking if CUDAToolkit::cudart target is not available
if(MSVC)
    find_library(CUDA_CUDART_LIBRARY
        NAMES cudart_static.lib cudart.lib
        PATHS "${CUDAToolkit_LIBRARY_DIR}"
        NO_DEFAULT_PATH
    )
else()
    find_library(CUDA_CUDART_LIBRARY
        NAMES cudart
        PATHS "${CUDAToolkit_LIBRARY_DIR}"
        NO_DEFAULT_PATH
    )
endif()

# --- NPP (NVIDIA Performance Primitives) Configuration ---
# Explicitly set CUDA and NPP paths for OpenCV to find them
set(CUDA_TOOLKIT_ROOT_DIR "${CUDAToolkit_TARGET_DIR}" CACHE PATH "CUDA Toolkit root directory")
set(CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES "${CUDAToolkit_INCLUDE_DIRS}" CACHE PATH "CUDA Toolkit include directories")

# Set NPP include and library directories explicitly
# NPP headers are in the CUDA Toolkit include directory
set(CUDA_INCLUDE_DIRS "${CUDAToolkit_INCLUDE_DIRS}" CACHE PATH "CUDA include directories")
set(CUDA_NPP_LIBRARY_ROOT_DIR "${CUDAToolkit_LIBRARY_DIR}" CACHE PATH "NPP library root directory")

# Provide hints for cuDNN path.
# First check if cuDNN is integrated into CUDA Toolkit (recommended approach)
# Then fall back to standalone cuDNN installation
set(CUDNN_FOUND FALSE)

# CRITICAL FIX: CUDAToolkit_INCLUDE_DIRS is a LIST, extract the first element
list(GET CUDAToolkit_INCLUDE_DIRS 0 CUDA_MAIN_INCLUDE_DIR)

# Check in CUDA Toolkit directory first
if(EXISTS "${CUDA_MAIN_INCLUDE_DIR}/cudnn.h")
    set(CUDNN_INCLUDE_DIR "${CUDA_MAIN_INCLUDE_DIR}" CACHE PATH "Path to cuDNN include directory")
    set(CUDNN_LIBRARY "${CUDAToolkit_LIBRARY_DIR}/cudnn.lib" CACHE FILEPATH "Path to cuDNN library")
    set(CUDNN_FOUND TRUE)
    message(STATUS "Found cuDNN integrated into CUDA Toolkit at ${CUDA_MAIN_INCLUDE_DIR}")
# Fall back to standalone cuDNN installation
elseif(EXISTS "C:/Program Files/NVIDIA/CUDNN/v9.14/include/cudnn.h")
    set(CUDNN_INCLUDE_DIR "C:/Program Files/NVIDIA/CUDNN/v9.14/include" CACHE PATH "Path to cuDNN include directory")
    set(CUDNN_LIBRARY "C:/Program Files/NVIDIA/CUDNN/v9.14/lib/x64/cudnn.lib" CACHE FILEPATH "Path to cuDNN library")
    set(CUDNN_FOUND TRUE)
    message(STATUS "Found standalone cuDNN at C:/Program Files/NVIDIA/CUDNN/v9.14/")
endif()

# Configure OpenCV based on cuDNN availability
if(CUDNN_FOUND)
    set(WITH_CUDNN ON CACHE BOOL "" FORCE)
    set(OPENCV_DNN_CUDA ON CACHE BOOL "" FORCE)
else()
    message(WARNING "cuDNN not found. OpenCV will build without cuDNN support.")
    message(WARNING "Disabling OPENCV_DNN_CUDA since cuDNN is required for CUDA DNN backend.")
    set(WITH_CUDNN OFF CACHE BOOL "" FORCE)
    set(OPENCV_DNN_CUDA OFF CACHE BOOL "" FORCE)
endif()

# --------------------------------------------------------------
# OpenCV (Computer Vision Library - used for Preset Creator UI)
# --------------------------------------------------------------

# Add /FS flag for MSVC BEFORE declaring OpenCV to fix parallel compilation PDB access issues
if(MSVC)
    # Save current flags
    set(SAVED_CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
    set(SAVED_CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
    
    # Add /FS flag to init variables (used by subprojects)
    set(CMAKE_CXX_FLAGS_INIT "${CMAKE_CXX_FLAGS_INIT} /FS" CACHE STRING "" FORCE)
    set(CMAKE_C_FLAGS_INIT "${CMAKE_C_FLAGS_INIT} /FS" CACHE STRING "" FORCE)
    
    # Also add to current flags
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /FS")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /FS")
endif()

# CRITICAL FIX: Add CUDA include directories using CMake's proper mechanism
# This works for both C++ and CUDA compilation (unlike compiler flags which break on spaces)
include_directories(SYSTEM ${CUDAToolkit_INCLUDE_DIRS})

# UPGRADED: Using OpenCV 4.x development branch with CUDA 12.9+ fix
# This includes PR #27288 which fixes nppGetStreamContext() issue for CUDA 12.9+
FetchContent_Declare(
  opencv
  GIT_REPOSITORY https://github.com/opencv/opencv.git
  GIT_TAG        4.x # Latest development branch with CUDA 13.0 support
)

# ADDED: opencv_contrib is required for many CUDA modules and advanced features (especially cudev).
FetchContent_Declare(
  opencv_contrib
  GIT_REPOSITORY https://github.com/opencv/opencv_contrib.git
  GIT_TAG        4.x # Must match the main OpenCV branch
)

# Fetch and populate opencv_contrib FIRST so we can get its source directory
FetchContent_GetProperties(opencv_contrib)
if(NOT opencv_contrib_POPULATED)
    FetchContent_Populate(opencv_contrib)
endif()

# Get the opencv_contrib source directory BEFORE configuring OpenCV
FetchContent_GetProperties(opencv_contrib SOURCE_DIR opencv_contrib_SOURCE_DIR)

# CRITICAL: Set OPENCV_EXTRA_MODULES_PATH BEFORE FetchContent_MakeAvailable(opencv)
# This ensures OpenCV can find the cudev module during configuration
set(OPENCV_EXTRA_MODULES_PATH "${opencv_contrib_SOURCE_DIR}/modules" CACHE PATH "" FORCE)

# --- OpenCV Build Configuration ---
set(BUILD_SHARED_LIBS OFF)
set(BUILD_opencv_world ON)
set(BUILD_TESTS OFF)
set(BUILD_PERF_TESTS OFF)
set(BUILD_EXAMPLES OFF)
set(BUILD_opencv_apps OFF)
set(ENABLE_PRECOMPILED_HEADERS OFF)
set(BUILD_WITH_STATIC_CRT OFF) # Correctly matches JUCE's dynamic runtime
set(WITH_IPP OFF) # Disable Intel IPP to avoid header path issues

# --- CUDA and cuDNN Configuration ---
set(WITH_CUDA ON CACHE BOOL "" FORCE)
# OPENCV_DNN_CUDA and WITH_CUDNN are set above based on cuDNN availability
set(WITH_NVIDIA_NPP ON CACHE BOOL "" FORCE)
set(WITH_NVCUVID OFF) # Video decoding, disable if not needed.
set(WITH_NVCUVENC OFF) # Video encoding, disable if not needed.

# Explicitly provide CUDA paths to OpenCV (critical for finding NPP headers)
set(CUDA_TOOLKIT_ROOT_DIR "${CUDAToolkit_TARGET_DIR}" CACHE PATH "" FORCE)
set(CUDA_INCLUDE_DIRS "${CUDAToolkit_INCLUDE_DIRS}" CACHE PATH "" FORCE)
# DO NOT set CUDA_LIBRARIES to a directory - causes "x64.lib" linker error
# OpenCV will find CUDA libraries automatically via CUDA_TOOLKIT_ROOT_DIR

# --- CUDA Architecture Targeting ---
# Target NVIDIA Blackwell (RTX 5090), Ada Lovelace (40-series), and Ampere (30-series)
set(CUDA_ARCH_BIN "8.6;8.9;12.0")
# Provide forward compatibility for future architectures
set(CUDA_ARCH_PTX "12.0")

# Explicitly enable required modules.
set(BUILD_opencv_core ON)
set(BUILD_opencv_dnn ON)
set(BUILD_opencv_features2d ON)
set(BUILD_opencv_highgui ON)
set(BUILD_opencv_imgcodecs ON)
set(BUILD_opencv_imgproc ON)
set(BUILD_opencv_objdetect ON)
set(BUILD_opencv_tracking ON)
set(BUILD_opencv_video ON)
set(BUILD_opencv_videoio ON)
set(BUILD_opencv_calib3d ON)
set(OPENCV_DNN_CAFFE ON)

# --- Finalize and Build OpenCV ---
FetchContent_MakeAvailable(opencv)

# Get the OpenCV build directory for generated headers
FetchContent_GetProperties(opencv)
if(NOT opencv_POPULATED)
    FetchContent_Populate(opencv)
endif()
set(OPENCV_BUILD_DIR "${CMAKE_BINARY_DIR}/_deps/opencv-build")

# ==============================================================================
# AUTO-GENERATE opencv_modules.hpp
# ==============================================================================
# OpenCV's build system should generate this file, but sometimes it doesn't
# create it during the initial configuration. This ensures it always exists.
set(OPENCV_MODULES_HPP "${OPENCV_BUILD_DIR}/opencv2/opencv_modules.hpp")
if(NOT EXISTS "${OPENCV_MODULES_HPP}")
    message(STATUS "Generating missing opencv_modules.hpp...")
    file(MAKE_DIRECTORY "${OPENCV_BUILD_DIR}/opencv2")
    file(WRITE "${OPENCV_MODULES_HPP}"
"/*
 * This file is auto-generated. Do not edit!
 */

#ifndef OPENCV_MODULES_HPP
#define OPENCV_MODULES_HPP

#define HAVE_OPENCV_CALIB3D
#define HAVE_OPENCV_CORE
#define HAVE_OPENCV_DNN
#define HAVE_OPENCV_FEATURES2D
#define HAVE_OPENCV_FLANN
#define HAVE_OPENCV_GAPI
#define HAVE_OPENCV_HIGHGUI
#define HAVE_OPENCV_IMGCODECS
#define HAVE_OPENCV_IMGPROC
#define HAVE_OPENCV_ML
#define HAVE_OPENCV_OBJDETECT
#define HAVE_OPENCV_PHOTO
#define HAVE_OPENCV_STITCHING
#define HAVE_OPENCV_VIDEO
#define HAVE_OPENCV_VIDEOIO
#define HAVE_OPENCV_WORLD

#endif
")
    message(STATUS "Generated opencv_modules.hpp at ${OPENCV_MODULES_HPP}")
endif()
# ==============================================================================

# Restore flags after OpenCV if needed
if(MSVC)
    set(CMAKE_CXX_FLAGS "${SAVED_CMAKE_CXX_FLAGS} /FS")
    set(CMAKE_C_FLAGS "${SAVED_CMAKE_C_FLAGS} /FS")
endif()

# ==============================================================================
# Define CUDA Support Preprocessor Macro for Application Code
# ==============================================================================
# This allows C++ code to check #if WITH_CUDA_SUPPORT at compile time
# Only define if both CUDA and cuDNN are available (required for full DNN CUDA support)
if(WITH_CUDA AND CUDNN_FOUND)
    message(STATUS "‚úì Enabling WITH_CUDA_SUPPORT preprocessor definition")
    message(STATUS "  - CUDA Version: ${CUDAToolkit_VERSION}")
    message(STATUS "  - cuDNN Found: ${CUDNN_INCLUDE_DIR}")
    # Will be added to targets later via target_compile_definitions
    set(CUDA_SUPPORT_ENABLED TRUE)
else()
    message(STATUS "CUDA support disabled - WITH_CUDA_SUPPORT not defined")
    if(NOT WITH_CUDA)
        message(STATUS "  Reason: WITH_CUDA is OFF")
    elseif(NOT CUDNN_FOUND)
        message(STATUS "  Reason: cuDNN not found")
    endif()
    set(CUDA_SUPPORT_ENABLED FALSE)
endif()

# ==============================================================================
# FFmpeg (Pre-built vendor binaries - SIMPLIFIED!)
# ==============================================================================
# Windows: Download from https://github.com/BtbN/FFmpeg-Builds/releases
# Extract to vendor/ffmpeg/ (see FFMPEG_SETUP_GUIDE.md)
set(FFMPEG_DIR "${CMAKE_SOURCE_DIR}/../vendor/ffmpeg" CACHE PATH "Path to FFmpeg")
set(FFMPEG_FOUND FALSE)

if(WIN32)
    # Windows: Use pre-built vendor binaries
    if(EXISTS "${FFMPEG_DIR}/include/libavformat/avformat.h")
        message(STATUS "‚úì FFmpeg found at ${FFMPEG_DIR}")
        
        set(FFMPEG_INCLUDE_DIR "${FFMPEG_DIR}/include")
        set(FFMPEG_LIB_DIR "${FFMPEG_DIR}/lib")
        set(FFMPEG_BIN_DIR "${FFMPEG_DIR}/bin")
        
        # Find all required libraries
        find_library(AVFORMAT_LIBRARY avformat PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(AVCODEC_LIBRARY avcodec PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(AVUTIL_LIBRARY avutil PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(SWRESAMPLE_LIBRARY swresample PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        find_library(SWSCALE_LIBRARY swscale PATHS "${FFMPEG_LIB_DIR}" NO_DEFAULT_PATH REQUIRED)
        
        set(FFMPEG_LIBRARIES 
            ${AVFORMAT_LIBRARY}
            ${AVCODEC_LIBRARY}
            ${AVUTIL_LIBRARY}
            ${SWRESAMPLE_LIBRARY}
            ${SWSCALE_LIBRARY}
        )
        
        message(STATUS "  - Include: ${FFMPEG_INCLUDE_DIR}")
        message(STATUS "  - Libraries: ${FFMPEG_LIBRARIES}")
        set(FFMPEG_FOUND TRUE)
    else()
        message(FATAL_ERROR 
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "‚ùå FFmpeg NOT FOUND!\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            "Expected location: ${FFMPEG_DIR}\n"
            "\n"
            "üì¶ Quick Setup (5 minutes):\n"
            "  1. Download: https://github.com/BtbN/FFmpeg-Builds/releases\n"
            "     Get: ffmpeg-master-latest-win64-gpl-shared.zip\n"
            "  2. Extract to: ${FFMPEG_DIR}\n"
            "  3. Folder structure should be:\n"
            "     vendor/ffmpeg/\n"
            "       ‚îú‚îÄ‚îÄ bin/     (DLL files)\n"
            "       ‚îú‚îÄ‚îÄ include/ (header files)\n"
            "       ‚îî‚îÄ‚îÄ lib/     (.lib files)\n"
            "\n"
            "üìñ See FFMPEG_SETUP_GUIDE.md for detailed instructions\n"
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        )
    endif()
else()
    # Linux/Mac: Use system packages
    find_package(PkgConfig QUIET)
    if(PKG_CONFIG_FOUND)
        pkg_check_modules(FFMPEG
            libavformat>=57.0
            libavcodec>=57.0
            libavutil>=55.0
            libswresample>=3.0
            libswscale>=5.0
        )
        if(FFMPEG_FOUND)
            set(FFMPEG_INCLUDE_DIR ${FFMPEG_INCLUDE_DIRS})
            set(FFMPEG_LIBRARIES ${FFMPEG_LIBRARIES})
            message(STATUS "‚úì FFmpeg found via pkg-config")
            message(STATUS "  - Include: ${FFMPEG_INCLUDE_DIR}")
        endif()
    endif()
    
    # Fallback: try finding libraries directly
    if(NOT FFMPEG_FOUND)
        find_path(FFMPEG_INCLUDE_DIR NAMES libavformat/avformat.h
            PATHS /usr/include /usr/local/include /opt/homebrew/include
        )
        find_library(AVFORMAT_LIBRARY avformat)
        find_library(AVCODEC_LIBRARY avcodec)
        find_library(AVUTIL_LIBRARY avutil)
        find_library(SWRESAMPLE_LIBRARY swresample)
        find_library(SWSCALE_LIBRARY swscale)
        
        if(FFMPEG_INCLUDE_DIR AND AVFORMAT_LIBRARY)
            set(FFMPEG_LIBRARIES 
                ${AVFORMAT_LIBRARY}
                ${AVCODEC_LIBRARY}
                ${AVUTIL_LIBRARY}
                ${SWRESAMPLE_LIBRARY}
                ${SWSCALE_LIBRARY}
            )
            set(FFMPEG_FOUND TRUE)
            message(STATUS "‚úì FFmpeg found")
        else()
            message(FATAL_ERROR
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                "‚ùå FFmpeg NOT FOUND!\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                "üì¶ Install FFmpeg:\n"
                "  Linux:  sudo apt-get install libavformat-dev libavcodec-dev libavutil-dev libswresample-dev libswscale-dev\n"
                "  macOS:  brew install ffmpeg\n"
                "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            )
        endif()
    endif()
endif()

# --------------------------------------------------------------
# Rubber Band (optional, real-time timestretcher/pitch-shifter)
# --------------------------------------------------------------
set(USE_RUBBERBAND ON CACHE BOOL "Enable Rubber Band time/pitch processing")
if (USE_RUBBERBAND)
  FetchContent_Declare(rubberband_fc
    GIT_REPOSITORY https://github.com/breakfastquay/rubberband.git
    GIT_TAG v3.3.0
  )
  FetchContent_MakeAvailable(rubberband_fc)
  # Build from single-file amalgamation to avoid external link issues
  # Use official amalgamated single-file build (works cross-platform)
  add_library(rubberband_single STATIC
    ${rubberband_fc_SOURCE_DIR}/single/RubberBandSingle.cpp
  )
  target_include_directories(rubberband_single PUBLIC
    ${rubberband_fc_SOURCE_DIR}
    ${rubberband_fc_SOURCE_DIR}/single
  )
  target_compile_definitions(rubberband_single PUBLIC
    NOMINMAX
    _USE_MATH_DEFINES
    RUBBERBAND_USE_R3=1
    RUBBERBAND_BUILD_FFT=KISSFFT
    RUBBERBAND_BUILD_RESAMPLER=NONE
  )
  set(RUBBERBAND_TARGET rubberband_single)
  set(RUBBERBAND_INCLUDE_DIR "${rubberband_fc_SOURCE_DIR}")
endif()

# ==============================================================================
# Main Engine App Target (Unchanged)
# ==============================================================================
juce_add_gui_app(ColliderApp
    PRODUCT_NAME "Collider Audio Engine"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(ColliderApp PRIVATE
    Source/main.cpp
    Source/app/MainApplication.cpp
    Source/app/MainApplication.h
    Source/ui/MainComponent.cpp
    Source/ui/MainComponent.h
    Source/ui/TestHarnessComponent.cpp
    Source/ui/TestHarnessComponent.h
    Source/ui/VisualiserComponent.cpp
    Source/ui/VisualiserComponent.h
    Source/ui/DebugInfo.h
    Source/audio/AudioEngine.h
    Source/audio/AudioEngine.cpp
    Source/audio/MidiDeviceManager.h
    Source/audio/MidiDeviceManager.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/voices/SynthVoiceProcessor.h
    Source/audio/voices/SynthVoiceProcessor.cpp
    Source/audio/voices/NoiseVoiceProcessor.h
    Source/audio/voices/NoiseVoiceProcessor.cpp
    Source/audio/voices/ModularVoice.h
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/fx/FXChain.h
    Source/audio/fx/GainProcessor.h
    Source/audio/fx/GainProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/ModuleProcessor.cpp
    Source/audio/modules/AudioInputModuleProcessor.h
    Source/audio/modules/AudioInputModuleProcessor.cpp
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/CVMixerModuleProcessor.h
    Source/audio/modules/CVMixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MultiSequencerModuleProcessor.h
    Source/audio/modules/MultiSequencerModuleProcessor.cpp
    Source/audio/modules/LagProcessorModuleProcessor.h
    Source/audio/modules/LagProcessorModuleProcessor.cpp
    Source/audio/modules/DeCrackleModuleProcessor.h
    Source/audio/modules/DeCrackleModuleProcessor.cpp
    Source/audio/modules/GraphicEQModuleProcessor.h
    Source/audio/modules/GraphicEQModuleProcessor.cpp
    Source/audio/modules/FrequencyGraphModuleProcessor.h
    Source/audio/modules/FrequencyGraphModuleProcessor.cpp
    Source/audio/modules/ChorusModuleProcessor.h
    Source/audio/modules/ChorusModuleProcessor.cpp
    Source/audio/modules/PhaserModuleProcessor.h
    Source/audio/modules/PhaserModuleProcessor.cpp
    Source/audio/modules/CompressorModuleProcessor.h
    Source/audio/modules/CompressorModuleProcessor.cpp
    Source/audio/modules/RecordModuleProcessor.h
    Source/audio/modules/RecordModuleProcessor.cpp
    Source/audio/modules/CommentModuleProcessor.h
    Source/audio/modules/CommentModuleProcessor.cpp
    Source/audio/modules/LimiterModuleProcessor.h
    Source/audio/modules/LimiterModuleProcessor.cpp
    Source/audio/modules/GateModuleProcessor.h
    Source/audio/modules/GateModuleProcessor.cpp
    Source/audio/modules/DriveModuleProcessor.h
    Source/audio/modules/DriveModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/ComparatorModuleProcessor.h
    Source/audio/modules/ComparatorModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/MultiBandShaperModuleProcessor.h
    Source/audio/modules/MultiBandShaperModuleProcessor.cpp
    Source/audio/modules/GranulatorModuleProcessor.h
    Source/audio/modules/GranulatorModuleProcessor.cpp
    Source/audio/modules/HarmonicShaperModuleProcessor.h
    Source/audio/modules/HarmonicShaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
    Source/audio/modules/TimePitchModuleProcessor.h
    Source/audio/modules/TimePitchModuleProcessor.cpp
    Source/audio/modules/MIDIPlayerModuleProcessor.h
    Source/audio/modules/MIDIPlayerModuleProcessor.cpp
        Source/audio/modules/TrackMixerModuleProcessor.h
        Source/audio/modules/TrackMixerModuleProcessor.cpp
    Source/audio/modules/PolyVCOModuleProcessor.h
    Source/audio/modules/PolyVCOModuleProcessor.cpp
        Source/audio/modules/DebugModuleProcessor.h
        Source/audio/modules/DebugModuleProcessor.cpp
        Source/audio/modules/CommentModuleProcessor.h
        Source/audio/modules/CommentModuleProcessor.cpp
        Source/audio/modules/InputDebugModuleProcessor.h
        Source/audio/modules/InputDebugModuleProcessor.cpp
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/TimingData.h
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/FunctionGeneratorModuleProcessor.h
    Source/audio/modules/FunctionGeneratorModuleProcessor.cpp
    Source/audio/modules/BestPracticeNodeProcessor.h
    Source/audio/modules/BestPracticeNodeProcessor.cpp
    Source/audio/modules/TimelineModuleProcessor.h
    Source/audio/modules/TimelineModuleProcessor.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/modules/VstHostModuleProcessor.h
    Source/audio/modules/VstHostModuleProcessor.cpp
    Source/audio/modules/ShapingOscillatorModuleProcessor.h
    Source/audio/modules/ShapingOscillatorModuleProcessor.cpp
    Source/audio/modules/InletModuleProcessor.h
    Source/audio/modules/InletModuleProcessor.cpp
    Source/audio/modules/OutletModuleProcessor.h
    Source/audio/modules/OutletModuleProcessor.cpp
    Source/audio/modules/MetaModuleProcessor.h
    Source/audio/modules/MetaModuleProcessor.cpp
    Source/audio/modules/SnapshotSequencerModuleProcessor.h
    Source/audio/modules/SnapshotSequencerModuleProcessor.cpp
    Source/audio/modules/MIDICVModuleProcessor.h
    Source/audio/modules/MIDICVModuleProcessor.cpp
    Source/audio/modules/MIDIFadersModuleProcessor.h
    Source/audio/modules/MIDIFadersModuleProcessor.cpp
    Source/audio/modules/MIDIKnobsModuleProcessor.h
    Source/audio/modules/MIDIKnobsModuleProcessor.cpp
    Source/audio/modules/MIDIButtonsModuleProcessor.h
    Source/audio/modules/MIDIButtonsModuleProcessor.cpp
    Source/audio/modules/MIDIJogWheelModuleProcessor.h
    Source/audio/modules/MIDIJogWheelModuleProcessor.cpp
    Source/audio/modules/MIDIPadModuleProcessor.h
    Source/audio/modules/MIDIPadModuleProcessor.cpp
    Source/audio/modules/MidiLoggerModuleProcessor.h
    Source/audio/modules/MidiLoggerModuleProcessor.cpp
    Source/audio/modules/TempoClockModuleProcessor.h
    Source/audio/modules/TempoClockModuleProcessor.cpp
    Source/audio/modules/PhysicsModuleProcessor.h
    Source/audio/modules/PhysicsModuleProcessor.cpp
    Source/audio/modules/StrokeSequencerModuleProcessor.h
    Source/audio/modules/StrokeSequencerModuleProcessor.cpp
    Source/audio/modules/TapTempo.h
    Source/audio/modules/TapTempo.cpp
    Source/audio/modules/BPMMonitorModuleProcessor.h
    Source/audio/modules/BPMMonitorModuleProcessor.cpp
    Source/audio/modules/AnimationModuleProcessor.h
    Source/audio/modules/AnimationModuleProcessor.cpp
    Source/video/VideoFrameManager.h
    Source/video/CameraEnumerator.h
    Source/audio/modules/WebcamLoaderModule.h
    Source/audio/modules/WebcamLoaderModule.cpp
    Source/audio/modules/VideoFileLoaderModule.h
    Source/audio/modules/VideoFileLoaderModule.cpp
    Source/audio/modules/FFmpegAudioReader.h
    Source/audio/modules/FFmpegAudioReader.cpp
    Source/audio/modules/TimeStretcherAudioSource.h
    Source/audio/modules/TimeStretcherAudioSource.cpp
    Source/audio/modules/VideoFXModule.h
    Source/audio/modules/VideoFXModule.cpp
    Source/audio/modules/MovementDetectorModule.h
    Source/audio/modules/MovementDetectorModule.cpp
    Source/audio/modules/HumanDetectorModule.h
    Source/audio/modules/HumanDetectorModule.cpp
    Source/audio/modules/PoseEstimatorModule.h
    Source/audio/modules/PoseEstimatorModule.cpp
    Source/audio/modules/HandTrackerModule.h
    Source/audio/modules/HandTrackerModule.cpp
    Source/audio/modules/FaceTrackerModule.h
    Source/audio/modules/FaceTrackerModule.cpp
    Source/audio/modules/ObjectDetectorModule.h
    Source/audio/modules/ObjectDetectorModule.cpp
    Source/audio/modules/ColorTrackerModule.h
    Source/audio/modules/ColorTrackerModule.cpp
    Source/audio/modules/ContourDetectorModule.h
    Source/audio/modules/ContourDetectorModule.cpp
    Source/audio/modules/SemanticSegmentationModule.h
    Source/audio/modules/SemanticSegmentationModule.cpp
    Source/audio/modules/CropVideoModule.h
    Source/audio/modules/CropVideoModule.cpp
    Source/animation/AnimationData.h
    Source/animation/RawAnimationData.h
    Source/animation/RawAnimationData.cpp
    Source/animation/AnimationBinder.h
    Source/animation/AnimationBinder.cpp
    Source/animation/Animator.h
    Source/animation/Animator.cpp
    Source/animation/AnimationFileLoader.h
    Source/animation/AnimationFileLoader.cpp
    Source/animation/GltfLoader.h
    Source/animation/GltfLoader.cpp
    Source/animation/FbxLoader.h
    Source/animation/FbxLoader.cpp
    Source/animation/AnimationRenderer.h
    Source/animation/AnimationRenderer.cpp
    Source/ipc/IpcServer.cpp
    Source/ipc/IpcServer.h
    Source/ipc/OscClient.h
    Source/ipc/CommandBus.cpp
    Source/ipc/CommandBus.h
    Source/audio/utils/VoiceDeletionUtils.h
    Source/audio/dsp/TimePitchProcessor.h
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
)

target_compile_definitions(ColliderApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:ColliderApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:ColliderApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    JUCE_PLUGINHOST_VST3=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:WITH_CUDA_SUPPORT=1>
)

target_link_libraries(ColliderApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    juce::juce_osc
    soundtouch
    box2d
    glm::glm
    tinygltf
    ufbx_static
    opencv_world
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVFORMAT_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVCODEC_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVUTIL_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${SWRESAMPLE_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${SWSCALE_LIBRARY}>
    # Piper TTS libraries (pre-built)
    ${ONNXRUNTIME_DIR}/lib/onnxruntime.lib
)

# Link CUDA runtime for OpenCV CUDA symbols
# Use CUDAToolkit::cudart if available, otherwise link directly
if(TARGET CUDAToolkit::cudart)
    target_link_libraries(ColliderApp PRIVATE CUDAToolkit::cudart)
elseif(CUDA_CUDART_LIBRARY)
    target_link_libraries(ColliderApp PRIVATE ${CUDA_CUDART_LIBRARY})
endif()

# Link Windows libraries for native camera enumeration (DirectShow)
if(WIN32)
    target_link_libraries(ColliderApp PRIVATE ole32 strmiids)
endif()

# Add include directories for ColliderApp
target_include_directories(ColliderApp PRIVATE
    ${PIPER_DIR}
    ${ONNXRUNTIME_DIR}/include
    ${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64/samples/cpp/thirdparty/nlohmann_json/single_include
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    ${ufbx_SOURCE_DIR}
    $<$<BOOL:${FFMPEG_FOUND}>:${FFMPEG_INCLUDE_DIR}>
    # OpenCV include directories - source and generated headers
    ${opencv_SOURCE_DIR}/include
    ${opencv_SOURCE_DIR}/modules/core/include
    ${opencv_SOURCE_DIR}/modules/imgproc/include
    ${opencv_SOURCE_DIR}/modules/imgcodecs/include
    ${opencv_SOURCE_DIR}/modules/videoio/include
    ${opencv_SOURCE_DIR}/modules/highgui/include
    ${opencv_SOURCE_DIR}/modules/video/include
    ${opencv_SOURCE_DIR}/modules/objdetect/include
    ${opencv_SOURCE_DIR}/modules/features2d/include
    ${opencv_SOURCE_DIR}/modules/calib3d/include
    ${opencv_SOURCE_DIR}/modules/dnn/include              # For DNN headers (dnn.hpp)
    ${OPENCV_BUILD_DIR}
    ${OPENCV_BUILD_DIR}/modules/world
    # OpenCV CUDA modules (from opencv_contrib source)
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaimgproc/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudawarping/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaarithm/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafilters/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafeatures2d/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaobjdetect/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaoptflow/include>
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# ==============================================================================
# Preset Creator App Target (Final Corrected Version)
# ==============================================================================

juce_add_gui_app(PresetCreatorApp
    PRODUCT_NAME "Preset Creator"
    VERSION "0.1.0"
    COMPANY_NAME "Collider"
)

target_sources(PresetCreatorApp PRIVATE
    # Your application sources
    Source/preset_creator/PresetCreatorMain.cpp
    Source/preset_creator/PinDatabase.h
    Source/preset_creator/PinDatabase.cpp
    Source/preset_creator/NotificationManager.h
    Source/preset_creator/NotificationManager.cpp
    Source/preset_creator/SavePresetJob.h
    Source/preset_creator/SavePresetJob.cpp
    Source/preset_creator/ImGuiNodeEditorComponent.h
    Source/preset_creator/ImGuiNodeEditorComponent.cpp
    Source/preset_creator/PresetCreatorComponent.h
    Source/preset_creator/PresetCreatorComponent.cpp
    Source/preset_creator/ControllerPresetManager.h
    Source/preset_creator/ControllerPresetManager.cpp

    # Add ImGui, imnodes, and the backend DIRECTLY as source files
    ${imgui_fc_SOURCE_DIR}/imgui.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_fc_SOURCE_DIR}/imgui_widgets.cpp
    ${imgui_fc_SOURCE_DIR}/backends/imgui_impl_opengl2.cpp
    ${imnodes_fc_SOURCE_DIR}/imnodes.cpp

    # Your other reused engine modules
    Source/audio/MidiDeviceManager.h
    Source/audio/MidiDeviceManager.cpp
    Source/audio/graph/ModularSynthProcessor.h
    Source/audio/graph/ModularSynthProcessor.cpp
    Source/audio/modules/ModuleProcessor.h
    Source/audio/modules/ModuleProcessor.cpp
    Source/audio/modules/AudioInputModuleProcessor.h
    Source/audio/modules/AudioInputModuleProcessor.cpp
    Source/audio/modules/VCOModuleProcessor.h
    Source/audio/modules/VCOModuleProcessor.cpp
    Source/audio/modules/VCFModuleProcessor.h
    Source/audio/modules/VCFModuleProcessor.cpp
    Source/audio/modules/VCAModuleProcessor.h
    Source/audio/modules/VCAModuleProcessor.cpp
    Source/audio/modules/NoiseModuleProcessor.h
    Source/audio/modules/NoiseModuleProcessor.cpp
    Source/audio/modules/LFOModuleProcessor.h
    Source/audio/modules/LFOModuleProcessor.cpp
    Source/audio/modules/ADSRModuleProcessor.h
    Source/audio/modules/ADSRModuleProcessor.cpp
    Source/audio/modules/MixerModuleProcessor.h
    Source/audio/modules/MixerModuleProcessor.cpp
    Source/audio/modules/CVMixerModuleProcessor.h
    Source/audio/modules/CVMixerModuleProcessor.cpp
    Source/audio/modules/DelayModuleProcessor.h
    Source/audio/modules/DelayModuleProcessor.cpp
    Source/audio/modules/ReverbModuleProcessor.h
    Source/audio/modules/ReverbModuleProcessor.cpp
    Source/audio/modules/SAndHModuleProcessor.h
    Source/audio/modules/SAndHModuleProcessor.cpp
    Source/audio/modules/AttenuverterModuleProcessor.h
    Source/audio/modules/AttenuverterModuleProcessor.cpp
    Source/audio/modules/ScopeModuleProcessor.h
    Source/audio/modules/ScopeModuleProcessor.cpp
    Source/audio/modules/StepSequencerModuleProcessor.h
    Source/audio/modules/StepSequencerModuleProcessor.cpp
    Source/audio/modules/MathModuleProcessor.h
    Source/audio/modules/MathModuleProcessor.cpp
    Source/audio/modules/MapRangeModuleProcessor.h
    Source/audio/modules/MapRangeModuleProcessor.cpp
    Source/audio/modules/ComparatorModuleProcessor.h
    Source/audio/modules/ComparatorModuleProcessor.cpp
    Source/audio/modules/RandomModuleProcessor.h
    Source/audio/modules/RandomModuleProcessor.cpp
    Source/audio/modules/RateModuleProcessor.h
    Source/audio/modules/RateModuleProcessor.cpp
    Source/audio/modules/QuantizerModuleProcessor.h
    Source/audio/modules/QuantizerModuleProcessor.cpp
    Source/audio/modules/SequentialSwitchModuleProcessor.h
    Source/audio/modules/SequentialSwitchModuleProcessor.cpp
    Source/audio/modules/LogicModuleProcessor.h
    Source/audio/modules/LogicModuleProcessor.cpp
    Source/audio/modules/ClockDividerModuleProcessor.h
    Source/audio/modules/ClockDividerModuleProcessor.cpp
    Source/audio/modules/WaveshaperModuleProcessor.h
    Source/audio/modules/WaveshaperModuleProcessor.cpp
    Source/audio/modules/MultiBandShaperModuleProcessor.h
    Source/audio/modules/MultiBandShaperModuleProcessor.cpp
    Source/audio/modules/GranulatorModuleProcessor.h
    Source/audio/modules/GranulatorModuleProcessor.cpp
    Source/audio/modules/HarmonicShaperModuleProcessor.h
    Source/audio/modules/HarmonicShaperModuleProcessor.cpp
    Source/audio/modules/ValueModuleProcessor.h
    Source/audio/modules/ValueModuleProcessor.cpp
        Source/audio/modules/DebugModuleProcessor.h
        Source/audio/modules/DebugModuleProcessor.cpp
        Source/audio/modules/CommentModuleProcessor.h
        Source/audio/modules/CommentModuleProcessor.cpp
        Source/audio/modules/InputDebugModuleProcessor.h
        Source/audio/modules/InputDebugModuleProcessor.cpp
    Source/audio/modules/TimePitchModuleProcessor.h
    Source/audio/modules/TimePitchModuleProcessor.cpp
    Source/audio/modules/MIDIPlayerModuleProcessor.h
    Source/audio/modules/MIDIPlayerModuleProcessor.cpp
        Source/audio/modules/TrackMixerModuleProcessor.h
        Source/audio/modules/TrackMixerModuleProcessor.cpp
    Source/audio/modules/PolyVCOModuleProcessor.h
    Source/audio/modules/PolyVCOModuleProcessor.cpp
    
    Source/audio/modules/TTSPerformerModuleProcessor.h
    Source/audio/modules/TTSPerformerModuleProcessor.cpp
    Source/audio/modules/TimingData.h
    Source/audio/modules/SampleLoaderModuleProcessor.h
    Source/audio/modules/SampleLoaderModuleProcessor.cpp
    Source/audio/modules/FunctionGeneratorModuleProcessor.h
    Source/audio/modules/FunctionGeneratorModuleProcessor.cpp
    Source/audio/modules/BestPracticeNodeProcessor.h
    Source/audio/modules/BestPracticeNodeProcessor.cpp
    Source/audio/modules/TimelineModuleProcessor.h
    Source/audio/modules/TimelineModuleProcessor.cpp
    Source/audio/modules/ShapingOscillatorModuleProcessor.h
    Source/audio/modules/ShapingOscillatorModuleProcessor.cpp
    Source/audio/voices/SampleVoiceProcessor.h
    Source/audio/voices/SampleVoiceProcessor.cpp
    Source/audio/graph/VoiceProcessor.h
    Source/audio/graph/VoiceProcessor.cpp
    Source/audio/assets/SampleBank.h
    Source/audio/assets/SampleBank.cpp
    Source/utils/RtLogger.h
    Source/utils/RtLogger.cpp
    Source/audio/modules/VocalTractFilterModuleProcessor.h
    Source/audio/modules/VocalTractFilterModuleProcessor.cpp
    Source/audio/modules/VstHostModuleProcessor.h
    Source/audio/modules/VstHostModuleProcessor.cpp
    Source/audio/modules/MultiSequencerModuleProcessor.h
    Source/audio/modules/MultiSequencerModuleProcessor.cpp
    Source/audio/modules/LagProcessorModuleProcessor.h
    Source/audio/modules/LagProcessorModuleProcessor.cpp
    Source/audio/modules/DeCrackleModuleProcessor.h
    Source/audio/modules/DeCrackleModuleProcessor.cpp
    Source/audio/modules/GraphicEQModuleProcessor.h
    Source/audio/modules/GraphicEQModuleProcessor.cpp
    Source/audio/modules/FrequencyGraphModuleProcessor.h
    Source/audio/modules/FrequencyGraphModuleProcessor.cpp
    Source/audio/modules/ChorusModuleProcessor.h
    Source/audio/modules/ChorusModuleProcessor.cpp
    Source/audio/modules/PhaserModuleProcessor.h
    Source/audio/modules/PhaserModuleProcessor.cpp
    Source/audio/modules/CompressorModuleProcessor.h
    Source/audio/modules/CompressorModuleProcessor.cpp
    Source/audio/modules/RecordModuleProcessor.h
    Source/audio/modules/RecordModuleProcessor.cpp
    Source/audio/modules/CommentModuleProcessor.h
    Source/audio/modules/CommentModuleProcessor.cpp
    Source/audio/modules/LimiterModuleProcessor.h
    Source/audio/modules/LimiterModuleProcessor.cpp
    Source/audio/modules/GateModuleProcessor.h
    Source/audio/modules/GateModuleProcessor.cpp
    Source/audio/modules/DriveModuleProcessor.h
    Source/audio/modules/DriveModuleProcessor.cpp
    Source/audio/modules/InletModuleProcessor.h
    Source/audio/modules/InletModuleProcessor.cpp
    Source/audio/modules/OutletModuleProcessor.h
    Source/audio/modules/OutletModuleProcessor.cpp
    Source/audio/modules/MetaModuleProcessor.h
    Source/audio/modules/MetaModuleProcessor.cpp
    Source/audio/modules/SnapshotSequencerModuleProcessor.h
    Source/audio/modules/SnapshotSequencerModuleProcessor.cpp
    Source/audio/modules/MIDICVModuleProcessor.h
    Source/audio/modules/MIDICVModuleProcessor.cpp
    Source/audio/modules/MIDIFadersModuleProcessor.h
    Source/audio/modules/MIDIFadersModuleProcessor.cpp
    Source/audio/modules/MIDIKnobsModuleProcessor.h
    Source/audio/modules/MIDIKnobsModuleProcessor.cpp
    Source/audio/modules/MIDIButtonsModuleProcessor.h
    Source/audio/modules/MIDIButtonsModuleProcessor.cpp
    Source/audio/modules/MIDIJogWheelModuleProcessor.h
    Source/audio/modules/MIDIJogWheelModuleProcessor.cpp
    Source/audio/modules/MIDIPadModuleProcessor.h
    Source/audio/modules/MIDIPadModuleProcessor.cpp
    Source/audio/modules/MidiLoggerModuleProcessor.h
    Source/audio/modules/MidiLoggerModuleProcessor.cpp
    Source/audio/modules/TempoClockModuleProcessor.h
    Source/audio/modules/TempoClockModuleProcessor.cpp
    Source/audio/modules/PhysicsModuleProcessor.h
    Source/audio/modules/PhysicsModuleProcessor.cpp
    Source/audio/modules/StrokeSequencerModuleProcessor.h
    Source/audio/modules/StrokeSequencerModuleProcessor.cpp
    Source/audio/modules/TapTempo.h
    Source/audio/modules/TapTempo.cpp
    Source/audio/modules/BPMMonitorModuleProcessor.h
    Source/audio/modules/BPMMonitorModuleProcessor.cpp
    Source/audio/modules/AnimationModuleProcessor.h
    Source/audio/modules/AnimationModuleProcessor.cpp
    Source/video/VideoFrameManager.h
    Source/video/CameraEnumerator.h
    Source/audio/modules/WebcamLoaderModule.h
    Source/audio/modules/WebcamLoaderModule.cpp
    Source/audio/modules/VideoFileLoaderModule.h
    Source/audio/modules/VideoFileLoaderModule.cpp
    Source/audio/modules/FFmpegAudioReader.h
    Source/audio/modules/FFmpegAudioReader.cpp
    Source/audio/modules/TimeStretcherAudioSource.h
    Source/audio/modules/TimeStretcherAudioSource.cpp
    Source/audio/modules/VideoFXModule.h
    Source/audio/modules/VideoFXModule.cpp
    Source/audio/modules/MovementDetectorModule.h
    Source/audio/modules/MovementDetectorModule.cpp
    Source/audio/modules/HumanDetectorModule.h
    Source/audio/modules/HumanDetectorModule.cpp
    Source/audio/modules/PoseEstimatorModule.h
    Source/audio/modules/PoseEstimatorModule.cpp
    Source/audio/modules/HandTrackerModule.h
    Source/audio/modules/HandTrackerModule.cpp
    Source/audio/modules/FaceTrackerModule.h
    Source/audio/modules/FaceTrackerModule.cpp
    Source/audio/modules/ObjectDetectorModule.h
    Source/audio/modules/ObjectDetectorModule.cpp
    Source/audio/modules/ColorTrackerModule.h
    Source/audio/modules/ColorTrackerModule.cpp
    Source/audio/modules/ContourDetectorModule.h
    Source/audio/modules/ContourDetectorModule.cpp
    Source/audio/modules/SemanticSegmentationModule.h
    Source/audio/modules/SemanticSegmentationModule.cpp
    Source/audio/modules/CropVideoModule.h
    Source/audio/modules/CropVideoModule.cpp
    Source/animation/AnimationData.h
    Source/animation/RawAnimationData.h
    Source/animation/RawAnimationData.cpp
    Source/animation/AnimationBinder.h
    Source/animation/AnimationBinder.cpp
    Source/animation/Animator.h
    Source/animation/Animator.cpp
    Source/animation/AnimationFileLoader.h
    Source/animation/AnimationFileLoader.cpp
    Source/animation/GltfLoader.h
    Source/animation/GltfLoader.cpp
    Source/animation/FbxLoader.h
    Source/animation/FbxLoader.cpp
    Source/animation/AnimationRenderer.h
    Source/animation/AnimationRenderer.cpp
)

# This target now needs to know where to find all the headers
target_include_directories(PresetCreatorApp PRIVATE
    ${imgui_fc_SOURCE_DIR}
    ${imgui_fc_SOURCE_DIR}/backends
    ${imnodes_fc_SOURCE_DIR}
    ${imgui_juce_fc_SOURCE_DIR}
    ${PIPER_DIR}
    ${ONNXRUNTIME_DIR}/include
    ${CMAKE_SOURCE_DIR}/../vendor/openvino_toolkit_windows_2025.3.0.19807.44526285f24_x86_64/samples/cpp/thirdparty/nlohmann_json/single_include
    ${CMAKE_SOURCE_DIR}/../soundtouch/include
    ${CMAKE_SOURCE_DIR}/../soundtouch/source/SoundTouch
    ${ufbx_SOURCE_DIR}
    $<$<BOOL:${FFMPEG_FOUND}>:${FFMPEG_INCLUDE_DIR}>
    # OpenCV include directories - source and generated headers
    ${opencv_SOURCE_DIR}/include
    ${opencv_SOURCE_DIR}/modules/core/include
    ${opencv_SOURCE_DIR}/modules/imgproc/include
    ${opencv_SOURCE_DIR}/modules/imgcodecs/include
    ${opencv_SOURCE_DIR}/modules/videoio/include
    ${opencv_SOURCE_DIR}/modules/highgui/include
    ${opencv_SOURCE_DIR}/modules/video/include
    ${opencv_SOURCE_DIR}/modules/objdetect/include
    ${opencv_SOURCE_DIR}/modules/features2d/include
    ${opencv_SOURCE_DIR}/modules/calib3d/include
    ${opencv_SOURCE_DIR}/modules/dnn/include              # For DNN headers (dnn.hpp)
    ${OPENCV_BUILD_DIR}
    ${OPENCV_BUILD_DIR}/modules/world
    # OpenCV CUDA modules (from opencv_contrib source)
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaimgproc/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudawarping/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaarithm/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafilters/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudafeatures2d/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaobjdetect/include>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:${opencv_contrib_SOURCE_DIR}/modules/cudaoptflow/include>
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_INCLUDE_DIR}>
)

# This target also needs the compile definitions
target_compile_definitions(PresetCreatorApp PRIVATE
    JUCE_APPLICATION_NAME_STRING="$<TARGET_PROPERTY:PresetCreatorApp,PRODUCT_NAME>"
    JUCE_APPLICATION_VERSION_STRING="$<TARGET_PROPERTY:PresetCreatorApp,VERSION>"
    JUCE_WEB_BROWSER=0 JUCE_USE_CURL=0
    JUCE_PLUGINHOST_VST3=1
    IMGUI_IMPL_JUCE_BEZEL=0
    IMGUI_DEFINE_MATH_OPERATORS
    IMNODES_NAMESPACE=ImNodes
    IMNODES_STATIC_DEFINE
    PRESET_CREATOR_UI=1
    $<$<BOOL:${USE_RUBBERBAND}>:USE_RUBBERBAND=1>
    $<$<NOT:$<BOOL:${USE_RUBBERBAND}>>:USE_RUBBERBAND=0>
    $<$<BOOL:${CUDA_SUPPORT_ENABLED}>:WITH_CUDA_SUPPORT=1>
)

target_link_libraries(PresetCreatorApp PRIVATE
    juce::juce_gui_extra
    juce::juce_opengl
    juce::juce_audio_devices
    juce::juce_audio_processors
    juce::juce_audio_utils
    juce::juce_audio_formats
    juce::juce_dsp
    imgui_impl_juce
    soundtouch
    box2d
    glm::glm
    tinygltf
    ufbx_static
    opencv_world
    $<$<BOOL:${USE_RUBBERBAND}>:${RUBBERBAND_TARGET}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVFORMAT_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVCODEC_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${AVUTIL_LIBRARY}>
    $<$<BOOL:${FFMPEG_FOUND}>:${SWRESAMPLE_LIBRARY}>
    # Piper TTS libraries (pre-built)
    ${ONNXRUNTIME_DIR}/lib/onnxruntime.lib
)

# Link CUDA runtime for OpenCV CUDA symbols
# Use CUDAToolkit::cudart if available, otherwise link directly
if(TARGET CUDAToolkit::cudart)
    target_link_libraries(PresetCreatorApp PRIVATE CUDAToolkit::cudart)
elseif(CUDA_CUDART_LIBRARY)
    target_link_libraries(PresetCreatorApp PRIVATE ${CUDA_CUDART_LIBRARY})
endif()

# Link Windows libraries for native camera enumeration (DirectShow)
if(WIN32)
    target_link_libraries(PresetCreatorApp PRIVATE ole32 strmiids)
endif()

if(WIN32)
    # Copy Piper executable and DLLs to output directories
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper.exe"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper_phonemize.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/espeak-ng.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime_providers_shared.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
        # Copy OpenCV FFmpeg video backend DLL (relative to build tree)
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${CMAKE_BINARY_DIR}/bin/$<CONFIG>/opencv_videoio_ffmpeg4130_64.dll"
                "$<TARGET_FILE_DIR:ColliderApp>"
    )
    
    # Copy FFmpeg DLLs separately (if FFmpeg is found)
    # We need to copy each DLL individually to avoid generator expression issues
    if(FFMPEG_FOUND AND EXISTS "${FFMPEG_BIN_DIR}")
        file(GLOB FFMPEG_DLLS "${FFMPEG_BIN_DIR}/*.dll")
        if(FFMPEG_DLLS)
            foreach(DLL ${FFMPEG_DLLS})
                get_filename_component(DLL_NAME ${DLL} NAME)
                add_custom_command(
                    TARGET ColliderApp POST_BUILD
                    COMMAND ${CMAKE_COMMAND} -E copy_if_different
                            "${DLL}"
                            "$<TARGET_FILE_DIR:ColliderApp>"
                    COMMENT "Copying ${DLL_NAME} to ColliderApp"
                )
                add_custom_command(
                    TARGET PresetCreatorApp POST_BUILD
                    COMMAND ${CMAKE_COMMAND} -E copy_if_different
                            "${DLL}"
                            "$<TARGET_FILE_DIR:PresetCreatorApp>"
                    COMMENT "Copying ${DLL_NAME} to PresetCreatorApp"
                )
            endforeach()
        endif()
    endif()
    
    # Continue with other files for ColliderApp
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${PIPER_DIR}/espeak-ng-data"
                "$<TARGET_FILE_DIR:ColliderApp>/espeak-ng-data"
        COMMENT "Copying espeak-ng-data to ColliderApp output directory"
    )
    add_custom_command(
        TARGET ColliderApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${opencv_SOURCE_DIR}/data/haarcascades/haarcascade_frontalface_default.xml"
                "$<TARGET_FILE_DIR:ColliderApp>"
        COMMENT "Copying OpenCV data to ColliderApp output directory"
    )
    add_custom_command(
        TARGET PresetCreatorApp POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper.exe"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/piper_phonemize.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${PIPER_DIR}/espeak-ng.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${ONNXRUNTIME_DIR}/lib/onnxruntime_providers_shared.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        # Copy OpenCV FFmpeg video backend DLL (relative to build tree)
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${CMAKE_BINARY_DIR}/bin/$<CONFIG>/opencv_videoio_ffmpeg4130_64.dll"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${PIPER_DIR}/espeak-ng-data"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/espeak-ng-data"
        # NEW (Corrected): Copy the entire assets folder
        COMMAND ${CMAKE_COMMAND} -E copy_directory
                "${CMAKE_SOURCE_DIR}/assets"
                "$<TARGET_FILE_DIR:PresetCreatorApp>/assets"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${opencv_SOURCE_DIR}/data/haarcascades/haarcascade_frontalface_default.xml"
                "$<TARGET_FILE_DIR:PresetCreatorApp>"
        COMMENT "Copying Piper TTS, OpenPose, FFmpeg, and other runtime assets to PresetCreatorApp output directory"
    )
endif()

