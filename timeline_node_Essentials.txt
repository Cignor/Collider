
================================================================================
FILE: architecture\00_PROJECT_OVERVIEW.md
================================================================================


# Collider PYO - Project Architecture

## Overview
This is a 2D physics simulation game built with **Pyglet** and **Pymunk**, featuring interactive tools, real-time physics, and audio integration using the **PYO** library. The project combines physics simulation with audio synthesis and effects.

## Project Structure

### Core Game Engine (`pyglet_physics_game/`)
The main game engine built with Pyglet for rendering and Pymunk for physics simulation.

### Audio System (`audio/`)
Audio generation and synthesis system using PYO library with frequency generators, noise generators, and sample libraries.

### Testing Framework (`tests/`)
Comprehensive test suite covering physics, audio, and rendering components.

### Documentation (`guide/`)
Technical guides and documentation for various components.

### Backup System (`BACKUPS/`)
Version control and backup system with timestamped snapshots of the project.

## Key Technologies

- **Pyglet**: 2D graphics and window management
- **Pymunk**: 2D physics simulation
- **SignalFlow**: Audio synthesis and processing
- **PyCairo**: Vector graphics rendering
- **NumPy**: Numerical computations

## Architecture Principles

1. **Modular Design**: Each system is self-contained with clear interfaces
2. **Performance First**: Optimized for high FPS and real-time physics
3. **Audio Integration**: Seamless integration between physics and audio
4. **Extensible Tools**: Easy to add new physics tools and audio effects
5. **Cross-Platform**: Designed to work on Windows, macOS, and Linux

## Entry Points

- `run_game.py`: Main entry point for the game
- `pyglet_physics_game/main.py`: Core game engine entry point
- `test_gemini.py`: Testing entry point

## Dependencies

See `requirements.txt` for complete dependency list including:
- Pyglet 2.1.8+
- Pymunk 8.0.0+
- SignalFlow (latest)
- PyCairo 1.25.0+
- NumPy 1.24.0+

## Development Workflow

1. **Core Development**: Work in `pyglet_physics_game/` directory
2. **Audio Development**: Work in `audio/` directory
3. **Testing**: Use `tests/` directory for comprehensive testing
4. **Backup**: Automatic backups in `BACKUPS/` directory
5. **Documentation**: Update relevant `.md` files in each directory

## Performance Targets

- **Physics**: 60 FPS physics simulation
- **Rendering**: 1200+ FPS target rendering
- **Audio**: Real-time audio synthesis with minimal latency
- **Memory**: Efficient object pooling and cleanup

## Future Enhancements

- 3D rendering capabilities
- Advanced audio effects
- Multiplayer support
- Scene save/load system
- Plugin architecture for custom tools


================================================================================
FILE: architecture\01_CORE_GAME_ENGINE.md
================================================================================


# Pyglet Physics Game - Architecture Documentation

## Overview
The main game engine built with Pyglet for rendering and Pymunk for physics simulation. This is the core of the Collider PYO project, featuring real-time physics, interactive tools, and audio integration.

## Core Architecture

### Main Entry Point
- **`main.py`**: Entry point that initializes and runs the PhysicsGame
- **`game/game_core.py`**: Core game class that orchestrates all systems

### System Architecture
The game follows a modular architecture with clear separation of concerns:

```
PhysicsGame (game_core.py)
├── Physics Engine (Pymunk)
├── Rendering System (Pyglet)
├── Input Handling
├── Audio Integration (PYO)
├── UI Systems
└── Performance Monitoring
```

## Directory Structure

### `/game/` - Core Game Logic
- **`game_core.py`**: Main PhysicsGame class
  - Initializes all subsystems
  - Manages game loop and timing
  - Handles physics simulation (60 FPS)
  - Coordinates rendering and input
  - Manages audio bullet system

### `/physics/` - Physics Engine
- **`physics_manager.py`**: Physics space management
  - Screen wrapping for objects
  - Tool effect application
  - Collision shape management
  - Gravity control
- **`physics_objects.py`**: Physics object definitions
- **`physics_tools.py`**: Interactive physics tools
  - Collision Tool (C)
  - Wind Tool (W)
  - Magnet Tool (M)
  - Teleporter Tool (T)
  - FreeDraw Tool (F)
- **`stroke_optimizer.py`**: Stroke optimization for performance

### `/rendering/` - Graphics System
- **`renderer.py`**: Main rendering engine
  - Pyglet batch rendering for performance
  - Layered rendering system
  - Background and grid rendering
  - Physics object rendering
  - UI overlay rendering

### `/input/` - Input Handling
- **`input_handler.py`**: Input event processing
  - Keyboard input (tool switching, physics control)
  - Mouse input (tool usage, object spawning)
  - Event delegation to tools and systems

### `/systems/` - Game Systems
- **`particle_system.py`**: Particle effects and visual feedback
- **`collision_system.py`**: Collision detection and response
- **`wind_system.py`**: Wind physics simulation
- **`trail_system.py`**: Object trail rendering
- **`bullet_manager.py`**: Bullet system management
- **`sound_bullet.py`**: Audio-integrated bullets
- **`bullet_data.py`**: Bullet data structures

### `/ui/` - User Interface
- **`manager.py`**: UI system manager
- **`modular_hud.py`**: Modular HUD system
- **`theme.py`**: UI theming system
- **`color_manager.py`**: Color management
- **`coordinate_system.py`**: Coordinate system management
- **`grid_system.py`**: Grid system for snapping
- **`mouse_system.py`**: Mouse interaction system
- **`visual_feedback.py`**: Visual feedback system
- **`debug_window.py`**: Debug information display

### `/tools/` - Audio and Physics Tools
- **`audio_effects/`**: Audio effect processors
- **`melody/`**: Melody generation tools
- **`physics_effects/`**: Physics effect tools

### `/shapes/` - Shape Management
- **`shape_manager.py`**: Shape creation and management
- **`shapes.json`**: Shape definitions

### `/utils/` - Utilities
- **`performance_monitor.py`**: Performance monitoring
- **`debug_utils.py`**: Debug utilities

## Key Features

### Physics System
- **Pymunk Integration**: 2D physics simulation
- **60 FPS Physics**: Fixed timestep for stability
- **Screen Wrapping**: Classic arcade-style object wrapping
- **Tool Integration**: Physics tools affect simulation

### Rendering System
- **Pyglet Graphics**: Hardware-accelerated rendering
- **Batch Rendering**: Single batch for maximum performance
- **Layered Rendering**: Proper depth ordering
- **Performance Optimization**: 1200+ FPS target

### Audio Integration
- **PYO Library**: Real-time audio synthesis
- **Sound Bullets**: Audio-integrated physics objects
- **Audio Presets**: Configurable audio properties
- **Real-time Processing**: Low-latency audio

### UI System
- **Modular Design**: Extensible UI components
- **Theme System**: Dynamic theming
- **Grid System**: Precise positioning and snapping
- **Debug Tools**: Comprehensive debugging interface

## Performance Characteristics

### Target Performance
- **Physics**: 60 FPS simulation
- **Rendering**: 1200+ FPS
- **Audio**: Real-time with minimal latency
- **Memory**: Efficient object pooling

### Optimization Strategies
- **Batch Rendering**: Single draw call for most elements
- **Object Pooling**: Reuse of physics objects
- **LOD System**: Level of detail for distant objects
- **Spatial Partitioning**: Efficient collision detection

## Integration Points

### Audio System
- Sound bullets integrate with physics
- Audio properties affect visual appearance
- Real-time audio synthesis based on physics

### UI System
- Grid system provides precise positioning
- Theme system affects all visual elements
- Debug system provides comprehensive monitoring

### Physics Tools
- Tools modify physics space
- Visual feedback for tool usage
- Real-time physics manipulation

## Development Guidelines

### Adding New Features
1. **Physics**: Add to `/physics/` directory
2. **Rendering**: Add to `/rendering/` directory
3. **UI**: Add to `/ui/` directory
4. **Systems**: Add to `/systems/` directory

### Performance Considerations
- Use batch rendering for multiple objects
- Implement object pooling for frequently created objects
- Minimize per-frame allocations
- Use efficient data structures

### Testing
- Test with high object counts
- Verify performance targets
- Test audio integration
- Validate physics accuracy

## Dependencies

### Core Dependencies
- **Pyglet 2.1.8+**: Graphics and window management
- **Pymunk 8.0.0+**: Physics simulation
- **SignalFlow**: Audio synthesis

### Additional Dependencies
- **NumPy**: Numerical computations
- **PyCairo**: Vector graphics

## Future Enhancements

### Planned Features
- 3D rendering capabilities
- Advanced audio effects
- Multiplayer support
- Scene save/load system
- Plugin architecture

### Performance Improvements
- GPU-accelerated physics
- Advanced culling techniques
- Memory optimization
- Multi-threading support


================================================================================
FILE: architecture\02_AUDIO_SYSTEM.md
================================================================================


# Audio System - Architecture Documentation

## Overview
The audio system provides real-time audio synthesis and processing using the SignalFlow library. It integrates with the physics simulation to create audio-visual experiences where physics objects generate sound based on their properties and interactions.

## System Architecture

### Core Components
- **Frequency Generators**: Pure tone generation (sine, square, triangle waves)
- **Noise Generators**: Various noise types (white, pink, brown)
- **Sample Library**: Pre-recorded audio samples for effects and instruments
- **Audio Integration**: Real-time audio synthesis based on physics

### Directory Structure

#### `/frequencies/` - Pure Tone Generation
- **`sine.py` & `sine.json`**: Sine wave generator
  - Frequency range: 20Hz - 20kHz
  - Gain control: -24dB to +12dB
- **`square.py` & `square.json`**: Square wave generator
  - Same parameter structure as sine
- **`triangle.py` & `triangle.json`**: Triangle wave generator
  - Same parameter structure as sine

#### `/noise/` - Noise Generation
- **`white_noise.py` & `white_noise.json`**: White noise generator
  - Gain control: -24dB to +12dB
  - Fade control: 0-2000ms
- **`pink_noise.py` & `pink_noise.json`**: Pink noise generator
- **`brown_noise.py` & `brown_noise.json`**: Brown noise generator

#### `/samples/` - Sample Library
- **`ambient/`**: Atmospheric and ambient sounds
  - Bass slides, duduk, joombush samples
  - Various musical keys and scales
- **`effects/`**: Sound effects and transitions
  - Animal sounds, psy FX
  - Various tempos and keys
- **`melodic/`**: Melodic instruments and fills
  - Saxophone, kemenche, bansuri, koto
  - Steel drums, orchestra, synth fills
- **`percussion/`**: Rhythmic elements
  - Acoustic crashes, kicks, rides, toms
  - Various timbres and dynamics
- **`new/`**: New sample additions

## Audio Integration

### Physics-Audio Connection
- **Sound Bullets**: Physics objects that generate audio
- **Material Properties**: Different materials produce different sounds
- **Real-time Synthesis**: Audio parameters change based on physics
- **Spatial Audio**: Position-based audio effects

### Audio Properties
Each audio generator has configurable parameters:
- **Frequency**: Pitch control for tone generators
- **Gain**: Volume control (-24dB to +12dB)
- **Fade**: Envelope control for noise generators
- **Material Type**: Affects audio characteristics

## Technical Implementation

### SignalFlow Integration
- **Real-time Processing**: Low-latency audio synthesis
- **Parameter Control**: Dynamic parameter adjustment
- **Audio Threading**: Separate audio processing thread
- **Buffer Management**: Efficient audio buffer handling

### Parameter System
- **JSON Configuration**: Human-readable parameter files
- **Type Safety**: Strongly typed parameters
- **Range Validation**: Min/max value constraints
- **Step Control**: Precise parameter adjustment

### Sample Management
- **WAV Format**: High-quality audio samples
- **Memory Management**: Efficient sample loading
- **Caching**: Sample preloading for performance
- **Streaming**: Large sample streaming support

## Audio Categories

### Frequency Generators
- **Pure Tones**: Sine, square, triangle waves
- **Harmonic Content**: Different wave shapes
- **Frequency Range**: Full audible spectrum
- **Real-time Control**: Dynamic frequency adjustment

### Noise Generators
- **White Noise**: Equal energy across all frequencies
- **Pink Noise**: Equal energy per octave
- **Brown Noise**: More energy in lower frequencies
- **Fade Control**: Envelope shaping

### Sample Library
- **Ambient**: Atmospheric and background sounds
- **Effects**: Transitions and special effects
- **Melodic**: Musical instruments and melodies
- **Percussion**: Rhythmic and percussive elements

## Performance Characteristics

### Audio Quality
- **Sample Rate**: 44.1kHz standard
- **Bit Depth**: 16-bit minimum, 24-bit preferred
- **Latency**: <10ms target
- **Dynamic Range**: 96dB theoretical

### Memory Usage
- **Sample Caching**: Efficient memory management
- **Streaming**: Large sample support
- **Compression**: Lossless compression where possible
- **Garbage Collection**: Automatic cleanup

## Integration with Physics

### Sound Bullet System
- **Physics Objects**: Generate audio based on properties
- **Material Types**: Different materials, different sounds
- **Collision Audio**: Sound on impact
- **Movement Audio**: Continuous sound based on motion

### Real-time Parameters
- **Frequency**: Based on object velocity
- **Gain**: Based on object mass
- **Effects**: Based on object material
- **Spatial**: Based on object position

## Development Guidelines

### Adding New Generators
1. Create `.py` file with generator class
2. Create `.json` file with parameters
3. Implement PYO integration
4. Add to audio system registry

### Adding New Samples
1. Place WAV files in appropriate category
2. Use descriptive naming convention
3. Ensure proper audio quality
4. Update sample index

### Performance Optimization
- Use efficient audio processing
- Minimize memory allocations
- Implement proper caching
- Use appropriate sample rates

## Future Enhancements

### Planned Features
- **Advanced Effects**: Reverb, delay, distortion
- **Synthesis**: More complex synthesis methods
- **Spatial Audio**: 3D audio positioning
- **MIDI Integration**: MIDI input/output support

### Audio Quality Improvements
- **Higher Sample Rates**: 48kHz, 96kHz support
- **Better Compression**: Advanced audio compression
- **Real-time Effects**: More audio effects
- **Audio Analysis**: FFT analysis and visualization

## Dependencies

### Core Dependencies
- **SignalFlow**: Audio synthesis library
- **NumPy**: Numerical computations
- **Pydub**: Audio file processing
- **Librosa**: Audio analysis

### Additional Dependencies
- **Mido**: MIDI file handling
- **Midiutil**: MIDI creation
- **Midi2audio**: MIDI to audio conversion
- **Espeakng**: Text-to-speech

## Troubleshooting

### Common Issues
- **Audio Latency**: Check buffer size settings
- **Memory Usage**: Monitor sample caching
- **Audio Quality**: Verify sample rate settings
- **Performance**: Check CPU usage

### Debug Tools
- **Audio Monitor**: Real-time audio level monitoring
- **Parameter Display**: Current parameter values
- **Performance Metrics**: Audio processing statistics
- **Error Logging**: Detailed error information


================================================================================
FILE: juce\Source\audio\modules\TimingData.h
================================================================================


#pragma once

#include <juce_core/juce_core.h>
#include <vector>

struct PhonemeTiming
{
	juce::String phoneme;
	double startTimeSeconds{};
	double endTimeSeconds{};
	double durationSeconds{};

	PhonemeTiming() = default;
	PhonemeTiming(const juce::String& p, double start, double end)
		: phoneme(p), startTimeSeconds(start), endTimeSeconds(end), durationSeconds(end - start) {}
};

struct WordTiming
{
	juce::String word;
	double startTimeSeconds{};
	double endTimeSeconds{};
	double durationSeconds{};
	std::vector<PhonemeTiming> phonemes;

	WordTiming() = default;
	WordTiming(const juce::String& w, double start, double end)
		: word(w), startTimeSeconds(start), endTimeSeconds(end), durationSeconds(end - start) {}
};


================================================================================
FILE: juce\Source\audio\modules\TempoClockModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class TempoClockModuleProcessor : public ModuleProcessor
{
public:
    TempoClockModuleProcessor();
    ~TempoClockModuleProcessor() override = default;

    // Parameter IDs for APVTS
    static constexpr auto paramIdBpm              = "bpm";
    static constexpr auto paramIdSwing            = "swing";
    static constexpr auto paramIdDivision         = "division";
    static constexpr auto paramIdGateWidth        = "gateWidth";
    static constexpr auto paramIdSyncToHost       = "syncToHost";
    static constexpr auto paramIdDivisionOverride = "divisionOverride";

    // Virtual modulation/control input IDs (no APVTS parameters required)
    static constexpr auto paramIdBpmMod       = "bpm_mod";
    static constexpr auto paramIdTapMod       = "tap_mod";
    static constexpr auto paramIdNudgeUpMod   = "nudge_up_mod";
    static constexpr auto paramIdNudgeDownMod = "nudge_down_mod";
    static constexpr auto paramIdPlayMod      = "play_mod";
    static constexpr auto paramIdStopMod      = "stop_mod";
    static constexpr auto paramIdResetMod     = "reset_mod";
    static constexpr auto paramIdSwingMod     = "swing_mod";

    const juce::String getName() const override { return "tempo_clock"; }

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void setTimingInfo(const TransportState& state) override { m_currentTransport = state; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

    // Parameter bus contract (virtual modulation IDs)
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

    juce::String getAudioInputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "BPM Mod";
            case 1: return "Tap";
            case 2: return "Nudge+";
            case 3: return "Nudge-";
            case 4: return "Play";
            case 5: return "Stop";
            case 6: return "Reset";
            case 7: return "Swing Mod";
            default: return juce::String("In ") + juce::String(channel + 1);
        }
    }

    juce::String getAudioOutputLabel(int channel) const override
    {
        switch (channel)
        {
            case 0: return "Clock";
            case 1: return "Beat Trig";
            case 2: return "Bar Trig";
            case 3: return "Beat Gate";
            case 4: return "Phase";
            case 5: return "BPM CV";
            case 6: return "Downbeat";
            default: return juce::String("Out ") + juce::String(channel + 1);
        }
    }

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    // Parameters
    juce::AudioProcessorValueTreeState apvts;
    std::atomic<float>* bpmParam { nullptr };
    std::atomic<float>* swingParam { nullptr };
    std::atomic<float>* divisionParam { nullptr };
    std::atomic<float>* gateWidthParam { nullptr };
    std::atomic<float>* syncToHostParam { nullptr };
    std::atomic<float>* divisionOverrideParam { nullptr };

    // Transport cache for per-block start
    TransportState m_currentTransport;

    // Internal state for tap/nudge and trigger edge detection
    double sampleRateHz { 0.0 };
    int lastBeatIndex { 0 };
    int lastBarIndex { 0 };
    double lastScaledBeats { 0.0 };
    bool lastPlayHigh { false };
    bool lastStopHigh { false };
    bool lastResetHigh { false };
    bool lastTapHigh { false };
    bool lastNudgeUpHigh { false };
    bool lastNudgeDownHigh { false };
    double samplesSinceLastTap { 0.0 };
    bool hasPreviousTap { false };  // Track if we have a valid previous tap for BPM calculation
    
    // UI tap button state (for GUI thread to trigger taps)
    std::atomic<double> uiTapTimestamp { 0.0 };  // Timestamp of last UI tap (in seconds)
    double lastProcessedUiTap { 0.0 };  // Last tap timestamp we've processed (audio thread)
};




================================================================================
FILE: juce\Source\audio\modules\TempoClockModuleProcessor.cpp
================================================================================


#include "TempoClockModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"

TempoClockModuleProcessor::TempoClockModuleProcessor()
    : ModuleProcessor(BusesProperties()
          .withInput("Mods", juce::AudioChannelSet::discreteChannels(8), true)    // bpm,tap,nudge+,nudge-,play,stop,reset,swing
          .withOutput("Clock", juce::AudioChannelSet::discreteChannels(7), true)), // clock, beatTrig, barTrig, beatGate, phase, bpmCv, downbeat
      apvts(*this, nullptr, "TempoClockParams", createParameterLayout())
{
    bpmParam = apvts.getRawParameterValue(paramIdBpm);
    swingParam = apvts.getRawParameterValue(paramIdSwing);
    divisionParam = apvts.getRawParameterValue(paramIdDivision);
    gateWidthParam = apvts.getRawParameterValue(paramIdGateWidth);
    syncToHostParam = apvts.getRawParameterValue(paramIdSyncToHost);
    divisionOverrideParam = apvts.getRawParameterValue(paramIdDivisionOverride);
}

juce::AudioProcessorValueTreeState::ParameterLayout TempoClockModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdBpm, "BPM", juce::NormalisableRange<float>(20.0f, 300.0f, 0.01f, 0.3f), 120.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdSwing, "Swing", juce::NormalisableRange<float>(0.0f, 0.75f, 0.0f, 1.0f), 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterChoice>(paramIdDivision, "Division", juce::StringArray{"1/32","1/16","1/8","1/4","1/2","1","2","4"}, 3));
    params.push_back(std::make_unique<juce::AudioParameterFloat>(paramIdGateWidth, "Gate Width", juce::NormalisableRange<float>(0.01f, 0.99f, 0.0f, 1.0f), 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdSyncToHost, "Sync to Host", false));
    params.push_back(std::make_unique<juce::AudioParameterBool>(paramIdDivisionOverride, "Division Override", false));
    return { params.begin(), params.end() };
}

void TempoClockModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    sampleRateHz = sampleRate;
}

void TempoClockModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto in = getBusBuffer(buffer, true, 0);
    auto out = getBusBuffer(buffer, false, 0);
    
    const int numSamples = buffer.getNumSamples();
    if (numSamples <= 0 || sampleRateHz <= 0.0)
        return;
    
    // FIX: DON'T clear output buffer yet - it might alias with input buffer!
    // We'll write to all output channels explicitly, so no need to clear.

    // Read CV inputs ONLY if connected (BestPractice/TTS pattern)
    const bool bpmMod = isParamInputConnected(paramIdBpmMod);
    const bool tapMod = isParamInputConnected(paramIdTapMod);
    const bool nudgeUpMod = isParamInputConnected(paramIdNudgeUpMod);
    const bool nudgeDownMod = isParamInputConnected(paramIdNudgeDownMod);
    const bool playMod = isParamInputConnected(paramIdPlayMod);
    const bool stopMod = isParamInputConnected(paramIdStopMod);
    const bool resetMod = isParamInputConnected(paramIdResetMod);
    const bool swingMod = isParamInputConnected(paramIdSwingMod);

    const float* bpmCV       = (bpmMod       && in.getNumChannels() > 0) ? in.getReadPointer(0) : nullptr;
    const float* tapCV       = (tapMod       && in.getNumChannels() > 1) ? in.getReadPointer(1) : nullptr;
    const float* nudgeUpCV   = (nudgeUpMod   && in.getNumChannels() > 2) ? in.getReadPointer(2) : nullptr;
    const float* nudgeDownCV = (nudgeDownMod && in.getNumChannels() > 3) ? in.getReadPointer(3) : nullptr;
    const float* playCV      = (playMod      && in.getNumChannels() > 4) ? in.getReadPointer(4) : nullptr;
    const float* stopCV      = (stopMod      && in.getNumChannels() > 5) ? in.getReadPointer(5) : nullptr;
    const float* resetCV     = (resetMod     && in.getNumChannels() > 6) ? in.getReadPointer(6) : nullptr;
    const float* swingCV     = (swingMod     && in.getNumChannels() > 7) ? in.getReadPointer(7) : nullptr;

    float bpm = bpmParam->load();
    
    // FIX: Set flag when BPM comes from CV so other sources won't override it (MultiBandShaper pattern)
    bool bpmFromCV = false;
    if (bpmCV)
    {
        const float cv = juce::jlimit(0.0f, 1.0f, bpmCV[0]);
        // Map 0..1 -> 20..300 with perceptual curve
        bpm = juce::jmap(std::pow(cv, 0.3f), 0.0f, 1.0f, 20.0f, 300.0f);
        bpmFromCV = true;
    }

    float swing = swingParam ? swingParam->load() : 0.0f;
    if (swingCV)
        swing = juce::jlimit(0.0f, 0.75f, swingCV[0]);

    // Increment tap counter each block (if we're waiting for a second tap)
    if (hasPreviousTap)
    {
        samplesSinceLastTap += numSamples;
    }

    // Handle edge controls (play/stop/reset/tap/nudge)
    // FIX: Only allow these to modify BPM if CV is NOT connected
    auto edge = [&](const float* cv, bool& last){ bool now = (cv && cv[0] > 0.5f); bool rising = now && !last; last = now; return rising; };
    if (edge(playCV, lastPlayHigh))   if (auto* p = getParent()) p->setPlaying(true);
    if (edge(stopCV, lastStopHigh))   if (auto* p = getParent()) p->setPlaying(false);
    if (edge(resetCV, lastResetHigh)) if (auto* p = getParent()) p->resetTransportPosition();
    
    // TAP TEMPO (CV Input): Calculate BPM from interval between taps (ONLY if BPM CV not connected)
    bool tapDetected = false;
    if (!bpmFromCV && edge(tapCV, lastTapHigh))
    {
        tapDetected = true;
    }
    
    // TAP TEMPO (UI Button): Detect if UI button was pressed
    if (!bpmFromCV)
    {
        const double currentUiTap = uiTapTimestamp.load();
        if (currentUiTap != lastProcessedUiTap && currentUiTap > 0.0)
        {
            tapDetected = true;
            lastProcessedUiTap = currentUiTap;
        }
    }
    
    // Process tap (from CV or UI button)
    if (tapDetected)
    {
        if (hasPreviousTap && samplesSinceLastTap > 0.0)
        {
            // Calculate BPM from time between taps
            const double secondsBetweenTaps = samplesSinceLastTap / sampleRateHz;
            
            // Sanity check: prevent extreme values (20-300 BPM range)
            // Min interval: 0.2 seconds (300 BPM), Max interval: 3.0 seconds (20 BPM)
            if (secondsBetweenTaps >= 0.2 && secondsBetweenTaps <= 3.0)
            {
                float newBPM = 60.0f / static_cast<float>(secondsBetweenTaps);
                bpm = juce::jlimit(20.0f, 300.0f, newBPM);
                
                // Update the parameter so it persists
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdBpm)))
                    *p = bpm;
                
                juce::Logger::writeToLog("[TempoClock] Tap tempo: " + 
                    juce::String(secondsBetweenTaps, 3) + "s interval = " + 
                    juce::String(bpm, 1) + " BPM");
            }
        }
        
        // Reset counter and mark that we have a valid tap
        samplesSinceLastTap = 0.0;
        hasPreviousTap = true;
    }
    
    // TAP TIMEOUT: Reset if no tap for 4 seconds
    if (hasPreviousTap && samplesSinceLastTap > sampleRateHz * 4.0)
    {
        hasPreviousTap = false;
        samplesSinceLastTap = 0.0;
    }
    
    // NUDGE: Only allow if BPM CV not connected
    if (!bpmFromCV)
    {
        if (edge(nudgeUpCV, lastNudgeUpHigh))   { bpm = juce::jlimit(20.0f, 300.0f, bpm + 0.5f); }
        if (edge(nudgeDownCV, lastNudgeDownHigh)) { bpm = juce::jlimit(20.0f, 300.0f, bpm - 0.5f); }
    }

    // Sync to Host: Use host transport tempo OR control it
    // FIX: BPM CV always takes priority over sync-to-host
    bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;
    if (auto* parent = getParent())
    {
        if (syncToHost && !bpmFromCV)  // FIX: Only sync from host if BPM CV is NOT connected
        {
            // Pull tempo FROM host transport (Tempo Clock follows)
            bpm = (float)m_currentTransport.bpm;
            parent->setTempoControlledByModule(false);  // Not controlling
        }
        else
        {
            // Push tempo TO host transport (Tempo Clock controls the global BPM)
            // This includes: manual BPM, BPM CV, tap tempo, and nudge
            parent->setBPM(bpm);
            parent->setTempoControlledByModule(true);  // Controlling - UI should be greyed
        }
    }
    
    // Publish live telemetry AFTER all BPM sources resolved (including sync)
    setLiveParamValue("bpm_live", bpm);
    setLiveParamValue("swing_live", swing);

    // Compute outputs
    float* clockOut = out.getNumChannels() > 0 ? out.getWritePointer(0) : nullptr;
    float* beatTrig = out.getNumChannels() > 1 ? out.getWritePointer(1) : nullptr;
    float* barTrig  = out.getNumChannels() > 2 ? out.getWritePointer(2) : nullptr;
    float* beatGate = out.getNumChannels() > 3 ? out.getWritePointer(3) : nullptr;
    float* phaseOut = out.getNumChannels() > 4 ? out.getWritePointer(4) : nullptr;
    float* bpmOut   = out.getNumChannels() > 5 ? out.getWritePointer(5) : nullptr;
    float* downbeat = out.getNumChannels() > 6 ? out.getWritePointer(6) : nullptr;

    int divisionIdx = divisionParam ? (int)divisionParam->load() : 3; // default 1/4
    
    // Division Override: Broadcast local division to global transport OR clear it
    bool divisionOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
    if (auto* parent = getParent())
    {
        if (divisionOverride)
        {
            // This clock becomes the master division source
            parent->setGlobalDivisionIndex(divisionIdx);
        }
        else
        {
            // Not overriding - clear the global division
            parent->setGlobalDivisionIndex(-1);
        }
    }
    static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0 };
    const double div = divisions[juce::jlimit(0, 7, divisionIdx)];

    // Use transport position + per-sample advancement to produce stable clock
    double sr = juce::jmax(1.0, sampleRateHz);
    double localBeatsStart = m_currentTransport.songPositionBeats;
    double phaseBeats = localBeatsStart;

    for (int i = 0; i < numSamples; ++i)
    {
        // Advance beats using current bpm
        phaseBeats += (1.0 / sr) * (bpm / 60.0);

        // Subdivision phase
        const double scaled = phaseBeats * div;
        const double frac = scaled - std::floor(scaled);

        if (phaseOut) phaseOut[i] = (float) frac;
        if (clockOut) clockOut[i] = frac < 0.01 ? 1.0f : 0.0f;
        if (bpmOut) bpmOut[i] = juce::jmap(bpm, 20.0f, 300.0f, 0.0f, 1.0f);

        // Beat/bar triggers from integer boundaries
        const int beatIndex = (int) std::floor(phaseBeats);
        const int barIndex = beatIndex / 4;
        if (beatTrig) beatTrig[i] = (beatIndex > lastBeatIndex) ? 1.0f : 0.0f;
        if (barTrig)  barTrig[i]  = (barIndex > lastBarIndex)   ? 1.0f : 0.0f;
        if (downbeat) downbeat[i] = (beatIndex > lastBeatIndex && (beatIndex % 4) == 0) ? 1.0f : 0.0f;

        // Gate width within subdivision
        const float gw = gateWidthParam ? gateWidthParam->load() : 0.5f;
        if (beatGate) beatGate[i] = (float)(frac < gw ? 1.0 : 0.0);

        lastBeatIndex = beatIndex;
        lastBarIndex = barIndex;
    }

    // Telemetry and meter
    setLiveParamValue("phase_live", (float)(phaseBeats - std::floor(phaseBeats)));
    if (!lastOutputValues.empty())
    {
        if (!lastOutputValues[0]) lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
        if (lastOutputValues[0]) lastOutputValues[0]->store(out.getNumChannels() > 0 ? out.getSample(0, numSamples - 1) : 0.0f);
    }
}

// Parameter routing: virtual IDs on single input bus
bool TempoClockModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0;
    if (paramId == paramIdBpmMod) { outChannelIndexInBus = 0; return true; }
    if (paramId == paramIdTapMod) { outChannelIndexInBus = 1; return true; }
    if (paramId == paramIdNudgeUpMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdNudgeDownMod) { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdPlayMod) { outChannelIndexInBus = 4; return true; }
    if (paramId == paramIdStopMod) { outChannelIndexInBus = 5; return true; }
    if (paramId == paramIdResetMod) { outChannelIndexInBus = 6; return true; }
    if (paramId == paramIdSwingMod) { outChannelIndexInBus = 7; return true; }
    return false;
}

#if defined(PRESET_CREATOR_UI)
void TempoClockModuleProcessor::drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth(itemWidth);
    
    // Helper for tooltips
    auto HelpMarkerClock = [](const char* desc) {
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip()) {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    // === TEMPO CONTROLS SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Tempo");
    ImGui::Spacing();

    // BPM slider with live display
    bool bpmMod = isParamInputConnected(paramIdBpmMod);  // FIX: Use isParamInputConnected, not isParamModulated
    float bpm = bpmMod ? getLiveParamValueFor(paramIdBpmMod, "bpm_live", bpmParam->load()) : bpmParam->load();
    bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;
    
    // Disable BPM control if synced to host
    if (bpmMod || syncToHost) { ImGui::BeginDisabled(); }
    if (ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f, "%.1f"))
    {
        if (!bpmMod && !syncToHost)
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdBpm))) *p = bpm;
        }
        onModificationEnded();
    }
    if (!bpmMod && !syncToHost) adjustParamOnWheel(apvts.getParameter(paramIdBpm), paramIdBpm, bpm);
    if (bpmMod) { ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    if (syncToHost) { ImGui::SameLine(); ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.8f, 1.0f), "(synced)"); }
    if (bpmMod || syncToHost) { ImGui::EndDisabled(); }
    ImGui::SameLine();
    HelpMarkerClock("Beats per minute (20-300 BPM)\nDisabled when synced to host");
    
    // TAP TEMPO BUTTON
    if (bpmMod || syncToHost) { ImGui::BeginDisabled(); }
    if (ImGui::Button("TAP", ImVec2(itemWidth * 0.3f, 30)))
    {
        // Record tap timestamp (audio thread will detect the change)
        uiTapTimestamp.store(juce::Time::getMillisecondCounterHiRes() / 1000.0);
    }
    if (bpmMod || syncToHost) { ImGui::EndDisabled(); }
    ImGui::SameLine();
    HelpMarkerClock("Click repeatedly to set tempo by tapping\nTap at least twice to calculate BPM");

    // Swing
    bool swingM = isParamInputConnected(paramIdSwingMod);  // FIX: Use isParamInputConnected, not isParamModulated
    float swing = swingM ? getLiveParamValueFor(paramIdSwingMod, "swing_live", swingParam->load()) : swingParam->load();
    if (swingM) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Swing", &swing, 0.0f, 0.75f, "%.2f"))
    {
        if (!swingM)
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdSwing))) *p = swing;
        }
        onModificationEnded();
    }
    if (!swingM) adjustParamOnWheel(apvts.getParameter(paramIdSwing), paramIdSwing, swing);
    if (swingM) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::SameLine();
    HelpMarkerClock("Swing amount (0-75%)\nDelays every other beat for shuffle feel");

    ImGui::Spacing();
    ImGui::Spacing();

    // === CLOCK OUTPUT SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Clock Output");
    ImGui::Spacing();

    // Division + Gate width in-line
    int div = divisionParam ? (int)divisionParam->load() : 3;
    const char* items[] = { "1/32","1/16","1/8","1/4","1/2","1","2","4" };
    ImGui::SetNextItemWidth(itemWidth * 0.5f);
    if (ImGui::Combo("Division", &div, items, 8))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter(paramIdDivision))) *p = div;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Clock output division\n1/4 = quarter notes, 1/16 = sixteenth notes");

    float gw = gateWidthParam ? gateWidthParam->load() : 0.5f;
    ImGui::SetNextItemWidth(itemWidth);
    if (ImGui::SliderFloat("Gate Width", &gw, 0.01f, 0.99f, "%.2f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter(paramIdGateWidth))) *p = gw;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Gate/trigger pulse width (1-99%)");

    ImGui::Spacing();
    ImGui::Spacing();

    // === LIVE CLOCK DISPLAY SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Clock Status");
    ImGui::Spacing();

    // Animated beat indicator (4 boxes for 4/4 time)
    float phase = getLiveParamValue("phase_live", 0.0f);
    int currentBeat = (int)(phase * 4.0f) % 4;
    
    for (int i = 0; i < 4; ++i)
    {
        if (i > 0) ImGui::SameLine();
        
        bool isCurrentBeat = (currentBeat == i);
        ImVec4 color = isCurrentBeat ? ImVec4(1.0f, 0.3f, 0.3f, 1.0f) : ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
        
        ImGui::PushStyleColor(ImGuiCol_Button, color);
        ImGui::Button(juce::String(i + 1).toRawUTF8(), ImVec2(itemWidth * 0.23f, 30));
        ImGui::PopStyleColor();
    }

    // Current BPM display (large, colored)
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.0f, 0.7f, 1.0f));
    ImGui::Text("♩ = %.1f BPM", getLiveParamValue("bpm_live", bpm));
    ImGui::PopStyleColor();

    // Bar:Beat display
    int bar = (int)(phase / 4.0f) + 1;
    int beat = currentBeat + 1;
    ImGui::Text("Bar %d | Beat %d", bar, beat);

    ImGui::Spacing();
    ImGui::Spacing();

    // === TRANSPORT SYNC SECTION ===
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Transport Sync");
    ImGui::Spacing();

    // Sync to Host checkbox
    bool sync = syncToHost;
    if (ImGui::Checkbox("Sync to Host", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(paramIdSyncToHost))) *p = sync;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Follow host transport tempo\nDisables manual BPM control when enabled");
    
    if (sync)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 1.0f, 0.8f, 1.0f));
        ImGui::Text("⚡ SYNCED TO HOST TRANSPORT");
        ImGui::PopStyleColor();
    }
    
    ImGui::Spacing();
    
    // Division Override checkbox
    bool divOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
    if (ImGui::Checkbox("Division Override", &divOverride))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(paramIdDivisionOverride))) *p = divOverride;
        onModificationEnded();
    }
    ImGui::SameLine();
    HelpMarkerClock("Broadcast this clock's division globally\nForces all synced modules to follow this clock's subdivision");
    
    if (divOverride)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.2f, 1.0f));
        ImGui::Text("⚡ MASTER DIVISION SOURCE");
        ImGui::PopStyleColor();
    }

    ImGui::PopItemWidth();
}

void TempoClockModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("BPM Mod", 0);
    helpers.drawAudioInputPin("Tap", 1);
    helpers.drawAudioInputPin("Nudge+", 2);
    helpers.drawAudioInputPin("Nudge-", 3);
    helpers.drawAudioInputPin("Play", 4);
    helpers.drawAudioInputPin("Stop", 5);
    helpers.drawAudioInputPin("Reset", 6);
    helpers.drawAudioInputPin("Swing Mod", 7);

    helpers.drawAudioOutputPin("Clock", 0);
    helpers.drawAudioOutputPin("Beat Trig", 1);
    helpers.drawAudioOutputPin("Bar Trig", 2);
    helpers.drawAudioOutputPin("Beat Gate", 3);
    helpers.drawAudioOutputPin("Phase", 4);
    helpers.drawAudioOutputPin("BPM CV", 5);
    helpers.drawAudioOutputPin("Downbeat", 6);
}
#endif




================================================================================
FILE: guides\TEMPO_CLOCK_INTEGRATION_GUIDE.md
================================================================================


# Tempo Clock Module Integration Guide

## Overview

This guide explains how the **TempoClockModuleProcessor** integrates with the global transport system and provides patterns for implementing similar transport-aware behavior in other modules.

## Table of Contents

1. [Transport System Architecture](#transport-system-architecture)
2. [Reading Transport State](#reading-transport-state)
3. [Controlling Transport](#controlling-transport)
4. [Tempo Synchronization Modes](#tempo-synchronization-modes)
5. [Division Override System](#division-override-system)
6. [CV Input Edge Detection](#cv-input-edge-detection)
7. [Live Parameter Telemetry](#live-parameter-telemetry)
8. [UI Integration Patterns](#ui-integration-patterns)
9. [Implementation Checklist](#implementation-checklist)

---

## Transport System Architecture

### Key Concepts

The transport system provides:
- **Global BPM** - Shared tempo across all modules
- **Song Position** - Current playback position in beats
- **Play/Stop State** - Global transport control
- **Division Override** - One clock can control global subdivision
- **Tempo Control Flag** - Indicates if a module is controlling the global tempo

### Parent Processor Interface

All modules inherit from `ModuleProcessor` which provides access to the parent `ModularSynthProcessor`:

```cpp
auto* parent = getParent();  // Returns ModularSynthProcessor*
```

### Transport State Structure

The `m_currentTransport` member (inherited from `ModuleProcessor`) contains:

```cpp
struct {
    double bpm;                    // Current tempo
    double songPositionBeats;      // Current position in beats
    bool isPlaying;                // Transport running state
    // ... other fields
} m_currentTransport;
```

This structure is automatically updated **before** each `processBlock()` call via `updateTransportState()`.

---

## Reading Transport State

### Basic Pattern

```cpp
void YourModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    // m_currentTransport is already updated by base class
    double currentBPM = m_currentTransport.bpm;
    double songPosition = m_currentTransport.songPositionBeats;
    bool isPlaying = m_currentTransport.isPlaying;
    
    // Use transport state in your processing...
}
```

### Computing Phase from Transport

```cpp
// Use transport position for stable, drift-free timing
double phaseBeats = m_currentTransport.songPositionBeats;

for (int i = 0; i < numSamples; ++i)
{
    // Advance phase using current BPM
    phaseBeats += (1.0 / sampleRate) * (currentBPM / 60.0);
    
    // Compute subdivision phase
    double scaled = phaseBeats * division;
    double frac = scaled - std::floor(scaled);
    
    // Generate clock output from phase...
}
```

**Why this matters:** Using the transport position ensures all modules stay in sync, even when BPM changes or transport is reset.

---

## Controlling Transport

### Setting Global BPM

```cpp
if (auto* parent = getParent())
{
    parent->setBPM(newBPM);
}
```

### Play/Stop/Reset

```cpp
if (auto* parent = getParent())
{
    parent->setPlaying(true);   // Start transport
    parent->setPlaying(false);  // Stop transport
    parent->resetTransportPosition();  // Reset to beat 0
}
```

### Example: Responding to CV Triggers

```cpp
// Edge detection helper
auto edge = [&](const float* cv, bool& last) {
    bool now = (cv && cv[0] > 0.5f);
    bool rising = now && !last;
    last = now;
    return rising;
};

// Process transport control inputs
if (edge(playCV, lastPlayHigh))   if (auto* p = getParent()) p->setPlaying(true);
if (edge(stopCV, lastStopHigh))   if (auto* p = getParent()) p->setPlaying(false);
if (edge(resetCV, lastResetHigh)) if (auto* p = getParent()) p->resetTransportPosition();
```

---

## Tempo Synchronization Modes

The Tempo Clock module supports two modes:

### Mode 1: Controlling Transport (Default)

```cpp
// This module CONTROLS the global BPM
if (auto* parent = getParent())
{
    parent->setBPM(localBPM);
    parent->setTempoControlledByModule(true);  // Mark as controlling
}
```

**Effect:**
- Module pushes its BPM to global transport
- Other modules see this BPM in `m_currentTransport.bpm`
- Top bar BPM control is **greyed out** (controlled by module)

### Mode 2: Syncing to Transport

```cpp
// This module FOLLOWS the global BPM
if (auto* parent = getParent())
{
    localBPM = (float)m_currentTransport.bpm;  // Read from transport
    parent->setTempoControlledByModule(false);  // Not controlling
}
```

**Effect:**
- Module reads BPM from transport
- Top bar BPM control is **enabled** (user can adjust)
- Module responds to external tempo changes

### Implementing Switchable Modes

```cpp
bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;

if (auto* parent = getParent())
{
    if (syncToHost)
    {
        // Mode 2: FOLLOW transport
        bpm = (float)m_currentTransport.bpm;
        parent->setTempoControlledByModule(false);
    }
    else
    {
        // Mode 1: CONTROL transport
        parent->setBPM(bpm);
        parent->setTempoControlledByModule(true);
    }
}
```

---

## Division Override System

### Purpose

Allows one Tempo Clock to broadcast its subdivision (1/4, 1/16, etc.) globally, forcing all synced modules to use the same division.

### Implementation

#### Broadcasting Division (Master Clock)

```cpp
bool divisionOverride = divisionOverrideParam && divisionOverrideParam->load() > 0.5f;
int localDivisionIdx = divisionParam ? (int)divisionParam->load() : 3;  // 0=1/32, 3=1/4, etc.

if (auto* parent = getParent())
{
    if (divisionOverride)
    {
        // Broadcast this module's division globally
        parent->setGlobalDivisionIndex(localDivisionIdx);
    }
    else
    {
        // Not overriding - clear the broadcast
        parent->setGlobalDivisionIndex(-1);
    }
}
```

#### Reading Global Division (Follower Module)

```cpp
if (auto* parent = getParent())
{
    int globalDiv = parent->getGlobalDivisionIndex();
    
    if (globalDiv >= 0)
    {
        // Use global division (master clock is broadcasting)
        divisionIdx = globalDiv;
    }
    else
    {
        // Use local division parameter
        divisionIdx = (int)divisionParam->load();
    }
}
```

### Division Index to Value Mapping

```cpp
static const double divisions[] = {
    1.0/32.0,  // idx 0: 1/32 notes
    1.0/16.0,  // idx 1: 1/16 notes
    1.0/8.0,   // idx 2: 1/8 notes
    1.0/4.0,   // idx 3: 1/4 notes (quarter notes)
    1.0/2.0,   // idx 4: 1/2 notes (half notes)
    1.0,       // idx 5: whole notes
    2.0,       // idx 6: 2 bars
    4.0        // idx 7: 4 bars
};

double div = divisions[juce::jlimit(0, 7, divisionIdx)];
double scaled = phaseBeats * div;  // Scale transport position by division
```

---

## CV Input Edge Detection

### Pattern: Reading CV Inputs Only When Connected

```cpp
// Check connection state ONCE per buffer (fast)
const bool playMod = isParamInputConnected("play_mod");
const bool stopMod = isParamInputConnected("stop_mod");
const bool resetMod = isParamInputConnected("reset_mod");

// Get read pointers ONLY if connected
const float* playCV  = (playMod  && in.getNumChannels() > 4) ? in.getReadPointer(4) : nullptr;
const float* stopCV  = (stopMod  && in.getNumChannels() > 5) ? in.getReadPointer(5) : nullptr;
const float* resetCV = (resetMod && in.getNumChannels() > 6) ? in.getReadPointer(6) : nullptr;
```

**Benefits:**
- Zero overhead when inputs are disconnected
- Follows best practices from TTS/BestPractice modules

### Edge Detection Helper

```cpp
// Lambda for detecting rising edges (0->1 transitions)
auto edge = [&](const float* cv, bool& last) {
    bool now = (cv && cv[0] > 0.5f);  // High when CV > 0.5
    bool rising = now && !last;        // Rising edge
    last = now;                        // Store state for next frame
    return rising;
};

// Usage:
if (edge(playCV, lastPlayHigh))   { /* Trigger action */ }
if (edge(stopCV, lastStopHigh))   { /* Trigger action */ }
if (edge(resetCV, lastResetHigh)) { /* Trigger action */ }
```

### Member Variables for Edge Detection

```cpp
class YourModuleProcessor : public ModuleProcessor
{
private:
    // Edge detection state
    bool lastPlayHigh = false;
    bool lastStopHigh = false;
    bool lastResetHigh = false;
    bool lastTapHigh = false;
    // ... etc
};
```

---

## Live Parameter Telemetry

### Purpose

Publish real-time values to the UI so parameters can display actual processed values (e.g., after CV modulation).

### Publishing Values

```cpp
void YourModuleProcessor::processBlock(...)
{
    // Compute final values (after CV modulation)
    float finalBPM = bpmParam->load();
    if (bpmCV)
    {
        const float cv = juce::jlimit(0.0f, 1.0f, bpmCV[0]);
        finalBPM = juce::jmap(std::pow(cv, 0.3f), 0.0f, 1.0f, 20.0f, 300.0f);
    }
    
    // Publish live telemetry (used by UI)
    setLiveParamValue("bpm_live", finalBPM);
    setLiveParamValue("swing_live", finalSwing);
    setLiveParamValue("phase_live", currentPhase);
}
```

### Reading Values in UI

```cpp
void YourModuleProcessor::drawParametersInNode(...)
{
    // Check if parameter is modulated
    bool bpmMod = isParamModulated("bpm_mod");
    
    // Read live value if modulated, otherwise read parameter
    float displayBPM = bpmMod 
        ? getLiveParamValueFor("bpm_mod", "bpm_live", bpmParam->load())
        : bpmParam->load();
    
    // Display with modulation indicator
    if (bpmMod) ImGui::BeginDisabled();
    ImGui::SliderFloat("BPM", &displayBPM, 20.0f, 300.0f, "%.1f");
    if (bpmMod) {
        ImGui::EndDisabled();
        ImGui::SameLine();
        ImGui::TextUnformatted("(mod)");
    }
}
```

---

## UI Integration Patterns

### Pattern 1: Disabling Controls When Synced

```cpp
// Grey out BPM control when synced to host
bool syncToHost = syncToHostParam && syncToHostParam->load() > 0.5f;

if (syncToHost) ImGui::BeginDisabled();

if (ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f, "%.1f"))
{
    if (!syncToHost)  // Only allow changes when NOT synced
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("bpm")))
            *p = bpm;
    }
}

if (syncToHost) {
    ImGui::EndDisabled();
    ImGui::SameLine();
    ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.8f, 1.0f), "(synced)");
}
```

### Pattern 2: Status Indicators

```cpp
// Show sync status prominently
if (syncToHost)
{
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.2f, 1.0f, 0.8f, 1.0f));
    ImGui::Text("⚡ SYNCED TO HOST TRANSPORT");
    ImGui::PopStyleColor();
}

if (divisionOverride)
{
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 0.8f, 0.2f, 1.0f));
    ImGui::Text("⚡ MASTER DIVISION SOURCE");
    ImGui::PopStyleColor();
}
```

### Pattern 3: Live Clock Display

```cpp
// Animated beat indicator (4 boxes for 4/4 time)
float phase = getLiveParamValue("phase_live", 0.0f);
int currentBeat = (int)(phase * 4.0f) % 4;

for (int i = 0; i < 4; ++i)
{
    if (i > 0) ImGui::SameLine();
    
    bool isCurrentBeat = (currentBeat == i);
    ImVec4 color = isCurrentBeat 
        ? ImVec4(1.0f, 0.3f, 0.3f, 1.0f)  // Red when active
        : ImVec4(0.3f, 0.3f, 0.3f, 1.0f); // Grey when inactive
    
    ImGui::PushStyleColor(ImGuiCol_Button, color);
    ImGui::Button(juce::String(i + 1).toRawUTF8(), ImVec2(itemWidth * 0.23f, 30));
    ImGui::PopStyleColor();
}

// Current BPM display
ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.5f, 1.0f, 0.7f, 1.0f));
ImGui::Text("♩ = %.1f BPM", getLiveParamValue("bpm_live", bpm));
ImGui::PopStyleColor();
```

### Pattern 4: Help Tooltips

```cpp
auto HelpMarker = [](const char* desc) {
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip()) {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
};

// Usage:
ImGui::SliderFloat("BPM", &bpm, 20.0f, 300.0f);
ImGui::SameLine();
HelpMarker("Beats per minute (20-300 BPM)\nDisabled when synced to host");
```

---

## Implementation Checklist

### For Modules That Need Transport Awareness

- [ ] **Read transport state** from `m_currentTransport` (automatically updated)
- [ ] **Use transport position** for timing instead of local counters
- [ ] **Respect global BPM** unless your module is controlling it
- [ ] **Add sync parameter** if module can follow OR control transport
- [ ] **Call `setTempoControlledByModule()`** to indicate control state
- [ ] **Check global division** if your module uses subdivisions
- [ ] **Publish live telemetry** for UI display

### For Modules That Control Transport

- [ ] **Call `setBPM()`** when controlling global tempo
- [ ] **Call `setTempoControlledByModule(true)`** when active
- [ ] **Call `setTempoControlledByModule(false)`** when syncing
- [ ] **Handle play/stop/reset** from CV inputs
- [ ] **Disable BPM control** in UI when syncing to host
- [ ] **Show sync status** prominently in UI

### For Modules That Use Division Override

- [ ] **Check `getGlobalDivisionIndex()`** before using local division
- [ ] **Use global division** when >= 0, local division when -1
- [ ] **Optionally broadcast** division using `setGlobalDivisionIndex()`
- [ ] **Add divisionOverride parameter** if module can be master
- [ ] **Show override status** in UI

### Parameter Routing

- [ ] **Map CV inputs** to virtual parameter IDs
- [ ] **Implement `getParamRouting()`** for input routing
- [ ] **Check connections** before reading CV buffers
- [ ] **Use edge detection** for trigger inputs
- [ ] **Store edge state** in member variables

### UI Best Practices

- [ ] **Disable controls** when externally controlled
- [ ] **Show modulation indicators** "(mod)" next to live values
- [ ] **Show sync status** with colored text/icons
- [ ] **Display live values** using telemetry
- [ ] **Add help tooltips** for complex parameters
- [ ] **Group related controls** with section headers
- [ ] **Use consistent colors** (green=synced, yellow=master, red=active)

---

## Common Patterns Summary

### Reading BPM

```cpp
// Simple: Just read current BPM
double bpm = m_currentTransport.bpm;
```

### Controlling BPM

```cpp
// Set global BPM and mark as controlling
if (auto* p = getParent()) {
    p->setBPM(myBPM);
    p->setTempoControlledByModule(true);
}
```

### Reading Division

```cpp
// Check for global division override
int div = 3;  // Default to 1/4
if (auto* p = getParent()) {
    int globalDiv = p->getGlobalDivisionIndex();
    if (globalDiv >= 0) div = globalDiv;
    else div = (int)divisionParam->load();
}
```

### Syncing to Transport

```cpp
// Use transport position for stable timing
double phase = m_currentTransport.songPositionBeats;
for (int i = 0; i < numSamples; ++i) {
    phase += (1.0 / sampleRate) * (bpm / 60.0);
    // ... use phase for clock generation
}
```

---

## Example: Minimal Transport-Aware Module

```cpp
class MyTransportModule : public ModuleProcessor
{
public:
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi) override
    {
        // 1. Read transport state (already updated by base class)
        double bpm = m_currentTransport.bpm;
        double songPos = m_currentTransport.songPositionBeats;
        bool playing = m_currentTransport.isPlaying;
        
        // 2. Check for global division override
        int divIdx = 3;  // Default 1/4
        if (auto* p = getParent()) {
            int globalDiv = p->getGlobalDivisionIndex();
            if (globalDiv >= 0) divIdx = globalDiv;
        }
        
        // 3. Use transport position for timing
        double phase = songPos;
        for (int i = 0; i < buffer.getNumSamples(); ++i) {
            phase += (1.0 / sampleRate) * (bpm / 60.0);
            // ... process using phase
        }
        
        // 4. Publish telemetry for UI
        setLiveParamValue("phase_live", (float)phase);
    }
};
```

---

## Questions to Ask When Implementing

1. **Does my module need to know the current BPM?**
   - YES: Read `m_currentTransport.bpm`
   - Add sync parameter if module should control OR follow

2. **Does my module need timing/phase information?**
   - YES: Use `m_currentTransport.songPositionBeats`
   - Advance phase using BPM/sampleRate formula

3. **Should my module respect global division?**
   - YES: Check `getGlobalDivisionIndex()` before using local division
   - Fallback to local division when global is -1

4. **Does my module generate tempo?**
   - YES: Call `setBPM()` and `setTempoControlledByModule(true)`
   - Disable in UI when syncing to host

5. **Does my module respond to transport controls?**
   - YES: Handle play/stop/reset from CV inputs
   - Use edge detection pattern

6. **Do I need to show live values in UI?**
   - YES: Publish telemetry with `setLiveParamValue()`
   - Read with `getLiveParamValue()` in UI code

---

## Related Files

- `TempoClockModuleProcessor.cpp` - Reference implementation
- `ModularSynthProcessor.h` - Parent processor interface
- `ModuleProcessor.h` - Base class with transport support
- `StepSequencerModuleProcessor.cpp` - Example of division override usage

---

## Conclusion

The transport system provides a unified way for modules to:
- Share timing information
- Control or follow global tempo
- Synchronize subdivisions
- Respond to transport controls

By following these patterns, your modules will integrate seamlessly with the rest of the synthesis environment and provide a consistent user experience.

For most modules, you only need to:
1. Read `m_currentTransport` for timing
2. Check global division if using subdivisions
3. Show live values in UI with telemetry

Advanced modules can control the transport or broadcast divisions, but this is optional.



================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <functional> // Required for std::function
#include <vector>
#include <map>
#include <unordered_map>
#include <atomic>

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#include <cmath>
#endif

// <<< TRANSPORT STATE FOR GLOBAL CLOCK >>>
// Transport state struct shared by all modules
struct TransportState {
    bool isPlaying = false;
    double bpm = 120.0;
    double songPositionBeats = 0.0;
    double songPositionSeconds = 0.0;
    // Optional global division broadcast from a master tempo/clock (-1 means inactive)
    std::atomic<int> globalDivisionIndex { -1 };
    // Flag to indicate if a Tempo Clock module is controlling the BPM (for UI feedback)
    std::atomic<bool> isTempoControlledByModule { false };
    
    // Custom copy constructor (atomics are not copyable by default)
    TransportState() = default;
    TransportState(const TransportState& other)
        : isPlaying(other.isPlaying)
        , bpm(other.bpm)
        , songPositionBeats(other.songPositionBeats)
        , songPositionSeconds(other.songPositionSeconds)
        , globalDivisionIndex(other.globalDivisionIndex.load())
        , isTempoControlledByModule(other.isTempoControlledByModule.load())
    {}
    
    // Custom copy assignment operator
    TransportState& operator=(const TransportState& other)
    {
        if (this != &other)
        {
            isPlaying = other.isPlaying;
            bpm = other.bpm;
            songPositionBeats = other.songPositionBeats;
            songPositionSeconds = other.songPositionSeconds;
            globalDivisionIndex.store(other.globalDivisionIndex.load());
            isTempoControlledByModule.store(other.isTempoControlledByModule.load());
        }
        return *this;
    }
};

// === RHYTHM REPORTING SYSTEM ===
// Allows modules to report their rhythmic timing for the BPM Monitor node

/**
 * Rhythm information reported by modules that produce rhythmic patterns
 */
struct RhythmInfo
{
    juce::String displayName;    // e.g., "Sequencer #3", "Animation: Walk Cycle"
    float bpm;                    // Current BPM (can be modulated live value)
    bool isActive;                // Is this source currently producing rhythm?
    bool isSynced;                // Is it synced to global transport?
    juce::String sourceType;      // "sequencer", "animation", "physics", etc.
    
    RhythmInfo() : bpm(0.0f), isActive(false), isSynced(false) {}
    RhythmInfo(const juce::String& name, float bpmValue, bool active, bool synced, const juce::String& type = "")
        : displayName(name), bpm(bpmValue), isActive(active), isSynced(synced), sourceType(type) {}
};

/**
 * Beat detection source (from audio input analysis)
 * Used by the BPM Monitor's tap tempo engine
 */
struct DetectedRhythmSource
{
    juce::String name;            // e.g., "Input 1 (Detected)"
    int inputChannel;             // Which input is being analyzed
    float detectedBPM;            // Calculated BPM from beat detection
    float confidence;             // 0.0-1.0 (how stable is the detection)
    bool isActive;                // Currently detecting beats?
    
    DetectedRhythmSource() : inputChannel(-1), detectedBPM(0.0f), confidence(0.0f), isActive(false) {}
};

// <<< MULTI-MIDI DEVICE SUPPORT >>>
// MIDI message with device source information
// This struct allows modules to filter MIDI by device and channel
struct MidiMessageWithDevice {
    juce::MidiMessage message;
    juce::String deviceIdentifier;
    juce::String deviceName;
    int deviceIndex = -1;
};

// <<< ALL PIN-RELATED DEFINITIONS ARE NOW CENTRALIZED HERE >>>

// Defines the data type of a modulation or audio signal
enum class PinDataType { CV, Audio, Gate, Raw };

// Forward declare NodeWidth enum (defined in ImGuiNodeEditorComponent.h)
// This avoids circular dependency while allowing ModulePinInfo to store it
enum class NodeWidth;

// Describes a single audio/CV input or output pin
struct AudioPin
{
    juce::String name;
    int channel;
    PinDataType type;
    
    AudioPin(const juce::String& n, int ch, PinDataType t) : name(n), channel(ch), type(t) {}
};

// Renamed to avoid conflict with ImGuiNodeEditorComponent's PinInfo
struct DynamicPinInfo {
    juce::String name;
    int channel;
    PinDataType type;

    // Constructor to allow brace-initialization
    DynamicPinInfo(const juce::String& n, int c, PinDataType t) : name(n), channel(c), type(t) {}
};

// Describes a single modulation input pin targeting a parameter
struct ModPin
{
    juce::String name;
    juce::String paramId;
    PinDataType type;
    
    ModPin(const juce::String& n, const juce::String& p, PinDataType t) : name(n), paramId(p), type(t) {}
};

// A collection of all pins for a given module type
struct ModulePinInfo
{
    NodeWidth defaultWidth;  // Standardized node width category
    std::vector<AudioPin> audioIns;
    std::vector<AudioPin> audioOuts;
    std::vector<ModPin> modIns;
    
    ModulePinInfo() : defaultWidth(static_cast<NodeWidth>(0)) {}  // Default to Small (0)
    
    ModulePinInfo(NodeWidth width,
                  std::initializer_list<AudioPin> ins,
                  std::initializer_list<AudioPin> outs,
                  std::initializer_list<ModPin> mods)
        : defaultWidth(width), audioIns(ins), audioOuts(outs), modIns(mods) {}
};

// Forward declaration for NodePinHelpers
class ModuleProcessor;

// Helper struct passed to modules for drawing their pins
struct NodePinHelpers
{
    std::function<void(const char* label, int channel)> drawAudioInputPin;
    std::function<void(const char* label, int channel)> drawAudioOutputPin;
    std::function<void(const char* inLabel, int inChannel, const char* outLabel, int outChannel)> drawParallelPins;
    std::function<void(ModuleProcessor* module)> drawIoPins;
};

class ModularSynthProcessor; // forward declaration

/**
    An abstract base class for all modular synthesizer components.

    This class enforces a common interface for modules, ensuring they can be
    managed by the ModularSynthProcessor. The key requirement is providing access
    to the module's own parameter state via getAPVTS().
*/
class ModuleProcessor : public juce::AudioProcessor
{
public:
    ModuleProcessor(const BusesProperties& ioLayouts) : juce::AudioProcessor(ioLayouts) {}
    ~ModuleProcessor() override = default;

    // Parent container link (set by ModularSynthProcessor when node is created)
    void setParent(ModularSynthProcessor* parent) { parentSynth = parent; }
    ModularSynthProcessor* getParent() const { return parentSynth; }

    // Pure virtual method that all concrete modules MUST implement.
    // This is crucial for the parameter proxy system.
    virtual juce::AudioProcessorValueTreeState& getAPVTS() = 0;

    // Optional UI hook for drawing parameters inside nodes (used by Preset Creator)
    virtual void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
    {
        juce::ignoreUnused(itemWidth, isParamModulated, onModificationEnded);
    }

    // Optional UI hook for drawing IO pins inside nodes
    virtual void drawIoPins(const NodePinHelpers& /*helpers*/) {}

#if defined(PRESET_CREATOR_UI)
    // Optional UI hook for modules that need custom node dimensions (Exception size category)
    // Return ImVec2(width, height) for custom size, or ImVec2(0, 0) to use default from PinDatabase
    // Height of 0 means auto-size to content (recommended for most cases)
    virtual ImVec2 getCustomNodeSize() const 
    { 
        return ImVec2(0.0f, 0.0f); // Default: use PinDatabase size
    }
#endif


    // Get the current output value for a channel (for visualization)
    virtual float getOutputChannelValue(int channel) const
    {
        if (juce::isPositiveAndBelow(channel, (int)lastOutputValues.size()) && lastOutputValues[channel])
            return lastOutputValues[channel]->load();
        return 0.0f;
    }
    
    // Helper method to update output telemetry with peak magnitude
    // Call this at the end of processBlock to update visualization values
    void updateOutputTelemetry(const juce::AudioBuffer<float>& buffer)
    {
        const int numChannels = juce::jmin(buffer.getNumChannels(), (int)lastOutputValues.size());
        for (int ch = 0; ch < numChannels; ++ch)
        {
            if (lastOutputValues[ch])
            {
                // Use peak magnitude (max absolute value) for better visualization
                const float peak = buffer.getMagnitude(ch, 0, buffer.getNumSamples());
                lastOutputValues[ch]->store(peak, std::memory_order_relaxed);
            }
        }
    }

    // Standardized labels for module audio I/O channels (override per module if needed)
    virtual juce::String getAudioInputLabel(int channel) const
    {
        return juce::String("In ") + juce::String(channel + 1);
    }

    virtual juce::String getAudioOutputLabel(int channel) const
    {
        return juce::String("Out ") + juce::String(channel + 1);
    }

    // Stable logical ID assigned by ModularSynthProcessor upon node creation.
    void setLogicalId(juce::uint32 id) { storedLogicalId = id; }
    juce::uint32 getLogicalId() const { return storedLogicalId; }

    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get detailed connection information for debugging
    virtual juce::String getConnectionDiagnostics() const
    {
        juce::String result = "=== CONNECTION DIAGNOSTICS ===\n";
        
        // Bus layout info
        result += "Input Buses: " + juce::String(getBusCount(true)) + "\n";
        result += "Output Buses: " + juce::String(getBusCount(false)) + "\n";
        
        for (int bus = 0; bus < getBusCount(true); ++bus)
        {
            auto busName = getBus(true, bus)->getName();
            auto numChannels = getBus(true, bus)->getNumberOfChannels();
            result += "  Input Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        for (int bus = 0; bus < getBusCount(false); ++bus)
        {
            auto busName = getBus(false, bus)->getName();
            auto numChannels = getBus(false, bus)->getNumberOfChannels();
            result += "  Output Bus " + juce::String(bus) + ": \"" + busName + "\" (" + juce::String(numChannels) + " channels)\n";
        }
        
        return result;
    }
    
    // Get parameter routing diagnostics
    virtual juce::String getParameterRoutingDiagnostics() const
    {
        juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
        
        // Note: This method is const, so we can't access getAPVTS() directly
        // We'll return a placeholder for now
        result += "Parameter routing diagnostics require non-const access.\n";
        result += "Use getModuleDiagnostics() from ModularSynthProcessor instead.\n";
        
        return result;
    }
    
    // Get live parameter values for debugging
    virtual juce::String getLiveParameterDiagnostics() const
    {
        juce::String result = "=== LIVE PARAMETER VALUES ===\n";
        
        for (const auto& pair : paramLiveValues)
        {
            result += "  " + pair.first + ": " + juce::String(pair.second.load(), 4) + "\n";
        }
        
        return result;
    }
    
    // Get comprehensive module diagnostics
    virtual juce::String getAllDiagnostics() const
    {
        juce::String result = "=== MODULE DIAGNOSTICS ===\n";
        result += "Module Type: " + getName() + "\n\n";
        result += getConnectionDiagnostics() + "\n";
        result += getParameterRoutingDiagnostics() + "\n";
        result += getLiveParameterDiagnostics();
        return result;
    }


    /**
        Resolves a parameter's string ID to its modulation bus and channel.

        This is a virtual function that each module must override to declare which of its
        parameters can be modulated by an external signal. The function maps parameter IDs
        to their corresponding input bus and channel indices within that bus.

        @param paramId              The string ID of the parameter to query (e.g., "cutoff", "frequency").
        @param outBusIndex          Receives the index of the input bus used for modulation.
        @param outChannelIndexInBus Receives the channel index within that bus.
        @returns                    True if the parameter supports modulation, false otherwise.
        
        @see isParamInputConnected
    */
    virtual bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const;

    /**
        Checks if a parameter's modulation input is connected in the synth graph.

        This is the single, reliable method for a module's audio thread to determine
        if it should use an incoming CV signal instead of its internal parameter value.
        The function internally uses getParamRouting() to resolve the parameter to its
        bus/channel location, then queries the parent synth's connection graph.

        @param paramId The string ID of the parameter to check (e.g., "cutoff", "frequency").
        @returns       True if a cable is connected to this parameter's modulation input.
        
        @see getParamRouting
    */
    bool isParamInputConnected(const juce::String& paramId) const;

    // --- Live telemetry for UI (thread-safe, lock-free) ---
    void setLiveParamValue(const juce::String& paramId, float value)
    {
        auto result = paramLiveValues.try_emplace(paramId, value);
        if (!result.second)
            result.first->second.store(value, std::memory_order_relaxed);
    }

    float getLiveParamValue(const juce::String& paramId, float fallback) const
    {
        // FIX: Only return the "live" (modulated) value if the corresponding
        // modulation input is actually connected. Otherwise, always return the
        // fallback, which is the base parameter's real value.
        if (isParamInputConnected(paramId))
        {
            if (auto it = paramLiveValues.find(paramId); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // New helper: decouple the connectivity check (modParamId) from the live value key (liveKey).
    // This allows UI code to ask "is X_mod connected?" while reading the corresponding
    // live telemetry stored under a different key like "X_live".
    float getLiveParamValueFor(const juce::String& modParamId,
                               const juce::String& liveKey,
                               float fallback) const
    {
        if (isParamInputConnected(modParamId))
        {
            if (auto it = paramLiveValues.find(liveKey); it != paramLiveValues.end())
                return it->second.load(std::memory_order_relaxed);
        }
        return fallback;
    }

    // Optional extra state hooks for modules that need to persist non-parameter data
    // Default: return invalid tree / ignore.
    virtual juce::ValueTree getExtraStateTree() const { return {}; }
    virtual void setExtraStateTree(const juce::ValueTree&) {}
    
    // Optional timing info hook for modules that need global clock/transport
    // Default: ignore (modules that don't need timing can skip implementing this)
    virtual void setTimingInfo(const TransportState& state) { juce::ignoreUnused(state); }
    
    // Optional rhythm reporting hook for BPM Monitor node
    // Modules that produce rhythmic patterns can implement this to report their BPM
    // Default: return empty (module doesn't produce rhythm)
    virtual std::optional<RhythmInfo> getRhythmInfo() const { return std::nullopt; }
    
    // Optional dynamic pin interface for modules with variable I/O (e.g., polyphonic modules)
    // Default: return empty vector (no dynamic pins)
    virtual std::vector<DynamicPinInfo> getDynamicInputPins() const { return {}; }
    virtual std::vector<DynamicPinInfo> getDynamicOutputPins() const { return {}; }
    
    /**
        Device-aware MIDI processing (MULTI-MIDI CONTROLLER SUPPORT)
        
        This method is called by ModularSynthProcessor BEFORE the standard graph processing
        begins. It provides MIDI modules with device-aware MIDI messages that include the
        source device information (name, identifier, index).
        
        MIDI modules should override this method to:
        - Filter messages by device (e.g., only respond to a specific controller)
        - Filter messages by MIDI channel
        - Update internal state based on filtered MIDI input
        
        The regular processBlock() can then use this updated state to generate CV outputs.
        
        @param midiMessages A vector of MIDI messages with device source information
        
        Default implementation: Does nothing (opt-in for MIDI modules only)
        
        @see MidiMessageWithDevice
    */
    virtual void handleDeviceSpecificMidi(const std::vector<MidiMessageWithDevice>& midiMessages)
    {
        juce::ignoreUnused(midiMessages);
        // Default: do nothing. MIDI-aware modules will override this method.
    }

public:
    // OPTION 9: Make public for TTS debugging
    // Live, modulated parameter values for UI feedback
    std::unordered_map<juce::String, std::atomic<float>> paramLiveValues;

protected:
    // Thread-safe storage for last known output values (for tooltips)
    std::vector<std::unique_ptr<std::atomic<float>>> lastOutputValues;

#if defined(PRESET_CREATOR_UI)

    static void adjustParamOnWheel (juce::RangedAudioParameter* parameter,
                                    const juce::String& idOrName,
                                    float displayedValue)
    {
        if (parameter == nullptr) return;
        if (! ImGui::IsItemHovered()) return;
        const float wheel = ImGui::GetIO().MouseWheel;
        if (wheel == 0.0f) return;

        if (auto* pf = dynamic_cast<juce::AudioParameterFloat*>(parameter))
        {
            // No right-click editing here; modules can add InputFloat next to sliders

            const auto& range = pf->range;
            const float span = range.end - range.start;
            const juce::String id = idOrName.toLowerCase();

            float step = span / 200.0f; // default ~0.5% of range
            if (span <= 1.0f) step = 0.01f;
            // Custom: fine tune for sequencer steps
            if (id.contains ("step"))
            {
                step = 0.05f;
            }
            if (id.contains ("hz") || id.contains ("freq") || id.contains ("cutoff") || id.contains ("rate"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (1.0f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("ms") || id.contains ("time"))
            {
                const float v = std::max (1.0f, std::abs (displayedValue));
                step = std::max (0.1f, std::pow (10.0f, std::floor (std::log10 (v)) - 1.0f));
            }
            else if (id.contains ("db") || id.contains ("gain"))
            {
                step = 0.5f;
            }
            else if (id.contains ("mix") || id.contains ("depth") || id.contains ("amount") || id.contains ("resonance") || id.contains ("q") || id.contains ("size") || id.contains ("damp") || id.contains ("pan") || id.contains ("threshold"))
            {
                step = 0.01f;
            }

            float newVal = pf->get() + (wheel > 0 ? step : -step);
            newVal = juce::jlimit (range.start, range.end, newVal);
            *pf = newVal;
        }
        else if (auto* pc = dynamic_cast<juce::AudioParameterChoice*>(parameter))
        {
            int idx = pc->getIndex();
            idx += (ImGui::GetIO().MouseWheel > 0 ? 1 : -1);
            idx = juce::jlimit (0, pc->choices.size() - 1, idx);
            *pc = idx;
        }
        else if (auto* pi = dynamic_cast<juce::AudioParameterInt*>(parameter))
        {
            int currentVal = pi->get();
            int newVal = currentVal + (wheel > 0 ? 1 : -1);
            const auto& range = pi->getNormalisableRange();
            newVal = juce::jlimit((int)range.start, (int)range.end, newVal);
            *pi = newVal;
        }
        else if (auto* pb = dynamic_cast<juce::AudioParameterBool*>(parameter))
        {
            // Optional: toggle on strong scroll
            juce::ignoreUnused (pb);
        }
    }

#endif

public:
    //==============================================================================
    // Helper function to convert bus index and channel-in-bus to absolute channel index
    //==============================================================================
    int getChannelIndexInProcessBlockBuffer(bool isInput, int busIndex, int channelIndexInBus) const
    {
        int absoluteChannel = channelIndexInBus;
        if (busIndex > 0)
        {
            int sum = 0;
            const int numBuses = getBusCount(isInput);
            for (int b = 0; b < numBuses && b < busIndex; ++b)
                sum += getChannelCountOfBus(isInput, b);
            absoluteChannel = sum + channelIndexInBus;
        }
        return absoluteChannel;
    }

    //==============================================================================
    // Provide default implementations for the pure virtuals to reduce boilerplate
    // in concrete module classes.
    //==============================================================================
    const juce::String getName() const override { return "Module"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override {}
    void setStateInformation (const void*, int) override {}

private:
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModuleProcessor)

protected:
    ModularSynthProcessor* parentSynth { nullptr };
    juce::uint32 storedLogicalId { 0 };
};

================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.h
================================================================================


#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <atomic>
#include <vector>
#include <memory>
#include "../modules/ModuleProcessor.h"
#include "../modules/InputDebugModuleProcessor.h"

class ModularSynthProcessor : public juce::AudioProcessor
{
public:
    ModularSynthProcessor();
    ~ModularSynthProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    const juce::String getName() const override { return "Modular Synth"; }
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return true; }
    double getTailLengthSeconds() const override { return 0.0; }
    juce::AudioProcessorEditor* createEditor() override { return nullptr; }
    bool hasEditor() const override { return false; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram (int) override {}
    const juce::String getProgramName (int) override { return {}; }
    void changeProgramName (int, const juce::String&) override {}
    void getStateInformation (juce::MemoryBlock&) override;
    void setStateInformation (const void*, int) override;

    // Public API (initial)
public:
    using Node = juce::AudioProcessorGraph::Node;
    using NodeID = juce::AudioProcessorGraph::NodeID;
    

    NodeID addModule(const juce::String& moduleType, bool commit = true);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc);
    NodeID addVstModule(juce::AudioPluginFormatManager& formatManager, const juce::PluginDescription& vstDesc, juce::uint32 logicalIdToAssign);
    void removeModule(const NodeID& nodeID);
    void clearAll(); // Add this line
    void clearAllConnections(); // Add this line
    void clearOutputConnections(); // <<< ADD THIS LINE
    void clearConnectionsForNode(const NodeID& nodeID); // <<< ADD THIS LINE
    bool connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    
    // Set the hardware input channel mapping for an Audio Input module
    void setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap);
    
    void commitChanges();
    NodeID getOutputNodeID() const { return audioOutputNode ? audioOutputNode->nodeID : NodeID{}; }
    NodeID getBPMMonitorNodeID() const { return bpmMonitorNode ? bpmMonitorNode->nodeID : NodeID{}; }
    // Introspection for editor
    std::vector<std::pair<juce::uint32, juce::String>> getModulesInfo() const;
    juce::AudioProcessorGraph::NodeID getNodeIdForLogical (juce::uint32 logicalId) const;
    juce::uint32 getLogicalIdForNode (const NodeID& nodeId) const;
    juce::String getModuleTypeForLogical(juce::uint32 logicalId) const;
    bool disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel);
    struct ConnectionInfo
    {
        juce::uint32 srcLogicalId { 0 };
        int srcChan { 0 };
        juce::uint32 dstLogicalId { 0 }; // 0 means audio output
        int dstChan { 0 };
        bool dstIsOutput { false };
    };
    std::vector<ConnectionInfo> getConnectionsInfo() const;
    // Access a module processor for UI parameter editing
    ModuleProcessor* getModuleForLogical (juce::uint32 logicalId) const;
    
    // === GLOBAL TRANSPORT & TIMING ===
    // (TransportState struct is defined in ModuleProcessor.h)
    
    TransportState getTransportState() const { return m_transportState; }
    void setPlaying(bool playing) {
        m_transportState.isPlaying = playing;
        // Immediately broadcast timing change to modules even if audio callback is stopped
        if (auto processors = activeAudioProcessors.load())
        {
            for (const auto& modulePtr : *processors)
                if (modulePtr)
                    modulePtr->setTimingInfo(m_transportState);
        }
    }
    void setBPM(double bpm) { m_transportState.bpm = juce::jlimit(20.0, 999.0, bpm); }
    void setGlobalDivisionIndex(int idx) { m_transportState.globalDivisionIndex.store(idx); }
    void setTempoControlledByModule(bool controlled) { m_transportState.isTempoControlledByModule.store(controlled); }
    
    // MIDI activity indicator
    bool hasMidiActivity() const { return m_midiActivityFlag.exchange(false); }
    void resetTransportPosition() { m_samplePosition = 0; m_transportState.songPositionBeats = 0.0; m_transportState.songPositionSeconds = 0.0; }
    
    // === MULTI-MIDI DEVICE SUPPORT ===
    
    /**
     * @brief Process device-aware MIDI messages
     * 
     * This method receives MIDI messages with device source information and
     * distributes them to all modules via handleDeviceSpecificMidi().
     * Should be called from the message thread (timer callback in PresetCreatorComponent).
     * 
     * @param messages Vector of MIDI messages with device information
     */
    void processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages);
    
    /**
     * @brief MIDI activity state per device and channel
     */
    struct MidiActivityState {
        std::map<int, std::array<bool, 16>> deviceChannelActivity;  // deviceIndex -> channels[16]
        std::map<int, juce::String> deviceNames;                    // deviceIndex -> name
    };
    
    /**
     * @brief Get snapshot of current MIDI activity
     * 
     * Used by UI for visualization (top bar indicator).
     * Thread-safe.
     * 
     * @return MidiActivityState structure
     */
    MidiActivityState getMidiActivityState() const;
    
    // === VOICE MANAGEMENT FOR POLYPHONY ===
    struct Voice {
        bool isActive = false;
        int noteNumber = -1;
        float velocity = 0.0f;
        juce::uint32 age = 0;  // Used for note stealing (oldest voice)
        juce::uint32 targetModuleLogicalId = 0;  // Which PolyVCO this voice is assigned to
    };
    
    void setVoiceManagerEnabled(bool enabled) { m_voiceManagerEnabled = enabled; }
    bool isVoiceManagerEnabled() const { return m_voiceManagerEnabled; }
    void setMaxVoices(int numVoices) { m_voices.resize(numVoices); }
    int getMaxVoices() const { return static_cast<int>(m_voices.size()); }
    const std::vector<Voice>& getVoices() const { return m_voices; }
    
    // === COMPREHENSIVE DIAGNOSTICS SYSTEM ===
    
    // Get system-wide diagnostics
    juce::String getSystemDiagnostics() const;
    
    // Get diagnostics for a specific module
    juce::String getModuleDiagnostics(juce::uint32 logicalId) const;
    
    // Get parameter routing diagnostics for a specific module
    juce::String getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const;
    
    // Get all connection diagnostics
    juce::String getConnectionDiagnostics() const;
    
    // Check if any recorder module is currently recording (prevents spacebar from stopping audio)
    bool isAnyModuleRecording() const;
    
    // Pause/Resume all active recorders (used by spacebar during audition)
    void pauseAllRecorders();
    void resumeAllRecorders();
    
    // Global start/stop all recorders (used by menu bar)
    void startAllRecorders();
    void stopAllRecorders();
    
    // Plugin format manager for VST support (optional, set by application)
    void setPluginFormatManager(juce::AudioPluginFormatManager* manager) { pluginFormatManager = manager; }
    void setKnownPluginList(juce::KnownPluginList* list) { knownPluginList = list; }
    
    // === PROBE TOOL API ===
    // Probe system for instant signal debugging without manual patching
    void setProbeConnection(const NodeID& sourceNodeID, int sourceChannel);
    void clearProbeConnection();
    ModuleProcessor* getProbeScopeProcessor() const;

private:
    // The internal graph that represents the modular patch
    std::unique_ptr<juce::AudioProcessorGraph> internalGraph;

    // Special nodes for handling I/O within the internal graph
    Node::Ptr audioInputNode;
    Node::Ptr audioOutputNode;
    Node::Ptr midiInputNode;
    
    
    // MIDI activity indicator (mutable because hasMidiActivity() is const)
    mutable std::atomic<bool> m_midiActivityFlag{false};
    
    // Multi-MIDI device support
    std::vector<MidiMessageWithDevice> currentBlockMidiMessages;
    mutable juce::CriticalSection midiActivityLock;
    MidiActivityState currentActivity;

    // The APVTS that will expose proxy parameters to the host/AudioEngine
    juce::AudioProcessorValueTreeState apvts;

    // Thread-safe module access for audio thread
    mutable juce::CriticalSection moduleLock;
    std::atomic<std::shared_ptr<const std::vector<std::shared_ptr<ModuleProcessor>>>> activeAudioProcessors;

    // Manage module nodes (legacy map by NodeID.uid)
    std::map<juce::uint32, Node::Ptr> modules; // keyed by NodeID.uid
    // Logical ID mapping for preset save/load
    struct LogicalModule
    {
        juce::AudioProcessorGraph::NodeID nodeID;
        juce::String type;
    };
    std::map<juce::uint32, LogicalModule> logicalIdToModule; // logicalId -> module
    juce::uint32 nextLogicalId { 1 };
    
    // Optional pointers for VST support
    juce::AudioPluginFormatManager* pluginFormatManager { nullptr };
    juce::KnownPluginList* knownPluginList { nullptr };
    
    // Probe scope for instant signal debugging (hidden from user, not saved in presets)
    Node::Ptr probeScopeNode;
    NodeID probeScopeNodeId;
    
    // BPM Monitor node (always present, undeletable like output node)
    Node::Ptr bpmMonitorNode;
    
    // Transport state
    TransportState m_transportState;
    juce::uint64 m_samplePosition { 0 };
    
    // Voice management state
    std::vector<Voice> m_voices;
    bool m_voiceManagerEnabled { false };
    juce::uint32 m_globalVoiceAge { 0 };  // Incremented for each note-on
    
    // Voice management helper methods
    int findFreeVoice();
    int findOldestVoice();
    void assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn);
    void releaseVoice(const juce::MidiMessage& noteOff);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModularSynthProcessor)
};

================================================================================
FILE: juce\Source\audio\modules\ModuleProcessor.cpp
================================================================================


#include "ModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <unordered_set>


bool ModuleProcessor::getParamRouting(const juce::String& /*paramId*/, int& /*outBusIndex*/, int& /*outChannelIndexInBus*/) const
{
    return false;
}

bool ModuleProcessor::isParamInputConnected(const juce::String& paramId) const
{
    auto* synth = parentSynth;
    if (synth == nullptr)
        return false;

    juce::uint32 myLogicalId = storedLogicalId;
    if (myLogicalId == 0)
    {
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical (info.first) == this)
            {
                myLogicalId = info.first;
                break;
            }
        }
        if (myLogicalId == 0)
            return false;
    }

    int busIndex = -1;
    int chanInBus = -1;
    if (!getParamRouting(paramId, busIndex, chanInBus))
        return false;

    int absoluteChannel = chanInBus;
    if (busIndex > 0)
    {
        int sum = 0;
        const int numInputBuses = getBusCount(true);
        for (int b = 0; b < numInputBuses && b < busIndex; ++b)
            sum += getChannelCountOfBus(true, b);
        absoluteChannel = sum + chanInBus;
    }

    for (const auto& c : synth->getConnectionsInfo())
        if (c.dstLogicalId == myLogicalId && c.dstChan == absoluteChannel)
            return true;

    // Fallback: if stored logicalId yields no match, re-resolve by pointer and retry once.
    {
        juce::uint32 ptrResolvedId = 0;
        for (const auto& info : synth->getModulesInfo())
        {
            if (synth->getModuleForLogical(info.first) == this)
            {
                ptrResolvedId = info.first;
                break;
            }
        }
        if (ptrResolvedId != 0 && ptrResolvedId != myLogicalId)
        {
            for (const auto& c : synth->getConnectionsInfo())
            {
                if (c.dstLogicalId == ptrResolvedId && c.dstChan == absoluteChannel)
                {
                    const_cast<ModuleProcessor*>(this)->setLogicalId(ptrResolvedId);
                    return true;
                }
            }
        }
    }

    return false;
}


================================================================================
FILE: juce\Source\audio\modules\BestPracticeNodeProcessor.h
================================================================================


#pragma once

/**
 * @file BestPracticeNodeProcessor.h
 * @brief Reference implementation demonstrating proper module naming conventions
 *
 * ## IMPORTANT: Module Naming Convention Standard
 *
 * This file serves as the definitive reference for the correct module naming convention
 * used throughout the Collider modular synthesizer system.
 *
 * ### The Problem We Solved
 * Previously, the system had inconsistent naming conventions:
 * - Module factory registered modules with lowercase names (e.g., "polyvco", "compressor")
 * - Module getName() methods returned PascalCase names (e.g., "PolyVCO", "Compressor")
 * - Module pin database used a mix of lowercase and PascalCase keys
 *
 * This caused pin color-coding failures because the UI couldn't find modules in the database.
 *
 * ### The Solution: Unified Lowercase Convention
 * We standardized on a **lowercase with spaces** naming convention:
 *
 * 1. **Module Factory Registration**: All modules registered as lowercase (e.g., "polyvco")
 * 2. **getName() Return Values**: All modules return lowercase names (e.g., "polyvco")
 * 3. **Pin Database Keys**: All keys are lowercase (e.g., "polyvco")
 * 4. **No Aliases Needed**: Single source of truth eliminates ambiguity
 *
 * ### Pattern for New Modules
 * When creating new modules, follow this exact pattern:
 *
 * ```cpp
 * class NewModuleProcessor : public ModuleProcessor
 * {
 * public:
 *     const juce::String getName() const override { return "new module"; }
 *     // ... rest of implementation
 * };
 * ```
 *
 * Register in ModularSynthProcessor.cpp:
 * ```cpp
 * reg("new module", []{ return std::make_unique<NewModuleProcessor>(); });
 * ```
 *
 * Add to pin database in ImGuiNodeEditorComponent.cpp:
 * ```cpp
 * modulePinDatabase["new module"] = ModulePinInfo(...);
 * ```
 *
 * ### Why This Works
 * - Module factory uses lowercase names as the canonical "type"
 * - getName() returns the same lowercase name for consistency
 * - UI looks up modules by their lowercase type in the pin database
 * - All lookups succeed because keys are standardized
 * - Pin colors display correctly (green for audio, blue for CV, yellow for gate)
 *
 * This pattern ensures robust, maintainable code and eliminates naming-related bugs.
 */

#include "ModuleProcessor.h"
#include <juce_dsp/juce_dsp.h>
#include <cmath>

class BestPracticeNodeProcessor : public ModuleProcessor
{
public:
    // Parameter IDs
    static constexpr auto paramIdFrequency    = "frequency";
    static constexpr auto paramIdWaveform     = "waveform";
    static constexpr auto paramIdDrive        = "drive";
    // Virtual modulation target IDs (no APVTS parameters required)
    static constexpr auto paramIdFrequencyMod = "frequency_mod";
    static constexpr auto paramIdWaveformMod  = "waveform_mod";
    static constexpr auto paramIdDriveMod     = "drive_mod";

    BestPracticeNodeProcessor();
    ~BestPracticeNodeProcessor() override = default;

    const juce::String getName() const override { return "best_practice"; }

    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth,
                               const std::function<bool(const juce::String& paramId)>& isParamModulated,
                               const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
#endif

    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    juce::dsp::Oscillator<float> oscillator;

    // Cached parameter pointers
    std::atomic<float>* frequencyParam { nullptr };
    std::atomic<float>* waveformParam  { nullptr };
    std::atomic<float>* driveParam     { nullptr };

    // Smoothed values to prevent zipper noise
    juce::SmoothedValue<float> smoothedFrequency;
    juce::SmoothedValue<float> smoothedDrive;

    int currentWaveform = -1;
};




================================================================================
FILE: juce\Source\audio\modules\BestPracticeNodeProcessor.cpp
================================================================================


#include "BestPracticeNodeProcessor.h"

juce::AudioProcessorValueTreeState::ParameterLayout BestPracticeNodeProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdFrequency, "Frequency",
        juce::NormalisableRange<float>(20.0f, 20000.0f, 1.0f, 0.25f), 440.0f));

    params.push_back(std::make_unique<juce::AudioParameterChoice>(
        paramIdWaveform, "Waveform",
        juce::StringArray { "Sine", "Saw", "Square" }, 0));

    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        paramIdDrive, "Drive",
        juce::NormalisableRange<float>(1.0f, 50.0f, 0.01f, 0.5f), 1.0f));

    return { params.begin(), params.end() };
}

BestPracticeNodeProcessor::BestPracticeNodeProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(5), true)
                        .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "BestPracticeParams", createParameterLayout())
{
    frequencyParam = apvts.getRawParameterValue(paramIdFrequency);
    waveformParam  = apvts.getRawParameterValue(paramIdWaveform);
    driveParam     = apvts.getRawParameterValue(paramIdDrive);

    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
    lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));

    oscillator.initialise([](float x){ return std::sin(x); }, 128);
}

void BestPracticeNodeProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::dsp::ProcessSpec spec { sampleRate, (juce::uint32) samplesPerBlock, 1 };
    oscillator.prepare(spec);

    smoothedFrequency.reset(sampleRate, 0.01);
    smoothedDrive.reset(sampleRate, 0.01);
}

void BestPracticeNodeProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);

    auto inBus  = getBusBuffer(buffer, true, 0);
    auto outBus = getBusBuffer(buffer, false, 0);

    const bool isFreqMod  = isParamInputConnected(paramIdFrequencyMod);
    const bool isWaveMod  = isParamInputConnected(paramIdWaveformMod);
    const bool isDriveMod = isParamInputConnected(paramIdDriveMod);

    const float* audioInL = inBus.getNumChannels() > 0 ? inBus.getReadPointer(0) : nullptr;
    const float* audioInR = inBus.getNumChannels() > 1 ? inBus.getReadPointer(1) : nullptr;
    const float* freqCV   = isFreqMod  && inBus.getNumChannels() > 2 ? inBus.getReadPointer(2) : nullptr;
    const float* waveCV   = isWaveMod  && inBus.getNumChannels() > 3 ? inBus.getReadPointer(3) : nullptr;
    const float* driveCV  = isDriveMod && inBus.getNumChannels() > 4 ? inBus.getReadPointer(4) : nullptr;

    auto* outL = outBus.getNumChannels() > 0 ? outBus.getWritePointer(0) : nullptr;
    auto* outR = outBus.getNumChannels() > 1 ? outBus.getWritePointer(1) : outL;

    const float baseFrequency = frequencyParam != nullptr ? frequencyParam->load() : 440.0f;
    const int   baseWaveform  = waveformParam  != nullptr ? (int) waveformParam->load()  : 0;
    const float baseDrive     = driveParam     != nullptr ? driveParam->load()     : 1.0f;

    for (int i = 0; i < buffer.getNumSamples(); ++i)
    {
        float currentFreq = baseFrequency;
        if (isFreqMod && freqCV)
        {
            const float cv = juce::jlimit(0.0f, 1.0f, freqCV[i]);
            constexpr float fMin = 20.0f;
            constexpr float fMax = 20000.0f;
            const float spanOct = std::log2(fMax / fMin);
            currentFreq = fMin * std::pow(2.0f, cv * spanOct);
        }

        int currentWave = baseWaveform;
        if (isWaveMod && waveCV)
        {
            const float cv = juce::jlimit(0.0f, 1.0f, waveCV[i]);
            currentWave = (int) (cv * 2.99f);
        }

        float currentDrive = baseDrive;
        if (isDriveMod && driveCV)
        {
            const float cv = juce::jlimit(0.0f, 1.0f, driveCV[i]);
            currentDrive = juce::jmap(cv, 1.0f, 50.0f);
        }

        smoothedFrequency.setTargetValue(currentFreq);
        smoothedDrive.setTargetValue(currentDrive);

        if (currentWaveform != currentWave)
        {
            if (currentWave == 0)      oscillator.initialise([](float x){ return std::sin(x); }, 128);
            else if (currentWave == 1) oscillator.initialise([](float x){ return (x / juce::MathConstants<float>::pi); }, 128);
            else                       oscillator.initialise([](float x){ return x < 0.0f ? -1.0f : 1.0f; }, 128);
            currentWaveform = currentWave;
        }

        oscillator.setFrequency(smoothedFrequency.getNextValue(), false);
        const float osc = oscillator.processSample(0.0f);
        const float shaped = std::tanh(osc * smoothedDrive.getNextValue());

        const float inL = audioInL ? audioInL[i] : 1.0f;
        const float inR = audioInR ? audioInR[i] : inL;

        const float outSampleL = shaped * inL;
        const float outSampleR = shaped * inR;

        if (outL) outL[i] = outSampleL;
        if (outR) outR[i] = outSampleR;

        if ((i & 0x3F) == 0)
        {
            setLiveParamValue("frequency_live", smoothedFrequency.getCurrentValue());
            setLiveParamValue("waveform_live", (float) currentWave);
            setLiveParamValue("drive_live", smoothedDrive.getCurrentValue());
        }
    }

    if (lastOutputValues.size() >= 2)
    {
        if (lastOutputValues[0]) lastOutputValues[0]->store(outBus.getNumChannels() > 0 ? outBus.getSample(0, buffer.getNumSamples() - 1) : 0.0f);
        if (lastOutputValues[1]) lastOutputValues[1]->store(outBus.getNumChannels() > 1 ? outBus.getSample(1, buffer.getNumSamples() - 1) : 0.0f);
    }
}

#if defined(PRESET_CREATOR_UI)
void BestPracticeNodeProcessor::drawParametersInNode (float itemWidth,
                                                      const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                                      const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();

    const bool freqIsMod = isParamModulated(paramIdFrequencyMod);
    float freq = freqIsMod ? getLiveParamValueFor(paramIdFrequencyMod, "frequency_live", frequencyParam ? frequencyParam->load() : 440.0f)
                           : (frequencyParam ? frequencyParam->load() : 440.0f);

    int wave = (int) (waveformParam ? waveformParam->load() : 0.0f);
    if (isParamModulated(paramIdWaveformMod))
        wave = (int) getLiveParamValueFor(paramIdWaveformMod, "waveform_live", (float) wave);

    const bool driveIsMod = isParamModulated(paramIdDriveMod);
    float drive = driveIsMod ? getLiveParamValueFor(paramIdDriveMod, "drive_live", driveParam ? driveParam->load() : 1.0f)
                             : (driveParam ? driveParam->load() : 1.0f);

    ImGui::PushItemWidth(itemWidth);

    if (freqIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Frequency", &freq, 20.0f, 20000.0f, "%.1f Hz", ImGuiSliderFlags_Logarithmic))
    {
        if (!freqIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdFrequency))) *p = freq;
    }
    if (!freqIsMod) adjustParamOnWheel(ap.getParameter(paramIdFrequency), "frequencyHz", freq);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (freqIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    const bool waveIsMod = isParamModulated(paramIdWaveformMod);
    if (waveIsMod) ImGui::BeginDisabled();
    if (ImGui::Combo("Waveform", &wave, "Sine\0Saw\0Square\0\0"))
    {
        if (!waveIsMod) if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter(paramIdWaveform))) *p = wave;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (waveIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    if (driveIsMod) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Drive", &drive, 1.0f, 50.0f, "%.2f", ImGuiSliderFlags_Logarithmic))
    {
        if (!driveIsMod) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter(paramIdDrive))) *p = drive;
    }
    if (!driveIsMod) adjustParamOnWheel(ap.getParameter(paramIdDrive), "drive", drive);
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (driveIsMod) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    ImGui::PopItemWidth();
}

void BestPracticeNodeProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("In L", 0);
    helpers.drawAudioInputPin("In R", 1);
    helpers.drawAudioInputPin("Freq Mod", 2);
    helpers.drawAudioInputPin("Wave Mod", 3);
    helpers.drawAudioInputPin("Drive Mod", 4);

    helpers.drawAudioOutputPin("Out L", 0);
    helpers.drawAudioOutputPin("Out R", 1);
}

juce::String BestPracticeNodeProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "In L";
        case 1: return "In R";
        case 2: return "Freq Mod";
        case 3: return "Wave Mod";
        case 4: return "Drive Mod";
        default: return {};
    }
}

juce::String BestPracticeNodeProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Out L";
        case 1: return "Out R";
        default: return {};
    }
}
#endif

bool BestPracticeNodeProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    outBusIndex = 0;
    if (paramId == paramIdFrequencyMod) { outChannelIndexInBus = 2; return true; }
    if (paramId == paramIdWaveformMod)  { outChannelIndexInBus = 3; return true; }
    if (paramId == paramIdDriveMod)     { outChannelIndexInBus = 4; return true; }
    return false;
}




================================================================================
FILE: juce\Source\audio\modules\ColorTrackerModule.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <opencv2/core.hpp>
#include <juce_core/juce_core.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_graphics/juce_graphics.h>
#if defined(PRESET_CREATOR_UI)
#include <juce_gui_basics/juce_gui_basics.h>
#endif

// A struct to hold the state and results for a single tracked color.
struct TrackedColor
{
    juce::String name;
    juce::Colour displayColour; // representative color for UI swatch
    cv::Scalar hsvLower { 0, 100, 100 };
    cv::Scalar hsvUpper { 10, 255, 255 };
    float tolerance { 1.0f }; // 1.0 = default window; <1 shrink, >1 expand
};

// x, y, area for each color
using ColorResult = std::vector<std::tuple<float, float, float>>;

class ColorTrackerModule : public ModuleProcessor, private juce::Thread
{
public:
    ColorTrackerModule();
    ~ColorTrackerModule() override;

    const juce::String getName() const override { return "color_tracker"; }
    
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi) override;
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    juce::Image getLatestFrame();

    // UI integration helpers
    void addColorAt(int x, int y);
    bool isPickerActive() const { return isColorPickerActive.load(); }
    void exitPickerMode() { isColorPickerActive.store(false); }

    // Dynamic outputs: 3 per color
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;

    // Persist tracked colors across sessions
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree& state) override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth,
                              const std::function<bool(const juce::String& paramId)>& isParamModulated,
                              const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
    ImVec2 getCustomNodeSize() const override;
#endif

private:
    void run() override;
    void updateGuiFrame(const cv::Mat& frame);
    
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    juce::AudioProcessorValueTreeState apvts;
    
    std::atomic<float>* sourceIdParam = nullptr;
    std::atomic<float>* zoomLevelParam = nullptr; // 0=Small,1=Normal,2=Large
    
    // Thread-safe color list
    std::vector<TrackedColor> trackedColors;
    mutable juce::CriticalSection colorListLock;
    
    // Source ID (set by audio thread)
    std::atomic<juce::uint32> currentSourceId { 0 };
    
    // FIFO for communication
    ColorResult lastResultForAudio;
    juce::AbstractFifo fifo { 16 };
    std::vector<ColorResult> fifoBuffer;
    
    // UI interaction
    std::atomic<bool> isColorPickerActive { false };
    // -1 means add a new color; 0+ means update that tracked color index
    std::atomic<int> pickerTargetIndex { -1 };
    std::atomic<int> pickerMouseX { -1 }, pickerMouseY { -1 };
    std::atomic<bool> addColorRequested { false };

    // UI preview
    juce::Image latestFrameForGui;
    juce::CriticalSection imageLock;

    // Cached last BGR frame for operations while source is paused/no new frames
    cv::Mat lastFrameBgr;
    juce::CriticalSection frameLock;
};




================================================================================
FILE: juce\Source\audio\modules\ColorTrackerModule.cpp
================================================================================


#include "ColorTrackerModule.h"
#include "../graph/ModularSynthProcessor.h"
#include "../../video/VideoFrameManager.h"
#include <opencv2/imgproc.hpp>

#if defined(PRESET_CREATOR_UI)
#include <imgui.h>
#endif

juce::AudioProcessorValueTreeState::ParameterLayout ColorTrackerModule::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back(std::make_unique<juce::AudioParameterFloat>(
        "sourceId", "Source ID", 0.0f, 1000.0f, 0.0f));
    params.push_back(std::make_unique<juce::AudioParameterChoice>(
        "zoomLevel", "Zoom Level", juce::StringArray{ "Small", "Normal", "Large" }, 1));
    return { params.begin(), params.end() };
}

ColorTrackerModule::ColorTrackerModule()
    : ModuleProcessor(BusesProperties()
                      .withInput("Input", juce::AudioChannelSet::mono(), true)
                      .withOutput("Output", juce::AudioChannelSet::discreteChannels(24), true)), // up to 8 colors x 3
      juce::Thread("Color Tracker Thread"),
      apvts(*this, nullptr, "ColorTrackerParams", createParameterLayout())
{
    sourceIdParam = apvts.getRawParameterValue("sourceId");
    zoomLevelParam = apvts.getRawParameterValue("zoomLevel");
    fifoBuffer.resize(16);
}

ColorTrackerModule::~ColorTrackerModule()
{
    stopThread(5000);
}

void ColorTrackerModule::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(sampleRate, samplesPerBlock);
    startThread(juce::Thread::Priority::normal);
}

void ColorTrackerModule::releaseResources()
{
    signalThreadShouldExit();
    stopThread(5000);
}

void ColorTrackerModule::run()
{
    while (!threadShouldExit())
    {
        juce::uint32 sourceId = currentSourceId.load();
        cv::Mat frame = VideoFrameManager::getInstance().getFrame(sourceId);
        if (!frame.empty())
        {
        cv::Mat hsv;
        if (!frame.empty())
        {
            // Cache last good frame for paused/no-signal scenarios
            {
                const juce::ScopedLock lk(frameLock);
                frame.copyTo(lastFrameBgr);
            }
        }
        else
        {
            // Use cached frame when no fresh frames are available (e.g., transport paused)
            const juce::ScopedLock lk(frameLock);
            if (!lastFrameBgr.empty())
                frame = lastFrameBgr.clone();
        }

        if (!frame.empty())
            cv::cvtColor(frame, hsv, cv::COLOR_BGR2HSV);

            // NOTE: No queued color-pick path here anymore; add/update is handled synchronously by addColorAt()

            ColorResult result;
            {
                const juce::ScopedLock lock(colorListLock);
                for (auto& tc : trackedColors)
                {
                    if (frame.empty() || hsv.empty())
                    {
                        result.emplace_back(0.5f, 0.5f, 0.0f);
                        continue;
                    }
                    // Compute tolerance-adjusted bounds
                    double centerH = 0.5 * ((double)tc.hsvLower[0] + (double)tc.hsvUpper[0]);
                    double centerS = 0.5 * ((double)tc.hsvLower[1] + (double)tc.hsvUpper[1]);
                    double centerV = 0.5 * ((double)tc.hsvLower[2] + (double)tc.hsvUpper[2]);
                    double deltaH  = 0.5 * ((double)tc.hsvUpper[0] - (double)tc.hsvLower[0]);
                    double deltaS  = 0.5 * ((double)tc.hsvUpper[1] - (double)tc.hsvLower[1]);
                    double deltaV  = 0.5 * ((double)tc.hsvUpper[2] - (double)tc.hsvLower[2]);
                    double scale   = juce::jlimit(0.1, 5.0, (double)tc.tolerance);
                    double lowH  = juce::jlimit(0.0, 179.0, centerH - deltaH * scale);
                    double highH = juce::jlimit(0.0, 179.0, centerH + deltaH * scale);
                    double lowS  = juce::jlimit(0.0, 255.0, centerS - deltaS * scale);
                    double highS = juce::jlimit(0.0, 255.0, centerS + deltaS * scale);
                    double lowV  = juce::jlimit(0.0, 255.0, centerV - deltaV * scale);
                    double highV = juce::jlimit(0.0, 255.0, centerV + deltaV * scale);

                    cv::Scalar lower(lowH, lowS, lowV);
                    cv::Scalar upper(highH, highS, highV);

                    cv::Mat mask;
                    cv::inRange(hsv, lower, upper, mask);
                    
                    // Morphological cleanup
                    cv::erode(mask, mask, cv::Mat(), cv::Point(-1,-1), 1);
                    cv::dilate(mask, mask, cv::Mat(), cv::Point(-1,-1), 1);
                    
                    std::vector<std::vector<cv::Point>> contours;
                    cv::findContours(mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
                    
                    if (!contours.empty())
                    {
                        size_t best = 0;
                        double maxArea = 0.0;
                        for (size_t i = 0; i < contours.size(); ++i)
                        {
                            double a = cv::contourArea(contours[i]);
                            if (a > maxArea) { maxArea = a; best = i; }
                        }
                        const auto& c = contours[best];
                        cv::Moments m = cv::moments(c);
                        float cx = (m.m00 > 0.0) ? (float)(m.m10 / m.m00) / (float)frame.cols : 0.5f;
                        float cy = (m.m00 > 0.0) ? (float)(m.m01 / m.m00) / (float)frame.rows : 0.5f;
                        float area = juce::jlimit(0.0f, 1.0f, (float)(maxArea / (frame.cols * frame.rows)));
                        result.emplace_back(cx, cy, area);
                        
                        // Draw
                        cv::Rect bbox = cv::boundingRect(c);
                        cv::rectangle(frame, bbox, cv::Scalar(0, 255, 255), 2);
                        cv::putText(frame, tc.name.toStdString(), bbox.tl() + cv::Point(0, -5), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255,255,255), 1);
                    }
                    else
                    {
                        result.emplace_back(0.5f, 0.5f, 0.0f);
                    }
                }
            }

            if (fifo.getFreeSpace() >= 1)
            {
                auto writeScope = fifo.write(1);
                if (writeScope.blockSize1 > 0)
                    fifoBuffer[writeScope.startIndex1] = result;
            }
            
            if (!frame.empty())
                updateGuiFrame(frame);
        }
        
        wait(33);
    }
}

void ColorTrackerModule::updateGuiFrame(const cv::Mat& frame)
{
    cv::Mat bgraFrame;
    cv::cvtColor(frame, bgraFrame, cv::COLOR_BGR2BGRA);
    const juce::ScopedLock lock(imageLock);
    if (latestFrameForGui.isNull() || latestFrameForGui.getWidth() != bgraFrame.cols || latestFrameForGui.getHeight() != bgraFrame.rows)
        latestFrameForGui = juce::Image(juce::Image::ARGB, bgraFrame.cols, bgraFrame.rows, true);
    juce::Image::BitmapData dest(latestFrameForGui, juce::Image::BitmapData::writeOnly);
    memcpy(dest.data, bgraFrame.data, bgraFrame.total() * bgraFrame.elemSize());
}

juce::Image ColorTrackerModule::getLatestFrame()
{
    const juce::ScopedLock lock(imageLock);
    return latestFrameForGui.createCopy();
}

void ColorTrackerModule::addColorAt(int x, int y)
{
    // Synchronous immediate update only (no background queuing)
    bool appliedSync = false;

    cv::Mat frameCopy;
    {
        const juce::ScopedLock lk(frameLock);
        if (!lastFrameBgr.empty())
            frameCopy = lastFrameBgr.clone();
    }
    if (!frameCopy.empty())
    {
        const int mx = juce::jlimit(0, frameCopy.cols - 1, x);
        const int my = juce::jlimit(0, frameCopy.rows - 1, y);
        cv::Rect roi(std::max(0, mx - 2), std::max(0, my - 2), 5, 5);
        roi &= cv::Rect(0, 0, frameCopy.cols, frameCopy.rows);
        if (roi.area() > 0)
        {
            cv::Scalar avgBgr = cv::mean(frameCopy(roi));
            cv::Vec3b bgr8((uchar)avgBgr[0], (uchar)avgBgr[1], (uchar)avgBgr[2]);
            cv::Mat onePix(1,1,CV_8UC3);
            onePix.at<cv::Vec3b>(0,0) = bgr8;
            cv::Mat onePixHsv;
            cv::cvtColor(onePix, onePixHsv, cv::COLOR_BGR2HSV);
            cv::Vec3b avgHsv = onePixHsv.at<cv::Vec3b>(0,0);
            int avgHue = (int)avgHsv[0];
            int avgSat = (int)avgHsv[1];
            int avgVal = (int)avgHsv[2];

            const juce::ScopedLock lock(colorListLock);
            int targetIdx = pickerTargetIndex.load();
            if (targetIdx < 0 || targetIdx >= (int)trackedColors.size())
            {
                TrackedColor tc;
                tc.name = juce::String("Color ") + juce::String((int)trackedColors.size() + 1);
                tc.hsvLower = cv::Scalar(
                    juce::jlimit(0, 179, avgHue - 10),
                    juce::jlimit(0, 255, avgSat - 40),
                    juce::jlimit(0, 255, avgVal - 40));
                tc.hsvUpper = cv::Scalar(
                    juce::jlimit(0, 179, avgHue + 10),
                    juce::jlimit(0, 255, avgSat + 40),
                    juce::jlimit(0, 255, avgVal + 40));
                tc.displayColour = juce::Colour((juce::uint8)bgr8[2], (juce::uint8)bgr8[1], (juce::uint8)bgr8[0]);
                trackedColors.push_back(tc);
            }
            else
            {
                auto& tc = trackedColors[(size_t)targetIdx];
                tc.hsvLower = cv::Scalar(
                    juce::jlimit(0, 179, avgHue - 10),
                    juce::jlimit(0, 255, avgSat - 40),
                    juce::jlimit(0, 255, avgVal - 40));
                tc.hsvUpper = cv::Scalar(
                    juce::jlimit(0, 179, avgHue + 10),
                    juce::jlimit(0, 255, avgSat + 40),
                    juce::jlimit(0, 255, avgVal + 40));
                tc.displayColour = juce::Colour((juce::uint8)bgr8[2], (juce::uint8)bgr8[1], (juce::uint8)bgr8[0]);
                appliedSync = true;
            }

            // Push the same frame to GUI immediately for instant visual feedback
            updateGuiFrame(frameCopy);
        }
    }

    // Finalize picker state; never queue async to avoid duplicates
    addColorRequested.store(false);
    pickerMouseX.store(-1);
    pickerMouseY.store(-1);
    isColorPickerActive.store(false);
}

juce::ValueTree ColorTrackerModule::getExtraStateTree() const
{
    juce::ValueTree state("ColorTrackerState");
    const juce::ScopedLock lock(colorListLock);
    for (const auto& tc : trackedColors)
    {
        juce::ValueTree node("TrackedColor");
        node.setProperty("name", tc.name, nullptr);
        node.setProperty("displayColour", tc.displayColour.toString(), nullptr);
        // Persist HSV windows (indexed fields for stability)
        node.setProperty("hsvLower0", (int)tc.hsvLower[0], nullptr);
        node.setProperty("hsvLower1", (int)tc.hsvLower[1], nullptr);
        node.setProperty("hsvLower2", (int)tc.hsvLower[2], nullptr);
        node.setProperty("hsvUpper0", (int)tc.hsvUpper[0], nullptr);
        node.setProperty("hsvUpper1", (int)tc.hsvUpper[1], nullptr);
        node.setProperty("hsvUpper2", (int)tc.hsvUpper[2], nullptr);
        node.setProperty("tolerance", tc.tolerance, nullptr);
        state.addChild(node, -1, nullptr);
    }
    return state;
}

void ColorTrackerModule::setExtraStateTree(const juce::ValueTree& state)
{
    if (!state.hasType("ColorTrackerState")) return;
    const juce::ScopedLock lock(colorListLock);
    trackedColors.clear();
    for (int i = 0; i < state.getNumChildren(); ++i)
    {
        auto node = state.getChild(i);
        if (!node.hasType("TrackedColor")) continue;
        TrackedColor tc;
        tc.name = node.getProperty("name", juce::String("Color ") + juce::String(i)).toString();
        tc.displayColour = juce::Colour::fromString(node.getProperty("displayColour", "ff000000").toString());
        int hL = (int)node.getProperty("hsvLower0", 0);
        int sL = (int)node.getProperty("hsvLower1", 100);
        int vL = (int)node.getProperty("hsvLower2", 100);
        int hU = (int)node.getProperty("hsvUpper0", 10);
        int sU = (int)node.getProperty("hsvUpper1", 255);
        int vU = (int)node.getProperty("hsvUpper2", 255);
        tc.hsvLower = cv::Scalar(hL, sL, vL);
        tc.hsvUpper = cv::Scalar(hU, sU, vU);
        tc.tolerance = (float)(double)node.getProperty("tolerance", 1.0);
        trackedColors.push_back(tc);
    }
    // UI will re-query pins on next frame; no explicit rebuild signal required
}

void ColorTrackerModule::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused(midi);
    auto inputBuffer = getBusBuffer(buffer, true, 0);
    if (inputBuffer.getNumChannels() > 0 && inputBuffer.getNumSamples() > 0)
        currentSourceId.store((juce::uint32)inputBuffer.getSample(0, 0));

    buffer.clear();
    if (fifo.getNumReady() > 0)
    {
        auto readScope = fifo.read(1);
        if (readScope.blockSize1 > 0)
            lastResultForAudio = fifoBuffer[readScope.startIndex1];
    }

    // Map each tracked color to 3 outputs: X, Y, Area
    for (size_t i = 0; i < lastResultForAudio.size(); ++i)
    {
        int chX = (int)i * 3 + 0;
        int chY = (int)i * 3 + 1;
        int chA = (int)i * 3 + 2;
        if (chA < buffer.getNumChannels())
        {
            const auto& tpl = lastResultForAudio[i];
            float vx = std::get<0>(tpl);
            float vy = std::get<1>(tpl);
            float va = std::get<2>(tpl);
            for (int s = 0; s < buffer.getNumSamples(); ++s)
            {
                buffer.setSample(chX, s, vx);
                buffer.setSample(chY, s, vy);
                buffer.setSample(chA, s, va);
            }
        }
    }
}

std::vector<DynamicPinInfo> ColorTrackerModule::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    const juce::ScopedLock lock(colorListLock);
    for (size_t i = 0; i < trackedColors.size(); ++i)
    {
        pins.emplace_back(trackedColors[i].name + " X", (int)(i * 3 + 0), PinDataType::CV);
        pins.emplace_back(trackedColors[i].name + " Y", (int)(i * 3 + 1), PinDataType::CV);
        pins.emplace_back(trackedColors[i].name + " Area", (int)(i * 3 + 2), PinDataType::CV);
    }
    return pins;
}

#if defined(PRESET_CREATOR_UI)
ImVec2 ColorTrackerModule::getCustomNodeSize() const
{
    int level = zoomLevelParam ? (int) zoomLevelParam->load() : 1;
    level = juce::jlimit(0, 2, level);
    const float widths[3] { 240.0f, 480.0f, 960.0f };
    return ImVec2(widths[level], 0.0f);
}

void ColorTrackerModule::drawParametersInNode(float itemWidth,
                                              const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                              const std::function<void()>& onModificationEnded)
{
    juce::ignoreUnused(isParamModulated, onModificationEnded);
    ImGui::PushItemWidth(itemWidth);

    if (ImGui::Button("Add Color...", ImVec2(itemWidth, 0)))
    {
        pickerTargetIndex.store(-1);
        isColorPickerActive.store(true);
    }

    if (isColorPickerActive.load())
    {
        ImGui::TextColored(ImVec4(1.f,1.f,0.f,1.f), "Click on the video preview to pick a color");
    }

    // Zoom controls (-/+) like PoseEstimator
    {
        int level = zoomLevelParam ? (int) zoomLevelParam->load() : 1;
        level = juce::jlimit(0, 2, level);
        float buttonWidth = (itemWidth / 2.0f) - 4.0f;
        const bool atMin = (level <= 0);
        const bool atMax = (level >= 2);
        if (atMin) ImGui::BeginDisabled();
        if (ImGui::Button("-", ImVec2(buttonWidth, 0)))
        {
            int newLevel = juce::jmax(0, level - 1);
            if (auto* p = apvts.getParameter("zoomLevel"))
                p->setValueNotifyingHost((float)newLevel / 2.0f);
        }
        if (atMin) ImGui::EndDisabled();
        ImGui::SameLine();
        if (atMax) ImGui::BeginDisabled();
        if (ImGui::Button("+", ImVec2(buttonWidth, 0)))
        {
            int newLevel = juce::jmin(2, level + 1);
            if (auto* p = apvts.getParameter("zoomLevel"))
                p->setValueNotifyingHost((float)newLevel / 2.0f);
        }
        if (atMax) ImGui::EndDisabled();
    }

    // Render tracked color list with swatch, tolerance, and remove
    {
        const juce::ScopedLock lock(colorListLock);
        for (size_t i = 0; i < trackedColors.size(); )
        {
            ImGui::Separator();
            const auto& tc = trackedColors[i];
            ImVec4 imc(tc.displayColour.getFloatRed(), tc.displayColour.getFloatGreen(), tc.displayColour.getFloatBlue(), 1.0f);
            if (ImGui::ColorButton((tc.name + "##swatch" + juce::String((int)i)).toRawUTF8(), imc, ImGuiColorEditFlags_NoTooltip, ImVec2(20,20)))
            {
                pickerTargetIndex.store((int)i);
                isColorPickerActive.store(true);
            }
            ImGui::SameLine();
            ImGui::TextUnformatted((tc.name + "##label" + juce::String((int)i)).toRawUTF8());
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120.0f);
            float tol = (float)tc.tolerance;
            if (ImGui::SliderFloat((juce::String("Tol##") + juce::String((int)i)).toRawUTF8(), &tol, 0.1f, 5.0f, "%.2fx"))
            {
                const_cast<TrackedColor&>(tc).tolerance = tol;
            }
            ImGui::SameLine();
            if (ImGui::SmallButton((juce::String("Remove##") + juce::String((int)i)).toRawUTF8()))
            {
                trackedColors.erase(trackedColors.begin() + (long long)i);
                continue; // don't increment i when erased
            }
            ++i;
        }
    }

    ImGui::PopItemWidth();
}

void ColorTrackerModule::drawIoPins(const NodePinHelpers& helpers)
{
    helpers.drawAudioInputPin("Source In", 0);
    // Outputs are dynamic; editor queries via getDynamicOutputPins
}
#endif




================================================================================
FILE: juce\Source\audio\modules\AnimationModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "../../animation/AnimationFileLoader.h"
#include "../../animation/AnimationBinder.h"
#include "../../animation/Animator.h"
#include "../../animation/AnimationRenderer.h"
#include <memory>
#include <atomic>
#include <algorithm>
#include <glm/glm.hpp>

// Inherit from juce::ChangeListener to receive notifications from the background loader
class AnimationModuleProcessor : public ModuleProcessor,
                                 public juce::ChangeListener
{
public:
    AnimationModuleProcessor();
    ~AnimationModuleProcessor() override;

    // --- Main JUCE Functions ---
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    const juce::String getName() const override { return "Animation Node"; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // --- Force this node to always be processed ---
    bool isBusesLayoutSupported(const BusesLayout& layouts) const override;
    
    // Tell the UI about our output pins
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;
    
    // Rhythm reporting for BPM Monitor
    std::optional<RhythmInfo> getRhythmInfo() const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth,
                              const std::function<bool(const juce::String& paramId)>& isParamModulated,
                              const std::function<void()>& onModificationEnded) override;
#endif

    // --- Custom Functions ---
    
    // Opens a file chooser and loads the selected animation file in the background
    void openAnimationFile();
    
    // Check if an animation file is currently being loaded in the background
    bool isCurrentlyLoading() const;
    
    // Callback executed on the main thread when background loading completes
    void changeListenerCallback(juce::ChangeBroadcaster* source) override;
    
    const std::vector<glm::mat4>& getFinalBoneMatrices() const;
    
    // Dynamic bone tracking
    void addTrackedBone(const std::string& boneName);
    void removeTrackedBone(const std::string& boneName);
    
    // Ground Plane data structure with depth
    struct GroundPlane {
        float y = 0.0f;
        float depth = 0.0f;
    };
    void addGroundPlane(float initialY = 0.0f, float initialDepth = 0.0f);
    void removeGroundPlane(int index = -1);
    std::vector<GroundPlane> getGroundPlanes() const;

    // --- State Management (for saving/loading presets) ---
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree& state) override;

#if defined(PRESET_CREATOR_UI)
    // Auto-connection feature flags
    std::atomic<bool> autoBuildTriggersAudioTriggered { false };
#endif

private:
    static constexpr int MAX_TRACKED_BONES = 10; // Maximum number of bones we can track simultaneously
    
    // Update bone IDs for all tracked bones from the currently loaded animation
    void updateTrackedBoneIDs();
    
    // Helper structure for tracking multiple bones
    struct TrackedBone
    {
        std::string name;
        int boneId = -1;

        // UI-thread state for kinematics
        glm::vec2 lastScreenPos { 0.0f, 0.0f };
        bool isFirstFrame = true;
        bool wasBelowGround = false; // Legacy screen-space flag
        bool wasBelowWorldGround = false; // Legacy single-plane flag
        std::vector<bool> wasAboveCenter; // NEW: Tracks if bone was above the plane's center line last frame
        float previousScreenY = 0.0f; // Kept for compatibility
        float hitFlashTimer = 0.0f; // Countdown timer for red flash visual feedback

        // Atomics for audio thread
        std::atomic<float> velX { 0.0f };
        std::atomic<float> velY { 0.0f };
        std::atomic<bool> triggerState { false };
        
        // Copy constructor (atomics can't be copied, so load/store their values)
        TrackedBone(const TrackedBone& other)
            : name(other.name), boneId(other.boneId),
              lastScreenPos(other.lastScreenPos), isFirstFrame(other.isFirstFrame),
              wasBelowGround(other.wasBelowGround), wasBelowWorldGround(other.wasBelowWorldGround),
              wasAboveCenter(other.wasAboveCenter), previousScreenY(other.previousScreenY),
              hitFlashTimer(other.hitFlashTimer),
              velX(other.velX.load()), velY(other.velY.load()),
              triggerState(other.triggerState.load())
        {}
        
        // Copy assignment operator
        TrackedBone& operator=(const TrackedBone& other)
        {
            if (this != &other)
            {
                name = other.name;
                boneId = other.boneId;
                lastScreenPos = other.lastScreenPos;
                isFirstFrame = other.isFirstFrame;
                wasBelowGround = other.wasBelowGround;
                wasBelowWorldGround = other.wasBelowWorldGround;
                wasAboveCenter = other.wasAboveCenter;
                previousScreenY = other.previousScreenY;
                hitFlashTimer = other.hitFlashTimer;
                velX.store(other.velX.load());
                velY.store(other.velY.load());
                triggerState.store(other.triggerState.load());
            }
            return *this;
        }
        
        // Default constructor
        TrackedBone() = default;
    };

    // Called after raw data is loaded to bind and set up the animation
    void setupAnimationFromRawData(std::unique_ptr<RawAnimationData> rawData);
    
    // Parameter state (empty for this module, but required by ModuleProcessor)
    juce::AudioProcessorValueTreeState apvts;

    // Background animation file loader
    AnimationFileLoader m_fileLoader;

    // --- Thread-Safe Animation Data Management ---
    
    // The audio thread reads from this atomic pointer (lock-free).
    // It points to the currently active Animator that's being used for audio processing.
    std::atomic<Animator*> m_activeAnimator { nullptr };
    
    // This owns the AnimationData for the currently active animator.
    // We must keep this alive as long as the active animator might be in use.
    std::unique_ptr<AnimationData> m_activeData;
    
    // When new data is loaded, it's prepared here first, away from the audio thread.
    std::unique_ptr<AnimationData> m_stagedAnimationData;
    std::unique_ptr<Animator> m_stagedAnimator;
    
    // Old animators/data that need to be deleted safely after the audio thread is done with them.
    // We can't delete immediately after swapping because the audio thread might still be using it.
    std::vector<std::unique_ptr<Animator>> m_animatorsToFree;
    std::vector<std::unique_ptr<AnimationData>> m_dataToFree;
    juce::CriticalSection m_freeingLock; // Protects the above arrays
    
    // Tracked bones (dynamic list) for dedicated outputs - preserves insertion order
    std::vector<TrackedBone> m_trackedBones;
    juce::CriticalSection m_trackedBonesLock; // Protects m_trackedBones from concurrent access
    
    // Dynamic ground planes for multi-level trigger detection
    std::vector<GroundPlane> m_groundPlanes;
    mutable juce::CriticalSection m_groundPlanesLock; // Protects m_groundPlanes from concurrent access
    
    // Rendering
    std::unique_ptr<AnimationRenderer> m_Renderer;
    
    // Per-frame bone colors for rendering (green=tracked, red=hit flash, white=default)
    std::vector<glm::vec3> m_boneColors;

    // NEW: Per-frame vertex pairs for bone edges
    std::vector<glm::vec3> m_boneEdges;

    // File chooser (kept alive during async operation)
    std::unique_ptr<juce::FileChooser> m_FileChooser;

    // Zoom and pan for the animation viewport
    float m_zoom = 10.0f;
    float m_panX = 0.0f;
    float m_panY = 0.0f;

    // View rotation angles (in radians)
    float m_viewRotationX = 0.0f;
    float m_viewRotationY = 0.0f;
    float m_viewRotationZ = 0.0f;

    // Ground line Y position for trigger detection
    float m_groundY = 180.0f;
    
    // UI bone selection (for visualization, not directly tied to outputs anymore)
    int m_selectedBoneIndex = -1;
    std::string m_selectedBoneName = "None";
    int m_selectedBoneID = -1; // Cached bone ID to avoid map lookups
    std::vector<std::string> m_cachedBoneNames; // Thread-safe cache of bone names for UI

    // Name of the animation clip to play when a preset is loaded
    juce::String m_clipToPlayOnLoad;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AnimationModuleProcessor)
};



================================================================================
FILE: juce\Source\audio\modules\AnimationModuleProcessor.cpp
================================================================================


#include "AnimationModuleProcessor.h"
#include "../../animation/AnimationData.h"
#include <glm/gtc/matrix_transform.hpp>
#include <algorithm>

// Helper function to recursively build edge list from skeleton hierarchy
void buildEdgeListRecursive(
    const NodeData& node,
    const std::vector<glm::mat4>& worldTransforms,
    const std::map<std::string, BoneInfo>& boneInfoMap,
    std::vector<glm::vec3>& outEdges)
{
    // Check if the current node is a bone and has a valid transform
    if (boneInfoMap.count(node.name))
    {
        const int boneId = boneInfoMap.at(node.name).id;
        
        // If this node has a parent which is also a bone, create an edge
        if (node.parent && boneInfoMap.count(node.parent->name))
        {
            const int parentBoneId = boneInfoMap.at(node.parent->name).id;
            
            if (boneId < worldTransforms.size() && parentBoneId < worldTransforms.size())
            {
                glm::vec3 childPos = worldTransforms[boneId][3];
                glm::vec3 parentPos = worldTransforms[parentBoneId][3];
                
                // Add the two vertices that form the line segment
                outEdges.push_back(parentPos);
                outEdges.push_back(childPos);
            }
        }
    }

    // Recurse to children
    for (const auto& child : node.children)
    {
        buildEdgeListRecursive(child, worldTransforms, boneInfoMap, outEdges);
    }
}

AnimationModuleProcessor::AnimationModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withOutput("Output", juce::AudioChannelSet::discreteChannels(30), true)), // Max 10 bones * 3 outputs each
      apvts(*this, nullptr, "AnimationParams", {})
{
    // Constructor: m_AnimationData and m_Animator are nullptrs initially.
    m_Renderer = std::make_unique<AnimationRenderer>();
    
    // Register this class to listen for changes from our file loader
    m_fileLoader.addChangeListener(this);
    
    // Tracked bones start empty - they will be added when an animation is loaded
    
    // Initialize with one default ground plane at Y=0
    m_groundPlanes.push_back({0.0f, 0.0f}); // y=0, depth=0
    
    // DEBUG: Verify output channel count
    juce::Logger::writeToLog("[AnimationModule] Constructor: getTotalNumOutputChannels() = " + 
                             juce::String(getTotalNumOutputChannels()));
}

AnimationModuleProcessor::~AnimationModuleProcessor()
{
    // Remove listener before destruction
    m_fileLoader.removeChangeListener(this);
    
    // Safely clean up the active animator
    Animator* oldAnimator = m_activeAnimator.exchange(nullptr);
    if (oldAnimator)
    {
        // Move to deletion queue to be freed safely
        const juce::ScopedLock lock(m_freeingLock);
        m_animatorsToFree.push_back(std::unique_ptr<Animator>(oldAnimator));
    }
    
    // Clear all pending deletions
    {
        const juce::ScopedLock lock(m_freeingLock);
        m_animatorsToFree.clear();
        m_dataToFree.clear();
    }
}

void AnimationModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    // We don't need to do anything special here for this module,
    // but the override is required.
}

void AnimationModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // This is the REAL-TIME AUDIO THREAD - must NOT block!
    
    // === STEP 1: Clean up old data (non-blocking try-lock) ===
    // This is a safe place to delete old animation data that was swapped out.
    {
        const juce::ScopedTryLock tryLock(m_freeingLock);
        if (tryLock.isLocked())
        {
            // We got the lock without blocking - safe to clear old data
            m_animatorsToFree.clear();
            m_dataToFree.clear();
        }
        // If we didn't get the lock, that's fine - we'll try again next block
    }
    
    // === STEP 2: Get current animator (LOCK-FREE atomic load) ===
    // Load the active animator pointer atomically.
    // This is lock-free and safe - even if the main thread swaps in new data,
    // our local pointer remains valid for this entire block.
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    // === STEP 3: Update animation if we have one ===
    if (currentAnimator != nullptr)
    {
        // Calculate the time elapsed for this audio block.
        const float deltaTime = buffer.getNumSamples() / getSampleRate();
        
        // Update the animation - this is now completely lock-free!
        currentAnimator->Update(deltaTime);
    }
    
    // Clear the output buffer first
    buffer.clear();
    
    // --- Bone Trigger and Velocity Outputs (Starting from Channel 0) ---
    const juce::ScopedTryLock tryLock(m_trackedBonesLock);
    if (tryLock.isLocked() && !m_trackedBones.empty())
    {
        for (int i = 0; i < m_trackedBones.size(); ++i)
        {
            auto& bone = m_trackedBones[i];
            if (bone.boneId != -1)
            {
                int baseChannel = i * 3; // Correct base channel

                if (baseChannel + 2 >= buffer.getNumChannels()) break;

                // --- Velocity Outputs (Continuous) ---
                float* velX_ptr = buffer.getWritePointer(baseChannel + 0);
                float* velY_ptr = buffer.getWritePointer(baseChannel + 1);
                juce::FloatVectorOperations::fill(velX_ptr, bone.velX.load(), buffer.getNumSamples());
                juce::FloatVectorOperations::fill(velY_ptr, bone.velY.load(), buffer.getNumSamples());
                
                // --- Hit Trigger Output (Single-Sample Pulse) ---
                if (bone.triggerState.load())
                {
                    buffer.setSample(baseChannel + 2, 0, 1.0f); // Fire trigger
                    bone.triggerState.store(false);             // Reset the flag
                    
                    // Log ONLY when a trigger is fired
                    juce::Logger::writeToLog("AnimationModule: Fired trigger for bone '" + bone.name + "'");
                }
            }
        }
    }
}

bool AnimationModuleProcessor::isCurrentlyLoading() const
{
    return m_fileLoader.isLoading();
}

void AnimationModuleProcessor::openAnimationFile()
{
    // If already loading, ignore the request
    if (isCurrentlyLoading())
    {
        juce::Logger::writeToLog("AnimationModule: Already loading a file. Ignoring new request.");
        return;
    }

    // Create a file chooser to let the user select an animation file
    // Store it as a member to keep it alive during the async operation
    m_FileChooser = std::make_unique<juce::FileChooser>(
        "Select an animation file (glTF/FBX)...",
        juce::File{},
        "*.gltf;*.glb;*.fbx");

    auto flags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

    // Launch the file chooser asynchronously
    m_FileChooser->launchAsync(flags, [this](const juce::FileChooser& chooser)
    {
        if (chooser.getResults().isEmpty())
        {
            juce::Logger::writeToLog("AnimationModule: File selection cancelled.");
            return; // User cancelled
        }

        juce::File file = chooser.getResult();
        
        if (!file.existsAsFile())
        {
            juce::Logger::writeToLog("AnimationModule: Selected file does not exist.");
            return;
        }
        
        juce::Logger::writeToLog("AnimationModule: Starting background load of: " + file.getFullPathName());
        
        // Start the background loading process
        // The UI will remain responsive while this happens!
        m_fileLoader.startLoadingFile(file);
    });
}

void AnimationModuleProcessor::addTrackedBone(const std::string& boneName)
{
    if (boneName == "None" || boneName.empty())
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);

    if (m_trackedBones.size() >= MAX_TRACKED_BONES)
    {
        juce::Logger::writeToLog("AnimationModule: Cannot add more than " + juce::String(MAX_TRACKED_BONES) + " tracked bones.");
        return;
    }

    // Check if the bone is already being tracked
    auto it = std::find_if(m_trackedBones.begin(), m_trackedBones.end(),
                           [&](const TrackedBone& bone) { return bone.name == boneName; });

    if (it != m_trackedBones.end())
        return; // Already exists, do nothing

    // Add the new bone to the END of the list (preserves insertion order)
    TrackedBone newBone;
    newBone.name = boneName;
    
    // Find the bone ID if an animation is already loaded
    if (m_activeData)
    {
        if (m_activeData->boneInfoMap.count(boneName))
        {
            newBone.boneId = m_activeData->boneInfoMap.at(boneName).id;
            juce::Logger::writeToLog("AnimationModule: Added tracked bone '" + juce::String(boneName) + "' with ID " + juce::String(newBone.boneId));
        }
    }
    
    m_trackedBones.push_back(newBone); // This preserves the order!
    
    // Note: Pins will update on next module reload/patch load
}

void AnimationModuleProcessor::removeTrackedBone(const std::string& boneName)
{
    if (boneName == "None" || boneName.empty())
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);

    // Use the erase-remove idiom to find and remove the bone by name
    auto it = std::remove_if(m_trackedBones.begin(), m_trackedBones.end(),
                             [&](const TrackedBone& bone) { return bone.name == boneName; });
    
    if (it != m_trackedBones.end())
    {
        m_trackedBones.erase(it, m_trackedBones.end());
        juce::Logger::writeToLog("AnimationModule: Removed tracked bone '" + juce::String(boneName) + "'");

        // Note: Pins will update on next module reload/patch load
    }
}

void AnimationModuleProcessor::addGroundPlane(float initialY, float initialDepth)
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    m_groundPlanes.push_back({initialY, initialDepth});
    juce::Logger::writeToLog("AnimationModule: Added ground plane at Y=" + juce::String(initialY) + " with Depth=" + juce::String(initialDepth));
}

void AnimationModuleProcessor::removeGroundPlane(int index)
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    if (m_groundPlanes.empty()) return;

    if (index < 0 || index >= (int)m_groundPlanes.size())
    {
        m_groundPlanes.pop_back(); // Default to removing the last one
    }
    else
    {
        m_groundPlanes.erase(m_groundPlanes.begin() + index);
    }
    juce::Logger::writeToLog("AnimationModule: Removed ground plane (count now: " + juce::String((int)m_groundPlanes.size()) + ")");
}

std::vector<AnimationModuleProcessor::GroundPlane> AnimationModuleProcessor::getGroundPlanes() const
{
    const juce::ScopedLock lock(m_groundPlanesLock);
    return m_groundPlanes;
}

void AnimationModuleProcessor::updateTrackedBoneIDs()
{
    // No animation loaded, nothing to do
    if (m_activeData == nullptr)
        return;

    const juce::ScopedLock lock(m_trackedBonesLock);
    
    // Go through all currently tracked bones and find matching bone IDs in the animation
    for (auto& bone : m_trackedBones)
    {
        const std::string& trackedBoneName = bone.name;
        int foundId = -1;

        // Search for this bone name in the animation's bone info map
        if (m_activeData->boneInfoMap.count(trackedBoneName))
        {
            foundId = m_activeData->boneInfoMap.at(trackedBoneName).id;
            juce::Logger::writeToLog("AnimationModule: Mapped tracked bone '" + juce::String(trackedBoneName) + 
                                     "' to ID " + juce::String(foundId));
        }
        else
        {
            juce::Logger::writeToLog("AnimationModule: WARNING - Tracked bone '" + juce::String(trackedBoneName) + 
                                     "' not found in animation");
        }
        
        bone.boneId = foundId;
    }
}

// THIS IS THE MOST IMPORTANT PART
// This function will be called on the MESSAGE THREAD when the background thread finishes
void AnimationModuleProcessor::changeListenerCallback(juce::ChangeBroadcaster* source)
{
    // Make sure the notification is coming from our file loader
    if (source == &m_fileLoader)
    {
        juce::Logger::writeToLog("AnimationModule: Background loading complete. Processing data...");
        
        // Get the loaded data from the loader (transfers ownership)
        std::unique_ptr<RawAnimationData> rawData = m_fileLoader.getLoadedData();

        if (rawData != nullptr)
        {
            // Success! The file was loaded and parsed in the background.
            // Now we can do the binding and setup work on the message thread.
            juce::String filePath = m_fileLoader.getLoadedFilePath();
            juce::Logger::writeToLog("AnimationModule: File loaded successfully: " + filePath);
            juce::Logger::writeToLog("   Raw Nodes: " + juce::String(rawData->nodes.size()));
            juce::Logger::writeToLog("   Raw Bones: " + juce::String(rawData->bones.size()));
            juce::Logger::writeToLog("   Raw Clips: " + juce::String(rawData->clips.size()));
            
            setupAnimationFromRawData(std::move(rawData));
        }
        else
        {
            // Failure - the loader returned nullptr
            juce::Logger::writeToLog("AnimationModule ERROR: Failed to load animation file. Check logs for details.");
            
            // Show error message to the user
            juce::AlertWindow::showMessageBoxAsync(
                juce::MessageBoxIconType::WarningIcon,
                "Loading Failed",
                "The selected animation file could not be loaded.\nCheck the console logs for details.",
                "OK");
        }
    }
}

void AnimationModuleProcessor::setupAnimationFromRawData(std::unique_ptr<RawAnimationData> rawData)
{
    // This is called on the MESSAGE THREAD after background loading completes
    
    juce::Logger::writeToLog("AnimationModule: Binding raw data to create AnimationData...");
    auto finalData = AnimationBinder::Bind(*rawData);

    if (!finalData)
    {
        juce::Logger::writeToLog("AnimationModule ERROR: AnimationBinder failed to create final AnimationData.");
        
        juce::AlertWindow::showMessageBoxAsync(
            juce::MessageBoxIconType::WarningIcon,
            "Binding Failed",
            "The animation data could not be processed after loading.",
            "OK");
        return;
    }
    
    juce::Logger::writeToLog("AnimationModule: Binder SUCCESS - Final data created.");
    juce::Logger::writeToLog("   Final Bones: " + juce::String(finalData->boneInfoMap.size()));
    juce::Logger::writeToLog("   Final Clips: " + juce::String(finalData->animationClips.size()));

    // === THREAD-SAFE DATA SWAP ===
    // Prepare the new animator and data in "staging" area (not visible to audio thread yet)
    m_stagedAnimationData = std::move(finalData);
    m_stagedAnimator = std::make_unique<Animator>(m_stagedAnimationData.get());
    
    // --- FIX: Play the correct animation clip from the preset ---
    bool playedSpecificClip = false;
    if (m_clipToPlayOnLoad.isNotEmpty())
    {
        // Try to find and play the clip saved in the preset.
        for (const auto& clip : m_stagedAnimationData->animationClips)
        {
            if (clip.name == m_clipToPlayOnLoad.toStdString())
            {
                m_stagedAnimator->PlayAnimation(clip.name);
                juce::Logger::writeToLog("AnimationModule: Playing saved animation clip: " + juce::String(clip.name));
                playedSpecificClip = true;
                break;
            }
        }
        m_clipToPlayOnLoad.clear(); // Clear after use
    }

    // Fallback: If no specific clip was played (or none was saved), play the first one.
    if (!playedSpecificClip && !m_stagedAnimationData->animationClips.empty())
    {
        const auto& firstClip = m_stagedAnimationData->animationClips[0];
        m_stagedAnimator->PlayAnimation(firstClip.name);
        juce::Logger::writeToLog("AnimationModule: No saved clip found. Playing first clip: " + juce::String(firstClip.name));
    }
    
    // Cache bone names for thread-safe UI access (on main thread, before audio thread gets it)
    m_cachedBoneNames.clear();
    for (const auto& pair : m_stagedAnimationData->boneInfoMap)
    {
        m_cachedBoneNames.push_back(pair.first);
    }
    juce::Logger::writeToLog("AnimationModule: Cached " + juce::String((int)m_cachedBoneNames.size()) + " bone names for UI.");
    
    // Update tracked bone IDs for the new animation (NON-DESTRUCTIVE)
    // This does NOT clear the list - it only refreshes the IDs
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        
        // If this is a completely fresh load (no bones tracked yet), add defaults
        if (m_trackedBones.empty())
        {
            TrackedBone leftFoot;
            leftFoot.name = "LeftFoot";
            m_trackedBones.push_back(leftFoot);
            
            TrackedBone rightFoot;
            rightFoot.name = "RightFoot";
            m_trackedBones.push_back(rightFoot);
            
            juce::Logger::writeToLog("AnimationModule: Initialized default tracked bones (LeftFoot, RightFoot)");
        }
        
        // Update bone IDs for ALL currently tracked bones from the new animation
        for (auto& bone : m_trackedBones)
        {
            const std::string& trackedBoneName = bone.name;
            int foundId = -1;

            // Search for a matching bone in the animation
            for (const auto& boneInfoPair : m_stagedAnimationData->boneInfoMap)
            {
                const std::string& boneNameFromFile = boneInfoPair.first;
                
                if (juce::String(boneNameFromFile).endsWithIgnoreCase(trackedBoneName))
                {
                    foundId = boneInfoPair.second.id;
                    juce::Logger::writeToLog("AnimationModule: Refreshed tracked bone '" + juce::String(trackedBoneName) + 
                                             "' with ID " + juce::String(foundId));
                    break;
                }
            }
            
            bone.boneId = foundId;
            
            if (foundId == -1)
            {
                juce::Logger::writeToLog("AnimationModule: WARNING - Tracked bone '" + juce::String(trackedBoneName) + 
                                         "' not found in new animation");
            }
        }
    }
    
    juce::Logger::writeToLog("AnimationModule: Preparing to swap animation data...");
    
    // 1. Release the raw pointer for the new animator from its unique_ptr.
    Animator* newAnimator = m_stagedAnimator.release();
    
    // 2. Atomically swap the new animator into the 'active' slot.
    // The audio thread will pick this up on its next processBlock().
    Animator* oldAnimator = m_activeAnimator.exchange(newAnimator, std::memory_order_release);
    
    // 3. Now, swap the unique_ptr that owns the AnimationData.
    // m_stagedAnimationData (holding the NEW data) is moved into m_activeData.
    // The previous m_activeData (holding the OLD data) is moved into a temporary.
    std::unique_ptr<AnimationData> oldDataToFree = std::move(m_activeData);
    m_activeData = std::move(m_stagedAnimationData);

    juce::Logger::writeToLog("AnimationModule: New animator is now active.");

    // 4. Queue the OLD animator and OLD data for safe deletion.
    // We can't delete them immediately, as the audio thread might still be using them.
    {
        const juce::ScopedLock lock(m_freeingLock);
        if (oldAnimator)
        {
            m_animatorsToFree.push_back(std::unique_ptr<Animator>(oldAnimator));
            juce::Logger::writeToLog("AnimationModule: Old animator queued for safe deletion.");
        }
        if (oldDataToFree)
        {
            m_dataToFree.push_back(std::move(oldDataToFree));
            juce::Logger::writeToLog("AnimationModule: Old animation data queued for safe deletion.");
        }
    }
    
    // Reset UI state now that new data is active
    m_selectedBoneIndex = -1;
    m_selectedBoneName = "None";
    
    juce::Logger::writeToLog("AnimationModule: Animation atomically swapped and ready for audio thread!");
}

const std::vector<glm::mat4>& AnimationModuleProcessor::getFinalBoneMatrices() const
{
    // This is called from the UI/message thread to get bone matrices for rendering.
    // We use the same atomic pointer the audio thread uses - this is safe and lock-free!
    
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);

    if (currentAnimator != nullptr)
    {
        return currentAnimator->GetFinalBoneMatrices();
    }

    // If there's no animator, return a static empty vector to avoid crashes.
    static const std::vector<glm::mat4> empty;
    return empty;
}

#if defined(PRESET_CREATOR_UI)

// Helper function to project a 3D point to 2D screen space
static glm::vec2 worldToScreen(const glm::vec3& worldPos, const glm::mat4& viewMatrix, const glm::mat4& projectionMatrix, ImVec2 viewportPos, ImVec2 viewportSize)
{
    glm::vec4 clipSpacePos = projectionMatrix * viewMatrix * glm::vec4(worldPos, 1.0f);
    if (clipSpacePos.w == 0.0f) return {0,0};
    glm::vec3 ndcSpacePos = glm::vec3(clipSpacePos.x, clipSpacePos.y, clipSpacePos.z) / clipSpacePos.w;
    glm::vec2 screenPos;
    screenPos.x = (ndcSpacePos.x + 1.0f) / 2.0f * viewportSize.x + viewportPos.x;
    screenPos.y = (1.0f - ndcSpacePos.y) / 2.0f * viewportSize.y + viewportPos.y;
    return screenPos;
}

// Helper function for tooltip with help marker
static void HelpMarker(const char* desc)
{
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

void AnimationModuleProcessor::drawParametersInNode(float itemWidth,
                                                     const std::function<bool(const juce::String& paramId)>& isParamModulated,
                                                     const std::function<void()>& onModificationEnded)
{
    ImGui::PushItemWidth(itemWidth);
    
    // File loading section
    ImGui::TextWrapped("glTF File:");
    
    // Show loading status or loaded file info
    // Get current animator atomically (lock-free)
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    if (isCurrentlyLoading())
    {
        // Show a loading indicator while file is being loaded in the background
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Loading...");
        ImGui::SameLine();
        // Simple animated spinner
        static float spinnerAngle = 0.0f;
        spinnerAngle += ImGui::GetIO().DeltaTime * 10.0f;
        ImGui::Text("%.1f", spinnerAngle); // Simple animation placeholder
    }
    else if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "Loaded");
        ImGui::Text("Bones: %zu", animData->boneInfoMap.size());
        ImGui::Text("Clips: %zu", animData->animationClips.size());
    }
    else
    {
        ImGui::TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "No file loaded");
    }
    
    // Disable button while loading
    if (isCurrentlyLoading())
        ImGui::BeginDisabled();
    
    if (ImGui::Button("Load Animation File...", ImVec2(itemWidth, 0)))
    {
        // Use the new async loading method!
        // This will not block the UI - the file chooser and loading happen in the background
        openAnimationFile();
    }
    
    if (isCurrentlyLoading())
        ImGui::EndDisabled();
    
    
    // --- BONE SELECTION ---
    if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        if (!animData->boneInfoMap.empty())
        {
            if (ImGui::BeginCombo("Selected Bone", m_selectedBoneName.c_str()))
            {
                // Add a "None" option
                bool isNoneSelected = (m_selectedBoneIndex == -1);
                if (ImGui::Selectable("None", isNoneSelected))
                {
                    m_selectedBoneIndex = -1;
                    m_selectedBoneName = "None";
                    m_selectedBoneID = -1;
                }

                // Iterate through cached bone names (thread-safe)
                int currentIndex = 0;
                for (const auto& boneName : m_cachedBoneNames)
                {
                    bool isSelected = (m_selectedBoneName == boneName);

                    if (ImGui::Selectable(boneName.c_str(), isSelected))
                    {
                        m_selectedBoneName = boneName;
                        m_selectedBoneIndex = currentIndex;
                        
                        // Cache the bone ID to avoid map lookups every frame
                        if (animData->boneInfoMap.count(boneName))
                        {
                            m_selectedBoneID = animData->boneInfoMap.at(boneName).id;
                        }
                        else
                        {
                            m_selectedBoneID = -1;
                        }
                    }
                    if (isSelected)
                    {
                        ImGui::SetItemDefaultFocus();
                    }
                    currentIndex++;
                }
                ImGui::EndCombo();
            }
            
            // Add/Remove Bone Output Buttons (with Undo/Redo support)
            bool isSelected = (m_selectedBoneName != "None" && !m_selectedBoneName.empty());
            bool isAlreadyTracked = false;
            if (isSelected)
            {
                const juce::ScopedLock lock(m_trackedBonesLock);
                auto it = std::find_if(m_trackedBones.begin(), m_trackedBones.end(),
                                       [this](const TrackedBone& bone) { return bone.name == m_selectedBoneName; });
                isAlreadyTracked = (it != m_trackedBones.end());
            }

            // "Add Bone Output" button
            if (!isSelected || isAlreadyTracked) ImGui::BeginDisabled();
            if (ImGui::Button("Add Bone Output", ImVec2(itemWidth / 2 - 2, 0)))
            {
                addTrackedBone(m_selectedBoneName);
                onModificationEnded(); // Trigger undo/redo snapshot
            }
            if (!isSelected || isAlreadyTracked) ImGui::EndDisabled();

            ImGui::SameLine();

            // "Remove Bone Output" button
            if (!isSelected || !isAlreadyTracked) ImGui::BeginDisabled();
            if (ImGui::Button("Remove Bone Output", ImVec2(itemWidth / 2 - 2, 0)))
            {
                removeTrackedBone(m_selectedBoneName);
                onModificationEnded(); // Trigger undo/redo snapshot
            }
            if (!isSelected || !isAlreadyTracked) ImGui::EndDisabled();
        }
    }
    
    // Build Triggers Audio Quick-Connect Button (80s blue style)
    ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.15f, 0.6f, 0.85f, 0.8f));
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.25f, 0.7f, 0.95f, 0.95f));
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.35f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.0f));
    if (ImGui::Button("BUILD TRIGGERS AUDIO", ImVec2(itemWidth, 0)))
    {
        autoBuildTriggersAudioTriggered = true;
    }
    ImGui::PopStyleColor(4);
    HelpMarker("Auto-create samplers + mixer, wire triggers to pads.");
    
    
    // Animation playback controls
    if (currentAnimator != nullptr && currentAnimator->GetAnimationData() != nullptr)
    {
        auto* animData = currentAnimator->GetAnimationData();
        ImGui::Text("Animation Controls:");
        
        // List available clips
        if (!animData->animationClips.empty())
        {
            ImGui::Text("Available Clips:");
            for (size_t i = 0; i < animData->animationClips.size(); ++i)
            {
                const auto& clip = animData->animationClips[i];
                if (ImGui::Button(clip.name.c_str(), ImVec2(itemWidth, 0)))
                {
                    // Safe to call directly - the animator pointer is valid for this frame
                    currentAnimator->PlayAnimation(clip.name);
                }
            }
        }
        
        
        // Speed control
        static float speed = 1.0f;
        if (ImGui::SliderFloat("Speed", &speed, 0.1f, 3.0f, "%.2f"))
        {
            // Safe to call directly - the animator pointer is valid for this frame
            currentAnimator->SetAnimationSpeed(speed);
        }
        
        // DEBUG: Display basic info (accessing animator state directly is unsafe due to audio thread)
        ImGui::Separator();
        ImGui::Text("Debug Info:");
        ImGui::Text("Bones: %d", (int)animData->boneInfoMap.size());
        ImGui::Text("Clips: %d", (int)animData->animationClips.size());
        ImGui::Separator();
        
        
        // --- RENDERING VIEWPORT ---
        
        ImGui::Text("Animation Viewport:");
        
        // Camera controls
        ImGui::SliderFloat("Zoom", &m_zoom, 1.0f, 50.0f, "%.1f");
        ImGui::SliderFloat("Pan X", &m_panX, -20.0f, 20.0f, "%.1f");
        ImGui::SliderFloat("Pan Y", &m_panY, -20.0f, 20.0f, "%.1f");
        
        // View rotation controls
        ImGui::Text("View Rotation:");
        ImGui::PushItemWidth(itemWidth / 3.0f - 5.0f); // Adjust width for 3 buttons side-by-side
        if (ImGui::Button("Rot X")) { m_viewRotationX += glm::radians(90.0f); }
        ImGui::SameLine();
        if (ImGui::Button("Rot Y")) { m_viewRotationY += glm::radians(90.0f); }
        ImGui::SameLine();
        if (ImGui::Button("Rot Z")) { m_viewRotationZ += glm::radians(90.0f); }
        ImGui::PopItemWidth();

        // Reset view button - resets rotation and frames the animation
        if (ImGui::Button("Reset View", ImVec2(itemWidth, 0)))
        {
            m_viewRotationX = 0.0f;
            m_viewRotationY = 0.0f;
            m_viewRotationZ = 0.0f;
            if (currentAnimator != nullptr)
            {
                glm::vec2 newPan;
                m_Renderer->frameView(currentAnimator->GetBoneWorldTransforms(), m_zoom, newPan);
                m_panX = newPan.x;
                m_panY = newPan.y;
            }
        }
        
        
        // === GROUND PLANE CONTROLS (FIXED) ===
        ImGui::Separator();
        ImGui::Text("Ground Planes:");

        // --- Step 1: Calculate the animation's current Y-bounds for a sensible slider range ---
        float sliderMin = -5.0f;
        float sliderMax = 5.0f;
        if (currentAnimator && !currentAnimator->GetBoneWorldTransforms().empty())
        {
            const auto& worldTransforms = currentAnimator->GetBoneWorldTransforms();
            float minY = 0.0f, maxY = 0.0f;
            bool boundsInitialized = false;
            for (const auto& matrix : worldTransforms)
            {
                glm::vec3 pos = matrix[3];
                if (glm::length(pos) < 0.001f) continue; // Ignore bones at origin

                if (!boundsInitialized) {
                    minY = maxY = pos.y;
                    boundsInitialized = true;
                } else {
                    minY = std::min(minY, pos.y);
                    maxY = std::max(maxY, pos.y);
                }
            }

            // Add padding to the range to allow placing planes above/below the animation
            if (boundsInitialized)
            {
                const float yRange = maxY - minY;
                const float padding = (yRange > 0.01f) ? yRange * 0.5f : 2.0f;
                sliderMin = minY - padding;
                sliderMax = maxY + padding;
            }
        }
        
        // Add/Remove Buttons
        if (ImGui::Button("Add Ground Plane", ImVec2(itemWidth / 2 - 2, 0)))
        {
            addGroundPlane(0.0f, 0.0f); // Default: line at world origin
            onModificationEnded(); 
        }
        ImGui::SameLine();
        bool canRemove = false;
        {
            const juce::ScopedLock lock(m_groundPlanesLock);
            canRemove = m_groundPlanes.size() > 1;
        }
        if (!canRemove) ImGui::BeginDisabled();
        if (ImGui::Button("Remove Ground Plane", ImVec2(itemWidth / 2 - 2, 0)))
        {
            removeGroundPlane();
            onModificationEnded();
        }
        if (!canRemove) ImGui::EndDisabled();

        // Colored Sliders for each ground plane
        {
            const juce::ScopedLock lock(m_groundPlanesLock);
            for (int i = 0; i < (int)m_groundPlanes.size(); ++i)
            {
                ImGui::PushID(i);
                float hue = fmodf((float)i * 0.2f, 1.0f);
                ImGui::PushStyleColor(ImGuiCol_FrameBg, (ImVec4)ImColor::HSV(hue, 0.5f, 0.5f));
                ImGui::PushStyleColor(ImGuiCol_FrameBgHovered, (ImVec4)ImColor::HSV(hue, 0.6f, 0.6f));
                ImGui::PushStyleColor(ImGuiCol_FrameBgActive, (ImVec4)ImColor::HSV(hue, 0.7f, 0.7f));
                ImGui::PushStyleColor(ImGuiCol_SliderGrab, (ImVec4)ImColor::HSV(hue, 0.9f, 0.9f));

                // Slider for Y position (center line)
                ImGui::SliderFloat("Ground Y", &m_groundPlanes[i].y, sliderMin, sliderMax, "%.2f");
                if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();

                // Slider for Depth (monitoring zone size)
                ImGui::SliderFloat("Depth", &m_groundPlanes[i].depth, 0.0f, 2.0f, "%.2f");
                if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();

                ImGui::PopStyleColor(4);
                ImGui::PopID();
            }
        }
        ImGui::Separator();
        
        
        // Pass the latest values to the renderer before drawing
        m_Renderer->setZoom(m_zoom);
        m_Renderer->setPan({m_panX, m_panY});
        m_Renderer->setViewRotation({m_viewRotationX, m_viewRotationY, m_viewRotationZ});
        
        // Define the size of our viewport
        const ImVec2 viewportSize(400, 400);
        
        // Setup the renderer (it will only run once internally)
        m_Renderer->setup(static_cast<int>(viewportSize.x), static_cast<int>(viewportSize.y));
        
        // Get world transforms for visualization (NOT skinning matrices!)
        const auto& worldTransforms = currentAnimator->GetBoneWorldTransforms();

        // --- NEW: Build the edge list for drawing lines between bones ---
        m_boneEdges.clear();
        if (currentAnimator->GetAnimationData())
        {
            const auto* animData = currentAnimator->GetAnimationData();
            buildEdgeListRecursive(animData->rootNode, worldTransforms, animData->boneInfoMap, m_boneEdges);
        }
        
        // --- DEBUG: Log bone positions to diagnose rendering issues ---
        static int debugFrameCounter = 0;
        if (++debugFrameCounter % 60 == 0 && !worldTransforms.empty()) // Log once per second at 60fps
        {
            juce::Logger::writeToLog("=== Animation Frame Debug ===");
            juce::Logger::writeToLog("Total bones: " + juce::String(worldTransforms.size()));
            
            // Log the first 3 bone positions to see if they're all at origin or varying
            for (size_t i = 0; i < std::min(size_t(3), worldTransforms.size()); ++i)
            {
                glm::vec3 pos = worldTransforms[i][3];
                juce::Logger::writeToLog("Bone[" + juce::String(i) + "] Position: (" + 
                    juce::String(pos.x, 2) + ", " + 
                    juce::String(pos.y, 2) + ", " + 
                    juce::String(pos.z, 2) + ")");
            }
        }
        
        // --- BONE COLOR, KINEMATIC, AND HIT-DETECTION LOGIC (MOVED BEFORE RENDER) ---
        const int numBones = worldTransforms.size();
        m_boneColors.assign(numBones, glm::vec3(1.0f, 1.0f, 1.0f)); // Default all to white

        const float deltaTime = ImGui::GetIO().DeltaTime;
        auto groundPlanesToDraw = getGroundPlanes();
        
        // Recreate matrices for hit detection and velocity
        glm::mat4 projection = glm::ortho(-m_zoom + m_panX, m_zoom + m_panX, -m_zoom + m_panY, m_zoom + m_panY, -10.0f, 10.0f);
        glm::mat4 view = glm::mat4(1.0f);
        view = glm::rotate(view, m_viewRotationX, glm::vec3(1.0f, 0.0f, 0.0f));
        view = glm::rotate(view, m_viewRotationY, glm::vec3(0.0f, 1.0f, 0.0f));
        view = glm::rotate(view, m_viewRotationZ, glm::vec3(0.0f, 0.0f, 1.0f));
        
        const juce::ScopedLock lock(m_trackedBonesLock);

        // First, set the base green color for all currently tracked bones
        for (const auto& bone : m_trackedBones) {
            if (bone.boneId != -1 && bone.boneId < numBones) {
                m_boneColors[bone.boneId] = glm::vec3(0.0f, 1.0f, 0.0f); // Green
            }
        }

        // Now iterate again to handle hits, timers, and velocity
        for (auto& bone : m_trackedBones)
        {
            // Update this bone's flash timer
            bone.hitFlashTimer = std::max(0.0f, bone.hitFlashTimer - deltaTime);

            if (bone.boneId != -1 && bone.boneId < numBones)
            {
                // Ensure the state vector is the correct size
                if (bone.wasAboveCenter.size() != groundPlanesToDraw.size()) {
                    bone.wasAboveCenter.assign(groundPlanesToDraw.size(), false);
                }

                glm::mat4 worldMatrix = worldTransforms[bone.boneId];
                glm::vec3 worldPos = worldMatrix[3];

                // Per-plane world-space hit detection
                for (int i = 0; i < (int)groundPlanesToDraw.size(); ++i) {
                    const auto& plane = groundPlanesToDraw[i];
                    float centerY = plane.y;
                    float topY = plane.y + plane.depth / 2.0f;
                    float bottomY = plane.y - plane.depth / 2.0f;
                    bool isCurrentlyInsideZone = (worldPos.y >= bottomY && worldPos.y <= topY);
                    
                    // Fire only if we are inside the zone AND we just crossed the center line downwards
                    if (isCurrentlyInsideZone && bone.wasAboveCenter[i] && worldPos.y <= centerY) {
                        bone.triggerState.store(true);
                        bone.hitFlashTimer = 0.5f;
                    }
                    bone.wasAboveCenter[i] = (worldPos.y > centerY);
                }

                // Velocity calculation
                ImVec2 viewportPos = ImGui::GetItemRectMin();
                glm::vec2 currentScreenPos = worldToScreen(worldPos, view, projection, viewportPos, viewportSize);
                if (bone.isFirstFrame) {
                    bone.lastScreenPos = currentScreenPos;
                    bone.isFirstFrame = false;
                }
                glm::vec2 velocity(0.0f);
                if (deltaTime > 0.0f) {
                    velocity = (currentScreenPos - bone.lastScreenPos) / deltaTime;
                }
                bone.lastScreenPos = currentScreenPos;
                bone.velX.store(velocity.x);
                bone.velY.store(velocity.y);
            } else {
                bone.wasAboveCenter.clear();
                bone.isFirstFrame = true;
                bone.hitFlashTimer = 0.0f;
            }

            // After all updates, set the final color for this bone
            if (bone.boneId != -1 && bone.boneId < numBones) {
                if (bone.hitFlashTimer > 0.0f) {
                    m_boneColors[bone.boneId] = glm::vec3(1.0f, 0.0f, 0.0f); // Red flash
                }
            }
        }

        // FIX: Call render AFTER calculating colors and pass the color AND edge data
        m_Renderer->render(worldTransforms, m_boneColors, m_boneEdges);
        
        // Display the texture from the FBO (flipped vertically)
        ImGui::Image((void*)(intptr_t)m_Renderer->getTextureID(), viewportSize, ImVec2(0, 1), ImVec2(1, 0));

        // --- DRAW GROUND ZONES WITH CENTER LINES ---
        ImDrawList* drawList = ImGui::GetWindowDrawList();
        ImVec2 p1 = ImGui::GetItemRectMin();
        ImVec2 p2 = ImGui::GetItemRectMax();
        
        for (int i = 0; i < (int)groundPlanesToDraw.size(); ++i)
        {
            const auto& plane = groundPlanesToDraw[i];
            float topY = plane.y + plane.depth / 2.0f;
            float bottomY = plane.y - plane.depth / 2.0f;
            
            glm::vec2 screenTop = worldToScreen({0.0f, topY, 0.0f}, view, projection, p1, viewportSize);
            glm::vec2 screenBottom = worldToScreen({0.0f, bottomY, 0.0f}, view, projection, p1, viewportSize);
            glm::vec2 screenCenter = worldToScreen({0.0f, plane.y, 0.0f}, view, projection, p1, viewportSize);

            float hue = fmodf((float)i * 0.2f, 1.0f);
            ImVec4 colorVec = (ImVec4)ImColor::HSV(hue, 0.9f, 0.9f);
            ImU32 color = IM_COL32((int)(colorVec.x * 255), (int)(colorVec.y * 255), (int)(colorVec.z * 255), 255);
            ImU32 fillColor = IM_COL32((int)(colorVec.x * 255), (int)(colorVec.y * 255), (int)(colorVec.z * 255), 50);

            if (plane.depth > 0.001f) {
                drawList->AddRectFilled(ImVec2(p1.x, screenTop.y), ImVec2(p2.x, screenBottom.y), fillColor);
                drawList->AddLine(ImVec2(p1.x, screenCenter.y), ImVec2(p2.x, screenCenter.y), color, 1.5f);
            } else {
                drawList->AddLine(ImVec2(p1.x, screenCenter.y), ImVec2(p2.x, screenCenter.y), color, 2.0f);
            }
        }
    }
    else
    {
        // Show a placeholder when no animation is loaded to maintain consistent node size
        ImGui::TextDisabled("Load an animation file to see animation");
        ImGui::Dummy(ImVec2(400, 400)); // Reserve space for the viewport
    }
    
    ImGui::PopItemWidth();
}
#endif

bool AnimationModuleProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const
{
    // Support up to our max channels (10 bones * 3 outputs), and no inputs.
    const int maxChannels = 30; // Max 10 bones
    return layouts.getMainOutputChannelSet().size() <= maxChannels
           && layouts.getMainInputChannelSet() == juce::AudioChannelSet::disabled();
}

std::vector<DynamicPinInfo> AnimationModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    const juce::ScopedLock lock(m_trackedBonesLock);
    
    // The loop now starts correctly at channel 0
    for (int i = 0; i < m_trackedBones.size(); ++i)
    {
        const auto& bone = m_trackedBones[i];
        int baseChannel = i * 3; // Correct base channel
        
        pins.push_back({ juce::String(bone.name) + " Vel X", baseChannel + 0, PinDataType::CV });
        pins.push_back({ juce::String(bone.name) + " Vel Y", baseChannel + 1, PinDataType::CV });
        pins.push_back({ juce::String(bone.name) + " Hit",   baseChannel + 2, PinDataType::Gate });
    }
    
    return pins;
}

// === State Management (for saving/loading presets) ===

juce::ValueTree AnimationModuleProcessor::getExtraStateTree() const
{
    // This function is called by the synth when saving a preset.
    // We create a ValueTree to hold our module's unique state.
    juce::ValueTree state("AnimationModuleState");

    // 1. Save the absolute path of the currently loaded animation file.
    state.setProperty("animationFilePath", m_fileLoader.getLoadedFilePath(), nullptr);

    // 2. Save the viewport/camera settings.
    state.setProperty("zoom", m_zoom, nullptr);
    state.setProperty("panX", m_panX, nullptr);
    state.setProperty("panY", m_panY, nullptr);
    state.setProperty("viewRotationX", m_viewRotationX, nullptr);
    state.setProperty("viewRotationY", m_viewRotationY, nullptr);
    state.setProperty("viewRotationZ", m_viewRotationZ, nullptr);

    // Save the name of the currently playing animation clip
    juce::String currentClipName;
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    if (currentAnimator != nullptr && currentAnimator->GetCurrentAnimation() != nullptr)
    {
        currentClipName = currentAnimator->GetCurrentAnimation()->name;
    }
    state.setProperty("animationClipName", currentClipName, nullptr);

    // 3. Save the list of ground planes
    juce::ValueTree groundPlanesNode("GroundPlanes");
    {
        const juce::ScopedLock lock(m_groundPlanesLock);
        for (const auto& plane : m_groundPlanes)
        {
            juce::ValueTree planeNode("Plane");
            planeNode.setProperty("y", plane.y, nullptr);
            planeNode.setProperty("depth", plane.depth, nullptr);
            groundPlanesNode.addChild(planeNode, -1, nullptr);
        }
    }
    state.addChild(groundPlanesNode, -1, nullptr);

    // 4. Save the list of tracked bones (preserves insertion order)
    juce::ValueTree trackedBonesNode("TrackedBones");
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        for (const auto& bone : m_trackedBones)
        {
            juce::ValueTree boneNode("Bone");
            boneNode.setProperty("name", juce::String(bone.name), nullptr);
            trackedBonesNode.addChild(boneNode, -1, nullptr);
        }
    }
    state.addChild(trackedBonesNode, -1, nullptr);

    // 5. Save the name of the currently selected bone.
    state.setProperty("selectedBoneName", juce::String(m_selectedBoneName), nullptr);

    juce::Logger::writeToLog("[AnimationModule] Saving state: file='" + 
                              m_fileLoader.getLoadedFilePath() + 
                              "', bone='" + juce::String(m_selectedBoneName) + "'");
    
    return state;
}

void AnimationModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    // This function is called by the synth when loading a preset.
    // We restore our state from the provided ValueTree.
    
    if (!state.hasType("AnimationModuleState"))
        return;

    juce::Logger::writeToLog("[AnimationModule] Loading state from preset...");

    // === CRITICAL: ORDER OF OPERATIONS FOR PRESET LOADING ===
    // We must load the animation file FIRST so that bone names can be matched to IDs afterward.
    
    // 1. Restore the viewport/camera settings.
    m_zoom = state.getProperty("zoom", 10.0f);
    m_panX = state.getProperty("panX", 0.0f);
    m_panY = state.getProperty("panY", 0.0f);
    m_viewRotationX = state.getProperty("viewRotationX", 0.0f);
    m_viewRotationY = state.getProperty("viewRotationY", 0.0f);
    m_viewRotationZ = state.getProperty("viewRotationZ", 0.0f);

    // 2. Restore the selected bone name (for UI dropdown).
    m_selectedBoneName = state.getProperty("selectedBoneName", "None").toString().toStdString();

    // Restore the name of the animation clip to be played after the file loads.
    m_clipToPlayOnLoad = state.getProperty("animationClipName", "").toString();

    // 3. IMPORTANT: Load the animation file BEFORE restoring tracked bones.
    juce::String filePath = state.getProperty("animationFilePath", "").toString();
    
    if (filePath.isNotEmpty())
    {
        juce::File fileToLoad(filePath);
        
        if (fileToLoad.existsAsFile())
        {
            juce::Logger::writeToLog("[AnimationModule] Restoring animation from preset: " + fileToLoad.getFullPathName());
            m_fileLoader.startLoadingFile(fileToLoad);
            // Note: This is async, but setupAnimationFromRawData is now non-destructive, so the
            // tracked bones we restore next won't be cleared.
        }
        else
        {
            juce::Logger::writeToLog("[AnimationModule] Warning: Animation file not found at: " + filePath);
        }
    }
    else
    {
        juce::Logger::writeToLog("[AnimationModule] No animation file path in preset.");
    }

    // 4. Restore the list of tracked bones from the preset (preserves saved order).
    // This happens AFTER we've started loading the file (which is async).
    // Since setupAnimationFromRawData is now non-destructive, it won't clear this list.
    if (auto trackedBonesNode = state.getChildWithName("TrackedBones"); trackedBonesNode.isValid())
    {
        const juce::ScopedLock lock(m_trackedBonesLock);
        m_trackedBones.clear(); // Clear the current list
        for (const auto& boneNode : trackedBonesNode)
        {
            if (boneNode.hasType("Bone"))
            {
                juce::String boneName = boneNode.getProperty("name").toString();
                if (boneName.isNotEmpty())
                {
                    TrackedBone newBone;
                    newBone.name = boneName.toStdString();
                    m_trackedBones.push_back(newBone); // Preserves order!
                    juce::Logger::writeToLog("[AnimationModule] Restored tracked bone: " + boneName);
                }
            }
        }
    }

    // 5. Restore the list of ground planes.
    if (auto groundPlanesNode = state.getChildWithName("GroundPlanes"); groundPlanesNode.isValid())
    {
        const juce::ScopedLock lock(m_groundPlanesLock);
        m_groundPlanes.clear();
        for (const auto& planeNode : groundPlanesNode)
        {
            if (planeNode.hasType("Plane"))
            {
                // Read both y and depth, providing a default of 0.0 for depth for old presets.
                m_groundPlanes.push_back({ (float)planeNode.getProperty("y", 0.0f), (float)planeNode.getProperty("depth", 0.0f) });
            }
        }
        // Fallback: if loading results in no ground planes, add one as a safety
        if (m_groundPlanes.empty())
        {
            m_groundPlanes.push_back({0.0f, 0.0f});
        }
    }
    else
    {
        // Legacy support: try to load single groundY value (depth will be 0)
        float legacyGroundY = state.getProperty("groundY", 0.0f);
        const juce::ScopedLock lock(m_groundPlanesLock);
        m_groundPlanes.clear();
        m_groundPlanes.push_back({legacyGroundY, 0.0f});
    }
    
    juce::Logger::writeToLog("[AnimationModule] Preset loading complete.");
}

std::optional<RhythmInfo> AnimationModuleProcessor::getRhythmInfo() const
{
    // Load animator atomically (thread-safe)
    Animator* currentAnimator = m_activeAnimator.load(std::memory_order_acquire);
    
    if (!currentAnimator || !currentAnimator->GetCurrentAnimation())
        return std::nullopt; // No animation loaded or playing
    
    RhythmInfo info;
    info.displayName = "Animation #" + juce::String(getLogicalId());
    info.sourceType = "animation";
    info.isActive = true; // Animation is playing if we got here
    info.isSynced = false; // Animations are always free-running
    
    // Calculate BPM from animation clip duration
    const auto* currentClip = currentAnimator->GetCurrentAnimation();
    if (currentClip && currentClip->durationInTicks > 0.0 && currentClip->ticksPerSecond > 0.0)
    {
        // Calculate duration in seconds
        const double durationSeconds = currentClip->durationInTicks / currentClip->ticksPerSecond;
        
        // One loop = one "beat" in BPM terms
        // Note: This is the base BPM without considering animation speed modifier
        info.bpm = static_cast<float>(60.0 / durationSeconds);
    }
    else
    {
        info.bpm = 0.0f;
    }
    
    return info;
}



================================================================================
FILE: juce\Source\audio\modules\BPMMonitorModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include "TapTempo.h"
#include <vector>
#include <array>

/**
 * BPM Monitor Node - Hybrid Smart System
 * 
 * This node automatically detects and reports BPM from rhythm-producing modules
 * using two complementary approaches:
 * 
 * 1. INTROSPECTION (Fast Path): Directly queries modules that implement getRhythmInfo()
 *    - Instant, accurate BPM reporting
 *    - Works with sequencers, animations, etc.
 * 
 * 2. BEAT DETECTION (Universal Fallback): Analyzes audio inputs for beat patterns
 *    - Tap tempo algorithm with rolling average
 *    - Works with any rhythmic signal (including external audio/VSTs)
 * 
 * The node dynamically generates output pins for each detected rhythm source:
 * - [Name] BPM (Raw) - Absolute BPM value
 * - [Name] CV - Normalized 0-1 for modulation
 * - [Name] Active/Confidence - Gate or confidence level
 * 
 * This node is always present (like the output node) and undeletable.
 */
class BPMMonitorModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_DETECTION_INPUTS = 16;  // Max beat detection inputs
    
    /**
     * Operation modes for the BPM Monitor
     */
    enum class OperationMode
    {
        Auto = 0,           // Use both introspection + beat detection
        IntrospectionOnly,  // Only scan modules with getRhythmInfo()
        DetectionOnly       // Only analyze audio inputs
    };
    
    BPMMonitorModuleProcessor();
    ~BPMMonitorModuleProcessor() override = default;

    // === JUCE AudioProcessor Interface ===
    const juce::String getName() const override { return "BPM Monitor"; }
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    // === Dynamic Pin Interface ===
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;
    std::vector<DynamicPinInfo> getDynamicInputPins() const override;
    
    // === Pin Labels ===
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
    
#if defined(PRESET_CREATOR_UI)
    // === UI Drawing ===
    void drawParametersInNode(float itemWidth, 
                             const std::function<bool(const juce::String&)>& isParamModulated,
                             const std::function<void()>& onModificationEnded) override;
#endif

private:
    // === Parameter Layout ===
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    double m_sampleRate = 44100.0;
    
    // === INTROSPECTION ENGINE ===
    
    /**
     * Cached information about a rhythm source discovered via introspection
     */
    struct IntrospectedSource {
        juce::String name;      // Display name (e.g., "Sequencer #3")
        juce::String type;      // Source type (e.g., "sequencer", "animation")
        float bpm;              // Current BPM
        bool isActive;          // Is currently running?
        bool isSynced;          // Synced to global transport?
    };
    
    std::vector<IntrospectedSource> m_introspectedSources;
    
    /**
     * Scan the parent graph for modules with getRhythmInfo()
     * Updates m_introspectedSources
     */
    void scanGraphForRhythmSources();
    
    // === BEAT DETECTION ENGINE ===
    
    std::array<TapTempo, MAX_DETECTION_INPUTS> m_tapAnalyzers;
    std::vector<DetectedRhythmSource> m_detectedSources;
    
    /**
     * Process beat detection on all active input channels
     * Updates m_detectedSources
     */
    void processDetection(const juce::AudioBuffer<float>& buffer);
    
    // === OUTPUT MANAGEMENT ===
    
    /**
     * Normalize BPM to 0-1 range for CV output
     */
    float normalizeBPM(float bpm, float minBPM, float maxBPM) const;
};



================================================================================
FILE: juce\Source\audio\modules\BPMMonitorModuleProcessor.cpp
================================================================================


#include "BPMMonitorModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"

juce::AudioProcessorValueTreeState::ParameterLayout BPMMonitorModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    
    // Operation mode selector
    params.push_back(std::make_unique<juce::AudioParameterChoice>("mode", "Mode",
        juce::StringArray{"Auto", "Introspection Only", "Detection Only"}, 0));
    
    // BPM normalization range for CV outputs
    params.push_back(std::make_unique<juce::AudioParameterFloat>("minBPM", "Min BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 60.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("maxBPM", "Max BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 240.0f));
    
    // Beat detection settings
    params.push_back(std::make_unique<juce::AudioParameterFloat>("sensitivity", "Detection Sensitivity", 
        juce::NormalisableRange<float>(0.0f, 1.0f, 0.01f), 0.5f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("detMinBPM", "Det Min BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 30.0f));
    params.push_back(std::make_unique<juce::AudioParameterFloat>("detMaxBPM", "Det Max BPM", 
        juce::NormalisableRange<float>(20.0f, 300.0f, 1.0f), 300.0f));
    
    // Number of active detection inputs (0-16)
    params.push_back(std::make_unique<juce::AudioParameterInt>("numInputs", "Num Detection Inputs", 
        0, MAX_DETECTION_INPUTS, 4));
    
    return { params.begin(), params.end() };
}

BPMMonitorModuleProcessor::BPMMonitorModuleProcessor()
    : ModuleProcessor(BusesProperties()
                        .withInput("Detection Inputs", juce::AudioChannelSet::discreteChannels(MAX_DETECTION_INPUTS), true)
                        .withOutput("Outputs", juce::AudioChannelSet::discreteChannels(96), true)), // Max 32 sources * 3 outputs each
      apvts(*this, nullptr, "BPMMonitorParams", createParameterLayout())
{
    // Initialize output telemetry for tooltips
    for (int i = 0; i < 96; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

void BPMMonitorModuleProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    juce::ignoreUnused(samplesPerBlock);
    m_sampleRate = sampleRate;
    
    // Reset all tap tempo analyzers
    for (auto& analyzer : m_tapAnalyzers)
        analyzer.reset();
}

void BPMMonitorModuleProcessor::scanGraphForRhythmSources()
{
    m_introspectedSources.clear();
    
    // Get parent synth
    auto* synth = getParent();
    if (!synth)
        return;
    
    // Iterate through all modules in the graph
    auto modules = synth->getModulesInfo();
    for (const auto& [logicalId, moduleType] : modules)
    {
        // Skip ourselves
        if (logicalId == getLogicalId())
            continue;
        
        // Get the module processor
        auto* module = synth->getModuleForLogical(logicalId);
        if (!module)
            continue;
        
        // Query for rhythm info
        auto rhythmInfo = module->getRhythmInfo();
        if (rhythmInfo.has_value())
        {
            IntrospectedSource source;
            source.name = rhythmInfo->displayName;
            source.type = rhythmInfo->sourceType;
            source.bpm = rhythmInfo->bpm;
            source.isActive = rhythmInfo->isActive;
            source.isSynced = rhythmInfo->isSynced;
            m_introspectedSources.push_back(source);
        }
    }
}

void BPMMonitorModuleProcessor::processDetection(const juce::AudioBuffer<float>& buffer)
{
    m_detectedSources.clear();
    
    const int numInputs = apvts.getRawParameterValue("numInputs")->load();
    const float sensitivity = apvts.getRawParameterValue("sensitivity")->load();
    const float detMinBPM = apvts.getRawParameterValue("detMinBPM")->load();
    const float detMaxBPM = apvts.getRawParameterValue("detMaxBPM")->load();
    
    const int numSamples = buffer.getNumSamples();
    const int numChannels = buffer.getNumChannels();
    
    // Process each active detection input
    for (int ch = 0; ch < std::min(numInputs, MAX_DETECTION_INPUTS); ++ch)
    {
        if (ch >= numChannels)
            break;
        
        // Configure analyzer for this channel
        auto& analyzer = m_tapAnalyzers[ch];
        analyzer.setSensitivity(sensitivity);
        analyzer.setMinBPM(detMinBPM);
        analyzer.setMaxBPM(detMaxBPM);
        
        // Process all samples in this block
        const float* inputData = buffer.getReadPointer(ch);
        for (int i = 0; i < numSamples; ++i)
            analyzer.processSample(inputData[i], m_sampleRate);
        
        // If analyzer is active (stable detection), add to detected sources
        if (analyzer.isActive())
        {
            DetectedRhythmSource source;
            source.name = "Input " + juce::String(ch + 1) + " (Detected)";
            source.inputChannel = ch;
            source.detectedBPM = analyzer.getBPM();
            source.confidence = analyzer.getConfidence();
            source.isActive = true;
            m_detectedSources.push_back(source);
        }
    }
}

float BPMMonitorModuleProcessor::normalizeBPM(float bpm, float minBPM, float maxBPM) const
{
    return juce::jmap(bpm, minBPM, maxBPM, 0.0f, 1.0f);
}

void BPMMonitorModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Read parameters
    const int mode = apvts.getRawParameterValue("mode")->load();
    const float minBPM = apvts.getRawParameterValue("minBPM")->load();
    const float maxBPM = apvts.getRawParameterValue("maxBPM")->load();
    
    // === INTROSPECTION ENGINE ===
    if (mode == (int)OperationMode::Auto || mode == (int)OperationMode::IntrospectionOnly)
        scanGraphForRhythmSources();
    else
        m_introspectedSources.clear();
    
    // === BEAT DETECTION ENGINE ===
    if (mode == (int)OperationMode::Auto || mode == (int)OperationMode::DetectionOnly)
        processDetection(buffer);
    else
        m_detectedSources.clear();
    
    // === OUTPUT GENERATION ===
    buffer.clear();
    
    int channelIndex = 0;
    const int numSamples = buffer.getNumSamples();
    
    // Introspected sources first (fast, accurate)
    for (const auto& source : m_introspectedSources)
    {
        if (channelIndex + 2 >= buffer.getNumChannels())
            break;
        
        // Channel 0: BPM Raw (absolute value)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.bpm, numSamples);
        
        // Channel 1: BPM CV (normalized 0-1)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         normalizeBPM(source.bpm, minBPM, maxBPM), numSamples);
        
        // Channel 2: Active gate (0.0 or 1.0)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.isActive ? 1.0f : 0.0f, numSamples);
    }
    
    // Detected sources next (universal fallback)
    for (const auto& source : m_detectedSources)
    {
        if (channelIndex + 2 >= buffer.getNumChannels())
            break;
        
        // Channel 0: Detected BPM Raw
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.detectedBPM, numSamples);
        
        // Channel 1: Detected BPM CV (normalized)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         normalizeBPM(source.detectedBPM, minBPM, maxBPM), numSamples);
        
        // Channel 2: Confidence level (0-1)
        juce::FloatVectorOperations::fill(buffer.getWritePointer(channelIndex++), 
                                         source.confidence, numSamples);
    }
    
    // Update output telemetry for tooltips
    updateOutputTelemetry(buffer);
}

std::vector<DynamicPinInfo> BPMMonitorModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    // Introspected sources
    for (const auto& source : m_introspectedSources)
    {
        const int baseChannel = (int)pins.size();
        pins.push_back({ source.name + " BPM", baseChannel, PinDataType::Raw });
        pins.push_back({ source.name + " CV", baseChannel + 1, PinDataType::CV });
        pins.push_back({ source.name + " Active", baseChannel + 2, PinDataType::Gate });
    }
    
    // Detected sources
    for (const auto& source : m_detectedSources)
    {
        const int baseChannel = (int)pins.size();
        pins.push_back({ source.name + " BPM", baseChannel, PinDataType::Raw });
        pins.push_back({ source.name + " CV", baseChannel + 1, PinDataType::CV });
        pins.push_back({ source.name + " Confidence", baseChannel + 2, PinDataType::CV });
    }
    
    return pins;
}

std::vector<DynamicPinInfo> BPMMonitorModuleProcessor::getDynamicInputPins() const
{
    std::vector<DynamicPinInfo> pins;
    
    const int numInputs = apvts.getRawParameterValue("numInputs")->load();
    for (int i = 0; i < numInputs; ++i)
    {
        pins.push_back({ "Detect In " + juce::String(i + 1), i, PinDataType::Gate });
    }
    
    return pins;
}

juce::String BPMMonitorModuleProcessor::getAudioInputLabel(int channel) const
{
    return "Detect In " + juce::String(channel + 1);
}

juce::String BPMMonitorModuleProcessor::getAudioOutputLabel(int channel) const
{
    // Outputs are dynamic - use getDynamicOutputPins() for proper names
    return "Out " + juce::String(channel + 1);
}

#if defined(PRESET_CREATOR_UI)
void BPMMonitorModuleProcessor::drawParametersInNode(float itemWidth, 
                                                      const std::function<bool(const juce::String&)>& isParamModulated,
                                                      const std::function<void()>& onModificationEnded)
{
    juce::ignoreUnused(isParamModulated);
    
    ImGui::PushItemWidth(itemWidth);
    
    ImGui::TextColored(ImVec4(0.3f, 0.8f, 1.0f, 1.0f), "BPM MONITOR");
    ImGui::Separator();
    
    // Mode selector
    int mode = apvts.getRawParameterValue("mode")->load();
    if (ImGui::Combo("Mode", &mode, "Auto\0Introspection Only\0Detection Only\0\0"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("mode")))
        {
            *p = mode;
            onModificationEnded();
        }
    }
    
    // BPM Normalization Range
    ImGui::Separator();
    ImGui::Text("CV Normalization Range:");
    
    float minBPM = apvts.getRawParameterValue("minBPM")->load();
    if (ImGui::SliderFloat("Min BPM", &minBPM, 20.0f, 300.0f, "%.0f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("minBPM")))
            *p = minBPM;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    
    float maxBPM = apvts.getRawParameterValue("maxBPM")->load();
    if (ImGui::SliderFloat("Max BPM", &maxBPM, 20.0f, 300.0f, "%.0f"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("maxBPM")))
            *p = maxBPM;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    
    // Beat Detection Settings (only show if detection is enabled)
    if (mode == (int)OperationMode::Auto || mode == (int)OperationMode::DetectionOnly)
    {
        ImGui::Separator();
        ImGui::Text("Beat Detection Settings:");
        
        int numInputs = apvts.getRawParameterValue("numInputs")->load();
        if (ImGui::SliderInt("Detection Inputs", &numInputs, 0, MAX_DETECTION_INPUTS))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numInputs")))
                *p = numInputs;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        
        float sensitivity = apvts.getRawParameterValue("sensitivity")->load();
        if (ImGui::SliderFloat("Sensitivity", &sensitivity, 0.0f, 1.0f, "%.2f"))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("sensitivity")))
                *p = sensitivity;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        
        float detMinBPM = apvts.getRawParameterValue("detMinBPM")->load();
        if (ImGui::SliderFloat("Det Min BPM", &detMinBPM, 20.0f, 300.0f, "%.0f"))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("detMinBPM")))
                *p = detMinBPM;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        
        float detMaxBPM = apvts.getRawParameterValue("detMaxBPM")->load();
        if (ImGui::SliderFloat("Det Max BPM", &detMaxBPM, 20.0f, 300.0f, "%.0f"))
        {
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("detMaxBPM")))
                *p = detMaxBPM;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    }
    
    // Display detected rhythm sources
    ImGui::Separator();
    ImGui::Text("Detected Rhythm Sources:");
    
    if (m_introspectedSources.empty() && m_detectedSources.empty())
    {
        ImGui::TextDisabled("  None");
    }
    else
    {
        // Introspected sources
        if (!m_introspectedSources.empty())
        {
            ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Introspected:");
            for (const auto& source : m_introspectedSources)
            {
                ImGui::BulletText("%s: %.1f BPM %s", 
                                 source.name.toRawUTF8(), 
                                 source.bpm,
                                 source.isActive ? "[ACTIVE]" : "[STOPPED]");
            }
        }
        
        // Detected sources
        if (!m_detectedSources.empty())
        {
            ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.3f, 1.0f), "Detected:");
            for (const auto& source : m_detectedSources)
            {
                ImGui::BulletText("%s: %.1f BPM (%.0f%% conf)", 
                                 source.name.toRawUTF8(), 
                                 source.detectedBPM,
                                 source.confidence * 100.0f);
            }
        }
    }
    
    ImGui::PopItemWidth();
}
#endif



================================================================================
FILE: juce\Source\audio\modules\MIDIPlayerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"
#include <juce_audio_basics/juce_audio_basics.h>

class MIDIPlayerModuleProcessor : public ModuleProcessor
{
public:
    // ADD THIS ENUM
    enum class AutoConnectState { None, Samplers, PolyVCO, Hybrid };
    
    static constexpr int kMaxTracks = 24;          // hard cap for output channels
    static constexpr int kOutputsPerTrack = 4;     // Pitch, Gate, Velocity, Trigger
    static constexpr int kClockChannelIndex = kMaxTracks * kOutputsPerTrack;        // 96
    static constexpr int kNumTracksChannelIndex = kClockChannelIndex + 1;           // 97
    static constexpr int kRawNumTracksChannelIndex = kNumTracksChannelIndex + 1;    // 98
    static constexpr int kTotalOutputs = kRawNumTracksChannelIndex + 1;             // 99
    static constexpr const char* SPEED_PARAM = "speed";
    static constexpr const char* PITCH_PARAM = "pitch";
    static constexpr const char* TEMPO_PARAM = "tempo";
    static constexpr const char* TRACK_PARAM = "track";
    static constexpr const char* LOOP_PARAM = "loop";
    static constexpr const char* SPEED_MOD_PARAM = "speed_mod";
    static constexpr const char* PITCH_MOD_PARAM = "pitch_mod";
    static constexpr const char* VELOCITY_MOD_PARAM = "velocity_mod";

    MIDIPlayerModuleProcessor();
    ~MIDIPlayerModuleProcessor() override = default;

    const juce::String getName() const override { return "midi_player"; }
    
    // Auto-connect trigger flags
    std::atomic<bool> autoConnectTriggered { false };
    std::atomic<bool> autoConnectVCOTriggered { false };
    std::atomic<bool> autoConnectHybridTriggered { false };

    // ADD THESE TWO LINES
    std::atomic<AutoConnectState> lastAutoConnectState { AutoConnectState::None };
    std::atomic<bool> connectionUpdateRequested { false };

    void prepareToPlay(double sampleRate, int maximumExpectedSamplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages) override;
    
    // CRITICAL: Receive transport state (BPM, position, play state) from ModularSynthProcessor
    void setTimingInfo(const TransportState& state) override { m_currentTransport = state; }

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    // POLYPHONIC OUTPUTS: Dynamic pins for multi-track playback
    std::vector<DynamicPinInfo> getDynamicOutputPins() const override;

    void drawIoPins(const NodePinHelpers& helpers) override;
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;

    // UI Methods
    #if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    #endif

    // Pin labeling
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;

    // MIDI File Management
    void loadMIDIFile(const juce::File& file);
    bool hasMIDIFileLoaded() const { return midiFile != nullptr && midiFile->getNumTracks() > 0; }
    juce::String getCurrentMIDIFileName() const { return currentMIDIFileName; }
    juce::String getCurrentMIDIFileFullPath() const { return currentMIDIFilePath; }

    // Piano Roll Data Access
    struct NoteData
    {
        double startTime;
        double endTime;
        int noteNumber;
        int velocity;
        int trackIndex;
    };
    
    struct TrackInfo
    {
        juce::String name;
        int noteCount;
        bool hasNotes;
    };
    
    const std::vector<std::vector<NoteData>>& getNotesByTrack() const { return notesByTrack; }
    const std::vector<TrackInfo>& getTrackInfos() const { return trackInfos; }
    const std::vector<int>& getActiveTrackIndices() const { return activeTrackIndices; }
    double getTotalDuration() const { return totalDuration; }
    
    // Quick Connect: Check and consume connection request
    // Returns: 0=none, 1=PolyVCO, 2=Samplers, 3=Both
    int getAndClearConnectionRequest() 
    { 
        int req = connectionRequestType.load(); 
        connectionRequestType = 0; 
        return req; 
    }
    int getNumTracks() const { return midiFile ? midiFile->getNumTracks() : 0; }
    int getTotalNoteCount() const;

private:
    // Protects cross-thread access to MIDI data structures
    juce::CriticalSection midiDataLock;

    juce::AudioProcessorValueTreeState apvts;
    
    // MIDI File Data
    std::unique_ptr<juce::MidiFile> midiFile;
    juce::String currentMIDIFileName;
    juce::String currentMIDIFilePath;
    
    // --- MODIFIED DATA STRUCTURES ---
    // Replace the single flat vector of notes with a per-track structure
    std::vector<std::vector<NoteData>> notesByTrack;
    std::vector<TrackInfo> trackInfos;
    double totalDuration { 0.0 };
    int numActiveTracks { 0 };
    std::vector<int> activeTrackIndices; // map active output group -> source track index
    
    // Playback State
    double currentPlaybackTime { 0.0 };
    double playbackSpeed { 1.0 };
    int currentTrackIndex { 0 };
    bool isLooping { true };
    
    // --- ADD NEW STATE VARIABLES FOR EFFICIENT SEARCH ---
    std::vector<int> lastNoteIndexHint; // Remembers the last search position for each track
    double previousPlaybackTime { -1.0 }; // Used to detect when playback loops or seeks
    
    // Output Values (legacy single-track summary retained for diagnostics, not routed)
    float pitchCV { 0.0f };
    float gateLevel { 0.0f };
    float velocityLevel { 0.0f };
    bool triggerPulse { false };
    float clockOutput { 0.0f };
    float numTracksOutput { 0.0f };
    std::atomic<double> pendingSeekTime { -1.0 };
    float lastResetCV { 0.0f }; // For reset modulation edge detection
    
    // Parameter Pointers
    std::atomic<float>* speedParam { nullptr };
    std::atomic<float>* pitchParam { nullptr };
    std::atomic<float>* tempoParam { nullptr };
    std::atomic<float>* trackParam { nullptr };
    std::atomic<float>* loopParam { nullptr };
    std::atomic<float>* speedModParam { nullptr };
    std::atomic<float>* pitchModParam { nullptr };
    std::atomic<float>* velocityModParam { nullptr };
    
    // File Chooser
    std::unique_ptr<juce::FileChooser> fileChooser;
    
    // TEMPO HANDLING: Smart tempo system with file/host/multiplier hierarchy
    juce::AudioParameterBool* syncToHostParam { nullptr };
    juce::AudioParameterFloat* tempoMultiplierParam { nullptr };
    double fileBpm = 120.0; // Stores tempo parsed from loaded .mid file
    
    // CRITICAL: Custom transport state (replaces JUCE getPlayHead() for standalone app)
    TransportState m_currentTransport;
    
    // PHASE 1: UI State Variables for Piano Roll
    float nodeWidth = 600.0f;
    float zoomX = 50.0f; // Pixels per beat (matches MidiLogger default)
    
    // Quick Connect: Connection request flag (0=none, 1=PolyVCO, 2=Samplers, 3=Both)
    std::atomic<int> connectionRequestType { 0 };
    
    // Internal Methods
    void parseMIDIFile();
    void updatePlaybackTime(double deltaTime);
    void generateCVOutputs();
    double noteNumberToCV(int noteNumber) const;
    juce::ValueTree getExtraStateTree() const override
    {
        juce::ValueTree vt ("MIDIPlayerExtra");
        vt.setProperty ("fileName", currentMIDIFileName, nullptr);
        vt.setProperty ("filePath", currentMIDIFilePath, nullptr);
        vt.setProperty ("track", currentTrackIndex, nullptr);
        return vt;
    }
    void setExtraStateTree(const juce::ValueTree& vt) override
    {
        if (! vt.isValid() || ! vt.hasType ("MIDIPlayerExtra")) return;
        currentMIDIFileName = vt.getProperty ("fileName").toString();
        currentMIDIFilePath = vt.getProperty ("filePath").toString();
        currentTrackIndex = (int) vt.getProperty ("track", 0);
        if (currentMIDIFilePath.isNotEmpty())
        {
            juce::File f (currentMIDIFilePath);
            if (f.existsAsFile())
                loadMIDIFile (f);
        }
        if (auto* p = apvts.getParameter(TRACK_PARAM))
        {
            float norm = apvts.getParameterRange(TRACK_PARAM).convertTo0to1((float) currentTrackIndex);
            p->setValueNotifyingHost(norm);
        }
    }
    
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
};


================================================================================
FILE: juce\Source\audio\modules\MIDIPlayerModuleProcessor.cpp
================================================================================


#include "MIDIPlayerModuleProcessor.h"

MIDIPlayerModuleProcessor::MIDIPlayerModuleProcessor()
    : ModuleProcessor(BusesProperties()
        .withInput("Speed Mod", juce::AudioChannelSet::mono(), true)
        .withInput("Pitch Mod", juce::AudioChannelSet::mono(), true)
        .withInput("Velocity Mod", juce::AudioChannelSet::mono(), true)
        .withInput("Reset Mod", juce::AudioChannelSet::mono(), true)
        .withInput("Loop Mod", juce::AudioChannelSet::mono(), true)
        .withOutput("Output", juce::AudioChannelSet::discreteChannels(kTotalOutputs), true))
    , apvts(*this, nullptr, "MIDIPlayerParameters", createParameterLayout())
{
    // Initialize parameter pointers
    speedParam = apvts.getRawParameterValue(SPEED_PARAM);
    pitchParam = apvts.getRawParameterValue(PITCH_PARAM);
    tempoParam = apvts.getRawParameterValue(TEMPO_PARAM);
    trackParam = apvts.getRawParameterValue(TRACK_PARAM);
    loopParam = apvts.getRawParameterValue(LOOP_PARAM);
    speedModParam = apvts.getRawParameterValue(SPEED_MOD_PARAM);
    pitchModParam = apvts.getRawParameterValue(PITCH_MOD_PARAM);
    velocityModParam = apvts.getRawParameterValue(VELOCITY_MOD_PARAM);
    
    // TEMPO HANDLING: Get pointers to new tempo control parameters
    syncToHostParam = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("syncToHost"));
    tempoMultiplierParam = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("tempoMultiplier"));
    
    // Initialize output values
    lastOutputValues.resize(kTotalOutputs);
    for (auto& value : lastOutputValues)
        value = std::make_unique<std::atomic<float>>(0.0f);
}

juce::AudioProcessorValueTreeState::ParameterLayout MIDIPlayerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters;
    
    // Playback Controls
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        SPEED_PARAM, "Speed", 0.25f, 4.0f, 1.0f));
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        PITCH_PARAM, "Pitch", -24.0f, 24.0f, 0.0f));
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        TEMPO_PARAM, "Tempo", 60.0f, 200.0f, 120.0f));
    parameters.push_back(std::make_unique<juce::AudioParameterInt>(
        TRACK_PARAM, "Track", -1, 31, 0)); // -1 = "Show All Tracks"
    parameters.push_back(std::make_unique<juce::AudioParameterBool>(
        LOOP_PARAM, "Loop", true));
    
    // TEMPO HANDLING: Smart tempo control parameters
    parameters.push_back(std::make_unique<juce::AudioParameterBool>(
        "syncToHost", "Sync to Host", false)); // Default: use file tempo
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        "tempoMultiplier", "Tempo Multiplier", 0.25f, 4.0f, 1.0f)); // 0.25x to 4x speed
    
    // Modulation Inputs
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        SPEED_MOD_PARAM, "Speed Mod", 0.0f, 1.0f, 0.5f));
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        PITCH_MOD_PARAM, "Pitch Mod", 0.0f, 1.0f, 0.5f));
    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
        VELOCITY_MOD_PARAM, "Velocity Mod", 0.0f, 1.0f, 0.5f));
    
    return { parameters.begin(), parameters.end() };
}

void MIDIPlayerModuleProcessor::prepareToPlay(double sampleRate, int maximumExpectedSamplesPerBlock)
{
    juce::Logger::writeToLog("[MIDI Player] prepareToPlay sr=" + juce::String(sampleRate) + ", block=" + juce::String(maximumExpectedSamplesPerBlock));
}

void MIDIPlayerModuleProcessor::releaseResources()
{
    // Nothing to release for MIDI Player
}

void MIDIPlayerModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    const juce::ScopedLock lock (midiDataLock);
    // Get a dedicated view of the multi-channel output bus
    auto outBus = getBusBuffer(buffer, false, 0);
    outBus.clear(); // Start with a clean slate

    if (!hasMIDIFileLoaded()) {
        return; // Exit if no MIDI file is loaded
    }
    
    const int numSamples = outBus.getNumSamples();
    const double sampleRate = getSampleRate();
    const double deltaTime = numSamples / sampleRate;

    // HIERARCHICAL TEMPO CALCULATION (Option A + Option B)
    // Priority: 1. Sync to Host (if enabled) → 2. File Tempo → 3. User Multiplier
    double activeBpm = fileBpm; // Start with file's tempo (Option A)
    
    if (syncToHostParam && syncToHostParam->get())
    {
        // Sync to Host enabled: use transport BPM from tempo clock (highest priority)
        activeBpm = m_currentTransport.bpm;
    }
    
    // Apply user's tempo multiplier (Option B: 0.25x to 4x)
    const float tempoMult = tempoMultiplierParam ? tempoMultiplierParam->get() : 1.0f;
    const double finalBpm = activeBpm * tempoMult;
    
    // Store for UI display and other calculations
    if (tempoParam)
        tempoParam->store((float)finalBpm);

    // --- 1. Update Playback Time (THE CRITICAL FIX: HOST SYNC) ---
    bool isSynced = syncToHostParam && syncToHostParam->get();
    
    // Calculate speed based on sync mode
    const double tempoSpeedRatio = (fileBpm > 0.0) ? (finalBpm / fileBpm) : 1.0;
    const double effectiveSpeed = tempoSpeedRatio;
    
    // Store live speed value for UI
    setLiveParamValue("speed_live", (float)effectiveSpeed);
    
    // Handle user seeking (clicking on the timeline)
    if (double seek = pendingSeekTime.load(); seek >= 0.0) {
        currentPlaybackTime = juce::jlimit(0.0, totalDuration, seek);
        pendingSeekTime.store(-1.0);
    }
    
    // Advance playback time (using transport BPM if synced, file BPM otherwise)
    // Note: activeBpm already contains the correct BPM based on sync mode (line 95-99)
    currentPlaybackTime += deltaTime * effectiveSpeed;

    // Handle Reset and Loop modulation
    bool shouldReset = false;
    bool shouldLoop = loopParam->load() > 0.5f;
    
    if (isParamInputConnected("reset")) {
        const auto& resetModBus = getBusBuffer(buffer, true, 3);
        if (resetModBus.getNumChannels() > 0) {
            float resetCV = resetModBus.getReadPointer(0)[0];
            if (resetCV > 0.5f && lastResetCV <= 0.5f) { // Rising edge
                shouldReset = true;
            }
            lastResetCV = resetCV;
        }
    }
    
    if (isParamInputConnected("loop")) {
        const auto& loopModBus = getBusBuffer(buffer, true, 4);
        if (loopModBus.getNumChannels() > 0) {
            float loopCV = loopModBus.getReadPointer(0)[0];
            shouldLoop = loopCV > 0.5f;
        }
    }
    
    // Apply reset
    if (shouldReset) {
        currentPlaybackTime = 0.0;
    }
    
    // Apply loop behavior
    if (currentPlaybackTime >= totalDuration && shouldLoop) {
        currentPlaybackTime = std::fmod(currentPlaybackTime, totalDuration);
    }

    // --- RESET SEARCH HINTS on loop or seek ---
    if (currentPlaybackTime < previousPlaybackTime)
    {
        std::fill(lastNoteIndexHint.begin(), lastNoteIndexHint.end(), 0);
    }
    previousPlaybackTime = currentPlaybackTime;

    // --- 2. Generate Outputs for Each Active MIDI Track ---
    const int tracksToProcess = std::min((int)activeTrackIndices.size(), kMaxTracks);
    if (tracksToProcess == 0)
    {
        // Debug in Collider: no active tracks, nothing to output
        static int ctr = 0; if ((ctr++ & 0x3F) == 0)
            juce::Logger::writeToLog("[MIDI Player] No active tracks; check preset load and activeTrackIndices");
    }
    for (int i = 0; i < tracksToProcess; ++i)
    {
        const int sourceTrackIndex = activeTrackIndices[i];
        
        // --- REPLACED with EFFICIENT SEARCH ---
        const NoteData* activeNote = nullptr;
        if (sourceTrackIndex < (int)notesByTrack.size())
        {
            auto& trackNotes = notesByTrack[sourceTrackIndex];
            int& searchIndex = lastNoteIndexHint[sourceTrackIndex];

            // Fast-forward past notes that have already ended
            while (searchIndex < (int)trackNotes.size() && trackNotes[searchIndex].endTime < currentPlaybackTime)
            {
                searchIndex++;
            }

            // Now, search from the hint to find the active note (last-note priority)
            double latestStart = -1.0;
            for (int j = searchIndex; j < (int)trackNotes.size(); ++j)
            {
                const auto& note = trackNotes[j];
                if (note.startTime > currentPlaybackTime) break; // Notes are sorted, so we can stop early

                if (currentPlaybackTime >= note.startTime && currentPlaybackTime <= note.endTime) {
                    if (note.startTime > latestStart) {
                        latestStart = note.startTime;
                        activeNote = &note;
                    }
                }
            }
        }
        // --- END OF EFFICIENT SEARCH ---

        // Calculate the four CV values for this track (Gate, Pitch, Velocity, Trigger)
        float pitchOut = 0.0f, gateOut = 0.0f, velOut = 0.0f, trigOut = 0.0f;
        if (activeNote) {
            pitchOut = (float)noteNumberToCV(activeNote->noteNumber);
            gateOut = 1.0f;
            velOut = activeNote->velocity / 127.0f;
            // Generate a 10ms trigger at the start of the note
            if (std::abs(currentPlaybackTime - activeNote->startTime) < 0.01) {
                trigOut = 1.0f;
            }
        }
        
        // Apply global pitch modulation
        float pitchOffset = pitchParam->load();
        if (isParamInputConnected("pitch"))
            pitchOffset += juce::jmap(getBusBuffer(buffer, true, 1).getReadPointer(0)[0], 0.0f, 1.0f, -24.0f, 24.0f);
        pitchOut = juce::jlimit(0.0f, 1.0f, pitchOut + (pitchOffset / 60.0f));
        
        // Store live pitch value for UI
        setLiveParamValue("pitch_live", pitchOffset);
    
    // Store live loop value for UI
    setLiveParamValue("loop_live", shouldLoop ? 1.0f : 0.0f);

    // --- 3. Ensure tooltip storage capacity ---
    const int requiredChannels = outBus.getNumChannels();
    if ((int) lastOutputValues.size() < requiredChannels)
    {
        const size_t oldSize = lastOutputValues.size();
        lastOutputValues.resize((size_t) requiredChannels);
        for (size_t i = oldSize; i < lastOutputValues.size(); ++i)
            lastOutputValues[i] = std::make_unique<std::atomic<float>>(0.0f);
    }

    // --- 4. Write to the Correct Output Channels ---
        // POLYPHONIC OUTPUTS: Use 4 channels per track (Gate, Pitch, Velo, Trigger)
        const int baseChannel = i * 4;
        const int gateChan  = baseChannel + 0;
        const int pitchChan = baseChannel + 1;
        const int velChan   = baseChannel + 2;
        const int trigChan  = baseChannel + 3;

        // This is the reliable way to write: check if channel exists, get pointer, then fill.
        if (pitchChan < outBus.getNumChannels())
    {
        juce::FloatVectorOperations::fill(outBus.getWritePointer(pitchChan), pitchOut, numSamples);
        if (pitchChan < (int) lastOutputValues.size() && lastOutputValues[(size_t) pitchChan])
            lastOutputValues[(size_t) pitchChan]->store(pitchOut);
    }
        if (gateChan < outBus.getNumChannels())
    {
        juce::FloatVectorOperations::fill(outBus.getWritePointer(gateChan), gateOut, numSamples);
        if (gateChan < (int) lastOutputValues.size() && lastOutputValues[(size_t) gateChan])
            lastOutputValues[(size_t) gateChan]->store(gateOut);
    }
        if (velChan < outBus.getNumChannels())
    {
        juce::FloatVectorOperations::fill(outBus.getWritePointer(velChan), velOut, numSamples);
        if (velChan < (int) lastOutputValues.size() && lastOutputValues[(size_t) velChan])
            lastOutputValues[(size_t) velChan]->store(velOut);
    }
        if (trigChan < outBus.getNumChannels())
    {
        juce::FloatVectorOperations::fill(outBus.getWritePointer(trigChan), trigOut, numSamples);
        if (trigChan < (int) lastOutputValues.size() && lastOutputValues[(size_t) trigChan])
            lastOutputValues[(size_t) trigChan]->store(trigOut);
    }
    }
    
    // --- 5. Write Global Outputs ---
    if (kClockChannelIndex < outBus.getNumChannels()) {
        float tempo = tempoParam->load();
        double beatTime = 60.0 / tempo;
        double clockPhase = std::fmod(currentPlaybackTime, beatTime) / beatTime;
        float clockValue = (clockPhase < 0.1f) ? 1.0f : 0.0f;
        juce::FloatVectorOperations::fill(outBus.getWritePointer(kClockChannelIndex), clockValue, numSamples);
        if (kClockChannelIndex < (int) lastOutputValues.size() && lastOutputValues[(size_t) kClockChannelIndex])
            lastOutputValues[(size_t) kClockChannelIndex]->store(clockValue);
    }

    // --- NEWLY ADDED BLOCK TO FIX THE "NUM TRACKS" OUTPUT ---
    if (kNumTracksChannelIndex < outBus.getNumChannels()) {
        // CRITICAL FIX: Output TOTAL tracks (notesByTrack.size()), not just tracks with notes
        // This matches the number of dynamic output pins created and ensures correct allocation
        const float numTracksValue = (float)notesByTrack.size() / (float)kMaxTracks;
        juce::FloatVectorOperations::fill(outBus.getWritePointer(kNumTracksChannelIndex), numTracksValue, numSamples);
        
        if (kNumTracksChannelIndex < (int)lastOutputValues.size() && lastOutputValues[(size_t)kNumTracksChannelIndex])
            lastOutputValues[(size_t)kNumTracksChannelIndex]->store(numTracksValue);
    }
    
    // --- RAW NUM TRACKS OUTPUT ---
    if (kRawNumTracksChannelIndex < outBus.getNumChannels()) {
        // CRITICAL FIX: Output TOTAL tracks from MIDI file
        // This ensures PolyVCO/TrackMixer allocate the correct number of voices/channels
        const float rawNumTracksValue = (float)notesByTrack.size();
        juce::FloatVectorOperations::fill(outBus.getWritePointer(kRawNumTracksChannelIndex), rawNumTracksValue, numSamples);
        
        if (kRawNumTracksChannelIndex < (int)lastOutputValues.size() && lastOutputValues[(size_t)kRawNumTracksChannelIndex])
            lastOutputValues[(size_t)kRawNumTracksChannelIndex]->store(rawNumTracksValue);
    }
    // --- END OF FIX ---
}

void MIDIPlayerModuleProcessor::updatePlaybackTime(double deltaTime)
{
    currentPlaybackTime += deltaTime;
    
    // Handle looping
    if (currentPlaybackTime >= totalDuration && isLooping)
    {
        currentPlaybackTime = std::fmod(currentPlaybackTime, totalDuration);
    }
    else if (currentPlaybackTime >= totalDuration)
    {
        currentPlaybackTime = totalDuration;
    }
}

void MIDIPlayerModuleProcessor::generateCVOutputs()
{
    // Reset outputs
    // Keep last pitchCV to avoid dropping to zero between notes
    gateLevel = 0.0f;
    velocityLevel = 0.0f;
    triggerPulse = false;
    
    // Debug logging (only every 1000 samples to avoid spam)
    static int debugCounter = 0;
    if (++debugCounter % 1000 == 0)
    {
        juce::Logger::writeToLog("[MIDI Player] Debug - Time: " + juce::String(currentPlaybackTime, 3) + 
                                "s, Track: " + juce::String(currentTrackIndex) + 
                                ", Total notes: " + juce::String(getTotalNoteCount()));
    }
    
    // Find active note(s) at current time and apply mono priority: last note on
    int activeNotes = 0;
    const NoteData* chosenNote = nullptr;
    double latestStart = -1.0;
    
    // Use efficient search for the current track
    if (currentTrackIndex < (int)notesByTrack.size())
    {
        const auto& trackNotes = notesByTrack[currentTrackIndex];
        for (const auto& note : trackNotes)
        {
            if (currentPlaybackTime >= note.startTime && currentPlaybackTime <= note.endTime)
            {
                activeNotes++;
                // Prefer the most recent onset; tie-breaker by higher velocity
                if (note.startTime > latestStart || (std::abs(note.startTime - latestStart) < 1e-6 && chosenNote != nullptr && note.velocity > chosenNote->velocity))
                {
                    latestStart = note.startTime;
                    chosenNote = &note;
                }
            }
        }
    }
    
    if (chosenNote != nullptr)
    {
        pitchCV = (float) noteNumberToCV(chosenNote->noteNumber);
        gateLevel = 1.0f;
        velocityLevel = chosenNote->velocity / 127.0f;
        
        if (debugCounter % 1000 == 0)
        {
            juce::Logger::writeToLog("[MIDI Player] Active note - MIDI Note: " + juce::String(chosenNote->noteNumber) +
                                    ", Velocity: " + juce::String(chosenNote->velocity) +
                                    ", CV: " + juce::String(pitchCV, 3));
        }
        
        if (std::abs(currentPlaybackTime - chosenNote->startTime) < 0.01)
        {
            triggerPulse = true;
        }
    }
    
    // Fallback: if selected track has zero notes at all, try track 0
    if (activeNotes == 0 && currentTrackIndex != 0 && currentTrackIndex < (int) trackInfos.size() && trackInfos[(size_t) currentTrackIndex].noteCount == 0)
    {
        if (0 < (int)notesByTrack.size())
        {
            const auto& track0Notes = notesByTrack[0];
            for (const auto& note : track0Notes)
            {
                if (currentPlaybackTime >= note.startTime && currentPlaybackTime <= note.endTime)
                {
                    // Note is active
                    pitchCV = (float) noteNumberToCV(note.noteNumber);
                    gateLevel = 1.0f;
                    velocityLevel = note.velocity / 127.0f;
                    
                    if (debugCounter % 1000 == 0)
                    {
                        juce::Logger::writeToLog("[MIDI Player] FALLBACK to track 0 - MIDI Note: " + juce::String(note.noteNumber));
                    }
                    break;
                }
            }
        }
    }
    
    // Debug track information
    if (debugCounter % 1000 == 0)
    {
        juce::Logger::writeToLog("[MIDI Player] Current track: " + juce::String(currentTrackIndex) + 
                                ", Total tracks: " + juce::String(getNumTracks()));
        
        for (int t = 0; t < getNumTracks(); ++t)
        {
            int notesInTrack = 0;
            if (t < (int)notesByTrack.size())
            {
                notesInTrack = (int)notesByTrack[t].size();
            }
            if (notesInTrack > 0)
            {
                juce::String trackName = (t < trackInfos.size()) ? trackInfos[t].name : "Track " + juce::String(t);
                juce::Logger::writeToLog("[MIDI Player] " + trackName + ": " + juce::String(notesInTrack) + " notes");
            }
        }
        
        if (activeNotes == 0 && currentTrackIndex < trackInfos.size())
        {
            const auto& info = trackInfos[currentTrackIndex];
            juce::Logger::writeToLog("[MIDI Player] WARNING: No active notes in " + info.name + 
                                    " (has " + juce::String(info.noteCount) + " total notes)");
        }
    }
    
    // Generate clock output (quarter note pulses)
    float tempo = tempoParam->load();
    double beatTime = 60.0 / tempo;
    double clockPhase = std::fmod(currentPlaybackTime, beatTime) / beatTime;
    clockOutput = (clockPhase < 0.1f) ? 1.0f : 0.0f; // 10% duty cycle
}

double MIDIPlayerModuleProcessor::noteNumberToCV(int noteNumber) const
{
    // Map MIDI note range C2..C7 (36..96) to 0..1 linearly
    // Notes below C2 clamp to 0, above C7 clamp to 1
    const double minNote = 36.0; // C2
    const double maxNote = 96.0; // C7
    if (noteNumber <= minNote) return 0.0;
    if (noteNumber >= maxNote) return 1.0;
    return (noteNumber - minNote) / (maxNote - minNote);
}

int MIDIPlayerModuleProcessor::getTotalNoteCount() const
{
    int totalNotes = 0;
    for (const auto& trackNotes : notesByTrack) {
        totalNotes += (int)trackNotes.size();
    }
    return totalNotes;
}

void MIDIPlayerModuleProcessor::parseMIDIFile()
{
    if (!midiFile)
        return;
    
    // Build new state off-thread, then swap under lock
    std::vector<std::vector<NoteData>> newNotesByTrack;
    std::vector<TrackInfo> newTrackInfos;
    std::vector<int> newActiveTrackIndices;
    double newTotalDuration = 0.0;

    newNotesByTrack.clear();
    newNotesByTrack.resize (midiFile->getNumTracks());
    
    for (int track = 0; track < midiFile->getNumTracks(); ++track)
    {
        const auto* sequence = midiFile->getTrack (track);
        if (! sequence) continue;
        
        for (int event = 0; event < sequence->getNumEvents(); ++event)
        {
            const auto& message = sequence->getEventPointer(event)->message;
            if (message.isNoteOn() && message.getVelocity() > 0)
            {
                double startTime = message.getTimeStamp();
                double endTime = startTime + 1.0;
                for (int searchEvent = event + 1; searchEvent < sequence->getNumEvents(); ++searchEvent)
                {
                    const auto& searchMessage = sequence->getEventPointer(searchEvent)->message;
                    if ((searchMessage.isNoteOff() || (searchMessage.isNoteOn() && searchMessage.getVelocity() == 0)) &&
                        searchMessage.getNoteNumber() == message.getNoteNumber())
                    {
                        endTime = searchMessage.getTimeStamp();
                        break;
                    }
                }
                if (endTime - startTime < 0.05)
                    endTime = startTime + 0.05;

                NoteData note;
                const double ticksPerQuarter = midiFile->getTimeFormat();
                const double tempo = tempoParam ? (double) tempoParam->load() : 120.0;
                const double secondsPerTick = (60.0 / tempo) / ticksPerQuarter;
                note.startTime = startTime * secondsPerTick;
                note.endTime   = endTime   * secondsPerTick;
                note.noteNumber = message.getNoteNumber();
                note.velocity   = message.getVelocity();
                note.trackIndex = track;
                newNotesByTrack[track].push_back (note);
                newTotalDuration = std::max (newTotalDuration, note.endTime);
            }
        }
    }

    newTrackInfos.clear();
    newTrackInfos.resize (midiFile->getNumTracks());
    newActiveTrackIndices.clear();
    int newNumActiveTracks = 0;
    
    for (int track = 0; track < midiFile->getNumTracks(); ++track)
    {
        TrackInfo info;
        info.name = "Track " + juce::String (track + 1);
        info.noteCount = (int) newNotesByTrack[track].size();
        info.hasNotes = (info.noteCount > 0);
        if (const auto* sequence = midiFile->getTrack (track))
        {
            for (int i = 0; i < sequence->getNumEvents(); ++i)
            {
                const auto& msg = sequence->getEventPointer(i)->message;
                if (msg.isTrackNameEvent()) { info.name = msg.getTextFromTextMetaEvent(); break; }
            }
        }
        newTrackInfos[track] = info;
        if (info.hasNotes)
        {
            ++newNumActiveTracks;
            if ((int) newActiveTrackIndices.size() < kMaxTracks)
                newActiveTrackIndices.push_back (track);
        }
    }

    {
        const juce::ScopedLock lock (midiDataLock);
        notesByTrack.swap (newNotesByTrack);
        trackInfos.swap (newTrackInfos);
        activeTrackIndices.swap (newActiveTrackIndices);
        totalDuration = newTotalDuration;
        lastNoteIndexHint.assign (midiFile->getNumTracks(), 0);
        previousPlaybackTime = -1.0;
        numActiveTracks = newNumActiveTracks;
    }

    int totalNotes = 0;
    for (const auto& tn : notesByTrack) totalNotes += (int) tn.size();
    juce::Logger::writeToLog ("[MIDI Player] Parsed " + juce::String (totalNotes) +
                              " notes from " + juce::String (midiFile->getNumTracks()) + " tracks");
    juce::Logger::writeToLog ("[MIDI Player] Time format: " + juce::String (midiFile->getTimeFormat()) +
                              " ticks/quarter, Total duration: " + juce::String (totalDuration, 3) + "s");
}

void MIDIPlayerModuleProcessor::loadMIDIFile(const juce::File& file)
{
    auto newMidiFile = std::make_unique<juce::MidiFile>();
    
    juce::FileInputStream inputStream(file);
    if (inputStream.openedOk() && newMidiFile->readFrom(inputStream))
    {
        {
            const juce::ScopedLock lock (midiDataLock);
            midiFile = std::move(newMidiFile);
            currentMIDIFileName = file.getFileName();
            currentMIDIFilePath = file.getFullPathName();
            currentPlaybackTime = 0.0;
            previousPlaybackTime = -1.0;
            lastNoteIndexHint.clear();
            
            // TEMPO PARSING: Extract BPM from MIDI file (Option A)
            // Most MIDI files store tempo in the first track as a meta event
            fileBpm = 120.0; // Default fallback
            if (midiFile && midiFile->getNumTracks() > 0)
            {
                const auto* firstTrack = midiFile->getTrack(0);
                for (int i = 0; i < firstTrack->getNumEvents(); ++i)
                {
                    const auto& event = firstTrack->getEventPointer(i)->message;
                    if (event.isTempoMetaEvent())
                    {
                        fileBpm = event.getTempoSecondsPerQuarterNote() > 0.0 
                            ? 60.0 / event.getTempoSecondsPerQuarterNote() 
                            : 120.0;
                        juce::Logger::writeToLog("[MIDI Player] Detected file tempo: " + 
                                                juce::String(fileBpm, 1) + " BPM");
                        break; // Use the first tempo event found
                    }
                }
            }
        }
        parseMIDIFile();
        
        juce::Logger::writeToLog("[MIDI Player] Loaded MIDI file: " + currentMIDIFileName);
        
        // --- ADD THIS LINE ---
        // If a new file is loaded, signal to the UI that connections may need to be updated.
        connectionUpdateRequested = true;
    }
    else
    {
        juce::Logger::writeToLog("[MIDI Player] Failed to load MIDI file: " + file.getFullPathName());
    }
}

#if defined(PRESET_CREATOR_UI)

// Helper function for tooltip with help marker
static void HelpMarkerPlayer(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}

// ==============================================================================
// PHASE 2: PIANO ROLL UI (Ported from MidiLogger)
// ==============================================================================
void MIDIPlayerModuleProcessor::drawParametersInNode(float /*itemWidth*/, const std::function<bool(const juce::String&)>&, const std::function<void()>& onModificationEnded)
{
    // --- Invisible Scaffolding ---
    ImGui::Dummy(ImVec2(nodeWidth, 0.0f));
    
    // --- 1. TOOLBAR ---
    // Status indicator based on playback
    const char* statusText = speedParam->load() > 0.01f ? "▶ PLAY" : "■ Stopped";
    ImVec4 statusColor = speedParam->load() > 0.01f ? 
        ImVec4(0.0f, 1.0f, 0.0f, 1.0f) : ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
    
    ImGui::PushStyleColor(ImGuiCol_Text, statusColor);
    ImGui::Text("%s", statusText);
        ImGui::PopStyleColor();
    ImGui::SameLine();
    
    // Load .mid Button
    if (ImGui::Button("Load .mid"))
    {
        juce::File startDir;
            auto appFile = juce::File::getSpecialLocation(juce::File::currentApplicationFile);
            auto dir = appFile.getParentDirectory();
            for (int i = 0; i < 10 && dir.exists(); ++i)
            {
                if (dir.getChildFile("juce").isDirectory())
                {
                    auto candidate = dir.getChildFile("audio").getChildFile("MIDI");
                    if (candidate.exists() && candidate.isDirectory())
                    {
                        startDir = candidate;
                        break;
                    }
                }
                dir = dir.getParentDirectory();
        }
        if (!startDir.exists()) startDir = juce::File();
        
        fileChooser = std::make_unique<juce::FileChooser>("Select MIDI File", startDir, "*.mid;*.midi");
        auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;
        fileChooser->launchAsync(chooserFlags, [this, onModificationEnded](const juce::FileChooser& fc)
        {
                auto file = fc.getResult();
                if (file != juce::File{})
                {
                juce::Logger::writeToLog("[MIDI Player] Loading file: " + file.getFullPathName());
                    loadMIDIFile(file);
                onModificationEnded();
            }
        });
    }
    ImGui::SameLine();
    
    // File name display
    ImGui::Text("File: %s", currentMIDIFileName.isEmpty() ? "No file loaded" : currentMIDIFileName.toRawUTF8());
    
    // === FILE INFORMATION DISPLAY ===
    if (hasMIDIFileLoaded())
    {
    ImGui::Spacing();
    
        // Count tracks with notes
        int tracksWithNotes = 0;
        for (const auto& track : notesByTrack)
        {
            if (!track.empty()) tracksWithNotes++;
        }
        
        // Get MIDI file format info
        int ppq = midiFile ? midiFile->getTimeFormat() : 0;
        int totalTracks = getNumTracks();
        
        // Calculate effective playback BPM
        const double currentBpm = tempoParam ? tempoParam->load() : fileBpm;
        const float tempoMult = tempoMultiplierParam ? tempoMultiplierParam->get() : 1.0f;
        const bool isSynced = syncToHostParam ? syncToHostParam->get() : false;
        
        // Display file info in a compact, organized way
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 0.9f, 1.0f, 1.0f)); // Light blue
        
        // Line 1: Original tempo and format info
        ImGui::Text("Original: %.1f BPM • PPQ: %d • Tracks: %d (%d with notes) • Duration: %.1fs",
                   fileBpm, ppq, totalTracks, tracksWithNotes, totalDuration);
        
        // Line 2: Current playback info
        const char* tempoSource = isSynced ? "Host" : "File";
        ImVec4 playbackColor = isSynced ? ImVec4(0.3f, 1.0f, 0.3f, 1.0f) : ImVec4(1.0f, 0.8f, 0.3f, 1.0f);
        
        ImGui::PopStyleColor();
        ImGui::PushStyleColor(ImGuiCol_Text, playbackColor);
        
        ImGui::Text("Playback: %.1f BPM (%.2fx from %s) • Time: %.2fs / %.2fs",
                   currentBpm, tempoMult, tempoSource, currentPlaybackTime, totalDuration);
        
        ImGui::PopStyleColor();
        ImGui::Spacing();
        
        // === HOTSWAP DROP ZONE (Compact, always visible when file is loaded) ===
        ImVec2 hotswapSize = ImVec2(nodeWidth, 30.0f);
        bool isDragging = ImGui::GetDragDropPayload() != nullptr;
        
        if (isDragging)
        {
            // Highlight during drag
            float time = (float)ImGui::GetTime();
            float pulse = (std::sin(time * 8.0f) * 0.5f + 0.5f);
            ImU32 fillColor = IM_COL32(180, 100, 255, (int)(80 + pulse * 100));
            ImU32 borderColor = IM_COL32((int)(220 * pulse), 120, 255, 255);
            
            ImGui::PushStyleColor(ImGuiCol_Button, fillColor);
            ImGui::PushStyleColor(ImGuiCol_Border, borderColor);
            ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 2.0f);
            ImGui::Button("##hotswap_zone", hotswapSize);
            ImGui::PopStyleVar();
            ImGui::PopStyleColor(2);
        }
        else
        {
            // Subtle zone when idle
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(40, 40, 45, 150));
            ImGui::PushStyleColor(ImGuiCol_Border, IM_COL32(80, 80, 90, 180));
            ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
            ImGui::Button("##hotswap_zone", hotswapSize);
            ImGui::PopStyleVar();
            ImGui::PopStyleColor(2);
        }
        
        // Draw text overlay
        const char* hotswapText = isDragging ? "⟳ Drop to Hotswap MIDI" : "⟳ Drop MIDI to Hotswap";
        ImVec2 textSize = ImGui::CalcTextSize(hotswapText);
        ImVec2 textPos = ImGui::GetItemRectMin();
        textPos.x += (hotswapSize.x - textSize.x) * 0.5f;
        textPos.y += (hotswapSize.y - textSize.y) * 0.5f;
        ImU32 textColor = isDragging ? IM_COL32(220, 180, 255, 255) : IM_COL32(150, 150, 160, 200);
        ImGui::GetWindowDrawList()->AddText(textPos, textColor, hotswapText);
        
        // Handle drop
        if (ImGui::BeginDragDropTarget())
        {
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_MIDI_PATH"))
            {
                const char* path = (const char*)payload->Data;
                loadMIDIFile(juce::File(path));
            onModificationEnded();
        }
            ImGui::EndDragDropTarget();
    }
    ImGui::Spacing();
        // === END HOTSWAP ZONE ===
    }
    // === END FILE INFO ===
    
    // Track Selector
    if (hasMIDIFileLoaded() && getNumTracks() > 0)
    {
        ImGui::SameLine();
        ImGui::PushItemWidth(150);
    int track = (int)trackParam->load();
    int maxTrack = std::max(0, getNumTracks() - 1);
    
        // Clamp track to valid range
        if (track > maxTrack)
        {
        track = 0;
        auto normZero = apvts.getParameterRange(TRACK_PARAM).convertTo0to1(0.0f);
        apvts.getParameter(TRACK_PARAM)->setValueNotifyingHost(normZero);
        currentTrackIndex = 0;
    }
    
        juce::String previewLabel;
        if (track == -1)
        {
            previewLabel = "Show All Tracks";
        }
        else if (track >= 0 && track < (int)trackInfos.size())
        {
            const auto& info = trackInfos[(size_t)track];
            previewLabel = info.name + " (" + juce::String(info.noteCount) + " notes)";
        }
        const char* previewText = previewLabel.isNotEmpty() ? previewLabel.toRawUTF8() : "No Track";
        
        if (ImGui::BeginCombo("##track", previewText))
        {
            // "Show All" option (track index -1)
            bool showAllSelected = (track == -1);
            if (ImGui::Selectable("Show All Tracks", showAllSelected))
            {
                float norm = apvts.getParameterRange(TRACK_PARAM).convertTo0to1(-1.0f);
                apvts.getParameter(TRACK_PARAM)->setValueNotifyingHost(norm);
                currentTrackIndex = -1;
                onModificationEnded();
            }
            if (showAllSelected)
                ImGui::SetItemDefaultFocus();
            
            ImGui::Separator();
            
            // Individual tracks
            for (int i = 0; i < getNumTracks(); ++i)
            {
                if (i < (int)trackInfos.size())
                {
                    const auto& info = trackInfos[(size_t)i];
                    juce::String label = info.name + " (" + juce::String(info.noteCount) + " notes)";
                    bool isSelected = (track == i);
                    
                    if (ImGui::Selectable(label.toRawUTF8(), isSelected))
                    {
                        float norm = apvts.getParameterRange(TRACK_PARAM).convertTo0to1((float)i);
                        apvts.getParameter(TRACK_PARAM)->setValueNotifyingHost(norm);
                        currentTrackIndex = i;
                        onModificationEnded();
                    }
                    
                    if (isSelected)
                        ImGui::SetItemDefaultFocus();
                }
            }
            ImGui::EndCombo();
        }
        ImGui::PopItemWidth();
    }
    
    // === TEMPO CONTROL SECTION ===
    ImGui::Text("Tempo Control:");
    ImGui::SameLine();
    
    bool syncToHost = syncToHostParam ? syncToHostParam->get() : false;
    if (ImGui::Checkbox("Sync to Host", &syncToHost))
    {
        if (syncToHostParam)
        {
            float norm = syncToHost ? 1.0f : 0.0f;
            apvts.getParameter("syncToHost")->setValueNotifyingHost(norm);
            onModificationEnded();
        }
    }
    if (ImGui::IsItemHovered())
        ImGui::SetTooltip("Lock tempo to application BPM");
    
    ImGui::SameLine();
    ImGui::PushItemWidth(100);
    float tempoMult = tempoMultiplierParam ? tempoMultiplierParam->get() : 1.0f;
    if (ImGui::SliderFloat("##tempo", &tempoMult, 0.25f, 4.0f, "%.2fx"))
    {
        juce::Logger::writeToLog("[TEMPO SLIDER] Changed to: " + juce::String(tempoMult) + " | zoomX is: " + juce::String(zoomX));
        if (tempoMultiplierParam)
        {
            float norm = apvts.getParameterRange("tempoMultiplier").convertTo0to1(tempoMult);
            apvts.getParameter("tempoMultiplier")->setValueNotifyingHost(norm);
            juce::Logger::writeToLog("[TEMPO SLIDER] Wrote " + juce::String(tempoMult) + " to tempoMultiplier param (norm=" + juce::String(norm) + ")");
            onModificationEnded();
        }
    }
    if (ImGui::IsItemHovered())
    {
        const double currentBpm = tempoParam ? tempoParam->load() : fileBpm;
        ImGui::SetTooltip("Tempo: %.1f BPM (%.2fx multiplier)\nBase: %.1f BPM from %s",
                         currentBpm, tempoMult, fileBpm,
                         syncToHost ? "Host" : "File");
    }
    ImGui::PopItemWidth();
    
    ImGui::Spacing(); // Visual separation between tempo and pitch
    
    // === PITCH TRANSPOSE SECTION ===
    ImGui::Text("Pitch Transpose:");
    ImGui::SameLine();
    ImGui::PushItemWidth(150);
    float pitchOffset = pitchParam ? pitchParam->load() : 0.0f;
    if (ImGui::SliderFloat("##pitchTranspose", &pitchOffset, -24.0f, 24.0f, "%+.0f semi"))
    {
        if (pitchParam)
        {
            float norm = apvts.getParameterRange(PITCH_PARAM).convertTo0to1(pitchOffset);
            apvts.getParameter(PITCH_PARAM)->setValueNotifyingHost(norm);
            onModificationEnded();
        }
    }
    if (ImGui::IsItemHovered())
    {
        int octaves = (int)(pitchOffset / 12.0f);
        int semis = (int)pitchOffset % 12;
        juce::String tooltip = "Transpose all notes by " + juce::String((int)pitchOffset) + " semitones";
        if (octaves != 0)
            tooltip += juce::String::formatted(" (%+d octave%s", octaves, std::abs(octaves) > 1 ? "s" : "");
        if (semis != 0)
        {
            if (octaves != 0) tooltip += ",";
            tooltip += juce::String::formatted(" %+d semi%s", semis, std::abs(semis) > 1 ? "s" : "");
        }
        if (octaves != 0) tooltip += ")";
        ImGui::SetTooltip("%s", tooltip.toRawUTF8());
    }
    ImGui::PopItemWidth();
    
    ImGui::Spacing(); // Visual separation between pitch and zoom
    
    // === TIMELINE ZOOM SECTION ===
    ImGui::Text("Timeline Zoom:");
    ImGui::SameLine();
    ImGui::PushItemWidth(120);
    if (ImGui::SliderFloat("##zoom", &zoomX, 20.0f, 400.0f, "%.0fpx/beat"))
    {
        juce::Logger::writeToLog("[ZOOM SLIDER] Changed to: " + juce::String(zoomX) + "px/beat");
    }
    ImGui::PopItemWidth();
    
    ImGui::Spacing();
    
    // --- QUICK CONNECT BUTTONS ---
    if (hasMIDIFileLoaded() && getNumTracks() > 0)
    {
        ImGui::Separator();
        ImGui::Text("Quick Connect:");
        ImGui::SameLine();
        
        if (ImGui::Button("→ PolyVCO"))
        {
            // Request connection: Pitch→Freq, Gate→Gate, Velo→Wave for all tracks
            connectionRequestType = 1; // PolyVCO
    }
    if (ImGui::IsItemHovered())
            ImGui::SetTooltip("Create PolyVCO and connect all tracks:\nPitch → Freq Mod\nGate → Gate Mod\nVelocity → Wave Mod");
    
    ImGui::SameLine();
        if (ImGui::Button("→ Samplers"))
    {
            // Request connection: Create one SampleLoader per track
            connectionRequestType = 2; // Samplers
    }
    if (ImGui::IsItemHovered())
            ImGui::SetTooltip("Create %d Sample Loaders (one per track):\nPitch → Pitch Mod\nGate → Gate Mod\nTrigger → Trigger Mod", getNumTracks());
    
        ImGui::SameLine();
        if (ImGui::Button("→ Both"))
    {
            // Request connection: Do both
            connectionRequestType = 3; // Both
    }
    if (ImGui::IsItemHovered())
        ImGui::SetTooltip("Connect to both PolyVCO and Sample Loaders");
    
        ImGui::Separator();
    }
    
        ImGui::Spacing();
        
    // --- 2. MAIN CONTENT AREA (PIANO ROLL) ---
    if (!hasMIDIFileLoaded())
    {
        // No file loaded - show drop zone with visual feedback
        ImVec2 dropZoneSize = ImVec2(nodeWidth, 100.0f);
        
        // Check if a drag-drop operation is in progress
        bool isDragging = ImGui::GetDragDropPayload() != nullptr;
        
        if (isDragging)
        {
            // Beautiful blinking animation during drag-drop
            float time = (float)ImGui::GetTime();
            float pulse = (std::sin(time * 8.0f) * 0.5f + 0.5f); // Fast blink
            float glow = (std::sin(time * 3.0f) * 0.3f + 0.7f);  // Slower glow
            
            // Vibrant purple/magenta with pulsing alpha
            ImU32 fillColor = IM_COL32((int)(180 * glow), (int)(100 * glow), (int)(255 * glow), (int)(100 + pulse * 155));
            ImU32 borderColor = IM_COL32((int)(220 * pulse), (int)(120 * glow), (int)(255 * pulse), 255);
            
            ImGui::PushStyleColor(ImGuiCol_Button, fillColor);
            ImGui::PushStyleColor(ImGuiCol_Border, borderColor);
            ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 3.0f);
            ImGui::Button("##dropzone_midi", dropZoneSize);
            ImGui::PopStyleVar();
            ImGui::PopStyleColor(2);
        }
        else
        {
            // Discrete outline only when idle
            ImGui::PushStyleColor(ImGuiCol_Button, IM_COL32(0, 0, 0, 0)); // Transparent fill
            ImGui::PushStyleColor(ImGuiCol_Border, IM_COL32(100, 100, 100, 120)); // Gray outline
            ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
            ImGui::Button("##dropzone_midi", dropZoneSize);
            ImGui::PopStyleVar();
            ImGui::PopStyleColor(2);
        }
        
        const char* text = isDragging ? "Drop MIDI Here!" : "Drop MIDI File Here or Click Load .mid";
        ImVec2 textSize = ImGui::CalcTextSize(text);
        ImVec2 textPos = ImGui::GetItemRectMin();
        textPos.x += (dropZoneSize.x - textSize.x) * 0.5f;
        textPos.y += (dropZoneSize.y - textSize.y) * 0.5f;
        ImU32 textColor = isDragging ? IM_COL32(220, 150, 255, 255) : IM_COL32(150, 150, 150, 200);
        ImGui::GetWindowDrawList()->AddText(textPos, textColor, text);
        
        if (ImGui::BeginDragDropTarget())
        {
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("DND_MIDI_PATH"))
            {
                const char* path = (const char*)payload->Data;
                loadMIDIFile(juce::File(path));
                onModificationEnded();
            }
            ImGui::EndDragDropTarget();
        }
        
        return; // Exit early if no file loaded
    }
    
    const float contentHeight = 250.0f;
    const float timelineHeight = 30.0f;
    
    ImGui::BeginChild("MainContent", ImVec2(nodeWidth, contentHeight), true, 
                      ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_NoMove);
    
    ImDrawList* drawList = ImGui::GetWindowDrawList();
    const float scrollX = ImGui::GetScrollX();
    
    // --- 3. TIMELINE RULER ---
    // CRITICAL FIX: Use ORIGINAL file tempo for visual layout, not current playback tempo!
    // This prevents the timeline from "zooming" when tempo multiplier changes
    const double visualTempo = fileBpm; // Use original file tempo for consistent visual layout
    const double samplesPerBeat = (60.0 / visualTempo) * getSampleRate();
    const float pixelsPerBeat = zoomX;
    const int numBars = (int)std::ceil(totalDuration / (60.0 / visualTempo * 4.0)); // Estimate bars from duration
    const float totalWidth = numBars * 4.0f * pixelsPerBeat;
    
    // CRITICAL: Reserve space for the ENTIRE timeline content so scrolling works properly
    ImGui::Dummy(ImVec2(totalWidth, timelineHeight));
    
    // Get the screen position for drawing (AFTER Dummy)
    const ImVec2 timelineStartPos = ImGui::GetItemRectMin();
    
    // Draw timeline background (only visible portion for performance)
    const float visibleLeft = timelineStartPos.x;
    const float visibleRight = visibleLeft + nodeWidth;
    drawList->AddRectFilled(
        ImVec2(visibleLeft, timelineStartPos.y), 
        ImVec2(visibleRight, timelineStartPos.y + timelineHeight), 
        IM_COL32(30, 30, 30, 255)
    );
    
    // --- SCROLL-AWARE CULLING FOR PERFORMANCE ---
    // Only draw beats that are actually visible in the current scroll position
    const int firstBeat = juce::jmax(0, static_cast<int>(scrollX / pixelsPerBeat));
    const int lastBeat = juce::jmin(numBars * 4, static_cast<int>((scrollX + nodeWidth) / pixelsPerBeat) + 1);
    
    // Draw only visible bar and beat lines
    for (int beatIndex = firstBeat; beatIndex <= lastBeat; ++beatIndex)
    {
        const bool isBarLine = (beatIndex % 4 == 0);
        const int barNumber = beatIndex / 4;
        
        // Calculate absolute position in content space
        const float x = timelineStartPos.x + (beatIndex * pixelsPerBeat);
        
        // Draw the vertical line
        drawList->AddLine(
            ImVec2(x, timelineStartPos.y),
            ImVec2(x, timelineStartPos.y + timelineHeight),
            isBarLine ? IM_COL32(140, 140, 140, 255) : IM_COL32(70, 70, 70, 255),
            isBarLine ? 2.0f : 1.0f
        );
        
        // Draw bar number label for bar lines
        if (isBarLine)
        {
            char label[8];
            snprintf(label, sizeof(label), "%d", barNumber + 1);
            drawList->AddText(ImVec2(x + 4, timelineStartPos.y + 4), IM_COL32(220, 220, 220, 255), label);
        }
    }
    
    // --- 4. PIANO ROLL GRID & NOTE RENDERING ---
    ImGui::Spacing();
    
    // CRITICAL: Calculate piano roll content height based on track count
    int currentTrack = (int)trackParam->load();
    const float trackHeight = 40.0f;
    const float pianoRollHeight = (currentTrack == -1) 
        ? (notesByTrack.size() * 30.0f + 10.0f)  // Multi-track view
        : trackHeight;                            // Single track view
    
    // CRITICAL: Reserve space for ENTIRE piano roll content (width × height)
    ImGui::Dummy(ImVec2(totalWidth, pianoRollHeight));
    
    // Get the piano roll area bounds (AFTER Dummy)
    const ImVec2 pianoRollStartPos = ImGui::GetItemRectMin();
    const ImVec2 pianoRollEndPos = ImGui::GetItemRectMax();
    
    if (currentTrack == -1)
    {
        // SHOW ALL TRACKS: Multi-track visualization like MidiLogger
        
        // Color palette for different tracks (cycling through hues)
        const ImU32 trackColors[] = {
            IM_COL32(100, 180, 255, 204),  // Blue
            IM_COL32(255, 120, 100, 204),  // Red
            IM_COL32(120, 255, 100, 204),  // Green
            IM_COL32(255, 200, 100, 204),  // Orange
            IM_COL32(200, 100, 255, 204),  // Purple
            IM_COL32(100, 255, 200, 204),  // Cyan
            IM_COL32(255, 100, 180, 204),  // Pink
            IM_COL32(220, 220, 100, 204),  // Yellow
        };
        const int numColors = sizeof(trackColors) / sizeof(trackColors[0]);
        
        const float trackHeightMulti = 30.0f;
        for (size_t trackIdx = 0; trackIdx < notesByTrack.size(); ++trackIdx)
        {
            const auto& notes = notesByTrack[trackIdx];
            if (notes.empty()) continue;
            
            // Assign color based on track index
            ImU32 noteColor = trackColors[trackIdx % numColors];
            ImU32 noteBorderColor = noteColor | IM_COL32(0, 0, 0, 51); // Slightly darker border
            
            const float trackY_top = pianoRollStartPos.y + (trackIdx * trackHeightMulti);
            const float trackY_bottom = trackY_top + trackHeightMulti - 5.0f;
            
            for (const auto& note : notes)
            {
                const float noteStartX_px = pianoRollStartPos.x + (float)(note.startTime / (60.0 / visualTempo)) * pixelsPerBeat;
                const float noteEndX_px = pianoRollStartPos.x + (float)(note.endTime / (60.0 / visualTempo)) * pixelsPerBeat;
                
                // ImGui handles clipping automatically - no manual culling needed
                
                // Draw note rectangle
                drawList->AddRectFilled(
                    ImVec2(noteStartX_px, trackY_top),
                    ImVec2(noteEndX_px, trackY_bottom),
                    noteColor,
                    3.0f // corner rounding
                );
                // Draw border
                drawList->AddRect(
                    ImVec2(noteStartX_px, trackY_top),
                    ImVec2(noteEndX_px, trackY_bottom),
                    noteBorderColor,
                    3.0f,
                    0,
                    1.2f
                );
            }
        }
    }
    else if (currentTrack >= 0 && currentTrack < (int)notesByTrack.size())
    {
        // SINGLE TRACK VIEW
        const auto& notes = notesByTrack[(size_t)currentTrack];
        
        // Draw notes
        ImU32 noteColor = IM_COL32(100, 180, 255, 204); // Blue with alpha
        ImU32 noteBorderColor = IM_COL32(150, 200, 255, 255); // Lighter blue border
        
        const float noteY_top = pianoRollStartPos.y + 5.0f;
        const float noteY_bottom = noteY_top + trackHeight - 10.0f;
        
        for (const auto& note : notes)
        {
            // Convert time (seconds) to pixels
            const float noteStartX_px = pianoRollStartPos.x + (float)(note.startTime / (60.0 / visualTempo)) * pixelsPerBeat;
            const float noteEndX_px = pianoRollStartPos.x + (float)(note.endTime / (60.0 / visualTempo)) * pixelsPerBeat;
            
            // ImGui handles clipping automatically - no manual culling needed
            
            // Draw note rectangle
            drawList->AddRectFilled(
                ImVec2(noteStartX_px, noteY_top),
                ImVec2(noteEndX_px, noteY_bottom),
                noteColor,
                4.0f // corner rounding
            );
            // Draw border
            drawList->AddRect(
                ImVec2(noteStartX_px, noteY_top),
                ImVec2(noteEndX_px, noteY_bottom),
                noteBorderColor,
                4.0f,
                0,
                1.5f
            );
        }
    }
    
    // --- 6. DRAW PLAYHEAD LINE (CRITICAL: Must be INSIDE BeginChild/EndChild for clipping!) ---
    // Draw playhead at its absolute position in the content (ImGui clips to child window)
    const float playheadX = timelineStartPos.x + (float)(currentPlaybackTime / (60.0 / visualTempo)) * pixelsPerBeat;
    
    drawList->AddLine(
        ImVec2(playheadX, timelineStartPos.y),
        ImVec2(playheadX, pianoRollEndPos.y),
        IM_COL32(255, 255, 0, 200), // Yellow playhead
        2.0f
    );
    
    // Draw a triangle handle at the top for visual reference
    drawList->AddTriangleFilled(
        ImVec2(playheadX, timelineStartPos.y),
        ImVec2(playheadX - 6.0f, timelineStartPos.y + 10.0f),
        ImVec2(playheadX + 6.0f, timelineStartPos.y + 10.0f),
        IM_COL32(255, 255, 0, 255)
    );
    
    ImGui::EndChild();
    
    // --- 5. PLAYHEAD INTERACTION (Click anywhere in timeline to seek) ---
    // Check if user clicked in the MainContent child window
    if (ImGui::IsItemHovered() && ImGui::IsMouseClicked(ImGuiMouseButton_Left))
    {
        // CRITICAL FIX: Get the child window's screen bounds (the item we just ended)
        ImVec2 childWindowMin = ImGui::GetItemRectMin(); // Top-left of visible child window
        float mouseX = ImGui::GetMousePos().x;
        
        // Calculate timeline position: mouse relative to visible window + scroll offset
        float relativeX = (mouseX - childWindowMin.x) + scrollX;
        double newTime = (relativeX / pixelsPerBeat) * (60.0 / visualTempo); // Use visualTempo
        
        // Clamp to valid range
        newTime = juce::jlimit(0.0, totalDuration, newTime);
        
        // Set the new playhead via the atomic seek mechanism
        pendingSeekTime.store(newTime);
    }
    
    // --- TRACK INFO ---
    int trackNum = (int)trackParam->load();
    if (trackNum == -1)
    {
        ImGui::Text("Viewing: All Tracks (Stacked)");
    }
    else if (trackNum >= 0 && trackNum < (int)trackInfos.size())
    {
        const auto& info = trackInfos[(size_t)trackNum];
        ImGui::Text("Track %d: %s • %d notes", 
                    trackNum + 1, 
                    info.name.isNotEmpty() ? info.name.toRawUTF8() : "Untitled",
                    info.noteCount);
    }
}
#endif

// ==============================================================================
// LEGACY UI CODE REMOVED
// Old controls (Speed, Pitch, Tempo, Loop sliders) are now accessed via parameter modulation
// The piano roll provides superior visual feedback for MIDI playback
// Speed/Pitch/Tempo/Loop parameters can still be modulated via CV inputs
// ==============================================================================

// ==============================================================================
// POLYPHONIC OUTPUTS: Dynamic pins for multi-track playback
// ==============================================================================
std::vector<DynamicPinInfo> MIDIPlayerModuleProcessor::getDynamicOutputPins() const
{
    std::vector<DynamicPinInfo> pins;
    const juce::ScopedLock lock(midiDataLock);
    
    // CRITICAL FIX: Create output pins for ALL tracks (not just those with notes)
    // This ensures pin indices match track indices for Quick Connect
    // Format: Gate 1, Pitch 1, Velo 1, Trig 1, Gate 2, Pitch 2, Velo 2, Trig 2, ...
    for (size_t i = 0; i < notesByTrack.size(); ++i)
    {
        const juce::String trackNumStr = juce::String(i + 1);
        const juce::String trackName = (i < trackInfos.size() && trackInfos[i].name.isNotEmpty()) 
            ? trackInfos[i].name 
            : ("Track " + trackNumStr);
        
        // Each track gets 4 pins: Gate, Pitch, Velocity, Trigger
        // Pin indices: track 0 = 0,1,2,3  track 1 = 4,5,6,7  etc.
        const int baseChannel = (int)i * 4;
        pins.push_back({ trackName + " Gate", baseChannel + 0, PinDataType::Gate });
        pins.push_back({ trackName + " Pitch", baseChannel + 1, PinDataType::CV });
        pins.push_back({ trackName + " Velo", baseChannel + 2, PinDataType::CV });
        pins.push_back({ trackName + " Trig", baseChannel + 3, PinDataType::Gate });
    }
    
    // Add "Num Tracks" output (Raw type for Track Mixer connection)
    pins.push_back({ "Num Tracks", kRawNumTracksChannelIndex, PinDataType::Raw });
    
    return pins;
}

void MIDIPlayerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // --- Global Inputs & Outputs (In Parallel) ---
    helpers.drawParallelPins("Speed Mod", 0, "Clock", kClockChannelIndex);
    helpers.drawParallelPins("Pitch Mod", 1, "Num Tracks", kNumTracksChannelIndex);
    helpers.drawParallelPins("Velocity Mod", 2, "Raw Num Tracks", kRawNumTracksChannelIndex);
    helpers.drawParallelPins("Reset Mod", 3, nullptr, 0);
    helpers.drawParallelPins("Loop Mod", 4, nullptr, 0);
    
    // --- Per-Track Outputs (Inputs side will be blank) ---
    int outIndex = 0;
    const int tracksToShow = std::min((int) activeTrackIndices.size(), kMaxTracks);

    for (int t = 0; t < tracksToShow; ++t)
    {
        const int srcTrack = activeTrackIndices[(size_t) t];
        juce::String base = (srcTrack < (int) trackInfos.size() && trackInfos[(size_t) srcTrack].name.isNotEmpty())
            ? trackInfos[(size_t) srcTrack].name : (juce::String("Track ") + juce::String(srcTrack+1));
        
        // Draw each track output on its own line, but on the right side of the node
        helpers.drawParallelPins(nullptr, 0, (base + " Pitch").toRawUTF8(),    outIndex++);
        helpers.drawParallelPins(nullptr, 0, (base + " Gate").toRawUTF8(),     outIndex++);
        helpers.drawParallelPins(nullptr, 0, (base + " Velocity").toRawUTF8(), outIndex++);
        helpers.drawParallelPins(nullptr, 0, (base + " Trigger").toRawUTF8(),  outIndex++);
    }
}

juce::String MIDIPlayerModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Speed Mod";
        case 1: return "Pitch Mod";
        case 2: return "Velocity Mod";
        case 3: return "Reset Mod";
        case 4: return "Loop Mod";
        default: return juce::String("In ") + juce::String(channel + 1);
    }
}

juce::String MIDIPlayerModuleProcessor::getAudioOutputLabel(int channel) const
{
    if (channel == kClockChannelIndex) return "Clock";
    if (channel == kNumTracksChannelIndex) return "Num Tracks";
    if (channel == kRawNumTracksChannelIndex) return "Raw Num Tracks";
    
    // Per-track outputs (Pitch/Gate/Velocity/Trigger)
    const int trackIndex = channel / kOutputsPerTrack;
    const int outputType = channel % kOutputsPerTrack;
    
    if (trackIndex < (int)activeTrackIndices.size())
    {
        const int srcTrack = activeTrackIndices[(size_t)trackIndex];
        juce::String base = (srcTrack < (int)trackInfos.size() && trackInfos[(size_t)srcTrack].name.isNotEmpty())
            ? trackInfos[(size_t)srcTrack].name : (juce::String("Track ") + juce::String(srcTrack+1));
        
        switch (outputType)
        {
            case 0: return base + " Pitch";
            case 1: return base + " Gate";
            case 2: return base + " Velocity";
            case 3: return base + " Trigger";
        }
    }
    
    return "Out " + juce::String(channel + 1);
}

// Parameter bus contract implementation
bool MIDIPlayerModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    if (paramId == "speed") { outBusIndex = 0; outChannelIndexInBus = 0; return true; }
    if (paramId == "pitch") { outBusIndex = 1; outChannelIndexInBus = 0; return true; }
    if (paramId == "velocity") { outBusIndex = 2; outChannelIndexInBus = 0; return true; }
    if (paramId == "reset") { outBusIndex = 3; outChannelIndexInBus = 0; return true; }
    if (paramId == "loop") { outBusIndex = 4; outChannelIndexInBus = 0; return true; }
    return false;
}


================================================================================
FILE: guides\XML_SAVING_AND_LOADING_HOW_TO.md
================================================================================


# XML Preset Saving and Loading - Complete Technical Guide

**Target Audience:** AI assistants and developers who need to understand the complete XML preset system in this JUCE-based modular synthesizer project.

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Architecture](#architecture)
3. [The Save Process](#the-save-process)
4. [The Load Process](#the-load-process)
5. [XML File Structure](#xml-file-structure)
6. [Module Parameter Serialization](#module-parameter-serialization)
7. [Connection Management](#connection-management)
8. [UI State Persistence](#ui-state-persistence)
9. [Special Cases](#special-cases)
10. [Code Examples](#code-examples)

---

## System Overview

This modular synthesizer uses **XML-based presets** to save and restore complete patch configurations including:

- **Modules** (VCO, VCF, VCA, effects, utilities, etc.)
- **Module parameters** (frequency, waveform, envelope settings, etc.)
- **Audio connections** (routing between modules)
- **Modulation routings** (CV parameter modulation)
- **UI state** (node positions, colors, mute states)
- **VST plugin instances** (including their internal state)

The system is built on **JUCE's ValueTree** and **AudioProcessorValueTreeState (APVTS)** framework, which provides:
- Automatic parameter management
- Undo/redo support
- Thread-safe parameter access
- XML serialization/deserialization

---

## Architecture

### Key Classes

#### 1. **ModularSynthProcessor** (`juce/Source/audio/graph/ModularSynthProcessor.cpp`)
The core audio graph that manages all modules and connections.

**Responsibilities:**
- Maintains the `AudioProcessorGraph` (JUCE's internal audio routing system)
- Tracks all modules via **logical IDs** (stable across save/load)
- Implements `getStateInformation()` and `setStateInformation()` for serialization
- Manages audio connections between modules

#### 2. **ModuleProcessor** (`juce/Source/audio/modules/ModuleProcessor.h`)
Abstract base class for all synthesizer modules.

**Responsibilities:**
- Provides `getAPVTS()` for parameter access
- Implements `getExtraStateTree()` for module-specific state (file paths, etc.)
- Handles audio processing via `processBlock()`

#### 3. **PresetCreatorComponent** (`juce/Source/preset_creator/PresetCreatorComponent.cpp`)
The UI layer that triggers save/load operations.

**Responsibilities:**
- Presents file chooser dialogs
- Orchestrates save/load sequences
- Handles mute state management during save
- Updates UI after load

#### 4. **ImGuiNodeEditorComponent** (`juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`)
The visual node graph editor.

**Responsibilities:**
- Stores node positions, colors, sizes
- Manages mute states
- Provides `getUiValueTree()` for UI serialization
- Applies UI state via `applyUiValueTreeNow()`

---

## The Save Process

### High-Level Flow

```
User clicks Save → File chooser → Unmute nodes → Get synth state → 
Re-mute nodes → Append UI state → Write XML file
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doSave()`)

```cpp
void PresetCreatorComponent::doSave()
{
    // Find default save location (project-root/Synth_presets)
    juce::File startDir;
    auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
    // Search up to 8 parent directories for Synth_presets folder
    auto dir = exeDir;
    for (int i = 0; i < 8 && dir.exists(); ++i)
    {
        auto candidate = dir.getSiblingFile("Synth_presets");
        if (candidate.exists() && candidate.isDirectory()) 
        { 
            startDir = candidate; 
            break; 
        }
        dir = dir.getParentDirectory();
    }
    
    // Launch async file chooser
    saveChooser = std::make_unique<juce::FileChooser>("Save preset", startDir, "*.xml");
    saveChooser->launchAsync(juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc)
    {
        // Callback continues in Step 2...
    });
}
```

#### Step 2: Unmute Nodes (Critical Fix)

**Problem:** Muted nodes have their connections replaced with bypass routing in the audio graph. If we save while nodes are muted, we'll save the bypass routing instead of the original connections.

**Solution:** Temporarily unmute all nodes before getting state, then immediately re-mute them.

```cpp
// 1. Get list of currently muted nodes
std::vector<juce::uint32> currentlyMutedNodes;
if (editor)
{
    for (const auto& pair : editor->mutedNodeStates)
    {
        currentlyMutedNodes.push_back(pair.first);
    }
    
    // 2. Temporarily UNMUTE all of them
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->unmuteNode(lid);
    }
}

// 3. Force synth to apply connection changes immediately
if (synth)
{
    synth->commitChanges();
}
```

#### Step 3: Get Synth State (`ModularSynthProcessor::getStateInformation()`)

This is where the core serialization happens.

```cpp
void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock(moduleLock);
    
    // Create root ValueTree
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    // === SERIALIZE MODULES ===
    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32)kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int)logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                // Special handling for VST modules
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    // Standard module: save APVTS parameters
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    // Save extra state (file paths, custom data)
                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    // === SERIALIZE CONNECTIONS ===
    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32)c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32)c.destination.nodeID.uid;
        
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            // Module-to-module connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int)dstIt->second, nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            // Module-to-output connection
            cv.setProperty("srcId", (int)srcIt->second, nullptr);
            cv.setProperty("srcChan", (int)c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int)c.destination.channelIndex, nullptr);
        }
        else
        {
            continue; // Skip internal graph connections
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    // === CONVERT TO XML ===
    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}
```

**Key Concepts:**

- **Logical IDs:** Each module gets a stable logical ID (1, 2, 3...) that persists across sessions
- **Node UIDs:** JUCE's internal graph node IDs (unstable, change on reload)
- **Parameter Storage:** Uses JUCE's APVTS `.copyState()` to serialize all parameters
- **Extra State:** Custom data (file paths, text, etc.) stored separately via `getExtraStateTree()`

#### Step 4: Re-mute Nodes and Add UI State

```cpp
// 5. IMMEDIATELY RE-MUTE the nodes to return editor to visible state
if (editor)
{
    for (juce::uint32 lid : currentlyMutedNodes)
    {
        editor->muteNode(lid);
    }
}

// 6. Force synth to apply the re-mute changes
if (synth)
{
    synth->commitChanges();
}

// === ADD UI STATE ===
juce::ValueTree presetVT = juce::ValueTree::fromXml(*xml);
if (editor)
{
    juce::ValueTree ui = editor->getUiValueTree();
    presetVT.addChild(ui, -1, nullptr);
}

// Write to file
f.replaceWithText(presetVT.createXml()->toString());
```

The UI state includes:
- Node X/Y positions
- Node colors
- Mute states
- Node widths/heights (for custom-sized modules)

---

## The Load Process

### High-Level Flow

```
User clicks Load → File chooser → Parse XML → Clear existing state → 
Recreate modules → Restore parameters → Recreate connections → Apply UI state
```

### Detailed Steps

#### Step 1: User Interface (`PresetCreatorComponent::doLoad()`)

```cpp
void PresetCreatorComponent::doLoad()
{
    // Find default location
    juce::File startDir;
    // (same directory search logic as save)
    
    loadChooser = std::make_unique<juce::FileChooser>("Load preset", startDir, "*.xml");
    loadChooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this](const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData(mb);
                
                // First: set the synth state
                synth->setStateInformation(mb.getData(), (int)mb.getSize());
                
                // Then: parse and apply UI state
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse(mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml(*xml);
                        auto ui = vt.getChildWithName("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow(ui);
                    }
                }
                
                refreshModulesList();
                log.insertTextAtCaret("Loaded: " + f.getFullPathName() + "\n");
            }
        } catch (...) {
            juce::Logger::writeToLog("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}
```

#### Step 2: Set State (`ModularSynthProcessor::setStateInformation()`)

This is the most complex part of the system.

```cpp
void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    
    // Parse XML
    std::unique_ptr<juce::XmlElement> xml(
        juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes))
    );
    
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML");
        return;
    }

    // === CLEAR EXISTING STATE ===
    clearAll();
    
    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // === RESTORE GLOBAL SETTINGS ===
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found");
        return;
    }
    
    // === FIND HIGHEST LOGICAL ID ===
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    // === RECREATE MODULES ===
    std::map<juce::uint32, NodeID> logicalToNodeId;
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module")) continue;

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module: logicalId=" + juce::String(logicalId) + 
                                " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            // Check if this is a VST module
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr)
                    {
                        // Find VST in known plugins list
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE] Loading VST: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                break;
                            }
                        }
                    }
                }
            }
            
            if (!isVstModule)
            {
                // Standard module
                nodeId = addModule(type, false);
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                if (!isVstModule)
                {
                    // Update logical ID mapping
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;

                // === RESTORE STATE (ORDER MATTERS!) ===
                
                // FIRST: Restore extra state
                // This loads files, initializes custom data structures, etc.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE] Restored extra state.");
                    }
                }

                // SECOND: Restore parameters
                // This overwrites any defaults set by extra state loading
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE] Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE] ERROR: Node creation failed!");
            }
        }
    }
    
    // === RESTORE CONNECTIONS ===
    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connected " + juce::String(connectedCount) + " connections.");
    }

    // === FINALIZE ===
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}
```

**Critical Points:**

1. **Order of restoration:** Extra state BEFORE parameters (file loading sets defaults, then parameters overwrite them)
2. **Logical ID assignment:** Must match saved logical IDs for connections to work
3. **VST handling:** Separate code path for loading VST plugins vs. built-in modules
4. **Connection restoration:** Uses logical ID mapping to reconnect modules

#### Step 3: Apply UI State (`ImGuiNodeEditorComponent::applyUiValueTreeNow()`)

```cpp
void ImGuiNodeEditorComponent::applyUiValueTreeNow(const juce::ValueTree& uiTree)
{
    if (!uiTree.isValid()) return;
    
    // Clear existing UI state
    nodePositions.clear();
    nodeColors.clear();
    mutedNodeStates.clear();
    
    // Restore node positions and properties
    for (int i = 0; i < uiTree.getNumChildren(); ++i)
    {
        auto child = uiTree.getChild(i);
        if (child.hasType("node"))
        {
            int logicalId = child.getProperty("id", 0);
            float x = child.getProperty("x", 0.0f);
            float y = child.getProperty("y", 0.0f);
            
            nodePositions[logicalId] = ImVec2(x, y);
            
            // Restore color if saved
            if (child.hasProperty("color"))
            {
                juce::uint32 colorInt = child.getProperty("color", 0);
                nodeColors[logicalId] = ImColor(colorInt);
            }
            
            // Restore mute state
            if (child.getProperty("muted", false))
            {
                mutedNodeStates[logicalId] = true;
                // Apply mute routing
                muteNode(logicalId);
            }
            
            // Restore width override
            if (child.hasProperty("width"))
            {
                float width = child.getProperty("width", 0.0f);
                nodeWidthOverrides[logicalId] = width;
            }
        }
    }
    
    graphNeedsRebuild = true;
}
```

---

## XML File Structure

### Complete Example

```xml
<?xml version="1.0" encoding="UTF-8"?>

<ModularSynthPreset version="1">
  <modules>
    <module logicalId="3" type="VCO">
      <params>
        <VCOParams>
          <PARAM id="frequency" value="440.0"/>
          <PARAM id="waveform" value="0.0"/>
        </VCOParams>
      </params>
    </module>
    
    <module logicalId="4" type="Sample_Loader">
      <params>
        <SampleLoaderParams>
          <PARAM id="trimStart" value="0.0"/>
          <PARAM id="trimEnd" value="1.0"/>
          <PARAM id="cvMax" value="1.0"/>
          <PARAM id="cvMin" value="0.0"/>
        </SampleLoaderParams>
      </params>
      <extra>
        <SampleLoaderState audioFilePath="H:\audio\samples\kick.wav" 
                          loopMode="0" loopStart="0" loopEnd="44100"/>
      </extra>
    </module>
    
    <module logicalId="5" type="Pro-Q 3">
      <extra>
        <VstHostState fileOrIdentifier="C:\VST\FabFilter Pro-Q 3.vst3"
                      name="Pro-Q 3" 
                      manufacturerName="FabFilter" 
                      version="3.2.1.0"
                      pluginFormatName="VST3" 
                      pluginState="(base64 encoded state data)"/>
      </extra>
    </module>
  </modules>
  
  <connections>
    <connection srcId="3" srcChan="0" dstId="4" dstChan="0"/>
    <connection srcId="4" srcChan="0" dstId="5" dstChan="0"/>
    <connection srcId="5" srcChan="0" dstId="output" dstChan="0"/>
  </connections>
  
  <NodeEditorUI>
    <node id="3" x="100.0" y="200.0" color="4294901760" width="200.0"/>
    <node id="4" x="400.0" y="200.0" muted="true"/>
    <node id="5" x="700.0" y="200.0"/>
    <node id="0" x="1000.0" y="200.0"/>
  </NodeEditorUI>
</ModularSynthPreset>
```

### Structure Breakdown

#### Root Element
```xml
<ModularSynthPreset version="1">
```
- `version`: Schema version (for future compatibility)

#### Modules Section
```xml
<modules>
  <module logicalId="X" type="ModuleType">
    <params>
      <ModuleTypeParams>
        <PARAM id="paramId" value="0.5"/>
      </ModuleTypeParams>
    </params>
    <extra>
      <!-- Module-specific state -->
    </extra>
  </module>
</modules>
```

- `logicalId`: Stable identifier for this module instance
- `type`: Module type string (must match factory registration)
- `params`: APVTS-generated parameter state
- `extra`: Custom state (file paths, text, etc.)

#### Connections Section
```xml
<connections>
  <connection srcId="1" srcChan="0" dstId="2" dstChan="1"/>
  <connection srcId="2" srcChan="0" dstId="output" dstChan="0"/>
</connections>
```

- `srcId`: Source module logical ID
- `srcChan`: Source output channel (0-indexed)
- `dstId`: Destination module logical ID (or "output")
- `dstChan`: Destination input channel (0-indexed)

#### UI Section
```xml
<NodeEditorUI>
  <node id="X" x="123.45" y="678.90" color="4294901760" muted="true" width="250.0"/>
</NodeEditorUI>
```

- `id`: Module logical ID (or 0 for output node)
- `x`, `y`: Node position in canvas space
- `color`: ARGB color as 32-bit integer (optional)
- `muted`: Boolean mute state (optional)
- `width`: Custom width override (optional)

---

## Module Parameter Serialization

### How APVTS Works

**AudioProcessorValueTreeState (APVTS)** is JUCE's parameter management system. Each module creates an APVTS in its constructor:

```cpp
class VCOModuleProcessor : public ModuleProcessor
{
public:
    VCOModuleProcessor()
        : ModuleProcessor(/* bus layout */),
          apvts(*this, nullptr, "VCOParams", createParameterLayout())
    {
    }
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
    {
        juce::AudioProcessorValueTreeState::ParameterLayout layout;
        
        layout.add(std::make_unique<juce::AudioParameterFloat>(
            "frequency",                    // Parameter ID
            "Frequency",                    // Display name
            juce::NormalisableRange<float>(20.0f, 20000.0f, 0.01f, 0.3f),
            440.0f));                       // Default value
        
        layout.add(std::make_unique<juce::AudioParameterChoice>(
            "waveform",
            "Waveform",
            juce::StringArray{"Sine", "Square", "Saw", "Triangle"},
            0));
        
        return layout;
    }
};
```

### Serialization

When we call `apvts.copyState()`, JUCE creates a ValueTree:

```xml
<VCOParams>
  <PARAM id="frequency" value="440.0"/>
  <PARAM id="waveform" value="0.0"/>
</VCOParams>
```

### Deserialization

When we call `apvts.replaceState(params)`, JUCE:
1. Finds each parameter by ID
2. Converts the string value to the parameter's native type
3. Sets the parameter value
4. Triggers any attached listeners

---

## Connection Management

### Connection Storage

Connections are stored in `juce::AudioProcessorGraph` as:

```cpp
struct Connection
{
    struct EndPoint
    {
        NodeID nodeID;
        int channelIndex;
    } source, destination;
};
```

### Channel Types

- **Audio channels:** 0, 1, 2, ... (stereo = channels 0 and 1)
- **MIDI channel:** `juce::AudioProcessorGraph::midiChannelIndex` (special constant)

### Connection Creation

```cpp
bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel,
                                    const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection{
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    // Check for duplicate
    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            return true; // Already connected
        }
    }

    // Add connection (deferred until commitChanges())
    return internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}
```

### Why Logical IDs?

**Problem:** JUCE's `NodeID::uid` values are unstable - they change every time you load a preset.

**Solution:** We maintain a separate `logicalId` system:

```cpp
// Mapping stored in ModularSynthProcessor
std::map<juce::uint32, LogicalModule> logicalIdToModule;

struct LogicalModule
{
    juce::AudioProcessorGraph::NodeID nodeID;  // Changes on reload
    juce::String type;
};
```

When saving:
```cpp
// Convert NodeID → Logical ID
nodeUidToLogical[nodeID.uid] = logicalId;
```

When loading:
```cpp
// Convert Logical ID → NodeID (new UID)
logicalToNodeId[logicalId] = newNodeId;
```

---

## UI State Persistence

### What UI State Includes

- **Node positions** (X, Y coordinates)
- **Node colors** (custom color per node)
- **Mute states** (which nodes are bypassed)
- **Width overrides** (custom widths for nodes)
- **Canvas pan/zoom** (viewport state)

### Generation (`ImGuiNodeEditorComponent::getUiValueTree()`)

```cpp
juce::ValueTree ImGuiNodeEditorComponent::getUiValueTree() const
{
    juce::ValueTree ui("NodeEditorUI");
    
    // Save all module nodes
    for (const auto& pair : nodePositions)
    {
        int logicalId = pair.first;
        ImVec2 pos = pair.second;
        
        juce::ValueTree nodeVT("node");
        nodeVT.setProperty("id", logicalId, nullptr);
        nodeVT.setProperty("x", pos.x, nullptr);
        nodeVT.setProperty("y", pos.y, nullptr);
        
        // Optional: color
        if (nodeColors.count(logicalId))
        {
            ImU32 colorInt = nodeColors.at(logicalId);
            nodeVT.setProperty("color", (int)colorInt, nullptr);
        }
        
        // Optional: mute state
        if (mutedNodeStates.count(logicalId) && mutedNodeStates.at(logicalId))
        {
            nodeVT.setProperty("muted", true, nullptr);
        }
        
        // Optional: width override
        if (nodeWidthOverrides.count(logicalId))
        {
            nodeVT.setProperty("width", nodeWidthOverrides.at(logicalId), nullptr);
        }
        
        ui.addChild(nodeVT, -1, nullptr);
    }
    
    // Always save output node position
    if (outputNodePosition.x != 0.0f || outputNodePosition.y != 0.0f)
    {
        juce::ValueTree outputVT("node");
        outputVT.setProperty("id", 0, nullptr); // Output node is always ID 0
        outputVT.setProperty("x", outputNodePosition.x, nullptr);
        outputVT.setProperty("y", outputNodePosition.y, nullptr);
        ui.addChild(outputVT, -1, nullptr);
    }
    
    return ui;
}
```

### Restoration (shown earlier in Load Process)

---

## Special Cases

### 1. VST Plugins

VST plugins have opaque internal state that we can't inspect. JUCE provides:

```cpp
// Get plugin state
juce::MemoryBlock stateData;
plugin->getStateInformation(stateData);

// Restore plugin state
plugin->setStateInformation(stateData.getData(), stateData.getSize());
```

We wrap this in `VstHostModuleProcessor` and store:
- Plugin identifier (file path)
- Plugin metadata (name, manufacturer, version)
- Plugin state (base64 encoded in XML)

### 2. Sample Loader

The Sample Loader module needs to store:
- File path (absolute path to audio file)
- Trim points (start/end in samples)
- Loop settings

This uses "extra state":

```cpp
juce::ValueTree SampleLoaderModuleProcessor::getExtraStateTree()
{
    juce::ValueTree state("SampleLoaderState");
    state.setProperty("audioFilePath", currentFilePath, nullptr);
    state.setProperty("loopMode", (int)loopMode, nullptr);
    state.setProperty("loopStart", loopStart, nullptr);
    state.setProperty("loopEnd", loopEnd, nullptr);
    return state;
}

void SampleLoaderModuleProcessor::setExtraStateTree(const juce::ValueTree& state)
{
    if (!state.hasType("SampleLoaderState")) return;
    
    currentFilePath = state.getProperty("audioFilePath", "").toString();
    loopMode = (LoopMode)(int)state.getProperty("loopMode", 0);
    loopStart = state.getProperty("loopStart", 0);
    loopEnd = state.getProperty("loopEnd", 0);
    
    // Load the audio file
    if (currentFilePath.isNotEmpty())
    {
        loadAudioFile(juce::File(currentFilePath));
    }
}
```

### 3. Comment Module

Comments store text and dimensions:

```cpp
<extra>
  <CommentState title="My Note" 
                text="This is important!" 
                width="250.0" 
                height="150.0"/>
</extra>
```

### 4. Mute States

Muting is complex because it modifies the audio graph:

**When a node is muted:**
1. Store original connections
2. Remove all connections to/from node
3. Create bypass connections (input → output directly)

**When saving with muted nodes:**
1. Temporarily unmute all nodes (restore original connections)
2. Save the unmuted connections
3. Immediately re-mute nodes

**When loading with muted nodes:**
1. Load normal connections
2. Apply mute states from UI tree
3. This triggers the mute logic, which replaces connections with bypasses

---

## Code Examples

### Example 1: Creating a Simple Module with APVTS

```cpp
// SimpleGainModule.h
#pragma once
#include "ModuleProcessor.h"

class SimpleGainModuleProcessor : public ModuleProcessor
{
public:
    SimpleGainModuleProcessor();
    ~SimpleGainModuleProcessor() override = default;
    
    const juce::String getName() const override { return "Simple Gain"; }
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
    void processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&) override;
    
private:
    juce::AudioProcessorValueTreeState apvts;
    
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SimpleGainModuleProcessor)
};

// SimpleGainModule.cpp
#include "SimpleGainModuleProcessor.h"

SimpleGainModuleProcessor::SimpleGainModuleProcessor()
    : ModuleProcessor(BusesProperties()
                       .withInput("Input", juce::AudioChannelSet::stereo())
                       .withOutput("Output", juce::AudioChannelSet::stereo())),
      apvts(*this, nullptr, "SimpleGainParams", createParameterLayout())
{
}

juce::AudioProcessorValueTreeState::ParameterLayout SimpleGainModuleProcessor::createParameterLayout()
{
    juce::AudioProcessorValueTreeState::ParameterLayout layout;
    
    layout.add(std::make_unique<juce::AudioParameterFloat>(
        "gain",                                           // Parameter ID
        "Gain",                                          // Display name
        juce::NormalisableRange<float>(0.0f, 2.0f),     // Range
        1.0f));                                          // Default value
    
    return layout;
}

void SimpleGainModuleProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // Read parameter value
    float gain = apvts.getRawParameterValue("gain")->load();
    
    // Apply gain
    buffer.applyGain(gain);
    
    // Update telemetry for visualization
    updateOutputTelemetry(buffer);
}
```

**What gets saved automatically:**
```xml
<module logicalId="X" type="Simple Gain">
  <params>
    <SimpleGainParams>
      <PARAM id="gain" value="1.5"/>
    </SimpleGainParams>
  </params>
</module>
```

### Example 2: Adding Extra State (File Path)

```cpp
class MyFileModuleProcessor : public ModuleProcessor
{
public:
    // ... (constructor, APVTS, etc.)
    
    // Override these two methods
    juce::ValueTree getExtraStateTree() override
    {
        juce::ValueTree state("MyFileModuleState");
        state.setProperty("filePath", currentFilePath, nullptr);
        state.setProperty("customData", someOtherData, nullptr);
        return state;
    }
    
    void setExtraStateTree(const juce::ValueTree& state) override
    {
        if (!state.hasType("MyFileModuleState")) return;
        
        currentFilePath = state.getProperty("filePath", "").toString();
        someOtherData = state.getProperty("customData", 0);
        
        // Do something with the loaded data
        if (currentFilePath.isNotEmpty())
        {
            loadFile(juce::File(currentFilePath));
        }
    }
    
private:
    juce::String currentFilePath;
    int someOtherData = 0;
};
```

**What gets saved:**
```xml
<module logicalId="X" type="MyFileModule">
  <params>
    <!-- APVTS parameters -->
  </params>
  <extra>
    <MyFileModuleState filePath="C:\audio\file.wav" customData="42"/>
  </extra>
</module>
```

### Example 3: Programmatic Save/Load

```cpp
// Save preset programmatically
void savePresetToFile(ModularSynthProcessor* synth, const juce::File& file)
{
    juce::MemoryBlock mb;
    synth->getStateInformation(mb);
    
    auto xml = juce::XmlDocument::parse(mb.toString());
    if (xml)
    {
        file.replaceWithText(xml->toString());
    }
}

// Load preset programmatically
void loadPresetFromFile(ModularSynthProcessor* synth, const juce::File& file)
{
    if (!file.existsAsFile()) return;
    
    juce::MemoryBlock mb;
    file.loadFileAsData(mb);
    
    synth->setStateInformation(mb.getData(), (int)mb.getSize());
}
```

---

## Summary

The XML preset system in this modular synthesizer is built on these key principles:

1. **Logical IDs** provide stable module references across save/load cycles
2. **JUCE's APVTS** handles automatic parameter serialization
3. **Extra state trees** allow modules to store custom data (files, text, etc.)
4. **Connection serialization** uses logical IDs instead of unstable node IDs
5. **UI state separation** keeps visual data separate from audio graph data
6. **Mute state handling** requires careful connection management during save
7. **VST support** wraps opaque plugin state in a standardized format

The complete flow is:
```
Save: UI → Get State → Serialize → Write XML
Load: Read XML → Parse → Recreate Graph → Apply UI
```

This architecture provides:
- ✅ **Stability:** Presets work across app restarts
- ✅ **Extensibility:** Easy to add new module types
- ✅ **Debugging:** Human-readable XML format
- ✅ **Performance:** Deferred graph updates via `commitChanges()`
- ✅ **Completeness:** Captures all module state, connections, and UI layout

---

## Key Files Reference

| File | Purpose |
|------|---------|
| `ModularSynthProcessor.cpp` | Core save/load implementation |
| `ModularSynthProcessor.h` | Logical ID management |
| `ModuleProcessor.h` | Base class for all modules |
| `PresetCreatorComponent.cpp` | UI save/load dialogs |
| `ImGuiNodeEditorComponent.cpp` | UI state management |
| `VCOModuleProcessor.cpp` | Example APVTS usage |
| `SampleLoaderModuleProcessor.cpp` | Example extra state usage |
| `VstHostModuleProcessor.cpp` | VST plugin state handling |

---

## Common Pitfalls

### ❌ Don't: Use Node UID in Connections
```cpp
// BAD: Node UIDs change on reload!
save_connection(node->nodeID.uid, otherNode->nodeID.uid);
```

### ✅ Do: Use Logical IDs
```cpp
// GOOD: Logical IDs are stable
save_connection(logicalId1, logicalId2);
```

### ❌ Don't: Save Parameters Manually
```cpp
// BAD: Duplicate work, error-prone
xml->setAttribute("frequency", frequency);
xml->setAttribute("waveform", waveform);
```

### ✅ Do: Use APVTS
```cpp
// GOOD: Automatic, correct, handles undo/redo
juce::ValueTree params = apvts.copyState();
```

### ❌ Don't: Forget commitChanges()
```cpp
// BAD: Changes not applied to audio thread
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
// Missing: synth->commitChanges();
```

### ✅ Do: Always Commit
```cpp
// GOOD: Audio graph updated properly
synth->addModule("VCO");
synth->connect(node1, 0, node2, 0);
synth->commitChanges(); // ✓
```

---

**End of Guide**

This document provides a complete understanding of the XML preset save/load system. For specific module implementation details, refer to the individual module processor files in `juce/Source/audio/modules/`.



================================================================================
FILE: juce\Source\audio\graph\ModularSynthProcessor.cpp
================================================================================


#include "ModularSynthProcessor.h"
#include "../modules/AudioInputModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/VCOModuleProcessor.h"
#include "../modules/VCFModuleProcessor.h"
#include "../modules/VCAModuleProcessor.h"
#include "../modules/NoiseModuleProcessor.h"
#include "../modules/LFOModuleProcessor.h"
#include "../modules/ADSRModuleProcessor.h"
#include "../modules/MixerModuleProcessor.h"
#include "../modules/DelayModuleProcessor.h"
#include "../modules/ReverbModuleProcessor.h"
#include "../modules/AttenuverterModuleProcessor.h"
#include "../modules/ScopeModuleProcessor.h"
#include "../modules/SAndHModuleProcessor.h"
#include "../modules/StepSequencerModuleProcessor.h"
#include "../modules/MathModuleProcessor.h"
#include "../modules/MapRangeModuleProcessor.h"
#include "../modules/RandomModuleProcessor.h"
#include "../modules/RateModuleProcessor.h"
#include "../modules/QuantizerModuleProcessor.h"
#include "../modules/SequentialSwitchModuleProcessor.h"
#include "../modules/LogicModuleProcessor.h"
#include "../modules/ValueModuleProcessor.h"
#include "../modules/ClockDividerModuleProcessor.h"
#include "../modules/WaveshaperModuleProcessor.h"
#include "../modules/MultiBandShaperModuleProcessor.h"
#include "../modules/GranulatorModuleProcessor.h"
#include "../modules/HarmonicShaperModuleProcessor.h"
#include "../modules/TrackMixerModuleProcessor.h"
#include "../modules/TTSPerformerModuleProcessor.h"
#include "../modules/ComparatorModuleProcessor.h"
#include "../modules/VocalTractFilterModuleProcessor.h"
#include "../modules/VstHostModuleProcessor.h"
#include "../modules/SampleLoaderModuleProcessor.h"
#include "../modules/FunctionGeneratorModuleProcessor.h"
#include "../modules/TimePitchModuleProcessor.h"
#include "../modules/DebugModuleProcessor.h"
#include "../modules/CommentModuleProcessor.h"
#include "../modules/MIDIPlayerModuleProcessor.h"
#include "../modules/PolyVCOModuleProcessor.h"
#include "../modules/BestPracticeNodeProcessor.h"
#include "../modules/BPMMonitorModuleProcessor.h"
#include "../modules/ShapingOscillatorModuleProcessor.h"
#include "../modules/MultiSequencerModuleProcessor.h"
#include "../modules/LagProcessorModuleProcessor.h"
#include "../modules/DeCrackleModuleProcessor.h"
#include "../modules/CVMixerModuleProcessor.h"
#include "../modules/GraphicEQModuleProcessor.h"
#include "../modules/FrequencyGraphModuleProcessor.h"
#include "../modules/ChorusModuleProcessor.h"
#include "../modules/PhaserModuleProcessor.h"
#include "../modules/CompressorModuleProcessor.h"
#include "../modules/RecordModuleProcessor.h"
#include "../modules/LimiterModuleProcessor.h"
#include "../modules/GateModuleProcessor.h"
#include "../modules/DriveModuleProcessor.h"
#include "../modules/SnapshotSequencerModuleProcessor.h"
#include "../modules/MIDICVModuleProcessor.h"
#include "../modules/MIDIFadersModuleProcessor.h"
#include "../modules/MIDIKnobsModuleProcessor.h"
#include "../modules/MIDIButtonsModuleProcessor.h"
#include "../modules/MIDIJogWheelModuleProcessor.h"
#include "../modules/MIDIPadModuleProcessor.h"
#include "../modules/MidiLoggerModuleProcessor.h"
#include "../modules/TempoClockModuleProcessor.h"
#include "../modules/PhysicsModuleProcessor.h"
#include "../modules/StrokeSequencerModuleProcessor.h"
#include "../modules/AnimationModuleProcessor.h"
#include "../modules/WebcamLoaderModule.h"
#include "../modules/VideoFileLoaderModule.h"
#include "../modules/MovementDetectorModule.h"
#include "../modules/HumanDetectorModule.h"
#include "../modules/PoseEstimatorModule.h"
#include "../modules/HandTrackerModule.h"
#include "../modules/FaceTrackerModule.h"
#include "../modules/ObjectDetectorModule.h"
#include "../modules/ColorTrackerModule.h"
#include "../modules/ContourDetectorModule.h"
#include "../modules/SemanticSegmentationModule.h"
#include "../modules/InletModuleProcessor.h"
#include "../modules/OutletModuleProcessor.h"
#include "../modules/MetaModuleProcessor.h"

ModularSynthProcessor::ModularSynthProcessor()
    : juce::AudioProcessor(BusesProperties()
                            .withInput("Input", juce::AudioChannelSet::stereo(), true)
                            .withOutput("Output", juce::AudioChannelSet::stereo(), true)),
      apvts(*this, nullptr, "ModularSynthParams", {})
{
    internalGraph = std::make_unique<juce::AudioProcessorGraph>();

    using IOProcessor = juce::AudioProcessorGraph::AudioGraphIOProcessor;
    audioInputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioInputNode));
    audioOutputNode = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::audioOutputNode));
    midiInputNode  = internalGraph->addNode(std::make_unique<IOProcessor>(IOProcessor::midiInputNode));

    internalGraph->addConnection({ { midiInputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex },
                                   { audioOutputNode->nodeID, juce::AudioProcessorGraph::midiChannelIndex } });
    
    probeScopeNode = internalGraph->addNode(std::make_unique<ScopeModuleProcessor>());
    probeScopeNodeId = probeScopeNode->nodeID;
    juce::Logger::writeToLog("[ModularSynth] Initialized probe scope with nodeID: " + juce::String(probeScopeNodeId.uid));
    
    // Create BPM Monitor node (always present, undeletable like output node)
    auto bpmMonitor = std::make_unique<BPMMonitorModuleProcessor>();
    bpmMonitor->setLogicalId(999); // Special ID to make it undeletable
    bpmMonitorNode = internalGraph->addNode(std::move(bpmMonitor));
    if (auto* processor = dynamic_cast<ModuleProcessor*>(bpmMonitorNode->getProcessor()))
        processor->setParent(this);
    juce::Logger::writeToLog("[ModularSynth] Initialized BPM Monitor with logicalID: 999");
    
    activeAudioProcessors.store(std::make_shared<const std::vector<std::shared_ptr<ModuleProcessor>>>());
    
    m_voices.resize(8);
    for (auto& voice : m_voices)
    {
        voice.isActive = false;
        voice.noteNumber = -1;
        voice.velocity = 0.0f;
        voice.age = 0;
        voice.targetModuleLogicalId = 0;
    }
}

ModularSynthProcessor::~ModularSynthProcessor() {}

void ModularSynthProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    internalGraph->setPlayConfigDetails(getTotalNumInputChannels(), getTotalNumOutputChannels(), sampleRate, samplesPerBlock);
    internalGraph->prepareToPlay(sampleRate, samplesPerBlock);
}

void ModularSynthProcessor::releaseResources()
{
    internalGraph->releaseResources();
}

//==============================================================================
// Multi-MIDI Device Support
//==============================================================================

void ModularSynthProcessor::processMidiWithDeviceInfo(const std::vector<MidiMessageWithDevice>& messages)
{
    const juce::ScopedLock lock(midiActivityLock);
    currentBlockMidiMessages = messages;
    
    // DEBUG LOGGING
    if (!messages.empty())
    {
        juce::Logger::writeToLog("[ModularSynth] processMidiWithDeviceInfo received " + 
                                juce::String(messages.size()) + " MIDI messages");
    }
    
    // Update activity tracking
    currentActivity.deviceChannelActivity.clear();
    currentActivity.deviceNames.clear();
    
    for (const auto& msg : messages)
    {
        // Skip system realtime messages
        if (msg.message.isMidiClock() || msg.message.isActiveSense())
            continue;
        
        int channel = msg.message.getChannel();
        if (channel >= 1 && channel <= 16)
        {
            int channelIndex = channel - 1;  // 0-15
            currentActivity.deviceChannelActivity[msg.deviceIndex][channelIndex] = true;
            currentActivity.deviceNames[msg.deviceIndex] = msg.deviceName;
        }
    }
}

ModularSynthProcessor::MidiActivityState ModularSynthProcessor::getMidiActivityState() const
{
    const juce::ScopedLock lock(midiActivityLock);
    return currentActivity;
}

//==============================================================================
// Audio Processing
//==============================================================================

void ModularSynthProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    try {
        // NOTE: Both tempo and division control flags are managed by Tempo Clock modules directly
        // No resets here to avoid flickering in UI
        
        // --- ADD THIS LOGGING BLOCK ---
        if (!midiMessages.isEmpty())
        {
            // If we get this message, it means MIDI is successfully reaching the synth.
            juce::Logger::writeToLog("[SynthCore] Received " + juce::String(midiMessages.getNumEvents()) + " MIDI events this block.");
            m_midiActivityFlag.store(true);
        }
        // --- END OF BLOCK ---
        
        if (m_transportState.isPlaying)
        {
            m_samplePosition += buffer.getNumSamples();
            m_transportState.songPositionSeconds = m_samplePosition / getSampleRate();
            m_transportState.songPositionBeats = (m_transportState.songPositionSeconds / 60.0) * m_transportState.bpm;
        }

        // --- FINAL THREAD-SAFE FIX ---
        auto currentProcessors = activeAudioProcessors.load();
        if (currentProcessors)
        {
            // Iterate over the safe, shared list.
            for (const auto& modulePtr : *currentProcessors)
            {
                // SAFETY NET + GRANULAR LOGGING
                if (modulePtr != nullptr)
                {
                    // Log the memory address before calling the function
                    // juce::Logger::writeToLog("[AudioThread] Ticking module at 0x" + juce::String::toHexString((juce::pointer_sized_int)modulePtr.get()));
                    modulePtr->setTimingInfo(m_transportState);
                }
                else
                {
                    // This should never happen with the shared_ptr fix, but if it does, it's critical info.
                    juce::Logger::writeToLog("[AudioThread] CRITICAL WARNING: Encountered nullptr in active processor list!");
                }
            }
        }
        // --- END OF FIX ---
        
        // === MULTI-MIDI DEVICE SUPPORT: Distribute device-aware MIDI to modules ===
        // This happens BEFORE voice management and graph processing
        // Modules receive device info and can filter by device/channel
        {
            const juce::ScopedLock lock(midiActivityLock);
            
            // DEBUG: Log every processBlock attempt to check the buffer
            static int checkCount = 0;
            static int distributionCount = 0;
            checkCount++;
            
            if (!currentBlockMidiMessages.empty())
            {
                distributionCount++;
                
                // Log only first few times to avoid spam
                if (distributionCount <= 5)
                {
                    juce::Logger::writeToLog("[ModularSynth processBlock] CHECK #" + juce::String(checkCount) + 
                                            " - Found " + juce::String(currentBlockMidiMessages.size()) + " messages to distribute");
                }
                
                if (internalGraph)
                {
                    int nodeCount = internalGraph->getNodes().size();
                    int moduleCount = 0;
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Distributing to " + juce::String(nodeCount) + " nodes");
                    }
                    
                    for (auto* node : internalGraph->getNodes())
                    {
                        if (auto* module = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                        {
                            moduleCount++;
                            module->handleDeviceSpecificMidi(currentBlockMidiMessages);
                        }
                    }
                    
                    if (distributionCount <= 5)
                    {
                        juce::Logger::writeToLog("[ModularSynth] Called handleDeviceSpecificMidi on " + 
                                                juce::String(moduleCount) + " modules");
                    }
                    
                    // Merge device-aware MIDI into standard MidiBuffer for backward compatibility
                    for (const auto& msg : currentBlockMidiMessages)
                    {
                        midiMessages.addEvent(msg.message, 0);
                    }
                    
                    // Clear for next block
                    currentBlockMidiMessages.clear();
                }
                else
                {
                    juce::Logger::writeToLog("[ModularSynth] WARNING: Have MIDI messages but internalGraph is null!");
                }
            }
        }
        // === END MULTI-MIDI DISTRIBUTION ===
        
        if (m_voiceManagerEnabled && !m_voices.empty())
        {
            juce::MidiBuffer processedMidi;
            for (const auto metadata : midiMessages)
            {
                const auto msg = metadata.getMessage();
                if (msg.isNoteOn())
                {
                    int voiceIndex = findFreeVoice();
                    if (voiceIndex < 0) voiceIndex = findOldestVoice();
                    if (voiceIndex >= 0)
                    {
                        assignNoteToVoice(voiceIndex, msg);
                        processedMidi.addEvent(msg, metadata.samplePosition);
                    }
                }
                else if (msg.isNoteOff())
                {
                    releaseVoice(msg);
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
                else
                {
                    processedMidi.addEvent(msg, metadata.samplePosition);
                }
            }
            midiMessages.swapWith(processedMidi);
        }
        
        internalGraph->processBlock(buffer, midiMessages);
        static int silentCtr = 0;
        if (buffer.getMagnitude(0, buffer.getNumSamples()) < 1.0e-6f)
        {
            if ((++silentCtr % 600) == 0)
                juce::Logger::writeToLog("[ModularSynthProcessor] silent block from internal graph");
        }
        else
        {
            silentCtr = 0;
        }
    } catch (const std::exception& e) {
        juce::Logger::writeToLog(juce::String("[ModSynth][FATAL] Exception in processBlock: ") + e.what());
        buffer.clear();
        return;
    } catch (...) {
        juce::Logger::writeToLog("[ModSynth][FATAL] Unknown exception in processBlock");
        buffer.clear();
        return;
    }
}

void ModularSynthProcessor::getStateInformation(juce::MemoryBlock& destData)
{
    const juce::ScopedLock lock (moduleLock);
    juce::ValueTree root("ModularSynthPreset");
    root.setProperty("version", 1, nullptr);
    root.setProperty("bpm", m_transportState.bpm, nullptr);

    juce::ValueTree modsVT("modules");
    std::map<juce::uint32, juce::uint32> nodeUidToLogical;
    for (const auto& kv : logicalIdToModule)
    {
        const juce::uint32 logicalId = kv.first;
        const auto nodeUID = (juce::uint32) kv.second.nodeID.uid;
        nodeUidToLogical[nodeUID] = logicalId;

        juce::ValueTree mv("module");
        mv.setProperty("logicalId", (int) logicalId, nullptr);
        mv.setProperty("type", kv.second.type, nullptr);
        auto itNode = modules.find(nodeUID);
        if (itNode != modules.end())
        {
            if (auto* modProc = dynamic_cast<ModuleProcessor*>(itNode->second->getProcessor()))
            {
                if (auto* vstHost = dynamic_cast<VstHostModuleProcessor*>(modProc))
                {
                    if (auto extra = vstHost->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
                else
                {
                    juce::ValueTree params = modProc->getAPVTS().copyState();
                    juce::ValueTree paramsWrapper("params");
                    paramsWrapper.addChild(params, -1, nullptr);
                    mv.addChild(paramsWrapper, -1, nullptr);

                    if (auto extra = modProc->getExtraStateTree(); extra.isValid())
                    {
                        juce::ValueTree extraWrapper("extra");
                        extraWrapper.addChild(extra, -1, nullptr);
                        mv.addChild(extraWrapper, -1, nullptr);
                    }
                }
            }
        }
        modsVT.addChild(mv, -1, nullptr);
    }
    root.addChild(modsVT, -1, nullptr);

    juce::ValueTree connsVT("connections");
    for (const auto& c : internalGraph->getConnections())
    {
        const juce::uint32 srcUID = (juce::uint32) c.source.nodeID.uid;
        const juce::uint32 dstUID = (juce::uint32) c.destination.nodeID.uid;
        juce::ValueTree cv("connection");
        auto srcIt = nodeUidToLogical.find(srcUID);
        auto dstIt = nodeUidToLogical.find(dstUID);
        if (srcIt != nodeUidToLogical.end() && dstIt != nodeUidToLogical.end())
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", (int) dstIt->second, nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else if (srcIt != nodeUidToLogical.end() && c.destination.nodeID == audioOutputNode->nodeID)
        {
            cv.setProperty("srcId", (int) srcIt->second, nullptr);
            cv.setProperty("srcChan", (int) c.source.channelIndex, nullptr);
            cv.setProperty("dstId", juce::String("output"), nullptr);
            cv.setProperty("dstChan", (int) c.destination.channelIndex, nullptr);
        }
        else
        {
            continue;
        }
        connsVT.addChild(cv, -1, nullptr);
    }
    root.addChild(connsVT, -1, nullptr);

    if (auto xml = root.createXml())
    {
        juce::MemoryOutputStream mos(destData, false);
        xml->writeTo(mos);
    }
}

void ModularSynthProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    juce::Logger::writeToLog("--- Restoring Snapshot ---");
    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse(juce::String::fromUTF8((const char*)data, (size_t)sizeInBytes)));
    if (!xml || !xml->hasTagName("ModularSynthPreset"))
    {
        juce::Logger::writeToLog("[STATE] ERROR: Invalid XML or wrong root tag. Aborting restore.");
        return;
    }

    clearAll();
    juce::Logger::writeToLog("[STATE] Cleared existing state.");

    juce::ValueTree root = juce::ValueTree::fromXml(*xml);
    
    // Restore global transport settings
    m_transportState.bpm = root.getProperty("bpm", 120.0);
    juce::Logger::writeToLog("[STATE] Restored BPM to " + juce::String(m_transportState.bpm));
    
    auto modsVT = root.getChildWithName("modules");
    if (!modsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <modules> block found in preset.");
        return;
    }
    
    juce::Logger::writeToLog("[STATE] Found <modules> block with " + juce::String(modsVT.getNumChildren()) + " children.");
    juce::uint32 maxId = 0;
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (mv.hasType("module"))
        {
            maxId = juce::jmax(maxId, (juce::uint32)(int)mv.getProperty("logicalId", 0));
        }
    }
    nextLogicalId = maxId + 1;

    std::map<juce::uint32, NodeID> logicalToNodeId;
    juce::Logger::writeToLog("[STATE] Starting module recreation pass...");
    
    for (int i = 0; i < modsVT.getNumChildren(); ++i)
    {
        auto mv = modsVT.getChild(i);
        if (!mv.hasType("module"))
        {
            juce::Logger::writeToLog("[STATE] Skipping non-module child at index " + juce::String(i));
            continue;
        }

        const juce::uint32 logicalId = (juce::uint32)(int)mv.getProperty("logicalId", 0);
        const juce::String type = mv.getProperty("type").toString();

        juce::Logger::writeToLog("[STATE] Processing module " + juce::String(i) + ": logicalId=" + juce::String(logicalId) + " type='" + type + "'");

        if (logicalId > 0 && type.isNotEmpty())
        {
            NodeID nodeId;
            
            auto extraWrapper = mv.getChildWithName("extra");
            bool isVstModule = false;
            
            if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
            {
                auto extraState = extraWrapper.getChild(0);
                if (extraState.hasType("VstHostState"))
                {
                    isVstModule = true;
                    juce::Logger::writeToLog("[STATE]   Loading VST module...");
                    
                    juce::String identifier = extraState.getProperty("fileOrIdentifier", "").toString();
                    
                    if (identifier.isNotEmpty() && pluginFormatManager != nullptr && knownPluginList != nullptr)
                    {
                        bool found = false;
                        for (const auto& desc : knownPluginList->getTypes())
                        {
                            if (desc.fileOrIdentifier == identifier)
                            {
                                juce::Logger::writeToLog("[STATE]   Found VST to load: " + desc.name);
                                nodeId = addVstModule(*pluginFormatManager, desc, logicalId);
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found)
                        {
                            juce::Logger::writeToLog("[STATE]   ERROR: VST plugin not found: " + identifier);
                        }
                    }
                    else
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: No plugin identifier or format manager/list not available");
                    }
                    
                    if (nodeId.uid == 0)
                    {
                        juce::Logger::writeToLog("[STATE]   ERROR: Failed to create VST module, skipping...");
                        continue;
                    }
                }
            }
            
            if (!isVstModule)
            {
                juce::Logger::writeToLog("[STATE]   Calling addModule('" + type + "')...");
                nodeId = addModule(type, false);
                juce::Logger::writeToLog("[STATE]   addModule returned nodeId.uid=" + juce::String(nodeId.uid));
            }
            
            auto* node = internalGraph->getNodeForId(nodeId);
            
            if (node)
            {
                juce::Logger::writeToLog("[STATE]   Node created successfully.");
                
                if (!isVstModule)
                {
                    for (auto it = logicalIdToModule.begin(); it != logicalIdToModule.end(); )
                    {
                        if (it->second.nodeID == nodeId)
                            it = logicalIdToModule.erase(it);
                        else
                            ++it;
                    }
                    logicalIdToModule[logicalId] = LogicalModule{ nodeId, type };
                }
                
                logicalToNodeId[logicalId] = nodeId;
                juce::Logger::writeToLog("[STATE]   Mapped logicalId " + juce::String(logicalId) + " to nodeId.uid " + juce::String(nodeId.uid));

                // --- FIX: Restore extra state FIRST ---
                // This will load the clip and reset trim sliders to defaults.
                auto extraWrapper = mv.getChildWithName("extra");
                if (extraWrapper.isValid() && extraWrapper.getNumChildren() > 0)
                {
                    auto extra = extraWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->setExtraStateTree(extra);
                        juce::Logger::writeToLog("[STATE]   Restored extra state.");
                    }
                }

                // Now restore parameters SECOND.
                // This will overwrite the temporary default trim values with the correct saved values.
                auto paramsWrapper = mv.getChildWithName("params");
                if (paramsWrapper.isValid() && paramsWrapper.getNumChildren() > 0)
                {
                    auto params = paramsWrapper.getChild(0);
                    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
                    {
                        mp->getAPVTS().replaceState(params);
                        juce::Logger::writeToLog("[STATE]   Restored parameters.");
                    }
                }
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   ERROR: Node creation failed! nodeId.uid was " + juce::String(nodeId.uid) + " but getNodeForId returned nullptr.");
            }
        }
        else
        {
            juce::Logger::writeToLog("[STATE]   Skipping module: logicalId=" + juce::String(logicalId) + " (valid=" + juce::String(logicalId > 0 ? "yes" : "no") + ") type='" + type + "' (empty=" + juce::String(type.isEmpty() ? "yes" : "no") + ")");
        }
    }
    
    juce::Logger::writeToLog("[STATE] Module recreation complete. Created " + juce::String(logicalToNodeId.size()) + " modules.");

    auto connsVT = root.getChildWithName("connections");
    if (connsVT.isValid())
    {
        juce::Logger::writeToLog("[STATE] Restoring " + juce::String(connsVT.getNumChildren()) + " connections...");
        int connectedCount = 0;
        int skippedCount = 0;
        
        for (int i = 0; i < connsVT.getNumChildren(); ++i)
        {
            auto cv = connsVT.getChild(i);
            if (!cv.hasType("connection")) continue;

            const juce::uint32 srcId = (juce::uint32)(int)cv.getProperty("srcId");
            const int srcChan = (int)cv.getProperty("srcChan", 0);
            const bool dstIsOutput = cv.getProperty("dstId").toString() == "output";
            const juce::uint32 dstId = dstIsOutput ? 0 : (juce::uint32)(int)cv.getProperty("dstId");
            const int dstChan = (int)cv.getProperty("dstChan", 0);

            NodeID srcNodeId = logicalToNodeId[srcId];
            NodeID dstNodeId = dstIsOutput ? audioOutputNode->nodeID : logicalToNodeId[dstId];

            if (srcNodeId.uid != 0 && dstNodeId.uid != 0)
            {
                connect(srcNodeId, srcChan, dstNodeId, dstChan);
                connectedCount++;
            }
            else
            {
                juce::Logger::writeToLog("[STATE]   WARNING: Skipping connection " + juce::String(i) + 
                                        ": srcId=" + juce::String(srcId) + " (uid=" + juce::String(srcNodeId.uid) + 
                                        ") → dstId=" + (dstIsOutput ? "output" : juce::String(dstId)) + 
                                        " (uid=" + juce::String(dstNodeId.uid) + ")");
                skippedCount++;
            }
        }
        
        juce::Logger::writeToLog("[STATE] Connection restore complete: " + juce::String(connectedCount) + 
                                " connected, " + juce::String(skippedCount) + " skipped.");
    }
    else
    {
        juce::Logger::writeToLog("[STATE] WARNING: No <connections> block found in preset.");
    }


    juce::Logger::writeToLog("[STATE] Calling commitChanges()...");
    commitChanges();
    juce::Logger::writeToLog("[STATE] Restore complete.");
}

namespace {
    static juce::String toLowerId (const juce::String& s)
    {
        return s.toLowerCase();
    }

    using Creator = std::function<std::unique_ptr<juce::AudioProcessor>()>;

    static std::map<juce::String, Creator>& getModuleFactory()
    {
        static std::map<juce::String, Creator> factory;
        static bool initialised = false;
        if (!initialised)
        {
            auto reg = [&](const juce::String& key, Creator c) { factory.emplace(toLowerId(key), std::move(c)); };

            reg("vco", []{ return std::make_unique<VCOModuleProcessor>(); });
            reg("audio_input", []{ return std::make_unique<AudioInputModuleProcessor>(); });
            reg("vcf", []{ return std::make_unique<VCFModuleProcessor>(); });
            reg("vca", []{ return std::make_unique<VCAModuleProcessor>(); });
            reg("noise", []{ return std::make_unique<NoiseModuleProcessor>(); });
            reg("lfo", []{ return std::make_unique<LFOModuleProcessor>(); });
            reg("adsr", []{ return std::make_unique<ADSRModuleProcessor>(); });
            reg("mixer", []{ return std::make_unique<MixerModuleProcessor>(); });
            reg("cv_mixer", []{ return std::make_unique<CVMixerModuleProcessor>(); });
            reg("track_mixer", []{ return std::make_unique<TrackMixerModuleProcessor>(); });
            reg("delay", []{ return std::make_unique<DelayModuleProcessor>(); });
            reg("reverb", []{ return std::make_unique<ReverbModuleProcessor>(); });
            reg("attenuverter", []{ return std::make_unique<AttenuverterModuleProcessor>(); });
            reg("scope", []{ return std::make_unique<ScopeModuleProcessor>(); });
            reg("frequency_graph", []{ return std::make_unique<FrequencyGraphModuleProcessor>(); });
            reg("s_and_h", []{ return std::make_unique<SAndHModuleProcessor>(); });
            reg("sequencer", []{ return std::make_unique<StepSequencerModuleProcessor>(); });
            reg("math", []{ return std::make_unique<MathModuleProcessor>(); });
            reg("map_range", []{ return std::make_unique<MapRangeModuleProcessor>(); });
            reg("comparator", []{ return std::make_unique<ComparatorModuleProcessor>(); });
            reg("random", []{ return std::make_unique<RandomModuleProcessor>(); });
            reg("rate", []{ return std::make_unique<RateModuleProcessor>(); });
            reg("quantizer", []{ return std::make_unique<QuantizerModuleProcessor>(); });
            reg("sequential_switch", []{ return std::make_unique<SequentialSwitchModuleProcessor>(); });
            reg("logic", []{ return std::make_unique<LogicModuleProcessor>(); });
            reg("clock_divider", []{ return std::make_unique<ClockDividerModuleProcessor>(); });
            reg("waveshaper", []{ return std::make_unique<WaveshaperModuleProcessor>(); });
            reg("8bandshaper", []{ return std::make_unique<MultiBandShaperModuleProcessor>(); });
            reg("granulator", []{ return std::make_unique<GranulatorModuleProcessor>(); });
            reg("harmonic_shaper", []{ return std::make_unique<HarmonicShaperModuleProcessor>(); });
            reg("debug", []{ return std::make_unique<DebugModuleProcessor>(); });
            reg("input_debug", []{ return std::make_unique<InputDebugModuleProcessor>(); });
            reg("vocal_tract_filter", []{ return std::make_unique<VocalTractFilterModuleProcessor>(); });
            reg("value", []{ return std::make_unique<ValueModuleProcessor>(); });
            reg("tts_performer", []{ return std::make_unique<TTSPerformerModuleProcessor>(); });
            reg("sample_loader", []{ return std::make_unique<SampleLoaderModuleProcessor>(); });
            reg("function_generator", []{ return std::make_unique<FunctionGeneratorModuleProcessor>(); });
            reg("timepitch", []{ return std::make_unique<TimePitchModuleProcessor>(); });
            reg("midi_player", []{ return std::make_unique<MIDIPlayerModuleProcessor>(); });
            reg("polyvco", []{ return std::make_unique<PolyVCOModuleProcessor>(); });
            reg("best_practice", []{ return std::make_unique<BestPracticeNodeProcessor>(); });
            reg("shaping_oscillator", []{ return std::make_unique<ShapingOscillatorModuleProcessor>(); });
            reg("multi_sequencer", []{ return std::make_unique<MultiSequencerModuleProcessor>(); });
            reg("lag_processor", []{ return std::make_unique<LagProcessorModuleProcessor>(); });
            reg("de_crackle", []{ return std::make_unique<DeCrackleModuleProcessor>(); });
            reg("graphic_eq", []{ return std::make_unique<GraphicEQModuleProcessor>(); });
            reg("chorus", []{ return std::make_unique<ChorusModuleProcessor>(); });
            reg("phaser", []{ return std::make_unique<PhaserModuleProcessor>(); });
            reg("compressor", []{ return std::make_unique<CompressorModuleProcessor>(); });
            reg("recorder", []{ return std::make_unique<RecordModuleProcessor>(); });
            reg("limiter", []{ return std::make_unique<LimiterModuleProcessor>(); });
            reg("gate", []{ return std::make_unique<GateModuleProcessor>(); });
            reg("drive", []{ return std::make_unique<DriveModuleProcessor>(); });
            reg("comment", []{ return std::make_unique<CommentModuleProcessor>(); });
            reg("snapshot_sequencer", []{ return std::make_unique<SnapshotSequencerModuleProcessor>(); });
            reg("midi_cv", []{ return std::make_unique<MIDICVModuleProcessor>(); });
            reg("midi_faders", []{ return std::make_unique<MIDIFadersModuleProcessor>(); });
            reg("midi_knobs", []{ return std::make_unique<MIDIKnobsModuleProcessor>(); });
            reg("midi_buttons", []{ return std::make_unique<MIDIButtonsModuleProcessor>(); });
            reg("midi_jog_wheel", []{ return std::make_unique<MIDIJogWheelModuleProcessor>(); });
            reg("midi_pads", []{ return std::make_unique<MIDIPadModuleProcessor>(); });
            reg("midi_logger", []{ return std::make_unique<MidiLoggerModuleProcessor>(); });
            reg("tempo_clock", []{ return std::make_unique<TempoClockModuleProcessor>(); });
            reg("physics", []{ return std::make_unique<PhysicsModuleProcessor>(); });
            reg("animation", []{ return std::make_unique<AnimationModuleProcessor>(); });
            reg("bpm_monitor", []{ return std::make_unique<BPMMonitorModuleProcessor>(); });
            reg("webcam_loader", []{ return std::make_unique<WebcamLoaderModule>(); });
            reg("video_file_loader", []{ return std::make_unique<VideoFileLoaderModule>(); });
            reg("movement_detector", []{ return std::make_unique<MovementDetectorModule>(); });
            reg("human_detector", []{ return std::make_unique<HumanDetectorModule>(); });
            reg("pose_estimator", []{ return std::make_unique<PoseEstimatorModule>(); });
            reg("hand_tracker", []{ return std::make_unique<HandTrackerModule>(); });
            reg("face_tracker", []{ return std::make_unique<FaceTrackerModule>(); });
            reg("object_detector", []{ return std::make_unique<ObjectDetectorModule>(); });
            reg("color_tracker", []{ return std::make_unique<ColorTrackerModule>(); });
            reg("contour_detector", []{ return std::make_unique<ContourDetectorModule>(); });
            reg("semantic_segmentation", []{ return std::make_unique<SemanticSegmentationModule>(); });
            reg("stroke_sequencer", []{ return std::make_unique<StrokeSequencerModuleProcessor>(); });
            
            reg("meta module", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("metamodule", []{ return std::make_unique<MetaModuleProcessor>(); });
            reg("inlet", []{ return std::make_unique<InletModuleProcessor>(); });
            reg("outlet", []{ return std::make_unique<OutletModuleProcessor>(); });

            initialised = true;
        }
        return factory;
    }
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addModule(const juce::String& moduleType, bool commit)
{
    const juce::ScopedLock lock (moduleLock);
    auto& factory = getModuleFactory();
    const juce::String key = moduleType.toLowerCase();
    std::unique_ptr<juce::AudioProcessor> processor;

    if (auto it = factory.find(key); it != factory.end())
        processor = it->second();

    if (! processor)
    {
        for (const auto& kv : factory)
            if (moduleType.equalsIgnoreCase(kv.first)) { processor = kv.second(); break; }
    }

    if (processor)
    {
        auto node = internalGraph->addNode(std::move(processor), {}, juce::AudioProcessorGraph::UpdateKind::none);
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setParent(this);
        modules[(juce::uint32) node->nodeID.uid] = node;
        const juce::uint32 logicalId = nextLogicalId++;
        logicalIdToModule[logicalId] = LogicalModule{ node->nodeID, moduleType };
        if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
            mp->setLogicalId(logicalId);
        
        if (moduleType.equalsIgnoreCase("audio_input"))
        {
            std::vector<int> defaultMapping = {0, 1};
            setAudioInputChannelMapping(node->nodeID, defaultMapping);
        }
        
        if (commit)
        {
            // Ensure the new module is immediately active
            commitChanges();
        }
        
        return node->nodeID;
    }

    juce::Logger::writeToLog("[ModSynth][WARN] Unknown module type: " + moduleType);
    return {};
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc,
    juce::uint32 logicalIdToAssign)
{
    juce::String errorMessage;
    std::unique_ptr<juce::AudioPluginInstance> instance = 
        formatManager.createPluginInstance(vstDesc, getSampleRate(), getBlockSize(), errorMessage);

    if (instance == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] Could not create VST instance: " + errorMessage);
        return {};
    }

    auto wrapper = std::make_unique<VstHostModuleProcessor>(std::move(instance), vstDesc);
    
    auto node = internalGraph->addNode(std::move(wrapper), {}, juce::AudioProcessorGraph::UpdateKind::none);

    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setParent(this);
    
    modules[(juce::uint32) node->nodeID.uid] = node;
    
    logicalIdToModule[logicalIdToAssign] = LogicalModule{ node->nodeID, vstDesc.name };
    
    if (auto* mp = dynamic_cast<ModuleProcessor*>(node->getProcessor()))
        mp->setLogicalId(logicalIdToAssign);
    
    juce::Logger::writeToLog("[ModSynth] Added VST module: " + vstDesc.name + " with logical ID " + juce::String(logicalIdToAssign));
    return node->nodeID;
}

ModularSynthProcessor::NodeID ModularSynthProcessor::addVstModule(
    juce::AudioPluginFormatManager& formatManager,
    const juce::PluginDescription& vstDesc)
{
    const juce::uint32 logicalId = nextLogicalId++;
    auto nodeId = addVstModule(formatManager, vstDesc, logicalId);
    
    if (nodeId.uid != 0)
        commitChanges();
    
    return nodeId;
}

void ModularSynthProcessor::removeModule(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;
    const juce::ScopedLock lock(moduleLock); // Ensure thread-safe access

    // --- LOGGING ---
    if (auto* node = internalGraph->getNodeForId(nodeID))
    {
        if (auto* proc = node->getProcessor())
        {
            juce::Logger::writeToLog("[GraphSync] Deleting module L-ID " + juce::String(getLogicalIdForNode(nodeID)) + 
                                   " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
        }
    }
    // --- END LOGGING ---

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    internalGraph->removeNode(nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    
    modules.erase((juce::uint32) nodeID.uid);
    if (logicalId != 0)
    {
        logicalIdToModule.erase(logicalId);
    }
}

bool ModularSynthProcessor::connect(const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };

    for (const auto& existing : internalGraph->getConnections())
    {
        if (existing.source.nodeID == sourceNodeID &&
            existing.source.channelIndex == sourceChannel &&
            existing.destination.nodeID == destNodeID &&
            existing.destination.channelIndex == destChannel)
        {
            juce::Logger::writeToLog("[ModSynth][INFO] Skipping duplicate connection [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                     + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
            return true;
        }
    }

    const bool ok = internalGraph->addConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
    if (! ok)
    {
        juce::Logger::writeToLog("[ModSynth][WARN] Failed to connect [" + juce::String(sourceNodeID.uid) + ":" + juce::String(sourceChannel)
                                 + "] -> [" + juce::String(destNodeID.uid) + ":" + juce::String(destChannel) + "]");
    }
    return ok;
}

void ModularSynthProcessor::commitChanges()
{
    internalGraph->rebuild();
    
    if (getSampleRate() > 0 && getBlockSize() > 0)
    {
        internalGraph->prepareToPlay(getSampleRate(), getBlockSize());
    }

    juce::Logger::writeToLog("--- Modular Synth Internal Patch State ---");
    juce::Logger::writeToLog("Num Nodes: " + juce::String(internalGraph->getNodes().size()));
    juce::Logger::writeToLog("Num Connections: " + juce::String(internalGraph->getConnections().size()));
    for (const auto& node : internalGraph->getNodes())
    {
        auto* p = node->getProcessor();
        juce::String name = p ? p->getName() : juce::String("<null>");
        const int ins  = p ? p->getTotalNumInputChannels()  : -1;
        const int outs = p ? p->getTotalNumOutputChannels() : -1;
        juce::Logger::writeToLog("  Node: id=" + juce::String(node->nodeID.uid) + " name='" + name + "' ins=" + juce::String(ins) + " outs=" + juce::String(outs));
    }
    for (const auto& conn : internalGraph->getConnections())
    {
        juce::Logger::writeToLog("  Connection: [" + juce::String(conn.source.nodeID.uid) + ":" + juce::String(conn.source.channelIndex)
            + "] -> [" + juce::String(conn.destination.nodeID.uid) + ":" + juce::String(conn.destination.channelIndex) + "]");
    }
    juce::Logger::writeToLog("-----------------------------------------");
    
    for (const auto& kv : logicalIdToModule)
    {
        if (ModuleProcessor* mp = getModuleForLogical(kv.first))
        {
            mp->setLogicalId(kv.first);
        }
    }
    
    // --- FINAL THREAD-SAFE FIX: Rebuild the list of active processors for the audio thread ---
    auto newProcessors = std::make_shared<std::vector<std::shared_ptr<ModuleProcessor>>>();
    {
        const juce::ScopedLock lock(moduleLock);
        newProcessors->reserve(logicalIdToModule.size());
        juce::Logger::writeToLog("[GraphSync] Building new processor list...");
        for (const auto& pair : logicalIdToModule)
        {
            // Find the Node::Ptr from the modules map
            auto modIt = modules.find((juce::uint32)pair.second.nodeID.uid);
            if (modIt != modules.end())
            {
                auto nodePtr = modIt->second; // This is a Node::Ptr (shared_ptr<Node>)
                if (auto* proc = dynamic_cast<ModuleProcessor*>(nodePtr->getProcessor()))
                {
                    // Create a shared_ptr to the processor with a custom deleter that keeps the Node alive
                    auto processor = std::shared_ptr<ModuleProcessor>(proc, [nodePtr](ModuleProcessor*) {
                        // Custom deleter: just hold the nodePtr, don't actually delete the processor
                        // When this shared_ptr is destroyed, the nodePtr will be released
                    });
                    newProcessors->push_back(processor);
                    juce::Logger::writeToLog("  [+] Adding module L-ID " + juce::String(pair.first) + 
                                           " (ptr: 0x" + juce::String::toHexString((int64_t)proc) + ")");
                }
            }
        }
    }
    activeAudioProcessors.store(newProcessors);
    juce::Logger::writeToLog("[GraphSync] Updated active processor list for audio thread with " + juce::String(newProcessors->size()) + " modules.");
}

void ModularSynthProcessor::clearAll()
{
    const juce::ScopedLock lock (moduleLock);
    
    // --- LOGGING ---
    juce::Logger::writeToLog("[GraphSync] clearAll() initiated - removing " + juce::String(logicalIdToModule.size()) + " modules");
    // --- END LOGGING ---
    
    for (const auto& kv : logicalIdToModule)
    {
        internalGraph->removeNode(kv.second.nodeID, juce::AudioProcessorGraph::UpdateKind::none);
    }

    modules.clear();
    logicalIdToModule.clear();
    nextLogicalId = 1;

    commitChanges();
}

void ModularSynthProcessor::clearAllConnections()
{
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex && 
            conn.destination.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearOutputConnections()
{
    if (audioOutputNode == nullptr)
        return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == audioOutputNode->nodeID)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }
    commitChanges();
}

void ModularSynthProcessor::clearConnectionsForNode(const NodeID& nodeID)
{
    if (nodeID.uid == 0) return;

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == nodeID || conn.destination.nodeID == nodeID)
        {
            if (conn.source.channelIndex != juce::AudioProcessorGraph::midiChannelIndex)
            {
                internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            }
        }
    }

    const juce::uint32 logicalId = getLogicalIdForNode(nodeID);

    commitChanges();
}

void ModularSynthProcessor::setAudioInputChannelMapping(const NodeID& audioInputNodeId, const std::vector<int>& channelMap)
{
    if (audioInputNode == nullptr)
    {
        juce::Logger::writeToLog("[ModSynth][ERROR] setAudioInputChannelMapping called but main audioInputNode is null.");
        return;
    }

    juce::String mapStr;
    for (int i = 0; i < (int)channelMap.size(); ++i)
    {
        if (i > 0) mapStr += ", ";
        mapStr += juce::String(channelMap[i]);
    }
    juce::Logger::writeToLog("[ModSynth] Remapping Audio Input Module " + juce::String(audioInputNodeId.uid) +
                             " to channels: [" + mapStr + "]");

    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.source.nodeID == audioInputNode->nodeID && conn.destination.nodeID == audioInputNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
        }
    }

    for (int moduleChannel = 0; moduleChannel < (int)channelMap.size(); ++moduleChannel)
    {
        int hardwareChannel = channelMap[moduleChannel];
        internalGraph->addConnection({ { audioInputNode->nodeID, hardwareChannel }, { audioInputNodeId, moduleChannel } }, 
                                     juce::AudioProcessorGraph::UpdateKind::none);
    }

    commitChanges();
}

std::vector<std::pair<juce::uint32, juce::String>> ModularSynthProcessor::getModulesInfo() const
{
    const juce::ScopedLock lock (moduleLock);
    std::vector<std::pair<juce::uint32, juce::String>> out;
    out.reserve(logicalIdToModule.size());
    for (const auto& kv : logicalIdToModule)
        out.emplace_back(kv.first, kv.second.type);
    return out;
}

juce::AudioProcessorGraph::NodeID ModularSynthProcessor::getNodeIdForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return {};
    return it->second.nodeID;
}

juce::uint32 ModularSynthProcessor::getLogicalIdForNode (const NodeID& nodeId) const
{
    const juce::ScopedLock lock (moduleLock);
    for (const auto& kv : logicalIdToModule)
        if (kv.second.nodeID == nodeId)
            return kv.first;
    return 0;
}

bool ModularSynthProcessor::disconnect (const NodeID& sourceNodeID, int sourceChannel, const NodeID& destNodeID, int destChannel)
{
    juce::AudioProcessorGraph::Connection connection {
        { sourceNodeID, sourceChannel },
        { destNodeID, destChannel }
    };
    return internalGraph->removeConnection(connection, juce::AudioProcessorGraph::UpdateKind::none);
}

std::vector<ModularSynthProcessor::ConnectionInfo> ModularSynthProcessor::getConnectionsInfo() const
{
    std::vector<ConnectionInfo> out;
    for (const auto& c : internalGraph->getConnections())
    {
        ConnectionInfo info;
        info.srcLogicalId = getLogicalIdForNode(c.source.nodeID);
        info.srcChan = c.source.channelIndex;
        info.dstLogicalId = getLogicalIdForNode(c.destination.nodeID);
        info.dstChan = c.destination.channelIndex;
        info.dstIsOutput = (c.destination.nodeID == audioOutputNode->nodeID);
        if (info.srcLogicalId != 0 && (info.dstLogicalId != 0 || info.dstIsOutput))
            out.push_back(info);
    }
    return out;
}


ModuleProcessor* ModularSynthProcessor::getModuleForLogical (juce::uint32 logicalId) const
{
    const juce::ScopedLock lock (moduleLock);
    auto it = logicalIdToModule.find(logicalId);
    if (it == logicalIdToModule.end()) return nullptr;
    if (auto* node = internalGraph->getNodeForId(it->second.nodeID))
        return dynamic_cast<ModuleProcessor*>(node->getProcessor());
    return nullptr;
}

juce::String ModularSynthProcessor::getModuleTypeForLogical(juce::uint32 logicalId) const
{
    auto it = logicalIdToModule.find(logicalId);
    if (it != logicalIdToModule.end())
    {
        return it->second.type;
    }
    return {};
}

// === COMPREHENSIVE DIAGNOSTICS SYSTEM ===

juce::String ModularSynthProcessor::getSystemDiagnostics() const
{
    juce::String result = "=== MODULAR SYNTH SYSTEM DIAGNOSTICS ===\n\n";
    
    result += "Total Modules: " + juce::String((int)logicalIdToModule.size()) + "\n";
    result += "Next Logical ID: " + juce::String((int)nextLogicalId) + "\n\n";
    
    result += "=== MODULES ===\n";
    for (const auto& pair : logicalIdToModule)
    {
        result += "Logical ID " + juce::String((int)pair.first) + ": " + pair.second.type + 
                 " (Node ID: " + juce::String((int)pair.second.nodeID.uid) + ")\n";
    }
    result += "\n";
    
    result += getConnectionDiagnostics() + "\n";
    
    result += "=== GRAPH STATE ===\n";
    result += "Total Nodes: " + juce::String(internalGraph->getNumNodes()) + "\n";
    result += "Total Connections: (not available)\n";
    
    return result;
}

juce::String ModularSynthProcessor::getModuleDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (module)
    {
        return module->getAllDiagnostics();
    }
    else
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
}

juce::String ModularSynthProcessor::getModuleParameterRoutingDiagnostics(juce::uint32 logicalId) const
{
    auto* module = getModuleForLogical(logicalId);
    if (!module)
    {
        return "Module with Logical ID " + juce::String((int)logicalId) + " not found!";
    }
    
    juce::String result = "=== PARAMETER ROUTING DIAGNOSTICS ===\n";
    result += "Module: " + module->getName() + "\n\n";
    
    auto params = module->getParameters();
    
    for (int i = 0; i < params.size(); ++i)
    {
        auto* param = params[i];
        if (auto* paramWithId = dynamic_cast<juce::AudioProcessorParameterWithID*>(param))
        {
            int busIndex, channelIndex;
            if (module->getParamRouting(paramWithId->paramID, busIndex, channelIndex))
            {
                int absoluteChannel = module->getChannelIndexInProcessBlockBuffer(true, busIndex, channelIndex);
                result += "  \"" + paramWithId->paramID + "\" -> Bus " + juce::String(busIndex) + 
                         ", Channel " + juce::String(channelIndex) + " (Absolute: " + juce::String(absoluteChannel) + ")\n";
            }
            else
            {
                result += "  \"" + paramWithId->paramID + "\" -> NO ROUTING\n";
            }
        }
    }
    
    return result;
}

juce::String ModularSynthProcessor::getConnectionDiagnostics() const
{
    juce::String result = "=== CONNECTIONS ===\n";
    
    auto connections = getConnectionsInfo();
    for (const auto& conn : connections)
    {
        result += "Logical " + juce::String((int)conn.srcLogicalId) + ":" + juce::String(conn.srcChan) + 
                 " -> ";
        
        if (conn.dstIsOutput)
        {
            result += "OUTPUT:" + juce::String(conn.dstChan);
        }
        else
        {
            result += "Logical " + juce::String((int)conn.dstLogicalId) + ":" + juce::String(conn.dstChan);
        }
        result += "\n";
    }
    
    if (connections.empty())
    {
        result += "No connections found.\n";
    }
    
    return result;
}

bool ModularSynthProcessor::isAnyModuleRecording() const
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            if (recorder->getIsRecording())
                return true;
        }
    }
    return false;
}

void ModularSynthProcessor::pauseAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->pauseRecording();
        }
    }
}

void ModularSynthProcessor::resumeAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->resumeRecording();
        }
    }
}

void ModularSynthProcessor::startAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStartRecording();
        }
    }
}

void ModularSynthProcessor::stopAllRecorders()
{
    for (const auto& kv : modules)
    {
        if (auto* recorder = dynamic_cast<RecordModuleProcessor*>(kv.second->getProcessor()))
        {
            recorder->programmaticStopRecording();
        }
    }
}

// === VOICE MANAGEMENT IMPLEMENTATION ===

int ModularSynthProcessor::findFreeVoice()
{
    for (int i = 0; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (!m_voices[i].isActive)
            return i;
    }
    return -1;
}

int ModularSynthProcessor::findOldestVoice()
{
    if (m_voices.empty())
        return -1;
    
    int oldestIndex = 0;
    juce::uint32 oldestAge = m_voices[0].age;
    
    for (int i = 1; i < static_cast<int>(m_voices.size()); ++i)
    {
        if (m_voices[i].age < oldestAge)
        {
            oldestAge = m_voices[i].age;
            oldestIndex = i;
        }
    }
    
    return oldestIndex;
}

void ModularSynthProcessor::assignNoteToVoice(int voiceIndex, const juce::MidiMessage& noteOn)
{
    if (voiceIndex < 0 || voiceIndex >= static_cast<int>(m_voices.size()))
        return;
    
    Voice& voice = m_voices[voiceIndex];
    voice.isActive = true;
    voice.noteNumber = noteOn.getNoteNumber();
    voice.velocity = noteOn.getFloatVelocity();
    voice.age = m_globalVoiceAge++;
    
    juce::Logger::writeToLog("[VoiceManager] Assigned note " + juce::String(voice.noteNumber) + 
                            " to voice " + juce::String(voiceIndex));
}

void ModularSynthProcessor::releaseVoice(const juce::MidiMessage& noteOff)
{
    int noteNumber = noteOff.getNoteNumber();
    
    for (auto& voice : m_voices)
    {
        if (voice.isActive && voice.noteNumber == noteNumber)
        {
            voice.isActive = false;
            voice.noteNumber = -1;
            juce::Logger::writeToLog("[VoiceManager] Released note " + juce::String(noteNumber));
            return;
        }
    }
}

// === PROBE TOOL IMPLEMENTATION ===

void ModularSynthProcessor::setProbeConnection(const NodeID& sourceNodeID, int sourceChannel)
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
    {
        juce::Logger::writeToLog("[PROBE] ERROR: Probe scope not initialized!");
        return;
    }
    
    juce::Logger::writeToLog("[PROBE] setProbeConnection called. Source NodeID: " + juce::String(sourceNodeID.uid) + ", Channel: " + juce::String(sourceChannel));
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            juce::Logger::writeToLog("[PROBE] Cleared old probe connection.");
        }
    }
    
    bool success = connect(sourceNodeID, sourceChannel, probeScopeNodeId, 0);
    juce::Logger::writeToLog("[PROBE] New connection attempt " + juce::String(success ? "succeeded." : "FAILED."));
    if (success)
    {
        juce::Logger::writeToLog("[Probe] Successfully connected to probe scope");
    }
    else
    {
        juce::Logger::writeToLog("[Probe] ERROR: Failed to connect to probe scope");
    }
    
    commitChanges();
}

void ModularSynthProcessor::clearProbeConnection()
{
    if (!probeScopeNode || probeScopeNodeId.uid == 0)
        return;
    
    juce::Logger::writeToLog("[PROBE] clearProbeConnection called.");
    bool cleared = false;
    
    auto connections = internalGraph->getConnections();
    for (const auto& conn : connections)
    {
        if (conn.destination.nodeID == probeScopeNodeId)
        {
            internalGraph->removeConnection(conn, juce::AudioProcessorGraph::UpdateKind::none);
            cleared = true;
        }
    }
    
    if (cleared) {
        juce::Logger::writeToLog("[PROBE] Cleared active probe connection.");
        commitChanges();
    } else {
        juce::Logger::writeToLog("[PROBE] No active probe connection to clear.");
    }
}

ModuleProcessor* ModularSynthProcessor::getProbeScopeProcessor() const
{
    if (!probeScopeNode)
        return nullptr;
    
    return dynamic_cast<ModuleProcessor*>(probeScopeNode->getProcessor());
}

================================================================================
FILE: juce\Source\preset_creator\PresetCreatorComponent.cpp
================================================================================


// RtLogger flush integrated via timer in component
#include "PresetCreatorComponent.h"
#include "ImGuiNodeEditorComponent.h"
#include "../utils/RtLogger.h"

PresetCreatorComponent::PresetCreatorComponent(juce::AudioDeviceManager& adm,
                                               juce::AudioPluginFormatManager& fm,
                                               juce::KnownPluginList& kl)
    : deviceManager(adm),
      pluginFormatManager(fm),
      knownPluginList(kl)
{
    juce::Logger::writeToLog("PresetCreatorComponent constructor starting...");
    addAndMakeVisible (log);

    // Replace list/combos UI with ImGui node editor
    juce::Logger::writeToLog("Attempting to create ImGuiNodeEditorComponent...");
    editor.reset (new ImGuiNodeEditorComponent(deviceManager));
    juce::Logger::writeToLog("ImGuiNodeEditorComponent created.");
    editor->onShowAudioSettings = [this]() { this->showAudioSettingsDialog(); };
    addAndMakeVisible (editor.get());
    log.setMultiLine (true); log.setReadOnly (true);

    juce::Logger::writeToLog("Creating ModularSynthProcessor...");
    synth = std::make_unique<ModularSynthProcessor>();
    
    // --- THIS IS THE FIX ---
    // Set the managers immediately so the synth is ready for state restoration.
    synth->setPluginFormatManager(&pluginFormatManager);
    synth->setKnownPluginList(&knownPluginList);
    juce::Logger::writeToLog("Plugin managers set on ModularSynthProcessor.");
    // --- END OF FIX ---
    
    juce::Logger::writeToLog("Setting model on editor...");
    if (editor != nullptr)
    {
        editor->setModel (synth.get());
    }
    synth->prepareToPlay (sampleRate, blockSize);

    // Use the shared AudioDeviceManager settings
    if (auto* dev = deviceManager.getCurrentAudioDevice())
    {
        sampleRate = dev->getCurrentSampleRate();
        blockSize = dev->getCurrentBufferSizeSamples();
        synth->prepareToPlay (sampleRate, blockSize);
        juce::Logger::writeToLog ("Audio device: " + dev->getName() +
                                   ", sr=" + juce::String (sampleRate) +
                                   ", bs=" + juce::String (blockSize));
    }
    // AudioProcessorPlayer lives in juce_audio_utils namespace path include; type is juce::AudioSourcePlayer for routing
    // Use AudioProcessorPlayer via juce_audio_utils module
    processorPlayer.setProcessor (synth.get());
    
    // --- MULTI-MIDI DEVICE SUPPORT ---
    // Initialize multi-device MIDI manager
    midiDeviceManager = std::make_unique<MidiDeviceManager>(deviceManager);
    midiDeviceManager->scanDevices();
    midiDeviceManager->enableAllDevices();  // Enable all MIDI devices by default
    juce::Logger::writeToLog("[MIDI] Multi-device manager initialized");
    // Note: MidiDeviceManager now handles all MIDI input callbacks
    // The processorPlayer will receive MIDI through ModularSynthProcessor's processBlock
    // --- END MULTI-MIDI SUPPORT ---
    
    // === CRITICAL FIX: Audio callback must ALWAYS be active for MIDI processing ===
    // Without this, processBlock never runs and MIDI learn doesn't work!
    deviceManager.addAudioCallback(&processorPlayer);
    auditioning = true;  // Set flag to indicate audio is active
    juce::Logger::writeToLog("[Audio] Audio callback started - synth is now processing");
    // === END FIX ===
    
    setWantsKeyboardFocus (true);

    // Setup FileLogger at the same path the user checks: <exe>/juce/logs/preset_creator_*.log
    {
        auto exeDir = juce::File::getSpecialLocation (juce::File::currentExecutableFile).getParentDirectory();
        auto juceLogsDir = exeDir.getChildFile ("juce").getChildFile ("logs");
        juceLogsDir.createDirectory();
        auto logName = juce::String ("preset_creator_") + juce::Time::getCurrentTime().formatted ("%Y-%m-%d_%H-%M-%S") + ".log";
        auto logFile = juceLogsDir.getChildFile (logName);
        fileLogger = std::make_unique<juce::FileLogger> (logFile, "Preset Creator Session", 10 * 1024 * 1024);
        if (fileLogger != nullptr)
            juce::Logger::setCurrentLogger (fileLogger.get());
        juce::Logger::writeToLog ("PresetCreator log file: " + logFile.getFullPathName());
    }
    // Init RT logger and start periodic flush
    RtLogger::init (2048, 256);
    
    // NOTE: Audio Settings button removed - now using menu integration
    
    juce::Logger::writeToLog ("PresetCreator constructed");
    startTimerHz (30);
    
    setWindowFileName({}); // Set the default title on startup
}

// ADD: Implementation of the audio settings dialog function
void PresetCreatorComponent::showAudioSettingsDialog()
{
    auto* component = new juce::AudioDeviceSelectorComponent(
        deviceManager, 0, 256, 0, 256, true, true, false, false);
    
    component->setSize(500, 450);

    juce::DialogWindow::LaunchOptions o;
    o.content.setOwned(component);
    o.dialogTitle                   = "Audio Settings";
    o.dialogBackgroundColour        = juce::Colours::darkgrey;
    o.escapeKeyTriggersCloseButton  = true;
    o.resizable                     = false;
    o.launchAsync();
}

void PresetCreatorComponent::setWindowFileName(const juce::String& fileName)
{
    // Find the parent window of this component
    if (auto* window = findParentComponentOfClass<juce::DocumentWindow>())
    {
        juce::String newTitle = "Preset Creator"; // The default title
        if (fileName.isNotEmpty())
        {
            newTitle += " - " + fileName; // Append the filename if one is provided
        }
        window->setName(newTitle);
    }
}

void PresetCreatorComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void PresetCreatorComponent::resized()
{
    for (auto* c : getChildren())
        if (dynamic_cast<ImGuiNodeEditorComponent*>(c) != nullptr)
            c->setBounds (0, 0, getWidth(), getHeight());
    
    // Audio Settings button removed - now using menu integration
    
    // Keep log overlay minimal for now
    log.setBounds (10, getHeight() - 160, getWidth() - 20, 150);
}

void PresetCreatorComponent::setMasterPlayState(bool shouldBePlaying)
{
    if (synth == nullptr)
        return;

    // 1. Control the Audio Engine (start/stop pulling audio)
    if (shouldBePlaying)
    {
        if (!auditioning)
        {
            deviceManager.addAudioCallback(&processorPlayer);
            auditioning = true;
        }
    }
    else
    {
        if (auditioning)
        {
            deviceManager.removeAudioCallback(&processorPlayer);
            auditioning = false;
        }
    }

    // 2. Control the synth's internal transport clock
    synth->setPlaying(shouldBePlaying);
}

PresetCreatorComponent::~PresetCreatorComponent()
{
    // MULTI-MIDI SUPPORT: MidiDeviceManager handles cleanup automatically in its destructor
    midiDeviceManager.reset();

    stopAudition();
    processorPlayer.setProcessor (nullptr);
    juce::Logger::writeToLog ("PresetCreator destroyed");
    RtLogger::shutdown();
    juce::Logger::setCurrentLogger (nullptr);
}

void PresetCreatorComponent::buttonClicked (juce::Button* b)
{
    if (b == &btnAddVCO) { synth->addModule ("VCO"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCF) { synth->addModule ("VCF"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnAddVCA) { synth->addModule ("VCA"); synth->commitChanges(); refreshModulesList(); }
    else if (b == &btnConnect) { doConnect(); }
    else if (b == &btnSave) { doSave(); }
    else if (b == &btnLoad) { doLoad(); }
}

void PresetCreatorComponent::refreshModulesList()
{
    modulesModel.rows.clear();
    cbSrc.clear(); cbDst.clear();
    int idx = 1;
    for (auto [logicalId, type] : synth->getModulesInfo())
    {
        modulesModel.rows.add (juce::String ((int) logicalId) + " - " + type);
        cbSrc.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        cbDst.addItem (juce::String ((int) logicalId) + " - " + type, idx);
        ++idx;
    }
    cbDst.addItem ("Output", 9999);
    listModules.updateContent();
}

void PresetCreatorComponent::doConnect()
{
    int selSrc = cbSrc.getSelectedId();
    int selDst = cbDst.getSelectedId();
    if (selSrc <= 0 || selDst <= 0) { log.insertTextAtCaret ("Select src/dst first\n"); return; }

    // Extract logical IDs from combo texts
    auto parseId = [] (const juce::String& s) -> juce::uint32 { return (juce::uint32) s.upToFirstOccurrenceOf(" ", false, false).getIntValue(); };
    juce::uint32 srcLogical = parseId (cbSrc.getText());
    juce::uint32 dstLogical = parseId (cbDst.getText());

    auto srcNode = synth->getNodeIdForLogical (srcLogical);
    juce::AudioProcessorGraph::NodeID dstNode;
    if (cbDst.getSelectedId() == 9999)
        dstNode = synth->getOutputNodeID();
    else
        dstNode = synth->getNodeIdForLogical (dstLogical);
    const int srcChan = cbSrcChan.getSelectedId() - 1;
    const int dstChan = cbDstChan.getSelectedId() - 1;
    if (srcNode.uid != 0 && dstNode.uid != 0)
    {
        if (synth->connect (srcNode, srcChan, dstNode, dstChan))
        {
            log.insertTextAtCaret ("Connected\n");
            synth->commitChanges();
        }
        else
        {
            log.insertTextAtCaret ("Connect failed\n");
        }
    }
}

void PresetCreatorComponent::doSave()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    saveChooser = std::make_unique<juce::FileChooser> ("Save preset", startDir, "*.xml");
    saveChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc)
    {
        auto f = fc.getResult();
        if (f.exists() || f.getParentDirectory().exists())
        {
            // Ensure directory exists when saving into default folder
            f.getParentDirectory().createDirectory();
            
            // --- FIX: Temporarily unmute nodes to save original connections ---
            // When nodes are muted, their connections are replaced with bypass routing.
            // We must save the ORIGINAL connections, not the bypass connections.
            
            // 1. Get a list of all currently muted nodes from the editor
            std::vector<juce::uint32> currentlyMutedNodes;
            if (editor)
            {
                for (const auto& pair : editor->mutedNodeStates)
                {
                    currentlyMutedNodes.push_back(pair.first);
                }
                
                // 2. Temporarily UNMUTE all of them to restore the original connections
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->unmuteNode(lid);
                }
            }
            
            // 3. CRITICAL: Force the synth to apply these connection changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // At this point, the synth graph is in its "true", unmuted state
            
            // 4. NOW get the state - this will save the correct, original connections
            juce::MemoryBlock mb;
            synth->getStateInformation (mb);
            auto xml = juce::XmlDocument::parse (mb.toString());
            if (! xml) return;
            
            // 5. IMMEDIATELY RE-MUTE the nodes to return the editor to its visible state
            if (editor)
            {
                for (juce::uint32 lid : currentlyMutedNodes)
                {
                    editor->muteNode(lid);
                }
            }
            
            // 6. CRITICAL: Force the synth to apply the re-mute changes immediately
            if (synth)
            {
                synth->commitChanges();
            }
            // The synth graph is now back to its bypassed state for audio processing
            // --- END OF FIX ---
            
            juce::ValueTree presetVT = juce::ValueTree::fromXml (*xml);
            // Attach UI state as child (which correctly contains the "muted" flags)
            if (editor)
            {
                juce::ValueTree ui = editor->getUiValueTree();
                presetVT.addChild (ui, -1, nullptr);
            }
            // Write
            f.replaceWithText (presetVT.createXml()->toString());
            log.insertTextAtCaret ("Saved: " + f.getFullPathName() + "\n");
            
            setWindowFileName(f.getFileName()); // Update title bar with filename
        }
    });
}

void PresetCreatorComponent::doLoad()
{
    // Default to project-root/Synth_presets
    juce::File startDir;
    {
        auto exeDir = juce::File::getSpecialLocation(juce::File::currentExecutableFile).getParentDirectory();
        auto dir = exeDir;
        for (int i = 0; i < 8 && dir.exists(); ++i)
        {
            auto candidate = dir.getSiblingFile("Synth_presets");
            if (candidate.exists() && candidate.isDirectory()) { startDir = candidate; break; }
            dir = dir.getParentDirectory();
        }
    }
    if (! startDir.exists()) startDir = juce::File();
    loadChooser = std::make_unique<juce::FileChooser> ("Load preset", startDir, "*.xml");
    loadChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
        [this] (const juce::FileChooser& fc) noexcept
    {
        try {
            auto f = fc.getResult();
            if (f.existsAsFile())
            {
                juce::MemoryBlock mb;
                f.loadFileAsData (mb);
                // First set the synth state
                synth->setStateInformation (mb.getData(), (int) mb.getSize());
                // Then parse and queue UI state for next frame (ensures editor exists and nodes are created)
                if (editor)
                {
                    if (auto xml = juce::XmlDocument::parse (mb.toString()))
                    {
                        auto vt = juce::ValueTree::fromXml (*xml);
                        auto ui = vt.getChildWithName ("NodeEditorUI");
                        if (ui.isValid())
                            editor->applyUiValueTreeNow (ui);
                    }
                }
                refreshModulesList();
                log.insertTextAtCaret ("Loaded: " + f.getFullPathName() + "\n");
                
                setWindowFileName(f.getFileName()); // Update title bar with filename
            }
        } catch (...) {
            juce::Logger::writeToLog ("[PresetCreator][FATAL] Exception in doLoad callback");
        }
    });
}

bool PresetCreatorComponent::keyPressed (const juce::KeyPress& key)
{
    if (key.getKeyCode() == juce::KeyPress::spaceKey)
    {
        if (spacebarDownTime == 0) // Only record time on the initial press
        {
            spacebarDownTime = juce::Time::getMillisecondCounter();
            wasLongPress = false;
        }
        return true;
    }
    return false;
}

bool PresetCreatorComponent::keyStateChanged (bool isKeyDown)
{
    juce::ignoreUnused (isKeyDown);

    if (!juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
    {
        if (spacebarDownTime != 0) // Key was just released
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration < longPressThresholdMs && !wasLongPress)
            {
                // SHORT PRESS (TOGGLE)
                if (synth)
                {
                    const bool isCurrentlyPlaying = synth->getTransportState().isPlaying;
                    setMasterPlayState(!isCurrentlyPlaying); // Use the unified function
                }
            }
            // If it was a long press, the timer callback will handle stopping.
        }
        spacebarDownTime = 0; // Reset for next press
    }
    return false;
}

void PresetCreatorComponent::visibilityChanged()
{
    juce::Logger::writeToLog (juce::String ("Component visible? ") + (isShowing() ? "yes" : "no"));
}

void PresetCreatorComponent::startAudition()
{
    if (auditioning) return;
    deviceManager.addAudioCallback (&processorPlayer);
    auditioning = true;
    log.insertTextAtCaret ("[Audition] Start (hold space)\n");
}

void PresetCreatorComponent::stopAudition()
{
    if (! auditioning) return;
    deviceManager.removeAudioCallback (&processorPlayer);
    auditioning = false;
    log.insertTextAtCaret ("[Audition] Stop\n");
}

void PresetCreatorComponent::timerCallback()
{
    RtLogger::flushToFileLogger();
    
    // MULTI-MIDI SUPPORT: Transfer MIDI messages from MidiDeviceManager to ModularSynthProcessor
    if (midiDeviceManager && synth)
    {
        std::vector<MidiDeviceManager::MidiMessageWithSource> midiMessages;
        midiDeviceManager->swapMessageBuffer(midiMessages);
        
        if (!midiMessages.empty())
        {
            juce::Logger::writeToLog("[PresetCreator] Received " + juce::String(midiMessages.size()) + 
                                    " MIDI messages from MidiDeviceManager");
            
            // Convert to ModularSynthProcessor format
            std::vector<MidiMessageWithDevice> convertedMessages;
            convertedMessages.reserve(midiMessages.size());
            
            for (const auto& msg : midiMessages)
            {
                MidiMessageWithDevice converted;
                converted.message = msg.message;
                converted.deviceIdentifier = msg.deviceIdentifier;
                converted.deviceName = msg.deviceName;
                converted.deviceIndex = msg.deviceIndex;
                convertedMessages.push_back(converted);
            }
            
            juce::Logger::writeToLog("[PresetCreator] Passing " + juce::String(convertedMessages.size()) + 
                                    " messages to ModularSynthProcessor");
            
            // Pass to synth for distribution to modules
            synth->processMidiWithDeviceInfo(convertedMessages);
        }
    }
    
    // Check for MIDI activity from the synth
    if (synth != nullptr && synth->hasMidiActivity())
        midiActivityFrames = 30;
    
    // Update MIDI activity indicator in editor
    if (editor != nullptr)
        editor->setMidiActivityFrames(midiActivityFrames);
    
    if (synth != nullptr)
    {
        // Check for long press activation
        if (spacebarDownTime != 0 && !wasLongPress)
        {
            auto pressDuration = juce::Time::getMillisecondCounter() - spacebarDownTime;
            if (pressDuration >= longPressThresholdMs)
            {
                wasLongPress = true;
                setMasterPlayState(true); // Use the unified function
            }
        }
        
        // Check for long press release
        if (wasLongPress && !juce::KeyPress::isKeyCurrentlyDown(juce::KeyPress::spaceKey))
        {
            setMasterPlayState(false); // Use the unified function
            wasLongPress = false;
            spacebarDownTime = 0;
        }
    }

    static int counter = 0;
    if ((++counter % 60) == 0)
        juce::Logger::writeToLog ("[Heartbeat] UI alive");
}


================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class StepSequencerModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_STEPS = 16;
    StepSequencerModuleProcessor();
    ~StepSequencerModuleProcessor() override = default;

    const juce::String getName() const override { return "sequencer"; }

    void prepareToPlay (double newSampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // State management for transport settings
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree&) override;

    // Pin label overrides
    juce::String getAudioOutputLabel(int channel) const override;
    juce::String getAudioInputLabel(int channel) const override;
    
    // Parameter bus contract implementation
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    
    // Rhythm reporting for BPM Monitor
    std::optional<RhythmInfo> getRhythmInfo() const override;

#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    void setTimingInfo(const TransportState& state) override;

    juce::AudioProcessorValueTreeState apvts;

    std::atomic<int> currentStep { 0 };
    double phase { 0.0 };
    double sampleRate { 44100.0 };

    TransportState m_currentTransport;
    bool wasPlaying = false;

    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* gateLengthParam { nullptr };
    std::atomic<float>* gateThresholdParam { nullptr };
    std::atomic<float>* rateModParam { nullptr };
    std::atomic<float>* gateLengthModParam { nullptr };
    std::atomic<float>* numStepsModParam { nullptr };
    std::atomic<float>* stepsModMaxParam { nullptr };
    std::vector<std::atomic<float>*> pitchParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepModParams; // size MAX_STEPS
    // Per-step trigger base (checkbox) and modulation
    std::vector<juce::AudioParameterBool*> stepTrigParams; // size MAX_STEPS
    std::vector<std::atomic<float>*> stepTrigModParams;    // size MAX_STEPS (0..1)
    // Per-step gate level parameters
    std::vector<std::atomic<float>*> stepGateParams;       // size MAX_STEPS (0..1)
    std::atomic<float>* numStepsParam { nullptr };

    // Pulse generator state for Trigger Out
    int pendingTriggerSamples { 0 };
    
    // Gate fade-in state
    bool previousGateOn { false };
    float gateFadeProgress { 0.0f };
    static constexpr float GATE_FADE_TIME_MS = 5.0f; // 5ms fade-in time
};

// Pin label overrides
inline juce::String StepSequencerModuleProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Pitch";
        case 1: return "Gate";
        case 2: return "Gate Nuanced";
        case 3: return "Velocity";
        case 4: return "Mod";
        case 5: return "Trigger";
        default: return juce::String("Out ") + juce::String(channel + 1);
    }
}

inline juce::String StepSequencerModuleProcessor::getAudioInputLabel(int channel) const
{
    switch (channel)
    {
        case 0: return "Mod In L";
        case 1: return "Mod In R";
        case 2: return "Rate Mod";
        case 3: return "Gate Mod";
        case 4: return "Steps Mod";
        default: return juce::String("In ") + juce::String(channel + 1);
    }
}




================================================================================
FILE: juce\Source\audio\modules\StepSequencerModuleProcessor.cpp
================================================================================


#include "StepSequencerModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <iostream>
#include <array>

using APVTS = juce::AudioProcessorValueTreeState;

static juce::NormalisableRange<float> makeRateRange()
{
    // FIX: Change the interval from 0.0f to a small, non-zero value like 0.01f.
    juce::NormalisableRange<float> r (0.1f, 20.0f, 0.01f, 0.5f); // semi-log response
    return r;
}

APVTS::ParameterLayout StepSequencerModuleProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps", "Number of Steps", 1, StepSequencerModuleProcessor::MAX_STEPS, 8));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate", "Rate", makeRateRange(), 2.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength", "Gate Length", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    // Threshold to generate gate when step value >= threshold
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateThreshold", "Gate Threshold", juce::NormalisableRange<float> (0.0f, 1.0f, 0.001f), 0.5f));
    
    // Add modulation parameters for rate, gate length and number of steps (absolute 0..1)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate_mod", "Rate Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength_mod", "Gate Length Mod", 0.0f, 1.0f, 0.5f));
    // Neutral default at 0.5 means "no override" (we'll treat values ~0.5 as disconnected)
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("numSteps_mod", "Num Steps Mod", 0.0f, 1.0f, 0.5f));
    // Optional maximum steps bound (1..MAX_STEPS), default MAX_STEPS
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps_max", "Num Steps Max", 1, StepSequencerModuleProcessor::MAX_STEPS, StepSequencerModuleProcessor::MAX_STEPS));
    
    // Transport sync parameters
    params.push_back(std::make_unique<juce::AudioParameterBool>("sync", "Sync to Transport", false));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("rate_division", "Division", 
        juce::StringArray{ "1/32", "1/16", "1/8", "1/4", "1/2", "1", "2", "4", "8" }, 3)); // Default: 1/4 note
    
    for (int i = 0; i < StepSequencerModuleProcessor::MAX_STEPS; ++i)
    {
        const juce::String pid = "step" + juce::String (i + 1);
        params.push_back (std::make_unique<juce::AudioParameterFloat> (pid, pid, juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));

        // ADD THIS: A new parameter for this step's modulation input
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        // Default 0.5 => no offset (unipolar 0..1 centered to bipolar -0.5..+0.5)
        params.push_back(std::make_unique<juce::AudioParameterFloat>(modPid, modPid, 0.0f, 1.0f, 0.5f));

        // NEW: per-step Trigger checkbox and its modulation (absolute 0..1)
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        params.push_back(std::make_unique<juce::AudioParameterBool>(trigPid, trigPid, false));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(trigModPid, trigModPid, 0.0f, 1.0f, 0.5f));

        // NEW: per-step Gate Level parameters
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gatePid, gatePid, 0.0f, 1.0f, 0.8f));
        const juce::String gateModPid = "step" + juce::String(i + 1) + "_gate_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gateModPid, gateModPid, 0.0f, 1.0f, 0.5f));
    }
    return { params.begin(), params.end() };
}

StepSequencerModuleProcessor::StepSequencerModuleProcessor()
    : ModuleProcessor (BusesProperties()
                        // ARCHITECTURAL FIX: Single large bus for all inputs:
                        // 2 (Audio) + 4 (Global Mods: rate, gate, steps, stepsMax) + 16 (Step Mods) + 16 (Trig Mods) + 16 (Gate Mods) = 54 channels
                        .withInput("Inputs", juce::AudioChannelSet::discreteChannels(2 + 4 + (MAX_STEPS * 3)), true)
                        // expand to 5 outputs (Pitch, Gate, Velocity, Mod, Trigger)
                        .withOutput ("CV Outputs", juce::AudioChannelSet::discreteChannels(6), true))
    , apvts (*this, nullptr, "SeqParams", createParameterLayout())
{
    // ADD THIS VERIFICATION LOGIC
    std::cout << "--- StepSequencerModuleProcessor Initializing ---" << std::endl;
    
    numStepsParam   = apvts.getRawParameterValue ("numSteps");
    rateParam       = apvts.getRawParameterValue ("rate");
    gateLengthParam = apvts.getRawParameterValue ("gateLength");
    gateThresholdParam = apvts.getRawParameterValue ("gateThreshold");
    rateModParam    = apvts.getRawParameterValue ("rate_mod");
    gateLengthModParam = apvts.getRawParameterValue ("gateLength_mod");
    numStepsModParam = apvts.getRawParameterValue ("numSteps_mod");
    stepsModMaxParam = apvts.getRawParameterValue ("numSteps_max");
    
    if (numStepsParam == nullptr) std::cout << "ERROR: 'numSteps' parameter is NULL!" << std::endl;
    if (rateParam == nullptr) std::cout << "ERROR: 'rate' parameter is NULL!" << std::endl;
    if (gateLengthParam == nullptr) std::cout << "ERROR: 'gateLength' parameter is NULL!" << std::endl;

    pitchParams.resize (MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        pitchParams[i] = apvts.getRawParameterValue ("step" + juce::String (i + 1));
        if (pitchParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "' parameter is NULL!" << std::endl;
        }
    }

    // Initialize stepModParams
    stepModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        stepModParams[i] = apvts.getRawParameterValue(modPid);
        if (stepModParams[i] == nullptr)
        {
            std::cout << "ERROR: 'step" << (i + 1) << "_mod' parameter is NULL!" << std::endl;
        }
    }
    std::cout << "--- Initialization Check Complete ---" << std::endl;
    
    // Initialize output value tracking for tooltips (6 outputs: Pitch, Gate, Gate Nuanced, Velocity, Mod, Trigger)
    for (int i = 0; i < 6; ++i)
        lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));

    // Cache pointers for per-step trigger params
    stepTrigParams.resize(MAX_STEPS);
    stepTrigModParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        stepTrigParams[i] = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter(trigPid));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        stepTrigModParams[i] = apvts.getRawParameterValue(trigModPid);
    }

    // Initialize gate parameter pointers
    stepGateParams.resize(MAX_STEPS);
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        stepGateParams[i] = apvts.getRawParameterValue(gatePid);
    }
}

void StepSequencerModuleProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sampleRate = newSampleRate > 0.0 ? newSampleRate : 44100.0;
    phase = 0.0;
}

void StepSequencerModuleProcessor::setTimingInfo(const TransportState& state)
{
    // Check if the transport has just started playing
    if (state.isPlaying && !wasPlaying)
    {
        // Reset to the beginning when play is pressed
        currentStep.store(0);
        phase = 0.0;
    }
    wasPlaying = state.isPlaying;
    
    m_currentTransport = state;
}

juce::ValueTree StepSequencerModuleProcessor::getExtraStateTree() const
{
    juce::ValueTree vt("SequencerState");
    vt.setProperty("sync", apvts.getRawParameterValue("sync")->load(), nullptr);
    vt.setProperty("rate_division", apvts.getRawParameterValue("rate_division")->load(), nullptr);
    return vt;
}

void StepSequencerModuleProcessor::setExtraStateTree(const juce::ValueTree& vt)
{
    if (vt.hasType("SequencerState"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync")))
            *p = (bool)vt.getProperty("sync", false);
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division")))
            *p = (int)vt.getProperty("rate_division", 3);
    }
}

void StepSequencerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    juce::ignoreUnused (midi);
    if (rateParam == nullptr || numStepsParam == nullptr || gateLengthParam == nullptr)
    {
        buffer.clear();
        return;
    }

    const int numSamples = buffer.getNumSamples();
    
    // ARCHITECTURAL FIX: Read CV from single input bus
    const auto& inputBus = getBusBuffer(buffer, true, 0); // All inputs are now on bus 0
    
    // Get pointers to global modulation CV inputs, if they are connected
    const bool isRateMod = isParamInputConnected("rate_mod");
    const bool isGateLenMod = isParamInputConnected("gateLength_mod");
    const bool isStepsMod = isParamInputConnected("numSteps_mod");
    
    // Absolute channel map on single input bus:
    // 0=L,1=R, 2=rate, 3=gateLen, 4=steps, 5=stepsMax,
    // 6..21: step1..step16 value mods, 22..37: step1..step16 trig mods, 38..53: step1..step16 gate mods
    const float* rateCV = isRateMod && inputBus.getNumChannels() > 2 ? inputBus.getReadPointer(2) : nullptr;
    const float* gateLenCV = isGateLenMod && inputBus.getNumChannels() > 3 ? inputBus.getReadPointer(3) : nullptr;
    const float* stepsCV = isStepsMod && inputBus.getNumChannels() > 4 ? inputBus.getReadPointer(4) : nullptr;
    
    // Get write pointers for all 6 output channels
    auto* pitchOut       = buffer.getWritePointer(0);
    auto* gateOut        = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : nullptr;
    auto* gateNuancedOut = buffer.getNumChannels() > 2 ? buffer.getWritePointer(2) : nullptr;
    auto* velocityOut    = buffer.getNumChannels() > 3 ? buffer.getWritePointer(3) : nullptr;
    auto* modOut         = buffer.getNumChannels() > 4 ? buffer.getWritePointer(4) : nullptr;
    auto* trigOut        = buffer.getNumChannels() > 5 ? buffer.getWritePointer(5) : nullptr;
    
    // The old, commented-out input logic can now be completely removed.
    
    // Get base parameter values ONCE
    const float baseRate = rateParam->load();
    const float baseGate = gateLengthParam != nullptr ? gateLengthParam->load() : 0.5f;
    const int baseSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMax = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const float gateThreshold = gateThresholdParam != nullptr ? juce::jlimit(0.0f, 1.0f, gateThresholdParam->load()) : 0.5f;
    

    // --- UI Telemetry Bootstrap ---
    // Publish per-step live values for ALL steps this block (use first-sample snapshot)
    {
        const int totalCh = inputBus.getNumChannels();
        for (int si = 0; si < MAX_STEPS; ++si)
        {
            // Absolute channel for per-step value mod: 6..21
            const int ch = 6 + si;
            const bool hasCh = totalCh > ch;
            const float base = (pitchParams.size() > (size_t) si && pitchParams[si] != nullptr) ? pitchParams[si]->load() : 0.0f;
            float live = base;
            if (hasCh)
            {
                const float cv0 = inputBus.getReadPointer(ch)[0];
                live = juce::jlimit(0.0f, 1.0f, base + (cv0 - 0.5f));
            }
            setLiveParamValue("step_live_" + juce::String(si + 1), live);

            // Per-step gate live values: channels 38..53
            const int gateCh = 38 + si;
            const bool hasGateCh = totalCh > gateCh;
            const float baseGate = (stepGateParams.size() > (size_t) si && stepGateParams[si] != nullptr) ? stepGateParams[si]->load() : 0.8f;
            float liveGate = baseGate;
            if (hasGateCh)
            {
                const float cv0 = inputBus.getReadPointer(gateCh)[0];
                liveGate = juce::jlimit(0.0f, 1.0f, baseGate + (cv0 - 0.5f));
            }
            setLiveParamValue("gate_live_" + juce::String(si + 1), liveGate);

            // Per-step trigger live values: channels 22..37
            const int trigCh = 22 + si;
            const bool hasTrigCh = totalCh > trigCh;
            const bool baseTrig = (stepTrigParams.size() > (size_t) si && stepTrigParams[si] != nullptr) ? (bool)(*stepTrigParams[si]) : false;
            bool liveTrig = baseTrig;
            if (hasTrigCh)
            {
                const float cv0 = inputBus.getReadPointer(trigCh)[0];
                liveTrig = cv0 > 0.5f;
            }
            setLiveParamValue("trig_live_" + juce::String(si + 1), liveTrig ? 1.0f : 0.0f);
        }
    }

    bool stepAdvanced = false;
    float lastRateLive = baseRate;
    float lastGateLive = baseGate;
    float lastGateThresholdLive = gateThreshold;
    int   lastStepsLive = baseSteps;
    for (int i = 0; i < numSamples; ++i)
    {
        // PER-SAMPLE FIX: Calculate global modulation parameters FOR THIS SAMPLE
        int activeSteps = baseSteps;
        if (isStepsMod && stepsCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, stepsCV[i]);
            // CV adds/subtracts steps around base (±8 steps)
            const int offset = (int)std::round((cv - 0.5f) * 16.0f);
            activeSteps = baseSteps + offset;
            activeSteps = juce::jlimit(1, boundMax, activeSteps);
        }
        // FIX: clamp playhead immediately when steps shrink
        if (currentStep.load() >= activeSteps)
            currentStep.store(0);
        
        float rate = baseRate;
        if (isRateMod && rateCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, rateCV[i]);
            // CV modulates ±2 octaves (0.25x to 4x)
            const float octaveOffset = (cv - 0.5f) * 4.0f;
            rate = baseRate * std::pow(2.0f, octaveOffset);
            rate = juce::jlimit(0.1f, 20.0f, rate);
        }
        lastRateLive = rate;
        
        float gateLen = baseGate;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            // CV adds offset to base gate length (±0.5)
            const float offset = (cv - 0.5f) * 1.0f;
            gateLen = baseGate + offset;
            gateLen = juce::jlimit(0.0f, 1.0f, gateLen);
        }
        lastGateLive = gateLen;
        
        // Use gateLenCV for gate threshold modulation (reusing the existing "Gate Mod" input)
        float gateThreshold = gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            gateThreshold = juce::jlimit(0.0f, 1.0f, cv);
        }
        lastGateThresholdLive = gateThreshold;
        
        // --- Transport Sync Logic ---
        const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;

        if (syncEnabled && m_currentTransport.isPlaying)
        {
            // SYNC MODE: Use the global beat position
            int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
            // Use global division if a Tempo Clock has override enabled
            // IMPORTANT: Read from parent's LIVE transport state, not cached copy (which is stale)
            if (getParent())
            {
                int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
                if (globalDiv >= 0)
                    divisionIndex = globalDiv;
            }
            static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
            const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
            
            // Calculate which step we should be on based on song position
            const int totalSteps = juce::jlimit(1, MAX_STEPS, activeSteps);
            const int stepForBeat = static_cast<int>(std::fmod(m_currentTransport.songPositionBeats * beatDivision, totalSteps));

            if (stepForBeat != currentStep.load())
            {
                currentStep.store(stepForBeat);
                stepAdvanced = true;
            }
        }
        else
        {
            // FREE-RUNNING MODE: Use the internal phase clock
            const double phaseInc = (sampleRate > 0.0 ? (double) rate / sampleRate : 0.0);
            phase += phaseInc;
            if (phase >= 1.0)
            {
                phase -= 1.0;
                const int next = (currentStep.load() + 1) % juce::jlimit (1, MAX_STEPS, activeSteps);
                currentStep.store(next);
                stepAdvanced = true;
            }
        }
        lastStepsLive = activeSteps;

        const int currentStepIndex = currentStep.load();
        const float sliderValue = pitchParams[currentStepIndex] != nullptr ? pitchParams[currentStepIndex]->load() : 0.0f;
        
        // PER-SAMPLE FIX: Read modulation from CV input bus for THIS SAMPLE
        float rawModValue = 0.5f; // neutral
        {
            const juce::String stepModId = "step" + juce::String(currentStepIndex + 1) + "_mod";
            const bool stepModConnected = isParamInputConnected(stepModId);
            if (stepModConnected)
            {
                // Absolute: step1_mod at 6, step2_mod at 7, ...
                const int modChannel = 6 + currentStepIndex;
                if (inputBus.getNumChannels() > modChannel)
                    rawModValue = inputBus.getReadPointer(modChannel)[i];
            }
        }
        // Center modulation around 0.0 (convert unipolar 0-1 to bipolar -0.5 to +0.5)
        const float modValue = rawModValue - 0.5f;

        const float pitchValue = juce::jlimit (0.0f, 1.0f, sliderValue + modValue);
        
        // --- REWRITTEN GATE LOGIC ---
        // 1. Get the gate level for the current step from its own slider.
        float stepGateLevel = (stepGateParams[currentStepIndex] != nullptr) ? stepGateParams[currentStepIndex]->load() : 0.8f;

        // 2. Apply modulation to the step's gate level if connected.
        const juce::String gateModId = "step" + juce::String(currentStepIndex + 1) + "_gate_mod";
        if (isParamInputConnected(gateModId))
        {
            const int gateModChannel = 38 + currentStepIndex;
            if (inputBus.getNumChannels() > gateModChannel)
            {
                const float cv = inputBus.getReadPointer(gateModChannel)[i];
                stepGateLevel = juce::jlimit(0.0f, 1.0f, stepGateLevel + (cv - 0.5f));
            }
        }

        // --- NEW DUAL GATE LOGIC WITH FADE-IN ---
        // 1. Perform the comparison once.
        const bool isGateOn = (stepGateLevel >= gateThreshold);
        
        // 2. Handle gate fade-in transition
        if (isGateOn && !previousGateOn) {
            // Gate just turned on - start fade-in
            gateFadeProgress = 0.0f;
        } else if (isGateOn && previousGateOn) {
            // Gate is on - continue fade-in
            const float fadeIncrement = sampleRate > 0.0f ? (1000.0f / GATE_FADE_TIME_MS) / sampleRate : 0.0f;
            gateFadeProgress = juce::jmin(1.0f, gateFadeProgress + fadeIncrement);
        } else {
            // Gate is off - reset fade progress
            gateFadeProgress = 0.0f;
        }
        previousGateOn = isGateOn;
        
        // 3. Generate the binary "Gate" output with fade-in.
        const float gateBinaryValue = isGateOn ? gateFadeProgress : 0.0f;
        
        // 4. Generate the analog "Gate Nuanced" output with fade-in.
        const float gateNuancedValue = isGateOn ? (stepGateLevel * gateFadeProgress) : 0.0f;
        // --- END OF NEW LOGIC ---
        
        // Live gate level is already stored in the UI telemetry bootstrap

        // Determine Trigger state for this step (checkbox + mod, but only count mod when connected)
        bool trigBase = false;
        if (stepTrigParams.size() > (size_t) currentStepIndex && stepTrigParams[currentStepIndex] != nullptr)
            trigBase = (bool) (*stepTrigParams[currentStepIndex]);
        bool trigActive = trigBase;
        {
            const juce::String trigModId = "step" + juce::String(currentStepIndex + 1) + "_trig_mod";
            const bool trigModConnected = isParamInputConnected(trigModId);
            if (trigModConnected)
            {
                // Absolute: step1_trig_mod at 22, step2 at 23, ...
                const int trigModChannel = 22 + currentStepIndex;
                if (inputBus.getNumChannels() > trigModChannel)
                {
                    const float trigModNorm = inputBus.getReadPointer(trigModChannel)[i];
                    if (trigModNorm > 0.5f) trigActive = true;
                }
            }
        }

        // If we advanced to this step, only emit a pulse if this step is enabled (checkbox or connected mod>0.5)
        if (stepAdvanced)
        {
            pendingTriggerSamples = trigActive ? (int) std::round (0.001 * sampleRate) : 0;
            stepAdvanced = false;
        }

        pitchOut[i] = pitchValue;
        // Live step value is already stored in the UI telemetry bootstrap
        if (gateOut != nullptr)         gateOut[i] = gateBinaryValue;
        if (gateNuancedOut != nullptr)  gateNuancedOut[i] = gateNuancedValue;
        if (velocityOut != nullptr) velocityOut[i] = 0.85f;
        if (modOut != nullptr)      modOut[i] = 0.0f;
        // Timed gate remains level-based
        // Trigger Out: 1ms pulse after each step advance
        if (trigOut != nullptr)
        {
            float pulse = 0.0f;
            if (pendingTriggerSamples > 0)
            {
                pulse = 1.0f;
                --pendingTriggerSamples;
            }
            trigOut[i] = pulse;
        }
    }
    // Publish block-level live telemetry for UI reflection
    setLiveParamValue("rate_live", lastRateLive);
    setLiveParamValue("gateLength_live", lastGateLive);
    setLiveParamValue("gateThreshold_live", lastGateThresholdLive);
    setLiveParamValue("steps_live", (float) lastStepsLive);
    
    // Update output values for tooltips
    if (lastOutputValues.size() >= 6)
    {
        if (lastOutputValues[0] && pitchOut) lastOutputValues[0]->store(pitchOut[numSamples - 1]);
        if (lastOutputValues[1] && gateOut) lastOutputValues[1]->store(gateOut[numSamples - 1]);
        if (lastOutputValues[2] && gateNuancedOut) lastOutputValues[2]->store(gateNuancedOut[numSamples - 1]);
        if (lastOutputValues[3] && velocityOut) lastOutputValues[3]->store(velocityOut[numSamples - 1]);
        if (lastOutputValues[4] && modOut) lastOutputValues[4]->store(modOut[numSamples - 1]);
        if (lastOutputValues[5] && trigOut) lastOutputValues[5]->store(trigOut[numSamples - 1]);
    }

}

#if defined(PRESET_CREATOR_UI)
void StepSequencerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;
    const int boundMaxUi = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const bool stepsAreModulated = isParamModulated("numSteps_mod");
    if (stepsAreModulated) {
        // Reflect live steps from audio thread telemetry
        const int liveSteps = (int) std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float) activeSteps));
        activeSteps = juce::jlimit (1, boundMaxUi, liveSteps);
    }

    // Step count controls - now using a slider instead of +/- buttons
    int currentSteps = numStepsParam != nullptr ? (int)numStepsParam->load() : 8;

    // If modulated, the displayed value comes from the modulation input.
    // Otherwise, it comes from the parameter itself.
    int displayedSteps = currentSteps;
    if (stepsAreModulated) {
        const int liveSteps = (int) std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float) currentSteps));
        displayedSteps = juce::jlimit (1, boundMaxUi, liveSteps);
    }

    // Ensure the displayed value never exceeds the max bound
    displayedSteps = juce::jmin(displayedSteps, boundMaxUi);

    // Disable the slider if steps are being modulated
    if (stepsAreModulated) ImGui::BeginDisabled();

    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderInt("Steps", &displayedSteps, 1, boundMaxUi))
    {
        // Only update the parameter if the slider is not disabled
        if (!stepsAreModulated) {
            if (auto* p = dynamic_cast<juce::AudioParameterInt*>(apvts.getParameter("numSteps"))) {
                *p = displayedSteps;
            }
        }
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    
    // Add scroll wheel support for the Steps slider
    if (!stepsAreModulated)
    {
        adjustParamOnWheel(apvts.getParameter("numSteps"), "numSteps", (float)displayedSteps);
    }
    
    ImGui::PopItemWidth();

    if (stepsAreModulated) {
        ImGui::EndDisabled();
        ImGui::SameLine(); 
        ImGui::TextUnformatted("(mod)");
    }

    // Use the displayed steps value for the slider strip
    const int shown = juce::jlimit (1, MAX_STEPS, displayedSteps);
    const float sliderW = itemWidth / (float) juce::jmax (8, shown) * 0.8f;

    ImGui::PushItemWidth (sliderW);
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();

        // Build display and interaction state
        float baseValue = (pitchParams[i] != nullptr ? pitchParams[i]->load() : 0.5f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        const bool modConnected = isParamModulated(modPid);

        // Reflect live per-step value for the currently active step when modulated
        float liveValue = getLiveParamValueFor("step" + juce::String(i + 1) + "_mod",
                                              "step_live_" + juce::String(i + 1),
                                              baseValue);
        float sliderValue = modConnected ? liveValue : baseValue; // widget bound to display value

        const bool isActive = (i == currentStep.load());
        if (isActive)
        {
            ImGui::PushStyleColor (ImGuiCol_FrameBg, ImVec4(0.3f, 0.7f, 1.0f, 1.0f));
            ImGui::PushStyleColor (ImGuiCol_SliderGrab, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
        }

        const std::string label = "##s" + std::to_string(i);
        if (modConnected) ImGui::BeginDisabled();
        if (ImGui::VSliderFloat (label.c_str(), ImVec2 (sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected) {
                // Only update if not modulated
                float newBaseValue = juce::jlimit (0.0f, 1.0f, sliderValue);
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                    *p = newBaseValue;
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }

        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit (0.0f, 1.0f, baseValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter ("step" + juce::String (i + 1)))) 
                        *p = newBaseValue;
                }
            }
        }

        if (modConnected) { ImGui::EndDisabled(); }

        if (isActive) ImGui::PopStyleColor(2);
    }
    ImGui::PopItemWidth();


    // Per-step Gate Sliders
    ImGui::PushItemWidth(sliderW);
    
    // Capture the screen position before drawing the gate sliders
    ImVec2 gate_sliders_p0 = ImGui::GetCursorScreenPos();
    
    for (int i = 0; i < shown; ++i)
    {
        if (i > 0) ImGui::SameLine();
        ImGui::PushID(2000 + i); // Use a new ID base to avoid collisions

        float baseGateValue = (stepGateParams[i] != nullptr ? stepGateParams[i]->load() : 0.8f);
        const juce::String modPid = "step" + juce::String(i + 1) + "_gate_mod";
        const bool modConnected = isParamModulated(modPid);
        
        // Reflect live modulated value for gate level
        float sliderValue = baseGateValue;
        if (modConnected) {
            // Use live gate value from audio thread
            sliderValue = getLiveParamValueFor("step" + juce::String(i + 1) + "_gate_mod",
                                              "gate_live_" + juce::String(i + 1),
                                              baseGateValue);
        }
        const bool isActive = (i == currentStep.load());

        if (isActive) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.7f, 0.3f, 1.0f));
        if (modConnected) ImGui::BeginDisabled();
        
        if (ImGui::VSliderFloat("##g", ImVec2(sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, ""))
        {
            if (!modConnected && stepGateParams[i] != nullptr) {
                if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("step" + juce::String(i + 1) + "_gate"))) {
                    *p = sliderValue;
                }
            }
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        
        // Wheel fine-tune: identical semantics to drag
        if (!modConnected)
        {
            if (ImGui::IsItemHovered())
            {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f)
                {
                    const float delta = (wheel > 0 ? 0.05f : -0.05f);
                    float newBaseValue = juce::jlimit(0.0f, 1.0f, sliderValue + delta);
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("step" + juce::String(i + 1) + "_gate"))) {
                        *p = newBaseValue;
                    }
                }
            }
        }
        
        if (modConnected) ImGui::EndDisabled();
        if (isActive) ImGui::PopStyleColor();
        
        ImGui::PopID();
    }
    ImGui::PopItemWidth();

    // Draw the yellow threshold line immediately after the gate sliders
    // Use the same threshold value that will be used by the Gate Threshold slider
    const bool gtIsModulatedForLine = isParamModulated("gateLength_mod");
    const float threshold_value = gtIsModulatedForLine ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f))
                                                          : (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f);
    const float slider_height = 60.0f; // This must match the VSliderFloat height
    const float row_width = (sliderW * shown) + (ImGui::GetStyle().ItemSpacing.x * (shown - 1));

    // Calculate the Y coordinate for the line. 
    // A threshold of 1.0 is at the top (y=0), 0.0 is at the bottom (y=height).
    const float line_y = gate_sliders_p0.y + (1.0f - threshold_value) * slider_height;

    ImDrawList* draw_list = ImGui::GetWindowDrawList();
    draw_list->AddLine(
        ImVec2(gate_sliders_p0.x, line_y),
        ImVec2(gate_sliders_p0.x + row_width, line_y),
        IM_COL32(255, 255, 0, 200), // A bright, slightly transparent yellow
        2.0f
    );

    // Current step indicator
    ImGui::Text("Current Step: %d", currentStep.load() + 1);

    // --- SYNC CONTROLS ---
    bool sync = apvts.getRawParameterValue("sync")->load() > 0.5f;
    if (ImGui::Checkbox("Sync to Transport", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync"))) *p = sync;
        onModificationEnded();
    }

    ImGui::PushItemWidth(itemWidth);
    if (sync)
    {
        // Check if global division is active (Tempo Clock override)
        // IMPORTANT: Read from parent's LIVE transport state, not cached copy
        int globalDiv = getParent() ? getParent()->getTransportState().globalDivisionIndex.load() : -1;
        bool isGlobalDivisionActive = globalDiv >= 0;
        int division = isGlobalDivisionActive ? globalDiv : (int)apvts.getRawParameterValue("rate_division")->load();
        
        // Grey out if controlled by Tempo Clock
        if (isGlobalDivisionActive) ImGui::BeginDisabled();
        
        if (ImGui::Combo("Division", &division, "1/32\0""1/16\0""1/8\0""1/4\0""1/2\0""1\0""2\0""4\0""8\0\0"))
        {
            if (!isGlobalDivisionActive)
            {
                if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division"))) *p = division;
                onModificationEnded();
            }
        }
        
        if (isGlobalDivisionActive)
        {
            ImGui::EndDisabled();
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
            {
                ImGui::BeginTooltip();
                ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Division Override Active");
                ImGui::TextUnformatted("A Tempo Clock node with 'Division Override' enabled is controlling the global division.");
                ImGui::PopTextWrapPos();
                ImGui::EndTooltip();
            }
        }
    }
    else
    {
        // Rate slider (only shown in free-running mode)
        const bool isRateModulated = isParamModulated("rate_mod");
        float rateDisplay = isRateModulated ? getLiveParamValueFor("rate_mod", "rate_live", rateParam->load()) : rateParam->load();
        
        if (isRateModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat("Rate (Hz)", &rateDisplay, 0.1f, 20.0f, "%.2f")) {
            if (!isRateModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("rate"))) *p = rateDisplay;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
        if (!isRateModulated) adjustParamOnWheel(apvts.getParameter("rate"), "rate", rateDisplay);
        if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
    ImGui::PopItemWidth();
    // --- END SYNC CONTROLS ---

    ImGui::PushItemWidth(itemWidth);

    const bool gtIsModulated = isParamModulated("gateLength_mod");
    float gtEff = gtIsModulated ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f))
                                 : (gateThresholdParam != nullptr ? gateThresholdParam->load() : 0.5f);

    if (gtIsModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat ("Gate Threshold", &gtEff, 0.0f, 1.0f))
    {
        if (! gtIsModulated)
            if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(apvts.getParameter("gateThreshold"))) *p = gtEff;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
    if (! gtIsModulated)
        adjustParamOnWheel (apvts.getParameter ("gateThreshold"), "gateThreshold", gtEff);
    if (gtIsModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::PopItemWidth();

    // --- Per-step Trigger checkboxes row ---
    // Place checkboxes exactly under each slider, matching widths and exact columns
    {
        const float cbWidth = sliderW; // same width as sliders
        for (int i = 0; i < shown; ++i)
        {
            // Compute the same X layout as sliders
            if (i > 0) ImGui::SameLine();

            bool baseTrig = (stepTrigParams.size() > (size_t) i && stepTrigParams[i] != nullptr) ? (bool) (*stepTrigParams[i]) : false;
            // Only grey out when the TRIGGER mod is connected (not the value mod)
            const juce::String trigModId = "step" + juce::String(i + 1) + "_trig_mod";
            const bool trigIsModulated = isParamModulated(trigModId);

            // Use live value for display when modulated
            bool displayTrig = baseTrig;
            if (trigIsModulated) {
                displayTrig = getLiveParamValueFor("step" + juce::String(i + 1) + "_trig_mod",
                                                  "trig_live_" + juce::String(i + 1),
                                                  baseTrig ? 1.0f : 0.0f) > 0.5f;
            }

            if (trigIsModulated) ImGui::BeginDisabled();
            ImGui::PushID(1000 + i);
            ImGui::SetNextItemWidth(cbWidth);
            ImGui::PushItemWidth(cbWidth);
            bool changed = ImGui::Checkbox("##trig", &displayTrig);
            ImGui::PopItemWidth();
            if (changed && !trigIsModulated && stepTrigParams.size() > (size_t) i && stepTrigParams[i] != nullptr)
            {
                // Only update parameter if not modulated
                *stepTrigParams[i] = displayTrig;
            }
            // Fill remaining width so columns align exactly to sliderW
            {
                float used = ImGui::GetItemRectSize().x;
                if (used < cbWidth) { ImGui::SameLine(0.0f, 0.0f); ImGui::Dummy(ImVec2(cbWidth - used, 0.0f)); }
            }
            if (ImGui::IsItemDeactivatedAfterEdit()) { onModificationEnded(); }
            ImGui::PopID();
            if (trigIsModulated) { ImGui::EndDisabled(); }
        }
        // Mod banner if any are modulated
        bool anyTrigMod = false;
        for (int i = 0; i < shown; ++i)
        {
            const juce::String trigModId = "step" + juce::String(i + 1) + "_trig_mod";
            if (isParamInputConnected(trigModId)) { anyTrigMod = true; break; }
        }
        if (anyTrigMod) { ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
}

void StepSequencerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    // ARCHITECTURAL FIX: All inputs are now on a single bus, so we can use direct channel indices
    
    // Main stereo audio input pins (Channels 0-1)
    helpers.drawAudioInputPin("Mod In L", 0);
    helpers.drawAudioInputPin("Mod In R", 1);
    
    // Global modulation inputs (Channels 2-4)
    helpers.drawAudioInputPin("Rate Mod", 2);
    helpers.drawAudioInputPin("Gate Mod", 3);
    helpers.drawAudioInputPin("Steps Mod", 4);
    
    // Dynamic per-step modulation inputs
    const int boundMaxPins = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    int activeSteps = numStepsParam != nullptr ? (int) numStepsParam->load() : 8;

    // FIX: reflect live, modulated steps value (from audio thread telemetry)
    if (isParamInputConnected("numSteps_mod"))
    {
        const int liveSteps = (int) std::round (getLiveParamValueFor("numSteps_mod", "steps_live", (float) activeSteps));
        activeSteps = juce::jlimit (1, boundMaxPins, liveSteps);
    }
    else
    {
        activeSteps = juce::jlimit (1, boundMaxPins, activeSteps);
    }
    
    // Interleaved per-step pins: Step n Mod, Step n Trig Mod, Step n Gate Mod (absolute channels match pin DB)
    for (int i = 0; i < activeSteps; ++i)
    {
        const int stepIdx = i + 1;
        const int valChan  = 6 + (stepIdx - 1);           // 6..21
        const int trigChan = 22 + (stepIdx - 1);          // 22..37
        const int gateChan = 38 + (stepIdx - 1);          // 38..53
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Mod").toRawUTF8(), valChan);
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Trig Mod").toRawUTF8(), trigChan);
        helpers.drawAudioInputPin(("Step " + juce::String(stepIdx) + " Gate Mod").toRawUTF8(), gateChan);
    }

    // Output pins
    helpers.drawAudioOutputPin("Pitch", 0);
    helpers.drawAudioOutputPin("Gate", 1);
    helpers.drawAudioOutputPin("Gate Nuanced", 2);
    helpers.drawAudioOutputPin("Velocity", 3);
    helpers.drawAudioOutputPin("Mod", 4);
    helpers.drawAudioOutputPin("Trigger", 5);

    // Note: helpers API handles pin disappearance when the number of steps shrinks; no manual clear required here.
}
#endif

// Parameter bus contract implementation
bool StepSequencerModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const
{
    // ARCHITECTURAL FIX: All modulation is now on the single input bus at index 0
    outBusIndex = 0;

    // Global Audio/Mod Inputs (Absolute Channels)
    // 0-1: Mod In L/R, 2: Rate, 3: GateLen, 4: Steps, 5: Steps Max
    if (paramId == "rate_mod")       { outChannelIndexInBus = 2; return true; }
    if (paramId == "gateLength_mod") { outChannelIndexInBus = 3; return true; }
    if (paramId == "numSteps_mod")   { outChannelIndexInBus = 4; return true; }

    // Per-Step Trigger Modulation (Absolute Channels 22..37) — check TRIGGER first to avoid matching generic "_mod" suffix
    if (paramId.startsWith("step") && paramId.endsWith("_trig_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_trig_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 22 + (stepNum - 1); // e.g., step1_trig_mod is on channel 22
            return true;
        }
    }

    // Per-Step Value Modulation (Absolute Channels 6..21)
    if (paramId.startsWith("step") && paramId.endsWith("_mod") && !paramId.endsWith("_trig_mod") && !paramId.endsWith("_gate_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 6 + (stepNum - 1); // e.g., step1_mod is on channel 6
            return true;
        }
    }

    // Per-Step Gate Level Modulation (Absolute Channels 38..53)
    if (paramId.startsWith("step") && paramId.endsWith("_gate_mod"))
    {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false)
                           .upToFirstOccurrenceOf("_gate_mod", false, false)
                           .getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS)
        {
            outChannelIndexInBus = 38 + (stepNum - 1); // e.g., step1_gate_mod is on channel 38
            return true;
        }
    }
    
    return false;
}

std::optional<RhythmInfo> StepSequencerModuleProcessor::getRhythmInfo() const
{
    RhythmInfo info;
    
    // Build display name with logical ID
    info.displayName = "Sequencer #" + juce::String(getLogicalId());
    info.sourceType = "sequencer";
    
    // Check if synced to transport
    const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;
    info.isSynced = syncEnabled;
    
    // Check if active (transport playing in sync mode, or always active in free-running)
    if (syncEnabled)
    {
        info.isActive = m_currentTransport.isPlaying;
    }
    else
    {
        info.isActive = true; // Free-running is always active
    }
    
    // Calculate effective BPM
    if (syncEnabled && info.isActive)
    {
        // In sync mode: calculate effective BPM from transport + division
        int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
        
        // Check for global division override from Tempo Clock
        if (getParent())
        {
            int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
            if (globalDiv >= 0)
                divisionIndex = globalDiv;
        }
        
        // Division multipliers: 1/32, 1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8
        static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
        const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
        
        // Effective BPM = transport BPM * division * num_steps
        // (Each complete cycle through all steps = one "measure" in BPM terms)
        const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
        info.bpm = static_cast<float>(m_currentTransport.bpm * beatDivision * numSteps);
    }
    else if (!syncEnabled)
    {
        // Free-running mode: convert Hz rate to BPM
        // Rate is in steps per second, convert to beats per minute
        const float rate = rateParam ? rateParam->load() : 2.0f;
        const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
        
        // One full cycle through all steps = one "beat"
        // BPM = (cycles_per_second) * 60
        // cycles_per_second = rate_hz / num_steps
        info.bpm = (rate / static_cast<float>(numSteps)) * 60.0f;
    }
    else
    {
        // Synced but transport stopped
        info.bpm = 0.0f;
    }
    
    return info;
}




================================================================================
FILE: juce\Source\audio\modules\MultiSequencerModuleProcessor.h
================================================================================


#pragma once

#include "ModuleProcessor.h"

class MultiSequencerModuleProcessor : public ModuleProcessor
{
public:
    static constexpr int MAX_STEPS = 16;
    MultiSequencerModuleProcessor();
    ~MultiSequencerModuleProcessor() override = default;

    const juce::String getName() const override { return "multi_sequencer"; }

    void prepareToPlay (double newSampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }

    // State management for transport settings
    juce::ValueTree getExtraStateTree() const override;
    void setExtraStateTree(const juce::ValueTree&) override;

    juce::String getAudioOutputLabel(int channel) const override;
    juce::String getAudioInputLabel(int channel) const override;
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const override;
    
    // Rhythm reporting for BPM Monitor
    std::optional<RhythmInfo> getRhythmInfo() const override;

#if defined(PRESET_CREATOR_UI)
    std::atomic<bool> autoConnectSamplersTriggered { false };
    std::atomic<bool> autoConnectVCOTriggered { false };

    void drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif

protected:
    void setTimingInfo(const TransportState& state) override;

private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    juce::AudioProcessorValueTreeState apvts;
    std::atomic<int> currentStep { 0 };
    double phase { 0.0 };
    double sampleRate { 44100.0 };

    TransportState m_currentTransport;
    bool wasPlaying = false;

    std::atomic<float>* rateParam { nullptr };
    std::atomic<float>* gateLengthParam { nullptr };
    std::atomic<float>* gateThresholdParam { nullptr };
    std::atomic<float>* rateModParam { nullptr };
    std::atomic<float>* gateLengthModParam { nullptr };
    std::atomic<float>* numStepsModParam { nullptr };
    std::atomic<float>* stepsModMaxParam { nullptr };
    std::vector<std::atomic<float>*> pitchParams;
    std::vector<std::atomic<float>*> stepModParams;
    std::vector<juce::AudioParameterBool*> stepTrigParams;
    std::vector<std::atomic<float>*> stepTrigModParams;
    std::vector<std::atomic<float>*> stepGateParams;
    std::atomic<float>* numStepsParam { nullptr };
    int pendingTriggerSamples { 0 };
    bool previousGateOn { false };
    float gateFadeProgress { 0.0f };
    static constexpr float GATE_FADE_TIME_MS = 5.0f;
};

================================================================================
FILE: juce\Source\audio\modules\MultiSequencerModuleProcessor.cpp
================================================================================


#include "MultiSequencerModuleProcessor.h"
#include "../graph/ModularSynthProcessor.h"
#include <iostream>
#include <array>

#if defined(PRESET_CREATOR_UI)
#include "../../preset_creator/ImGuiNodeEditorComponent.h"
#endif

using APVTS = juce::AudioProcessorValueTreeState;

// This function is a direct copy from the original StepSequencerModuleProcessor.cpp
static juce::NormalisableRange<float> makeRateRange()
{
    juce::NormalisableRange<float> r (0.1f, 20.0f, 0.01f, 0.5f);
    return r;
}

// This function is a direct copy from the original StepSequencerModuleProcessor.cpp
APVTS::ParameterLayout MultiSequencerModuleProcessor::createParameterLayout()
{
	std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps", "Number of Steps", 1, MAX_STEPS, 8));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate", "Rate", makeRateRange(), 2.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength", "Gate Length", juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateThreshold", "Gate Threshold", juce::NormalisableRange<float> (0.0f, 1.0f, 0.001f), 0.5f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("rate_mod", "Rate Mod", 0.0f, 1.0f, 0.0f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("gateLength_mod", "Gate Length Mod", 0.0f, 1.0f, 0.5f));
    params.push_back (std::make_unique<juce::AudioParameterFloat> ("numSteps_mod", "Num Steps Mod", 0.0f, 1.0f, 0.5f));
    params.push_back (std::make_unique<juce::AudioParameterInt> ("numSteps_max", "Num Steps Max", 1, MAX_STEPS, MAX_STEPS));
    
    // Transport sync parameters
    params.push_back(std::make_unique<juce::AudioParameterBool>("sync", "Sync to Transport", false));
    params.push_back(std::make_unique<juce::AudioParameterChoice>("rate_division", "Division", 
        juce::StringArray{ "1/32", "1/16", "1/8", "1/4", "1/2", "1", "2", "4", "8" }, 3));
    
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        const juce::String pid = "step" + juce::String (i + 1);
        params.push_back (std::make_unique<juce::AudioParameterFloat> (pid, pid, juce::NormalisableRange<float> (0.0f, 1.0f), 0.5f));
        const juce::String modPid = "step" + juce::String(i + 1) + "_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(modPid, modPid, 0.0f, 1.0f, 0.5f));
        const juce::String trigPid = "step" + juce::String(i + 1) + "_trig";
        params.push_back(std::make_unique<juce::AudioParameterBool>(trigPid, trigPid, false));
        const juce::String trigModPid = "step" + juce::String(i + 1) + "_trig_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(trigModPid, trigModPid, 0.0f, 1.0f, 0.5f));
        const juce::String gatePid = "step" + juce::String(i + 1) + "_gate";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gatePid, gatePid, 0.0f, 1.0f, 0.8f));
        const juce::String gateModPid = "step" + juce::String(i + 1) + "_gate_mod";
        params.push_back(std::make_unique<juce::AudioParameterFloat>(gateModPid, gateModPid, 0.0f, 1.0f, 0.5f));
	}
	return { params.begin(), params.end() };
}

MultiSequencerModuleProcessor::MultiSequencerModuleProcessor()
    // <<< CHANGE 1: Update the output bus to add per-step outputs
    : ModuleProcessor (BusesProperties()
                           .withInput("Inputs", juce::AudioChannelSet::discreteChannels(2 + 4 + (MAX_STEPS * 3)), true)
                           .withOutput ("Outputs", juce::AudioChannelSet::discreteChannels(6 + (MAX_STEPS * 3)), true)),
      apvts (*this, nullptr, "SeqParams", createParameterLayout())
{
    numStepsParam      = apvts.getRawParameterValue ("numSteps");
    rateParam          = apvts.getRawParameterValue ("rate");
    gateLengthParam    = apvts.getRawParameterValue ("gateLength");
    gateThresholdParam = apvts.getRawParameterValue ("gateThreshold");
    rateModParam       = apvts.getRawParameterValue ("rate_mod");
    gateLengthModParam = apvts.getRawParameterValue ("gateLength_mod");
    numStepsModParam   = apvts.getRawParameterValue ("numSteps_mod");
    stepsModMaxParam   = apvts.getRawParameterValue ("numSteps_max");
    
    pitchParams.resize (MAX_STEPS);
	stepModParams.resize(MAX_STEPS);
	stepTrigParams.resize(MAX_STEPS);
    stepTrigModParams.resize(MAX_STEPS);
    stepGateParams.resize(MAX_STEPS);
	for (int i = 0; i < MAX_STEPS; ++i)
	{
        pitchParams[i] = apvts.getRawParameterValue ("step" + juce::String (i + 1));
		stepModParams[i] = apvts.getRawParameterValue("step" + juce::String(i + 1) + "_mod");
		stepTrigParams[i] = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("step" + juce::String(i + 1) + "_trig"));
        stepTrigModParams[i] = apvts.getRawParameterValue("step" + juce::String(i + 1) + "_trig_mod");
        stepGateParams[i] = apvts.getRawParameterValue("step" + juce::String(i + 1) + "_gate");
	}

    // <<< CHANGE 2: Initialize for all 54 outputs
    for (int i = 0; i < 6 + (MAX_STEPS * 3); ++i)
		lastOutputValues.push_back(std::make_unique<std::atomic<float>>(0.0f));
}

void MultiSequencerModuleProcessor::prepareToPlay (double newSampleRate, int samplesPerBlock)
{
    juce::ignoreUnused (samplesPerBlock);
    sampleRate = newSampleRate > 0.0 ? newSampleRate : 44100.0;
	phase = 0.0;
}

void MultiSequencerModuleProcessor::setTimingInfo(const TransportState& state)
{
    // Check if the transport has just started playing
    if (state.isPlaying && !wasPlaying)
    {
        // Reset to the beginning when play is pressed
        currentStep.store(0);
        phase = 0.0;
    }
    wasPlaying = state.isPlaying;
    
    m_currentTransport = state;
}

juce::ValueTree MultiSequencerModuleProcessor::getExtraStateTree() const
{
    juce::ValueTree vt("SequencerState");
    vt.setProperty("sync", apvts.getRawParameterValue("sync")->load(), nullptr);
    vt.setProperty("rate_division", apvts.getRawParameterValue("rate_division")->load(), nullptr);
    return vt;
}

void MultiSequencerModuleProcessor::setExtraStateTree(const juce::ValueTree& vt)
{
    if (vt.hasType("SequencerState"))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(apvts.getParameter("sync")))
            *p = (bool)vt.getProperty("sync", false);
        if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(apvts.getParameter("rate_division")))
            *p = (int)vt.getProperty("rate_division", 3);
    }
}

void MultiSequencerModuleProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midi)
{
    // --- PART 1: The original, working StepSequencer logic for "Live" outputs ---
    juce::ignoreUnused (midi);
    if (rateParam == nullptr || numStepsParam == nullptr || gateLengthParam == nullptr)
    {
        buffer.clear();
        return;
    }

    const int numSamples = buffer.getNumSamples();
    const auto& inputBus = getBusBuffer(buffer, true, 0);
    auto* pitchOut       = buffer.getWritePointer(0);
    auto* gateOut        = buffer.getNumChannels() > 1 ? buffer.getWritePointer(1) : nullptr;
    auto* gateNuancedOut = buffer.getNumChannels() > 2 ? buffer.getWritePointer(2) : nullptr;
    auto* velocityOut    = buffer.getNumChannels() > 3 ? buffer.getWritePointer(3) : nullptr;
    auto* modOut         = buffer.getNumChannels() > 4 ? buffer.getWritePointer(4) : nullptr;
    auto* trigOut        = buffer.getNumChannels() > 5 ? buffer.getWritePointer(5) : nullptr;
    
    const bool isRateMod = isParamInputConnected("rate_mod");
    const bool isGateLenMod = isParamInputConnected("gateLength_mod");
    const bool isStepsMod = isParamInputConnected("numSteps_mod");
    const float* rateCV = isRateMod && inputBus.getNumChannels() > 2 ? inputBus.getReadPointer(2) : nullptr;
    const float* gateLenCV = isGateLenMod && inputBus.getNumChannels() > 3 ? inputBus.getReadPointer(3) : nullptr;
    const float* stepsCV = isStepsMod && inputBus.getNumChannels() > 4 ? inputBus.getReadPointer(4) : nullptr;
    
    const float baseRate = rateParam->load();
    const float baseGate = gateLengthParam->load();
    const int baseSteps = (int) numStepsParam->load();
    const int boundMax = stepsModMaxParam != nullptr ? juce::jlimit (1, MAX_STEPS, (int) stepsModMaxParam->load()) : MAX_STEPS;
    const float gateThreshold = gateThresholdParam != nullptr ? juce::jlimit(0.0f, 1.0f, gateThresholdParam->load()) : 0.5f;

    // --- UI Telemetry Bootstrap (from old StepSequencer) ---
    // Publish per-step live values for ALL steps this block (use first-sample snapshot)
    {
        const int totalCh = inputBus.getNumChannels();
        for (int si = 0; si < MAX_STEPS; ++si)
        {
            // Absolute channel for per-step value mod: 6..21
            const int ch = 6 + si;
            const bool hasCh = totalCh > ch;
            const float base = (pitchParams.size() > (size_t) si && pitchParams[si] != nullptr) ? pitchParams[si]->load() : 0.0f;
            float live = base;
            if (hasCh && isParamInputConnected("step" + juce::String(si + 1) + "_mod"))
            {
                const float cv0 = inputBus.getReadPointer(ch)[0];
                live = juce::jlimit(0.0f, 1.0f, base + (cv0 - 0.5f));
            }
            setLiveParamValue("step_live_" + juce::String(si + 1), live);

            // Per-step gate live values: channels 38..53
            const int gateCh = 38 + si;
            const bool hasGateCh = totalCh > gateCh;
            const float baseGateVal = (stepGateParams.size() > (size_t) si && stepGateParams[si] != nullptr) ? stepGateParams[si]->load() : 0.8f;
            float liveGate = baseGateVal;
            if (hasGateCh && isParamInputConnected("step" + juce::String(si + 1) + "_gate_mod"))
            {
                const float cv0 = inputBus.getReadPointer(gateCh)[0];
                liveGate = juce::jlimit(0.0f, 1.0f, baseGateVal + (cv0 - 0.5f));
            }
            setLiveParamValue("gate_live_" + juce::String(si + 1), liveGate);

            // Per-step trigger live values: channels 22..37
            const int trigCh = 22 + si;
            const bool hasTrigCh = totalCh > trigCh;
            const bool baseTrig = (stepTrigParams.size() > (size_t) si && stepTrigParams[si] != nullptr) ? (bool)(*stepTrigParams[si]) : false;
            bool liveTrig = baseTrig;
            if (hasTrigCh && isParamInputConnected("step" + juce::String(si + 1) + "_trig_mod"))
            {
                const float cv0 = inputBus.getReadPointer(trigCh)[0];
                liveTrig = cv0 > 0.5f;
            }
            setLiveParamValue("trig_live_" + juce::String(si + 1), liveTrig ? 1.0f : 0.0f);
        }
    }

    bool stepAdvanced = false;
    float lastRateLive = baseRate;
    float lastGateLive = baseGate;
    float lastGateThresholdLive = gateThreshold;
    int   lastStepsLive = baseSteps;

	for (int i = 0; i < numSamples; ++i)
	{
        int activeSteps = baseSteps;
        if (isStepsMod && stepsCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, stepsCV[i]);
            const int mapped = 1 + (int) std::round(cv * (MAX_STEPS - 1));
            activeSteps = juce::jlimit(1, boundMax, mapped);
        }
        if (currentStep.load() >= activeSteps)
            currentStep.store(0);
        
        float rate = baseRate;
        if (isRateMod && rateCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, rateCV[i]);
            const float modRateHz = 0.01f + cv * (50.0f - 0.01f);
            rate = modRateHz;
        }
        lastRateLive = rate;
        
        float gateLen = baseGate;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            gateLen = juce::jlimit(0.0f, 1.0f, cv);
        }
        lastGateLive = gateLen;
        
        float gateThresholdLive = gateThreshold;
        if (isGateLenMod && gateLenCV != nullptr) {
            const float cv = juce::jlimit(0.0f, 1.0f, gateLenCV[i]);
            gateThresholdLive = juce::jlimit(0.0f, 1.0f, cv);
        }
        lastGateThresholdLive = gateThresholdLive;
        
        // --- Transport Sync Logic ---
        const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;

        if (syncEnabled && m_currentTransport.isPlaying)
        {
            // SYNC MODE: Use the global beat position
            int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
            // Use global division if a Tempo Clock has override enabled
            // IMPORTANT: Read from parent's LIVE transport state, not cached copy (which is stale)
            if (getParent())
            {
                int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
                if (globalDiv >= 0)
                    divisionIndex = globalDiv;
            }
            static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
            const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
            
            // Calculate which step we should be on based on song position
            const int totalSteps = juce::jlimit(1, MAX_STEPS, activeSteps);
            const int stepForBeat = static_cast<int>(std::fmod(m_currentTransport.songPositionBeats * beatDivision, totalSteps));

            if (stepForBeat != currentStep.load())
            {
                currentStep.store(stepForBeat);
                stepAdvanced = true;
            }
        }
        else
        {
            // FREE-RUNNING MODE: Use the internal phase clock
            const double phaseInc = (sampleRate > 0.0 ? (double) rate / sampleRate : 0.0);
            phase += phaseInc;
            if (phase >= 1.0)
            {
                phase -= 1.0;
                const int next = (currentStep.load() + 1) % juce::jlimit (1, MAX_STEPS, activeSteps);
                currentStep.store(next);
                stepAdvanced = true;
            }
        }
        lastStepsLive = activeSteps;

        const int currentStepIndex = currentStep.load();
        const float sliderValue = pitchParams[currentStepIndex] != nullptr ? pitchParams[currentStepIndex]->load() : 0.0f;
        
        float rawModValue = 0.5f;
        const auto stepModId = "step" + juce::String(currentStepIndex + 1) + "_mod";
        if (isParamInputConnected(stepModId))
        {
            const int modChannel = 6 + currentStepIndex;
            if (inputBus.getNumChannels() > modChannel)
                rawModValue = inputBus.getReadPointer(modChannel)[i];
        }
        const float modValue = rawModValue - 0.5f;
        const float pitchValue = juce::jlimit (0.0f, 1.0f, sliderValue + modValue);
        
        float stepGateLevel = (stepGateParams[currentStepIndex] != nullptr) ? stepGateParams[currentStepIndex]->load() : 0.8f;
        const auto gateModId = "step" + juce::String(currentStepIndex + 1) + "_gate_mod";
        if (isParamInputConnected(gateModId))
        {
            const int gateModChannel = 38 + currentStepIndex;
            if (inputBus.getNumChannels() > gateModChannel)
            {
                const float cv = inputBus.getReadPointer(gateModChannel)[i];
                stepGateLevel = juce::jlimit(0.0f, 1.0f, stepGateLevel + (cv - 0.5f));
            }
        }

        const bool isGateOn = (stepGateLevel >= gateThresholdLive);
        if (isGateOn && !previousGateOn) {
            gateFadeProgress = 0.0f;
        } else if (!isGateOn && previousGateOn) {
            gateFadeProgress = 0.0f;
        }
        
        const float fadeIncrement = sampleRate > 0.0f ? (1000.0f / GATE_FADE_TIME_MS) / sampleRate : 0.0f;
        gateFadeProgress = juce::jmin(1.0f, gateFadeProgress + fadeIncrement);
        const float fadeMultiplier = isGateOn ? gateFadeProgress : (1.0f - gateFadeProgress);
        
        const float gateBinaryValue = (phase < gateLen) && isGateOn ? fadeMultiplier : 0.0f;
        const float gateNuancedValue = (phase < gateLen) && isGateOn ? (stepGateLevel * fadeMultiplier) : 0.0f;
        previousGateOn = isGateOn;
        
        bool trigActive = (stepTrigParams[currentStepIndex]) ? (bool)(*stepTrigParams[currentStepIndex]) : false;
        const auto trigModId = "step" + juce::String(currentStepIndex + 1) + "_trig_mod";
        if (isParamInputConnected(trigModId))
        {
            const int trigModChannel = 22 + currentStepIndex;
            if (inputBus.getNumChannels() > trigModChannel)
            {
                if (inputBus.getReadPointer(trigModChannel)[i] > 0.5f) trigActive = true;
            }
        }
        
        if (stepAdvanced) {
            pendingTriggerSamples = trigActive ? (int) std::round (0.001 * sampleRate) : 0;
            stepAdvanced = false;
        }

        pitchOut[i] = pitchValue;
        if (gateOut) gateOut[i] = gateBinaryValue;
        if (gateNuancedOut) gateNuancedOut[i] = gateNuancedValue;
        if (velocityOut) velocityOut[i] = 0.85f;
        if (modOut) modOut[i] = 0.0f;
        if (trigOut) {
            trigOut[i] = (pendingTriggerSamples > 0) ? 1.0f : 0.0f;
            if (pendingTriggerSamples > 0) --pendingTriggerSamples;
        }
    }
    setLiveParamValue("rate_live", lastRateLive);
    setLiveParamValue("gateLength_live", lastGateLive);
    setLiveParamValue("gateThreshold_live", lastGateThresholdLive);
    setLiveParamValue("steps_live", (float) lastStepsLive);

    // --- PART 2: NEW Logic to populate the parallel static outputs ---
    auto outBus = getBusBuffer(buffer, false, 0);
    for (int step = 0; step < lastStepsLive; ++step)
    {
        const float baseValue = pitchParams[step] ? pitchParams[step]->load() : 0.0f;
        float liveValue = baseValue;
        const int modChannel = 6 + step;
        if (isParamInputConnected("step" + juce::String(step + 1) + "_mod") && inputBus.getNumChannels() > modChannel) {
            liveValue = juce::jlimit(0.0f, 1.0f, baseValue + (inputBus.getReadPointer(modChannel)[0] - 0.5f));
        }

        const bool baseTrig = stepTrigParams[step] ? (bool)(*stepTrigParams[step]) : false;
        bool liveTrig = baseTrig;
        const int trigModChannel = 22 + step;
        if (isParamInputConnected("step" + juce::String(step + 1) + "_trig_mod") && inputBus.getNumChannels() > trigModChannel) {
            liveTrig = inputBus.getReadPointer(trigModChannel)[0] > 0.5f;
        }

        // --- THE FIX IS HERE ---
        // The trigger is only high if it's enabled AND the playhead is on this step.
        const float trigOutputValue = (liveTrig && step == currentStep.load()) ? 1.0f : 0.0f;

        float gateLevel = stepGateParams[step] ? stepGateParams[step]->load() : 0.8f;
        const int gateModChannel = 38 + step;
        if (isParamInputConnected("step" + juce::String(step + 1) + "_gate_mod") && inputBus.getNumChannels() > gateModChannel) {
             const float cv = inputBus.getReadPointer(gateModChannel)[0];
             gateLevel = juce::jlimit(0.0f, 1.0f, gateLevel + (cv - 0.5f));
        }

        int pitchOutChannel = 7 + step * 3 + 0;
        int gateOutChannel  = 7 + step * 3 + 1;
        int trigOutChannel  = 7 + step * 3 + 2;

        // Fill the buffers with the correct values
        if (pitchOutChannel < outBus.getNumChannels())
            juce::FloatVectorOperations::fill(outBus.getWritePointer(pitchOutChannel), liveValue, numSamples);
            
        if (gateOutChannel < outBus.getNumChannels())
            juce::FloatVectorOperations::fill(outBus.getWritePointer(gateOutChannel), gateLevel, numSamples);

        if (trigOutChannel < outBus.getNumChannels())
            juce::FloatVectorOperations::fill(outBus.getWritePointer(trigOutChannel), trigOutputValue, numSamples);
    }
    
    // --- Write the number of active steps to the Num Steps output pin (channel 6) ---
    if (outBus.getNumChannels() > 6)
    {
        juce::FloatVectorOperations::fill(outBus.getWritePointer(6), (float)lastStepsLive, numSamples);
    }
    
    if (lastOutputValues.size() >= (size_t)outBus.getNumChannels()) {
        for (int ch = 0; ch < outBus.getNumChannels(); ++ch)
            if (lastOutputValues[ch]) lastOutputValues[ch]->store(outBus.getSample(ch, numSamples - 1));
    }
}


#if defined(PRESET_CREATOR_UI)
// ... The rest of your file (drawParametersInNode, etc.) remains unchanged ...
void MultiSequencerModuleProcessor::drawParametersInNode (float itemWidth, const std::function<bool(const juce::String& paramId)>& isParamModulated, const std::function<void()>& onModificationEnded)
{
    auto& ap = getAPVTS();
    int activeSteps = numStepsParam ? (int)numStepsParam->load() : 8;
    const int boundMaxUi = stepsModMaxParam ? juce::jlimit(1, MAX_STEPS, (int)stepsModMaxParam->load()) : MAX_STEPS;
    const bool stepsAreModulated = isParamInputConnected("numSteps_mod");
    if (stepsAreModulated) {
        activeSteps = juce::jlimit(1, boundMaxUi, (int)std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float)activeSteps)));
    }
    int displayedSteps = activeSteps;
    if (stepsAreModulated) ImGui::BeginDisabled();
    ImGui::PushItemWidth(itemWidth);
    if (ImGui::SliderInt("Steps", &displayedSteps, 1, boundMaxUi)) {
        if (!stepsAreModulated) if (auto* p = dynamic_cast<juce::AudioParameterInt*>(ap.getParameter("numSteps"))) *p = displayedSteps;
    }
    if (!stepsAreModulated) adjustParamOnWheel(ap.getParameter("numSteps"), "numSteps", (float)displayedSteps);
    if (ImGui::IsItemDeactivatedAfterEdit() && !stepsAreModulated) onModificationEnded();
    ImGui::PopItemWidth();
    if (stepsAreModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }

    const int shown = juce::jlimit(1, MAX_STEPS, displayedSteps);
    // Calculate responsive step width based on itemWidth and spacing
    const float spacing = 4.0f;
    const float sliderW = (itemWidth - spacing * (shown - 1)) / (float)shown;
    
    // Apply the calculated spacing to ItemSpacing for consistent grid layout
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));
    
    // CRITICAL FIX: Use BeginGroup() to constrain the grid to exactly itemWidth
    // This prevents the first item from expanding to full width
    ImGui::BeginGroup();
    for (int i = 0; i < shown; ++i) {
        if (i > 0) ImGui::SameLine();
        float baseValue = (pitchParams[i]) ? pitchParams[i]->load() : 0.5f;
        const auto modPid = "step" + juce::String(i + 1) + "_mod";
        const bool modConnected = isParamInputConnected(modPid);
        float liveValue = getLiveParamValueFor(modPid, "step_live_" + juce::String(i + 1), baseValue);
        float sliderValue = modConnected ? liveValue : baseValue;
        const bool isActive = (i == currentStep.load());
        if (isActive) {
            ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.3f, 0.7f, 1.0f, 1.0f));
            ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.9f, 0.9f, 0.9f, 1.0f));
        }
        ImGui::PushID(i);
        if (modConnected) ImGui::BeginDisabled();
        if (ImGui::VSliderFloat("##s", ImVec2(sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, "")) {
            if (!modConnected) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("step" + juce::String(i + 1)))) *p = sliderValue;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        if (!modConnected) {
            if (ImGui::IsItemHovered()) {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f) {
                    if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("step" + juce::String(i + 1)))) *p = juce::jlimit(0.0f, 1.0f, baseValue + (wheel > 0 ? 0.05f : -0.05f));
                }
            }
        }
        if (modConnected) ImGui::EndDisabled();
        if (isActive) ImGui::PopStyleColor(2);
        ImGui::PopID();
    }
    ImGui::EndGroup();  // End pitch sliders group
    
    ImGui::PopStyleVar(); // Pop ItemSpacing for value sliders

    // Apply spacing for gate sliders grid
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));
    ImVec2 gate_sliders_p0 = ImGui::GetCursorScreenPos();
    
    // CRITICAL FIX: Use BeginGroup() to constrain the grid
    ImGui::BeginGroup();
    for (int i = 0; i < shown; ++i) {
		if (i > 0) ImGui::SameLine();
        ImGui::PushID(2000 + i);
        float baseGateValue = (stepGateParams[i]) ? stepGateParams[i]->load() : 0.8f;
        const auto modPid = "step" + juce::String(i + 1) + "_gate_mod";
        const bool modConnected = isParamInputConnected(modPid);
        float sliderValue = modConnected ? getLiveParamValueFor(modPid, "gate_live_" + juce::String(i + 1), baseGateValue) : baseGateValue;
        const bool isActive = (i == currentStep.load());
        if (isActive) ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(1.0f, 0.7f, 0.3f, 1.0f));
        if (modConnected) ImGui::BeginDisabled();
        if (ImGui::VSliderFloat("##g", ImVec2(sliderW, 60.0f), &sliderValue, 0.0f, 1.0f, "")) {
            if (!modConnected && stepGateParams[i]) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("step" + juce::String(i + 1) + "_gate"))) *p = sliderValue;
		}
		if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        if (!modConnected) {
            if (ImGui::IsItemHovered()) {
                float wheel = ImGui::GetIO().MouseWheel;
                if (wheel != 0.0f) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("step" + juce::String(i + 1) + "_gate"))) *p = juce::jlimit(0.0f, 1.0f, sliderValue + (wheel > 0 ? 0.05f : -0.05f));
            }
        }
        if (modConnected) ImGui::EndDisabled();
		if (isActive) ImGui::PopStyleColor();
		ImGui::PopID();
	}
    ImGui::EndGroup();  // End gate sliders group
    
    ImGui::PopStyleVar(); // Pop ItemSpacing for gate sliders
    
    // Draw threshold line overlay on the gate sliders
    const bool gtIsModulatedForLine = isParamInputConnected("gateLength_mod");
    const float threshold_value = gtIsModulatedForLine ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam ? gateThresholdParam->load() : 0.5f)) : (gateThresholdParam ? gateThresholdParam->load() : 0.5f);
    const float slider_height = 60.0f;
    const float row_width = (sliderW * shown) + (spacing * (shown - 1));
    const float line_y = gate_sliders_p0.y + (1.0f - threshold_value) * slider_height;
    ImGui::GetWindowDrawList()->AddLine(ImVec2(gate_sliders_p0.x, line_y), ImVec2(gate_sliders_p0.x + row_width, line_y), IM_COL32(255, 255, 0, 200), 2.0f);
    
    // Apply spacing for trigger checkbox grid (MOVED HERE - directly after gate sliders!)
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));
    
    // CRITICAL FIX: Use BeginGroup() to constrain the grid
    ImGui::BeginGroup();
    for (int i = 0; i < shown; ++i) {
        if (i > 0) ImGui::SameLine();
        bool baseTrig = (stepTrigParams.size() > (size_t)i && stepTrigParams[i]) ? (bool)(*stepTrigParams[i]) : false;
        const auto trigModId = "step" + juce::String(i + 1) + "_trig_mod";
        const bool trigIsModulated = isParamInputConnected(trigModId);
        bool displayTrig = trigIsModulated ? getLiveParamValueFor(trigModId, "trig_live_" + juce::String(i + 1), baseTrig ? 1.0f : 0.0f) > 0.5f : baseTrig;
        if (trigIsModulated) ImGui::BeginDisabled();
        ImGui::PushID(1000 + i);
        if (ImGui::Checkbox("##trig", &displayTrig) && !trigIsModulated && stepTrigParams[i]) *stepTrigParams[i] = displayTrig;
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        ImGui::PopID();
        if (trigIsModulated) ImGui::EndDisabled();
    }
    ImGui::EndGroup();  // End checkboxes group
    
    ImGui::PopStyleVar(); // Pop ItemSpacing for trigger checkboxes
    
    ImGui::Text("Current Step: %d", currentStep.load() + 1);
    
    // --- SYNC CONTROLS ---
    bool sync = apvts.getRawParameterValue("sync")->load() > 0.5f;
    if (ImGui::Checkbox("Sync to Transport", &sync))
    {
        if (auto* p = dynamic_cast<juce::AudioParameterBool*>(ap.getParameter("sync"))) *p = sync;
        onModificationEnded();
    }

    ImGui::PushItemWidth(itemWidth);
    if (sync)
    {
        // Check if global division is active (Tempo Clock override)
        // IMPORTANT: Read from parent's LIVE transport state, not cached copy
        int globalDiv = getParent() ? getParent()->getTransportState().globalDivisionIndex.load() : -1;
        bool isGlobalDivisionActive = globalDiv >= 0;
        int division = isGlobalDivisionActive ? globalDiv : (int)apvts.getRawParameterValue("rate_division")->load();
        
        // Grey out if controlled by Tempo Clock
        if (isGlobalDivisionActive) ImGui::BeginDisabled();
        
        if (ImGui::Combo("Division", &division, "1/32\0""1/16\0""1/8\0""1/4\0""1/2\0""1\0""2\0""4\0""8\0\0"))
        {
            if (!isGlobalDivisionActive)
            {
                if (auto* p = dynamic_cast<juce::AudioParameterChoice*>(ap.getParameter("rate_division"))) *p = division;
                onModificationEnded();
            }
        }
        
        if (isGlobalDivisionActive)
        {
            ImGui::EndDisabled();
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled))
            {
                ImGui::BeginTooltip();
                ImGui::PushTextWrapPos(ImGui::GetFontSize() * 25.0f);
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.0f, 1.0f), "Tempo Clock Division Override Active");
                ImGui::TextUnformatted("A Tempo Clock node with 'Division Override' enabled is controlling the global division.");
                ImGui::PopTextWrapPos();
                ImGui::EndTooltip();
            }
        }
    }
    else
    {
        // Rate slider (only shown in free-running mode)
        const bool isRateModulated = isParamInputConnected("rate_mod");
        float rateDisplay = isRateModulated ? getLiveParamValueFor("rate_mod", "rate_live", rateParam->load()) : rateParam->load();
        
        if (isRateModulated) ImGui::BeginDisabled();
        if (ImGui::SliderFloat("Rate (Hz)", &rateDisplay, 0.1f, 20.0f, "%.2f")) {
            if (!isRateModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("rate"))) *p = rateDisplay;
        }
        if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
        if (!isRateModulated) adjustParamOnWheel(ap.getParameter("rate"), "rate", rateDisplay);
        if (isRateModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    }
    ImGui::PopItemWidth();
    // --- END SYNC CONTROLS ---

    ImGui::PushItemWidth(itemWidth);

    const bool gtIsModulated = isParamInputConnected("gateLength_mod");
    float gtEff = gtIsModulated ? getLiveParamValueFor("gateLength_mod", "gateThreshold_live", (gateThresholdParam ? gateThresholdParam->load() : 0.5f)) : (gateThresholdParam ? gateThresholdParam->load() : 0.5f);
    if (gtIsModulated) ImGui::BeginDisabled();
    if (ImGui::SliderFloat("Gate Threshold", &gtEff, 0.0f, 1.0f)) {
        if (!gtIsModulated) if (auto* p = dynamic_cast<juce::AudioParameterFloat*>(ap.getParameter("gateThreshold"))) *p = gtEff;
    }
    if (ImGui::IsItemDeactivatedAfterEdit()) onModificationEnded();
    if (!gtIsModulated) adjustParamOnWheel(ap.getParameter("gateThreshold"), "gateThreshold", gtEff);
    if (gtIsModulated) { ImGui::EndDisabled(); ImGui::SameLine(); ImGui::TextUnformatted("(mod)"); }
    ImGui::PopItemWidth();
    
    // ADDED: Auto-connect buttons
    if (ImGui::Button("Connect to Samplers", ImVec2(itemWidth, 0))) { autoConnectSamplersTriggered = true; }
    if (ImGui::Button("Connect to PolyVCO", ImVec2(itemWidth, 0))) { autoConnectVCOTriggered = true; }
}

void MultiSequencerModuleProcessor::drawIoPins(const NodePinHelpers& helpers)
{
    const int boundMaxPins = stepsModMaxParam ? juce::jlimit(1, MAX_STEPS, (int)stepsModMaxParam->load()) : MAX_STEPS;
    int activeSteps = numStepsParam ? (int)numStepsParam->load() : 8;
    if (isParamInputConnected("numSteps_mod")) {
        activeSteps = juce::jlimit(1, boundMaxPins, (int)std::round(getLiveParamValueFor("numSteps_mod", "steps_live", (float)activeSteps)));
    } else {
        activeSteps = juce::jlimit(1, boundMaxPins, activeSteps);
    }
    
    // --- Section 1: Global I/O (Parallel Layout for Compactness) ---
    helpers.drawParallelPins("Mod In L", 0, "Pitch", 0);
    helpers.drawParallelPins("Mod In R", 1, "Gate", 1);
    helpers.drawParallelPins("Rate Mod", 2, "Gate Nuanced", 2);
    helpers.drawParallelPins("Gate Mod", 3, "Velocity", 3);
    helpers.drawParallelPins("Steps Mod", 4, "Mod", 4);
    helpers.drawParallelPins(nullptr, -1, "Trigger", 5);
    helpers.drawParallelPins(nullptr, -1, "Num Steps", 6);
    
    ImGui::Spacing();

    // --- Section 2: Per-Step I/O (Parallel Layout for Compactness) ---
    for (int i = 0; i < activeSteps; ++i)
    {
        const juce::String stepStr = " " + juce::String(i + 1);
        
        // Draw all 3 I/O pairs for this step on consecutive lines
        helpers.drawParallelPins(("Step" + stepStr + " Mod").toRawUTF8(), 6 + i, 
                                ("Pitch" + stepStr).toRawUTF8(), 7 + i * 3 + 0);
        helpers.drawParallelPins(("Step" + stepStr + " Gate Mod").toRawUTF8(), 38 + i, 
                                ("Gate" + stepStr).toRawUTF8(), 7 + i * 3 + 1);
        helpers.drawParallelPins(("Step" + stepStr + " Trig Mod").toRawUTF8(), 22 + i, 
                                ("Trig" + stepStr).toRawUTF8(), 7 + i * 3 + 2);
	}
}
#endif

juce::String MultiSequencerModuleProcessor::getAudioOutputLabel(int channel) const
{
    switch (channel) {
        case 0: return "Pitch";
        case 1: return "Gate";
        case 2: return "Gate Nuanced";
        case 3: return "Velocity";
        case 4: return "Mod";
        case 5: return "Trigger";
        case 6: return "Num Steps";
    }
    int stepChannel = channel - 7;
    if (stepChannel >= 0 && stepChannel < MAX_STEPS * 3) {
        int step = (stepChannel / 3) + 1;
        int outputType = stepChannel % 3;
        switch (outputType) {
            case 0: return "Pitch " + juce::String(step);
            case 1: return "Gate " + juce::String(step);
            case 2: return "Trig " + juce::String(step);
        }
    }
	return {};
}

juce::String MultiSequencerModuleProcessor::getAudioInputLabel(int channel) const {
    switch (channel) {
        case 0: return "Mod In L";
        case 1: return "Mod In R";
        case 2: return "Rate Mod";
        case 3: return "Gate Mod";
        case 4: return "Steps Mod";
    }
    if (channel >= 6 && channel < 6 + MAX_STEPS) return "Step " + juce::String(channel - 5) + " Mod";
    if (channel >= 22 && channel < 22 + MAX_STEPS) return "Step " + juce::String(channel - 21) + " Trig Mod";
    if (channel >= 38 && channel < 38 + MAX_STEPS) return "Step " + juce::String(channel - 37) + " Gate Mod";
	return {};
}

bool MultiSequencerModuleProcessor::getParamRouting(const juce::String& paramId, int& outBusIndex, int& outChannelIndexInBus) const {
	outBusIndex = 0;
    if (paramId == "rate_mod") { outChannelIndexInBus = 2; return true; }
    if (paramId == "gateLength_mod") { outChannelIndexInBus = 3; return true; }
    if (paramId == "numSteps_mod") { outChannelIndexInBus = 4; return true; }
    if (paramId.startsWith("step") && paramId.endsWith("_mod") && !paramId.endsWith("_trig_mod") && !paramId.endsWith("_gate_mod")) {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false).upToFirstOccurrenceOf("_mod", false, false).getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS) { outChannelIndexInBus = 6 + (stepNum - 1); return true; }
    }
    if (paramId.startsWith("step") && paramId.endsWith("_trig_mod")) {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false).upToFirstOccurrenceOf("_trig_mod", false, false).getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS) { outChannelIndexInBus = 22 + (stepNum - 1); return true; }
    }
    if (paramId.startsWith("step") && paramId.endsWith("_gate_mod")) {
        int stepNum = paramId.fromFirstOccurrenceOf("step", false, false).upToFirstOccurrenceOf("_gate_mod", false, false).getIntValue();
        if (stepNum > 0 && stepNum <= MAX_STEPS) { outChannelIndexInBus = 38 + (stepNum - 1); return true; }
	}
	return false;
}

std::optional<RhythmInfo> MultiSequencerModuleProcessor::getRhythmInfo() const
{
    RhythmInfo info;
    
    // Build display name with logical ID
    info.displayName = "Multi Seq #" + juce::String(getLogicalId());
    info.sourceType = "multi_sequencer";
    
    // Check if synced to transport
    const bool syncEnabled = apvts.getRawParameterValue("sync")->load() > 0.5f;
    info.isSynced = syncEnabled;
    
    // Check if active
    if (syncEnabled)
    {
        info.isActive = m_currentTransport.isPlaying;
    }
    else
    {
        info.isActive = true; // Free-running is always active
    }
    
    // Calculate effective BPM (same logic as StepSequencer)
    if (syncEnabled && info.isActive)
    {
        int divisionIndex = (int)apvts.getRawParameterValue("rate_division")->load();
        
        if (getParent())
        {
            int globalDiv = getParent()->getTransportState().globalDivisionIndex.load();
            if (globalDiv >= 0)
                divisionIndex = globalDiv;
        }
        
        static const double divisions[] = { 1.0/32.0, 1.0/16.0, 1.0/8.0, 1.0/4.0, 1.0/2.0, 1.0, 2.0, 4.0, 8.0 };
        const double beatDivision = divisions[juce::jlimit(0, 8, divisionIndex)];
        
        const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
        info.bpm = static_cast<float>(m_currentTransport.bpm * beatDivision * numSteps);
    }
    else if (!syncEnabled)
    {
        const float rate = rateParam ? rateParam->load() : 2.0f;
        const int numSteps = numStepsParam ? (int)numStepsParam->load() : 8;
        info.bpm = (rate / static_cast<float>(numSteps)) * 60.0f;
    }
    else
    {
        info.bpm = 0.0f;
    }
    
    return info;
}


================================================================================
FILE: juce\Source\animation\AnimationData.h
================================================================================


#pragma once

#include <string>
#include <vector>
#include <map>

#include <glm/glm.hpp>
#include <glm/gtc/quaternion.hpp>

struct KeyPosition
{
    glm::vec3 position;
    double timeStamp;
};

struct KeyRotation
{
    glm::quat orientation;
    double timeStamp;
};

struct KeyScale
{
    glm::vec3 scale;
    double timeStamp;
};

// Contains all position, rotation, and scale keyframes for a single bone
class BoneAnimation
{
public:
    std::vector<KeyPosition> positions;
    std::vector<KeyRotation> rotations;
    std::vector<KeyScale> scales;
    std::string boneName;
};

// Represents a single, self-contained animation clip (e.g., "walk", "run")
class AnimationClip
{
public:
    std::string name;
    double durationInTicks;
    double ticksPerSecond;
    std::map<std::string, BoneAnimation> boneAnimations;
};

// Contains static information about a single bone that influences the mesh
struct BoneInfo
{
    int id; // Unique ID for the bone, used as an index into the final transform array
    std::string name;
    glm::mat4 offsetMatrix; // Transforms vertices from model space to bone space
};

// Forward declare
class BoneAnimation;

// Represents a node in the skeleton's hierarchy. A node can be a bone or just a transform group.
struct NodeData
{
    glm::mat4 transformation = glm::mat4(1.0f); // The node's local transform relative to its parent
    std::string name;
    std::vector<NodeData> children;
    NodeData* parent = nullptr;
    BoneAnimation* currentBoneAnimation = nullptr; // Pre-linked for current animation (NO string lookup needed!)
    int boneIndex = -1; // Pre-linked bone index (-1 if not a bone)
    glm::mat4 offsetMatrix = glm::mat4(1.0f); // Pre-linked offset matrix (identity if not a bone)
};

// The top-level container for all parsed animation and skeleton data from a single file
class AnimationData
{
public:
    NodeData rootNode;
    std::map<std::string, BoneInfo> boneInfoMap;
    std::vector<AnimationClip> animationClips;
};



================================================================================
FILE: juce\Source\animation\AnimationRenderer.h
================================================================================


#pragma once

#include <juce_opengl/juce_opengl.h>
#include <glm/glm.hpp>
#include <vector>

class AnimationRenderer
{
public:
    AnimationRenderer();
    ~AnimationRenderer();

    // Call once to set up OpenGL resources
    void setup(int width, int height);

    // Call every frame to draw the skeleton
    void render(const std::vector<glm::mat4>& finalBoneMatrices, const std::vector<glm::vec3>& boneColors = {}, const std::vector<glm::vec3>& boneEdges = {});

    // Get the ID of the final texture to display in ImGui
    GLuint getTextureID() const { return fboTextureID; }
    
    // Set zoom level (affects orthographic projection)
    void setZoom(float zoom) { m_zoom = zoom; }
    
    // Set pan offset (affects orthographic projection)
    void setPan(const glm::vec2& pan) { m_pan = pan; }
    
    // Set the view rotation in radians
    void setViewRotation(const glm::vec3& rotation) { m_viewRotation = rotation; }
    
    // Calculate optimal zoom and pan to frame all bones in view
    void frameView(const std::vector<glm::mat4>& boneMatrices, float& outZoom, glm::vec2& outPan);

private:
    void createFramebuffer(int width, int height);
    void createShaders();
    // Helper for compiling and linking shader programs
    GLuint createShaderProgram(const char* vsSource, const char* gsSource, const char* fsSource);

    GLuint fboID = 0;
    GLuint fboTextureID = 0;
    GLuint rboDepthID = 0; // Renderbuffer for depth testing
    
    // Resources for drawing points
    GLuint pointShaderProgramID = 0;

    // NEW: Resources for drawing lines
    GLuint lineShaderProgramID = 0;
    GLuint lineVBO = 0, lineVAO = 0;

    int textureWidth = 0;
    int textureHeight = 0;
    
    bool m_isInitialized = false; // Track if setup has been called
    float m_zoom = 10.0f; // Zoom level for orthographic projection
    glm::vec2 m_pan = { 0.0f, 0.0f }; // Pan offset for orthographic projection
    glm::vec3 m_viewRotation = { 0.0f, 0.0f, 0.0f }; // View rotation angles in radians
};



================================================================================
FILE: juce\Source\animation\AnimationRenderer.cpp
================================================================================


#include "AnimationRenderer.h"
#include <juce_core/juce_core.h>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <limits>

// Use JUCE's OpenGL extension wrapper - this provides all the modern OpenGL functions
using namespace juce::gl;

// --- GLSL Shader Source Code ---

const char* vertexShaderSource = R"glsl(
    #version 330 core
    layout (location = 0) in vec3 aPos;

    out VS_OUT {
        vec3 color;
    } vs_out;

    uniform mat4 boneMatrices[100];
    uniform vec3 boneColors[100];

    void main()
    {
        // Pass the bone's world position and color directly to the geometry shader
        mat4 boneTransform = boneMatrices[gl_VertexID];
        gl_Position = boneTransform * vec4(0.0, 0.0, 0.0, 1.0);
        vs_out.color = boneColors[gl_VertexID];
    }
)glsl";

const char* geometryShaderSource = R"glsl(
    #version 330 core
    layout (points) in;
    layout (triangle_strip, max_vertices = 4) out;

    in VS_OUT {
        vec3 color;
    } gs_in[];

    out vec3 fColor;
    out vec2 quadCoord;

    uniform mat4 projection;
    uniform float pointRadius; // New uniform to control size in world units

    void main() {
        fColor = gs_in[0].color;
        
        // Get the world position from the vertex shader
        vec3 worldPos = gl_in[0].gl_Position.xyz;

        // Calculate billboard corner offsets that always face the camera
        // We get these from the inverse of the projection matrix
        vec3 camRight_worldspace = vec3(1.0, 0.0, 0.0);
        vec3 camUp_worldspace = vec3(0.0, 1.0, 0.0);
        
        float radius = pointRadius;

        // Bottom-left
        quadCoord = vec2(-1.0, -1.0);
        gl_Position = projection * vec4(worldPos - camRight_worldspace * radius - camUp_worldspace * radius, 1.0);
        EmitVertex();

        // Top-left
        quadCoord = vec2(-1.0, 1.0);
        gl_Position = projection * vec4(worldPos - camRight_worldspace * radius + camUp_worldspace * radius, 1.0);
        EmitVertex();

        // Bottom-right
        quadCoord = vec2(1.0, -1.0);
        gl_Position = projection * vec4(worldPos + camRight_worldspace * radius - camUp_worldspace * radius, 1.0);
        EmitVertex();

        // Top-right
        quadCoord = vec2(1.0, 1.0);
        gl_Position = projection * vec4(worldPos + camRight_worldspace * radius + camUp_worldspace * radius, 1.0);
        EmitVertex();

        EndPrimitive();
    }
)glsl";

const char* fragmentShaderSource = R"glsl(
    #version 330 core
    out vec4 FragColor;

    in vec3 fColor;
    in vec2 quadCoord;

    void main()
    {
        // Create a circular shape instead of a square
        if (dot(quadCoord, quadCoord) > 1.0) {
            discard;
        }
        FragColor = vec4(fColor, 1.0);
    }
)glsl";

const char* lineVertexShaderSource = R"glsl(
    #version 330 core
    layout (location = 0) in vec3 aPos;

    uniform mat4 projectionView;

    void main()
    {
        gl_Position = projectionView * vec4(aPos, 1.0);
    }
)glsl";

const char* lineFragmentShaderSource = R"glsl(
    #version 330 core
    out vec4 FragColor;

    void main()
    {
        // Light, semi-transparent grey for the edges
        FragColor = vec4(0.8, 0.8, 0.8, 0.6);
    }
)glsl";

AnimationRenderer::AnimationRenderer()
{
}

AnimationRenderer::~AnimationRenderer()
{
    if (pointShaderProgramID != 0) glDeleteProgram(pointShaderProgramID);
    if (lineShaderProgramID != 0) glDeleteProgram(lineShaderProgramID);

    if (fboTextureID != 0)
        glDeleteTextures(1, &fboTextureID);
    if (rboDepthID != 0)
        glDeleteRenderbuffers(1, &rboDepthID);
    if (fboID != 0)
        glDeleteFramebuffers(1, &fboID);

    if (lineVBO != 0) glDeleteBuffers(1, &lineVBO);
    if (lineVAO != 0) glDeleteVertexArrays(1, &lineVAO);
}

void AnimationRenderer::setup(int width, int height)
{
    if (m_isInitialized)
        return;

    createShaders();
    createFramebuffer(width, height);

    // NEW: Setup VAO/VBO for line drawing
    glGenVertexArrays(1, &lineVAO);
    glGenBuffers(1, &lineVBO);

    glBindVertexArray(lineVAO);
    glBindBuffer(GL_ARRAY_BUFFER, lineVBO);
    // The data will be uploaded each frame, so we just set up the attribute pointer here
    glBufferData(GL_ARRAY_BUFFER, 0, nullptr, GL_DYNAMIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    m_isInitialized = true;
}

void AnimationRenderer::render(const std::vector<glm::mat4>& finalBoneMatrices, const std::vector<glm::vec3>& boneColors, const std::vector<glm::vec3>& boneEdges)
{
    if (finalBoneMatrices.empty() || pointShaderProgramID == 0)
        return;

    // --- SAVE IMGUI'S OPENGL STATE ---
    GLint last_program;
    glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);
    GLint last_texture;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    GLint last_array_buffer;
    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    GLint last_viewport[4];
    glGetIntegerv(GL_VIEWPORT, last_viewport);
    GLint last_scissor_box[4];
    glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);

    // --- CONFIGURE OPENGL FOR OUR FBO ---
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);
    glViewport(0, 0, textureWidth, textureHeight);
    glDisable(GL_SCISSOR_TEST); // We want to clear and draw to the whole FBO
    glEnable(GL_BLEND); // Enable blending for semi-transparent lines
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Clear the framebuffer
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // --- CREATE PROJECTION-VIEW MATRIX ---
    // 1. Set up orthographic projection matrix (zoom and pan controlled by m_zoom and m_pan)
    glm::mat4 projection = glm::ortho(-m_zoom + m_pan.x, m_zoom + m_pan.x, -m_zoom + m_pan.y, m_zoom + m_pan.y, -10.0f, 10.0f);

    // 2. Create the view matrix from our rotation angles
    glm::mat4 view = glm::mat4(1.0f);
    view = glm::rotate(view, m_viewRotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
    view = glm::rotate(view, m_viewRotation.y, glm::vec3(0.0f, 1.0f, 0.0f));
    view = glm::rotate(view, m_viewRotation.z, glm::vec3(0.0f, 0.0f, 1.0f));

    // 3. Combine them into a final projection-view matrix
    glm::mat4 projectionView = projection * view;

    // --- PASS 1: DRAW LINES (Edges) ---
    if (!boneEdges.empty())
    {
        glUseProgram(lineShaderProgramID);
        glUniformMatrix4fv(glGetUniformLocation(lineShaderProgramID, "projectionView"), 1, GL_FALSE, &projectionView[0][0]);

        glBindVertexArray(lineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, lineVBO);
        // Upload vertex data for the lines for this frame
        glBufferData(GL_ARRAY_BUFFER, boneEdges.size() * sizeof(glm::vec3), boneEdges.data(), GL_DYNAMIC_DRAW);
        
        glDrawArrays(GL_LINES, 0, static_cast<GLsizei>(boneEdges.size()));
        
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
    }
    
    // --- PASS 2: DRAW POINTS (Bones) ---
    glEnable(GL_PROGRAM_POINT_SIZE); // Required for gl_PointSize in shader to work
    glUseProgram(pointShaderProgramID);
    
    // 4. Send matrices and radius to the shader uniforms
    glUniformMatrix4fv(glGetUniformLocation(pointShaderProgramID, "projection"), 1, GL_FALSE, &projectionView[0][0]);
    glUniform1f(glGetUniformLocation(pointShaderProgramID, "pointRadius"), 0.02f);

    // Send the bone matrices to the shader
    glUniformMatrix4fv(glGetUniformLocation(pointShaderProgramID, "boneMatrices"), 
                      static_cast<GLsizei>(finalBoneMatrices.size()), 
                      GL_FALSE, 
                      &finalBoneMatrices[0][0][0]);
    
    // Send the bone colors to the shader (default to white if no colors provided)
    if (!boneColors.empty() && boneColors.size() >= finalBoneMatrices.size())
    {
        glUniform3fv(glGetUniformLocation(pointShaderProgramID, "boneColors"),
                     static_cast<GLsizei>(finalBoneMatrices.size()),
                     &boneColors[0][0]);
    }
    else
    {
        // Default all bones to white if no color data provided
        std::vector<glm::vec3> defaultColors(finalBoneMatrices.size(), glm::vec3(1.0f, 1.0f, 1.0f));
        glUniform3fv(glGetUniformLocation(pointShaderProgramID, "boneColors"),
                     static_cast<GLsizei>(defaultColors.size()),
                     &defaultColors[0][0]);
    }

    glDrawArrays(GL_POINTS, 0, static_cast<GLsizei>(finalBoneMatrices.size()));
    glDisable(GL_PROGRAM_POINT_SIZE);

    // --- RESTORE IMGUI'S OPENGL STATE ---
    glBindFramebuffer(GL_FRAMEBUFFER, 0); // Unbind FBO first
    glDisable(GL_BLEND);
    glUseProgram(last_program);
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
    if (last_enable_scissor_test) {
        glEnable(GL_SCISSOR_TEST);
    }
}

void AnimationRenderer::createFramebuffer(int width, int height)
{
    textureWidth = width;
    textureHeight = height;

    glGenFramebuffers(1, &fboID);
    glBindFramebuffer(GL_FRAMEBUFFER, fboID);

    // Create Color Texture Attachment
    glGenTextures(1, &fboTextureID);
    glBindTexture(GL_TEXTURE_2D, fboTextureID);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fboTextureID, 0);

    // Create Depth Renderbuffer Attachment
    glGenRenderbuffers(1, &rboDepthID);
    glBindRenderbuffer(GL_RENDERBUFFER, rboDepthID);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, width, height);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepthID);

    // Check if framebuffer is complete
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        DBG("ERROR::FRAMEBUFFER:: Framebuffer is not complete!");

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

// Shader helper function to avoid duplicating compilation/linking code
GLuint AnimationRenderer::createShaderProgram(const char* vsSource, const char* gsSource, const char* fsSource)
{
    GLint success;
    GLchar infoLog[512];

    // Vertex Shader
    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vs, 1, &vsSource, NULL);
    glCompileShader(vs);
    glGetShaderiv(vs, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(vs, 512, NULL, infoLog);
        DBG("ERROR::SHADER::VERTEX::COMPILATION_FAILED: " + juce::String(infoLog));
    }

    // Geometry Shader (optional)
    GLuint gs = 0;
    if (gsSource != nullptr) {
        gs = glCreateShader(GL_GEOMETRY_SHADER);
        glShaderSource(gs, 1, &gsSource, NULL);
        glCompileShader(gs);
        glGetShaderiv(gs, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(gs, 512, NULL, infoLog);
            DBG("ERROR::SHADER::GEOMETRY::COMPILATION_FAILED: " + juce::String(infoLog));
        }
    }

    // Fragment Shader
    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fs, 1, &fsSource, NULL);
    glCompileShader(fs);
    glGetShaderiv(fs, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(fs, 512, NULL, infoLog);
        DBG("ERROR::SHADER::FRAGMENT::COMPILATION_FAILED: " + juce::String(infoLog));
    }

    // Shader Program
    GLuint programID = glCreateProgram();
    glAttachShader(programID, vs);
    if (gs != 0) glAttachShader(programID, gs);
    glAttachShader(programID, fs);
    glLinkProgram(programID);
    glGetProgramiv(programID, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(programID, 512, NULL, infoLog);
        DBG("ERROR::SHADER::PROGRAM::LINKING_FAILED: " + juce::String(infoLog));
    }

    // Delete shaders as they're now linked into our program
    glDeleteShader(vs);
    if (gs != 0) glDeleteShader(gs);
    glDeleteShader(fs);
    
    return programID;
}

void AnimationRenderer::createShaders()
{
    // Create the shader program for drawing points
    pointShaderProgramID = createShaderProgram(vertexShaderSource, geometryShaderSource, fragmentShaderSource);
    
    // Create the shader program for drawing lines
    lineShaderProgramID = createShaderProgram(lineVertexShaderSource, nullptr, lineFragmentShaderSource);
}

void AnimationRenderer::frameView(const std::vector<glm::mat4>& boneMatrices, float& outZoom, glm::vec2& outPan)
{
    if (boneMatrices.empty())
        return;

    // Find the bounding box of all bone positions
    glm::vec2 minPoint(std::numeric_limits<float>::max());
    glm::vec2 maxPoint(std::numeric_limits<float>::lowest());

    for (const auto& matrix : boneMatrices)
    {
        glm::vec3 position = matrix[3]; // Position is in the 4th column

        // === START FIX: Ignore bones at or very near the origin ===
        // This prevents non-skeleton helper nodes from ruining the auto-frame.
        if (glm::length(position) < 0.001f)
        {
            continue; // Skip this bone
        }
        // === END FIX ===

        minPoint.x = std::min(minPoint.x, position.x);
        minPoint.y = std::min(minPoint.y, position.y);
        maxPoint.x = std::max(maxPoint.x, position.x);
        maxPoint.y = std::max(maxPoint.y, position.y);
    }

    // Calculate the center of the bounding box
    outPan = (minPoint + maxPoint) * 0.5f;

    // Calculate the size needed to contain the bounding box
    glm::vec2 size = maxPoint - minPoint;
    float requiredZoom = glm::max(size.x, size.y) * 0.5f;

    // Set the zoom with a little padding
    outZoom = requiredZoom * 1.1f;
}



================================================================================
FILE: juce\Source\animation\Animator.h
================================================================================


#pragma once

#include <vector>
#include <string>
#include "AnimationData.h"
#include <glm/glm.hpp>
#include <juce_core/juce_core.h> // For JUCE_ASSERT

class Animator
{
public:
    Animator(AnimationData* animationData);

    void Update(float deltaTime);
    void PlayAnimation(const std::string& animationName);
    void SetAnimationSpeed(float speed) { m_AnimationSpeed = speed; }

    const std::vector<glm::mat4>& GetFinalBoneMatrices() const { return m_FinalBoneMatrices; }
    const std::vector<glm::mat4>& GetBoneWorldTransforms() const { return m_BoneWorldTransforms; }
    const AnimationData* GetAnimationData() const { return m_AnimationData; }
    float GetCurrentTime() const { return m_CurrentTime; }
    const AnimationClip* GetCurrentAnimation() const { return m_CurrentAnimation; }

private:
    glm::vec3 InterpolatePosition(float animationTime, const std::vector<KeyPosition>& keyframes, const glm::vec3& defaultPos);
    glm::quat InterpolateRotation(float animationTime, const std::vector<KeyRotation>& keyframes, const glm::quat& defaultRot);
    glm::vec3 InterpolateScale(float animationTime, const std::vector<KeyScale>& keyframes, const glm::vec3& defaultScale);
    void CalculateBoneTransform(NodeData* node, const glm::mat4& parentTransform);
    void LinkBoneAnimationsToNodes(NodeData* node); // Pre-link animations to nodes (called on main thread)

    std::vector<glm::mat4> m_FinalBoneMatrices; // For skinning (includes offset matrix)
    std::vector<glm::mat4> m_BoneWorldTransforms; // For visualization (world positions only)
    AnimationData* m_AnimationData;
    AnimationClip* m_CurrentAnimation;
    float m_CurrentTime;
    float m_AnimationSpeed;
};


================================================================================
FILE: juce\Source\animation\Animator.cpp
================================================================================


#define GLM_ENABLE_EXPERIMENTAL
#include "Animator.h"
#include <glm/gtx/matrix_decompose.hpp>
#include <glm/gtx/quaternion.hpp>

Animator::Animator(AnimationData* animationData) {
    m_CurrentTime = 0.0;
    m_AnimationData = animationData;
    m_CurrentAnimation = nullptr;
    m_AnimationSpeed = 1.0f;
    if(m_AnimationData && !m_AnimationData->boneInfoMap.empty()) {
        m_FinalBoneMatrices.resize(m_AnimationData->boneInfoMap.size(), glm::mat4(1.0f));
        m_BoneWorldTransforms.resize(m_AnimationData->boneInfoMap.size(), glm::mat4(1.0f));
    }
}

void Animator::PlayAnimation(const std::string& animationName) {
    if(!m_AnimationData) return;
    for (auto& clip : m_AnimationData->animationClips) {
        if (clip.name == animationName) {
            m_CurrentAnimation = &clip;
            m_CurrentTime = 0.0f;
            
            // Pre-link bone animations to nodes (MAIN THREAD ONLY - string operations here!)
            // This eliminates ALL string lookups in the audio thread
            LinkBoneAnimationsToNodes(&m_AnimationData->rootNode);
            return;
        }
    }
}

// Recursively pre-link bone animations to node tree (called on main thread)
void Animator::LinkBoneAnimationsToNodes(NodeData* node) {
    if (!node || !m_CurrentAnimation) return;
    
    // Try to find a bone animation for this node
    if (m_CurrentAnimation->boneAnimations.count(node->name)) {
        node->currentBoneAnimation = &m_CurrentAnimation->boneAnimations[node->name];
    } else {
        node->currentBoneAnimation = nullptr;
    }
    
    // Recurse to children
    for (auto& child : node->children) {
        LinkBoneAnimationsToNodes(&child);
    }
}

void Animator::Update(float deltaTime) {
    // NO LOGGING ALLOWED HERE - called from audio thread!
    if (!m_AnimationData || !m_CurrentAnimation || m_CurrentAnimation->durationInTicks <= 0.0f) 
    {
        return;
    }
    
    m_CurrentTime += m_CurrentAnimation->ticksPerSecond * deltaTime * m_AnimationSpeed;
    m_CurrentTime = fmod(m_CurrentTime, m_CurrentAnimation->durationInTicks);
    
    CalculateBoneTransform(&m_AnimationData->rootNode, glm::mat4(1.0f));
}

void Animator::CalculateBoneTransform(NodeData* node, const glm::mat4& parentTransform) {
    if(!node) return;

    BoneAnimation* boneAnim = node->currentBoneAnimation;
    glm::mat4 nodeTransform; // This will hold the final local transform for this node.

    // === START: THE DEFINITIVE FIX ===
    // If there is an active animation clip affecting this specific bone...
    if (boneAnim)
    {
        // ...then we decompose the bone's base transform, apply the animation keyframes,
        // and recompose a new transform matrix for this frame.
        glm::vec3 scale, translation;
        glm::quat rotation;
        glm::vec3 skew;
        glm::vec4 perspective;
        glm::decompose(node->transformation, scale, rotation, translation, skew, perspective);

        // These calls are safe even if a track (e.g., scale) is missing from the animation
        translation = InterpolatePosition(m_CurrentTime, boneAnim->positions, translation);
        rotation    = InterpolateRotation(m_CurrentTime, boneAnim->rotations, rotation);
        scale       = InterpolateScale(m_CurrentTime, boneAnim->scales, scale);
        
        nodeTransform = glm::translate(glm::mat4(1.0f), translation) * glm::toMat4(rotation) * glm::scale(glm::mat4(1.0f), scale);
    }
    else
    {
        // ...otherwise, if this bone is NOT animated, we use its original, unmodified
        // transformation matrix. This prevents the decompose/recompose cycle that was
        // corrupting the transforms by introducing accumulating floating-point errors.
        nodeTransform = node->transformation;
    }
    // === END: THE DEFINITIVE FIX ===

    glm::mat4 globalTransform = parentTransform * nodeTransform;

    // Use pre-linked bone index and offset matrix (NO string operations!)
    if (node->boneIndex >= 0 && node->boneIndex < m_FinalBoneMatrices.size())
    {
        // Store world transform for visualization (without offset matrix)
        m_BoneWorldTransforms[node->boneIndex] = globalTransform;
        // Apply the offset matrix to get the final skinning transform
        m_FinalBoneMatrices[node->boneIndex] = globalTransform * node->offsetMatrix;
    }

    for (auto& child : node->children) {
        CalculateBoneTransform(&child, globalTransform);
    }
}

// --- Interpolation Helpers ---
glm::vec3 Animator::InterpolatePosition(float animationTime, const std::vector<KeyPosition>& keyframes, const glm::vec3& defaultPos) {
    if (keyframes.empty()) return defaultPos;
    if (keyframes.size() == 1) return keyframes[0].position;
    
    int p0Index = 0;
    if (animationTime >= keyframes.back().timeStamp) return keyframes.back().position;
    for (size_t i = 0; i < keyframes.size() - 1; ++i) {
        if (animationTime < keyframes[i + 1].timeStamp) { p0Index = i; break; }
    }
    int p1Index = p0Index + 1;
    if (p1Index >= keyframes.size()) return keyframes[p0Index].position;

    float p1Time = keyframes[p1Index].timeStamp;
    float p0Time = keyframes[p0Index].timeStamp;
    float scaleFactor = (p1Time - p0Time > 0.0f) ? (animationTime - p0Time) / (p1Time - p0Time) : 0.0f;
    return glm::mix(keyframes[p0Index].position, keyframes[p1Index].position, scaleFactor);
}

glm::quat Animator::InterpolateRotation(float animationTime, const std::vector<KeyRotation>& keyframes, const glm::quat& defaultRot) {
    if (keyframes.empty()) return defaultRot;
    if (keyframes.size() == 1) return glm::normalize(keyframes[0].orientation);

    int p0Index = 0;
    if (animationTime >= keyframes.back().timeStamp) return glm::normalize(keyframes.back().orientation);
    for (size_t i = 0; i < keyframes.size() - 1; ++i) {
        if (animationTime < keyframes[i + 1].timeStamp) { p0Index = i; break; }
    }
    int p1Index = p0Index + 1;
    if (p1Index >= keyframes.size()) return glm::normalize(keyframes[p0Index].orientation);

    float p1Time = keyframes[p1Index].timeStamp;
    float p0Time = keyframes[p0Index].timeStamp;
    float scaleFactor = (p1Time - p0Time > 0.0f) ? (animationTime - p0Time) / (p1Time - p0Time) : 0.0f;
    return glm::normalize(glm::slerp(keyframes[p0Index].orientation, keyframes[p1Index].orientation, scaleFactor));
}

glm::vec3 Animator::InterpolateScale(float animationTime, const std::vector<KeyScale>& keyframes, const glm::vec3& defaultScale) {
    if (keyframes.empty()) return defaultScale;
    if (keyframes.size() == 1) return keyframes[0].scale;

    int p0Index = 0;
    if (animationTime >= keyframes.back().timeStamp) return keyframes.back().scale;
    for (size_t i = 0; i < keyframes.size() - 1; ++i) {
        if (animationTime < keyframes[i + 1].timeStamp) { p0Index = i; break; }
    }
    int p1Index = p0Index + 1;
    if (p1Index >= keyframes.size()) return keyframes[p0Index].scale;

    float p1Time = keyframes[p1Index].timeStamp;
    float p0Time = keyframes[p0Index].timeStamp;
    float scaleFactor = (p1Time - p0Time > 0.0f) ? (animationTime - p0Time) / (p1Time - p0Time) : 0.0f;
    return glm::mix(keyframes[p0Index].scale, keyframes[p1Index].scale, scaleFactor);
}


================================================================================
FILE: juce\Source\preset_creator\ImGuiNodeEditorComponent.h
================================================================================


#pragma once

#include <juce_gui_extra/juce_gui_extra.h>
#include <juce_opengl/juce_opengl.h>
#include <juce_audio_devices/juce_audio_devices.h>
#include <unordered_map>
#include <tuple>
#include <deque>
#include <imgui.h>
#include "../audio/modules/ModuleProcessor.h"
#include "../audio/graph/ModularSynthProcessor.h"
#include "PresetManager.h"
#include "SampleManager.h"
#include "MidiManager.h"
#include "ControllerPresetManager.h"

// Forward declarations from Dear ImGui / imnodes
struct ImGuiContext; struct ImGuiIO; struct ImNodesContext;
class MIDIPlayerModuleProcessor;
class MultiSequencerModuleProcessor;
class StrokeSequencerModuleProcessor;
class AnimationModuleProcessor;

// === NODE SIZING SYSTEM ===
// Standardized node width categories for consistent visual layout
enum class NodeWidth 
{ 
    Small,      // 240px - Basic modules (VCO, VCA, simple utilities)
    Medium,     // 360px - Effects with visualizations (Reverb, Chorus, Phaser)
    Big,        // 480px - Complex modules (PolyVCO, advanced effects)
    ExtraWide,  // 840px - Timeline/grid modules (MultiSequencer, MIDI Player)
    Exception   // Custom size - Module defines its own dimensions via getCustomNodeSize()
};

// Helper function to convert NodeWidth category to pixel width
inline float getWidthForCategory(NodeWidth width)
{
    switch (width)
    {
        case NodeWidth::Medium:    return 360.0f;
        case NodeWidth::Big:       return 480.0f;
        case NodeWidth::ExtraWide: return 840.0f;
        case NodeWidth::Exception: return 0.0f;  // Signals that module provides custom size
        case NodeWidth::Small:
        default:                   return 360.0f;
    }
}

// Pin information struct for node editor
struct PinInfo {
    uint32_t id;      // The unique ID of the pin
    juce::String type; // The parsed type ("Pitch", "Gate", "Trig", etc.)
};

class ImGuiNodeEditorComponent : public juce::Component,
                                 private juce::OpenGLRenderer
{
public:
    ImGuiNodeEditorComponent(juce::AudioDeviceManager& deviceManager);
    ~ImGuiNodeEditorComponent() override;

    void paint (juce::Graphics&) override;
    void resized() override;
    // Input is handled by imgui_juce backend; no JUCE overrides needed
    
    void setMidiActivityFrames(int frames) { midiActivityFrames = frames; }
    
    void setModel (ModularSynthProcessor* model)
    { 
        synth = model; 
        undoStack.clear(); 
        redoStack.clear(); 
    }
    
    // ADD: Callback for showing audio settings dialog
    std::function<void()> onShowAudioSettings;
    
    // UI state roundtrip
    juce::ValueTree getUiValueTree() const;
    // Thread-safe: queues UI state to be applied on next render frame
    void applyUiValueTree (const juce::ValueTree& uiState);
    void applyUiValueTreeNow (const juce::ValueTree& uiState);

    // --- Helper structs ---
    struct Range { float min; float max; };
    
    // --- Pin ID System Struct (declare before any usage) ---
    struct PinID
    {
        juce::uint32 logicalId = 0;
        int channel = 0;
        bool isInput = false;
        bool isMod = false;
        juce::String paramId; // used for mod pins
    };

    // OpenGLRenderer
    void newOpenGLContextCreated() override;
    void renderOpenGL() override;
    void openGLContextClosing() override;

    // Helper functions for pin type checking and UI
    PinDataType getPinDataTypeForPin(const PinID& pin);
    unsigned int getImU32ForType(PinDataType type);
    const char* pinDataTypeToString(PinDataType type);
    
    void handleRandomizePatch();
    void handleRandomizeConnections();
    void handleConnectSelectedToTrackMixer();
    void handleBeautifyLayout();
    void handleMidiPlayerAutoConnect(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectVCO(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleMidiPlayerAutoConnectHybrid(MIDIPlayerModuleProcessor* midiPlayer, juce::uint32 midiPlayerLid);
    void handleInsertNodeOnSelectedLinks(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType);
    void insertNodeBetween(const juce::String& nodeType, const PinID& srcPin, const PinID& dstPin);
    void drawInsertNodeOnLinkPopup();

    // New intelligent auto-connection system
    void parsePinName(const juce::String& fullName, juce::String& outType, int& outIndex);
    
    // Helper functions to get pins from modules
    std::vector<AudioPin> getOutputPins(const juce::String& moduleType);
    std::vector<AudioPin> getInputPins(const juce::String& moduleType);
    AudioPin* findInputPin(const juce::String& moduleType, const juce::String& pinName);
    AudioPin* findOutputPin(const juce::String& moduleType, const juce::String& pinName);
    std::vector<juce::uint32> findNodesOfType(const juce::String& moduleType);
    
    // New dynamic pin-fetching helper
    std::vector<PinInfo> getDynamicOutputPins(ModuleProcessor* module);
    
    template<typename TargetProcessorType>
    void connectToMonophonicTargets(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping, const std::vector<juce::uint32>& targetLids);
    template<typename TargetProcessorType>
    void connectToPolyphonicTarget(ModuleProcessor* sourceNode, const std::map<juce::String, juce::String>& pinNameMapping);
    void handleAutoConnectionRequests();
    
    // MIDI Player Quick Connect handler
    void handleMIDIPlayerConnectionRequest(juce::uint32 midiPlayerLid, MIDIPlayerModuleProcessor* midiPlayer, int requestType);
    
    // StrokeSequencer specific handler
    void handleStrokeSeqBuildDrumKit(StrokeSequencerModuleProcessor* strokeSeq, juce::uint32 strokeSeqLid);
    
    // AnimationModule specific handlers
    void handleAnimationBuildTriggersAudio(AnimationModuleProcessor* animModule, juce::uint32 animModuleLid);
    
    // MultiSequencer specific handlers
    void handleMultiSequencerAutoConnectSamplers(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);
    void handleMultiSequencerAutoConnectVCO(MultiSequencerModuleProcessor* sequencer, juce::uint32 sequencerLid);

    void renderImGui();
    void handleDeletion();
    void bypassDeleteSelectedNodes();
    void bypassDeleteNode(juce::uint32 logicalId);
    void startSaveDialog();
    void startLoadDialog();
    juce::String getTypeForLogical (juce::uint32 logicalId) const;

    // --- Collision-Proof Pin ID System ---
    // 32-bit ID with guaranteed separation from node IDs:
    // Bit 31: PIN_ID_FLAG (always 1 for pins, 0 for nodes)
    // Bit 30: IS_INPUT_FLAG (1 for input, 0 for output)
    // Bits 16-29: Channel Index (14 bits, up to 16384 channels)
    // Bits 0-15: Node Logical ID (16 bits, up to 65535 nodes)
    // This ensures pin IDs can never collide with node IDs
    
    static int encodePinId(const PinID& pinId)
    {
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);
        
        juce::uint32 encoded = PIN_ID_FLAG |
                               (pinId.isInput ? IS_INPUT_FLAG : 0) |
                               (((juce::uint32)pinId.channel & 0x3FFF) << 16) |
                               (pinId.logicalId & 0xFFFF);
        
        return (int)encoded;
    }

    static PinID decodePinId(int id)
    {
        PinID pinId;
        const juce::uint32 uid = (juce::uint32)id;
        const juce::uint32 PIN_ID_FLAG = (1u << 31);
        const juce::uint32 IS_INPUT_FLAG = (1u << 30);

        // Only decode if this is actually a pin ID (has the flag set)
        if ((uid & PIN_ID_FLAG) == 0)
        {
            // This is not a pin ID! Return invalid pin
            juce::Logger::writeToLog("[ERROR] decodePinId called with non-pin ID: " + juce::String((int)id));
            pinId.logicalId = 0;
            pinId.channel = 0;
            pinId.isInput = false;
            pinId.isMod = false;
            return pinId;
        }

        pinId.logicalId = uid & 0xFFFF;
        pinId.channel   = (int)((uid >> 16) & 0x3FFF); // 14-bit mask
        pinId.isInput   = (uid & IS_INPUT_FLAG) != 0;
        pinId.isMod     = false; // handled contextually, not in the bitmask
        return pinId;
    }


    juce::OpenGLContext glContext;
    ImGuiContext* imguiContext { nullptr };
    ImGuiIO* imguiIO { nullptr };
    ImNodesContext* editorContext { nullptr };
    double lastTime { 0.0 };

    juce::AudioDeviceManager& deviceManager;
    ModularSynthProcessor* synth { nullptr };
    juce::ValueTree uiPending; // applied at next render before drawing nodes
    std::atomic<bool> graphNeedsRebuild { false };
    int midiActivityFrames = 0; // For MIDI activity indicator
    
    // Preset and sample management
    PresetManager m_presetManager;
    SampleManager m_sampleManager;
    juce::String m_presetSearchTerm;
    juce::String m_sampleSearchTerm;
    juce::File m_presetScanPath;
    juce::File m_sampleScanPath;
    std::unique_ptr<juce::FileChooser> presetPathChooser;
    std::unique_ptr<juce::FileChooser> samplePathChooser;
    
    // MIDI file management
    MidiManager m_midiManager;
    juce::File m_midiScanPath;
    juce::String m_midiSearchTerm;
    std::unique_ptr<juce::FileChooser> midiPathChooser;
    
    // Meta module editing state
    juce::uint32 metaModuleToEditLid = 0;
    
    // Cache of last-known valid node positions (used when graphNeedsRebuild prevents rendering)
    std::unordered_map<int, ImVec2> lastKnownNodePositions;

    // Selection state
    int selectedLogicalId { 0 };

    std::unique_ptr<juce::FileChooser> saveChooser, loadChooser;

    // Map of linkId -> (srcAttr, dstAttr) populated each frame
    std::unordered_map<int, std::pair<int,int>> linkIdToAttrs;
    
    // Link ID registry (cleared each frame for stateless rendering)
    struct LinkKey { int srcAttr; int dstAttr; };
    struct LinkKeyHash { size_t operator()(const LinkKey& k) const noexcept { return ((size_t)k.srcAttr << 32) ^ (size_t)k.dstAttr; } };
    struct LinkKeyEq { bool operator()(const LinkKey& a, const LinkKey& b) const noexcept { return a.srcAttr==b.srcAttr && a.dstAttr==b.dstAttr; } };
    std::unordered_map<LinkKey, int, LinkKeyHash, LinkKeyEq> linkToId;
    int nextLinkId { 1000 };
    int getLinkId(int srcAttr, int dstAttr)
    {
        LinkKey k{ srcAttr, dstAttr };
        auto it = linkToId.find(k);
        if (it != linkToId.end()) return it->second;
        const int id = nextLinkId++;
        linkToId.emplace(k, id);
        return id;
    }

    // Cable inspector highlight state (updated once per frame after EndNodeEditor)
    juce::uint32 hoveredLinkSrcId { 0 };
    juce::uint32 hoveredLinkDstId { 0 };
    static constexpr juce::uint32 kOutputHighlightId = 0xFFFFFFFFu; // sentinel for main output node highlight
    int lastHoveredLinkId { -1 }; // cache inside-editor hovered link id for post-editor use

    // Positions to apply for specific node IDs on the next render (grid space)
    std::unordered_map<int, ImVec2> pendingNodePositions;
    // Screen-space positions queued for just-created nodes (converted after draw)
    std::unordered_map<int, ImVec2> pendingNodeScreenPositions;
    // Sizes to apply for specific node IDs on the next render (for Comment nodes)
    std::unordered_map<int, ImVec2> pendingNodeSizes;

    // Cable inspector rolling stats (last N seconds) for quick visual validation
    struct ChannelHistory { std::deque<std::pair<double,float>> samples; };
    std::map<std::pair<juce::uint32,int>, ChannelHistory> inspectorHistory; // key: (logicalId, channel)
    float inspectorWindowSeconds { 5.0f };

    // --- NEW STATE FOR CABLE SPLITTING ---
    // Stores the attribute ID of the pin we are splitting from.
    // -1 means no split operation is active.
    int splittingFromAttrId = -1;

    // A map to cache the screen position of every pin attribute ID each frame.
    // This is a necessary workaround as ImNodes doesn't provide a public API
    // to get a pin's position by its ID.
    std::unordered_map<int, ImVec2> attrPositions;


    // UI state / hover
    int lastHoveredNodeId { -1 };
    bool isDraggingNode { false };
    bool snapshotAfterEditor { false }; // arm when action requires node to exist (add/duplicate)
    // zoom/pan disabled

    // --- Undo/Redo (module ops) ---
    struct Snapshot
    {
        juce::MemoryBlock synthState;
        juce::ValueTree   uiState;
    };
    std::vector<Snapshot> undoStack;
    std::vector<Snapshot> redoStack;
    void pushSnapshot();
    void restoreSnapshot (const Snapshot& s);
    
    // SampleLoader texture management (use JUCE OpenGLTexture to avoid raw GL includes)
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> sampleLoaderTextureIds;
    std::unordered_map<int, std::unique_ptr<juce::OpenGLTexture>> visionModuleTextures;

    // Preset status tracking
    juce::String currentPresetFile;
    bool isPatchDirty { false };

    // Help window
    bool showShortcutsWindow { false };

    // Shortcut debounce
    bool mixerShortcutCooldown { false };
    bool insertNodeShortcutCooldown { false };
    bool showInsertNodePopup { false };
    bool showDebugMenu { false };
    bool showMidiDeviceManager { false };
    int pendingInsertLinkId { -1 };
    
    // Probe tool state
    bool isProbeModeActive { false };
    bool showProbeScope { true };
    
    // Insert node on link state
    struct LinkInfo
    {
        int linkId = -1;
        bool isMod = false;
        // For Audio links:
        PinID srcPin;
        PinID dstPin;
        // For Mod links:
        juce::uint32 srcLogicalId;
        int srcChan;
        juce::uint32 dstLogicalId;
        juce::String paramId;
    };
    LinkInfo linkToInsertOn;
    
    // Mute/Bypass state management (non-destructive)
    struct MutedNodeState {
        std::vector<ModularSynthProcessor::ConnectionInfo> incomingConnections;
        std::vector<ModularSynthProcessor::ConnectionInfo> outgoingConnections;
    };
    std::map<juce::uint32, MutedNodeState> mutedNodeStates;
    
    void muteNodeSilent(juce::uint32 logicalId);  // Store mute state without modifying graph (for loading presets)
    void muteNode(juce::uint32 logicalId);
    void unmuteNode(juce::uint32 logicalId);
    void handleMuteToggle();

    // Copy/Paste settings clipboard
    juce::ValueTree nodeSettingsClipboard;
    juce::String clipboardModuleType;

    // Helper functions
    void insertNodeOnLink(const juce::String& nodeType, const LinkInfo& linkInfo, const ImVec2& position);
    void insertNodeOnLinkStereo(const juce::String& nodeType, const LinkInfo& linkLeft, const LinkInfo& linkRight, const ImVec2& position);
    juce::File findPresetsDirectory();

    // --- NEW: Handler for node chaining shortcut ---
    void handleNodeChaining();

    // --- NEW: Handlers for color-coded chaining ---
    void handleColorCodedChaining(PinDataType targetType);
    std::vector<AudioPin> getPinsOfType(juce::uint32 logicalId, bool isInput, PinDataType targetType);
    
    // --- Recorder Output Shortcut ---
    void handleRecordOutput();
    
    // --- Unified Preset Loading ---
    void loadPresetFromFile(const juce::File& file);
    void mergePresetFromFile(const juce::File& file, ImVec2 dropPosition);
    
    // --- Meta Module (Sub-Patching) Support ---
    void handleCollapseToMetaModule();
    
    // --- Module Category Color Coding ---
    enum class ModuleCategory { Source, Effect, Modulator, Utility, Seq, MIDI, Analysis, TTS_Voice, Special_Exp, OpenCV, Sys, Comment, Plugin };
    ModuleCategory getModuleCategory(const juce::String& moduleType);
    unsigned int getImU32ForCategory(ModuleCategory category, bool hovered = false);
    
    // --- Quick Add Menu ---
    std::map<juce::String, std::pair<const char*, const char*>> getModuleRegistry();
    std::vector<std::pair<juce::String, const char*>> getModuleDescriptions();
    
    // --- VST Plugin Support ---
    void addPluginModules();
};


================================================================================
FILE: juce\Source\preset_creator\PinDatabase.h
================================================================================


#pragma once

#include "../audio/modules/ModuleProcessor.h"
#include <map>

// Getter functions that return references to static local variables
// This ensures safe initialization after JUCE is ready (construct on first use idiom)

// Returns the pin database for all module types
inline std::map<juce::String, ModulePinInfo>& getModulePinDatabase()
{
    // By declaring the map as static inside a function, we ensure it's
    // initialized safely on its first use, after JUCE is ready.
    static std::map<juce::String, ModulePinInfo> modulePinDatabase;
    return modulePinDatabase;
}

// Returns the module descriptions database
inline std::map<juce::String, const char*>& getModuleDescriptions()
{
    static std::map<juce::String, const char*> moduleDescriptions;
    return moduleDescriptions;
}

// Function to populate both databases - must be called before first use
void populatePinDatabase();



================================================================================
FILE: juce\Source\preset_creator\PinDatabase.cpp
================================================================================


#include "PinDatabase.h"
#include "ImGuiNodeEditorComponent.h" // For NodeWidth enum

// Module Descriptions - populated on first use
void populateModuleDescriptions()
{
    auto& descriptions = getModuleDescriptions();
    if (!descriptions.empty()) return; // Only run once
    
    // Sources
    descriptions["audio_input"] = "Brings hardware audio into the patch.";
    descriptions["VCO"] = "A standard Voltage-Controlled Oscillator.";
    descriptions["polyvco"] = "A multi-voice oscillator bank for polyphony.";
    descriptions["Noise"] = "Generates white, pink, or brown noise.";
    descriptions["Sequencer"] = "A classic 16-step CV and Gate sequencer.";
    descriptions["multi sequencer"] = "Advanced sequencer with parallel per-step outputs.";
    descriptions["midi player"] = "Plays MIDI files and outputs CV/Gate for each track.";
    descriptions["midi cv"] = "Converts MIDI Note/CC messages to CV signals. (Monophonic)";
    descriptions["midi control center"] = "A powerful MIDI learn interface to map any MIDI CC to CV/Gate outputs.";
    descriptions["midi faders"] = "1-16 MIDI-learnable faders with customizable output ranges.";
    descriptions["midi knobs"] = "1-16 MIDI-learnable knobs with customizable output ranges.";
    descriptions["midi buttons"] = "1-32 MIDI-learnable buttons with Gate/Toggle/Trigger modes.";
    descriptions["midi jog wheel"] = "A single MIDI-learnable jog wheel control for expressive modulation.";
    descriptions["Value"] = "Outputs a constant, adjustable numerical value.";
    descriptions["sample_loader"] = "Loads and plays audio samples with pitch/time control.";
    descriptions["best_practice"] = "A template and example node demonstrating best practices.";
    // TTS Family
    descriptions["TTS Performer"] = "Advanced Text-to-Speech engine with word-level sequencing.";
    descriptions["Vocal Tract Filter"] = "A formant filter that simulates human vowel sounds.";
    // Effects
    descriptions["VCF"] = "A Voltage-Controlled Filter (LP, HP, BP).";
    descriptions["Delay"] = "A stereo delay effect with modulation.";
    descriptions["Reverb"] = "A stereo reverb effect.";
    descriptions["chorus"] = "A stereo chorus effect.";
    descriptions["phaser"] = "A stereo phaser effect.";
    descriptions["compressor"] = "Reduces the dynamic range of a signal.";
    descriptions["limiter"] = "Prevents a signal from exceeding a set level.";
    descriptions["gate"] = "A stereo noise gate to silence signals below a threshold.";
    descriptions["drive"] = "A waveshaping distortion effect.";
    descriptions["graphic_eq"] = "An 8-band graphic equalizer.";
    descriptions["frequency_graph"] = "A high-resolution, real-time spectrum analyzer.";
    descriptions["Waveshaper"] = "A distortion effect with multiple shaping algorithms.";
    descriptions["8bandshaper"] = "A multi-band waveshaper for frequency-specific distortion.";
    descriptions["Granulator"] = "A granular synthesizer/effect that plays small grains of a sample.";
    descriptions["harmonic shaper"] = "Shapes the harmonic content of a signal.";
    descriptions["timepitch"] = "Real-time pitch and time manipulation using RubberBand.";
    descriptions["De-Crackle"] = "A utility to reduce clicks from discontinuous signals.";
    descriptions["recorder"] = "Records incoming audio to a WAV, AIFF, or FLAC file.";
    descriptions["tempo_clock"] = "Global clock generator with BPM control, transport, and clock outputs.";
    descriptions["bpm_monitor"] = "Monitors and reports BPM from rhythm-producing modules (sequencers, animations). Always present and undeletable.";
    // Modulators
    descriptions["LFO"] = "A Low-Frequency Oscillator for modulation.";
    descriptions["ADSR"] = "An Attack-Decay-Sustain-Release envelope generator.";
    descriptions["Random"] = "A random value generator with internal sample & hold.";
    descriptions["S&H"] = "A classic Sample and Hold module.";
    descriptions["function_generator"] = "A complex, drawable envelope/LFO generator.";
    descriptions["shaping_oscillator"] = "An oscillator with a built-in waveshaper.";
    // Utilities & Logic
    descriptions["VCA"] = "A Voltage-Controlled Amplifier to control signal level.";
    descriptions["Mixer"] = "A stereo audio mixer with crossfading and panning.";
    descriptions["cv mixer"] = "A mixer specifically for control voltage signals.";
    descriptions["trackmixer"] = "A multi-channel mixer for polyphonic sources.";
    descriptions["Attenuverter"] = "Attenuates (reduces) and/or inverts signals.";
    descriptions["Lag Processor"] = "Smooths out abrupt changes in a signal (slew limiter).";
    descriptions["Math"] = "Performs mathematical operations on signals.";
    descriptions["MapRange"] = "Remaps a signal from one numerical range to another.";
    descriptions["Quantizer"] = "Snaps a continuous signal to a musical scale.";
    descriptions["Rate"] = "Converts a control signal into a normalized rate value.";
    descriptions["Comparator"] = "Outputs a high signal if an input is above a threshold.";
    descriptions["Logic"] = "Performs boolean logic (AND, OR, XOR, NOT) on gate signals.";
    descriptions["ClockDivider"] = "Divides and multiplies clock signals.";
    descriptions["SequentialSwitch"] = "A signal router with multiple thresholds.";
    // Analysis
    descriptions["Scope"] = "Visualizes an audio or CV signal.";
    descriptions["debug"] = "A tool for logging signal value changes.";
    descriptions["input_debug"] = "A passthrough version of the Debug node for inspecting signals on a cable.";
    
    // Physics
    descriptions["physics"] = "A 2D physics simulation that outputs collision and contact data.";
    descriptions["animation"] = "Loads and plays 3D animations, outputs joint positions and velocities.";
    descriptions["stroke_sequencer"] = "Gesture-based sequencer that records and plays back drawn patterns.";
    
    // OpenCV (Computer Vision)
    descriptions["webcam_loader"] = "Captures video from a webcam and publishes it as a source for vision processing modules.";
    descriptions["video_file_loader"] = "Loads and plays a video file, publishes it as a source for vision processing modules.";
    descriptions["movement_detector"] = "Analyzes video source for motion via optical flow or background subtraction, outputs motion data as CV.";
    descriptions["human_detector"] = "Detects faces or bodies in video source via Haar Cascades or HOG, outputs position and size as CV.";
    descriptions["pose_estimator"] = "Uses OpenPose to detect 15 body keypoints (head, shoulders, elbows, wrists, hips, knees, ankles) and outputs their positions as CV signals.";
    descriptions["hand_tracker"] = "Detects 21 hand keypoints and outputs their X/Y positions as CV (42 channels).";
    descriptions["face_tracker"] = "Detects 70 facial landmarks and outputs X/Y positions as CV (140 channels).";
    descriptions["object_detector"] = "Uses YOLOv3 to detect objects (person, car, etc.) and outputs bounding box position/size as CV.";
    descriptions["color_tracker"] = "Tracks multiple colors in video and outputs their positions and sizes as CV.";
    descriptions["contour_detector"] = "Detects shapes via background subtraction and outputs area, complexity, and aspect ratio as CV.";
    descriptions["semantic_segmentation"] = "Uses deep learning to segment video into semantic regions and outputs detected areas as CV.";
    
    // Add aliases for underscore naming conventions
    descriptions["clock_divider"] = descriptions["ClockDivider"];
    descriptions["sequential_switch"] = descriptions["SequentialSwitch"];
    descriptions["s_and_h"] = descriptions["S&H"];
    descriptions["snapshot_sequencer"] = "A sequencer that stores and recalls complete patch states.";
}

void populatePinDatabase()
{
    // Populate both databases
    populateModuleDescriptions();
    
    auto& db = getModulePinDatabase();
    if (!db.empty()) return; // Only run once

    // --- Sources ---
    db["audio_input"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Out 1", 0, PinDataType::Audio), AudioPin("Out 2", 1, PinDataType::Audio),
          AudioPin("Gate", 16, PinDataType::Gate), AudioPin("Trigger", 17, PinDataType::Gate), AudioPin("EOP", 18, PinDataType::Gate) },
        {}
    );
    db["vco"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Frequency", 0, PinDataType::CV), AudioPin("Waveform", 1, PinDataType::CV), AudioPin("Gate", 2, PinDataType::Gate) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    db["noise"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Level Mod", 0, PinDataType::CV), AudioPin("Colour Mod", 1, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) }, // Stereo output to match actual implementation
        {}
    );
    db["value"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Raw", 0, PinDataType::Raw), AudioPin("Normalized", 1, PinDataType::CV), AudioPin("Inverted", 2, PinDataType::Raw),
          AudioPin("Integer", 3, PinDataType::Raw), AudioPin("CV Out", 4, PinDataType::CV) },
        {}
    );
    db["sample_loader"] = ModulePinInfo(
        NodeWidth::Big,
        { AudioPin("Pitch Mod", 0, PinDataType::CV), AudioPin("Speed Mod", 1, PinDataType::CV), AudioPin("Gate Mod", 2, PinDataType::CV),
          AudioPin("Trigger Mod", 3, PinDataType::Gate), AudioPin("Range Start Mod", 4, PinDataType::CV), AudioPin("Range End Mod", 5, PinDataType::CV),
          AudioPin("Randomize Trig", 6, PinDataType::Gate) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // --- Effects ---
    db["vcf"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Cutoff Mod", 2, PinDataType::CV),
          AudioPin("Resonance Mod", 3, PinDataType::CV), AudioPin("Type Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["delay"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Time Mod", 2, PinDataType::CV),
          AudioPin("Feedback Mod", 3, PinDataType::CV), AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["reverb"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Size Mod", 2, PinDataType::CV),
          AudioPin("Damp Mod", 3, PinDataType::CV), AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["compressor"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Thresh Mod", 2, PinDataType::CV),
          AudioPin("Ratio Mod", 3, PinDataType::CV), AudioPin("Attack Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV),
          AudioPin("Makeup Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // --- Modulators ---
    db["lfo"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Rate Mod", 0, PinDataType::CV), AudioPin("Depth Mod", 1, PinDataType::CV), AudioPin("Wave Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );
    db["adsr"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Gate In", 0, PinDataType::Gate), AudioPin("Trigger In", 1, PinDataType::Gate), AudioPin("Attack Mod", 2, PinDataType::CV),
          AudioPin("Decay Mod", 3, PinDataType::CV), AudioPin("Sustain Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV) },
        { AudioPin("Env Out", 0, PinDataType::CV), AudioPin("Inv Out", 1, PinDataType::CV), AudioPin("EOR Gate", 2, PinDataType::Gate),
          AudioPin("EOC Gate", 3, PinDataType::Gate) },
        {}
    );
    db["random"] = ModulePinInfo(
        NodeWidth::Small,
        {}, // No inputs - self-contained random generator
        { AudioPin("Norm Out", 0, PinDataType::CV), AudioPin("Raw Out", 1, PinDataType::Raw), AudioPin("CV Out", 2, PinDataType::CV),
          AudioPin("Bool Out", 3, PinDataType::Gate), AudioPin("Trig Out", 4, PinDataType::Gate) },
        {}
    );

    // --- Utilities ---
    db["vca"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Gain Mod", 2, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["mixer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A L", 0, PinDataType::Audio), AudioPin("In A R", 1, PinDataType::Audio), AudioPin("In B L", 2, PinDataType::Audio),
          AudioPin("In B R", 3, PinDataType::Audio), AudioPin("Gain Mod", 4, PinDataType::CV), AudioPin("Pan Mod", 5, PinDataType::CV),
          AudioPin("X-Fade Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["scope"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In", 0, PinDataType::Audio) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    db["graphic_eq"] = ModulePinInfo(
        NodeWidth::Big,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Band 1 Mod", 2, PinDataType::CV), AudioPin("Band 2 Mod", 3, PinDataType::CV),
          AudioPin("Band 3 Mod", 4, PinDataType::CV), AudioPin("Band 4 Mod", 5, PinDataType::CV),
          AudioPin("Band 5 Mod", 6, PinDataType::CV), AudioPin("Band 6 Mod", 7, PinDataType::CV),
          AudioPin("Band 7 Mod", 8, PinDataType::CV), AudioPin("Band 8 Mod", 9, PinDataType::CV),
          AudioPin("Gate Thresh Mod", 10, PinDataType::CV), AudioPin("Trig Thresh Mod", 11, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio),
          AudioPin("Gate Out", 2, PinDataType::Gate), AudioPin("Trig Out", 3, PinDataType::Gate) },
        {}
    );
    db["frequency_graph"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("In", 0, PinDataType::Audio) }, // Mono Audio Input
        { // Outputs: Stereo audio pass-through + 8 Gate/Trigger outputs
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio),
            AudioPin("Sub Gate", 2, PinDataType::Gate),
            AudioPin("Sub Trig", 3, PinDataType::Gate),
            AudioPin("Bass Gate", 4, PinDataType::Gate),
            AudioPin("Bass Trig", 5, PinDataType::Gate),
            AudioPin("Mid Gate", 6, PinDataType::Gate),
            AudioPin("Mid Trig", 7, PinDataType::Gate),
            AudioPin("High Gate", 8, PinDataType::Gate),
            AudioPin("High Trig", 9, PinDataType::Gate)
        },
        {} // No modulation inputs
    );
    db["chorus"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Depth Mod", 3, PinDataType::CV),
          AudioPin("Mix Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["phaser"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Depth Mod", 3, PinDataType::CV),
          AudioPin("Centre Mod", 4, PinDataType::CV), AudioPin("Feedback Mod", 5, PinDataType::CV),
          AudioPin("Mix Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["compressor"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Thresh Mod", 2, PinDataType::CV), AudioPin("Ratio Mod", 3, PinDataType::CV),
          AudioPin("Attack Mod", 4, PinDataType::CV), AudioPin("Release Mod", 5, PinDataType::CV),
          AudioPin("Makeup Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["Recorder"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        {}, // No outputs
        {}
    );
    db["limiter"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio),
          AudioPin("Thresh Mod", 2, PinDataType::CV), AudioPin("Release Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["gate"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["drive"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["timepitch"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Speed Mod", 2, PinDataType::CV), AudioPin("Pitch Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["waveshaper"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Drive Mod", 2, PinDataType::CV), AudioPin("Type Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["8bandshaper"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("In L", 0, PinDataType::Audio),
            AudioPin("In R", 1, PinDataType::Audio),
            AudioPin("Drive 1 Mod", 2, PinDataType::CV),
            AudioPin("Drive 2 Mod", 3, PinDataType::CV),
            AudioPin("Drive 3 Mod", 4, PinDataType::CV),
            AudioPin("Drive 4 Mod", 5, PinDataType::CV),
            AudioPin("Drive 5 Mod", 6, PinDataType::CV),
            AudioPin("Drive 6 Mod", 7, PinDataType::CV),
            AudioPin("Drive 7 Mod", 8, PinDataType::CV),
            AudioPin("Drive 8 Mod", 9, PinDataType::CV),
            AudioPin("Gain Mod", 10, PinDataType::CV)
        },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["granulator"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("In L", 0, PinDataType::Audio),
            AudioPin("In R", 1, PinDataType::Audio),
            AudioPin("Trigger In", 2, PinDataType::Gate),
            AudioPin("Density Mod", 3, PinDataType::CV),
            AudioPin("Size Mod", 4, PinDataType::CV),
            AudioPin("Position Mod", 5, PinDataType::CV),
            AudioPin("Pitch Mod", 6, PinDataType::CV),
            AudioPin("Gate Mod", 7, PinDataType::CV)
        },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["mixer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A L", 0, PinDataType::Audio), AudioPin("In A R", 1, PinDataType::Audio), AudioPin("In B L", 2, PinDataType::Audio), AudioPin("In B R", 3, PinDataType::Audio), AudioPin("Gain Mod", 4, PinDataType::CV), AudioPin("Pan Mod", 5, PinDataType::CV), AudioPin("X-Fade Mod", 6, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    db["sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("Mod In L", 0, PinDataType::Audio), AudioPin("Mod In R", 1, PinDataType::Audio), AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Gate Mod", 3, PinDataType::CV), AudioPin("Steps Mod", 4, PinDataType::CV), AudioPin("Gate Thr Mod", 5, PinDataType::CV),
          // Per-step value mods absolute 6..21 (Step1..Step16)
          AudioPin("Step 1 Mod", 6, PinDataType::CV), AudioPin("Step 2 Mod", 7, PinDataType::CV), AudioPin("Step 3 Mod", 8, PinDataType::CV), AudioPin("Step 4 Mod", 9, PinDataType::CV),
          AudioPin("Step 5 Mod", 10, PinDataType::CV), AudioPin("Step 6 Mod", 11, PinDataType::CV), AudioPin("Step 7 Mod", 12, PinDataType::CV), AudioPin("Step 8 Mod", 13, PinDataType::CV),
          AudioPin("Step 9 Mod", 14, PinDataType::CV), AudioPin("Step 10 Mod", 15, PinDataType::CV), AudioPin("Step 11 Mod", 16, PinDataType::CV), AudioPin("Step 12 Mod", 17, PinDataType::CV),
          AudioPin("Step 13 Mod", 18, PinDataType::CV), AudioPin("Step 14 Mod", 19, PinDataType::CV), AudioPin("Step 15 Mod", 20, PinDataType::CV), AudioPin("Step 16 Mod", 21, PinDataType::CV),
          // Per-step trig mods absolute 22..37 (Step1..Step16) — these are Gates
          AudioPin("Step 1 Trig Mod", 22, PinDataType::Gate), AudioPin("Step 2 Trig Mod", 23, PinDataType::Gate), AudioPin("Step 3 Trig Mod", 24, PinDataType::Gate), AudioPin("Step 4 Trig Mod", 25, PinDataType::Gate),
          AudioPin("Step 5 Trig Mod", 26, PinDataType::Gate), AudioPin("Step 6 Trig Mod", 27, PinDataType::Gate), AudioPin("Step 7 Trig Mod", 28, PinDataType::Gate), AudioPin("Step 8 Trig Mod", 29, PinDataType::Gate),
          AudioPin("Step 9 Trig Mod", 30, PinDataType::Gate), AudioPin("Step 10 Trig Mod", 31, PinDataType::Gate), AudioPin("Step 11 Trig Mod", 32, PinDataType::Gate), AudioPin("Step 12 Trig Mod", 33, PinDataType::Gate),
          AudioPin("Step 13 Trig Mod", 34, PinDataType::Gate), AudioPin("Step 14 Trig Mod", 35, PinDataType::Gate), AudioPin("Step 15 Trig Mod", 36, PinDataType::Gate), AudioPin("Step 16 Trig Mod", 37, PinDataType::Gate),
          // Per-step gate level mods absolute 38..53
          AudioPin("Step 1 Gate Mod", 38, PinDataType::CV), AudioPin("Step 2 Gate Mod", 39, PinDataType::CV), AudioPin("Step 3 Gate Mod", 40, PinDataType::CV), AudioPin("Step 4 Gate Mod", 41, PinDataType::CV),
          AudioPin("Step 5 Gate Mod", 42, PinDataType::CV), AudioPin("Step 6 Gate Mod", 43, PinDataType::CV), AudioPin("Step 7 Gate Mod", 44, PinDataType::CV), AudioPin("Step 8 Gate Mod", 45, PinDataType::CV),
          AudioPin("Step 9 Gate Mod", 46, PinDataType::CV), AudioPin("Step 10 Gate Mod", 47, PinDataType::CV), AudioPin("Step 11 Gate Mod", 48, PinDataType::CV), AudioPin("Step 12 Gate Mod", 49, PinDataType::CV),
          AudioPin("Step 13 Gate Mod", 50, PinDataType::CV), AudioPin("Step 14 Gate Mod", 51, PinDataType::CV), AudioPin("Step 15 Gate Mod", 52, PinDataType::CV), AudioPin("Step 16 Gate Mod", 53, PinDataType::CV) },
        { AudioPin("Pitch", 0, PinDataType::CV), AudioPin("Gate", 1, PinDataType::Gate), AudioPin("Gate Nuanced", 2, PinDataType::CV), AudioPin("Velocity", 3, PinDataType::CV), AudioPin("Mod", 4, PinDataType::CV), AudioPin("Trigger", 5, PinDataType::Gate) },
        {}
    );

    db["value"] = ModulePinInfo(
        NodeWidth::Small,
        {},
        { AudioPin("Raw", 0, PinDataType::Raw), AudioPin("Normalized", 1, PinDataType::CV), AudioPin("Inverted", 2, PinDataType::Raw), AudioPin("Integer", 3, PinDataType::Raw), AudioPin("CV Out", 4, PinDataType::CV) },
        {}
    );

db["random"] = ModulePinInfo(
    NodeWidth::Small,
    {}, // No inputs - self-contained random generator
    { 
        AudioPin("Norm Out", 0, PinDataType::CV), 
        AudioPin("Raw Out", 1, PinDataType::Raw), 
        AudioPin("CV Out", 2, PinDataType::CV),
        AudioPin("Bool Out", 3, PinDataType::Gate), 
        AudioPin("Trig Out", 4, PinDataType::Gate) 
    },
    {} // No modulation inputs
);

    db["tts performer"] = ModulePinInfo(
        NodeWidth::Big,
        { // Inputs (absolute channels based on bus structure)
            AudioPin("Rate Mod", 0, PinDataType::CV),
            AudioPin("Gate Mod", 1, PinDataType::CV),
            AudioPin("Trigger", 2, PinDataType::Gate),
            AudioPin("Reset", 3, PinDataType::Gate),
            AudioPin("Randomize Trig", 4, PinDataType::Gate),
            AudioPin("Trim Start Mod", 5, PinDataType::CV),
            AudioPin("Trim End Mod", 6, PinDataType::CV),
            AudioPin("Speed Mod", 7, PinDataType::CV),
            AudioPin("Pitch Mod", 8, PinDataType::CV),
            // Word Triggers (Channels 9-24)
            AudioPin("Word 1 Trig", 9, PinDataType::Gate), AudioPin("Word 2 Trig", 10, PinDataType::Gate),
            AudioPin("Word 3 Trig", 11, PinDataType::Gate), AudioPin("Word 4 Trig", 12, PinDataType::Gate),
            AudioPin("Word 5 Trig", 13, PinDataType::Gate), AudioPin("Word 6 Trig", 14, PinDataType::Gate),
            AudioPin("Word 7 Trig", 15, PinDataType::Gate), AudioPin("Word 8 Trig", 16, PinDataType::Gate),
            AudioPin("Word 9 Trig", 17, PinDataType::Gate), AudioPin("Word 10 Trig", 18, PinDataType::Gate),
            AudioPin("Word 11 Trig", 19, PinDataType::Gate), AudioPin("Word 12 Trig", 20, PinDataType::Gate),
            AudioPin("Word 13 Trig", 21, PinDataType::Gate), AudioPin("Word 14 Trig", 22, PinDataType::Gate),
            AudioPin("Word 15 Trig", 23, PinDataType::Gate), AudioPin("Word 16 Trig", 24, PinDataType::Gate)
        },
        { // Outputs
            AudioPin("Audio", 0, PinDataType::Audio),
            AudioPin("Word Gate", 1, PinDataType::Gate),
            AudioPin("EOP Gate", 2, PinDataType::Gate),
            // Per-Word Gates (Channels 3-18)
            AudioPin("Word 1 Gate", 3, PinDataType::Gate), AudioPin("Word 2 Gate", 4, PinDataType::Gate),
            AudioPin("Word 3 Gate", 5, PinDataType::Gate), AudioPin("Word 4 Gate", 6, PinDataType::Gate),
            AudioPin("Word 5 Gate", 7, PinDataType::Gate), AudioPin("Word 6 Gate", 8, PinDataType::Gate),
            AudioPin("Word 7 Gate", 9, PinDataType::Gate), AudioPin("Word 8 Gate", 10, PinDataType::Gate),
            AudioPin("Word 9 Gate", 11, PinDataType::Gate), AudioPin("Word 10 Gate", 12, PinDataType::Gate),
            AudioPin("Word 11 Gate", 13, PinDataType::Gate), AudioPin("Word 12 Gate", 14, PinDataType::Gate),
            AudioPin("Word 13 Gate", 15, PinDataType::Gate), AudioPin("Word 14 Gate", 16, PinDataType::Gate),
            AudioPin("Word 15 Gate", 17, PinDataType::Gate), AudioPin("Word 16 Gate", 18, PinDataType::Gate),
            // Per-Word Triggers (Channels 19-34)
            AudioPin("Word 1 Trig", 19, PinDataType::Gate), AudioPin("Word 2 Trig", 20, PinDataType::Gate),
            AudioPin("Word 3 Trig", 21, PinDataType::Gate), AudioPin("Word 4 Trig", 22, PinDataType::Gate),
            AudioPin("Word 5 Trig", 23, PinDataType::Gate), AudioPin("Word 6 Trig", 24, PinDataType::Gate),
            AudioPin("Word 7 Trig", 25, PinDataType::Gate), AudioPin("Word 8 Trig", 26, PinDataType::Gate),
            AudioPin("Word 9 Trig", 27, PinDataType::Gate), AudioPin("Word 10 Trig", 28, PinDataType::Gate),
            AudioPin("Word 11 Trig", 29, PinDataType::Gate), AudioPin("Word 12 Trig", 30, PinDataType::Gate),
            AudioPin("Word 13 Trig", 31, PinDataType::Gate), AudioPin("Word 14 Trig", 32, PinDataType::Gate),
            AudioPin("Word 15 Trig", 33, PinDataType::Gate), AudioPin("Word 16 Trig", 34, PinDataType::Gate)
        },
        { // Modulation Pins (for UI parameter disabling)
            ModPin("Rate", "rate_mod", PinDataType::CV),
            ModPin("Gate", "gate_mod", PinDataType::CV),
            ModPin("Trim Start", "trimStart_mod", PinDataType::CV),
            ModPin("Trim End", "trimEnd_mod", PinDataType::CV),
            ModPin("Speed", "speed_mod", PinDataType::CV),
            ModPin("Pitch", "pitch_mod", PinDataType::CV)
        }
    );
    db["vocal tract filter"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Audio In", 0, PinDataType::Audio) },
        { AudioPin("Audio Out", 0, PinDataType::Audio) },
        { ModPin("Vowel", "vowelShape", PinDataType::CV), ModPin("Formant", "formantShift", PinDataType::CV), ModPin("Instability", "instability", PinDataType::CV), ModPin("Gain", "formantGain", PinDataType::CV) }
    );
    db["best_practice"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Wave Mod", 3, PinDataType::CV), AudioPin("Drive Mod", 4, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        { ModPin("Frequency", "frequency_mod", PinDataType::CV), ModPin("Waveform", "waveform_mod", PinDataType::CV), ModPin("Drive", "drive_mod", PinDataType::CV) }
    );
    db["shaping_oscillator"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Wave Mod", 3, PinDataType::CV), AudioPin("Drive Mod", 4, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        { ModPin("Frequency", "frequency_mod", PinDataType::CV), ModPin("Waveform", "waveform_mod", PinDataType::CV), ModPin("Drive", "drive_mod", PinDataType::CV) }
    );
    db["harmonic shaper"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Freq Mod", 2, PinDataType::CV), AudioPin("Drive Mod", 3, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        { ModPin("Master Frequency", "masterFrequency_mod", PinDataType::CV), ModPin("Master Drive", "masterDrive_mod", PinDataType::CV) }
    );
    db["function_generator"] = ModulePinInfo(
        NodeWidth::Big,
        { 
            AudioPin("Gate In", 0, PinDataType::Gate),
            AudioPin("Trigger In", 1, PinDataType::Gate),
            AudioPin("Sync In", 2, PinDataType::Gate),
            AudioPin("Rate Mod", 3, PinDataType::CV),
            AudioPin("Slew Mod", 4, PinDataType::CV),
            AudioPin("Gate Thresh Mod", 5, PinDataType::CV),
            AudioPin("Trig Thresh Mod", 6, PinDataType::CV),
            AudioPin("Pitch Base Mod", 7, PinDataType::CV),
            AudioPin("Value Mult Mod", 8, PinDataType::CV),
            AudioPin("Curve Select Mod", 9, PinDataType::CV)
        },
        { 
            AudioPin("Value", 0, PinDataType::CV),
            AudioPin("Inverted", 1, PinDataType::CV),
            AudioPin("Bipolar", 2, PinDataType::CV),
            AudioPin("Pitch", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate),
            AudioPin("Trigger", 5, PinDataType::Gate),
            AudioPin("End of Cycle", 6, PinDataType::Gate),
            // New dedicated outputs
            AudioPin("Blue Value", 7, PinDataType::CV),
            AudioPin("Blue Pitch", 8, PinDataType::CV),
            AudioPin("Red Value", 9, PinDataType::CV),
            AudioPin("Red Pitch", 10, PinDataType::CV),
            AudioPin("Green Value", 11, PinDataType::CV),
            AudioPin("Green Pitch", 12, PinDataType::CV)
        },
        { 
            ModPin("Rate", "rate_mod", PinDataType::CV),
            ModPin("Slew", "slew_mod", PinDataType::CV),
            ModPin("Gate Thresh", "gateThresh_mod", PinDataType::CV),
            ModPin("Trig Thresh", "trigThresh_mod", PinDataType::CV),
            ModPin("Pitch Base", "pitchBase_mod", PinDataType::CV),
            ModPin("Value Mult", "valueMult_mod", PinDataType::CV),
            ModPin("Curve Select", "curveSelect_mod", PinDataType::CV)
        }
    );

    db["multi sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { // Inputs: Mod In L, Mod In R, Rate Mod, Gate Mod, Steps Mod, Gate Thr Mod, plus per-step mods and triggers
            AudioPin("Mod In L", 0, PinDataType::Audio), AudioPin("Mod In R", 1, PinDataType::Audio),
            AudioPin("Rate Mod", 2, PinDataType::CV), AudioPin("Gate Mod", 3, PinDataType::CV),
            AudioPin("Steps Mod", 4, PinDataType::CV), AudioPin("Gate Thr Mod", 5, PinDataType::CV),
            // Per-step mods (channels 6-21)
            AudioPin("Step 1 Mod", 6, PinDataType::CV), AudioPin("Step 2 Mod", 7, PinDataType::CV),
            AudioPin("Step 3 Mod", 8, PinDataType::CV), AudioPin("Step 4 Mod", 9, PinDataType::CV),
            AudioPin("Step 5 Mod", 10, PinDataType::CV), AudioPin("Step 6 Mod", 11, PinDataType::CV),
            AudioPin("Step 7 Mod", 12, PinDataType::CV), AudioPin("Step 8 Mod", 13, PinDataType::CV),
            AudioPin("Step 9 Mod", 14, PinDataType::CV), AudioPin("Step 10 Mod", 15, PinDataType::CV),
            AudioPin("Step 11 Mod", 16, PinDataType::CV), AudioPin("Step 12 Mod", 17, PinDataType::CV),
            AudioPin("Step 13 Mod", 18, PinDataType::CV), AudioPin("Step 14 Mod", 19, PinDataType::CV),
            AudioPin("Step 15 Mod", 20, PinDataType::CV), AudioPin("Step 16 Mod", 21, PinDataType::CV),
            // Per-step trigger mods (channels 22-37)
            AudioPin("Step 1 Trig Mod", 22, PinDataType::Gate), AudioPin("Step 2 Trig Mod", 23, PinDataType::Gate),
            AudioPin("Step 3 Trig Mod", 24, PinDataType::Gate), AudioPin("Step 4 Trig Mod", 25, PinDataType::Gate),
            AudioPin("Step 5 Trig Mod", 26, PinDataType::Gate), AudioPin("Step 6 Trig Mod", 27, PinDataType::Gate),
            AudioPin("Step 7 Trig Mod", 28, PinDataType::Gate), AudioPin("Step 8 Trig Mod", 29, PinDataType::Gate),
            AudioPin("Step 9 Trig Mod", 30, PinDataType::Gate), AudioPin("Step 10 Trig Mod", 31, PinDataType::Gate),
            AudioPin("Step 11 Trig Mod", 32, PinDataType::Gate), AudioPin("Step 12 Trig Mod", 33, PinDataType::Gate),
            AudioPin("Step 13 Trig Mod", 34, PinDataType::Gate), AudioPin("Step 14 Trig Mod", 35, PinDataType::Gate),
            AudioPin("Step 15 Trig Mod", 36, PinDataType::Gate), AudioPin("Step 16 Trig Mod", 37, PinDataType::Gate)
        },
        { // Outputs: Live outputs (0-6) + Parallel step outputs (7+)
            // Live Outputs
            AudioPin("Pitch", 0, PinDataType::CV), AudioPin("Gate", 1, PinDataType::Gate),
            AudioPin("Gate Nuanced", 2, PinDataType::CV), AudioPin("Velocity", 3, PinDataType::CV),
            AudioPin("Mod", 4, PinDataType::CV), AudioPin("Trigger", 5, PinDataType::Gate),
            AudioPin("Num Steps", 6, PinDataType::Raw),
            // Parallel Step Outputs (Corrected Names and Channels, shifted by +1 after Num Steps)
            AudioPin("Pitch 1", 7, PinDataType::CV), AudioPin("Gate 1", 8, PinDataType::Gate), AudioPin("Trig 1", 9, PinDataType::Gate),
            AudioPin("Pitch 2", 10, PinDataType::CV), AudioPin("Gate 2", 11, PinDataType::Gate), AudioPin("Trig 2", 12, PinDataType::Gate),
            AudioPin("Pitch 3", 13, PinDataType::CV), AudioPin("Gate 3", 14, PinDataType::Gate), AudioPin("Trig 3", 15, PinDataType::Gate),
            AudioPin("Pitch 4", 16, PinDataType::CV), AudioPin("Gate 4", 17, PinDataType::Gate), AudioPin("Trig 4", 18, PinDataType::Gate),
            AudioPin("Pitch 5", 19, PinDataType::CV), AudioPin("Gate 5", 20, PinDataType::Gate), AudioPin("Trig 5", 21, PinDataType::Gate),
            AudioPin("Pitch 6", 22, PinDataType::CV), AudioPin("Gate 6", 23, PinDataType::Gate), AudioPin("Trig 6", 24, PinDataType::Gate),
            AudioPin("Pitch 7", 25, PinDataType::CV), AudioPin("Gate 7", 26, PinDataType::Gate), AudioPin("Trig 7", 27, PinDataType::Gate),
            AudioPin("Pitch 8", 28, PinDataType::CV), AudioPin("Gate 8", 29, PinDataType::Gate), AudioPin("Trig 8", 30, PinDataType::Gate),
            AudioPin("Pitch 9", 31, PinDataType::CV), AudioPin("Gate 9", 32, PinDataType::Gate), AudioPin("Trig 9", 33, PinDataType::Gate),
            AudioPin("Pitch 10", 34, PinDataType::CV), AudioPin("Gate 10", 35, PinDataType::Gate), AudioPin("Trig 10", 36, PinDataType::Gate),
            AudioPin("Pitch 11", 37, PinDataType::CV), AudioPin("Gate 11", 38, PinDataType::Gate), AudioPin("Trig 11", 39, PinDataType::Gate),
            AudioPin("Pitch 12", 40, PinDataType::CV), AudioPin("Gate 12", 41, PinDataType::Gate), AudioPin("Trig 12", 42, PinDataType::Gate),
            AudioPin("Pitch 13", 43, PinDataType::CV), AudioPin("Gate 13", 44, PinDataType::Gate), AudioPin("Trig 13", 45, PinDataType::Gate),
            AudioPin("Pitch 14", 46, PinDataType::CV), AudioPin("Gate 14", 47, PinDataType::Gate), AudioPin("Trig 14", 48, PinDataType::Gate),
            AudioPin("Pitch 15", 49, PinDataType::CV), AudioPin("Gate 15", 50, PinDataType::Gate), AudioPin("Trig 15", 51, PinDataType::Gate),
            AudioPin("Pitch 16", 52, PinDataType::CV), AudioPin("Gate 16", 53, PinDataType::Gate), AudioPin("Trig 16", 54, PinDataType::Gate)
        },
        {}
    );
    db["comparator"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In", 0, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Gate) },
        {}
    );

    db["sample_loader"] = ModulePinInfo(
        NodeWidth::Big,
        {
            AudioPin("Pitch Mod", 0, PinDataType::CV),
            AudioPin("Speed Mod", 1, PinDataType::CV),
            AudioPin("Gate Mod", 2, PinDataType::CV),
            AudioPin("Trigger Mod", 3, PinDataType::Gate),
            AudioPin("Range Start Mod", 4, PinDataType::CV),
            AudioPin("Range End Mod", 5, PinDataType::CV),
            AudioPin("Randomize Trig", 6, PinDataType::Gate)
        },
        {
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    // Track Mixer - first 8 tracks UI definition (mono per track + gain/pan CV) and a Tracks Mod pin
    db["track mixer"] = ModulePinInfo(
        NodeWidth::Big,
        {
            // Mono audio inputs for first 8 tracks (absolute channels 0..7)
            AudioPin("In 1", 0, PinDataType::Audio),
            AudioPin("In 2", 1, PinDataType::Audio),
            AudioPin("In 3", 2, PinDataType::Audio),
            AudioPin("In 4", 3, PinDataType::Audio),
            AudioPin("In 5", 4, PinDataType::Audio),
            AudioPin("In 6", 5, PinDataType::Audio),
            AudioPin("In 7", 6, PinDataType::Audio),
            AudioPin("In 8", 7, PinDataType::Audio),

            // Num Tracks modulation CV at absolute channel 64 (start of Mod bus)
            AudioPin("Num Tracks Mod", 64, PinDataType::Raw),

            // Per-track CV inputs on Mod bus: Gain at 65,67,... Pan at 66,68,...
            AudioPin("Gain 1 Mod", 65, PinDataType::CV),  AudioPin("Pan 1 Mod", 66, PinDataType::CV),
            AudioPin("Gain 2 Mod", 67, PinDataType::CV),  AudioPin("Pan 2 Mod", 68, PinDataType::CV),
            AudioPin("Gain 3 Mod", 69, PinDataType::CV),  AudioPin("Pan 3 Mod", 70, PinDataType::CV),
            AudioPin("Gain 4 Mod", 71, PinDataType::CV),  AudioPin("Pan 4 Mod", 72, PinDataType::CV),
            AudioPin("Gain 5 Mod", 73, PinDataType::CV),  AudioPin("Pan 5 Mod", 74, PinDataType::CV),
            AudioPin("Gain 6 Mod", 75, PinDataType::CV),  AudioPin("Pan 6 Mod", 76, PinDataType::CV),
            AudioPin("Gain 7 Mod", 77, PinDataType::CV),  AudioPin("Pan 7 Mod", 78, PinDataType::CV),
            AudioPin("Gain 8 Mod", 79, PinDataType::CV),  AudioPin("Pan 8 Mod", 80, PinDataType::CV)
        },
        {
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    // Add PolyVCO module - Build the pin lists directly in initializer list
    db["polyvco"] = ModulePinInfo(
        NodeWidth::Big,
        {
            // Num Voices modulation input
            AudioPin("Num Voices Mod", 0, PinDataType::Raw),
            
            // Frequency modulation inputs (channels 1-32)
            AudioPin("Freq 1 Mod", 1, PinDataType::CV), AudioPin("Freq 2 Mod", 2, PinDataType::CV),
            AudioPin("Freq 3 Mod", 3, PinDataType::CV), AudioPin("Freq 4 Mod", 4, PinDataType::CV),
            AudioPin("Freq 5 Mod", 5, PinDataType::CV), AudioPin("Freq 6 Mod", 6, PinDataType::CV),
            AudioPin("Freq 7 Mod", 7, PinDataType::CV), AudioPin("Freq 8 Mod", 8, PinDataType::CV),
            AudioPin("Freq 9 Mod", 9, PinDataType::CV), AudioPin("Freq 10 Mod", 10, PinDataType::CV),
            AudioPin("Freq 11 Mod", 11, PinDataType::CV), AudioPin("Freq 12 Mod", 12, PinDataType::CV),
            AudioPin("Freq 13 Mod", 13, PinDataType::CV), AudioPin("Freq 14 Mod", 14, PinDataType::CV),
            AudioPin("Freq 15 Mod", 15, PinDataType::CV), AudioPin("Freq 16 Mod", 16, PinDataType::CV),
            AudioPin("Freq 17 Mod", 17, PinDataType::CV), AudioPin("Freq 18 Mod", 18, PinDataType::CV),
            AudioPin("Freq 19 Mod", 19, PinDataType::CV), AudioPin("Freq 20 Mod", 20, PinDataType::CV),
            AudioPin("Freq 21 Mod", 21, PinDataType::CV), AudioPin("Freq 22 Mod", 22, PinDataType::CV),
            AudioPin("Freq 23 Mod", 23, PinDataType::CV), AudioPin("Freq 24 Mod", 24, PinDataType::CV),
            AudioPin("Freq 25 Mod", 25, PinDataType::CV), AudioPin("Freq 26 Mod", 26, PinDataType::CV),
            AudioPin("Freq 27 Mod", 27, PinDataType::CV), AudioPin("Freq 28 Mod", 28, PinDataType::CV),
            AudioPin("Freq 29 Mod", 29, PinDataType::CV), AudioPin("Freq 30 Mod", 30, PinDataType::CV),
            AudioPin("Freq 31 Mod", 31, PinDataType::CV), AudioPin("Freq 32 Mod", 32, PinDataType::CV),
            
            // Waveform modulation inputs (channels 33-64)
            AudioPin("Wave 1 Mod", 33, PinDataType::CV), AudioPin("Wave 2 Mod", 34, PinDataType::CV),
            AudioPin("Wave 3 Mod", 35, PinDataType::CV), AudioPin("Wave 4 Mod", 36, PinDataType::CV),
            AudioPin("Wave 5 Mod", 37, PinDataType::CV), AudioPin("Wave 6 Mod", 38, PinDataType::CV),
            AudioPin("Wave 7 Mod", 39, PinDataType::CV), AudioPin("Wave 8 Mod", 40, PinDataType::CV),
            AudioPin("Wave 9 Mod", 41, PinDataType::CV), AudioPin("Wave 10 Mod", 42, PinDataType::CV),
            AudioPin("Wave 11 Mod", 43, PinDataType::CV), AudioPin("Wave 12 Mod", 44, PinDataType::CV),
            AudioPin("Wave 13 Mod", 45, PinDataType::CV), AudioPin("Wave 14 Mod", 46, PinDataType::CV),
            AudioPin("Wave 15 Mod", 47, PinDataType::CV), AudioPin("Wave 16 Mod", 48, PinDataType::CV),
            AudioPin("Wave 17 Mod", 49, PinDataType::CV), AudioPin("Wave 18 Mod", 50, PinDataType::CV),
            AudioPin("Wave 19 Mod", 51, PinDataType::CV), AudioPin("Wave 20 Mod", 52, PinDataType::CV),
            AudioPin("Wave 21 Mod", 53, PinDataType::CV), AudioPin("Wave 22 Mod", 54, PinDataType::CV),
            AudioPin("Wave 23 Mod", 55, PinDataType::CV), AudioPin("Wave 24 Mod", 56, PinDataType::CV),
            AudioPin("Wave 25 Mod", 57, PinDataType::CV), AudioPin("Wave 26 Mod", 58, PinDataType::CV),
            AudioPin("Wave 27 Mod", 59, PinDataType::CV), AudioPin("Wave 28 Mod", 60, PinDataType::CV),
            AudioPin("Wave 29 Mod", 61, PinDataType::CV), AudioPin("Wave 30 Mod", 62, PinDataType::CV),
            AudioPin("Wave 31 Mod", 63, PinDataType::CV), AudioPin("Wave 32 Mod", 64, PinDataType::CV),
            
            // Gate modulation inputs (channels 65-96)
            AudioPin("Gate 1 Mod", 65, PinDataType::Gate), AudioPin("Gate 2 Mod", 66, PinDataType::Gate),
            AudioPin("Gate 3 Mod", 67, PinDataType::Gate), AudioPin("Gate 4 Mod", 68, PinDataType::Gate),
            AudioPin("Gate 5 Mod", 69, PinDataType::Gate), AudioPin("Gate 6 Mod", 70, PinDataType::Gate),
            AudioPin("Gate 7 Mod", 71, PinDataType::Gate), AudioPin("Gate 8 Mod", 72, PinDataType::Gate),
            AudioPin("Gate 9 Mod", 73, PinDataType::Gate), AudioPin("Gate 10 Mod", 74, PinDataType::Gate),
            AudioPin("Gate 11 Mod", 75, PinDataType::Gate), AudioPin("Gate 12 Mod", 76, PinDataType::Gate),
            AudioPin("Gate 13 Mod", 77, PinDataType::Gate), AudioPin("Gate 14 Mod", 78, PinDataType::Gate),
            AudioPin("Gate 15 Mod", 79, PinDataType::Gate), AudioPin("Gate 16 Mod", 80, PinDataType::Gate),
            AudioPin("Gate 17 Mod", 81, PinDataType::Gate), AudioPin("Gate 18 Mod", 82, PinDataType::Gate),
            AudioPin("Gate 19 Mod", 83, PinDataType::Gate), AudioPin("Gate 20 Mod", 84, PinDataType::Gate),
            AudioPin("Gate 21 Mod", 85, PinDataType::Gate), AudioPin("Gate 22 Mod", 86, PinDataType::Gate),
            AudioPin("Gate 23 Mod", 87, PinDataType::Gate), AudioPin("Gate 24 Mod", 88, PinDataType::Gate),
            AudioPin("Gate 25 Mod", 89, PinDataType::Gate), AudioPin("Gate 26 Mod", 90, PinDataType::Gate),
            AudioPin("Gate 27 Mod", 91, PinDataType::Gate), AudioPin("Gate 28 Mod", 92, PinDataType::Gate),
            AudioPin("Gate 29 Mod", 93, PinDataType::Gate), AudioPin("Gate 30 Mod", 94, PinDataType::Gate),
            AudioPin("Gate 31 Mod", 95, PinDataType::Gate), AudioPin("Gate 32 Mod", 96, PinDataType::Gate)
        },
        {
            // Audio outputs (channels 0-31)
            AudioPin("Out 1", 0, PinDataType::Audio), AudioPin("Out 2", 1, PinDataType::Audio),
            AudioPin("Out 3", 2, PinDataType::Audio), AudioPin("Out 4", 3, PinDataType::Audio),
            AudioPin("Out 5", 4, PinDataType::Audio), AudioPin("Out 6", 5, PinDataType::Audio),
            AudioPin("Out 7", 6, PinDataType::Audio), AudioPin("Out 8", 7, PinDataType::Audio),
            AudioPin("Out 9", 8, PinDataType::Audio), AudioPin("Out 10", 9, PinDataType::Audio),
            AudioPin("Out 11", 10, PinDataType::Audio), AudioPin("Out 12", 11, PinDataType::Audio),
            AudioPin("Out 13", 12, PinDataType::Audio), AudioPin("Out 14", 13, PinDataType::Audio),
            AudioPin("Out 15", 14, PinDataType::Audio), AudioPin("Out 16", 15, PinDataType::Audio),
            AudioPin("Out 17", 16, PinDataType::Audio), AudioPin("Out 18", 17, PinDataType::Audio),
            AudioPin("Out 19", 18, PinDataType::Audio), AudioPin("Out 20", 19, PinDataType::Audio),
            AudioPin("Out 21", 20, PinDataType::Audio), AudioPin("Out 22", 21, PinDataType::Audio),
            AudioPin("Out 23", 22, PinDataType::Audio), AudioPin("Out 24", 23, PinDataType::Audio),
            AudioPin("Out 25", 24, PinDataType::Audio), AudioPin("Out 26", 25, PinDataType::Audio),
            AudioPin("Out 27", 26, PinDataType::Audio), AudioPin("Out 28", 27, PinDataType::Audio),
            AudioPin("Out 29", 28, PinDataType::Audio), AudioPin("Out 30", 29, PinDataType::Audio),
            AudioPin("Out 31", 30, PinDataType::Audio), AudioPin("Out 32", 31, PinDataType::Audio)
        },
        {}
    );
    
    // Add missing modules
    db["Quantizer"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("CV In", 0, PinDataType::CV), AudioPin("Scale Mod", 1, PinDataType::CV), AudioPin("Root Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );
    
    db["TimePitch"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Audio In", 0, PinDataType::Audio), AudioPin("Speed Mod", 1, PinDataType::CV), AudioPin("Pitch Mod", 2, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );
    
    // Note: TTS Performer pin database is defined earlier in this function (around line 378)
    // Duplicate entry removed to avoid conflicts

    
    // Add TrackMixer module alias (main definition is "track mixer" above)
    db["trackmixer"] = db["track mixer"];
    
    
    // Add MIDI Player module
    db["midiplayer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        {},
        {},
        {}
    );
    
    // Add converter modules
    db["Attenuverter"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio), AudioPin("Amount Mod", 2, PinDataType::CV) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );
    
    // Add lowercase alias for Attenuverter
    db["attenuverter"] = db["Attenuverter"];
    
    // Add Sample & Hold module
    db["s&h"] = ModulePinInfo(
        NodeWidth::Small,
        { 
            AudioPin("Signal In L", 0, PinDataType::Audio),
            AudioPin("Signal In R", 1, PinDataType::Audio),
            AudioPin("Trig In L", 2, PinDataType::Gate),
            AudioPin("Trig In R", 3, PinDataType::Gate),
            AudioPin("Threshold Mod", 4, PinDataType::CV),
            AudioPin("Edge Mod", 5, PinDataType::CV),
            AudioPin("Slew Mod", 6, PinDataType::CV)
        },
        { 
            AudioPin("Out L", 0, PinDataType::Audio),
            AudioPin("Out R", 1, PinDataType::Audio)
        },
        {}
    );
    
    db["MapRange"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Raw In", 0, PinDataType::Raw) },
        { AudioPin("CV Out", 0, PinDataType::CV), AudioPin("Audio Out", 1, PinDataType::Audio) },
        { ModPin("Min In", "minIn", PinDataType::Raw), ModPin("Max In", "maxIn", PinDataType::Raw), ModPin("Min Out", "minOut", PinDataType::Raw), ModPin("Max Out", "maxOut", PinDataType::Raw) }
    );
    
    db["Lag Processor"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Signal In", 0, PinDataType::CV), AudioPin("Rise Mod", 1, PinDataType::CV), AudioPin("Fall Mod", 2, PinDataType::CV) },
        { AudioPin("Smoothed Out", 0, PinDataType::CV) },
        {}
    );
    
    db["De-Crackle"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
        { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
        {}
    );

    // ADD MISSING MODULES FOR COLOR-CODED CHAINING

    db["Scope"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("In", 0, PinDataType::Audio) },
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );

    db["Logic"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A", 0, PinDataType::Gate), AudioPin("In B", 1, PinDataType::Gate) },
        {
            AudioPin("AND", 0, PinDataType::Gate),
            AudioPin("OR", 1, PinDataType::Gate),
            AudioPin("XOR", 2, PinDataType::Gate),
            AudioPin("NOT A", 3, PinDataType::Gate)
        },
        {}
    );

    db["ClockDivider"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Clock In", 0, PinDataType::Gate), AudioPin("Reset", 1, PinDataType::Gate) },
        {
            AudioPin("/2", 0, PinDataType::Gate), AudioPin("/4", 1, PinDataType::Gate),
            AudioPin("/8", 2, PinDataType::Gate), AudioPin("x2", 3, PinDataType::Gate),
            AudioPin("x3", 4, PinDataType::Gate), AudioPin("x4", 5, PinDataType::Gate)
        },
        {}
    );

    db["Rate"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("Rate Mod", 0, PinDataType::CV) },
        { AudioPin("Out", 0, PinDataType::CV) },
        {}
    );

    // ADD REMAINING MISSING MODULES FROM CMAKE LISTS

    db["Math"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In A", 0, PinDataType::CV), AudioPin("In B", 1, PinDataType::CV) },
        { AudioPin("Add", 0, PinDataType::CV), AudioPin("Subtract", 1, PinDataType::CV),
          AudioPin("Multiply", 2, PinDataType::CV), AudioPin("Divide", 3, PinDataType::CV) },
        {}
    );

    db["SequentialSwitch"] = ModulePinInfo(
        NodeWidth::Small,
        { 
            AudioPin("Gate In", 0, PinDataType::Audio),
            AudioPin("Thresh 1 CV", 1, PinDataType::CV),
            AudioPin("Thresh 2 CV", 2, PinDataType::CV),
            AudioPin("Thresh 3 CV", 3, PinDataType::CV),
            AudioPin("Thresh 4 CV", 4, PinDataType::CV)
        },
        { 
            AudioPin("Out 1", 0, PinDataType::Audio),
            AudioPin("Out 2", 1, PinDataType::Audio),
            AudioPin("Out 3", 2, PinDataType::Audio),
            AudioPin("Out 4", 3, PinDataType::Audio)
        },
        {}
    );

    db["snapshot_sequencer"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        { AudioPin("Clock", 0, PinDataType::Gate), AudioPin("Reset", 1, PinDataType::Gate) },
        {}, // No audio outputs
        {}
    );

    db["midi cv"] = ModulePinInfo(
        NodeWidth::Medium,
        {}, // No inputs - receives MIDI messages
        {
            AudioPin("Pitch", 0, PinDataType::CV),
            AudioPin("Gate", 1, PinDataType::Gate),
            AudioPin("Velocity", 2, PinDataType::CV),
            AudioPin("Mod Wheel", 3, PinDataType::CV),
            AudioPin("Pitch Bend", 4, PinDataType::CV),
            AudioPin("Aftertouch", 5, PinDataType::CV)
        },
        {}
    );

    // MIDI Family - New Modules with Correct Pin Types
    {
        // MIDI Faders: All outputs are CV (blue)
        db["midi faders"] = ModulePinInfo();
        db["midi faders"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 16; ++i)
            db["midi faders"].audioOuts.emplace_back("Fader " + juce::String(i+1), i, PinDataType::CV);

        // MIDI Knobs: All outputs are CV (blue)
        db["midi knobs"] = ModulePinInfo();
        db["midi knobs"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 16; ++i)
            db["midi knobs"].audioOuts.emplace_back("Knob " + juce::String(i+1), i, PinDataType::CV);

        // MIDI Buttons: All outputs are Gate/Trigger (yellow)
        db["midi buttons"] = ModulePinInfo();
        db["midi buttons"].defaultWidth = NodeWidth::Big;
        for (int i = 0; i < 32; ++i)
            db["midi buttons"].audioOuts.emplace_back("Button " + juce::String(i+1), i, PinDataType::Gate);

        // MIDI Jog Wheel: Output is CV (blue)
        db["midi jog wheel"] = ModulePinInfo(
            NodeWidth::Small,
            {},
            { AudioPin("Value", 0, PinDataType::CV) },
            {}
        );
    }

    db["Debug"] = ModulePinInfo(
        NodeWidth::Small,
        { AudioPin("In", 0, PinDataType::Audio) },
        {}, // No outputs
        {}
    );

    db["InputDebug"] = ModulePinInfo(
        NodeWidth::Small,
        {}, // No inputs
        { AudioPin("Out", 0, PinDataType::Audio) },
        {}
    );

    // Tempo Clock
    db["tempo_clock"] = ModulePinInfo(
        NodeWidth::ExtraWide,
        {
            AudioPin("BPM Mod", 0, PinDataType::CV),
            AudioPin("Tap", 1, PinDataType::Gate),
            AudioPin("Nudge+", 2, PinDataType::Gate),
            AudioPin("Nudge-", 3, PinDataType::Gate),
            AudioPin("Play", 4, PinDataType::Gate),
            AudioPin("Stop", 5, PinDataType::Gate),
            AudioPin("Reset", 6, PinDataType::Gate),
            AudioPin("Swing Mod", 7, PinDataType::CV)
        },
        {
            AudioPin("Clock", 0, PinDataType::Gate),
            AudioPin("Beat Trig", 1, PinDataType::Gate),
            AudioPin("Bar Trig", 2, PinDataType::Gate),
            AudioPin("Beat Gate", 3, PinDataType::Gate),
            AudioPin("Phase", 4, PinDataType::CV),
            AudioPin("BPM CV", 5, PinDataType::CV),
            AudioPin("Downbeat", 6, PinDataType::Gate)
        },
        {
            ModPin("BPM", "bpm_mod", PinDataType::CV),
            ModPin("Tap", "tap_mod", PinDataType::Gate),
            ModPin("Nudge+", "nudge_up_mod", PinDataType::Gate),
            ModPin("Nudge-", "nudge_down_mod", PinDataType::Gate),
            ModPin("Play", "play_mod", PinDataType::Gate),
            ModPin("Stop", "stop_mod", PinDataType::Gate),
            ModPin("Reset", "reset_mod", PinDataType::Gate),
            ModPin("Swing", "swing_mod", PinDataType::CV)
        }
    );

    // BPM Monitor - Uses dynamic pins based on detected rhythm sources
    db["bpm_monitor"] = ModulePinInfo(
        NodeWidth::Big,
        {}, // Dynamic inputs defined by module (beat detection inputs)
        {}, // Dynamic outputs defined by module (per-source BPM/CV/Active)
        {}
    );

    // Physics Module - Exception size (custom dimensions defined by module)
    db["physics"] = ModulePinInfo(
        NodeWidth::Exception,
        {}, // Dynamic inputs defined by module
        {}, // Dynamic outputs defined by module
        {}
    );

    db["webcam_loader"] = ModulePinInfo(
        NodeWidth::Exception, // Custom size for video display
        {}, // No inputs
        { 
            AudioPin("Source ID", 0, PinDataType::Raw)
        },
        {}
    );

    db["video_file_loader"] = ModulePinInfo(
        NodeWidth::Exception, // Custom size for video display
        {}, // No inputs
        { 
            AudioPin("Source ID", 0, PinDataType::Raw)
        },
        {}
    );

    db["movement_detector"] = ModulePinInfo(
        NodeWidth::Medium,
        { 
            AudioPin("Source In", 0, PinDataType::Raw)
        },
        { 
            AudioPin("Motion X", 0, PinDataType::CV),
            AudioPin("Motion Y", 1, PinDataType::CV),
            AudioPin("Amount", 2, PinDataType::CV),
            AudioPin("Trigger", 3, PinDataType::Gate)
        },
        {}
    );

    db["human_detector"] = ModulePinInfo(
        NodeWidth::Medium,
        { 
            AudioPin("Source In", 0, PinDataType::Raw)
        },
        { 
            AudioPin("X", 0, PinDataType::CV),
            AudioPin("Y", 1, PinDataType::CV),
            AudioPin("Width", 2, PinDataType::CV),
            AudioPin("Height", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate)
        },
        {}
    );

    // Object Detector (YOLOv3) - 1 input (Source ID) and 5 outputs (X,Y,Width,Height,Gate)
    db["object_detector"] = ModulePinInfo(
        NodeWidth::Medium,
        {
            AudioPin("Source In", 0, PinDataType::Raw)
        },
        {
            AudioPin("X", 0, PinDataType::CV),
            AudioPin("Y", 1, PinDataType::CV),
            AudioPin("Width", 2, PinDataType::CV),
            AudioPin("Height", 3, PinDataType::CV),
            AudioPin("Gate", 4, PinDataType::Gate)
        },
        {}
    );

    // Color Tracker: dynamic outputs (3 per color). Only declare input here.
    db["color_tracker"] = ModulePinInfo(
        NodeWidth::Exception, // custom node width with zoom
        {
            AudioPin("Source In", 0, PinDataType::Raw)
        },
        {},
        {}
    );

    // Pose Estimator: 15 keypoints x 2 coordinates = 30 output pins
    db["pose_estimator"] = ModulePinInfo();
    db["pose_estimator"].defaultWidth = NodeWidth::Exception; // Custom size with zoom support
    db["pose_estimator"].audioIns.emplace_back("Source In", 0, PinDataType::Raw);
    // Programmatically add all 30 output pins (15 keypoints x 2 coordinates)
    const std::vector<std::string> keypointNames = {
        "Head", "Neck", "R Shoulder", "R Elbow", "R Wrist",
        "L Shoulder", "L Elbow", "L Wrist", "R Hip", "R Knee",
        "R Ankle", "L Hip", "L Knee", "L Ankle", "Chest"
    };
    for (size_t i = 0; i < keypointNames.size(); ++i)
    {
        db["pose_estimator"].audioOuts.emplace_back(keypointNames[i] + " X", i * 2, PinDataType::CV);
        db["pose_estimator"].audioOuts.emplace_back(keypointNames[i] + " Y", i * 2 + 1, PinDataType::CV);
    }

    // Hand Tracker: 21 keypoints x 2 = 42 outs
    db["hand_tracker"] = ModulePinInfo();
    db["hand_tracker"].defaultWidth = NodeWidth::Exception;
    db["hand_tracker"].audioIns.emplace_back("Source In", 0, PinDataType::Raw);
    const char* handNames[21] = {
        "Wrist",
        "Thumb 1","Thumb 2","Thumb 3","Thumb 4",
        "Index 1","Index 2","Index 3","Index 4",
        "Middle 1","Middle 2","Middle 3","Middle 4",
        "Ring 1","Ring 2","Ring 3","Ring 4",
        "Pinky 1","Pinky 2","Pinky 3","Pinky 4"
    };
    for (int i=0;i<21;++i)
    {
        db["hand_tracker"].audioOuts.emplace_back(std::string(handNames[i]) + " X", i*2, PinDataType::CV);
        db["hand_tracker"].audioOuts.emplace_back(std::string(handNames[i]) + " Y", i*2+1, PinDataType::CV);
    }

    // Face Tracker: 70 * 2 = 140 outs
    db["face_tracker"] = ModulePinInfo();
    db["face_tracker"].defaultWidth = NodeWidth::Exception;
    db["face_tracker"].audioIns.emplace_back("Source In", 0, PinDataType::Raw);
    for (int i=0;i<70;++i)
    {
        std::string base = std::string("Pt ") + std::to_string(i+1);
        db["face_tracker"].audioOuts.emplace_back(base + " X", i*2, PinDataType::CV);
        db["face_tracker"].audioOuts.emplace_back(base + " Y", i*2+1, PinDataType::CV);
    }

    // Add aliases for nodes with underscore naming convention
    db["clock_divider"] = db["ClockDivider"];
    db["sequential_switch"] = db["SequentialSwitch"];
    db["s_and_h"] = db["s&h"];

    // Contour Detector: 1 input, 3 outputs
    db["contour_detector"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Source In", 0, PinDataType::Raw) },
        { AudioPin("Area", 0, PinDataType::CV), AudioPin("Complexity", 1, PinDataType::CV), AudioPin("Aspect Ratio", 2, PinDataType::CV) },
        {}
    );

    // Semantic Segmentation: 1 input, 4 outputs (Area, Center X, Center Y, Gate)
    db["semantic_segmentation"] = ModulePinInfo(
        NodeWidth::Medium,
        { AudioPin("Source In", 0, PinDataType::Raw) },
        { AudioPin("Area", 0, PinDataType::CV), AudioPin("Center X", 1, PinDataType::CV), AudioPin("Center Y", 2, PinDataType::CV), AudioPin("Gate", 3, PinDataType::Gate) },
        {}
    );

}





================================================================================
FILE: guides\IMGUI_NODE_DESIGN_GUIDE.md
================================================================================


# 📐 ImGui Node UI Design Guide

**Version**: 2.3.2  
**Last Updated**: 2025-10-24  
**Based on**: `imgui_demo.cpp` best practices + **official imnodes examples**

---

## 🎯 Purpose

This guide documents proven UI patterns for designing professional, consistent, and user-friendly node interfaces in our modular synth environment. All patterns are derived from `imgui_demo.cpp` and real-world refinement.

**Golden Rule**: *Every UI element must respect node boundaries and provide clear, immediate feedback to the user.*

---

## 📏 1. Node Layout & Structure

### 1.1 Item Width Management

**Rule**: Always respect the `itemWidth` parameter passed to `drawParametersInNode()`.

```cpp
void drawParametersInNode(float itemWidth, ...) override
{
    ImGui::PushItemWidth(itemWidth);
    
    // All controls here...
    
    ImGui::PopItemWidth();
}
```

**Why**: This ensures controls don't overflow node boundaries.

---

### 1.2 Section Separators (CRITICAL!)

**❌ NEVER USE** `ImGui::Separator()` or `ImGui::SeparatorText()` inside nodes!

These functions consume full available width and **extend beyond node boundaries**, creating visual glitches.

**✅ CORRECT APPROACH**:

```cpp
// Option 1: Simple text title + spacing
ImGui::Text("Section Name");
ImGui::Spacing();

// Option 2: Color-coded section title (preferred)
ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Section Name");
ImGui::Spacing();

// Option 3: Custom separator (advanced)
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 pos = ImGui::GetCursorScreenPos();
ImVec2 lineEnd = ImVec2(pos.x + itemWidth, pos.y);
drawList->AddLine(pos, lineEnd, IM_COL32(100, 100, 100, 255), 1.0f);
ImGui::Dummy(ImVec2(0, 1)); // Reserve space for line
ImGui::Spacing();
```

**Reference**: See `MIDIFadersModuleProcessor.cpp` lines 180-185 for working examples.

---

### 1.3 Vertical Spacing

**Best Practice**: Use `ImGui::Spacing()` liberally for visual breathing room.

```cpp
// Between major sections
ImGui::Spacing();
ImGui::Spacing();

// Between related controls
ImGui::Spacing();
```

**From imgui_demo.cpp**: Consistent spacing improves readability significantly.

---

## 🎨 2. Visual Feedback & Indicators

### 2.1 Color-Coded Modulation States

**Pattern**: Use distinct colors to show when parameters are under CV control.

```cpp
const bool isModulated = isParamModulated(paramId);

if (isModulated)
{
    // Cyan for CV modulation
    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
    ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
}

if (isModulated) ImGui::BeginDisabled();
// ... slider/control here ...
if (isModulated) ImGui::EndDisabled();

if (isModulated) ImGui::PopStyleColor(3);
```

**Color Scheme**:
- **Cyan** (0.4, 0.8, 1.0): Frequency/Pitch modulation
- **Orange** (1.0, 0.8, 0.4): Timbre/Waveform modulation
- **Magenta** (1.0, 0.4, 1.0): Amplitude/Level modulation
- **Green** (0.4, 1.0, 0.4): Filter/EQ modulation

**Reference**: `VCOModuleProcessor.h` lines 59-64, 151-155

---

### 2.2 Real-Time Meters & Displays

**Pattern**: Use `ImGui::ProgressBar()` for level meters with color coding.

```cpp
float level = lastOutputValues[0]->load();
float absLevel = std::abs(level);

// Color-coded by level
ImVec4 meterColor;
if (absLevel < 0.7f)
    meterColor = ImVec4(0.2f, 0.8f, 0.2f, 1.0f); // Green (safe)
else if (absLevel < 0.9f)
    meterColor = ImVec4(0.9f, 0.7f, 0.0f, 1.0f); // Yellow (hot)
else
    meterColor = ImVec4(0.9f, 0.2f, 0.2f, 1.0f); // Red (clipping!)

ImGui::PushStyleColor(ImGuiCol_PlotHistogram, meterColor);
ImGui::ProgressBar(absLevel, ImVec2(itemWidth, 0), "");
ImGui::PopStyleColor();

ImGui::SameLine(0, 5);
ImGui::Text("%.3f", level);
```

**Reference**: `VCOModuleProcessor.h` lines 202-213

---

### 2.3 Waveform/Data Visualization

**Pattern**: Use `ImGui::PlotLines()` for waveform previews.

```cpp
float waveformData[128];
// ... populate waveformData ...

ImGui::PlotLines(
    "##wavepreview",           // Hidden label (## prefix)
    waveformData,              // Data array
    128,                       // Array size
    0,                         // Values offset
    nullptr,                   // Overlay text
    -1.2f,                     // Scale min
    1.2f,                      // Scale max
    ImVec2(itemWidth, 80)      // Size
);
```

**From imgui_demo.cpp**: Lines 1982-1985, 2012-2013

**Reference**: `VCOModuleProcessor.h` lines 178-192

---

## 💡 3. Tooltips & Help System

### 3.1 HelpMarker Function (Standard)

**REQUIRED**: Implement this helper in every `drawParametersInNode()`:

```cpp
auto HelpMarker = [](const char* desc)
{
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::BeginItemTooltip())
    {
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
};
```

**From imgui_demo.cpp**: Lines 273-282

**Usage**:
```cpp
ImGui::SliderFloat("Frequency", &freq, 20.0f, 20000.0f);
HelpMarker("Sets the fundamental frequency.\nCan be modulated by CV input.");
```

---

### 3.2 Tooltip Best Practices

**Do**:
- ✅ Explain what the parameter does
- ✅ Mention CV modulation behavior
- ✅ Provide typical ranges or values
- ✅ Use `\n` for multi-line explanations

**Don't**:
- ❌ Write essays (keep under 3 lines)
- ❌ Repeat the obvious
- ❌ Forget to call `HelpMarker()` after EVERY control

**Reference**: `VCOModuleProcessor.h` lines 85, 175, 217

---

## 🎛️ 4. Control Patterns

### 4.1 Slider with Label Pattern

**Standard**:
```cpp
if (ImGui::SliderFloat("##paramId", &value, min, max, "%.1f", flags))
{
    if (!isModulated)
        *apvtsParam = value;
}
if (ImGui::IsItemDeactivatedAfterEdit())
    onModificationEnded();

ImGui::SameLine();
ImGui::Text("Parameter Name");
HelpMarker("Description here");
```

**Why separate label?**: Allows color-coding the text independently of the slider.

---

### 4.2 Quick Preset Buttons

**Pattern**: Provide common values as one-click buttons.

```cpp
ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(4, 4));
float btnWidth = (itemWidth - 12) / 4.0f;  // 4 buttons with spacing

if (ImGui::Button("A4", ImVec2(btnWidth, 0)))
{
    *frequencyParam = 440.0f;
    onModificationEnded();
}
if (ImGui::IsItemHovered())
    ImGui::SetTooltip("440 Hz (Concert A)");

ImGui::SameLine();
// ... more buttons ...

ImGui::PopStyleVar();
```

**Reference**: `VCOModuleProcessor.h` lines 103-140

---

### 4.3 Combo Box (Dropdown) Pattern

```cpp
const char* items[] = { "Option 1", "Option 2", "Option 3" };
int currentItem = 0;

if (ImGui::Combo("##comboId", &currentItem, items, IM_ARRAYSIZE(items)))
{
    *apvtsParam = currentItem;
}
if (ImGui::IsItemDeactivatedAfterEdit())
    onModificationEnded();

ImGui::SameLine();
ImGui::Text("Selector Name");
HelpMarker("Choose from available options");
```

---

## 🔄 5. Tables & Multi-Control Layouts

### 5.1 Table Flags (From MIDI Modules Experience)

**REQUIRED FLAGS**:
```cpp
ImGuiTableFlags flags = 
    ImGuiTableFlags_SizingFixedFit |    // Fixed column widths
    ImGuiTableFlags_NoHostExtendX |     // Don't extend beyond itemWidth
    ImGuiTableFlags_Borders |           // Show cell borders
    ImGuiTableFlags_RowBg;              // Alternating row colors

if (ImGui::BeginTable("##tableId", numColumns, flags))
{
    // Setup columns with FIXED width
    ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_WidthFixed, 120.0f);
    // ... content ...
    ImGui::EndTable();
}
```

**Critical**: ALL columns must use `ImGuiTableColumnFlags_WidthFixed` when using `NoHostExtendX`.

**Reference**: `MIDIFadersModuleProcessor.cpp` table implementation (lines ~400-500)

---

### 5.2 Button Grids

**Pattern**: Use calculated widths for perfect alignment.

```cpp
float spacing = 4.0f;
float btnWidth = (itemWidth - spacing * (numButtons - 1)) / numButtons;

ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(spacing, spacing));

for (int i = 0; i < numButtons; ++i)
{
    if (i > 0) ImGui::SameLine();
    
    ImGui::PushID(i);  // CRITICAL for unique IDs!
    if (ImGui::Button("Button", ImVec2(btnWidth, 0)))
    {
        // Action
    }
    ImGui::PopID();
}

ImGui::PopStyleVar();
```

---

## 🆔 6. ID Management

### 6.1 Unique IDs Rule

**Every widget must have a unique ImGui ID!**

**Methods**:

1. **Hidden Label Suffix** (`##`):
```cpp
ImGui::SliderFloat("##freq", &freq, ...);  // ID = "##freq"
ImGui::SameLine();
ImGui::Text("Frequency");  // Visible label separate
```

2. **Push/Pop ID Scope**:
```cpp
for (int i = 0; i < count; ++i)
{
    ImGui::PushID(i);
    ImGui::Button("Learn");  // Unique ID: "Learn/0", "Learn/1", etc.
    ImGui::PopID();
}
```

3. **String ID in Popups/Combos**:
```cpp
ImGui::OpenPopup("SavePreset##nodeId");  // Unique per node
```

**From imgui_demo.cpp**: ID management examples throughout, especially lines 1000-1200 (widgets section)

---

## 🎨 7. Custom Drawing (Advanced)

### 7.1 Circular Indicators (Jog Wheel Pattern)

```cpp
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 center = ImGui::GetCursorScreenPos();
center.x += itemWidth * 0.5f;
center.y += 80.0f;

float radius = 40.0f;

// Background circle
drawList->AddCircle(center, radius, IM_COL32(100, 100, 100, 255), 32, 2.0f);

// Indicator needle
float angle = value * 2.0f * M_PI;  // Convert value to radians
ImVec2 needleEnd(
    center.x + std::cos(angle - M_PI / 2.0f) * (radius - 5.0f),
    center.y + std::sin(angle - M_PI / 2.0f) * (radius - 5.0f)
);

drawList->AddLine(center, needleEnd, IM_COL32(100, 200, 255, 255), 3.0f);
drawList->AddCircleFilled(center, 4.0f, IM_COL32(100, 200, 255, 255));

ImGui::Dummy(ImVec2(itemWidth, 160));  // Reserve space
```

**Reference**: `MIDIJogWheelModuleProcessor.cpp` lines 310-340

---

### 7.2 Clipping Regions

**Pattern**: Constrain drawing to specific area.

```cpp
ImDrawList* drawList = ImGui::GetWindowDrawList();
ImVec2 pos = ImGui::GetCursorScreenPos();
ImVec2 size(itemWidth, 100);

drawList->PushClipRect(pos, ImVec2(pos.x + size.x, pos.y + size.y), true);
// ... drawing code ...
drawList->PopClipRect();
```

**From imgui_demo.cpp**: Lines 6800-6850 (custom rendering examples)

---

## 📦 8. Complete Node Template

```cpp
#if defined(PRESET_CREATOR_UI)
void drawParametersInNode(float itemWidth,
                          const std::function<bool(const juce::String&)>& isParamModulated,
                          const std::function<void()>& onModificationEnded) override
{
    // 1. HelpMarker helper
    auto HelpMarker = [](const char* desc)
    {
        ImGui::SameLine();
        ImGui::TextDisabled("(?)");
        if (ImGui::BeginItemTooltip())
        {
            ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
            ImGui::TextUnformatted(desc);
            ImGui::PopTextWrapPos();
            ImGui::EndTooltip();
        }
    };

    ImGui::PushItemWidth(itemWidth);

    // 2. Section 1: Main Controls
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Main Controls");
    ImGui::Spacing();
    
    // 3. Modulation-aware slider
    const bool isModulated = isParamModulated("param1");
    
    if (isModulated)
    {
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_SliderGrab, ImVec4(0.4f, 0.8f, 1.0f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.2f, 0.4f, 0.5f, 0.5f));
    }
    
    if (isModulated) ImGui::BeginDisabled();
    
    float param1 = param1Param->load();
    if (ImGui::SliderFloat("##param1", &param1, 0.0f, 1.0f))
    {
        if (!isModulated)
            *param1Param = param1;
    }
    if (ImGui::IsItemDeactivatedAfterEdit())
        onModificationEnded();
    
    if (isModulated) ImGui::EndDisabled();
    
    ImGui::SameLine();
    if (isModulated)
    {
        ImGui::TextColored(ImVec4(0.4f, 0.8f, 1.0f, 1.0f), "Parameter 1 (CV)");
        ImGui::PopStyleColor(3);
    }
    else
    {
        ImGui::Text("Parameter 1");
    }
    HelpMarker("This parameter does something important.\nRange: 0 to 1");

    ImGui::Spacing();
    ImGui::Spacing();

    // 4. Section 2: Visualization
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "Output");
    ImGui::Spacing();
    
    // 5. Real-time meter
    float level = lastOutputValues[0]->load();
    ImVec4 color = (std::abs(level) < 0.7f) 
        ? ImVec4(0.2f, 0.8f, 0.2f, 1.0f)   // Green
        : ImVec4(0.9f, 0.2f, 0.2f, 1.0f);  // Red
    
    ImGui::PushStyleColor(ImGuiCol_PlotHistogram, color);
    ImGui::ProgressBar(std::abs(level), ImVec2(itemWidth, 0), "");
    ImGui::PopStyleColor();
    
    ImGui::SameLine(0, 5);
    ImGui::Text("%.3f", level);
    HelpMarker("Current output level");

    ImGui::PopItemWidth();
}

void drawIoPins(const NodePinHelpers& helpers) override
{
    helpers.drawAudioInputPin("In", 0);
    helpers.drawAudioOutputPin("Out", 0);
}
#endif
```

---

## 🔌 8. Pin Label Spacing (CRITICAL!)

### 8.1 Output Pin Text Alignment

**Problem**: Default spacing between pin labels and pin circles creates visual disconnection.

**From imgui_demo.cpp**: Line 447 shows `ImGui::SameLine(0, 0)` for minimal spacing between elements.

**Best Practice**: Use `ImGui::Indent()` for right-alignment (IMNODES OFFICIAL PATTERN).

```cpp
// ✅ CORRECT: Use Indent() - this is how ALL imnodes examples do it!
// From: color_node_editor.cpp:353, save_load.cpp:77, multi_editor.cpp:73
auto rightLabelWithinWidth = [&](const char* txt, float nodeContentWidth)
{
    const ImVec2 textSize = ImGui::CalcTextSize(txt);
    
    // Indent by (nodeWidth - textWidth) to right-align
    // ImNodes uses Indent(), NOT Dummy() + SameLine()!
    const float indentAmount = juce::jmax(0.0f, nodeContentWidth - textSize.x);
    ImGui::Indent(indentAmount);
    ImGui::TextUnformatted(txt);
    ImGui::Unindent(indentAmount);  // CRITICAL: Reset indent!
};
```

**⚠️ CRITICAL**: Always call `Unindent()` to match `Indent()`! Indent is **persistent** and will affect all subsequent ImGui elements until reset.

**❌ WRONG**: Using Dummy() + SameLine() (imgui_demo.cpp pattern doesn't work for imnodes!)
```cpp
// BAD: This works in regular ImGui windows but NOT in imnodes!
// Causes layout issues and scrollbars in node contexts
ImGui::Dummy(ImVec2(dummyWidth, 0));
ImGui::SameLine(0, 0);
ImGui::TextUnformatted(txt);  // Wrong for imnodes!
```

**❌ WRONG**: Manual cursor positioning
```cpp
// BAD: SetCursorPosX() fights with ImNodes' internal layout
const float leftEdge = ImGui::GetCursorPosX();
ImGui::SetCursorPosX(leftEdge + nodeContentWidth - textWidth);  // Breaks!
```

**❌ WRONG**: GetContentRegionAvail() causes infinite scrollbars!
```cpp
// BAD: GetContentRegionAvail() changes as you add content!
// Creates feedback loop in fixed-size nodes
const float availWidth = ImGui::GetContentRegionAvail().x;
float x = cursorX + (availWidth - textWidth);  // Infinite scaling!
```

**Why `Indent()` is the Correct Pattern for ImNodes**:
- **Official ImNodes pattern**: Used in ALL official imnodes examples
- **Works with ImNodes layout**: Respects node padding and spacing
- **No side effects**: Doesn't trigger scrollbars or layout recalculation
- **Simple and clean**: Single function call, no SameLine() needed

**Example from Official ImNodes (color_node_editor.cpp:351-356)**:
```cpp
ImNodes::BeginOutputAttribute(node.id);
const float label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - label_width);  // ← This is the pattern!
ImGui::TextUnformatted("result");
ImNodes::EndOutputAttribute();
```

**Key Insight**: `Dummy()` is used in imnodes to SET node minimum width (line 425), NOT for text alignment!

**Reference**: `ImGuiNodeEditorComponent.cpp` lines 1976-1985

---

### 8.2 Output Pin Circle Positioning (CRITICAL!)

**Problem**: The pin circle itself can be positioned with an offset from the text, creating additional gap.

**❌ WRONG**: Adding offset to pin position
```cpp
const float PIN_CIRCLE_OFFSET = 8.0f;  // Creates 8px gap!
float x_pos = pinMax.x + PIN_CIRCLE_OFFSET;
attrPositions[attr] = ImVec2(x_pos, y_center);
```

**✅ CORRECT**: Zero offset - pin circle at text edge
```cpp
// Text is right-aligned to nodeContentWidth
// Pin circle positioned RIGHT at the edge
float x_pos = pinMax.x;  // No offset!
attrPositions[attr] = ImVec2(x_pos, y_center);
```

**Complete Flow**:
1. Text is right-aligned using `rightLabelWithinWidth` (0px padding)
2. `pinMax.x` captures the rightmost edge of the text area
3. Pin circle is positioned AT `pinMax.x` with no additional offset
4. Result: Pin circle touches text, which touches node border

**Reference**: `ImGuiNodeEditorComponent.cpp` lines 2175-2181, 2061-2067

---

### 8.3 SameLine Spacing Patterns

**From imgui_demo.cpp**:

```cpp
// Zero spacing (tight alignment)
ImGui::Text("Label");
ImGui::SameLine(0, 0);  // Second param = 0 removes extra spacing
ImGui::Button("Button");

// Small spacing (5px)
ImGui::ProgressBar(0.5f);
ImGui::SameLine(0, 5);  // 5px gap
ImGui::Text("50%%");

// Default spacing
ImGui::Checkbox("Option", &flag);
ImGui::SameLine();  // Uses style.ItemSpacing.x
HelpMarker("Tooltip text");
```

**Rule**: Use `SameLine(0, 0)` when you want elements visually "touching" (like pin labels to pins).

---

## 📦 9. ImNodes-Specific Patterns (FROM OFFICIAL EXAMPLES)

### 9.1 Node Content Width Management

**Pattern**: Use fixed widths, NOT GetContentRegionAvail()

```cpp
// From color_node_editor.cpp:314, 363, 415, 482
const float node_width = 100.0f;  // Fixed width for predictable layout
```

**Use Dummy() to set minimum width**:
```cpp
// From color_node_editor.cpp:425
ImGui::Dummy(ImVec2(node_width, 0.f));  // At START of node content
```

**Why Fixed Width**:
- Nodes don't resize dynamically like windows
- Prevents feedback loops and scrollbars
- All examples use hardcoded values (100.0f, 120.0f)

---

### 9.2 Input Attribute Pattern (Left Side)

**Structure**: Text first, then optional control

```cpp
// From color_node_editor.cpp:321-331
ImNodes::BeginInputAttribute(pin_id);
const float label_width = ImGui::CalcTextSize("left").x;
ImGui::TextUnformatted("left");

// If pin not connected, show input control
if (not_connected)
{
    ImGui::SameLine();
    ImGui::PushItemWidth(node_width - label_width);
    ImGui::DragFloat("##hidelabel", &value, 0.01f);
    ImGui::PopItemWidth();
}
ImNodes::EndInputAttribute();
```

**Key Points**:
- Label first, control after (if shown)
- Use `SameLine()` to put control next to label
- `PushItemWidth(node_width - label_width)` ensures control fits

---

### 9.3 Output Attribute Pattern (Right Side)

**Structure**: Indent first, text, then Unindent (NO SameLine!)

```cpp
// From color_node_editor.cpp:351-356 (with Unindent() added for persistence prevention)
ImNodes::BeginOutputAttribute(pin_id);
const float label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - label_width);  // ← Right-align!
ImGui::TextUnformatted("result");
ImGui::Unindent(node_width - label_width);  // ← Reset indent! CRITICAL!
ImNodes::EndOutputAttribute();
```

**Critical**: 
- Use `Indent()` for right-alignment, NOT Dummy() + SameLine()!
- **ALWAYS** call `Unindent()` to match `Indent()` - indent is persistent!

**Why Unindent() is Required**:
The imnodes examples work because they only have ONE output per node, so the indent doesn't affect anything else. In our multi-pin nodes, failing to unindent causes ALL subsequent elements to be indented cumulatively, creating the "red line" alignment bug where all text appears at the same wrong X position.

---

### 9.4 Static Attribute Pattern (No Pin)

**Structure**: For controls that don't connect to anything

```cpp
// From save_load.cpp:69-73, multi_editor.cpp:65-69
ImNodes::BeginStaticAttribute(attr_id);
ImGui::PushItemWidth(120.f);
ImGui::DragFloat("value", &value, 0.01f);
ImGui::PopItemWidth();
ImNodes::EndStaticAttribute();
```

**Use Cases**:
- Node settings/parameters
- Controls that affect node behavior
- UI elements without data flow

---

### 9.5 Node Layout Best Practices

**From ALL imnodes examples**:

1. **Title bar always first**:
```cpp
ImNodes::BeginNode(node_id);
ImNodes::BeginNodeTitleBar();
ImGui::TextUnformatted("node name");
ImNodes::EndNodeTitleBar();
// ... content ...
ImNodes::EndNode();
```

2. **Use Spacing() between sections**:
```cpp
// From color_node_editor.cpp:348, 400, 441, 458, 508
ImGui::Spacing();  // Visual separation
```

3. **Input pins before output pins**:
```cpp
// Input pins (left side)
ImNodes::BeginInputAttribute(...);
// Output pins (right side)  
ImNodes::BeginOutputAttribute(...);
```

4. **Calculate widths based on text**:
```cpp
const float label_width = ImGui::CalcTextSize("label").x;
```

---

### 9.6 Common Mistakes to Avoid

**❌ DON'T**: Forget to call Unindent() (CRITICAL BUG!)
```cpp
// BAD: Indent persists and affects all subsequent elements!
ImGui::Indent(node_width - text_width);
ImGui::Text("out");
// Missing Unindent() causes "red line" alignment bug!
```

**✅ DO**: Always match Indent() with Unindent()
```cpp
ImGui::Indent(node_width - text_width);
ImGui::Text("out");
ImGui::Unindent(node_width - text_width);  // CRITICAL!
```

**❌ DON'T**: Use Dummy() + SameLine() for output text
```cpp
// This is for ImGui windows, NOT imnodes!
ImGui::Dummy(ImVec2(width, 0));
ImGui::SameLine();
ImGui::Text("out");
```

**❌ DON'T**: Use GetContentRegionAvail() or -1 width in nodes
```cpp
float w = ImGui::GetContentRegionAvail().x;  // Causes scrollbars!
ImGui::ProgressBar(progress, ImVec2(-1, 0), "");  // -1 width also causes infinite scaling!
```

**✅ DO**: Use fixed widths from itemWidth parameter
```cpp
const float node_width = 240.0f;
ImGui::ProgressBar(progress, ImVec2(itemWidth, 0), "");  // Fixed width!
```

**Real-world bug**: MIDI Player initially used `ImVec2(-1, 0)` for progress bar, causing infinite right-side scaling. Fixed by using `ImVec2(itemWidth, 0)`.

**❌ DON'T**: Manually position with SetCursorPosX()
```cpp
ImGui::SetCursorPosX(x);  // Fights with ImNodes layout
```

**✅ DO**: Let ImNodes handle positioning with Indent()
```cpp
ImGui::Indent(amount);
```

---

### 9.7 Complete Node Example (From Official Examples)

```cpp
const float node_width = 100.0f;
ImNodes::BeginNode(node_id);

// Title
ImNodes::BeginNodeTitleBar();
ImGui::TextUnformatted("add");
ImNodes::EndNodeTitleBar();

// Input pin with optional control
ImNodes::BeginInputAttribute(input_id);
const float label_width = ImGui::CalcTextSize("left").x;
ImGui::TextUnformatted("left");
if (!is_connected)
{
    ImGui::SameLine();
    ImGui::PushItemWidth(node_width - label_width);
    ImGui::DragFloat("##hide", &value, 0.01f);
    ImGui::PopItemWidth();
}
ImNodes::EndInputAttribute();

ImGui::Spacing();  // Visual separation

// Output pin (right-aligned)
ImNodes::BeginOutputAttribute(output_id);
const float out_label_width = ImGui::CalcTextSize("result").x;
ImGui::Indent(node_width - out_label_width);
ImGui::TextUnformatted("result");
ImNodes::EndOutputAttribute();

ImNodes::EndNode();
```

**Reference**: color_node_editor.cpp:313-359, save_load.cpp:57-82, multi_editor.cpp:54-78

---

## ✅ 10. Pre-Flight Checklist

Before committing any node UI:

- [ ] No `ImGui::Separator()` or `ImGui::SeparatorText()` used
- [ ] All sections use `ImGui::TextColored()` + `ImGui::Spacing()`
- [ ] Every control has a `HelpMarker()` tooltip
- [ ] Modulated parameters have color-coding
- [ ] All tables use `NoHostExtendX` + `WidthFixed` columns
- [ ] Unique IDs for all widgets (check with `##` or `PushID()`)
- [ ] `ImGui::PushItemWidth(itemWidth)` at start
- [ ] `ImGui::PopItemWidth()` at end
- [ ] Real-time feedback where applicable (meters, plots)
- [ ] Output pins use `Indent()` for right-alignment (NOT Dummy() + SameLine!)
- [ ] Fixed node width used (NOT GetContentRegionAvail())
- [ ] Input pins: label first, control after with SameLine()
- [ ] Output pins: Indent() first, then text
- [ ] Tested with modulation connected and disconnected

---

## 📚 11. Reference Examples

**Best Implementations**:
1. **VCOModuleProcessor.h** (lines 28-220): Complete modern node with all patterns
2. **MIDIFadersModuleProcessor.cpp** (lines 180-600): Table layouts, learn modes
3. **MIDIJogWheelModuleProcessor.cpp** (lines 140-340): Custom drawing, circular indicators

**imgui_demo.cpp Sections**:
- Lines 273-282: HelpMarker implementation
- Lines 1982-2032: PlotLines examples
- Lines 3552-3555: TextColored usage
- Lines 6800-7000: Custom drawing with ImDrawList

**imnodes Official Examples** (H:\0000_CODE\01_collider_pyo\imnode_examples\):
- **hello.cpp**: Basic node structure (lines 17-32)
- **color_node_editor.cpp**: Complete node patterns
  - Fixed width pattern (lines 314, 363, 415, 482)
  - Input attribute with control (lines 321-331)
  - Output attribute with Indent() (lines 351-356)
  - Dummy() for minimum width (line 425)
- **save_load.cpp**: Simple node with static attribute (lines 57-82)
- **multi_editor.cpp**: Multi-context management (lines 54-78)

---

## 🔢 12. Multi-Voice & Collapsible UI Patterns

### 12.1 Collapsible Headers (For Polyphonic/Multi-Instance Modules)

When dealing with many similar controls (e.g., 32 voices in PolyVCO), use collapsible headers with proper state management.

**Pattern**:

```cpp
// Add Expand/Collapse All controls
static bool expandAllState = false;
static bool collapseAllState = false;

if (ImGui::SmallButton("Expand All")) {
    expandAllState = true;
}
ImGui::SameLine();
if (ImGui::SmallButton("Collapse All")) {
    collapseAllState = true;
}

ImGui::Spacing();

for (int i = 0; i < numVoices; ++i)
{
    ImGui::PushID(i);  // CRITICAL: Unique ID per iteration
    
    // CRITICAL: Use else-if to prevent SetNextItemOpen calls from overlapping
    if (expandAllState) {
        ImGui::SetNextItemOpen(true);
    }
    else if (collapseAllState) {
        ImGui::SetNextItemOpen(false);
    }
    else {
        // Default open state (first 4 only, on first use)
        ImGui::SetNextItemOpen(i < 4, ImGuiCond_Once);
    }
    
    // Color-code for visual distinction
    float hue = (float)i / (float)maxVoices;
    ImGui::PushStyleColor(ImGuiCol_Text, ImColor::HSV(hue, 0.7f, 1.0f).Value);
    
    if (ImGui::CollapsingHeader(("Voice " + juce::String(i+1)).toRawUTF8(),
                                ImGuiTreeNodeFlags_None))
    {
        ImGui::PopStyleColor();
        
        // Controls go here (see next section for table layout)
    }
    else
    {
        ImGui::PopStyleColor();
    }
    
    ImGui::PopID();
}

// Reset expand/collapse state after loop
expandAllState = false;
collapseAllState = false;
```

**Key Points**:
- `ImGui::PushID(i)` prevents ID conflicts between similar controls
- **CRITICAL**: Use `else-if` logic to prevent `SetNextItemOpen()` calls from overlapping! Only ONE call should execute per iteration
- `ImGuiCond_Once` ensures default state applies only on first use (but gets overwritten if not protected by else-if)
- **DO NOT** use `ImGuiTreeNodeFlags_SpanAvailWidth` or `ImGuiTreeNodeFlags_FramePadding` - they cause visual bleeding outside node bounds
- Use `ImGuiTreeNodeFlags_None` for clean, minimal headers in fixed-size nodes
- Color-coding helps distinguish voices at a glance

---

### 12.2 Table Layout Inside Collapsible Sections

For compact, multi-column layouts inside headers, use tables instead of Indent().

**Pattern**:

```cpp
if (ImGui::CollapsingHeader("Voice 1", ...))
{
    const float columnWidth = itemWidth / 3.0f;
    
    if (ImGui::BeginTable("voiceTable", 3,
                          ImGuiTableFlags_SizingFixedFit |
                          ImGuiTableFlags_NoBordersInBody,
                          ImVec2(itemWidth, 0)))
    {
        // Column 1
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);  // 8px padding
        ImGui::Combo("##wave", &wave, "Sine\0Saw\0Square\0\0");
        ImGui::TextUnformatted("Wave");
        ImGui::PopItemWidth();
        
        // Column 2
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);
        ImGui::SliderFloat("##freq", &freq, 20.0f, 20000.0f, "%.0f", 
                          ImGuiSliderFlags_Logarithmic);
        ImGui::TextUnformatted("Hz");
        ImGui::PopItemWidth();
        
        // Column 3
        ImGui::TableNextColumn();
        ImGui::PushItemWidth(columnWidth - 8.0f);
        ImGui::SliderFloat("##gate", &gate, 0.0f, 1.0f, "%.2f");
        ImGui::TextUnformatted("Gate");
        ImGui::PopItemWidth();
        
        ImGui::EndTable();
    }
}
```

**Why Tables**:
- Avoids cumulative Indent() bugs
- Provides consistent column widths
- Handles overflow better than manual layout
- **CRITICAL**: Don't use `ImGuiTableFlags_RowBg` with fixed-size tables in nodes! Row backgrounds can bleed outside node boundaries. Use plain tables with `NoBordersInBody` only.

---

### 12.3 Parallel Pin Drawing (Multi-Voice Nodes)

For nodes with multiple voices/channels, use `helpers.drawParallelPins()` to align inputs with outputs.

**Pattern**:

```cpp
void drawIoPins(const NodePinHelpers& helpers) override
{
    // Global input (no output pairing)
    helpers.drawParallelPins("NumVoices Mod", 0, nullptr, -1);
    
    for (int i = 0; i < getEffectiveNumVoices(); ++i)
    {
        juce::String idx = juce::String(i + 1);
        
        // Pair primary input with output on same row
        helpers.drawParallelPins(("Freq " + idx + " Mod").toRawUTF8(), 
                                 1 + i,
                                 ("Voice " + idx).toRawUTF8(), 
                                 i);
        
        // Secondary inputs (no output pairing)
        helpers.drawParallelPins(("Wave " + idx + " Mod").toRawUTF8(), 
                                 1 + MAX_VOICES + i, 
                                 nullptr, -1);
        helpers.drawParallelPins(("Gate " + idx + " Mod").toRawUTF8(), 
                                 1 + (2 * MAX_VOICES) + i, 
                                 nullptr, -1);
    }
}
```

**Why Parallel Pins**:
- Creates visual alignment between related inputs/outputs
- Reduces vertical node height
- Makes signal flow clearer
- Matches MultiSequencer pattern for consistency

**Signature**:
```cpp
void drawParallelPins(const char* inputLabel, int inputChannel,
                     const char* outputLabel, int outputChannel);
```

Pass `nullptr` and `-1` for outputLabel/outputChannel when there's no output on that row.

---

### 12.4 Complete Example: PolyVCO Node

See `juce/Source/audio/modules/PolyVCOModuleProcessor.cpp` for the complete, production-ready implementation featuring:
- Expand/Collapse All buttons
- Color-coded collapsible headers (HSV hue cycling)
- 3-column table layout for voice parameters
- Parallel pin drawing with 3 inputs per voice + 1 output
- Live modulation feedback with "(mod)" indicators
- First 4 voices open by default

---

## 🔄 13. Update Log

| Date | Version | Changes |
|------|---------|---------|
| 2025-10-24 | **2.3.2** | **🐛 DOUBLE CRITICAL FIX**: Fixed PolyVCO Expand/Collapse buttons + blue bleeding lines!<br>• **Problem 1**: Expand/Collapse All buttons didn't work<br>• **Root cause**: Multiple `SetNextItemOpen()` calls - last one wins! `ImGuiCond_Once` was overwriting button state<br>• **Solution**: Use `else-if` logic to ensure only ONE SetNextItemOpen call executes<br>• **Problem 2**: Blue lines from collapsing headers bleeding outside node<br>• **Root cause**: `ImGuiTreeNodeFlags_SpanAvailWidth` and `FramePadding` extend beyond bounds<br>• **Solution**: Use `ImGuiTreeNodeFlags_None` for minimal, clean headers<br>• Updated Section 12.1 with critical else-if pattern and flag warnings |
| 2025-10-24 | **2.3.1** | **🐛 CRITICAL FIX**: Removed `ImGuiTableFlags_RowBg` from PolyVCO tables!<br>• **Problem**: Blue row backgrounds were bleeding outside node boundaries<br>• **Root cause**: `RowBg` creates backgrounds that extend beyond fixed-size table constraints in nodes<br>• **Solution**: Use `SizingFixedFit + NoBordersInBody` WITHOUT `RowBg` flag<br>• Updated Section 12.2 with warning about RowBg in fixed-size nodes<br>• Based on imgui_demo.cpp analysis: RowBg is for scrollable/dynamic tables, not fixed-size property grids |
| 2025-10-24 | **2.3** | **🎯 NEW PATTERNS**: Multi-Voice & Collapsible UI!<br>• Added Section 12: Complete patterns for polyphonic nodes<br>• **12.1**: Collapsible headers with Expand/Collapse All<br>• **12.2**: Table-based layouts inside headers (avoids Indent bugs)<br>• **12.3**: Parallel pin drawing for multi-voice nodes<br>• **12.4**: PolyVCO as reference implementation<br>• Fixed PolyVCO node (32 voices, 3-column tables, parallel pins)<br>• Documented stable ID management and HSV color-coding |
| 2025-10-24 | **2.2** | **🚨 CRITICAL BUG FIX**: Documented `-1` width issue in ProgressBar!<br>• **Real-world bug**: MIDI Player used `ImVec2(-1, 0)` for progress bar width<br>• **Symptom**: Infinite right-side scaling, unusable node<br>• **Fix**: Use `ImVec2(itemWidth, 0)` with fixed width parameter<br>• Updated Section 9.6 with progress bar example<br>• Added warning about `-1` width alongside `GetContentRegionAvail()` issue |
| 2025-10-24 | **2.1** | **🚨 CRITICAL BUG FIX**: Added `Unindent()` to match every `Indent()` call!<br>• **Root cause**: Indent() is persistent and was affecting all subsequent elements<br>• **Symptom**: All output labels appeared at same X position ("red line" bug)<br>• **Fix**: Always call `ImGui::Unindent(amount)` after `ImGui::Indent(amount)`<br>• Updated Section 9.3 with Unindent() requirement<br>• Added new Common Mistake #1: Forgetting Unindent()<br>**Why imnodes examples didn't show this**: They only have ONE output per node! |
| 2025-10-24 | **2.0** | **🎯 MAJOR UPDATE**: Analyzed ALL official imnodes examples. Discovered `ImGui::Indent()` is the CORRECT pattern (NOT Dummy()!).<br>• Added comprehensive Section 9: ImNodes-Specific Patterns<br>• Documented input/output attribute patterns from official examples<br>• Added complete node example with all best practices<br>• Updated all code to use Indent() for output pin alignment<br>• Expanded reference section with imnodes examples<br>**Breaking insight**: imgui_demo.cpp patterns don't always apply to imnodes! |
| 2025-10-24 | 1.6 | ~~Dummy() + SameLine() approach~~ (WRONG for imnodes, fixed in v2.0) |
| 2025-10-24 | 1.5 | ~~Manual cursor positioning~~ (WRONG, fixed in v2.0) |
| 2025-10-24 | 1.4 | ~~GetContentRegionAvail()~~ (caused scrollbars, fixed in v2.0) |
| 2025-10-24 | 1.3 | **CRITICAL FIX**: Eliminated PIN_CIRCLE_OFFSET (was 8px). Added Section 8.2: Output Pin Circle Positioning. Pin circles now positioned at pinMax.x with zero offset for perfect node border alignment. |
| 2025-10-24 | 1.2 | Further reduced pin padding from 2px to 0px for maximum tightness. Updated all examples and checklist. |
| 2025-10-24 | 1.1 | Added Section 8: Pin Label Spacing (CRITICAL!). Fixed output pin text gap issue by reducing padding from 8px to 2px. Added SameLine spacing patterns from imgui_demo.cpp. |
| 2025-10-24 | 1.0 | Initial guide created. Added separator fix, color-coding patterns, tooltip system. |

---

## 📝 12. Contributing to This Guide

When you discover a new pattern or fix an issue:

1. Document it here with a clear example
2. Reference the source file and line numbers
3. Explain WHY this pattern is better
4. Add to the Pre-Flight Checklist if applicable
5. Update the version number and log

**This guide is a living document!** Update it after every successful node redesign.

---

**End of Guide** | Version 2.3.2 | 2025-10-24



================================================================================
FILE: guides\ADD_NEW_NODE_COMPREHENSIVE_GUIDE.md
================================================================================


# Complete Guide: Adding a New Node (Module) to All Menu Systems

## Overview

This guide documents **every location** where a new module needs to be registered to appear in all menu systems. We use the **Drive** node as a reference example throughout.

When adding a new module to the synthesizer, you need to register it in **8 different locations**:

1. **Module Processor Implementation** (C++ class files)
2. **Module Factory Registration** 
3. **Pin Database** (I/O pin definitions)
4. **Module Descriptions** (tooltip text)
5. **Left Panel Menu** (categorized buttons)
6. **Right-Click Context Menu** (Add Node at Mouse)
7. **Top Bar "Insert Between" Menu** (insert on selected node's cables)
8. **Insert on Cable(s) Menu** (right-click on cable)
9. **Search System** (fuzzy search and categorization)

---

## 1. Module Processor Implementation

First, create your module's processor files:

### File: `juce/Source/audio/modules/YourModuleProcessor.h`

```cpp
#pragma once

#include "ModuleProcessor.h"

class YourModuleProcessor : public ModuleProcessor
{
public:
    // Parameter IDs (use constexpr for consistency)
    static constexpr auto paramIdYourParam = "your_param";
    
    YourModuleProcessor();
    ~YourModuleProcessor() override = default;
    
    // CRITICAL: This name MUST match the factory registration key
    const juce::String getName() const override { return "your_module"; }
    
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override {}
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    
    juce::AudioProcessorValueTreeState& getAPVTS() override { return apvts; }
    
#if defined(PRESET_CREATOR_UI)
    void drawParametersInNode(float itemWidth, 
                              const std::function<bool(const juce::String& paramId)>& isParamModulated,
                              const std::function<void()>& onModificationEnded) override;
    void drawIoPins(const NodePinHelpers& helpers) override;
#endif
    
    bool getParamRouting(const juce::String& paramId, int& outBusIndex, 
                         int& outChannelIndexInBus) const override;
    juce::String getAudioInputLabel(int channel) const override;
    juce::String getAudioOutputLabel(int channel) const override;
    
private:
    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    
    juce::AudioProcessorValueTreeState apvts;
    
    // Your member variables here
};
```

### File: `juce/Source/audio/modules/YourModuleProcessor.cpp`

**Key Method - `getName()`:**

```cpp
const juce::String getName() const override { return "your_module"; }
```

⚠️ **CRITICAL**: The string returned by `getName()` **MUST** match:
- The factory registration key (step 2)
- The internal type name used in all menus
- The pin database key (step 3)

---

## 2. Module Factory Registration

**File:** `juce/Source/audio/graph/ModularSynthProcessor.cpp`

**Location:** Inside the `getModuleFactory()` function (~line 630-730)

**What to add:**

```cpp
// Inside getModuleFactory() function
auto& factory = getFactoryInstance();
if (!initialised)
{
    auto reg = [&](const juce::String& key, std::function<std::unique_ptr<juce::AudioProcessor>()> fn) {
        factory[key.toLowerCase()] = fn;
    };
    
    // ... existing registrations ...
    
    // ADD YOUR MODULE HERE:
    reg("your_module", []{ return std::make_unique<YourModuleProcessor>(); });
    
    initialised = true;
}
```

### Drive Example (line 705):

```cpp
reg("drive", []{ return std::make_unique<DriveModuleProcessor>(); });
```

### Important Notes:
- The key string (`"your_module"`) should be **lowercase with underscores** for spaces
- This key MUST match the string returned by `YourModuleProcessor::getName()`
- The factory uses a case-insensitive lookup, but lowercase is the convention

---

## 3. Pin Database (I/O Pin Definitions)

**File:** `juce/Source/preset_creator/PinDatabase.cpp`

**Location:** Inside the `populateModulePinDatabase()` function (~line 100-900)

**What to add:**

```cpp
// Inside populateModulePinDatabase()
db["your_module"] = ModulePinInfo(
    NodeWidth::Small,  // Options: Small, Medium, Big
    {  // Input pins
        AudioPin("In L", 0, PinDataType::Audio),
        AudioPin("In R", 1, PinDataType::Audio),
        AudioPin("Param Mod", 2, PinDataType::CV)  // Optional modulation inputs
    },
    {  // Output pins
        AudioPin("Out L", 0, PinDataType::Audio),
        AudioPin("Out R", 1, PinDataType::Audio)
    },
    {}  // Modulation outputs (leave empty unless you have mod outputs)
);
```

### Drive Example (lines 277-282):

```cpp
db["drive"] = ModulePinInfo(
    NodeWidth::Small,
    { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
    { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
    {}
);
```

### Pin Data Types:
- `PinDataType::Audio` - Audio signals
- `PinDataType::CV` - Control voltage (modulation)
- `PinDataType::Gate` - Triggers and gates
- `PinDataType::Mod` - Modulation outputs (e.g., from LFO)

### Node Widths:
- `NodeWidth::Small` - 2-channel I/O, simple processing
- `NodeWidth::Medium` - 3-4 channel I/O, moderate complexity
- `NodeWidth::Big` - 5+ channels, complex modules

---

## 4. Module Descriptions (Tooltips)

**File:** `juce/Source/preset_creator/PinDatabase.cpp`

**Location:** Inside the `populateModuleDescriptions()` function (~line 1-100)

**What to add:**

```cpp
// Inside populateModuleDescriptions()
void populateModuleDescriptions()
{
    auto& descriptions = getModuleDescriptions();
    if (!descriptions.empty()) return; // Only run once
    
    // ... existing descriptions ...
    
    // ADD YOUR MODULE DESCRIPTION:
    descriptions["your_module"] = "Brief description of what your module does.";
}
```

### Drive Example (line 39):

```cpp
descriptions["drive"] = "A waveshaping distortion effect.";
```

### Tips:
- Keep descriptions concise (one sentence)
- Describe the primary function
- These appear as tooltips in the UI

---

## 5. Left Panel Menu (Categorized Buttons)

**File:** `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Location:** Inside the `drawLeftPanel()` function (~line 1300-1550)

**What to add:**

Find the appropriate category section and add a button:

```cpp
// Find the correct category section, e.g., for Effects:
pushCategoryColor(ModuleCategory::Effect);
bool effectsExpanded = ImGui::CollapsingHeader("Effects", ImGuiTreeNodeFlags_DefaultOpen);
ImGui::PopStyleColor(3);
if (effectsExpanded) {
    // ... existing buttons ...
    
    // ADD YOUR BUTTON:
    addModuleButton("Your Module Display Name", "your_module");
}
```

### Drive Example (line 1475):

```cpp
// Inside the Effects section
addModuleButton("Drive", "drive");
```

### Available Categories:
- **Sources** - Oscillators, noise, inputs
- **Effects** - Audio effects and processors
- **Modulators** - LFOs, envelopes, etc.
- **Utilities & Logic** - Math, mixers, gates
- **Analysis** - Scopes, debug tools
- **Sequencers** - Step sequencers, MIDI
- **MIDI** - MIDI controllers and converters
- **Computer Vision** - OpenCV modules
- **Special** - Physics, animation, etc.

### Category Locations in Code:
- Sources: ~line 1360
- Sequencers: ~line 1390
- MIDI: ~line 1425
- Effects: ~line 1463 (Drive is here)
- Modulators: ~line 1484
- Utilities & Logic: ~line 1497
- Analysis: ~line 1518
- Computer Vision: ~line 1527
- Special: ~line 1539

---

## 6. Right-Click Context Menu (Add Node at Mouse)

**File:** `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Location:** Inside the context menu drawing code (~line 3400-3600)

**What to add:**

Find the appropriate submenu and add a menu item:

```cpp
// Inside the right-click context menu
if (ImGui::BeginMenu("Effects")) {
    // ... existing items ...
    
    // ADD YOUR MENU ITEM:
    if (ImGui::MenuItem("Your Module Display Name")) addAtMouse("your_module");
    
    ImGui::EndMenu();
}
```

### Drive Example (line 3480):

```cpp
if (ImGui::BeginMenu("Effects")) {
    // ... other effects ...
    if (ImGui::MenuItem("Drive")) addAtMouse("drive");
    // ... more effects ...
    ImGui::EndMenu();
}
```

### Available Submenus:
- Sources
- Sequencers
- MIDI
- Effects
- Modulators
- Utilities & Logic
- Analysis
- Computer Vision
- Special

---

## 7. Top Bar "Insert Between" Menu

**File:** `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Location:** Inside the top menu bar code (~line 690-740)

**What to add:**

This menu appears in the top bar and inserts a node between the selected node and all its outgoing connections.

```cpp
// Inside the "Insert Between" menu
if (ImGui::BeginMenu("Audio Path", isNodeSelected))
{
    // ... existing items ...
    
    // ADD YOUR MENU ITEM:
    if (ImGui::MenuItem("Your Module")) { insertNodeBetween("your_module"); }
    
    ImGui::EndMenu();
}
```

### Drive Example (line 703):

```cpp
if (ImGui::BeginMenu("Audio Path", isNodeSelected))
{
    // ... other modules ...
    if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }
    // ... more modules ...
    ImGui::EndMenu();
}
```

### Available Submenus:
- **Audio Path** (line ~692) - For audio processors
- **Modulation Path** (line ~721) - For CV/modulation processors

---

## 8. Insert on Cable(s) Menu

**File:** `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Location:** Inside the `drawInsertNodeOnLinkPopup()` function (~line 6200-6250)

**What to add:**

This menu appears when right-clicking on a cable or selecting multiple cables.

```cpp
void ImGuiNodeEditorComponent::drawInsertNodeOnLinkPopup()
{
    if (ImGui::BeginPopup("InsertNodeOnLinkPopup"))
    {
        // Find the appropriate map (audio or modulation)
        const std::map<const char*, const char*> audioInsertable = {
            // ... existing entries ...
            
            // ADD YOUR MODULE:
            {"Your Display Name", "your_module"},
        };
        
        // OR for modulation:
        const std::map<const char*, const char*> modInsertable = {
            {"Your Display Name", "your_module"},
        };
        
        // ... rest of function ...
    }
}
```

### Drive Example (line 6214):

```cpp
const std::map<const char*, const char*> audioInsertable = {
    {"VCF", "vcf"}, {"VCA", "vca"}, {"Delay", "delay"}, {"Reverb", "reverb"},
    {"Chorus", "chorus"}, {"Phaser", "phaser"}, {"Compressor", "compressor"},
    {"Recorder", "recorder"}, {"Limiter", "limiter"}, {"Gate", "gate"}, 
    {"Drive", "drive"},  // <-- Drive entry
    {"Graphic EQ", "graphic_eq"}, {"Waveshaper", "waveshaper"},
    // ... more entries ...
};
```

### Notes:
- Use `audioInsertable` for audio path modules
- Use `modInsertable` for CV/modulation path modules
- Format: `{"Display Name", "internal_type"}`

---

## 9. Search System

The search system has **three** components that need updating:

### 9.1. Search Database (Fuzzy Search)

**File:** `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Location:** Inside the search database initialization (~line 7150-7250)

**What to add:**

```cpp
// Inside the allModulesSearch map
static const std::map<const char*, std::pair<const char*, const char*>> allModulesSearch = {
    // ... existing entries ...
    
    // ADD YOUR MODULE:
    // Format: {"Display Name", {"internal_type", "description"}}
    {"Your Module", {"your_module", "Brief description for search results"}},
};
```

### Drive Example (line 7170):

```cpp
{"Drive", {"drive", "Distortion/overdrive"}},
```

### 9.2. Category Matcher (Color Coding)

**File:** `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp`

**Location:** Inside the `getModuleCategory()` function (~line 7050-7100)

**What to add:**

```cpp
ModuleCategory ImGuiNodeEditorComponent::getModuleCategory(const juce::String& moduleName)
{
    juce::String lower = moduleName.toLowerCase();
    
    // ... existing checks ...
    
    // --- Effects (Red) ---
    if (lower.contains("vcf") || lower.contains("delay") || 
        lower.contains("drive") ||  // <-- Drive is here
        lower.contains("your_keyword") ||  // ADD YOUR KEYWORD
        // ... more keywords ...
        )
        return ModuleCategory::Effect;
    
    // ... more categories ...
}
```

### Drive Example (line 7070):

```cpp
if (lower.contains("vcf") || lower.contains("delay") || 
    lower.contains("reverb") || lower.contains("chorus") || 
    lower.contains("phaser") || lower.contains("compressor") || 
    lower.contains("drive") || lower.contains("shaper") ||  // Drive is here
    lower.contains("filter") || lower.contains("waveshaper") ||
    // ... more keywords ...
    return ModuleCategory::Effect;
```

### Available Categories:
- `ModuleCategory::Source` - Green
- `ModuleCategory::Effect` - Red
- `ModuleCategory::Modulator` - Blue
- `ModuleCategory::Utility` - Orange
- `ModuleCategory::Analysis` - Purple
- `ModuleCategory::Comment` - Grey
- `ModuleCategory::Plugin` - Teal

---

## Complete Checklist for Adding a New Module

Use this checklist to ensure you've registered your module everywhere:

- [ ] **1. Module Processor Files Created**
  - [ ] `YourModuleProcessor.h` created
  - [ ] `YourModuleProcessor.cpp` created
  - [ ] `getName()` returns correct identifier
  - [ ] Includes added to relevant build files

- [ ] **2. Factory Registration** (`ModularSynthProcessor.cpp` ~line 705)
  - [ ] `reg("your_module", []{ return std::make_unique<YourModuleProcessor>(); });`

- [ ] **3. Pin Database** (`PinDatabase.cpp` ~line 277)
  - [ ] Input pins defined
  - [ ] Output pins defined
  - [ ] Node width set appropriately

- [ ] **4. Module Description** (`PinDatabase.cpp` ~line 39)
  - [ ] Tooltip description added

- [ ] **5. Left Panel Menu** (`ImGuiNodeEditorComponent.cpp` ~line 1475)
  - [ ] `addModuleButton("Display Name", "your_module");` added to correct category

- [ ] **6. Right-Click Menu** (`ImGuiNodeEditorComponent.cpp` ~line 3480)
  - [ ] `if (ImGui::MenuItem("Display Name")) addAtMouse("your_module");` added

- [ ] **7. Top Bar Insert Between Menu** (`ImGuiNodeEditorComponent.cpp` ~line 703)
  - [ ] `if (ImGui::MenuItem("Display Name")) { insertNodeBetween("your_module"); }` added

- [ ] **8. Insert on Cable Menu** (`ImGuiNodeEditorComponent.cpp` ~line 6214)
  - [ ] Entry added to `audioInsertable` or `modInsertable` map

- [ ] **9. Search System** (`ImGuiNodeEditorComponent.cpp`)
  - [ ] Search database entry added (~line 7170)
  - [ ] Category keyword added (~line 7070)

---

## Naming Conventions

### Internal Type Names (used in code):
- **Format:** lowercase with underscores
- **Examples:** `drive`, `graphic_eq`, `sample_loader`, `midi_player`
- **Used in:** Factory registration, `getName()`, pin database, all menu registrations

### Display Names (shown to users):
- **Format:** Title Case with spaces
- **Examples:** "Drive", "Graphic EQ", "Sample Loader", "MIDI Player"
- **Used in:** Menu items, buttons, search results

### Key Matching Rule:
```cpp
// In YourModuleProcessor.h
const juce::String getName() const override { return "your_module"; }  // Must match factory key

// In ModularSynthProcessor.cpp
reg("your_module", []{ return std::make_unique<YourModuleProcessor>(); });  // Must match getName()

// In PinDatabase.cpp
db["your_module"] = ModulePinInfo(...);  // Must match factory key
```

---

## Common Pitfalls

### ❌ Mistake 1: Inconsistent Naming
```cpp
// BAD - Different names in different places
getName() returns "YourModule"
Factory registered as "your_module"
Pin database uses "yourmodule"
```

✅ **Solution:** Use the exact same internal name everywhere (lowercase with underscores)

### ❌ Mistake 2: Missing from Search
```cpp
// BAD - Added to menus but not to search database
// User searches for "drive" and nothing appears
```

✅ **Solution:** Always add to all 3 search components (database, category, keywords)

### ❌ Mistake 3: Wrong Category in Left Panel
```cpp
// BAD - Drive module added to "Utilities" instead of "Effects"
// Users can't find it where they expect
```

✅ **Solution:** Choose the category that best matches the module's primary function

### ❌ Mistake 4: Forgetting Insert on Cable Menu
```cpp
// BAD - Can't insert the module on an existing cable
// Forces users to disconnect and reconnect manually
```

✅ **Solution:** Add to both top bar "Insert Between" AND right-click on cable menu

---

## Testing Your New Module

After adding your module, test that it appears in all locations:

1. **Left Panel**: Click the category, verify button appears
2. **Right-Click Empty Space**: Check "Add Node" submenu
3. **Top Bar Insert Between**: Select a node, check menu appears
4. **Right-Click Cable**: Right-click a cable, verify module in list
5. **Search**: Type module name in search box, verify it appears
6. **Factory**: Actually create the module and verify it loads
7. **Pin Database**: Verify pins appear correctly in the node
8. **Tooltip**: Hover over the module, verify description appears

---

## Example: Complete Registration for Drive Module

Here's a complete reference showing Drive in all 9 locations:

### 1. Module Files
- `juce/Source/audio/modules/DriveModuleProcessor.h`
- `juce/Source/audio/modules/DriveModuleProcessor.cpp`
- `getName()` returns `"drive"`

### 2. Factory (line 705)
```cpp
reg("drive", []{ return std::make_unique<DriveModuleProcessor>(); });
```

### 3. Pin Database (line 277)
```cpp
db["drive"] = ModulePinInfo(
    NodeWidth::Small,
    { AudioPin("In L", 0, PinDataType::Audio), AudioPin("In R", 1, PinDataType::Audio) },
    { AudioPin("Out L", 0, PinDataType::Audio), AudioPin("Out R", 1, PinDataType::Audio) },
    {}
);
```

### 4. Description (line 39)
```cpp
descriptions["drive"] = "A waveshaping distortion effect.";
```

### 5. Left Panel (line 1475)
```cpp
addModuleButton("Drive", "drive");  // In Effects section
```

### 6. Right-Click Menu (line 3480)
```cpp
if (ImGui::MenuItem("Drive")) addAtMouse("drive");  // In Effects submenu
```

### 7. Top Bar Insert Between (line 703)
```cpp
if (ImGui::MenuItem("Drive")) { insertNodeBetween("drive"); }  // In Audio Path
```

### 8. Insert on Cable (line 6214)
```cpp
{"Drive", "drive"},  // In audioInsertable map
```

### 9. Search System
- **Database** (line 7170): `{"Drive", {"drive", "Distortion/overdrive"}}`
- **Category** (line 7070): `lower.contains("drive")`

---

## Advanced: Auto-Connection Features

If you want to add a button in your module that auto-creates and connects other modules (like the "Build Drum Kit" button), see:

- **Guide:** `guides/STROKE_SEQUENCER_BUILD_DRUM_KIT_GUIDE.md`
- **Example:** StrokeSequencerModuleProcessor

### Quick Overview:
1. Add an `std::atomic<bool>` flag to your processor
2. Set the flag when button is clicked in `drawParametersInNode()`
3. Check the flag in `ImGuiNodeEditorComponent::checkForAutoConnectionRequests()`
4. Implement a handler function to create and connect modules

---

## Conclusion

Adding a new module requires updating **9 distinct locations** across **3 files**:

**Files to modify:**
1. `juce/Source/audio/modules/YourModuleProcessor.h` (new file)
2. `juce/Source/audio/modules/YourModuleProcessor.cpp` (new file)
3. `juce/Source/audio/graph/ModularSynthProcessor.cpp` (factory)
4. `juce/Source/preset_creator/PinDatabase.cpp` (pins + description)
5. `juce/Source/preset_creator/ImGuiNodeEditorComponent.cpp` (5 menu locations + search)

**Total edits needed:**
- 2 new files (module implementation)
- 1 factory registration
- 1 pin database entry
- 1 description
- 5 menu locations
- 3 search components

Follow this guide systematically and use the checklist to ensure your module appears everywhere users expect to find it!

---

**Last Updated:** October 30, 2025  
**Reference Module:** Drive (`DriveModuleProcessor`)  
**Author:** Collider Modular Synthesizer Project


